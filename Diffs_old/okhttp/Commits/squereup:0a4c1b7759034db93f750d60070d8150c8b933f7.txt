diff --git a/build.gradle b/build.gradle
index e490a1cbfa..df8b61124f 100644
--- a/build.gradle
+++ b/build.gradle
@@ -77,12 +77,12 @@ allprojects {
     google()
   }
 
-  task downloadDependencies() {
-    description 'Download all dependencies to the Gradle cache'
-    doLast {
-      configurations.findAll { it.canBeResolved }.files
-    }
-  }
+//  task downloadDependencies() {
+//    description 'Download all dependencies to the Gradle cache'
+//    doLast {
+//      configurations.findAll { it.canBeResolved }.files
+//    }
+//  }
 }
 
 subprojects { project ->
@@ -96,7 +96,6 @@ subprojects { project ->
   apply plugin: 'ru.vyarus.animalsniffer'
   apply plugin: 'net.ltgt.errorprone'
   apply plugin: 'org.jetbrains.dokka'
-  apply plugin: 'com.diffplug.gradle.spotless'
   sourceCompatibility = JavaVersion.VERSION_1_8
   targetCompatibility = JavaVersion.VERSION_1_8
 
@@ -118,12 +117,12 @@ subprojects { project ->
     signature 'org.codehaus.mojo.signature:java18:1.0@signature'
   }
 
-  spotless {
-    kotlin {
-      target "**/*.kt"
-      ktlint(versions.ktlint).userData(['indent_size': '2', 'continuation_indent_size': '2'])
-    }
-  }
+//  spotless {
+//    kotlin {
+//      target "**/*.kt"
+//      ktlint(versions.ktlint).userData(['indent_size': '2', 'continuation_indent_size': '2'])
+//    }
+//  }
 
   tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).configureEach {
     kotlinOptions {
diff --git a/okcurl/README.md b/okcurl/README.md
deleted file mode 100644
index 4c65202b11..0000000000
--- a/okcurl/README.md
+++ /dev/null
@@ -1,7 +0,0 @@
-OkCurl
-======
-
-_A curl for the next-generation web._
-
-OkCurl is an OkHttp-backed curl clone which allows you to test OkHttp's HTTP engine (including
-HTTP/2) against web servers.
diff --git a/okcurl/build.gradle b/okcurl/build.gradle
deleted file mode 100644
index 5ba959f92d..0000000000
--- a/okcurl/build.gradle
+++ /dev/null
@@ -1,37 +0,0 @@
-apply plugin: 'com.vanniktech.maven.publish'
-apply plugin: 'com.github.johnrengelman.shadow'
-
-jar {
-  manifest {
-    attributes 'Automatic-Module-Name': 'okhttp3.curl'
-    attributes 'Main-Class': 'okhttp3.curl.Main'
-  }
-}
-
-// resources-templates.
-sourceSets {
-  main.resources.srcDirs += "$buildDir/generated/resources-templates"
-}
-compileJava {
-  dependsOn 'copyResourcesTemplates'
-}
-task copyResourcesTemplates(type: Copy) {
-  from 'src/main/resources-templates'
-  into "$buildDir/generated/resources-templates"
-  expand('projectVersion': "$VERSION_NAME")
-  filteringCharset = 'UTF-8'
-}
-
-dependencies {
-  api project(':okhttp')
-  api project(':okhttp-logging-interceptor')
-  implementation deps.picocli
-  implementation deps.guava
-
-  testImplementation deps.junit
-  testImplementation deps.assertj
-}
-
-shadowJar {
-  mergeServiceFiles()
-}
diff --git a/okcurl/gradle.properties b/okcurl/gradle.properties
deleted file mode 100644
index ae701b79bd..0000000000
--- a/okcurl/gradle.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-POM_ARTIFACT_ID=okcurl
-POM_NAME=okcurl
-POM_PACKAGING=jar
diff --git a/okcurl/okcurl b/okcurl/okcurl
deleted file mode 100755
index 72d5ac525a..0000000000
--- a/okcurl/okcurl
+++ /dev/null
@@ -1,5 +0,0 @@
-#!/bin/sh -e
-
-../gradlew -q --console plain installDist
-
-./build/install/okcurl/bin/okcurl "$@"
diff --git a/okcurl/src/main/java/okhttp3/curl/Main.kt b/okcurl/src/main/java/okhttp3/curl/Main.kt
deleted file mode 100644
index 9a8f323d52..0000000000
--- a/okcurl/src/main/java/okhttp3/curl/Main.kt
+++ /dev/null
@@ -1,275 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.curl
-
-import okhttp3.MediaType
-import okhttp3.MediaType.Companion.toMediaTypeOrNull
-import okhttp3.OkHttpClient
-import okhttp3.Protocol
-import okhttp3.Request
-import okhttp3.RequestBody.Companion.toRequestBody
-import okhttp3.curl.Main.Companion.NAME
-import okhttp3.internal.format
-import okhttp3.internal.http.StatusLine
-import okhttp3.internal.http2.Http2
-import okhttp3.internal.platform.Platform
-import okhttp3.logging.HttpLoggingInterceptor
-import okhttp3.logging.LoggingEventListener
-import okio.sink
-import picocli.CommandLine
-import picocli.CommandLine.Command
-import picocli.CommandLine.IVersionProvider
-import picocli.CommandLine.Option
-import picocli.CommandLine.Parameters
-import java.io.IOException
-import java.security.cert.X509Certificate
-import java.util.Properties
-import java.util.concurrent.TimeUnit.SECONDS
-import java.util.logging.ConsoleHandler
-import java.util.logging.Level
-import java.util.logging.LogRecord
-import java.util.logging.Logger
-import java.util.logging.SimpleFormatter
-import javax.net.ssl.HostnameVerifier
-import javax.net.ssl.SSLSocketFactory
-import javax.net.ssl.TrustManager
-import javax.net.ssl.X509TrustManager
-import kotlin.system.exitProcess
-
-@Command(name = NAME, description = ["A curl for the next-generation web."],
-    mixinStandardHelpOptions = true, versionProvider = Main.VersionProvider::class)
-class Main : Runnable {
-  @Option(names = ["-X", "--request"], description = ["Specify request command to use"])
-  var method: String? = null
-
-  @Option(names = ["-d", "--data"], description = ["HTTP POST data"])
-  var data: String? = null
-
-  @Option(names = ["-H", "--header"], description = ["Custom header to pass to server"])
-  var headers: MutableList<String>? = null
-
-  @Option(names = ["-A", "--user-agent"], description = ["User-Agent to send to server"])
-  var userAgent = NAME + "/" + versionString()
-
-  @Option(names = ["--connect-timeout"],
-      description = ["Maximum time allowed for connection (seconds)"])
-  var connectTimeout = DEFAULT_TIMEOUT
-
-  @Option(names = ["--read-timeout"],
-      description = ["Maximum time allowed for reading data (seconds)"])
-  var readTimeout = DEFAULT_TIMEOUT
-
-  @Option(names = ["--call-timeout"],
-      description = ["Maximum time allowed for the entire call (seconds)"])
-  var callTimeout = DEFAULT_TIMEOUT
-
-  @Option(names = ["-L", "--location"], description = ["Follow redirects"])
-  var followRedirects: Boolean = false
-
-  @Option(names = ["-k", "--insecure"], description = ["Allow connections to SSL sites without certs"])
-  var allowInsecure: Boolean = false
-
-  @Option(names = ["-i", "--include"], description = ["Include protocol headers in the output"])
-  var showHeaders: Boolean = false
-
-  @Option(names = ["--frames"], description = ["Log HTTP/2 frames to STDERR"])
-  var showHttp2Frames: Boolean = false
-
-  @Option(names = ["-e", "--referer"], description = ["Referer URL"])
-  var referer: String? = null
-
-  @Option(names = ["-v", "--verbose"], description = ["Makes $NAME verbose during the operation"])
-  var verbose: Boolean = false
-
-  @Option(names = ["--completionScript"], hidden = true)
-  var completionScript: Boolean = false
-
-  @Parameters(paramLabel = "url", description = ["Remote resource URL"])
-  var url: String? = null
-
-  private lateinit var client: OkHttpClient
-
-  override fun run() {
-    if (completionScript) {
-      println(picocli.AutoComplete.bash("okcurl", CommandLine(Main())))
-      return
-    }
-
-    if (showHttp2Frames) {
-      enableHttp2FrameLogging()
-    }
-
-    client = createClient()
-    val request = createRequest()
-
-    try {
-      val response = client.newCall(request).execute()
-      if (showHeaders) {
-        println(StatusLine.get(response))
-        val headers = response.headers
-        for ((name, value) in headers) {
-          println("$name: $value")
-        }
-        println()
-      }
-
-      // Stream the response to the System.out as it is returned from the server.
-      val out = System.out.sink()
-      val source = response.body!!.source()
-      while (!source.exhausted()) {
-        out.write(source.buffer, source.buffer.size)
-        out.flush()
-      }
-
-      response.body!!.close()
-    } catch (e: IOException) {
-      e.printStackTrace()
-    } finally {
-      close()
-    }
-  }
-
-  private fun createClient(): OkHttpClient {
-    val builder = OkHttpClient.Builder()
-    builder.followSslRedirects(followRedirects)
-    if (connectTimeout != DEFAULT_TIMEOUT) {
-      builder.connectTimeout(connectTimeout.toLong(), SECONDS)
-    }
-    if (readTimeout != DEFAULT_TIMEOUT) {
-      builder.readTimeout(readTimeout.toLong(), SECONDS)
-    }
-    if (callTimeout != DEFAULT_TIMEOUT) {
-      builder.callTimeout(callTimeout.toLong(), SECONDS)
-    }
-    if (allowInsecure) {
-      val trustManager = createInsecureTrustManager()
-      val sslSocketFactory = createInsecureSslSocketFactory(trustManager)
-      builder.sslSocketFactory(sslSocketFactory, trustManager)
-      builder.hostnameVerifier(createInsecureHostnameVerifier())
-    }
-    if (verbose) {
-      val logger = object : HttpLoggingInterceptor.Logger {
-        override fun log(message: String) {
-          println(message)
-        }
-      }
-      builder.eventListenerFactory(LoggingEventListener.Factory(logger))
-    }
-    return builder.build()
-  }
-
-  public fun createRequest(): Request {
-    val request = Request.Builder()
-
-    val requestMethod = method ?: if (data != null) "POST" else "GET"
-
-    request.url(url!!)
-
-    data?.let {
-      request.method(requestMethod, it.toRequestBody(mediaType()))
-    }
-
-    for (header in headers.orEmpty()) {
-      val parts = header.split(':', limit = 2)
-      request.header(parts[0], parts[1])
-    }
-    referer?.let {
-      request.header("Referer", it)
-    }
-    request.header("User-Agent", userAgent)
-
-    return request.build()
-  }
-
-  private fun mediaType(): MediaType? {
-    val mimeType = headers?.let {
-      for (header in it) {
-        val parts = header.split(':', limit = 2)
-        if ("Content-Type".equals(parts[0], ignoreCase = true)) {
-          it.remove(header)
-          return@let parts[1].trim()
-        }
-      }
-      return@let null
-    } ?: "application/x-www-form-urlencoded"
-
-    return mimeType.toMediaTypeOrNull()
-  }
-
-  private fun close() {
-    client.connectionPool.evictAll() // Close any persistent connections.
-    client.dispatcher.executorService.shutdownNow()
-  }
-
-  class VersionProvider : IVersionProvider {
-    override fun getVersion(): Array<String> {
-      return arrayOf(
-          "$NAME ${versionString()}",
-          "Protocols: ${Protocol.values().joinToString(", ")}",
-          "Platform: ${Platform.get()::class.java.simpleName}"
-      )
-    }
-  }
-
-  companion object {
-    internal const val NAME = "okcurl"
-    internal const val DEFAULT_TIMEOUT = -1
-    private var frameLogger: Logger? = null
-
-    @JvmStatic
-    fun main(args: Array<String>) {
-      exitProcess(CommandLine(Main()).execute(*args))
-    }
-
-    private fun versionString(): String? {
-      val prop = Properties()
-      Main::class.java.getResourceAsStream("/okcurl-version.properties").use {
-        prop.load(it)
-      }
-      return prop.getProperty("version", "dev")
-    }
-
-    private fun createInsecureTrustManager(): X509TrustManager = object : X509TrustManager {
-      override fun checkClientTrusted(chain: Array<X509Certificate>, authType: String) {}
-
-      override fun checkServerTrusted(chain: Array<X509Certificate>, authType: String) {}
-
-      override fun getAcceptedIssuers(): Array<X509Certificate> = arrayOf()
-    }
-
-    private fun createInsecureSslSocketFactory(trustManager: TrustManager): SSLSocketFactory =
-        Platform.get().newSSLContext().apply {
-          init(null, arrayOf(trustManager), null)
-        }.socketFactory
-
-    private fun createInsecureHostnameVerifier(): HostnameVerifier =
-        HostnameVerifier { _, _ -> true }
-
-    private fun enableHttp2FrameLogging() {
-      frameLogger = Logger.getLogger(Http2::class.java.name).apply {
-        level = Level.FINE
-        addHandler(ConsoleHandler().apply {
-          level = Level.FINE
-          formatter = object : SimpleFormatter() {
-            override fun format(record: LogRecord): String {
-              return format("%s%n", record.message)
-            }
-          }
-        })
-      }
-    }
-  }
-}
diff --git a/okcurl/src/main/resources-templates/okcurl-version.properties b/okcurl/src/main/resources-templates/okcurl-version.properties
deleted file mode 100644
index a15427847c..0000000000
--- a/okcurl/src/main/resources-templates/okcurl-version.properties
+++ /dev/null
@@ -1 +0,0 @@
-version=${projectVersion}
diff --git a/okcurl/src/test/java/okhttp3/curl/MainTest.java b/okcurl/src/test/java/okhttp3/curl/MainTest.java
deleted file mode 100644
index 4eecbc938f..0000000000
--- a/okcurl/src/test/java/okhttp3/curl/MainTest.java
+++ /dev/null
@@ -1,113 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.curl;
-
-import java.io.IOException;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okio.Buffer;
-import org.junit.Test;
-import picocli.CommandLine;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class MainTest {
-  public static Main fromArgs(String... args) {
-    return CommandLine.populateCommand(new Main(), args);
-  }
-
-  @Test public void simple() {
-    Request request = fromArgs("http://example.com").createRequest();
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void put() throws IOException {
-    Request request = fromArgs("-X", "PUT", "-d", "foo", "http://example.com").createRequest();
-    assertThat(request.method()).isEqualTo("PUT");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/");
-    assertThat(request.body().contentLength()).isEqualTo(3);
-  }
-
-  @Test public void dataPost() {
-    Request request = fromArgs("-d", "foo", "http://example.com").createRequest();
-    RequestBody body = request.body();
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/");
-    assertThat(body.contentType().toString()).isEqualTo(
-        "application/x-www-form-urlencoded; charset=utf-8");
-    assertThat(bodyAsString(body)).isEqualTo("foo");
-  }
-
-  @Test public void dataPut() {
-    Request request = fromArgs("-d", "foo", "-X", "PUT", "http://example.com").createRequest();
-    RequestBody body = request.body();
-    assertThat(request.method()).isEqualTo("PUT");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/");
-    assertThat(body.contentType().toString()).isEqualTo(
-        "application/x-www-form-urlencoded; charset=utf-8");
-    assertThat(bodyAsString(body)).isEqualTo("foo");
-  }
-
-  @Test public void contentTypeHeader() {
-    Request request = fromArgs("-d", "foo", "-H", "Content-Type: application/json",
-        "http://example.com").createRequest();
-    RequestBody body = request.body();
-    assertThat(request.method()).isEqualTo("POST");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/");
-    assertThat(body.contentType().toString()).isEqualTo("application/json; charset=utf-8");
-    assertThat(bodyAsString(body)).isEqualTo("foo");
-  }
-
-  @Test public void referer() {
-    Request request = fromArgs("-e", "foo", "http://example.com").createRequest();
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/");
-    assertThat(request.header("Referer")).isEqualTo("foo");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void userAgent() {
-    Request request = fromArgs("-A", "foo", "http://example.com").createRequest();
-    assertThat(request.method()).isEqualTo("GET");
-    assertThat(request.url().toString()).isEqualTo("http://example.com/");
-    assertThat(request.header("User-Agent")).isEqualTo("foo");
-    assertThat(request.body()).isNull();
-  }
-
-  @Test public void defaultUserAgent() {
-    Request request = fromArgs("http://example.com").createRequest();
-    assertThat(request.header("User-Agent")).startsWith("okcurl/");
-  }
-
-  @Test public void headerSplitWithDate() {
-    Request request = fromArgs("-H", "If-Modified-Since: Mon, 18 Aug 2014 15:16:06 GMT",
-        "http://example.com").createRequest();
-    assertThat(request.header("If-Modified-Since")).isEqualTo(
-        "Mon, 18 Aug 2014 15:16:06 GMT");
-  }
-
-  private static String bodyAsString(RequestBody body) {
-    try {
-      Buffer buffer = new Buffer();
-      body.writeTo(buffer);
-      return buffer.readString(body.contentType().charset());
-    } catch (IOException e) {
-      throw new RuntimeException(e);
-    }
-  }
-}
diff --git a/okhttp-brotli/README.md b/okhttp-brotli/README.md
deleted file mode 100644
index 6ed3f15371..0000000000
--- a/okhttp-brotli/README.md
+++ /dev/null
@@ -1,20 +0,0 @@
-OkHttp Brotli Implementation
-============================
-
-This module is an implementation of [Brotli][1] compression.  
-It enables Brotli support in addition to tranparent Gzip support, 
-provided Accept-Encoding is not set previously.  Modern web servers
-must choose to return Brotli responses.  n.b. It is not used for
-sending requests.
-
-```java
-OkHttpClient client = new OkHttpClient.Builder()
-  .addInterceptor(BrotliInterceptor.INSTANCE)
-  .build();
-```
-
-```kotlin
-implementation("com.squareup.okhttp3:okhttp-brotli:4.2.1")
-```
-
- [1]: https://github.com/google/brotli
diff --git a/okhttp-brotli/build.gradle b/okhttp-brotli/build.gradle
deleted file mode 100644
index 0cff4929bf..0000000000
--- a/okhttp-brotli/build.gradle
+++ /dev/null
@@ -1,21 +0,0 @@
-apply plugin: 'com.vanniktech.maven.publish'
-
-jar {
-  manifest {
-    attributes('Automatic-Module-Name': 'okhttp3.brotli')
-  }
-}
-
-dependencies {
-  api project(':okhttp')
-  api deps.brotli
-  compileOnly deps.jsr305
-
-}
-
-afterEvaluate { project ->
-  project.tasks.dokka {
-    outputDirectory = "$rootDir/docs/4.x"
-    outputFormat = 'gfm'
-  }
-}
diff --git a/okhttp-brotli/gradle.properties b/okhttp-brotli/gradle.properties
deleted file mode 100644
index dc6217c482..0000000000
--- a/okhttp-brotli/gradle.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-POM_ARTIFACT_ID=okhttp-brotli
-POM_NAME=okhttp-brotli
-POM_PACKAGING=jar
diff --git a/okhttp-brotli/src/main/java/okhttp3/brotli/BrotliInterceptor.kt b/okhttp-brotli/src/main/java/okhttp3/brotli/BrotliInterceptor.kt
deleted file mode 100644
index ab4e18220e..0000000000
--- a/okhttp-brotli/src/main/java/okhttp3/brotli/BrotliInterceptor.kt
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.brotli
-
-import okhttp3.Interceptor
-import okhttp3.Response
-import okhttp3.ResponseBody.Companion.asResponseBody
-import okio.GzipSource
-import okio.buffer
-import okio.source
-import org.brotli.dec.BrotliInputStream
-
-/**
- * Transparent Brotli response support.
- *
- * Adds Accept-Encoding: br to request and checks (and strips) for Content-Encoding: br in
- * responses.  n.b. this replaces the transparent gzip compression in BridgeInterceptor.
- */
-object BrotliInterceptor : Interceptor {
-  override fun intercept(chain: Interceptor.Chain): Response =
-      if (chain.request().header("Accept-Encoding") == null) {
-        val request = chain.request().newBuilder()
-            .header("Accept-Encoding", "br,gzip")
-            .build()
-
-        val response = chain.proceed(request)
-
-        uncompress(response)
-      } else {
-        chain.proceed(chain.request())
-      }
-
-  internal fun uncompress(response: Response): Response {
-    val body = response.body ?: return response
-    val encoding = response.header("Content-Encoding") ?: return response
-
-    val decompressedSource = when {
-      encoding.equals("br", ignoreCase = true) ->
-        BrotliInputStream(body.source().inputStream()).source().buffer()
-      encoding.equals("gzip", ignoreCase = true) ->
-        GzipSource(body.source()).buffer()
-      else -> return response
-    }
-
-    return response.newBuilder()
-        .removeHeader("Content-Encoding")
-        .removeHeader("Content-Length")
-        .body(decompressedSource.asResponseBody(body.contentType(), -1))
-        .build()
-  }
-}
diff --git a/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliInterceptorJavaApiTest.java b/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliInterceptorJavaApiTest.java
deleted file mode 100644
index 9b0efd0b11..0000000000
--- a/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliInterceptorJavaApiTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.brotli;
-
-import org.junit.Ignore;
-import org.junit.Test;
-
-public class BrotliInterceptorJavaApiTest {
-  @Test @Ignore
-  public void testApi() {
-    BrotliInterceptor.INSTANCE.intercept(null);
-  }
-}
diff --git a/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliInterceptorTest.kt b/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliInterceptorTest.kt
deleted file mode 100644
index c4e16e6b9d..0000000000
--- a/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliInterceptorTest.kt
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.brotli
-
-import okhttp3.MediaType.Companion.toMediaType
-import okhttp3.Protocol
-import okhttp3.Request
-import okhttp3.Response
-import okhttp3.ResponseBody.Companion.toResponseBody
-import okio.ByteString
-import okio.ByteString.Companion.decodeHex
-import okio.ByteString.Companion.encodeUtf8
-import org.assertj.core.api.Assertions.assertThat
-import org.junit.Assert.fail
-import org.junit.Test
-import java.io.IOException
-
-class BrotliInterceptorTest {
-  @Test
-  fun testUncompressBrotli() {
-    val s =
-        "1bce00009c05ceb9f028d14e416230f718960a537b0922d2f7b6adef56532c08dff44551516690131494db" +
-            "6021c7e3616c82c1bc2416abb919aaa06e8d30d82cc2981c2f5c900bfb8ee29d5c03deb1c0dacff80e" +
-            "abe82ba64ed250a497162006824684db917963ecebe041b352a3e62d629cc97b95cac24265b175171e" +
-            "5cb384cd0912aeb5b5dd9555f2dd1a9b20688201"
-
-    val response = response("https://httpbin.org/brotli", s.decodeHex()) {
-      header("Content-Encoding", "br")
-    }
-
-    val uncompressed = BrotliInterceptor.uncompress(response)
-
-    val responseString = uncompressed.body?.string()
-    assertThat(responseString).contains("\"brotli\": true,")
-    assertThat(responseString).contains("\"Accept-Encoding\": \"br\"")
-  }
-
-  @Test
-  fun testUncompressGzip() {
-    val s =
-        "1f8b0800968f215d02ff558ec10e82301044ef7c45b3e75269d0c478e340e4a426e007086c4a636c9bb65e" +
-            "24fcbb5b484c3cec61deccecee9c3106eaa39dc3114e2cfa377296d8848f117d20369324500d03ba98" +
-            "d766b0a3368a0ce83d4f55581b14696c88894f31ba5e1b61bdfa79f7803eaf149a35619f29b3db0b29" +
-            "8abcbd54b7b6b97640c965bbfec238d9f4109ceb6edb01d66ba54d6247296441531e445970f627215b" +
-            "b22f1017320dd5000000"
-
-    val response = response("https://httpbin.org/gzip", s.decodeHex()) {
-      header("Content-Encoding", "gzip")
-    }
-
-    val uncompressed = BrotliInterceptor.uncompress(response)
-
-    val responseString = uncompressed.body?.string()
-    assertThat(responseString).contains("\"gzipped\": true,")
-    assertThat(responseString).contains("\"Accept-Encoding\": \"br,gzip\"")
-  }
-
-  @Test
-  fun testNoUncompress() {
-    val response = response("https://httpbin.org/brotli", "XXXX".encodeUtf8())
-
-    val same = BrotliInterceptor.uncompress(response)
-
-    val responseString = same.body?.string()
-    assertThat(responseString).isEqualTo("XXXX")
-  }
-
-  @Test
-  fun testFailsUncompress() {
-    val response = response("https://httpbin.org/brotli", "bb919aaa06e8".decodeHex()) {
-      header("Content-Encoding", "br")
-    }
-
-    try {
-      val failingResponse = BrotliInterceptor.uncompress(response)
-      failingResponse.body?.string()
-
-      fail("expected uncompress error")
-    } catch (ioe: IOException) {
-      assertThat(ioe).hasMessage("Brotli stream decoding failed")
-      assertThat(ioe.cause?.javaClass?.simpleName).isEqualTo("BrotliRuntimeException")
-    }
-  }
-
-  private fun response(
-    url: String,
-    bodyHex: ByteString,
-    fn: Response.Builder.() -> Unit = {}
-  ): Response {
-    return Response.Builder()
-        .body(bodyHex.toResponseBody("text/plain".toMediaType()))
-        .code(200)
-        .message("OK")
-        .request(Request.Builder().url(url).build())
-        .protocol(Protocol.HTTP_2)
-        .apply(fn)
-        .build()
-  }
-}
diff --git a/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliTestMain.kt b/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliTestMain.kt
deleted file mode 100644
index bfae423ee1..0000000000
--- a/okhttp-brotli/src/test/java/okhttp3/brotli/BrotliTestMain.kt
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.brotli
-
-import okhttp3.OkHttpClient
-import okhttp3.Request
-
-fun main() {
-  val client = OkHttpClient.Builder()
-      .addInterceptor(BrotliInterceptor)
-      .build()
-
-  sendRequest("https://httpbin.org/brotli", client)
-  sendRequest("https://httpbin.org/gzip", client)
-}
-
-private fun sendRequest(url: String, client: OkHttpClient) {
-  val req = Request.Builder().url(url).build()
-
-  client.newCall(req).execute().use {
-    println(it.body?.string())
-  }
-}
\ No newline at end of file
diff --git a/okhttp-dnsoverhttps/README.md b/okhttp-dnsoverhttps/README.md
deleted file mode 100644
index 638671f38b..0000000000
--- a/okhttp-dnsoverhttps/README.md
+++ /dev/null
@@ -1,11 +0,0 @@
-OkHttp DNS over HTTPS Implementation
-====================================
-
-This module is an experimental implementation of DNS over HTTPS using OkHttp.
-API is not considered stable and may change at any time.
-
-### Download
-
-```kotlin
-testImplementation("com.squareup.okhttp3:okhttp-dnsoverhttps:4.2.1")
-```
diff --git a/okhttp-dnsoverhttps/build.gradle b/okhttp-dnsoverhttps/build.gradle
deleted file mode 100644
index d40c4fce82..0000000000
--- a/okhttp-dnsoverhttps/build.gradle
+++ /dev/null
@@ -1,20 +0,0 @@
-apply plugin: 'com.vanniktech.maven.publish'
-
-jar {
-  manifest {
-    attributes('Automatic-Module-Name': 'okhttp3.dnsoverhttps')
-  }
-}
-
-dependencies {
-  api project(':okhttp')
-  compileOnly deps.jsr305
-
-}
-
-afterEvaluate { project ->
-  project.tasks.dokka {
-    outputDirectory = "$rootDir/docs/4.x"
-    outputFormat = 'gfm'
-  }
-}
diff --git a/okhttp-dnsoverhttps/gradle.properties b/okhttp-dnsoverhttps/gradle.properties
deleted file mode 100644
index bd908aaa26..0000000000
--- a/okhttp-dnsoverhttps/gradle.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-POM_ARTIFACT_ID=okhttp-dnsoverhttps
-POM_NAME=okhttp-dnsoverhttps
-POM_PACKAGING=jar
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/BootstrapDns.kt b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/BootstrapDns.kt
deleted file mode 100644
index 5523487838..0000000000
--- a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/BootstrapDns.kt
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.dnsoverhttps
-
-import okhttp3.Dns
-import java.net.InetAddress
-import java.net.UnknownHostException
-
-/**
- * Internal Bootstrap DNS implementation for handling initial connection to DNS over HTTPS server.
- *
- * Returns hardcoded results for the known host.
- */
-internal class BootstrapDns(
-  private val dnsHostname: String,
-  private val dnsServers: List<InetAddress>
-) : Dns {
-  @Throws(UnknownHostException::class)
-  override fun lookup(hostname: String): List<InetAddress> {
-    if (this.dnsHostname != hostname) {
-      throw UnknownHostException(
-          "BootstrapDns called for $hostname instead of $dnsHostname"
-      )
-    }
-
-    return dnsServers
-  }
-}
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.kt b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.kt
deleted file mode 100644
index e8a35ed0cf..0000000000
--- a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.kt
+++ /dev/null
@@ -1,319 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.dnsoverhttps
-
-import okhttp3.CacheControl
-import okhttp3.Call
-import okhttp3.Callback
-import okhttp3.Dns
-import okhttp3.HttpUrl
-import okhttp3.MediaType
-import okhttp3.MediaType.Companion.toMediaType
-import okhttp3.OkHttpClient
-import okhttp3.Protocol
-import okhttp3.Request
-import okhttp3.RequestBody.Companion.toRequestBody
-import okhttp3.Response
-import okhttp3.internal.platform.Platform
-import okhttp3.internal.publicsuffix.PublicSuffixDatabase
-import java.io.IOException
-import java.net.InetAddress
-import java.net.UnknownHostException
-import java.util.ArrayList
-import java.util.concurrent.CountDownLatch
-
-/**
- * [DNS over HTTPS implementation][doh_spec].
- *
- * > A DNS API client encodes a single DNS query into an HTTP request
- * > using either the HTTP GET or POST method and the other requirements
- * > of this section.  The DNS API server defines the URI used by the
- * > request through the use of a URI Template.
- *
- * ### Warning: This is a non-final API.
- *
- * As of OkHttp 3.14, this feature is an unstable preview: the API is subject to change, and the
- * implementation is incomplete. We expect that OkHttp 4.0 or 4.1 will finalize this API. Until
- * then, expect API and behavior changes when you update your OkHttp dependency.**
- *
- * [doh_spec]: https://tools.ietf.org/html/draft-ietf-doh-dns-over-https-13
- */
-class DnsOverHttps internal constructor(
-  @get:JvmName("client") val client: OkHttpClient,
-  @get:JvmName("url") val url: HttpUrl,
-  @get:JvmName("includeIPv6") val includeIPv6: Boolean,
-  @get:JvmName("post") val post: Boolean,
-  @get:JvmName("resolvePrivateAddresses") val resolvePrivateAddresses: Boolean,
-  @get:JvmName("resolvePublicAddresses") val resolvePublicAddresses: Boolean
-) : Dns {
-  @Throws(UnknownHostException::class)
-  override fun lookup(hostname: String): List<InetAddress> {
-    if (!resolvePrivateAddresses || !resolvePublicAddresses) {
-      val privateHost = isPrivateHost(hostname)
-
-      if (privateHost && !resolvePrivateAddresses) {
-        throw UnknownHostException("private hosts not resolved")
-      }
-
-      if (!privateHost && !resolvePublicAddresses) {
-        throw UnknownHostException("public hosts not resolved")
-      }
-    }
-
-    return lookupHttps(hostname)
-  }
-
-  @Throws(UnknownHostException::class)
-  private fun lookupHttps(hostname: String): List<InetAddress> {
-    val networkRequests = ArrayList<Call>(2)
-    val failures = ArrayList<Exception>(2)
-    val results = ArrayList<InetAddress>(5)
-
-    buildRequest(hostname, networkRequests, results, failures, DnsRecordCodec.TYPE_A)
-
-    if (includeIPv6) {
-      buildRequest(hostname, networkRequests, results, failures, DnsRecordCodec.TYPE_AAAA)
-    }
-
-    executeRequests(hostname, networkRequests, results, failures)
-
-    return if (results.isNotEmpty()) {
-      results
-    } else {
-      throwBestFailure(hostname, failures)
-    }
-  }
-
-  private fun buildRequest(
-    hostname: String,
-    networkRequests: MutableList<Call>,
-    results: MutableList<InetAddress>,
-    failures: MutableList<Exception>,
-    type: Int
-  ) {
-    val request = buildRequest(hostname, type)
-    val response = getCacheOnlyResponse(request)
-
-    response?.let { processResponse(it, hostname, results, failures) } ?: networkRequests.add(
-        client.newCall(request))
-  }
-
-  private fun executeRequests(
-    hostname: String,
-    networkRequests: List<Call>,
-    responses: MutableList<InetAddress>,
-    failures: MutableList<Exception>
-  ) {
-    val latch = CountDownLatch(networkRequests.size)
-
-    for (call in networkRequests) {
-      call.enqueue(object : Callback {
-        override fun onFailure(call: Call, e: IOException) {
-          synchronized(failures) {
-            failures.add(e)
-          }
-          latch.countDown()
-        }
-
-        override fun onResponse(call: Call, response: Response) {
-          processResponse(response, hostname, responses, failures)
-          latch.countDown()
-        }
-      })
-    }
-
-    try {
-      latch.await()
-    } catch (e: InterruptedException) {
-      failures.add(e)
-    }
-  }
-
-  private fun processResponse(
-    response: Response,
-    hostname: String,
-    results: MutableList<InetAddress>,
-    failures: MutableList<Exception>
-  ) {
-    try {
-      val addresses = readResponse(hostname, response)
-      synchronized(results) {
-        results.addAll(addresses)
-      }
-    } catch (e: Exception) {
-      synchronized(failures) {
-        failures.add(e)
-      }
-    }
-  }
-
-  @Throws(UnknownHostException::class)
-  private fun throwBestFailure(hostname: String, failures: List<Exception>): List<InetAddress> {
-    if (failures.isEmpty()) {
-      throw UnknownHostException(hostname)
-    }
-
-    val failure = failures[0]
-
-    if (failure is UnknownHostException) {
-      throw failure
-    }
-
-    val unknownHostException = UnknownHostException(hostname)
-    unknownHostException.initCause(failure)
-
-    for (i in 1 until failures.size) {
-      unknownHostException.addSuppressed(failures[i])
-    }
-
-    throw unknownHostException
-  }
-
-  private fun getCacheOnlyResponse(request: Request): Response? {
-    if (!post && client.cache != null) {
-      try {
-        val cacheRequest = request.newBuilder().cacheControl(CacheControl.FORCE_CACHE).build()
-
-        val cacheResponse = client.newCall(cacheRequest).execute()
-
-        if (cacheResponse.code != 504) {
-          return cacheResponse
-        }
-      } catch (ioe: IOException) {
-        // Failures are ignored as we can fallback to the network
-        // and hopefully repopulate the cache.
-      }
-    }
-
-    return null
-  }
-
-  @Throws(Exception::class)
-  private fun readResponse(hostname: String, response: Response): List<InetAddress> {
-    if (response.cacheResponse == null && response.protocol !== Protocol.HTTP_2) {
-      Platform.get().log("Incorrect protocol: ${response.protocol}", Platform.WARN)
-    }
-
-    response.use {
-      if (!response.isSuccessful) {
-        throw IOException("response: " + response.code + " " + response.message)
-      }
-
-      val body = response.body
-
-      if (body!!.contentLength() > MAX_RESPONSE_SIZE) {
-        throw IOException(
-            "response size exceeds limit ($MAX_RESPONSE_SIZE bytes): ${body.contentLength()} bytes"
-        )
-      }
-
-      val responseBytes = body.source().readByteString()
-
-      return DnsRecordCodec.decodeAnswers(hostname, responseBytes)
-    }
-  }
-
-  private fun buildRequest(hostname: String, type: Int): Request =
-      Request.Builder().header("Accept", DNS_MESSAGE.toString()).apply {
-        val query = DnsRecordCodec.encodeQuery(hostname, type)
-
-        if (post) {
-          url(url).post(query.toRequestBody(DNS_MESSAGE))
-        } else {
-          val encoded = query.base64Url().replace("=", "")
-          val requestUrl = url.newBuilder().addQueryParameter("dns", encoded).build()
-
-          url(requestUrl)
-        }
-      }.build()
-
-  class Builder {
-    internal var client: OkHttpClient? = null
-    internal var url: HttpUrl? = null
-    internal var includeIPv6 = true
-    internal var post = false
-    internal var systemDns = Dns.SYSTEM
-    internal var bootstrapDnsHosts: List<InetAddress>? = null
-    internal var resolvePrivateAddresses = false
-    internal var resolvePublicAddresses = true
-
-    fun build(): DnsOverHttps {
-      val client = this.client ?: throw NullPointerException("client not set")
-      return DnsOverHttps(
-          client.newBuilder().dns(buildBootstrapClient(this)).build(),
-          checkNotNull(url) { "url not set" },
-          includeIPv6,
-          post,
-          resolvePrivateAddresses,
-          resolvePublicAddresses
-      )
-    }
-
-    fun client(client: OkHttpClient) = apply {
-      this.client = client
-    }
-
-    fun url(url: HttpUrl) = apply {
-      this.url = url
-    }
-
-    fun includeIPv6(includeIPv6: Boolean) = apply {
-      this.includeIPv6 = includeIPv6
-    }
-
-    fun post(post: Boolean) = apply {
-      this.post = post
-    }
-
-    fun resolvePrivateAddresses(resolvePrivateAddresses: Boolean) = apply {
-      this.resolvePrivateAddresses = resolvePrivateAddresses
-    }
-
-    fun resolvePublicAddresses(resolvePublicAddresses: Boolean) = apply {
-      this.resolvePublicAddresses = resolvePublicAddresses
-    }
-
-    fun bootstrapDnsHosts(bootstrapDnsHosts: List<InetAddress>?) = apply {
-      this.bootstrapDnsHosts = bootstrapDnsHosts
-    }
-
-    fun bootstrapDnsHosts(vararg bootstrapDnsHosts: InetAddress): Builder =
-        bootstrapDnsHosts(bootstrapDnsHosts.toList())
-
-    fun systemDns(systemDns: Dns) = apply {
-      this.systemDns = systemDns
-    }
-  }
-
-  companion object {
-    val DNS_MESSAGE: MediaType = "application/dns-message".toMediaType()
-    const val MAX_RESPONSE_SIZE = 64 * 1024
-
-    private fun buildBootstrapClient(builder: Builder): Dns {
-      val hosts = builder.bootstrapDnsHosts
-
-      return if (hosts != null) {
-        BootstrapDns(builder.url!!.host, hosts)
-      } else {
-        builder.systemDns
-      }
-    }
-
-    internal fun isPrivateHost(host: String): Boolean {
-      return PublicSuffixDatabase.get().getEffectiveTldPlusOne(host) == null
-    }
-  }
-}
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.kt b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.kt
deleted file mode 100644
index ebf0d4a592..0000000000
--- a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.kt
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
- * Copyright 2016 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
- * "License"); you may not use this file except in compliance with the License. You may obtain a
- * copy of the License at:
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package okhttp3.dnsoverhttps
-
-import okio.Buffer
-import okio.ByteString
-import okio.utf8Size
-import java.io.EOFException
-import java.net.InetAddress
-import java.net.UnknownHostException
-import java.nio.charset.StandardCharsets
-
-/**
- * Trivial Dns Encoder/Decoder, basically ripped from Netty full implementation.
- */
-object DnsRecordCodec {
-  private const val SERVFAIL = 2
-  private const val NXDOMAIN = 3
-  const val TYPE_A = 0x0001
-  const val TYPE_AAAA = 0x001c
-  private const val TYPE_PTR = 0x000c
-  private val ASCII = StandardCharsets.US_ASCII
-
-  fun encodeQuery(host: String, type: Int): ByteString = Buffer().apply {
-    writeShort(0) // query id
-    writeShort(256) // flags with recursion
-    writeShort(1) // question count
-    writeShort(0) // answerCount
-    writeShort(0) // authorityResourceCount
-    writeShort(0) // additional
-
-    val nameBuf = Buffer()
-    val labels = host.split('.').dropLastWhile { it.isEmpty() }
-    for (label in labels) {
-      val utf8ByteCount = label.utf8Size()
-      require(utf8ByteCount == label.length.toLong()) { "non-ascii hostname: $host" }
-      nameBuf.writeByte(utf8ByteCount.toInt())
-      nameBuf.writeUtf8(label)
-    }
-    nameBuf.writeByte(0) // end
-
-    nameBuf.copyTo(this, 0, nameBuf.size)
-    writeShort(type)
-    writeShort(1) // CLASS_IN
-  }.readByteString()
-
-  @Throws(Exception::class)
-  fun decodeAnswers(hostname: String, byteString: ByteString): List<InetAddress> {
-    val result = mutableListOf<InetAddress>()
-
-    val buf = Buffer()
-    buf.write(byteString)
-    buf.readShort() // query id
-
-    val flags = buf.readShort().toInt() and 0xffff
-    require(flags shr 15 != 0) { "not a response" }
-
-    val responseCode = flags and 0xf
-
-    if (responseCode == NXDOMAIN) {
-      throw UnknownHostException("$hostname: NXDOMAIN")
-    } else if (responseCode == SERVFAIL) {
-      throw UnknownHostException("$hostname: SERVFAIL")
-    }
-
-    val questionCount = buf.readShort().toInt() and 0xffff
-    val answerCount = buf.readShort().toInt() and 0xffff
-    buf.readShort() // authority record count
-    buf.readShort() // additional record count
-
-    for (i in 0 until questionCount) {
-      skipName(buf) // name
-      buf.readShort() // type
-      buf.readShort() // class
-    }
-
-    for (i in 0 until answerCount) {
-      skipName(buf) // name
-
-      val type = buf.readShort().toInt() and 0xffff
-      buf.readShort() // class
-      @Suppress("UNUSED_VARIABLE") val ttl = buf.readInt().toLong() and 0xffffffffL // ttl
-      val length = buf.readShort().toInt() and 0xffff
-
-      if (type == TYPE_A || type == TYPE_AAAA) {
-        val bytes = ByteArray(length)
-        buf.read(bytes)
-        result.add(InetAddress.getByAddress(bytes))
-      } else {
-        buf.skip(length.toLong())
-      }
-    }
-
-    return result
-  }
-
-  @Throws(EOFException::class)
-  private fun skipName(source: Buffer) {
-    // 0 - 63 bytes
-    var length = source.readByte().toInt()
-
-    if (length < 0) {
-      // compressed name pointer, first two bits are 1
-      // drop second byte of compression offset
-      source.skip(1)
-    } else {
-      while (length > 0) {
-        // skip each part of the domain name
-        source.skip(length.toLong())
-        length = source.readByte().toInt()
-      }
-    }
-  }
-}
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.kt b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.kt
deleted file mode 100644
index b998f5b899..0000000000
--- a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.kt
+++ /dev/null
@@ -1,2 +0,0 @@
-/** A DNS over HTTPS implementation for OkHttp. */
-package okhttp3.dnsoverhttps
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsOverHttpsTest.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsOverHttpsTest.java
deleted file mode 100644
index 8b750f018c..0000000000
--- a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsOverHttpsTest.java
+++ /dev/null
@@ -1,203 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.dnsoverhttps;
-
-import java.io.EOFException;
-import java.io.File;
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.Arrays;
-import java.util.List;
-import okhttp3.Cache;
-import okhttp3.Dns;
-import okhttp3.HttpUrl;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okio.Buffer;
-import okio.ByteString;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static java.util.Arrays.asList;
-import static java.util.Collections.singletonList;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public class DnsOverHttpsTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private final OkHttpClient bootstrapClient =
-      new OkHttpClient.Builder().protocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1)).build();
-  private Dns dns = buildLocalhost(bootstrapClient, false);
-
-  @Before public void setUp() {
-    server.setProtocols(bootstrapClient.protocols());
-  }
-
-  @Test public void getOne() throws Exception {
-    server.enqueue(dnsResponse(
-        "0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010001c00c00050001"
-            + "00000a6d000603617069c012c0300005000100000cde000c04737461720463313072c012c04200010"
-            + "0010000003b00049df00112"));
-
-    List<InetAddress> result = dns.lookup("google.com");
-
-    assertThat(result).isEqualTo(singletonList(address("157.240.1.18")));
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo("GET");
-    assertThat(recordedRequest.getPath()).isEqualTo(
-        "/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ");
-  }
-
-  @Test public void getIpv6() throws Exception {
-    server.enqueue(dnsResponse(
-        "0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010001c00c00050001"
-            + "00000a6d000603617069c012c0300005000100000cde000c04737461720463313072c012c04200010"
-            + "0010000003b00049df00112"));
-    server.enqueue(dnsResponse(
-        "0000818000010003000000000567726170680866616365626f6f6b03636f6d00001c0001c00c00050001"
-            + "00000a1b000603617069c012c0300005000100000b1f000c04737461720463313072c012c042001c0"
-            + "0010000003b00102a032880f0290011faceb00c00000002"));
-
-    dns = buildLocalhost(bootstrapClient, true);
-
-    List<InetAddress> result = dns.lookup("google.com");
-
-    assertThat(result.size()).isEqualTo(2);
-    assertThat(result).contains(address("157.240.1.18"));
-    assertThat(result).contains(address("2a03:2880:f029:11:face:b00c:0:2"));
-
-    RecordedRequest request1 = server.takeRequest();
-    assertThat(request1.getMethod()).isEqualTo("GET");
-
-    RecordedRequest request2 = server.takeRequest();
-    assertThat(request2.getMethod()).isEqualTo("GET");
-
-    assertThat(asList(request1.getPath(), request2.getPath())).containsExactlyInAnyOrder(
-        "/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ",
-        "/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AABwAAQ");
-  }
-
-  @Test public void failure() throws Exception {
-    server.enqueue(dnsResponse(
-        "0000818300010000000100000e7364666c6b686673646c6b6a64660265650000010001c01b00060001"
-            + "000007070038026e7303746c64c01b0a686f73746d61737465720d6565737469696e7465726e657"
-            + "4c01b5adb12c100000e10000003840012750000000e10"));
-
-    try {
-      dns.lookup("google.com");
-      fail();
-    } catch (UnknownHostException uhe) {
-      uhe.printStackTrace();
-      assertThat(uhe.getMessage()).isEqualTo("google.com: NXDOMAIN");
-    }
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo("GET");
-    assertThat(recordedRequest.getPath()).isEqualTo(
-        "/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ");
-  }
-
-  @Test public void failOnExcessiveResponse() {
-    char[] array = new char[128 * 1024 + 2];
-    Arrays.fill(array, '0');
-    server.enqueue(dnsResponse(new String(array)));
-
-    try {
-      dns.lookup("google.com");
-      fail();
-    } catch (IOException ioe) {
-      assertThat(ioe.getMessage()).isEqualTo("google.com");
-      Throwable cause = ioe.getCause();
-      assertThat(cause).isInstanceOf(IOException.class);
-      assertThat(cause).hasMessage("response size exceeds limit (65536 bytes): 65537 bytes");
-    }
-  }
-
-  @Test public void failOnBadResponse() {
-    server.enqueue(dnsResponse("00"));
-
-    try {
-      dns.lookup("google.com");
-      fail();
-    } catch (IOException ioe) {
-      assertThat(ioe).hasMessage("google.com");
-      assertThat(ioe.getCause()).isInstanceOf(EOFException.class);
-    }
-  }
-
-  // TODO GET preferred order - with tests to confirm this
-  // 1. successful fresh cached GET response
-  // 2. unsuccessful (404, 500) fresh cached GET response
-  // 3. successful network response
-  // 4. successful stale cached GET response
-  // 5. unsuccessful response
-
-  // TODO how closely to follow POST rules on caching?
-
-  @Test public void usesCache() throws Exception {
-    Cache cache = new Cache(new File("./target/DnsOverHttpsTest.cache"), 100 * 1024);
-    OkHttpClient cachedClient = bootstrapClient.newBuilder().cache(cache).build();
-    DnsOverHttps cachedDns = buildLocalhost(cachedClient, false);
-
-    server.enqueue(dnsResponse(
-        "0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010001c00c00050001"
-            + "00000a6d000603617069c012c0300005000100000cde000c04737461720463313072c012c04200010"
-            + "0010000003b00049df00112").setHeader("cache-control", "private, max-age=298"));
-
-    List<InetAddress> result = cachedDns.lookup("google.com");
-
-    assertThat(result).containsExactly(address("157.240.1.18"));
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo("GET");
-    assertThat(recordedRequest.getPath()).isEqualTo(
-        "/lookup?ct&dns=AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ");
-
-    result = cachedDns.lookup("google.com");
-    assertThat(result).isEqualTo(singletonList(address("157.240.1.18")));
-  }
-
-  private MockResponse dnsResponse(String s) {
-    return new MockResponse().setBody(new Buffer().write(ByteString.decodeHex(s)))
-        .addHeader("content-type", "application/dns-message")
-        .addHeader("content-length", s.length() / 2);
-  }
-
-  private DnsOverHttps buildLocalhost(OkHttpClient bootstrapClient, boolean includeIPv6) {
-    HttpUrl url = server.url("/lookup?ct");
-    return new DnsOverHttps.Builder().client(bootstrapClient)
-        .includeIPv6(includeIPv6)
-        .resolvePrivateAddresses(true)
-        .url(url)
-        .build();
-  }
-
-  private static InetAddress address(String host) {
-    try {
-      return InetAddress.getByName(host);
-    } catch (UnknownHostException e) {
-      // impossible for IP addresses
-      throw new RuntimeException(e);
-    }
-  }
-}
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java
deleted file mode 100644
index 88e1bb3aad..0000000000
--- a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.dnsoverhttps;
-
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.List;
-import okio.ByteString;
-import org.junit.Test;
-
-import static okhttp3.dnsoverhttps.DnsRecordCodec.TYPE_A;
-import static okhttp3.dnsoverhttps.DnsRecordCodec.TYPE_AAAA;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public class DnsRecordCodecTest {
-  @Test public void testGoogleDotComEncoding() {
-    String encoded = encodeQuery("google.com", TYPE_A);
-
-    assertThat(encoded).isEqualTo("AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ");
-  }
-
-  private String encodeQuery(String host, int type) {
-    return DnsRecordCodec.INSTANCE.encodeQuery(host, type).base64Url().replace("=", "");
-  }
-
-  @Test public void testGoogleDotComEncodingWithIPv6() {
-    String encoded = encodeQuery("google.com", TYPE_AAAA);
-
-    assertThat(encoded).isEqualTo("AAABAAABAAAAAAAABmdvb2dsZQNjb20AABwAAQ");
-  }
-
-  @Test public void testGoogleDotComDecodingFromCloudflare() throws Exception {
-    List<InetAddress> encoded = DnsRecordCodec.INSTANCE.decodeAnswers("test.com",
-        ByteString.decodeHex("00008180000100010000000006676f6f676c6503636f6d0000010001c00c000100010"
-            + "00000430004d83ad54e"));
-
-    assertThat(encoded).containsExactly(InetAddress.getByName("216.58.213.78"));
-  }
-
-  @Test public void testGoogleDotComDecodingFromGoogle() throws Exception {
-    List<InetAddress> decoded = DnsRecordCodec.INSTANCE.decodeAnswers("test.com",
-        ByteString.decodeHex("0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010"
-            + "001c00c0005000100000a6d000603617069c012c0300005000100000cde000c04737461720463313072c"
-            + "012c042000100010000003b00049df00112"));
-
-    assertThat(decoded).containsExactly(InetAddress.getByName("157.240.1.18"));
-  }
-
-  @Test public void testGoogleDotComDecodingFromGoogleIPv6() throws Exception {
-    List<InetAddress> decoded = DnsRecordCodec.INSTANCE.decodeAnswers("test.com",
-        ByteString.decodeHex("0000818000010003000000000567726170680866616365626f6f6b03636f6d00001c0"
-            + "001c00c0005000100000a1b000603617069c012c0300005000100000b1f000c04737461720463313072c"
-            + "012c042001c00010000003b00102a032880f0290011faceb00c00000002"));
-
-    assertThat(decoded).containsExactly(InetAddress.getByName("2a03:2880:f029:11:face:b00c:0:2"));
-  }
-
-  @Test public void testGoogleDotComDecodingNxdomainFailure() throws Exception {
-    try {
-      DnsRecordCodec.INSTANCE.decodeAnswers("sdflkhfsdlkjdf.ee", ByteString.decodeHex("000081830001"
-          + "0000000100000e7364666c6b686673646c6b6a64660265650000010001c01b00060001000007070038026e"
-          + "7303746c64c01b0a686f73746d61737465720d6565737469696e7465726e6574c01b5adb12c100000e1000"
-          + "0003840012750000000e10"));
-      fail();
-    } catch (UnknownHostException uhe) {
-      assertThat(uhe.getMessage()).isEqualTo("sdflkhfsdlkjdf.ee: NXDOMAIN");
-    }
-  }
-}
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DohProviders.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DohProviders.java
deleted file mode 100644
index 301eee57ca..0000000000
--- a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DohProviders.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.dnsoverhttps;
-
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.ArrayList;
-import java.util.List;
-import okhttp3.HttpUrl;
-import okhttp3.OkHttpClient;
-
-/**
- * Temporary registry of known DNS over HTTPS providers.
- *
- * https://github.com/curl/curl/wiki/DNS-over-HTTPS
- */
-public class DohProviders {
-  static DnsOverHttps buildGoogle(OkHttpClient bootstrapClient) {
-    return new DnsOverHttps.Builder().client(bootstrapClient)
-        .url(HttpUrl.get("https://dns.google.com/experimental"))
-        .bootstrapDnsHosts(getByIp("216.58.204.78"), getByIp("2a00:1450:4009:814:0:0:0:200e"))
-        .build();
-  }
-
-  static DnsOverHttps buildGooglePost(OkHttpClient bootstrapClient) {
-    return new DnsOverHttps.Builder().client(bootstrapClient)
-        .url(HttpUrl.get("https://dns.google.com/experimental"))
-        .bootstrapDnsHosts(getByIp("216.58.204.78"), getByIp("2a00:1450:4009:814:0:0:0:200e"))
-        .post(true)
-        .build();
-  }
-
-  static DnsOverHttps buildCloudflareIp(OkHttpClient bootstrapClient) {
-    return new DnsOverHttps.Builder().client(bootstrapClient)
-        .url(HttpUrl.get("https://1.1.1.1/dns-query"))
-        .includeIPv6(false)
-        .build();
-  }
-
-  static DnsOverHttps buildCloudflare(OkHttpClient bootstrapClient) {
-    return new DnsOverHttps.Builder().client(bootstrapClient)
-        .url(HttpUrl.get("https://cloudflare-dns.com/dns-query"))
-        .bootstrapDnsHosts(getByIp("1.1.1.1"))
-        .includeIPv6(false)
-        .build();
-  }
-
-  static DnsOverHttps buildCloudflarePost(OkHttpClient bootstrapClient) {
-    return new DnsOverHttps.Builder().client(bootstrapClient)
-        .url(HttpUrl.get("https://cloudflare-dns.com/dns-query"))
-        .bootstrapDnsHosts(getByIp("104.16.111.25"), getByIp("104.16.112.25"),
-            getByIp("2400:cb00:2048:1:0:0:6810:7019"), getByIp("2400:cb00:2048:1:0:0:6810:6f19"))
-        .includeIPv6(false)
-        .post(true)
-        .build();
-  }
-
-  static DnsOverHttps buildCleanBrowsing(OkHttpClient bootstrapClient) {
-    return new DnsOverHttps.Builder().client(bootstrapClient)
-        .url(HttpUrl.get("https://doh.cleanbrowsing.org/doh/family-filter/"))
-        .includeIPv6(false)
-        .build();
-  }
-
-  static DnsOverHttps buildChantra(OkHttpClient bootstrapClient) {
-    return new DnsOverHttps.Builder().client(bootstrapClient)
-        .url(HttpUrl.get("https://dns.dnsoverhttps.net/dns-query"))
-        .includeIPv6(false)
-        .build();
-  }
-
-  static DnsOverHttps buildCryptoSx(OkHttpClient bootstrapClient) {
-    return new DnsOverHttps.Builder().client(bootstrapClient)
-        .url(HttpUrl.get("https://doh.crypto.sx/dns-query"))
-        .includeIPv6(false)
-        .build();
-  }
-
-  public static List<DnsOverHttps> providers(OkHttpClient client, boolean http2Only,
-      boolean workingOnly, boolean getOnly) {
-
-    List<DnsOverHttps> result = new ArrayList<>();
-
-    result.add(buildGoogle(client));
-    if (!getOnly) {
-      result.add(buildGooglePost(client));
-    }
-    result.add(buildCloudflare(client));
-    result.add(buildCloudflareIp(client));
-    if (!getOnly) {
-      result.add(buildCloudflarePost(client));
-    }
-    if (!workingOnly) {
-      //result.add(buildCleanBrowsing(client)); // timeouts
-      result.add(buildCryptoSx(client)); // 521 - server down
-    }
-    result.add(buildChantra(client));
-
-    return result;
-  }
-
-  private static InetAddress getByIp(String host) {
-    try {
-      return InetAddress.getByName(host);
-    } catch (UnknownHostException e) {
-      // unlikely
-      throw new RuntimeException(e);
-    }
-  }
-}
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/TestDohMain.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/TestDohMain.java
deleted file mode 100644
index 6a25e7ebf3..0000000000
--- a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/TestDohMain.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.dnsoverhttps;
-
-import java.io.File;
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.security.Security;
-import java.util.Collections;
-import java.util.List;
-import okhttp3.Cache;
-import okhttp3.HttpUrl;
-import okhttp3.OkHttpClient;
-
-import static java.util.Arrays.asList;
-
-public class TestDohMain {
-  public static void main(String[] args) throws IOException {
-    Security.insertProviderAt(new org.conscrypt.OpenSSLProvider(), 1);
-
-    OkHttpClient bootstrapClient = new OkHttpClient.Builder().build();
-
-    List<String> names = asList("google.com", "graph.facebook.com", "sdflkhfsdlkjdf.ee");
-
-    try {
-      System.out.println("uncached\n********\n");
-      List<DnsOverHttps> dnsProviders =
-          DohProviders.providers(bootstrapClient, false, false, false);
-      runBatch(dnsProviders, names);
-
-      Cache dnsCache =
-          new Cache(new File("./target/TestDohMain.cache." + System.currentTimeMillis()),
-              10 * 1024 * 1024);
-
-      System.out.println("Bad targets\n***********\n");
-
-      HttpUrl url = HttpUrl.get("https://dns.cloudflare.com/.not-so-well-known/run-dmc-query");
-      List<DnsOverHttps> badProviders = Collections.singletonList(
-          new DnsOverHttps.Builder().client(bootstrapClient).url(url).post(true).build());
-      runBatch(badProviders, names);
-
-      System.out.println("cached first run\n****************\n");
-      names = asList("google.com", "graph.facebook.com");
-      bootstrapClient = bootstrapClient.newBuilder().cache(dnsCache).build();
-      dnsProviders = DohProviders.providers(bootstrapClient, true, true, true);
-      runBatch(dnsProviders, names);
-
-      System.out.println("cached second run\n*****************\n");
-      dnsProviders = DohProviders.providers(bootstrapClient, true, true, true);
-      runBatch(dnsProviders, names);
-    } finally {
-      bootstrapClient.connectionPool().evictAll();
-      bootstrapClient.dispatcher().executorService().shutdownNow();
-      Cache cache = bootstrapClient.cache();
-      if (cache != null) {
-        cache.close();
-      }
-    }
-  }
-
-  private static void runBatch(List<DnsOverHttps> dnsProviders, List<String> names) {
-    long time = System.currentTimeMillis();
-
-    for (DnsOverHttps dns : dnsProviders) {
-      System.out.println("Testing " + dns.url());
-
-      for (String host : names) {
-        System.out.print(host + ": ");
-        System.out.flush();
-
-        try {
-          List<InetAddress> results = dns.lookup(host);
-          System.out.println(results);
-        } catch (UnknownHostException uhe) {
-          Throwable e = uhe;
-
-          while (e != null) {
-            System.out.println(e.toString());
-
-            e = e.getCause();
-          }
-        }
-      }
-
-      System.out.println();
-    }
-
-    time = System.currentTimeMillis() - time;
-
-    System.out.println("Time: " + (((double) time) / 1000) + " seconds\n");
-  }
-}
diff --git a/okhttp-logging-interceptor/Module.md b/okhttp-logging-interceptor/Module.md
deleted file mode 100644
index d018b76711..0000000000
--- a/okhttp-logging-interceptor/Module.md
+++ /dev/null
@@ -1,3 +0,0 @@
-# Module okhttp-logging-interceptor
-
-An OkHttp interceptor which logs HTTP request and response data.
diff --git a/okhttp-logging-interceptor/README.md b/okhttp-logging-interceptor/README.md
deleted file mode 100644
index 5f0f513740..0000000000
--- a/okhttp-logging-interceptor/README.md
+++ /dev/null
@@ -1,44 +0,0 @@
-Logging Interceptor
-===================
-
-An [OkHttp interceptor][interceptors] which logs HTTP request and response data.
-
-```java
-HttpLoggingInterceptor logging = new HttpLoggingInterceptor();
-logging.setLevel(Level.BASIC);
-OkHttpClient client = new OkHttpClient.Builder()
-  .addInterceptor(logging)
-  .build();
-```
-
-You can change the log level at any time by calling `setLevel()`.
-
-To log to a custom location, pass a `Logger` instance to the constructor.
-```java
-HttpLoggingInterceptor logging = new HttpLoggingInterceptor(new Logger() {
-  @Override public void log(String message) {
-    Timber.tag("OkHttp").d(message);
-  }
-});
-```
-
-**Warning**: The logs generated by this interceptor when using the `HEADERS` or `BODY` levels have
-the potential to leak sensitive information such as "Authorization" or "Cookie" headers and the
-contents of request and response bodies. This data should only be logged in a controlled way or in
-a non-production environment.
-
-You can redact headers that may contain sensitive information by calling `redactHeader()`.
-```java
-logging.redactHeader("Authorization");
-logging.redactHeader("Cookie");
-```
-
-Download
---------
-
-```kotlin
-implementation("com.squareup.okhttp3:logging-interceptor:4.2.1")
-```
-
-
-[interceptors]: https://square.github.io/okhttp/interceptors/
diff --git a/okhttp-logging-interceptor/build.gradle b/okhttp-logging-interceptor/build.gradle
deleted file mode 100644
index 01fea55a9c..0000000000
--- a/okhttp-logging-interceptor/build.gradle
+++ /dev/null
@@ -1,40 +0,0 @@
-apply plugin: 'com.vanniktech.maven.publish'
-apply plugin: 'me.champeau.gradle.japicmp'
-
-jar {
-  manifest {
-    attributes('Automatic-Module-Name': 'okhttp3.logging')
-  }
-}
-
-dependencies {
-  api project(':okhttp')
-  compileOnly deps.jsr305
-
-  testCompileOnly deps.jsr305
-  testImplementation deps.junit
-}
-
-afterEvaluate { project ->
-  project.tasks.dokka {
-    outputDirectory = "$rootDir/docs/4.x"
-    outputFormat = 'gfm'
-  }
-}
-
-task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
-  oldClasspath = files(baselineJar(project, baselineVersion))
-  newClasspath = files(jar.archivePath)
-  onlyBinaryIncompatibleModified = true
-  failOnModification = true
-  txtOutputFile = file("$buildDir/reports/japi.txt")
-  ignoreMissingClasses = true
-  includeSynthetic = true
-  methodExcludes = [
-    // Became 'final' in 4.0.0:
-    'okhttp3.logging.HttpLoggingInterceptor#redactHeader(java.lang.String)',
-    'okhttp3.logging.HttpLoggingInterceptor#getLevel()',
-    'okhttp3.logging.HttpLoggingInterceptor#setLevel(okhttp3.logging.HttpLoggingInterceptor$Level)'
-  ]
-}
-check.dependsOn(japicmp)
diff --git a/okhttp-logging-interceptor/gradle.properties b/okhttp-logging-interceptor/gradle.properties
deleted file mode 100644
index e0fec2973b..0000000000
--- a/okhttp-logging-interceptor/gradle.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-POM_ARTIFACT_ID=logging-interceptor
-POM_NAME=logging-interceptor
-POM_PACKAGING=jar
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.kt b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.kt
deleted file mode 100644
index e346c74f70..0000000000
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.kt
+++ /dev/null
@@ -1,289 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.logging
-
-import okhttp3.Headers
-import okhttp3.Interceptor
-import okhttp3.OkHttpClient
-import okhttp3.Response
-import okhttp3.internal.http.promisesBody
-import okhttp3.internal.platform.Platform
-import okio.Buffer
-import okio.GzipSource
-import java.io.IOException
-import java.nio.charset.Charset
-import java.nio.charset.StandardCharsets.UTF_8
-import java.util.TreeSet
-import java.util.concurrent.TimeUnit
-
-/**
- * An OkHttp interceptor which logs request and response information. Can be applied as an
- * [application interceptor][OkHttpClient.interceptors] or as a [OkHttpClient.networkInterceptors].
- *
- * The format of the logs created by this class should not be considered stable and may
- * change slightly between releases. If you need a stable logging format, use your own interceptor.
- */
-class HttpLoggingInterceptor @JvmOverloads constructor(
-  private val logger: Logger = Logger.DEFAULT
-) : Interceptor {
-
-  @Volatile private var headersToRedact = emptySet<String>()
-
-  @set:JvmName("level")
-  @Volatile var level = Level.NONE
-
-  enum class Level {
-    /** No logs. */
-    NONE,
-
-    /**
-     * Logs request and response lines.
-     *
-     * Example:
-     * ```
-     * --> POST /greeting http/1.1 (3-byte body)
-     *
-     * <-- 200 OK (22ms, 6-byte body)
-     * ```
-     */
-    BASIC,
-
-    /**
-     * Logs request and response lines and their respective headers.
-     *
-     * Example:
-     * ```
-     * --> POST /greeting http/1.1
-     * Host: example.com
-     * Content-Type: plain/text
-     * Content-Length: 3
-     * --> END POST
-     *
-     * <-- 200 OK (22ms)
-     * Content-Type: plain/text
-     * Content-Length: 6
-     * <-- END HTTP
-     * ```
-     */
-    HEADERS,
-
-    /**
-     * Logs request and response lines and their respective headers and bodies (if present).
-     *
-     * Example:
-     * ```
-     * --> POST /greeting http/1.1
-     * Host: example.com
-     * Content-Type: plain/text
-     * Content-Length: 3
-     *
-     * Hi?
-     * --> END POST
-     *
-     * <-- 200 OK (22ms)
-     * Content-Type: plain/text
-     * Content-Length: 6
-     *
-     * Hello!
-     * <-- END HTTP
-     * ```
-     */
-    BODY
-  }
-
-  interface Logger {
-    fun log(message: String)
-
-    companion object {
-      /** A [Logger] defaults output appropriate for the current platform. */
-      @JvmField
-      val DEFAULT: Logger = object : Logger {
-        override fun log(message: String) {
-          Platform.get().log(message)
-        }
-      }
-    }
-  }
-
-  fun redactHeader(name: String) {
-    val newHeadersToRedact = TreeSet(String.CASE_INSENSITIVE_ORDER)
-    newHeadersToRedact += headersToRedact
-    newHeadersToRedact += name
-    headersToRedact = newHeadersToRedact
-  }
-
-  @Deprecated(
-      message = "Moved to var. Replace setLevel(...) with level(...) to fix Java",
-      replaceWith = ReplaceWith(expression = "apply { this.level = level }"),
-      level = DeprecationLevel.WARNING)
-  fun setLevel(level: Level) = apply {
-    this.level = level
-  }
-
-  @JvmName("-deprecated_level")
-  @Deprecated(
-      message = "moved to var",
-      replaceWith = ReplaceWith(expression = "level"),
-      level = DeprecationLevel.ERROR)
-  fun getLevel(): Level = level
-
-  @Throws(IOException::class)
-  override fun intercept(chain: Interceptor.Chain): Response {
-    val level = this.level
-
-    val request = chain.request()
-    if (level == Level.NONE) {
-      return chain.proceed(request)
-    }
-
-    val logBody = level == Level.BODY
-    val logHeaders = logBody || level == Level.HEADERS
-
-    val requestBody = request.body
-
-    val connection = chain.connection()
-    var requestStartMessage =
-        ("--> ${request.method} ${request.url}${if (connection != null) " " + connection.protocol() else ""}")
-    if (!logHeaders && requestBody != null) {
-      requestStartMessage += " (${requestBody.contentLength()}-byte body)"
-    }
-    logger.log(requestStartMessage)
-
-    if (logHeaders) {
-      val headers = request.headers
-
-      if (requestBody != null) {
-        // Request body headers are only present when installed as a network interceptor. When not
-        // already present, force them to be included (if available) so their values are known.
-        requestBody.contentType()?.let {
-          if (headers["Content-Type"] == null) {
-            logger.log("Content-Type: $it")
-          }
-        }
-        if (requestBody.contentLength() != -1L) {
-          if (headers["Content-Length"] == null) {
-            logger.log("Content-Length: ${requestBody.contentLength()}")
-          }
-        }
-      }
-
-      for (i in 0 until headers.size) {
-        logHeader(headers, i)
-      }
-
-      if (!logBody || requestBody == null) {
-        logger.log("--> END ${request.method}")
-      } else if (bodyHasUnknownEncoding(request.headers)) {
-        logger.log("--> END ${request.method} (encoded body omitted)")
-      } else if (requestBody.isDuplex()) {
-        logger.log("--> END ${request.method} (duplex request body omitted)")
-      } else if (requestBody.isOneShot()) {
-        logger.log("--> END ${request.method} (one-shot body omitted)")
-      } else {
-        val buffer = Buffer()
-        requestBody.writeTo(buffer)
-
-        val contentType = requestBody.contentType()
-        val charset: Charset = contentType?.charset(UTF_8) ?: UTF_8
-
-        logger.log("")
-        if (buffer.isProbablyUtf8()) {
-          logger.log(buffer.readString(charset))
-          logger.log("--> END ${request.method} (${requestBody.contentLength()}-byte body)")
-        } else {
-          logger.log(
-              "--> END ${request.method} (binary ${requestBody.contentLength()}-byte body omitted)")
-        }
-      }
-    }
-
-    val startNs = System.nanoTime()
-    val response: Response
-    try {
-      response = chain.proceed(request)
-    } catch (e: Exception) {
-      logger.log("<-- HTTP FAILED: $e")
-      throw e
-    }
-
-    val tookMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs)
-
-    val responseBody = response.body!!
-    val contentLength = responseBody.contentLength()
-    val bodySize = if (contentLength != -1L) "$contentLength-byte" else "unknown-length"
-    logger.log(
-        "<-- ${response.code}${if (response.message.isEmpty()) "" else ' ' + response.message} ${response.request.url} (${tookMs}ms${if (!logHeaders) ", $bodySize body" else ""})")
-
-    if (logHeaders) {
-      val headers = response.headers
-      for (i in 0 until headers.size) {
-        logHeader(headers, i)
-      }
-
-      if (!logBody || !response.promisesBody()) {
-        logger.log("<-- END HTTP")
-      } else if (bodyHasUnknownEncoding(response.headers)) {
-        logger.log("<-- END HTTP (encoded body omitted)")
-      } else {
-        val source = responseBody.source()
-        source.request(Long.MAX_VALUE) // Buffer the entire body.
-        var buffer = source.buffer
-
-        var gzippedLength: Long? = null
-        if ("gzip".equals(headers["Content-Encoding"], ignoreCase = true)) {
-          gzippedLength = buffer.size
-          GzipSource(buffer.clone()).use { gzippedResponseBody ->
-            buffer = Buffer()
-            buffer.writeAll(gzippedResponseBody)
-          }
-        }
-
-        val contentType = responseBody.contentType()
-        val charset: Charset = contentType?.charset(UTF_8) ?: UTF_8
-
-        if (!buffer.isProbablyUtf8()) {
-          logger.log("")
-          logger.log("<-- END HTTP (binary ${buffer.size}-byte body omitted)")
-          return response
-        }
-
-        if (contentLength != 0L) {
-          logger.log("")
-          logger.log(buffer.clone().readString(charset))
-        }
-
-        if (gzippedLength != null) {
-          logger.log("<-- END HTTP (${buffer.size}-byte, $gzippedLength-gzipped-byte body)")
-        } else {
-          logger.log("<-- END HTTP (${buffer.size}-byte body)")
-        }
-      }
-    }
-
-    return response
-  }
-
-  private fun logHeader(headers: Headers, i: Int) {
-    val value = if (headers.name(i) in headersToRedact) "" else headers.value(i)
-    logger.log(headers.name(i) + ": " + value)
-  }
-
-  private fun bodyHasUnknownEncoding(headers: Headers): Boolean {
-    val contentEncoding = headers["Content-Encoding"] ?: return false
-    return !contentEncoding.equals("identity", ignoreCase = true) &&
-        !contentEncoding.equals("gzip", ignoreCase = true)
-  }
-}
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.kt b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.kt
deleted file mode 100644
index 35024ed219..0000000000
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/LoggingEventListener.kt
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.logging
-
-import okhttp3.Call
-import okhttp3.Connection
-import okhttp3.EventListener
-import okhttp3.Handshake
-import okhttp3.HttpUrl
-import okhttp3.OkHttpClient
-import okhttp3.Protocol
-import okhttp3.Request
-import okhttp3.Response
-import java.io.IOException
-import java.net.InetAddress
-import java.net.InetSocketAddress
-import java.net.Proxy
-import java.util.concurrent.TimeUnit
-
-/**
- * An OkHttp EventListener, which logs call events. Can be applied as an
- * [event listener factory][OkHttpClient.eventListenerFactory].
- *
- * The format of the logs created by this class should not be considered stable and may change
- * slightly between releases. If you need a stable logging format, use your own event listener.
- */
-class LoggingEventListener private constructor(
-  private val logger: HttpLoggingInterceptor.Logger
-) : EventListener() {
-  private var startNs: Long = 0
-
-  override fun callStart(call: Call) {
-    startNs = System.nanoTime()
-
-    logWithTime("callStart: ${call.request()}")
-  }
-
-  override fun proxySelectStart(call: Call, url: HttpUrl) {
-    logWithTime("proxySelectStart: $url")
-  }
-
-  override fun proxySelectEnd(call: Call, url: HttpUrl, proxies: List<Proxy>) {
-    logWithTime("proxySelectEnd: $proxies")
-  }
-
-  override fun dnsStart(call: Call, domainName: String) {
-    logWithTime("dnsStart: $domainName")
-  }
-
-  override fun dnsEnd(call: Call, domainName: String, inetAddressList: List<InetAddress>) {
-    logWithTime("dnsEnd: $inetAddressList")
-  }
-
-  override fun connectStart(call: Call, inetSocketAddress: InetSocketAddress, proxy: Proxy) {
-    logWithTime("connectStart: $inetSocketAddress $proxy")
-  }
-
-  override fun secureConnectStart(call: Call) {
-    logWithTime("secureConnectStart")
-  }
-
-  override fun secureConnectEnd(call: Call, handshake: Handshake?) {
-    logWithTime("secureConnectEnd: $handshake")
-  }
-
-  override fun connectEnd(
-    call: Call,
-    inetSocketAddress: InetSocketAddress,
-    proxy: Proxy,
-    protocol: Protocol?
-  ) {
-    logWithTime("connectEnd: $protocol")
-  }
-
-  override fun connectFailed(
-    call: Call,
-    inetSocketAddress: InetSocketAddress,
-    proxy: Proxy,
-    protocol: Protocol?,
-    ioe: IOException
-  ) {
-    logWithTime("connectFailed: $protocol $ioe")
-  }
-
-  override fun connectionAcquired(call: Call, connection: Connection) {
-    logWithTime("connectionAcquired: $connection")
-  }
-
-  override fun connectionReleased(call: Call, connection: Connection) {
-    logWithTime("connectionReleased")
-  }
-
-  override fun requestHeadersStart(call: Call) {
-    logWithTime("requestHeadersStart")
-  }
-
-  override fun requestHeadersEnd(call: Call, request: Request) {
-    logWithTime("requestHeadersEnd")
-  }
-
-  override fun requestBodyStart(call: Call) {
-    logWithTime("requestBodyStart")
-  }
-
-  override fun requestBodyEnd(call: Call, byteCount: Long) {
-    logWithTime("requestBodyEnd: byteCount=$byteCount")
-  }
-
-  override fun requestFailed(call: Call, ioe: IOException) {
-    logWithTime("requestFailed: $ioe")
-  }
-
-  override fun responseHeadersStart(call: Call) {
-    logWithTime("responseHeadersStart")
-  }
-
-  override fun responseHeadersEnd(call: Call, response: Response) {
-    logWithTime("responseHeadersEnd: $response")
-  }
-
-  override fun responseBodyStart(call: Call) {
-    logWithTime("responseBodyStart")
-  }
-
-  override fun responseBodyEnd(call: Call, byteCount: Long) {
-    logWithTime("responseBodyEnd: byteCount=$byteCount")
-  }
-
-  override fun responseFailed(call: Call, ioe: IOException) {
-    logWithTime("responseFailed: $ioe")
-  }
-
-  override fun callEnd(call: Call) {
-    logWithTime("callEnd")
-  }
-
-  override fun callFailed(call: Call, ioe: IOException) {
-    logWithTime("callFailed: $ioe")
-  }
-
-  private fun logWithTime(message: String) {
-    val timeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNs)
-    logger.log("[$timeMs ms] $message")
-  }
-
-  open class Factory @JvmOverloads constructor(
-    private val logger: HttpLoggingInterceptor.Logger = HttpLoggingInterceptor.Logger.DEFAULT
-  ) : EventListener.Factory {
-    override fun create(call: Call): EventListener = LoggingEventListener(logger)
-  }
-}
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/utf8.kt b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/utf8.kt
deleted file mode 100644
index d8ebe52e17..0000000000
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/utf8.kt
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.logging
-
-import okio.Buffer
-import java.io.EOFException
-
-/**
- * Returns true if the body in question probably contains human readable text. Uses a small
- * sample of code points to detect unicode control characters commonly used in binary file
- * signatures.
- */
-internal fun Buffer.isProbablyUtf8(): Boolean {
-  try {
-    val prefix = Buffer()
-    val byteCount = size.coerceAtMost(64)
-    copyTo(prefix, 0, byteCount)
-    for (i in 0 until 16) {
-      if (prefix.exhausted()) {
-        break
-      }
-      val codePoint = prefix.readUtf8CodePoint()
-      if (Character.isISOControl(codePoint) && !Character.isWhitespace(codePoint)) {
-        return false
-      }
-    }
-    return true
-  } catch (_: EOFException) {
-    return false // Truncated UTF-8 sequence.
-  }
-}
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
deleted file mode 100644
index 3591bc9c0a..0000000000
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
+++ /dev/null
@@ -1,954 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.logging;
-
-import java.io.IOException;
-import java.net.UnknownHostException;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.regex.Pattern;
-import javax.annotation.Nullable;
-import javax.net.ssl.HostnameVerifier;
-import okhttp3.HttpUrl;
-import okhttp3.Interceptor;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.testing.PlatformRule;
-import okhttp3.Protocol;
-import okhttp3.RecordingHostnameVerifier;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.ResponseBody;
-import okhttp3.logging.HttpLoggingInterceptor.Level;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.tls.HandshakeCertificates;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.ByteString;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeThat;
-
-public final class HttpLoggingInterceptorTest {
-  private static final MediaType PLAIN = MediaType.get("text/plain; charset=utf-8");
-
-  @Rule public final PlatformRule platform = new PlatformRule();
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private final HandshakeCertificates handshakeCertificates = localhost();
-  private final HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-  private OkHttpClient client;
-  private String host;
-  private HttpUrl url;
-
-  private final LogRecorder networkLogs = new LogRecorder();
-  private final HttpLoggingInterceptor networkInterceptor =
-      new HttpLoggingInterceptor(networkLogs);
-
-  private final LogRecorder applicationLogs = new LogRecorder();
-  private final HttpLoggingInterceptor applicationInterceptor =
-      new HttpLoggingInterceptor(applicationLogs);
-
-  private Interceptor extraNetworkInterceptor = null;
-
-  private void setLevel(Level level) {
-    networkInterceptor.setLevel(level);
-    applicationInterceptor.setLevel(level);
-  }
-
-  @Before public void setUp() {
-    client = new OkHttpClient.Builder()
-        .addNetworkInterceptor(chain -> extraNetworkInterceptor != null
-            ? extraNetworkInterceptor.intercept(chain)
-            : chain.proceed(chain.request()))
-        .addNetworkInterceptor(networkInterceptor)
-        .addInterceptor(applicationInterceptor)
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(hostnameVerifier)
-        .build();
-
-    host = server.getHostName() + ":" + server.getPort();
-    url = server.url("/");
-  }
-
-  @Test public void levelGetter() {
-    // The default is NONE.
-    assertThat(applicationInterceptor.getLevel()).isEqualTo(Level.NONE);
-
-    for (Level level : Level.values()) {
-      applicationInterceptor.setLevel(level);
-      assertThat(applicationInterceptor.getLevel()).isEqualTo(level);
-    }
-  }
-
-  @Test public void setLevelShouldPreventNullValue() {
-    try {
-      applicationInterceptor.setLevel(null);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setLevelShouldReturnSameInstanceOfInterceptor() {
-    for (Level level : Level.values()) {
-      assertThat(applicationInterceptor.setLevel(level)).isSameAs(applicationInterceptor);
-    }
-  }
-
-  @Test public void none() throws IOException {
-    server.enqueue(new MockResponse());
-    client.newCall(request().build()).execute();
-
-    applicationLogs.assertNoMoreLogs();
-    networkLogs.assertNoMoreLogs();
-  }
-
-  @Test public void basicGet() throws IOException {
-    setLevel(Level.BASIC);
-
-    server.enqueue(new MockResponse());
-    client.newCall(request().build()).execute();
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void basicPost() throws IOException {
-    setLevel(Level.BASIC);
-
-    server.enqueue(new MockResponse());
-    client.newCall(request().post(RequestBody.create("Hi?", PLAIN)).build()).execute();
-
-    applicationLogs
-        .assertLogEqual("--> POST " + url + " (3-byte body)")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> POST " + url + " http/1.1 (3-byte body)")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void basicResponseBody() throws IOException {
-    setLevel(Level.BASIC);
-
-    server.enqueue(new MockResponse()
-        .setBody("Hello!")
-        .setHeader("Content-Type", PLAIN));
-    Response response = client.newCall(request().build()).execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 6-byte body\\)")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 6-byte body\\)")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void basicChunkedResponseBody() throws IOException {
-    setLevel(Level.BASIC);
-
-    server.enqueue(new MockResponse()
-        .setChunkedBody("Hello!", 2)
-        .setHeader("Content-Type", PLAIN));
-    Response response = client.newCall(request().build()).execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, unknown-length body\\)")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, unknown-length body\\)")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void headersGet() throws IOException {
-    setLevel(Level.HEADERS);
-
-    server.enqueue(new MockResponse());
-    Response response = client.newCall(request().build()).execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void headersPost() throws IOException {
-    setLevel(Level.HEADERS);
-
-    server.enqueue(new MockResponse());
-    Request request = request().post(RequestBody.create("Hi?", PLAIN)).build();
-    Response response = client.newCall(request).execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> POST " + url)
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("Content-Length: 3")
-        .assertLogEqual("--> END POST")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> POST " + url + " http/1.1")
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("Content-Length: 3")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("--> END POST")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void headersPostNoContentType() throws IOException {
-    setLevel(Level.HEADERS);
-
-    server.enqueue(new MockResponse());
-    Request request = request().post(RequestBody.create("Hi?", null)).build();
-    Response response = client.newCall(request).execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> POST " + url)
-        .assertLogEqual("Content-Length: 3")
-        .assertLogEqual("--> END POST")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> POST " + url + " http/1.1")
-        .assertLogEqual("Content-Length: 3")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("--> END POST")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void headersPostNoLength() throws IOException {
-    setLevel(Level.HEADERS);
-
-    server.enqueue(new MockResponse());
-    RequestBody body = new RequestBody() {
-      @Override public MediaType contentType() {
-        return PLAIN;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.writeUtf8("Hi!");
-      }
-    };
-    Response response = client.newCall(request().post(body).build()).execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> POST " + url)
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("--> END POST")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> POST " + url + " http/1.1")
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("Transfer-Encoding: chunked")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("--> END POST")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void headersPostWithHeaderOverrides() throws IOException {
-    setLevel(Level.HEADERS);
-
-    extraNetworkInterceptor = chain -> chain.proceed(chain.request()
-        .newBuilder()
-        .header("Content-Length", "2")
-        .header("Content-Type", "text/plain-ish")
-        .build());
-
-    server.enqueue(new MockResponse());
-    client.newCall(request()
-        .post(RequestBody.create("Hi?", PLAIN))
-        .build()).execute();
-
-    applicationLogs
-        .assertLogEqual("--> POST " + url)
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("Content-Length: 3")
-        .assertLogEqual("--> END POST")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> POST " + url + " http/1.1")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("Content-Length: 2")
-        .assertLogEqual("Content-Type: text/plain-ish")
-        .assertLogEqual("--> END POST")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void headersResponseBody() throws IOException {
-    setLevel(Level.HEADERS);
-
-    server.enqueue(new MockResponse()
-        .setBody("Hello!")
-        .setHeader("Content-Type", PLAIN));
-    Response response = client.newCall(request().build()).execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 6")
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("<-- END HTTP")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 6")
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("<-- END HTTP")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void bodyGet() throws IOException {
-    setLevel(Level.BODY);
-
-    server.enqueue(new MockResponse());
-    Response response = client.newCall(request().build()).execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP (0-byte body)")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP (0-byte body)")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void bodyGet204() throws IOException {
-    setLevel(Level.BODY);
-    bodyGetNoBody(204);
-  }
-
-  @Test public void bodyGet205() throws IOException {
-    setLevel(Level.BODY);
-    bodyGetNoBody(205);
-  }
-
-  private void bodyGetNoBody(int code) throws IOException {
-    server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 " + code + " No Content"));
-    Response response = client.newCall(request().build()).execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- " + code + " No Content " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP (0-byte body)")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- " + code + " No Content " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP (0-byte body)")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void bodyPost() throws IOException {
-    setLevel(Level.BODY);
-
-    server.enqueue(new MockResponse());
-    Request request = request().post(RequestBody.create("Hi?", PLAIN)).build();
-    Response response = client.newCall(request).execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> POST " + url)
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("Content-Length: 3")
-        .assertLogEqual("")
-        .assertLogEqual("Hi?")
-        .assertLogEqual("--> END POST (3-byte body)")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP (0-byte body)")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> POST " + url + " http/1.1")
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("Content-Length: 3")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("")
-        .assertLogEqual("Hi?")
-        .assertLogEqual("--> END POST (3-byte body)")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("<-- END HTTP (0-byte body)")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void bodyResponseBody() throws IOException {
-    setLevel(Level.BODY);
-
-    server.enqueue(new MockResponse()
-        .setBody("Hello!")
-        .setHeader("Content-Type", PLAIN));
-    Response response = client.newCall(request().build()).execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 6")
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("")
-        .assertLogEqual("Hello!")
-        .assertLogEqual("<-- END HTTP (6-byte body)")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 6")
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("")
-        .assertLogEqual("Hello!")
-        .assertLogEqual("<-- END HTTP (6-byte body)")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void bodyResponseBodyChunked() throws IOException {
-    setLevel(Level.BODY);
-
-    server.enqueue(new MockResponse()
-        .setChunkedBody("Hello!", 2)
-        .setHeader("Content-Type", PLAIN));
-    Response response = client.newCall(request().build()).execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Transfer-encoding: chunked")
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("")
-        .assertLogEqual("Hello!")
-        .assertLogEqual("<-- END HTTP (6-byte body)")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Transfer-encoding: chunked")
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("")
-        .assertLogEqual("Hello!")
-        .assertLogEqual("<-- END HTTP (6-byte body)")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void bodyResponseGzipEncoded() throws IOException {
-    setLevel(Level.BODY);
-
-    server.enqueue(new MockResponse()
-        .setHeader("Content-Encoding", "gzip")
-        .setHeader("Content-Type", PLAIN)
-        .setBody(new Buffer().write(ByteString.decodeBase64(
-            "H4sIAAAAAAAAAPNIzcnJ11HwQKIAdyO+9hMAAAA="))));
-    Response response = client.newCall(request().build()).execute();
-
-    ResponseBody responseBody = response.body();
-    assertThat(responseBody.string()).overridingErrorMessage(
-        "Expected response body to be valid").isEqualTo("Hello, Hello, Hello");
-    responseBody.close();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Encoding: gzip")
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogMatch("Content-Length: \\d+")
-        .assertLogEqual("")
-        .assertLogEqual("Hello, Hello, Hello")
-        .assertLogEqual("<-- END HTTP (19-byte, 29-gzipped-byte body)")
-        .assertNoMoreLogs();
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-        .assertLogEqual("")
-        .assertLogEqual("Hello, Hello, Hello")
-        .assertLogEqual("<-- END HTTP (19-byte body)")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void bodyResponseUnknownEncoded() throws IOException {
-      setLevel(Level.BODY);
-
-      server.enqueue(new MockResponse()
-          // It's invalid to return this if not requested, but the server might anyway
-          .setHeader("Content-Encoding", "br")
-          .setHeader("Content-Type", PLAIN)
-          .setBody(new Buffer().write(ByteString.decodeBase64(
-              "iwmASGVsbG8sIEhlbGxvLCBIZWxsbwoD"))));
-      Response response = client.newCall(request().build()).execute();
-      response.body().close();
-
-      networkLogs
-          .assertLogEqual("--> GET " + url + " http/1.1")
-          .assertLogEqual("Host: " + host)
-          .assertLogEqual("Connection: Keep-Alive")
-          .assertLogEqual("Accept-Encoding: gzip")
-          .assertLogMatch("User-Agent: okhttp/.+")
-          .assertLogEqual("--> END GET")
-          .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-          .assertLogEqual("Content-Encoding: br")
-          .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-          .assertLogMatch("Content-Length: \\d+")
-          .assertLogEqual("<-- END HTTP (encoded body omitted)")
-          .assertNoMoreLogs();
-
-      applicationLogs
-          .assertLogEqual("--> GET " + url)
-          .assertLogEqual("--> END GET")
-          .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-          .assertLogEqual("Content-Encoding: br")
-          .assertLogEqual("Content-Type: text/plain; charset=utf-8")
-          .assertLogMatch("Content-Length: \\d+")
-          .assertLogEqual("<-- END HTTP (encoded body omitted)")
-          .assertNoMoreLogs();
-    }
-
-  @Test public void bodyGetMalformedCharset() throws IOException {
-    setLevel(Level.BODY);
-
-    server.enqueue(new MockResponse()
-        .setHeader("Content-Type", "text/html; charset=0")
-        .setBody("Body with unknown charset"));
-    Response response = client.newCall(request().build()).execute();
-    response.body().close();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Type: text/html; charset=0")
-        .assertLogMatch("Content-Length: \\d+")
-        .assertLogMatch("")
-        .assertLogEqual("Body with unknown charset")
-        .assertLogEqual("<-- END HTTP (25-byte body)")
-        .assertNoMoreLogs();
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Type: text/html; charset=0")
-        .assertLogMatch("Content-Length: \\d+")
-        .assertLogEqual("")
-        .assertLogEqual("Body with unknown charset")
-        .assertLogEqual("<-- END HTTP (25-byte body)")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void responseBodyIsBinary() throws IOException {
-    setLevel(Level.BODY);
-    Buffer buffer = new Buffer();
-    buffer.writeUtf8CodePoint(0x89);
-    buffer.writeUtf8CodePoint(0x50);
-    buffer.writeUtf8CodePoint(0x4e);
-    buffer.writeUtf8CodePoint(0x47);
-    buffer.writeUtf8CodePoint(0x0d);
-    buffer.writeUtf8CodePoint(0x0a);
-    buffer.writeUtf8CodePoint(0x1a);
-    buffer.writeUtf8CodePoint(0x0a);
-    server.enqueue(new MockResponse()
-        .setBody(buffer)
-        .setHeader("Content-Type", "image/png; charset=utf-8"));
-    Response response = client.newCall(request().build()).execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 9")
-        .assertLogEqual("Content-Type: image/png; charset=utf-8")
-        .assertLogEqual("")
-        .assertLogEqual("<-- END HTTP (binary 9-byte body omitted)")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 9")
-        .assertLogEqual("Content-Type: image/png; charset=utf-8")
-        .assertLogEqual("")
-        .assertLogEqual("<-- END HTTP (binary 9-byte body omitted)")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void connectFail() throws IOException {
-    setLevel(Level.BASIC);
-    client = new OkHttpClient.Builder()
-        .dns(hostname -> { throw new UnknownHostException("reason"); })
-        .addInterceptor(applicationInterceptor)
-        .build();
-
-    try {
-      client.newCall(request().build()).execute();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogEqual("<-- HTTP FAILED: java.net.UnknownHostException: reason")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void http2() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    url = server.url("/");
-
-    setLevel(Level.BASIC);
-
-    server.enqueue(new MockResponse());
-    Response response = client.newCall(request().build()).execute();
-    assumeThat(response.protocol(), equalTo(Protocol.HTTP_2));
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogMatch("<-- 200 " + url + " \\(\\d+ms, 0-byte body\\)")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " h2")
-        .assertLogMatch("<-- 200 " + url + " \\(\\d+ms, 0-byte body\\)")
-        .assertNoMoreLogs();
-  }
-
-  @Test
-  public void headersAreRedacted() throws Exception {
-    HttpLoggingInterceptor networkInterceptor =
-        new HttpLoggingInterceptor(networkLogs).setLevel(Level.HEADERS);
-    networkInterceptor.redactHeader("sEnSiTiVe");
-
-    HttpLoggingInterceptor applicationInterceptor =
-        new HttpLoggingInterceptor(applicationLogs).setLevel(Level.HEADERS);
-    applicationInterceptor.redactHeader("sEnSiTiVe");
-
-    client =
-        new OkHttpClient.Builder()
-            .addNetworkInterceptor(networkInterceptor)
-            .addInterceptor(applicationInterceptor)
-            .build();
-
-    server.enqueue(
-        new MockResponse().addHeader("SeNsItIvE", "Value").addHeader("Not-Sensitive", "Value"));
-    Response response =
-        client
-            .newCall(
-                request()
-                    .addHeader("SeNsItIvE", "Value")
-                    .addHeader("Not-Sensitive", "Value")
-                    .build())
-            .execute();
-    response.body().close();
-
-    applicationLogs
-        .assertLogEqual("--> GET " + url)
-        .assertLogEqual("SeNsItIvE: ")
-        .assertLogEqual("Not-Sensitive: Value")
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("SeNsItIvE: ")
-        .assertLogEqual("Not-Sensitive: Value")
-        .assertLogEqual("<-- END HTTP")
-        .assertNoMoreLogs();
-
-    networkLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
-        .assertLogEqual("SeNsItIvE: ")
-        .assertLogEqual("Not-Sensitive: Value")
-        .assertLogEqual("Host: " + host)
-        .assertLogEqual("Connection: Keep-Alive")
-        .assertLogEqual("Accept-Encoding: gzip")
-        .assertLogMatch("User-Agent: okhttp/.+")
-        .assertLogEqual("--> END GET")
-        .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("Content-Length: 0")
-        .assertLogEqual("SeNsItIvE: ")
-        .assertLogEqual("Not-Sensitive: Value")
-        .assertLogEqual("<-- END HTTP")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void duplexRequestsAreNotLogged() throws Exception {
-    platform.assumeHttp2Support();
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false); // HTTP/2
-    url = server.url("/");
-
-    setLevel(Level.BODY);
-
-    server.enqueue(new MockResponse()
-        .setBody("Hello response!"));
-
-    RequestBody asyncRequestBody = new RequestBody() {
-      @Override public @Nullable MediaType contentType() {
-        return null;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.writeUtf8("Hello request!");
-        sink.close();
-      }
-
-      @Override public boolean isDuplex() {
-        return true;
-      }
-    };
-
-    Request request = request()
-        .post(asyncRequestBody)
-        .build();
-    Response response = client.newCall(request).execute();
-    assumeThat(response.protocol(), equalTo(Protocol.HTTP_2));
-
-    assertThat(response.body().string()).isEqualTo("Hello response!");
-
-    applicationLogs
-        .assertLogEqual("--> POST " + url)
-        .assertLogEqual("--> END POST (duplex request body omitted)")
-        .assertLogMatch("<-- 200 " + url + " \\(\\d+ms\\)")
-        .assertLogEqual("content-length: 15")
-        .assertLogEqual("")
-        .assertLogEqual("Hello response!")
-        .assertLogEqual("<-- END HTTP (15-byte body)")
-        .assertNoMoreLogs();
-  }
-
-  @Test public void oneShotRequestsAreNotLogged() throws Exception {
-    url = server.url("/");
-
-    setLevel(Level.BODY);
-
-    server.enqueue(new MockResponse()
-                           .setBody("Hello response!"));
-
-    RequestBody asyncRequestBody = new RequestBody() {
-      @Override public @Nullable MediaType contentType() {
-        return null;
-      }
-
-      int counter = 0;
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        counter++;
-        assertThat(counter).isLessThanOrEqualTo(1);
-
-        sink.writeUtf8("Hello request!");
-        sink.close();
-      }
-
-      @Override public boolean isOneShot() {
-        return true;
-      }
-    };
-
-    Request request = request()
-                              .post(asyncRequestBody)
-                              .build();
-    Response response = client.newCall(request).execute();
-
-    assertThat(response.body().string()).isEqualTo("Hello response!");
-
-    applicationLogs
-            .assertLogEqual("--> POST " + url)
-            .assertLogEqual("--> END POST (one-shot body omitted)")
-            .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
-            .assertLogEqual("Content-Length: 15")
-            .assertLogEqual("")
-            .assertLogEqual("Hello response!")
-            .assertLogEqual("<-- END HTTP (15-byte body)")
-            .assertNoMoreLogs();
-  }
-
-  private Request.Builder request() {
-    return new Request.Builder().url(url);
-  }
-
-  static class LogRecorder implements HttpLoggingInterceptor.Logger {
-    private final List<String> logs = new ArrayList<>();
-    private int index;
-
-    LogRecorder assertLogEqual(String expected) {
-      assertThat(index).overridingErrorMessage("No more messages found").isLessThan(logs.size());
-      String actual = logs.get(index++);
-      assertThat(actual).isEqualTo(expected);
-      return this;
-    }
-
-    LogRecorder assertLogMatch(String pattern) {
-      assertThat(index).overridingErrorMessage("No more messages found").isLessThan(logs.size());
-      String actual = logs.get(index++);
-      assertThat(actual).matches(Pattern.compile(pattern, Pattern.DOTALL));
-      return this;
-    }
-
-    void assertNoMoreLogs() {
-      assertThat(logs.size()).overridingErrorMessage(
-          "More messages remain: " + logs.subList(index, logs.size())).isEqualTo(index);
-    }
-
-    @Override public void log(String message) {
-      logs.add(message);
-    }
-  }
-}
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/IsProbablyUtf8Test.kt b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/IsProbablyUtf8Test.kt
deleted file mode 100644
index c31d990129..0000000000
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/IsProbablyUtf8Test.kt
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.logging
-
-import okio.Buffer
-import org.assertj.core.api.Assertions.assertThat
-import org.junit.Test
-
-class IsProbablyUtf8Test {
-  @Test fun isProbablyUtf8() {
-    assertThat(Buffer().isProbablyUtf8()).isTrue()
-    assertThat(Buffer().writeUtf8("abc").isProbablyUtf8()).isTrue()
-    assertThat(Buffer().writeUtf8("new\r\nlines").isProbablyUtf8()).isTrue()
-    assertThat(Buffer().writeUtf8("white\t space").isProbablyUtf8()).isTrue()
-    assertThat(Buffer().writeByte(0x80).isProbablyUtf8()).isTrue()
-    assertThat(Buffer().writeByte(0x00).isProbablyUtf8()).isFalse()
-    assertThat(Buffer().writeByte(0xc0).isProbablyUtf8()).isFalse()
-  }
-}
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java
deleted file mode 100644
index 97690f5997..0000000000
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/LoggingEventListenerTest.java
+++ /dev/null
@@ -1,241 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.logging;
-
-import java.io.IOException;
-import java.net.UnknownHostException;
-import okhttp3.HttpUrl;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.testing.PlatformRule;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.tls.HandshakeCertificates;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static java.util.Arrays.asList;
-import static okhttp3.Protocol.HTTP_1_1;
-import static okhttp3.Protocol.HTTP_2;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class LoggingEventListenerTest {
-  private static final MediaType PLAIN = MediaType.get("text/plain");
-
-  @Rule public final PlatformRule platform = new PlatformRule();
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private final HandshakeCertificates handshakeCertificates = localhost();
-  private final LogRecorder logRecorder = new LogRecorder();
-  private final LoggingEventListener.Factory loggingEventListenerFactory =
-      new LoggingEventListener.Factory(logRecorder);
-  private OkHttpClient client;
-  private HttpUrl url;
-
-  @Before
-  public void setUp() {
-    client =
-        new OkHttpClient.Builder()
-            .eventListenerFactory(loggingEventListenerFactory)
-            .sslSocketFactory(
-                handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-            .retryOnConnectionFailure(false)
-            .build();
-
-    url = server.url("/");
-  }
-
-  @Test
-  public void get() throws Exception {
-    server.enqueue(new MockResponse().setBody("Hello!").setHeader("Content-Type", PLAIN));
-    Response response = client.newCall(request().build()).execute();
-    assertThat(response.body()).isNotNull();
-    response.body().bytes();
-
-    logRecorder
-        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + "\\}")
-        .assertLogMatch("proxySelectStart: " + url)
-        .assertLogMatch("proxySelectEnd: \\[DIRECT\\]")
-        .assertLogMatch("dnsStart: " + url.host())
-        .assertLogMatch("dnsEnd: \\[.+\\]")
-        .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
-        .assertLogMatch("connectEnd: http/1.1")
-        .assertLogMatch(
-            "connectionAcquired: Connection\\{"
-                + url.host()
-                + ":\\d+, proxy=DIRECT hostAddress="
-                + url.host()
-                + "/.+ cipherSuite=none protocol=http/1\\.1\\}")
-        .assertLogMatch("requestHeadersStart")
-        .assertLogMatch("requestHeadersEnd")
-        .assertLogMatch("responseHeadersStart")
-        .assertLogMatch(
-            "responseHeadersEnd: Response\\{protocol=http/1\\.1, code=200, message=OK, url="
-                + url
-                + "}")
-        .assertLogMatch("responseBodyStart")
-        .assertLogMatch("responseBodyEnd: byteCount=6")
-        .assertLogMatch("connectionReleased")
-        .assertLogMatch("callEnd")
-        .assertNoMoreLogs();
-  }
-
-  @Test
-  public void post() throws IOException {
-    server.enqueue(new MockResponse());
-    client.newCall(request().post(RequestBody.create("Hello!", PLAIN)).build()).execute();
-
-    logRecorder
-        .assertLogMatch("callStart: Request\\{method=POST, url=" + url + "\\}")
-        .assertLogMatch("proxySelectStart: " + url)
-        .assertLogMatch("proxySelectEnd: \\[DIRECT\\]")
-        .assertLogMatch("dnsStart: " + url.host())
-        .assertLogMatch("dnsEnd: \\[.+\\]")
-        .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
-        .assertLogMatch("connectEnd: http/1.1")
-        .assertLogMatch(
-            "connectionAcquired: Connection\\{"
-                + url.host()
-                + ":\\d+, proxy=DIRECT hostAddress="
-                + url.host()
-                + "/.+ cipherSuite=none protocol=http/1\\.1\\}")
-        .assertLogMatch("requestHeadersStart")
-        .assertLogMatch("requestHeadersEnd")
-        .assertLogMatch("requestBodyStart")
-        .assertLogMatch("requestBodyEnd: byteCount=6")
-        .assertLogMatch("responseHeadersStart")
-        .assertLogMatch(
-            "responseHeadersEnd: Response\\{protocol=http/1\\.1, code=200, message=OK, url="
-                + url
-                + "}")
-        .assertLogMatch("responseBodyStart")
-        .assertLogMatch("responseBodyEnd: byteCount=0")
-        .assertLogMatch("connectionReleased")
-        .assertLogMatch("callEnd")
-        .assertNoMoreLogs();
-  }
-
-  @Test
-  public void secureGet() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    url = server.url("/");
-
-    server.enqueue(new MockResponse());
-    Response response = client.newCall(request().build()).execute();
-    assertThat(response.body()).isNotNull();
-    response.body().bytes();
-
-    platform.assumeHttp2Support();
-
-    logRecorder
-        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + "\\}")
-        .assertLogMatch("proxySelectStart: " + url)
-        .assertLogMatch("proxySelectEnd: \\[DIRECT\\]")
-        .assertLogMatch("dnsStart: " + url.host())
-        .assertLogMatch("dnsEnd: \\[.+\\]")
-        .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
-        .assertLogMatch("secureConnectStart")
-        .assertLogMatch("secureConnectEnd: Handshake\\{"
-            + "tlsVersion=TLS_1_[23] "
-            + "cipherSuite=TLS_.* "
-            + "peerCertificates=\\[CN=localhost\\] "
-            + "localCertificates=\\[\\]}")
-        .assertLogMatch("connectEnd: h2")
-        .assertLogMatch(
-            "connectionAcquired: Connection\\{"
-                + url.host()
-                + ":\\d+, proxy=DIRECT hostAddress="
-                + url.host()
-                + "/.+ cipherSuite=.+ protocol=h2}")
-        .assertLogMatch("requestHeadersStart")
-        .assertLogMatch("requestHeadersEnd")
-        .assertLogMatch("responseHeadersStart")
-        .assertLogMatch(
-            "responseHeadersEnd: Response\\{protocol=h2, code=200, message=, url=" + url + "}")
-        .assertLogMatch("responseBodyStart")
-        .assertLogMatch("responseBodyEnd: byteCount=0")
-        .assertLogMatch("connectionReleased")
-        .assertLogMatch("callEnd")
-        .assertNoMoreLogs();
-  }
-
-  @Test
-  public void dnsFail() throws IOException {
-    client = new OkHttpClient.Builder()
-        .dns(hostname -> { throw new UnknownHostException("reason"); })
-        .eventListenerFactory(loggingEventListenerFactory)
-        .build();
-
-    try {
-      client.newCall(request().build()).execute();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-
-    logRecorder
-        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + "\\}")
-        .assertLogMatch("proxySelectStart: " + url)
-        .assertLogMatch("proxySelectEnd: \\[DIRECT\\]")
-        .assertLogMatch("dnsStart: " + url.host())
-        .assertLogMatch("callFailed: java.net.UnknownHostException: reason")
-        .assertNoMoreLogs();
-  }
-
-  @Test
-  public void connectFail() {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.setProtocols(asList(HTTP_2, HTTP_1_1));
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-    url = server.url("/");
-
-    try {
-      client.newCall(request().build()).execute();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    logRecorder
-        .assertLogMatch("callStart: Request\\{method=GET, url=" + url + "\\}")
-        .assertLogMatch("proxySelectStart: " + url)
-        .assertLogMatch("proxySelectEnd: \\[DIRECT\\]")
-        .assertLogMatch("dnsStart: " + url.host())
-        .assertLogMatch("dnsEnd: \\[.+\\]")
-        .assertLogMatch("connectStart: " + url.host() + "/.+ DIRECT")
-        .assertLogMatch("secureConnectStart")
-        .assertLogMatch(
-            "connectFailed: null javax\\.net\\.ssl\\.(?:SSLProtocolException|SSLHandshakeException): (?:Unexpected handshake message: client_hello|Handshake message sequence violation, 1|Read error).*")
-        .assertLogMatch(
-            "callFailed: javax\\.net\\.ssl\\.(?:SSLProtocolException|SSLHandshakeException): (?:Unexpected handshake message: client_hello|Handshake message sequence violation, 1|Read error).*")
-        .assertNoMoreLogs();
-  }
-
-  private Request.Builder request() {
-    return new Request.Builder().url(url);
-  }
-
-  private static class LogRecorder extends HttpLoggingInterceptorTest.LogRecorder {
-    @Override LogRecorder assertLogMatch(String pattern) {
-      return (LogRecorder) super.assertLogMatch("\\[\\d+ ms] " + pattern);
-    }
-  }
-}
diff --git a/okhttp-sse/Module.md b/okhttp-sse/Module.md
deleted file mode 100644
index 1802142d80..0000000000
--- a/okhttp-sse/Module.md
+++ /dev/null
@@ -1,3 +0,0 @@
-# Module okhttp-sse
-
-Support for server-sent events.
diff --git a/okhttp-sse/README.md b/okhttp-sse/README.md
deleted file mode 100644
index cf64bc1f8a..0000000000
--- a/okhttp-sse/README.md
+++ /dev/null
@@ -1,11 +0,0 @@
-OkHttp Server-Sent Events
-=========================
-
-Experimental support for server-sent events.
-API is not considered stable and may change at any time.
-
-### Download
-
-```kotlin
-testImplementation("com.squareup.okhttp3:okhttp-sse:4.2.1")
-```
diff --git a/okhttp-sse/build.gradle b/okhttp-sse/build.gradle
deleted file mode 100644
index 4afef7824e..0000000000
--- a/okhttp-sse/build.gradle
+++ /dev/null
@@ -1,35 +0,0 @@
-apply plugin: 'com.vanniktech.maven.publish'
-apply plugin: 'me.champeau.gradle.japicmp'
-
-jar {
-  manifest {
-    attributes('Automatic-Module-Name': 'okhttp3.sse')
-  }
-}
-
-dependencies {
-  api project(':okhttp')
-  compileOnly deps.jsr305
-
-}
-
-afterEvaluate { project ->
-  project.tasks.dokka {
-    outputDirectory = "$rootDir/docs/4.x"
-    outputFormat = 'gfm'
-  }
-}
-
-task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
-  oldClasspath = files(baselineJar(project, baselineVersion))
-  newClasspath = files(jar.archivePath)
-  onlyBinaryIncompatibleModified = true
-  failOnModification = true
-  txtOutputFile = file("$buildDir/reports/japi.txt")
-  ignoreMissingClasses = true
-  includeSynthetic = true
-  packageExcludes = [
-      'okhttp3.internal.sse',
-  ]
-}
-check.dependsOn(japicmp)
diff --git a/okhttp-sse/gradle.properties b/okhttp-sse/gradle.properties
deleted file mode 100644
index 497287dfc0..0000000000
--- a/okhttp-sse/gradle.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-POM_ARTIFACT_ID=okhttp-sse
-POM_NAME=okhttp-sse
-POM_PACKAGING=jar
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.kt b/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.kt
deleted file mode 100644
index 1d72013c2f..0000000000
--- a/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.kt
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.sse
-
-import okhttp3.Call
-import okhttp3.Callback
-import okhttp3.EventListener
-import okhttp3.OkHttpClient
-import okhttp3.Request
-import okhttp3.Response
-import okhttp3.ResponseBody
-import okhttp3.internal.EMPTY_RESPONSE
-import okhttp3.internal.connection.Exchange
-import okhttp3.sse.EventSource
-import okhttp3.sse.EventSourceListener
-import java.io.IOException
-
-class RealEventSource(
-  private val request: Request,
-  private val listener: EventSourceListener
-) : EventSource, ServerSentEventReader.Callback, Callback {
-  private lateinit var call: Call
-
-  fun connect(client: OkHttpClient) {
-    val client = client.newBuilder()
-        .eventListener(EventListener.NONE)
-        .build()
-    call = client.newCall(request)
-    call.enqueue(this)
-  }
-
-  override fun onResponse(call: Call, response: Response) {
-    processResponse(response)
-  }
-
-  fun processResponse(response: Response) {
-    response.use {
-      if (!response.isSuccessful) {
-        listener.onFailure(this, null, response)
-        return
-      }
-
-      val body = response.body!!
-
-      if (!body.isEventStream()) {
-        listener.onFailure(this,
-            IllegalStateException("Invalid content-type: ${body.contentType()}"), response)
-        return
-      }
-
-      // This is a long-lived response. Cancel full-call timeouts.
-      Exchange.get(response)?.timeoutEarlyExit()
-
-      // Replace the body with an empty one so the callbacks can't see real data.
-      val response = response.newBuilder()
-          .body(EMPTY_RESPONSE)
-          .build()
-
-      val reader = ServerSentEventReader(body.source(), this)
-      try {
-        listener.onOpen(this, response)
-        while (reader.processNextEvent()) {
-        }
-      } catch (e: Exception) {
-        listener.onFailure(this, e, response)
-        return
-      }
-      listener.onClosed(this)
-    }
-  }
-
-  private fun ResponseBody.isEventStream(): Boolean {
-    val contentType = contentType() ?: return false
-    return contentType.type == "text" && contentType.subtype == "event-stream"
-  }
-
-  override fun onFailure(call: Call, e: IOException) {
-    listener.onFailure(this, e, null)
-  }
-
-  override fun request(): Request = request
-
-  override fun cancel() {
-    call.cancel()
-  }
-
-  override fun onEvent(id: String?, type: String?, data: String) {
-    listener.onEvent(this, id, type, data)
-  }
-
-  override fun onRetryChange(timeMs: Long) {
-    // Ignored. We do not auto-retry.
-  }
-}
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.kt b/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.kt
deleted file mode 100644
index ca2ee2e1e9..0000000000
--- a/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.kt
+++ /dev/null
@@ -1,158 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.sse
-
-import okhttp3.internal.toLongOrDefault
-import okio.Buffer
-import okio.BufferedSource
-import okio.ByteString.Companion.encodeUtf8
-import okio.Options
-import java.io.IOException
-
-class ServerSentEventReader(
-  private val source: BufferedSource,
-  private val callback: Callback
-) {
-  private var lastId: String? = null
-
-  interface Callback {
-    fun onEvent(id: String?, type: String?, data: String)
-    fun onRetryChange(timeMs: Long)
-  }
-
-  /**
-   * Process the next event. This will result in a single call to [Callback.onEvent] *unless* the
-   * data section was empty. Any number of calls to [Callback.onRetryChange] may occur while
-   * processing an event.
-   *
-   * @return false when EOF is reached
-   */
-  @Throws(IOException::class)
-  fun processNextEvent(): Boolean {
-    var id = lastId
-    var type: String? = null
-    val data = Buffer()
-
-    while (true) {
-      when (source.select(options)) {
-        in 0..2 -> {
-          completeEvent(id, type, data)
-          return true
-        }
-
-        in 3..4 -> {
-          source.readData(data)
-        }
-
-        in 5..7 -> {
-          data.writeByte('\n'.toInt()) // 'data' on a line of its own.
-        }
-
-        in 8..9 -> {
-          id = source.readUtf8LineStrict().takeIf { it.isNotEmpty() }
-        }
-
-        in 10..12 -> {
-          id = null // 'id' on a line of its own.
-        }
-
-        in 13..14 -> {
-          type = source.readUtf8LineStrict().takeIf { it.isNotEmpty() }
-        }
-
-        in 15..17 -> {
-          type = null // 'event' on a line of its own
-        }
-
-        in 18..19 -> {
-          val retryMs = source.readRetryMs()
-          if (retryMs != -1L) {
-            callback.onRetryChange(retryMs)
-          }
-        }
-
-        -1 -> {
-          val lineEnd = source.indexOfElement(CRLF)
-          if (lineEnd != -1L) {
-            // Skip the line and newline
-            source.skip(lineEnd)
-            source.select(options)
-          } else {
-            return false // No more newlines.
-          }
-        }
-
-        else -> throw AssertionError()
-      }
-    }
-  }
-
-  @Throws(IOException::class)
-  private fun completeEvent(id: String?, type: String?, data: Buffer) {
-    if (data.size != 0L) {
-      lastId = id
-      data.skip(1L) // Leading newline.
-      callback.onEvent(id, type, data.readUtf8())
-    }
-  }
-
-  companion object {
-    val options = Options.of(
-        /*  0 */ "\r\n".encodeUtf8(),
-        /*  1 */ "\r".encodeUtf8(),
-        /*  2 */ "\n".encodeUtf8(),
-
-        /*  3 */ "data: ".encodeUtf8(),
-        /*  4 */ "data:".encodeUtf8(),
-
-        /*  5 */ "data\r\n".encodeUtf8(),
-        /*  6 */ "data\r".encodeUtf8(),
-        /*  7 */ "data\n".encodeUtf8(),
-
-        /*  8 */ "id: ".encodeUtf8(),
-        /*  9 */ "id:".encodeUtf8(),
-
-        /* 10 */ "id\r\n".encodeUtf8(),
-        /* 11 */ "id\r".encodeUtf8(),
-        /* 12 */ "id\n".encodeUtf8(),
-
-        /* 13 */ "event: ".encodeUtf8(),
-        /* 14 */ "event:".encodeUtf8(),
-
-        /* 15 */ "event\r\n".encodeUtf8(),
-        /* 16 */ "event\r".encodeUtf8(),
-        /* 17 */ "event\n".encodeUtf8(),
-
-        /* 18 */ "retry: ".encodeUtf8(),
-        /* 19 */ "retry:".encodeUtf8()
-    )
-
-    private val CRLF = "\r\n".encodeUtf8()
-
-    @Throws(IOException::class)
-    private fun BufferedSource.readData(data: Buffer) {
-      data.writeByte('\n'.toInt())
-      readFully(data, indexOfElement(CRLF))
-      select(options) // Skip the newline bytes.
-    }
-
-    @Throws(IOException::class)
-    private fun BufferedSource.readRetryMs(): Long {
-      val retryString = readUtf8LineStrict()
-      return retryString.toLongOrDefault(-1L)
-    }
-  }
-}
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/EventSource.kt b/okhttp-sse/src/main/java/okhttp3/sse/EventSource.kt
deleted file mode 100644
index 38174e1ab0..0000000000
--- a/okhttp-sse/src/main/java/okhttp3/sse/EventSource.kt
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.sse
-
-import okhttp3.Request
-
-interface EventSource {
-  /** Returns the original request that initiated this event source. */
-  fun request(): Request
-
-  /**
-   * Immediately and violently release resources held by this event source. This does nothing if
-   * the event source has already been closed or canceled.
-   */
-  fun cancel()
-
-  interface Factory {
-    /**
-     * Creates a new event source and immediately returns it. Creating an event source initiates an
-     * asynchronous process to connect the socket. Once that succeeds or fails, `listener` will be
-     * notified. The caller must cancel the returned event source when it is no longer in use.
-     */
-    fun newEventSource(request: Request, listener: EventSourceListener): EventSource
-  }
-}
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/EventSourceListener.kt b/okhttp-sse/src/main/java/okhttp3/sse/EventSourceListener.kt
deleted file mode 100644
index cf24ab51c4..0000000000
--- a/okhttp-sse/src/main/java/okhttp3/sse/EventSourceListener.kt
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.sse
-
-import okhttp3.Response
-
-abstract class EventSourceListener {
-  /**
-   * Invoked when an event source has been accepted by the remote peer and may begin transmitting
-   * events.
-   */
-  open fun onOpen(eventSource: EventSource, response: Response) {
-  }
-
-  /**
-   * TODO description.
-   */
-  open fun onEvent(eventSource: EventSource, id: String?, type: String?, data: String) {
-  }
-
-  /**
-   * TODO description.
-   *
-   * No further calls to this listener will be made.
-   */
-  open fun onClosed(eventSource: EventSource) {
-  }
-
-  /**
-   * Invoked when an event source has been closed due to an error reading from or writing to the
-   * network. Incoming events may have been lost. No further calls to this listener will be made.
-   */
-  open fun onFailure(eventSource: EventSource, t: Throwable?, response: Response?) {
-  }
-}
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/EventSources.kt b/okhttp-sse/src/main/java/okhttp3/sse/EventSources.kt
deleted file mode 100644
index e7297a500c..0000000000
--- a/okhttp-sse/src/main/java/okhttp3/sse/EventSources.kt
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.sse
-
-import okhttp3.OkHttpClient
-import okhttp3.Request
-import okhttp3.Response
-import okhttp3.internal.sse.RealEventSource
-
-object EventSources {
-  @JvmStatic
-  fun createFactory(client: OkHttpClient): EventSource.Factory {
-    return object : EventSource.Factory {
-      override fun newEventSource(request: Request, listener: EventSourceListener): EventSource {
-        return RealEventSource(request, listener).apply {
-          connect(client)
-        }
-      }
-    }
-  }
-
-  @JvmStatic
-  fun processResponse(response: Response, listener: EventSourceListener) {
-    val eventSource = RealEventSource(response.request, listener)
-    eventSource.processResponse(response)
-  }
-}
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java
deleted file mode 100644
index fade2b978a..0000000000
--- a/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.sse;
-
-import java.util.Objects;
-import javax.annotation.Nullable;
-
-final class Event {
-  final @Nullable String id;
-  final @Nullable String type;
-  final String data;
-
-  Event(@Nullable String id, @Nullable String type, String data) {
-    if (data == null) throw new NullPointerException("data == null");
-    this.id = id;
-    this.type = type;
-    this.data = data;
-  }
-
-  @Override public String toString() {
-    return "Event{id='" + id + "', type='" + type + "', data='" + data + "'}";
-  }
-
-  @Override public boolean equals(Object o) {
-    if (this == o) return true;
-    if (!(o instanceof Event)) return false;
-    Event other = (Event) o;
-    return Objects.equals(id, other.id)
-        && Objects.equals(type, other.type)
-        && data.equals(other.data);
-  }
-
-  @Override public int hashCode() {
-    int result = Objects.hashCode(id);
-    result = 31 * result + Objects.hashCode(type);
-    result = 31 * result + data.hashCode();
-    return result;
-  }
-}
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
deleted file mode 100644
index d96f38e84d..0000000000
--- a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.sse;
-
-import java.util.concurrent.TimeUnit;
-import okhttp3.OkHttpClient;
-import okhttp3.OkHttpClientTestRule;
-import okhttp3.Request;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.sse.EventSource;
-import okhttp3.sse.EventSources;
-import org.junit.After;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class EventSourceHttpTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  private final EventSourceRecorder listener = new EventSourceRecorder();
-  private OkHttpClient client = clientTestRule.newClient();
-
-  @After public void after() {
-    listener.assertExhausted();
-  }
-
-  @Test public void event() {
-    server.enqueue(new MockResponse().setBody(""
-        + "data: hey\n"
-        + "\n").setHeader("content-type", "text/event-stream"));
-
-    EventSource source = newEventSource();
-
-    assertThat(source.request().url().encodedPath()).isEqualTo("/");
-
-    listener.assertOpen();
-    listener.assertEvent(null, null, "hey");
-    listener.assertClose();
-  }
-
-  @Test public void badContentType() {
-    server.enqueue(new MockResponse().setBody(""
-        + "data: hey\n"
-        + "\n").setHeader("content-type", "text/plain"));
-
-    EventSource source = newEventSource();
-    listener.assertFailure("Invalid content-type: text/plain");
-  }
-
-  @Test public void badResponseCode() {
-    server.enqueue(new MockResponse().setBody(""
-        + "data: hey\n"
-        + "\n").setHeader("content-type", "text/event-stream").setResponseCode(401));
-
-    EventSource source = newEventSource();
-    listener.assertFailure(null);
-  }
-
-  @Test public void fullCallTimeoutDoesNotApplyOnceConnected() throws Exception {
-    client = client.newBuilder()
-        .callTimeout(250, TimeUnit.MILLISECONDS)
-        .build();
-
-    server.enqueue(new MockResponse()
-        .setBodyDelay(500, TimeUnit.MILLISECONDS)
-        .setHeader("content-type", "text/event-stream")
-        .setBody("data: hey\n\n"));
-
-    EventSource source = newEventSource();
-
-    assertThat(source.request().url().encodedPath()).isEqualTo("/");
-
-    listener.assertOpen();
-    listener.assertEvent(null, null, "hey");
-    listener.assertClose();
-  }
-
-  @Test public void fullCallTimeoutAppliesToSetup() throws Exception {
-    client = client.newBuilder()
-        .callTimeout(250, TimeUnit.MILLISECONDS)
-        .build();
-
-    server.enqueue(new MockResponse()
-        .setHeadersDelay(500, TimeUnit.MILLISECONDS)
-        .setHeader("content-type", "text/event-stream")
-        .setBody("data: hey\n\n"));
-
-    newEventSource();
-    listener.assertFailure("timeout");
-  }
-
-  private EventSource newEventSource() {
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    EventSource.Factory factory = EventSources.createFactory(client);
-    return factory.newEventSource(request, listener);
-  }
-}
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java
deleted file mode 100644
index c96672d273..0000000000
--- a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.sse;
-
-import java.io.IOException;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.LinkedBlockingDeque;
-import javax.annotation.Nullable;
-import okhttp3.Response;
-import okhttp3.internal.platform.Platform;
-import okhttp3.sse.EventSource;
-import okhttp3.sse.EventSourceListener;
-
-import static java.util.concurrent.TimeUnit.SECONDS;
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class EventSourceRecorder extends EventSourceListener {
-  private final BlockingQueue<Object> events = new LinkedBlockingDeque<>();
-
-  @Override public void onOpen(EventSource eventSource, Response response) {
-    Platform.get().log("[ES] onOpen", Platform.INFO, null);
-    events.add(new Open(eventSource, response));
-  }
-
-  @Override public void onEvent(EventSource eventSource, @Nullable String id, @Nullable String type,
-      String data) {
-    Platform.get().log("[ES] onEvent", Platform.INFO, null);
-    events.add(new Event(id, type, data));
-  }
-
-  @Override public void onClosed(EventSource eventSource) {
-    Platform.get().log("[ES] onClosed", Platform.INFO, null);
-    events.add(new Closed());
-  }
-
-  @Override
-  public void onFailure(EventSource eventSource, @Nullable Throwable t, @Nullable Response response) {
-    Platform.get().log("[ES] onFailure", Platform.INFO, t);
-    events.add(new Failure(t, response));
-  }
-
-  private Object nextEvent() {
-    try {
-      Object event = events.poll(10, SECONDS);
-      if (event == null) {
-        throw new AssertionError("Timed out waiting for event.");
-      }
-      return event;
-    } catch (InterruptedException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  public void assertExhausted() {
-    assertThat(events).isEmpty();
-  }
-
-  public void assertEvent(@Nullable String id, @Nullable String type, String data) {
-    Object actual = nextEvent();
-    assertThat(actual).isEqualTo(new Event(id, type, data));
-  }
-
-  public EventSource assertOpen() {
-    Object event = nextEvent();
-    if (!(event instanceof Open)) {
-      throw new AssertionError("Expected Open but was " + event);
-    }
-    return ((Open) event).eventSource;
-  }
-
-  public void assertClose() {
-    Object event = nextEvent();
-    if (!(event instanceof Closed)) {
-      throw new AssertionError("Expected Open but was " + event);
-    }
-  }
-
-  public void assertFailure(@Nullable String message) {
-    Object event = nextEvent();
-    if (!(event instanceof Failure)) {
-      throw new AssertionError("Expected Failure but was " + event);
-    }
-    if (message != null) {
-      assertThat(((Failure) event).t.getMessage()).isEqualTo(message);
-    } else {
-      assertThat(((Failure) event).t).isNull();
-    }
-  }
-
-  static final class Open {
-    final EventSource eventSource;
-    final Response response;
-
-    Open(EventSource eventSource, Response response) {
-      this.eventSource = eventSource;
-      this.response = response;
-    }
-
-    @Override public String toString() {
-      return "Open[" + response + ']';
-    }
-  }
-
-  static final class Failure {
-    final Throwable t;
-    final Response response;
-    final String responseBody;
-
-    Failure(Throwable t, Response response) {
-      this.t = t;
-      this.response = response;
-      String responseBody = null;
-      if (response != null) {
-        try {
-          responseBody = response.body().string();
-        } catch (IOException ignored) {
-        }
-      }
-      this.responseBody = responseBody;
-    }
-
-    @Override public String toString() {
-      if (response == null) {
-        return "Failure[" + t + "]";
-      }
-      return "Failure[" + response + "]";
-    }
-  }
-
-  static final class Closed {
-    @Override public String toString() {
-      return "Closed[]";
-    }
-  }
-}
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java
deleted file mode 100644
index e837e0e42c..0000000000
--- a/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java
+++ /dev/null
@@ -1,226 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.sse;
-
-import java.io.IOException;
-import java.util.ArrayDeque;
-import java.util.Deque;
-import javax.annotation.Nullable;
-import okio.Buffer;
-import org.junit.After;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class ServerSentEventIteratorTest {
-  /** Either {@link Event} or {@link Long} items for events and retry changes, respectively. */
-  private final Deque<Object> callbacks = new ArrayDeque<>();
-
-  @After public void after() {
-    assertThat(callbacks).isEmpty();
-  }
-
-  @Test public void multiline() throws IOException {
-    consumeEvents(""
-        + "data: YHOO\n"
-        + "data: +2\n"
-        + "data: 10\n"
-        + "\n");
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "YHOO\n+2\n10"));
-  }
-
-  @Test public void multilineCr() throws IOException {
-    consumeEvents(""
-        + "data: YHOO\r"
-        + "data: +2\r"
-        + "data: 10\r"
-        + "\r");
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "YHOO\n+2\n10"));
-  }
-
-  @Test public void multilineCrLf() throws IOException {
-    consumeEvents(""
-        + "data: YHOO\r\n"
-        + "data: +2\r\n"
-        + "data: 10\r\n"
-        + "\r\n");
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "YHOO\n+2\n10"));
-  }
-
-  @Test public void eventType() throws IOException {
-    consumeEvents(""
-        + "event: add\n"
-        + "data: 73857293\n"
-        + "\n"
-        + "event: remove\n"
-        + "data: 2153\n"
-        + "\n"
-        + "event: add\n"
-        + "data: 113411\n"
-        + "\n");
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, "add", "73857293"));
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, "remove", "2153"));
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, "add", "113411"));
-  }
-
-  @Test public void commentsIgnored() throws IOException {
-    consumeEvents(""
-        + ": test stream\n"
-        + "\n"
-        + "data: first event\n"
-        + "id: 1\n"
-        + "\n");
-    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "first event"));
-  }
-
-  @Test public void idCleared() throws IOException {
-    consumeEvents(""
-        + "data: first event\n"
-        + "id: 1\n"
-        + "\n"
-        + "data: second event\n"
-        + "id\n"
-        + "\n"
-        + "data: third event\n"
-        + "\n");
-    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "first event"));
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "second event"));
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "third event"));
-  }
-
-  @Test public void nakedFieldNames() throws IOException {
-    consumeEvents(""
-        + "data\n"
-        + "\n"
-        + "data\n"
-        + "data\n"
-        + "\n"
-        + "data:\n");
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, ""));
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "\n"));
-  }
-
-  @Test public void colonSpaceOptional() throws IOException {
-    consumeEvents(""
-        + "data:test\n"
-        + "\n"
-        + "data: test\n"
-        + "\n");
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "test"));
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "test"));
-  }
-
-  @Test public void leadingWhitespace() throws IOException {
-    consumeEvents(""
-        + "data:  test\n"
-        + "\n");
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, " test"));
-  }
-
-  @Test public void idReusedAcrossEvents() throws IOException {
-    consumeEvents(""
-        + "data: first event\n"
-        + "id: 1\n"
-        + "\n"
-        + "data: second event\n"
-        + "\n"
-        + "id: 2\n"
-        + "data: third event\n"
-        + "\n");
-    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "first event"));
-    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "second event"));
-    assertThat(callbacks.remove()).isEqualTo(new Event("2", null, "third event"));
-  }
-
-  @Test public void idIgnoredFromEmptyEvent() throws IOException {
-    consumeEvents(""
-        + "data: first event\n"
-        + "id: 1\n"
-        + "\n"
-        + "id: 2\n"
-        + "\n"
-        + "data: second event\n"
-        + "\n");
-    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "first event"));
-    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "second event"));
-  }
-
-  @Test public void retry() throws IOException {
-    consumeEvents(""
-        + "retry: 22\n"
-        + "\n"
-        + "data: first event\n"
-        + "id: 1\n"
-        + "\n");
-    assertThat(callbacks.remove()).isEqualTo(22L);
-    assertThat(callbacks.remove()).isEqualTo(new Event("1", null, "first event"));
-  }
-
-  @Test public void retryInvalidFormatIgnored() throws IOException {
-    consumeEvents(""
-        + "retry: 22\n"
-        + "\n"
-        + "retry: hey"
-        + "\n");
-    assertThat(callbacks.remove()).isEqualTo(22L);
-  }
-
-  @Test public void namePrefixIgnored() throws IOException {
-    consumeEvents(""
-        + "data: a\n"
-        + "eventually\n"
-        + "database\n"
-        + "identity\n"
-        + "retrying\n"
-        + "\n");
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "a"));
-  }
-
-  @Test public void nakedNameClearsIdAndTypeAppendsData() throws IOException {
-    consumeEvents(""
-        + "id: a\n"
-        + "event: b\n"
-        + "data: c\n"
-        + "id\n"
-        + "event\n"
-        + "data\n"
-        + "\n");
-    assertThat(callbacks.remove()).isEqualTo(new Event(null, null, "c\n"));
-  }
-
-  @Test public void nakedRetryIgnored() throws IOException {
-    consumeEvents(""
-        + "retry\n"
-        + "\n");
-    assertThat(callbacks).isEmpty();
-  }
-
-  private void consumeEvents(String source) throws IOException {
-    ServerSentEventReader.Callback callback = new ServerSentEventReader.Callback() {
-      @Override public void onEvent(@Nullable String id, @Nullable String type, String data) {
-        callbacks.add(new Event(id, type, data));
-      }
-      @Override public void onRetryChange(long timeMs) {
-        callbacks.add(timeMs);
-      }
-    };
-    Buffer buffer = new Buffer().writeUtf8(source);
-    ServerSentEventReader reader = new ServerSentEventReader(buffer, callback);
-    while (reader.processNextEvent());
-    assertThat(buffer.size()).overridingErrorMessage("Unconsumed buffer: " + buffer.readUtf8())
-        .isEqualTo(0);
-  }
-}
diff --git a/okhttp-tls/Module.md b/okhttp-tls/Module.md
deleted file mode 100644
index b97773f31b..0000000000
--- a/okhttp-tls/Module.md
+++ /dev/null
@@ -1,3 +0,0 @@
-# Module okhttp-tls
-
-OkHttp Transport Layer Security (TLS) library.
diff --git a/okhttp-tls/README.md b/okhttp-tls/README.md
deleted file mode 100644
index 52a4bfc321..0000000000
--- a/okhttp-tls/README.md
+++ /dev/null
@@ -1,236 +0,0 @@
-OkHttp TLS
-==========
-
-Approachable APIs for using TLS.
-
-A [`HeldCertificate`][held_certificate] is a certificate and its private key. Use the
-[builder][held_certificate_builder] to create a self-signed certificate that a test server can use
-for HTTPS:
-
-```java
-String localhost = InetAddress.getByName("localhost").getCanonicalHostName();
-HeldCertificate localhostCertificate = new HeldCertificate.Builder()
-    .addSubjectAlternativeName(localhost)
-    .build();
-```
-
-[`HandshakeCertificates`][handshake_certificates] keeps the certificates for a TLS handshake.
-Use its [builder][handshake_certificates_builder] to define which certificates the HTTPS server
-returns to its clients. The returned instance can create an `SSLSocketFactory` that implements this
-policy:
-
-```java
-HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
-    .heldCertificate(localhostCertificate)
-    .build();
-MockWebServer server = new MockWebServer();
-server.useHttps(serverCertificates.sslSocketFactory(), false);
-```
-
-`HandshakeCertificates` also works for clients where its job is to define which root certificates
-to trust. In this simplified example we trust the server's self-signed certificate:
-
-```java
-HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
-    .addTrustedCertificate(localhostCertificate.certificate())
-    .build();
-OkHttpClient client = new OkHttpClient.Builder()
-    .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
-    .build();
-```
-
-With a server that holds a certificate and a client that trusts it we have enough for an HTTPS
-handshake. The best part of this example is that we don't need to make our test code insecure with a
-a fake `HostnameVerifier` or `X509TrustManager`.
-
-Certificate Authorities
------------------------
-
-The above example uses a self-signed certificate. This is convenient for testing but not
-representative of real-world HTTPS deployment. To get closer to that we can use `HeldCertificate`
-to generate a trusted root certificate, an intermediate certificate, and a server certificate.
-We use `certificateAuthority(int)` to create certificates that can sign other certificates. The
-int specifies how many intermediate certificates are allowed beneath it in the chain.
-
-```java
-HeldCertificate rootCertificate = new HeldCertificate.Builder()
-    .certificateAuthority(1)
-    .build();
-
-HeldCertificate intermediateCertificate = new HeldCertificate.Builder()
-    .certificateAuthority(0)
-    .signedBy(rootCertificate)
-    .build();
-
-String localhost = InetAddress.getByName("localhost").getCanonicalHostName();
-HeldCertificate serverCertificate = new HeldCertificate.Builder()
-    .addSubjectAlternativeName(localhost)
-    .signedBy(intermediateCertificate)
-    .build();
-```
-
-To serve this configuration the server needs to provide its clients with a chain of certificates
-starting with its own and including everything up-to but not including the root. We don't need to
-include root certificates because the client already has them.
-
-```java
-HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
-    .heldCertificate(serverCertificate, intermediateCertificate.certificate())
-    .build();
-```
-
-The client only needs to know the trusted root certificate. It checks the server's certificate by
-validating the signatures within the chain.
-
-```java
-HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
-    .addTrustedCertificate(rootCertificate.certificate())
-    .build();
-OkHttpClient client = new OkHttpClient.Builder()
-    .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
-    .build();
-```
-
-Client Authentication
----------------------
-
-The above scenario is representative of most TLS set ups: the client uses certificates to validate
-the identity of a server. The converse is also possible. Here we create a server that authenticates
-a client and a client that authenticates a server.
-
-```java
-// Create the root for client and server to trust. We could also use different roots for each!
-HeldCertificate rootCertificate = new HeldCertificate.Builder()
-    .certificateAuthority(0)
-    .build();
-
-// Create a server certificate and a server that uses it.
-HeldCertificate serverCertificate = new HeldCertificate.Builder()
-    .commonName("ingen")
-    .addSubjectAlternativeName(server.getHostName())
-    .signedBy(rootCertificate)
-    .build();
-HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
-    .addTrustedCertificate(rootCertificate.certificate())
-    .heldCertificate(serverCertificate)
-    .build();
-MockWebServer server = new MockWebServer();
-server.useHttps(serverCertificates.sslSocketFactory(), false);
-server.requestClientAuth();
-server.enqueue(new MockResponse());
-
-// Create a client certificate and a client that uses it.
-HeldCertificate clientCertificate = new HeldCertificate.Builder()
-    .commonName("ianmalcolm")
-    .signedBy(rootCertificate)
-    .build();
-HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
-    .addTrustedCertificate(rootCertificate.certificate())
-    .heldCertificate(clientCertificate)
-    .build();
-OkHttpClient client = new OkHttpClient.Builder()
-    .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
-    .build();
-
-// Connect 'em all together. Certificates are exchanged in the handshake.
-Call call = client.newCall(new Request.Builder()
-    .url(server.url("/"))
-    .build());
-Response response = call.execute();
-System.out.println(response.handshake().peerPrincipal());
-RecordedRequest recordedRequest = server.takeRequest();
-System.out.println(recordedRequest.getHandshake().peerPrincipal());
-```
-
-This handshake is successful because each party has prearranged to trust the root certificate that
-signs the other party's chain.
-
-Well-Known Certificate Authorities
-----------------------------------
-
-In these examples we've prearranged which root certificates to trust. But for regular HTTPS on the
-Internet this set of trusted root certificates is usually provided by default by the host platform.
-Such a set typically includes many root certificates from well-known certificate authorities like
-Entrust and Verisign.
-
-This is the behavior you'll get with your OkHttpClient if you don't specifically configure
-`HandshakeCertificates`. Or you can do it explicitly with `addPlatformTrustedCertificates()`:
-
-```java
-HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
-    .addPlatformTrustedCertificates()
-    .build();
-OkHttpClient client = new OkHttpClient.Builder()
-    .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
-    .build();
-```
-
-PEM files
----------
-
-You can encode a `HeldCertificate` in PEM format:
-
-```java
-HeldCertificate heldCertificate = ...
-System.out.println(heldCertificate.certificatePem())
-```
-
-```
------BEGIN CERTIFICATE-----
-MIIBSjCB8aADAgECAgEBMAoGCCqGSM49BAMCMC8xLTArBgNVBAMTJDJiYWY3NzVl
-LWE4MzUtNDM5ZS1hYWE2LTgzNmNiNDlmMGM3MTAeFw0xODA3MTMxMjA0MzJaFw0x
-ODA3MTQxMjA0MzJaMC8xLTArBgNVBAMTJDJiYWY3NzVlLWE4MzUtNDM5ZS1hYWE2
-LTgzNmNiNDlmMGM3MTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABDmlOiZ3dxA2
-zw1KwqGNsKVUZbkUVj5cxV1jDbSTvTlOjSj6LR0Ovys9RFdrjcbbMLWvSvMQgHch
-k8Q50c6Kb34wCgYIKoZIzj0EAwIDSAAwRQIhAJkXiCbIR3zxuH5SQR5PEAPJ+ntg
-msOSMaAKwAePESf+AiBlxbEu6YpHt1ZJoAhMAv6raYnwSp/A94eJGlJynQ0igQ==
------END CERTIFICATE-----
-```
-
-You can also do so with the private key. Be careful with these!
-
-```java
-HeldCertificate heldCertificate = ...
-System.out.println(heldCertificate.privateKeyPkcs8Pem())
-```
-
-```
------BEGIN PRIVATE KEY-----
-MIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQgQbYDQiewSnregm9e
-IjXEHQgc6w3ELHdnH1houEUom9CgCgYIKoZIzj0DAQehRANCAAQ5pTomd3cQNs8N
-SsKhjbClVGW5FFY+XMVdYw20k705To0o+i0dDr8rPURXa43G2zC1r0rzEIB3IZPE
-OdHOim9+
------END PRIVATE KEY-----
-```
-
-Recommendations
----------------
-
-Typically servers need a held certificate plus a chain of intermediates. Servers only need the
-private key for their own certificate. The chain served by a server doesn't need the root
-certificate.
-
-The trusted roots don't need to be the same for client and server when using client authentication.
-Clients might rely on the platform certificates and servers might use a private
-organization-specific certificate authority.
-
-By default `HeldCertificate` instances expire after 24 hours. Use `duration()` to adjust.
-
-By default server certificates need to identify which hostnames they're trusted for. You may add as
-many as necessary with `addSubjectAlternativeName()`. This mechanism also supports a very limited
-form of wildcards `*.example.com` where the `*` must be first and doesn't match nested subdomains.
-
-By default certificates use fast and secure 256-bit ECDSA keys. For interoperability with very old
-clients use `HeldCertificate.Builder.rsa2048()`.
-
-Download
---------
-
-```kotlin
-implementation("com.squareup.okhttp3:okhttp-tls:4.2.1")
-```
-
- [held_certificate]: http://square.github.io/okhttp/4.x/okhttp-tls/okhttp3.tls/-held-certificate/
- [held_certificate_builder]: http://square.github.io/okhttp/4.x/okhttp-tls/okhttp3.tls/-held-certificate/-builder/
- [handshake_certificates]: http://square.github.io/okhttp/4.x/okhttp-tls/okhttp3.tls/-handshake-certificates/
- [handshake_certificates_builder]: http://square.github.io/okhttp/4.x/okhttp-tls/okhttp3.tls/-handshake-certificates/-builder/
diff --git a/okhttp-tls/build.gradle b/okhttp-tls/build.gradle
deleted file mode 100644
index b3847c6368..0000000000
--- a/okhttp-tls/build.gradle
+++ /dev/null
@@ -1,67 +0,0 @@
-apply plugin: 'com.vanniktech.maven.publish'
-apply plugin: 'me.champeau.gradle.japicmp'
-
-jar {
-  manifest {
-    attributes('Automatic-Module-Name': 'okhttp3.tls')
-  }
-}
-
-dependencies {
-  api deps.okio
-  implementation project(':okhttp')
-  implementation deps.bouncycastle
-  compileOnly deps.jsr305
-
-}
-
-afterEvaluate { project ->
-  project.tasks.dokka {
-    outputDirectory = "$rootDir/docs/4.x"
-    outputFormat = 'gfm'
-  }
-}
-
-task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
-  oldClasspath = files(baselineJar(project, baselineVersion))
-  newClasspath = files(jar.archivePath)
-  onlyBinaryIncompatibleModified = true
-  failOnModification = true
-  txtOutputFile = file("$buildDir/reports/japi.txt")
-  ignoreMissingClasses = true
-  includeSynthetic = true
-  packageExcludes = [
-      'okhttp3.tls.internal',
-  ]
-  methodExcludes = [
-      // Became 'final' in 4.0.0:
-      'okhttp3.tls.HandshakeCertificates#keyManager()',
-      'okhttp3.tls.HandshakeCertificates#sslContext()',
-      'okhttp3.tls.HandshakeCertificates#sslSocketFactory()',
-      'okhttp3.tls.HandshakeCertificates#trustManager()',
-      'okhttp3.tls.HandshakeCertificates$Builder#addPlatformTrustedCertificates()',
-      'okhttp3.tls.HandshakeCertificates$Builder#addTrustedCertificate(java.security.cert.X509Certificate)',
-      'okhttp3.tls.HandshakeCertificates$Builder#build()',
-      'okhttp3.tls.HandshakeCertificates$Builder#heldCertificate(okhttp3.tls.HeldCertificate, java.security.cert.X509Certificate\\[\\])',
-      'okhttp3.tls.HeldCertificate#certificate()',
-      'okhttp3.tls.HeldCertificate#certificatePem()',
-      'okhttp3.tls.HeldCertificate#keyPair()',
-      'okhttp3.tls.HeldCertificate#privateKeyPkcs1Pem()',
-      'okhttp3.tls.HeldCertificate#privateKeyPkcs8Pem()',
-      'okhttp3.tls.HeldCertificate$Builder#addSubjectAlternativeName(java.lang.String)',
-      'okhttp3.tls.HeldCertificate$Builder#build()',
-      'okhttp3.tls.HeldCertificate$Builder#certificateAuthority(int)',
-      'okhttp3.tls.HeldCertificate$Builder#commonName(java.lang.String)',
-      'okhttp3.tls.HeldCertificate$Builder#duration(long, java.util.concurrent.TimeUnit)',
-      'okhttp3.tls.HeldCertificate$Builder#ecdsa256()',
-      'okhttp3.tls.HeldCertificate$Builder#keyPair(java.security.KeyPair)',
-      'okhttp3.tls.HeldCertificate$Builder#keyPair(java.security.PublicKey, java.security.PrivateKey)',
-      'okhttp3.tls.HeldCertificate$Builder#organizationalUnit(java.lang.String)',
-      'okhttp3.tls.HeldCertificate$Builder#rsa2048()',
-      'okhttp3.tls.HeldCertificate$Builder#serialNumber(java.math.BigInteger)',
-      'okhttp3.tls.HeldCertificate$Builder#serialNumber(long)',
-      'okhttp3.tls.HeldCertificate$Builder#signedBy(okhttp3.tls.HeldCertificate)',
-      'okhttp3.tls.HeldCertificate$Builder#validityInterval(long, long)',
-  ]
-}
-check.dependsOn(japicmp)
diff --git a/okhttp-tls/gradle.properties b/okhttp-tls/gradle.properties
deleted file mode 100644
index 7ed0a3b63a..0000000000
--- a/okhttp-tls/gradle.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-POM_ARTIFACT_ID=okhttp-tls
-POM_NAME=okhttp-tls
-POM_PACKAGING=jar
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.kt b/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.kt
deleted file mode 100644
index a9859a241d..0000000000
--- a/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.kt
+++ /dev/null
@@ -1,149 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.tls
-
-import okhttp3.CertificatePinner
-import okhttp3.internal.platform.Platform
-import okhttp3.tls.internal.TlsUtil.newKeyManager
-import okhttp3.tls.internal.TlsUtil.newTrustManager
-import java.security.SecureRandom
-import java.security.cert.X509Certificate
-import java.util.Collections
-import javax.net.ssl.KeyManager
-import javax.net.ssl.SSLContext
-import javax.net.ssl.SSLSocketFactory
-import javax.net.ssl.TrustManager
-import javax.net.ssl.X509KeyManager
-import javax.net.ssl.X509TrustManager
-
-/**
- * Certificates to identify which peers to trust and also to earn the trust of those peers in kind.
- * Client and server exchange these certificates during the handshake phase of a TLS connection.
- *
- * ### Server Authentication
- *
- * This is the most common form of TLS authentication: clients verify that servers are trusted and
- * that they own the hostnames that they represent. Server authentication is required.
- *
- * To perform server authentication:
- *
- *  * The server's handshake certificates must have a [held certificate][HeldCertificate] (a
- *    certificate and its private key). The certificate's subject alternative names must match the
- *    server's hostname. The server must also have is a (possibly-empty) chain of intermediate
- *    certificates to establish trust from a root certificate to the server's certificate. The root
- *    certificate is not included in this chain.
- *  * The client's handshake certificates must include a set of trusted root certificates. They will
- *    be used to authenticate the server's certificate chain. Typically this is a set of well-known
- *    root certificates that is distributed with the HTTP client or its platform. It may be
- *    augmented by certificates private to an organization or service.
- *
- * ### Client Authentication
- *
- * This is authentication of the client by the server during the TLS handshake. Client
- * authentication is optional.
- *
- * To perform client authentication:
- *
- *  * The client's handshake certificates must have a [held certificate][HeldCertificate] (a
- *    certificate and its private key). The client must also have a (possibly-empty) chain of
- *    intermediate certificates to establish trust from a root certificate to the client's
- *    certificate. The root certificate is not included in this chain.
- *  * The server's handshake certificates must include a set of trusted root certificates. They
- *    will be used to authenticate the client's certificate chain. Typically this is not the same
- *    set of root certificates used in server authentication. Instead it will be a small set of
- *    roots private to an organization or service.
- */
-class HandshakeCertificates private constructor(
-  @get:JvmName("keyManager") val keyManager: X509KeyManager,
-  @get:JvmName("trustManager") val trustManager: X509TrustManager
-) {
-
-  @JvmName("-deprecated_keyManager")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "keyManager"),
-      level = DeprecationLevel.ERROR)
-  fun keyManager(): X509KeyManager = keyManager
-
-  @JvmName("-deprecated_trustManager")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "trustManager"),
-      level = DeprecationLevel.ERROR)
-  fun trustManager(): X509TrustManager = trustManager
-
-  fun sslSocketFactory(): SSLSocketFactory = sslContext().socketFactory
-
-  fun sslContext(): SSLContext {
-    return Platform.get().newSSLContext().apply {
-      init(arrayOf<KeyManager>(keyManager), arrayOf<TrustManager>(trustManager), SecureRandom())
-    }
-  }
-
-  class Builder {
-    private var heldCertificate: HeldCertificate? = null
-    private var intermediates: Array<X509Certificate>? = null
-    private val trustedCertificates = mutableListOf<X509Certificate>()
-
-    /**
-     * Configure the certificate chain to use when being authenticated. The first certificate is
-     * the held certificate, further certificates are included in the handshake so the peer can
-     * build a trusted path to a trusted root certificate.
-     *
-     * The chain should include all intermediate certificates but does not need the root certificate
-     * that we expect to be known by the remote peer. The peer already has that certificate so
-     * transmitting it is unnecessary.
-     */
-    fun heldCertificate(
-      heldCertificate: HeldCertificate,
-      vararg intermediates: X509Certificate
-    ) = apply {
-      this.heldCertificate = heldCertificate
-      this.intermediates = arrayOf(*intermediates) // Defensive copy.
-    }
-
-    /**
-     * Add a trusted root certificate to use when authenticating a peer. Peers must provide
-     * a chain of certificates whose root is one of these.
-     */
-    fun addTrustedCertificate(certificate: X509Certificate) = apply {
-      this.trustedCertificates += certificate
-    }
-
-    /**
-     * Add all of the host platform's trusted root certificates. This set varies by platform
-     * (Android vs. Java), by platform release (Android 4.4 vs. Android 9), and with user
-     * customizations.
-     *
-     * Most TLS clients that connect to hosts on the public Internet should call this method.
-     * Otherwise it is necessary to manually prepare a comprehensive set of trusted roots.
-     *
-     * If the host platform is compromised or misconfigured this may contain untrustworthy root
-     * certificates. Applications that connect to a known set of servers may be able to mitigate
-     * this problem with [certificate pinning][CertificatePinner].
-     */
-    fun addPlatformTrustedCertificates() = apply {
-      val platformTrustManager = Platform.get().platformTrustManager()
-      Collections.addAll(trustedCertificates, *platformTrustManager.acceptedIssuers)
-    }
-
-    fun build(): HandshakeCertificates {
-      val keyManager = newKeyManager(null, heldCertificate, *(intermediates ?: emptyArray()))
-      val trustManager = newTrustManager(null, trustedCertificates)
-      return HandshakeCertificates(keyManager, trustManager)
-    }
-  }
-}
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.kt b/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.kt
deleted file mode 100644
index e82a9fde19..0000000000
--- a/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.kt
+++ /dev/null
@@ -1,529 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.tls
-
-import okhttp3.internal.canParseAsIpAddress
-import okio.Buffer
-import okio.ByteString
-import okio.ByteString.Companion.decodeBase64
-import okio.ByteString.Companion.toByteString
-import org.bouncycastle.asn1.ASN1Encodable
-import org.bouncycastle.asn1.DERSequence
-import org.bouncycastle.asn1.pkcs.PrivateKeyInfo
-import org.bouncycastle.asn1.x509.BasicConstraints
-import org.bouncycastle.asn1.x509.GeneralName
-import org.bouncycastle.asn1.x509.X509Extensions
-import org.bouncycastle.jce.provider.BouncyCastleProvider
-import org.bouncycastle.x509.X509V3CertificateGenerator
-import java.math.BigInteger
-import java.security.GeneralSecurityException
-import java.security.KeyFactory
-import java.security.KeyPair
-import java.security.KeyPairGenerator
-import java.security.PrivateKey
-import java.security.PublicKey
-import java.security.SecureRandom
-import java.security.Security
-import java.security.cert.CertificateFactory
-import java.security.cert.X509Certificate
-import java.security.interfaces.ECPublicKey
-import java.security.interfaces.RSAPrivateKey
-import java.security.interfaces.RSAPublicKey
-import java.security.spec.PKCS8EncodedKeySpec
-import java.util.Date
-import java.util.UUID
-import java.util.concurrent.TimeUnit
-import javax.security.auth.x500.X500Principal
-
-/**
- * A certificate and its private key. These are some properties of certificates that are used with
- * TLS:
- *
- *  * **A common name.** This is a string identifier for the certificate. It usually describes the
- *    purpose of the certificate like "Entrust Root Certification Authority - G2" or
- *    "www.squareup.com".
- *
- *  * **A set of hostnames.** These are in the certificate's subject alternative name (SAN)
- *    extension. A subject alternative name is either a literal hostname (`squareup.com`), a literal
- *    IP address (`74.122.190.80`), or a hostname pattern (`*.api.squareup.com`).
- *
- *  * **A validity interval.** A certificate should not be used before its validity interval starts
- *    or after it ends.
- *
- *  * **A public key.** This cryptographic key is used for asymmetric encryption digital signatures.
- *    Note that the private key is not a part of the certificate!
- *
- *  * **A signature issued by another certificate's private key.** This mechanism allows a trusted
- *    third-party to endorse a certificate. Third parties should only endorse certificates once
- *    they've confirmed that the owner of the private key is also the owner of the certificate's
- *    other properties.
- *
- * Certificates are signed by other certificates and a sequence of them is called a certificate
- * chain. The chain terminates in a self-signed "root" certificate. Signing certificates in the
- * middle of the chain are called "intermediates". Organizations that offer certificate signing are
- * called certificate authorities (CAs).
- *
- * Browsers and other HTTP clients need a set of trusted root certificates to authenticate their
- * peers. Sets of root certificates are managed by either the HTTP client (like Firefox), or the
- * host platform (like Android). In July 2018 Android had 134 trusted root certificates for its HTTP
- * clients to trust.
- *
- * For example, in order to establish a secure connection to `https://www.squareup.com/`,
- * these three certificates are used.
- *
- * ```
- * www.squareup.com certificate:
- *
- * Common Name: www.squareup.com
- * Subject Alternative Names: www.squareup.com, squareup.com, account.squareup.com...
- * Validity: 2018-07-03T20:18:17Z  2019-08-01T20:48:15Z
- * Public Key: d107beecc17325f55da976bcbab207ba4df68bd3f8fce7c3b5850311128264fd53e1baa342f58d93...
- * Signature: 1fb0e66fac05322721fe3a3917f7c98dee1729af39c99eab415f22d8347b508acdf0bab91781c3720...
- *
- * signed by intermediate certificate:
- *
- * Common Name: Entrust Certification Authority - L1M
- * Subject Alternative Names: none
- * Validity: 2014-12-15T15:25:03Z  2030-10-15T15:55:03Z
- * Public Key: d081c13923c2b1d1ecf757dd55243691202248f7fcca520ab0ab3f33b5b08407f6df4e7ab0fb9822...
- * Signature: b487c784221a29c0a478ecf54f1bb484976f77eed4cf59afa843962f1d58dea6f3155b2ed9439c4c4...
- *
- * signed by root certificate:
- *
- * Common Name: Entrust Root Certification Authority - G2
- * Subject Alternative Names: none
- * Validity: 2009-07-07T17:25:54Z  2030-12-07T17:55:54Z
- * Public Key: ba84b672db9e0c6be299e93001a776ea32b895411ac9da614e5872cffef68279bf7361060aa527d8...
- * Self-signed Signature: 799f1d96c6b6793f228d87d3870304606a6b9a2e59897311ac43d1f513ff8d392bc0f...
- * ```
- *
- * In this example the HTTP client already knows and trusts the last certificate, "Entrust Root
- * Certification Authority - G2". That certificate is used to verify the signature of the
- * intermediate certificate, "Entrust Certification Authority - L1M". The intermediate certificate
- * is used to verify the signature of the "www.squareup.com" certificate.
- *
- * This roles are reversed for client authentication. In that case the client has a private key and
- * a chain of certificates. The server uses a set of trusted root certificates to authenticate the
- * client. Subject alternative names are not used for client authentication.
- */
-class HeldCertificate(
-  @get:JvmName("keyPair") val keyPair: KeyPair,
-  @get:JvmName("certificate") val certificate: X509Certificate
-) {
-
-  @JvmName("-deprecated_certificate")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "certificate"),
-      level = DeprecationLevel.ERROR)
-  fun certificate(): X509Certificate = certificate
-
-  @JvmName("-deprecated_keyPair")
-  @Deprecated(
-      message = "moved to val",
-      replaceWith = ReplaceWith(expression = "keyPair"),
-      level = DeprecationLevel.ERROR)
-  fun keyPair(): KeyPair = keyPair
-
-  /**
-   * Returns the certificate encoded in [PEM format][rfc_7468].
-   *
-   * [rfc_7468]: https://tools.ietf.org/html/rfc7468
-   */
-  fun certificatePem(): String {
-    return buildString {
-      append("-----BEGIN CERTIFICATE-----\n")
-      encodeBase64Lines(certificate.encoded.toByteString())
-      append("-----END CERTIFICATE-----\n")
-    }
-  }
-
-  /**
-   * Returns the RSA private key encoded in [PKCS #8][rfc_5208] [PEM format][rfc_7468].
-   *
-   * [rfc_5208]: https://tools.ietf.org/html/rfc5208
-   * [rfc_7468]: https://tools.ietf.org/html/rfc7468
-   */
-  fun privateKeyPkcs8Pem(): String {
-    return buildString {
-      append("-----BEGIN PRIVATE KEY-----\n")
-      encodeBase64Lines(keyPair.private.encoded.toByteString())
-      append("-----END PRIVATE KEY-----\n")
-    }
-  }
-
-  /**
-   * Returns the RSA private key encoded in [PKCS #1][rfc_8017] [PEM format][rfc_7468].
-   *
-   * [rfc_8017]: https://tools.ietf.org/html/rfc8017
-   * [rfc_7468]: https://tools.ietf.org/html/rfc7468
-   */
-  fun privateKeyPkcs1Pem(): String {
-    check(keyPair.private is RSAPrivateKey) { "PKCS1 only supports RSA keys" }
-    return buildString {
-      append("-----BEGIN RSA PRIVATE KEY-----\n")
-      encodeBase64Lines(pkcs1Bytes())
-      append("-----END RSA PRIVATE KEY-----\n")
-    }
-  }
-
-  private fun pkcs1Bytes(): ByteString {
-    val privateKeyInfo = PrivateKeyInfo.getInstance(keyPair.private.encoded)
-    return privateKeyInfo.parsePrivateKey().toASN1Primitive().encoded.toByteString()
-  }
-
-  private fun StringBuilder.encodeBase64Lines(data: ByteString) {
-    val base64 = data.base64()
-    for (i in 0 until base64.length step 64) {
-      append(base64, i, minOf(i + 64, base64.length)).append('\n')
-    }
-  }
-
-  /** Build a held certificate with reasonable defaults. */
-  class Builder {
-    private var notBefore = -1L
-    private var notAfter = -1L
-    private var cn: String? = null
-    private var ou: String? = null
-    private val altNames = mutableListOf<String>()
-    private var serialNumber: BigInteger? = null
-    private var keyPair: KeyPair? = null
-    private var signedBy: HeldCertificate? = null
-    private var maxIntermediateCas = -1
-    private var keyAlgorithm: String? = null
-    private var keySize: Int = 0
-
-    init {
-      ecdsa256()
-    }
-
-    /**
-     * Sets the certificate to be valid in ```[notBefore..notAfter]```. Both endpoints are specified
-     * in the format of [System.currentTimeMillis]. Specify -1L for both values to use the default
-     * interval, 24 hours starting when the certificate is created.
-     */
-    fun validityInterval(notBefore: Long, notAfter: Long) = apply {
-      require(notBefore <= notAfter && notBefore == -1L == (notAfter == -1L)) {
-        "invalid interval: $notBefore..$notAfter"
-      }
-      this.notBefore = notBefore
-      this.notAfter = notAfter
-    }
-
-    /**
-     * Sets the certificate to be valid immediately and until the specified duration has elapsed.
-     * The precision of this field is seconds; further precision will be truncated.
-     */
-    fun duration(duration: Long, unit: TimeUnit) = apply {
-      val now = System.currentTimeMillis()
-      validityInterval(now, now + unit.toMillis(duration))
-    }
-
-    /**
-     * Adds a subject alternative name (SAN) to the certificate. This is usually a literal hostname,
-     * a literal IP address, or a hostname pattern. If no subject alternative names are added that
-     * extension will be omitted.
-     */
-    fun addSubjectAlternativeName(altName: String) = apply {
-      altNames += altName
-    }
-
-    /**
-     * Set this certificate's common name (CN). Historically this held the hostname of TLS
-     * certificate, but that practice was deprecated by [RFC 2818][rfc_2818] and replaced with
-     * [addSubjectAlternativeName]. If unset a random string will be used.
-     *
-     * [rfc_2818]: https://tools.ietf.org/html/rfc2818
-     */
-    fun commonName(cn: String) = apply {
-      this.cn = cn
-    }
-
-    /** Sets the certificate's organizational unit (OU). If unset this field will be omitted. */
-    fun organizationalUnit(ou: String) = apply {
-      this.ou = ou
-    }
-
-    /** Sets this certificate's serial number. If unset the serial number will be 1. */
-    fun serialNumber(serialNumber: BigInteger) = apply {
-      this.serialNumber = serialNumber
-    }
-
-    /** Sets this certificate's serial number. If unset the serial number will be 1. */
-    fun serialNumber(serialNumber: Long) = apply {
-      serialNumber(BigInteger.valueOf(serialNumber))
-    }
-
-    /**
-     * Sets the public/private key pair used for this certificate. If unset a key pair will be
-     * generated.
-     */
-    fun keyPair(keyPair: KeyPair) = apply {
-      this.keyPair = keyPair
-    }
-
-    /**
-     * Sets the public/private key pair used for this certificate. If unset a key pair will be
-     * generated.
-     */
-    fun keyPair(publicKey: PublicKey, privateKey: PrivateKey) = apply {
-      keyPair(KeyPair(publicKey, privateKey))
-    }
-
-    /**
-     * Set the certificate that will issue this certificate. If unset the certificate will be
-     * self-signed.
-     */
-    fun signedBy(signedBy: HeldCertificate?) = apply {
-      this.signedBy = signedBy
-    }
-
-    /**
-     * Set this certificate to be a signing certificate, with up to `maxIntermediateCas`
-     * intermediate signing certificates beneath it.
-     *
-     * By default this certificate cannot not sign other certificates. Set this to 0 so this
-     * certificate can sign other certificates (but those certificates cannot themselves sign
-     * certificates). Set this to 1 so this certificate can sign intermediate certificates that can
-     * themselves sign certificates. Add one for each additional layer of intermediates to permit.
-     */
-    fun certificateAuthority(maxIntermediateCas: Int) = apply {
-      require(maxIntermediateCas >= 0) {
-        "maxIntermediateCas < 0: $maxIntermediateCas"
-      }
-      this.maxIntermediateCas = maxIntermediateCas
-    }
-
-    /**
-     * Configure the certificate to generate a 256-bit ECDSA key, which provides about 128 bits of
-     * security. ECDSA keys are noticeably faster than RSA keys.
-     *
-     * This is the default configuration and has been since this API was introduced in OkHttp
-     * 3.11.0. Note that the default may change in future releases.
-     */
-    fun ecdsa256() = apply {
-      keyAlgorithm = "EC"
-      keySize = 256
-    }
-
-    /**
-     * Configure the certificate to generate a 2048-bit RSA key, which provides about 112 bits of
-     * security. RSA keys are interoperable with very old clients that don't support ECDSA.
-     */
-    fun rsa2048() = apply {
-      keyAlgorithm = "RSA"
-      keySize = 2048
-    }
-
-    fun build(): HeldCertificate {
-      // Subject, public & private keys for this certificate.
-      val heldKeyPair = keyPair ?: generateKeyPair()
-      val subject = buildSubject()
-
-      // Subject, public & private keys for this certificate's signer. It may be self signed!
-      val signedByKeyPair: KeyPair
-      val signedByPrincipal: X500Principal
-      if (signedBy != null) {
-        signedByKeyPair = signedBy!!.keyPair
-        signedByPrincipal = signedBy!!.certificate.subjectX500Principal
-      } else {
-        signedByKeyPair = heldKeyPair
-        signedByPrincipal = subject
-      }
-
-      // Generate & sign the certificate.
-      val notBefore = if (this.notBefore != -1L) {
-        this.notBefore
-      } else {
-        System.currentTimeMillis()
-      }
-      val notAfter = if (this.notAfter != -1L) {
-        this.notAfter
-      } else {
-        notBefore + DEFAULT_DURATION_MILLIS
-      }
-      val serialNumber = if (this.serialNumber != null) {
-        this.serialNumber
-      } else {
-        BigInteger.ONE
-      }
-      val signatureAlgorithm = if (signedByKeyPair.private is RSAPrivateKey) {
-        "SHA256WithRSA"
-      } else {
-        "SHA256withECDSA"
-      }
-      val generator = X509V3CertificateGenerator()
-      generator.setSerialNumber(serialNumber)
-      generator.setIssuerDN(signedByPrincipal)
-      generator.setNotBefore(Date(notBefore))
-      generator.setNotAfter(Date(notAfter))
-      generator.setSubjectDN(subject)
-      generator.setPublicKey(heldKeyPair.public)
-      generator.setSignatureAlgorithm(signatureAlgorithm)
-
-      if (maxIntermediateCas != -1) {
-        generator.addExtension(X509Extensions.BasicConstraints, true,
-            BasicConstraints(maxIntermediateCas))
-      }
-
-      if (altNames.isNotEmpty()) {
-        val encodableAltNames = arrayOfNulls<ASN1Encodable>(altNames.size)
-        for (i in 0 until altNames.size) {
-          val altName = altNames[i]
-          val tag = when {
-            altName.canParseAsIpAddress() -> GeneralName.iPAddress
-            else -> GeneralName.dNSName
-          }
-          encodableAltNames[i] = GeneralName(tag, altName)
-        }
-        generator.addExtension(X509Extensions.SubjectAlternativeName, true,
-            DERSequence(encodableAltNames))
-      }
-
-      val certificate = generator.generate(signedByKeyPair.private)
-      return HeldCertificate(heldKeyPair, certificate)
-    }
-
-    private fun buildSubject(): X500Principal {
-      val name = buildString {
-        append("CN=")
-        if (cn != null) {
-          append(cn)
-        } else {
-          append(UUID.randomUUID())
-        }
-        if (ou != null) {
-          append(", OU=")
-          append(ou)
-        }
-      }
-      return X500Principal(name)
-    }
-
-    private fun generateKeyPair(): KeyPair {
-      val keyPairGenerator = KeyPairGenerator.getInstance(keyAlgorithm)
-      keyPairGenerator.initialize(keySize, SecureRandom())
-      return keyPairGenerator.generateKeyPair()
-    }
-
-    companion object {
-      private const val DEFAULT_DURATION_MILLIS = 1000L * 60 * 60 * 24 // 24 hours.
-
-      init {
-        Security.addProvider(BouncyCastleProvider())
-      }
-    }
-  }
-
-  companion object {
-    private val PEM_REGEX = Regex("""-----BEGIN ([!-,.-~ ]*)-----([^-]*)-----END \1-----""")
-
-    /**
-     * Decodes a multiline string that contains both a [certificate][certificatePem] and a
-     * [private key][privateKeyPkcs8Pem], both [PEM-encoded][rfc_7468]. A typical input string looks
-     * like this:
-     *
-     * ```
-     * -----BEGIN CERTIFICATE-----
-     * MIIBYTCCAQegAwIBAgIBKjAKBggqhkjOPQQDAjApMRQwEgYDVQQLEwtlbmdpbmVl
-     * cmluZzERMA8GA1UEAxMIY2FzaC5hcHAwHhcNNzAwMTAxMDAwMDA1WhcNNzAwMTAx
-     * MDAwMDEwWjApMRQwEgYDVQQLEwtlbmdpbmVlcmluZzERMA8GA1UEAxMIY2FzaC5h
-     * cHAwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASda8ChkQXxGELnrV/oBnIAx3dD
-     * ocUOJfdz4pOJTP6dVQB9U3UBiW5uSX/MoOD0LL5zG3bVyL3Y6pDwKuYvfLNhoyAw
-     * HjAcBgNVHREBAf8EEjAQhwQBAQEBgghjYXNoLmFwcDAKBggqhkjOPQQDAgNIADBF
-     * AiAyHHg1N6YDDQiY920+cnI5XSZwEGhAtb9PYWO8bLmkcQIhAI2CfEZf3V/obmdT
-     * yyaoEufLKVXhrTQhRfodTeigi4RX
-     * -----END CERTIFICATE-----
-     * -----BEGIN PRIVATE KEY-----
-     * MEECAQAwEwYHKoZIzj0CAQYIKoZIzj0DAQcEJzAlAgEBBCA7ODT0xhGSNn4ESj6J
-     * lu/GJQZoU9lDrCPeUcQ28tzOWw==
-     * -----END PRIVATE KEY-----
-     * ```
-     *
-     * The string should contain exactly one certificate and one private key in [PKCS #8][rfc_5208]
-     * format. It should not contain any other PEM-encoded blocks, but it may contain other text
-     * which will be ignored.
-     *
-     * Encode a held certificate into this format by concatenating the results of
-     * [certificatePem()][certificatePem] and [privateKeyPkcs8Pem()][privateKeyPkcs8Pem].
-     *
-     * [rfc_7468]: https://tools.ietf.org/html/rfc7468
-     * [rfc_5208]: https://tools.ietf.org/html/rfc5208
-     */
-    @JvmStatic
-    fun decode(certificateAndPrivateKeyPem: String): HeldCertificate {
-      var certificatePem: String? = null
-      var pkcs8Base64: String? = null
-      for (match in PEM_REGEX.findAll(certificateAndPrivateKeyPem)) {
-        when (val label = match.groups[1]!!.value) {
-          "CERTIFICATE" -> {
-            require(certificatePem == null) { "string includes multiple certificates" }
-            certificatePem = match.groups[0]!!.value // Keep --BEGIN-- and --END-- for certificates.
-          }
-          "PRIVATE KEY" -> {
-            require(pkcs8Base64 == null) { "string includes multiple private keys" }
-            pkcs8Base64 = match.groups[2]!!.value // Include the contents only for PKCS8.
-          }
-          else -> {
-            throw IllegalArgumentException("unexpected type: $label")
-          }
-        }
-      }
-      require(certificatePem != null) { "string does not include a certificate" }
-      require(pkcs8Base64 != null) { "string does not include a private key" }
-
-      return decode(certificatePem, pkcs8Base64)
-    }
-
-    private fun decode(certificatePem: String, pkcs8Base64Text: String): HeldCertificate {
-      val certificate = try {
-        decodePem(certificatePem)
-      } catch (e: GeneralSecurityException) {
-        throw IllegalArgumentException("failed to decode certificate", e)
-      }
-
-      val privateKey = try {
-        val pkcs8Bytes = pkcs8Base64Text.decodeBase64()
-            ?: throw IllegalArgumentException("failed to decode private key")
-
-        // The private key doesn't tell us its type but it's okay because the certificate knows!
-        val keyType = when (certificate.publicKey) {
-          is ECPublicKey -> "EC"
-          is RSAPublicKey -> "RSA"
-          else -> throw IllegalArgumentException("unexpected key type: ${certificate.publicKey}")
-        }
-
-        decodePkcs8(pkcs8Bytes, keyType)
-      } catch (e: GeneralSecurityException) {
-        throw IllegalArgumentException("failed to decode private key", e)
-      }
-
-      val keyPair = KeyPair(certificate.publicKey, privateKey)
-      return HeldCertificate(keyPair, certificate)
-    }
-
-    private fun decodePem(pem: String): X509Certificate {
-      val certificates = CertificateFactory.getInstance("X.509")
-          .generateCertificates(Buffer().writeUtf8(pem).inputStream())
-      return certificates.iterator().next() as X509Certificate
-    }
-
-    private fun decodePkcs8(data: ByteString, keyAlgorithm: String): PrivateKey {
-      val keyFactory = KeyFactory.getInstance(keyAlgorithm)
-      return keyFactory.generatePrivate(PKCS8EncodedKeySpec(data.toByteArray()))
-    }
-  }
-}
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.kt b/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.kt
deleted file mode 100644
index c5bb9d8e00..0000000000
--- a/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.kt
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.tls.internal
-
-import okhttp3.tls.HandshakeCertificates
-import okhttp3.tls.HeldCertificate
-import java.io.InputStream
-import java.net.InetAddress
-import java.security.KeyStore
-import java.security.cert.Certificate
-import java.security.cert.X509Certificate
-import javax.net.ssl.KeyManagerFactory
-import javax.net.ssl.TrustManagerFactory
-import javax.net.ssl.X509KeyManager
-import javax.net.ssl.X509TrustManager
-
-object TlsUtil {
-  val password = "password".toCharArray()
-
-  private val localhost: HandshakeCertificates by lazy {
-    // Generate a self-signed cert for the server to serve and the client to trust.
-    val heldCertificate = HeldCertificate.Builder()
-        .commonName("localhost")
-        .addSubjectAlternativeName(InetAddress.getByName("localhost").canonicalHostName)
-        .build()
-    return@lazy HandshakeCertificates.Builder()
-        .heldCertificate(heldCertificate)
-        .addTrustedCertificate(heldCertificate.certificate)
-        .build()
-  }
-
-  /** Returns an SSL client for this host's localhost address. */
-  @JvmStatic
-  fun localhost(): HandshakeCertificates = localhost
-
-  /** Returns a trust manager that trusts `trustedCertificates`. */
-  @JvmStatic
-  fun newTrustManager(
-    keyStoreType: String?,
-    trustedCertificates: List<X509Certificate>
-  ): X509TrustManager {
-    val trustStore = newEmptyKeyStore(keyStoreType)
-    for (i in trustedCertificates.indices) {
-      trustStore.setCertificateEntry("cert_$i", trustedCertificates[i])
-    }
-
-    val factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
-    factory.init(trustStore)
-    val result = factory.trustManagers!!
-    check(result.size == 1 && result[0] is X509TrustManager) {
-      "Unexpected trust managers: ${result.contentToString()}"
-    }
-
-    return result[0] as X509TrustManager
-  }
-
-  /**
-   * Returns a key manager for the held certificate and its chain. Returns an empty key manager if
-   * `heldCertificate` is null.
-   */
-  @JvmStatic
-  fun newKeyManager(
-    keyStoreType: String?,
-    heldCertificate: HeldCertificate?,
-    vararg intermediates: X509Certificate
-  ): X509KeyManager {
-    val keyStore = newEmptyKeyStore(keyStoreType)
-    if (heldCertificate != null) {
-      val chain = arrayOfNulls<Certificate>(1 + intermediates.size)
-      chain[0] = heldCertificate.certificate
-      intermediates.copyInto(chain, 1)
-      keyStore.setKeyEntry("private", heldCertificate.keyPair.private, password, chain)
-    }
-
-    val factory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
-    factory.init(keyStore, password)
-    val result = factory.keyManagers!!
-    check(result.size == 1 && result[0] is X509KeyManager) {
-      "Unexpected key managers:${result.contentToString()}"
-    }
-
-    return result[0] as X509KeyManager
-  }
-
-  private fun newEmptyKeyStore(keyStoreType: String?): KeyStore {
-    return KeyStore.getInstance(keyStoreType ?: KeyStore.getDefaultType()).apply {
-      val inputStream: InputStream? = null // By convention, 'null' creates an empty key store.
-      load(inputStream, password)
-    }
-  }
-}
diff --git a/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java b/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java
deleted file mode 100644
index 96b876cb94..0000000000
--- a/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java
+++ /dev/null
@@ -1,205 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.tls;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.security.PrivateKey;
-import java.security.cert.X509Certificate;
-import java.util.LinkedHashSet;
-import java.util.Set;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import javax.net.ServerSocketFactory;
-import javax.net.SocketFactory;
-import javax.net.ssl.SSLSocket;
-import okhttp3.Handshake;
-import okio.ByteString;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
-import static java.util.Arrays.asList;
-import static okhttp3.internal.Util.closeQuietly;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assume.assumeFalse;
-
-public final class HandshakeCertificatesTest {
-  private ExecutorService executorService;
-  private ServerSocket serverSocket;
-
-  @Before public void setUp() {
-    executorService = Executors.newCachedThreadPool();
-  }
-
-  @After public void tearDown() {
-    executorService.shutdown();
-    if (serverSocket != null) {
-      closeQuietly(serverSocket);
-    }
-  }
-
-  @Test public void clientAndServer() throws Exception {
-    assumeFalse(getPlatform().equals("conscrypt"));
-
-    HeldCertificate clientRoot = new HeldCertificate.Builder()
-        .certificateAuthority(1)
-        .build();
-    HeldCertificate clientIntermediate = new HeldCertificate.Builder()
-        .certificateAuthority(0)
-        .signedBy(clientRoot)
-        .build();
-    HeldCertificate clientCertificate = new HeldCertificate.Builder()
-        .signedBy(clientIntermediate)
-        .build();
-
-    HeldCertificate serverRoot = new HeldCertificate.Builder()
-        .certificateAuthority(1)
-        .build();
-    HeldCertificate serverIntermediate = new HeldCertificate.Builder()
-        .certificateAuthority(0)
-        .signedBy(serverRoot)
-        .build();
-    HeldCertificate serverCertificate = new HeldCertificate.Builder()
-        .signedBy(serverIntermediate)
-        .build();
-
-    HandshakeCertificates server = new HandshakeCertificates.Builder()
-        .addTrustedCertificate(clientRoot.certificate())
-        .heldCertificate(serverCertificate, serverIntermediate.certificate())
-        .build();
-
-    HandshakeCertificates client = new HandshakeCertificates.Builder()
-        .addTrustedCertificate(serverRoot.certificate())
-        .heldCertificate(clientCertificate, clientIntermediate.certificate())
-        .build();
-
-    InetSocketAddress serverAddress = startTlsServer();
-    Future<Handshake> serverHandshakeFuture = doServerHandshake(server);
-    Future<Handshake> clientHandshakeFuture = doClientHandshake(client, serverAddress);
-
-    Handshake serverHandshake = serverHandshakeFuture.get();
-    assertThat(asList(clientCertificate.certificate(), clientIntermediate.certificate()))
-        .isEqualTo(serverHandshake.peerCertificates());
-    assertThat(asList(serverCertificate.certificate(), serverIntermediate.certificate()))
-        .isEqualTo(serverHandshake.localCertificates());
-
-    Handshake clientHandshake = clientHandshakeFuture.get();
-    assertThat(asList(serverCertificate.certificate(), serverIntermediate.certificate()))
-        .isEqualTo(clientHandshake.peerCertificates());
-    assertThat(asList(clientCertificate.certificate(), clientIntermediate.certificate()))
-        .isEqualTo(clientHandshake.localCertificates());
-  }
-
-  @Test public void keyManager() {
-    HeldCertificate root = new HeldCertificate.Builder()
-        .certificateAuthority(1)
-        .build();
-    HeldCertificate intermediate = new HeldCertificate.Builder()
-        .certificateAuthority(0)
-        .signedBy(root)
-        .build();
-    HeldCertificate certificate = new HeldCertificate.Builder()
-        .signedBy(intermediate)
-        .build();
-
-    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
-        .heldCertificate(certificate, intermediate.certificate())
-        .build();
-    assertPrivateKeysEquals(certificate.keyPair().getPrivate(),
-        handshakeCertificates.keyManager().getPrivateKey("private"));
-    assertThat(asList(handshakeCertificates.keyManager().getCertificateChain("private"))).isEqualTo(
-        asList(certificate.certificate(), intermediate.certificate()));
-  }
-
-  @Test public void platformTrustedCertificates() {
-    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
-        .addPlatformTrustedCertificates()
-        .build();
-    Set<String> names = new LinkedHashSet<>();
-    for (X509Certificate certificate : handshakeCertificates.trustManager().getAcceptedIssuers()) {
-      // Abbreviate a long name like "CN=Entrust Root Certification Authority - G2, OU=..."
-      String name = certificate.getSubjectDN().getName();
-      names.add(name.substring(0, name.indexOf(" ")));
-    }
-    // It's safe to assume all platforms will have a major Internet certificate issuer.
-    assertThat(names).contains("CN=Entrust");
-  }
-
-  private InetSocketAddress startTlsServer() throws IOException {
-    ServerSocketFactory serverSocketFactory = ServerSocketFactory.getDefault();
-    serverSocket = serverSocketFactory.createServerSocket();
-    InetAddress serverAddress = InetAddress.getByName("localhost");
-    serverSocket.bind(new InetSocketAddress(serverAddress, 0), 50);
-    return new InetSocketAddress(serverAddress, serverSocket.getLocalPort());
-  }
-
-  private Future<Handshake> doServerHandshake(HandshakeCertificates server) {
-    return executorService.submit(() -> {
-      Socket rawSocket = null;
-      SSLSocket sslSocket = null;
-      try {
-        rawSocket = serverSocket.accept();
-        sslSocket = (SSLSocket) server.sslSocketFactory().createSocket(rawSocket,
-            rawSocket.getInetAddress().getHostAddress(), rawSocket.getPort(), true /* autoClose */);
-        sslSocket.setUseClientMode(false);
-        sslSocket.setWantClientAuth(true);
-        sslSocket.startHandshake();
-        return Handshake.get(sslSocket.getSession());
-      } finally {
-        if (rawSocket != null) {
-          closeQuietly(rawSocket);
-        }
-        if (sslSocket != null) {
-          closeQuietly(sslSocket);
-        }
-      }
-    });
-  }
-
-  private Future<Handshake> doClientHandshake(
-      HandshakeCertificates client, InetSocketAddress serverAddress) {
-    return executorService.submit(() -> {
-      Socket rawSocket = SocketFactory.getDefault().createSocket();
-      rawSocket.connect(serverAddress);
-      SSLSocket sslSocket = null;
-      try {
-        sslSocket = (SSLSocket) client.sslSocketFactory().createSocket(rawSocket,
-            rawSocket.getInetAddress().getHostAddress(), rawSocket.getPort(), true /* autoClose */);
-        sslSocket.startHandshake();
-        return Handshake.get(sslSocket.getSession());
-      } finally {
-        closeQuietly(rawSocket);
-        if (sslSocket != null) {
-          closeQuietly(sslSocket);
-        }
-      }
-    });
-  }
-
-  private void assertPrivateKeysEquals(PrivateKey expected, PrivateKey actual) {
-    assertThat(ByteString.of(actual.getEncoded())).isEqualTo(
-        ByteString.of(expected.getEncoded()));
-  }
-
-  public static String getPlatform() {
-    return System.getProperty("okhttp.platform", "platform");
-  }
-}
diff --git a/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java b/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java
deleted file mode 100644
index 378e154069..0000000000
--- a/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java
+++ /dev/null
@@ -1,487 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.tls;
-
-import java.math.BigInteger;
-import java.security.KeyFactory;
-import java.security.PrivateKey;
-import java.security.PublicKey;
-import java.security.cert.CertificateParsingException;
-import java.security.cert.X509Certificate;
-import java.security.spec.PKCS8EncodedKeySpec;
-import java.security.spec.X509EncodedKeySpec;
-import java.util.concurrent.TimeUnit;
-import okio.ByteString;
-import org.bouncycastle.asn1.x509.GeneralName;
-import org.junit.Test;
-
-import static java.util.Arrays.asList;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.data.Offset.offset;
-import static org.junit.Assert.fail;
-
-public final class HeldCertificateTest {
-  @Test public void defaultCertificate() throws CertificateParsingException {
-    long now = System.currentTimeMillis();
-    HeldCertificate heldCertificate = new HeldCertificate.Builder().build();
-
-    X509Certificate certificate = heldCertificate.certificate();
-    assertThat(certificate.getSubjectX500Principal().getName()).overridingErrorMessage(
-        "self-signed").isEqualTo(certificate.getIssuerX500Principal().getName());
-    assertThat(certificate.getIssuerX500Principal().getName()).matches("CN=[0-9a-f-]{36}");
-    assertThat(certificate.getSerialNumber()).isEqualTo(BigInteger.ONE);
-    assertThat(certificate.getSubjectAlternativeNames()).isNull();
-
-    double deltaMillis = 1000.0;
-    long durationMillis = TimeUnit.MINUTES.toMillis(60 * 24);
-    assertThat((double) certificate.getNotBefore().getTime()).isCloseTo(
-        (double) now, offset(deltaMillis));
-    assertThat((double) certificate.getNotAfter().getTime()).isCloseTo(
-        (double) now + durationMillis, offset(deltaMillis));
-  }
-
-  @Test public void customInterval() {
-    // 5 seconds starting on 1970-01-01.
-    HeldCertificate heldCertificate = new HeldCertificate.Builder()
-        .validityInterval(5_000L, 10_000L)
-        .build();
-    X509Certificate certificate = heldCertificate.certificate();
-    assertThat(certificate.getNotBefore().getTime()).isEqualTo(5_000L);
-    assertThat(certificate.getNotAfter().getTime()).isEqualTo(10_000L);
-  }
-
-  @Test public void customDuration() {
-    long now = System.currentTimeMillis();
-
-    HeldCertificate heldCertificate = new HeldCertificate.Builder()
-        .duration(5, TimeUnit.SECONDS)
-        .build();
-    X509Certificate certificate = heldCertificate.certificate();
-
-    double deltaMillis = 1000.0;
-    long durationMillis = 5_000L;
-    assertThat((double) certificate.getNotBefore().getTime()).isCloseTo(
-        (double) now, offset(deltaMillis));
-    assertThat((double) certificate.getNotAfter().getTime()).isCloseTo(
-        (double) now + durationMillis, offset(deltaMillis));
-  }
-
-  @Test public void subjectAlternativeNames() throws CertificateParsingException {
-    HeldCertificate heldCertificate = new HeldCertificate.Builder()
-        .addSubjectAlternativeName("1.1.1.1")
-        .addSubjectAlternativeName("cash.app")
-        .build();
-
-    X509Certificate certificate = heldCertificate.certificate();
-    assertThat(certificate.getSubjectAlternativeNames()).containsExactly(
-        asList(GeneralName.iPAddress, "1.1.1.1"),
-        asList(GeneralName.dNSName, "cash.app"));
-  }
-
-  @Test public void commonName() {
-    HeldCertificate heldCertificate = new HeldCertificate.Builder()
-        .commonName("cash.app")
-        .build();
-
-    X509Certificate certificate = heldCertificate.certificate();
-    assertThat(certificate.getSubjectX500Principal().getName()).isEqualTo("CN=cash.app");
-  }
-
-  @Test public void organizationalUnit() {
-    HeldCertificate heldCertificate = new HeldCertificate.Builder()
-        .commonName("cash.app")
-        .organizationalUnit("cash")
-        .build();
-
-    X509Certificate certificate = heldCertificate.certificate();
-    assertThat(certificate.getSubjectX500Principal().getName()).isEqualTo(
-        "CN=cash.app,OU=cash");
-  }
-
-  /** Confirm golden values of encoded PEMs. */
-  @Test public void pems() throws Exception {
-    KeyFactory keyFactory = KeyFactory.getInstance("RSA");
-
-    ByteString publicKeyBytes = ByteString.decodeBase64("MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCApF"
-        + "HhtrLan28q+oMolZuaTfWBA0V5aMIvq32BsloQu6LlvX1wJ4YEoUCjDlPOtpht7XLbUmBnbIzN89XK4UJVM6Sqp3"
-        + "K88Km8z7gMrdrfTom/274wL25fICR+yDEQ5fUVYBmJAKXZF1aoI0mIoEx0xFsQhIJ637v2MxJDupd61wIDAQAB");
-    PublicKey publicKey = keyFactory.generatePublic(
-        new X509EncodedKeySpec(publicKeyBytes.toByteArray()));
-
-    ByteString privateKeyBytes = ByteString.decodeBase64("MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbA"
-        + "gEAAoGBAICkUeG2stqfbyr6gyiVm5pN9YEDRXlowi+rfYGyWhC7ouW9fXAnhgShQKMOU862mG3tcttSYGdsjM3z1"
-        + "crhQlUzpKqncrzwqbzPuAyt2t9Oib/bvjAvbl8gJH7IMRDl9RVgGYkApdkXVqgjSYigTHTEWxCEgnrfu/YzEkO6l"
-        + "3rXAgMBAAECgYB99mhnB6piADOuddXv626NzUBTr4xbsYRTgSxHzwf50oFTTBSDuW+1IOBVyTWu94SSPyt0LllPb"
-        + "C8Di3sQSTnVGpSqAvEXknBMzIc0UO74Rn9p3gZjEenPt1l77fIBa2nK06/rdsJCoE/1P1JSfM9w7LU1RsTmseYML"
-        + "eJl5F79gQJBAO/BbAKqg1yzK7VijygvBoUrr+rt2lbmKgcUQ/rxu8IIQk0M/xgJqSkXDXuOnboGM7sQSKfJAZUtT"
-        + "7xozvLzV7ECQQCJW59w7NIM0qZ/gIX2gcNZr1B/V3zcGlolTDciRm+fnKGNt2EEDKnVL3swzbEfTCa48IT0QKgZJ"
-        + "qpXZERa26UHAkBLXmiP5f5pk8F3wcXzAeVw06z3k1IB41Tu6MX+CyPU+TeudRlz+wV8b0zDvK+EnRKCCbptVFj1B"
-        + "kt8lQ4JfcnhAkAk2Y3Gz+HySrkcT7Cg12M/NkdUQnZe3jr88pt/+IGNwomc6Wt/mJ4fcWONTkGMcfOZff1NQeNXD"
-        + "AZ6941XCsIVAkASOg02PlVHLidU7mIE65swMM5/RNhS4aFjez/MwxFNOHaxc9VgCwYPXCLOtdf7AVovdyG0XWgbU"
-        + "XH+NyxKwboE");
-    PrivateKey privateKey = keyFactory.generatePrivate(
-        new PKCS8EncodedKeySpec(privateKeyBytes.toByteArray()));
-
-    HeldCertificate heldCertificate = new HeldCertificate.Builder()
-        .keyPair(publicKey, privateKey)
-        .commonName("cash.app")
-        .validityInterval(0L, 1_000L)
-        .rsa2048()
-        .build();
-
-    assertThat((""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIBmjCCAQOgAwIBAgIBATANBgkqhkiG9w0BAQsFADATMREwDwYDVQQDEwhjYXNo\n"
-        + "LmFwcDAeFw03MDAxMDEwMDAwMDBaFw03MDAxMDEwMDAwMDFaMBMxETAPBgNVBAMT\n"
-        + "CGNhc2guYXBwMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCApFHhtrLan28q\n"
-        + "+oMolZuaTfWBA0V5aMIvq32BsloQu6LlvX1wJ4YEoUCjDlPOtpht7XLbUmBnbIzN\n"
-        + "89XK4UJVM6Sqp3K88Km8z7gMrdrfTom/274wL25fICR+yDEQ5fUVYBmJAKXZF1ao\n"
-        + "I0mIoEx0xFsQhIJ637v2MxJDupd61wIDAQABMA0GCSqGSIb3DQEBCwUAA4GBADam\n"
-        + "UVwKh5Ry7es3OxtY3IgQunPUoLc0Gw71gl9Z+7t2FJ5VkcI5gWfutmdxZ2bDXCI8\n"
-        + "8V0vxo1pHXnbBrnxhS/Z3TBerw8RyQqcaWOdp+pBXyIWmR+jHk9cHZCqQveTIBsY\n"
-        + "jaA9VEhgdaVhxBsT2qzUNDsXlOzGsliznDfoqETb\n"
-        + "-----END CERTIFICATE-----\n")).isEqualTo(heldCertificate.certificatePem());
-
-    assertThat((""
-        + "-----BEGIN RSA PRIVATE KEY-----\n"
-        + "MIICWwIBAAKBgQCApFHhtrLan28q+oMolZuaTfWBA0V5aMIvq32BsloQu6LlvX1w\n"
-        + "J4YEoUCjDlPOtpht7XLbUmBnbIzN89XK4UJVM6Sqp3K88Km8z7gMrdrfTom/274w\n"
-        + "L25fICR+yDEQ5fUVYBmJAKXZF1aoI0mIoEx0xFsQhIJ637v2MxJDupd61wIDAQAB\n"
-        + "AoGAffZoZweqYgAzrnXV7+tujc1AU6+MW7GEU4EsR88H+dKBU0wUg7lvtSDgVck1\n"
-        + "rveEkj8rdC5ZT2wvA4t7EEk51RqUqgLxF5JwTMyHNFDu+EZ/ad4GYxHpz7dZe+3y\n"
-        + "AWtpytOv63bCQqBP9T9SUnzPcOy1NUbE5rHmDC3iZeRe/YECQQDvwWwCqoNcsyu1\n"
-        + "Yo8oLwaFK6/q7dpW5ioHFEP68bvCCEJNDP8YCakpFw17jp26BjO7EEinyQGVLU+8\n"
-        + "aM7y81exAkEAiVufcOzSDNKmf4CF9oHDWa9Qf1d83BpaJUw3IkZvn5yhjbdhBAyp\n"
-        + "1S97MM2xH0wmuPCE9ECoGSaqV2REWtulBwJAS15oj+X+aZPBd8HF8wHlcNOs95NS\n"
-        + "AeNU7ujF/gsj1Pk3rnUZc/sFfG9Mw7yvhJ0Sggm6bVRY9QZLfJUOCX3J4QJAJNmN\n"
-        + "xs/h8kq5HE+woNdjPzZHVEJ2Xt46/PKbf/iBjcKJnOlrf5ieH3FjjU5BjHHzmX39\n"
-        + "TUHjVwwGeveNVwrCFQJAEjoNNj5VRy4nVO5iBOubMDDOf0TYUuGhY3s/zMMRTTh2\n"
-        + "sXPVYAsGD1wizrXX+wFaL3chtF1oG1Fx/jcsSsG6BA==\n"
-        + "-----END RSA PRIVATE KEY-----\n")).isEqualTo(heldCertificate.privateKeyPkcs1Pem());
-
-    assertThat((""
-        + "-----BEGIN PRIVATE KEY-----\n"
-        + "MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAICkUeG2stqfbyr6\n"
-        + "gyiVm5pN9YEDRXlowi+rfYGyWhC7ouW9fXAnhgShQKMOU862mG3tcttSYGdsjM3z\n"
-        + "1crhQlUzpKqncrzwqbzPuAyt2t9Oib/bvjAvbl8gJH7IMRDl9RVgGYkApdkXVqgj\n"
-        + "SYigTHTEWxCEgnrfu/YzEkO6l3rXAgMBAAECgYB99mhnB6piADOuddXv626NzUBT\n"
-        + "r4xbsYRTgSxHzwf50oFTTBSDuW+1IOBVyTWu94SSPyt0LllPbC8Di3sQSTnVGpSq\n"
-        + "AvEXknBMzIc0UO74Rn9p3gZjEenPt1l77fIBa2nK06/rdsJCoE/1P1JSfM9w7LU1\n"
-        + "RsTmseYMLeJl5F79gQJBAO/BbAKqg1yzK7VijygvBoUrr+rt2lbmKgcUQ/rxu8II\n"
-        + "Qk0M/xgJqSkXDXuOnboGM7sQSKfJAZUtT7xozvLzV7ECQQCJW59w7NIM0qZ/gIX2\n"
-        + "gcNZr1B/V3zcGlolTDciRm+fnKGNt2EEDKnVL3swzbEfTCa48IT0QKgZJqpXZERa\n"
-        + "26UHAkBLXmiP5f5pk8F3wcXzAeVw06z3k1IB41Tu6MX+CyPU+TeudRlz+wV8b0zD\n"
-        + "vK+EnRKCCbptVFj1Bkt8lQ4JfcnhAkAk2Y3Gz+HySrkcT7Cg12M/NkdUQnZe3jr8\n"
-        + "8pt/+IGNwomc6Wt/mJ4fcWONTkGMcfOZff1NQeNXDAZ6941XCsIVAkASOg02PlVH\n"
-        + "LidU7mIE65swMM5/RNhS4aFjez/MwxFNOHaxc9VgCwYPXCLOtdf7AVovdyG0XWgb\n"
-        + "UXH+NyxKwboE\n"
-        + "-----END PRIVATE KEY-----\n")).isEqualTo(heldCertificate.privateKeyPkcs8Pem());
-  }
-
-  @Test public void ecdsaSignedByRsa() {
-    HeldCertificate root = new HeldCertificate.Builder()
-        .certificateAuthority(0)
-        .rsa2048()
-        .build();
-    HeldCertificate leaf = new HeldCertificate.Builder()
-        .certificateAuthority(0)
-        .ecdsa256()
-        .signedBy(root)
-        .build();
-
-    assertThat(root.certificate().getSigAlgName()).isEqualTo("SHA256WITHRSA");
-    assertThat(leaf.certificate().getSigAlgName()).isEqualTo("SHA256WITHRSA");
-  }
-
-  @Test public void rsaSignedByEcdsa() {
-    HeldCertificate root = new HeldCertificate.Builder()
-        .certificateAuthority(0)
-        .ecdsa256()
-        .build();
-    HeldCertificate leaf = new HeldCertificate.Builder()
-        .certificateAuthority(0)
-        .rsa2048()
-        .signedBy(root)
-        .build();
-
-    assertThat(root.certificate().getSigAlgName()).isEqualTo("SHA256WITHECDSA");
-    assertThat(leaf.certificate().getSigAlgName()).isEqualTo("SHA256WITHECDSA");
-  }
-
-  @Test public void decodeEcdsa256() throws Exception {
-    // The certificate + private key below was generated programmatically:
-    //
-    // HeldCertificate heldCertificate = new HeldCertificate.Builder()
-    //     .validityInterval(5_000L, 10_000L)
-    //     .addSubjectAlternativeName("1.1.1.1")
-    //     .addSubjectAlternativeName("cash.app")
-    //     .serialNumber(42L)
-    //     .commonName("cash.app")
-    //     .organizationalUnit("engineering")
-    //     .ecdsa256()
-    //     .build();
-
-    String certificatePem = ""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIBYTCCAQegAwIBAgIBKjAKBggqhkjOPQQDAjApMRQwEgYDVQQLEwtlbmdpbmVl\n"
-        + "cmluZzERMA8GA1UEAxMIY2FzaC5hcHAwHhcNNzAwMTAxMDAwMDA1WhcNNzAwMTAx\n"
-        + "MDAwMDEwWjApMRQwEgYDVQQLEwtlbmdpbmVlcmluZzERMA8GA1UEAxMIY2FzaC5h\n"
-        + "cHAwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASda8ChkQXxGELnrV/oBnIAx3dD\n"
-        + "ocUOJfdz4pOJTP6dVQB9U3UBiW5uSX/MoOD0LL5zG3bVyL3Y6pDwKuYvfLNhoyAw\n"
-        + "HjAcBgNVHREBAf8EEjAQhwQBAQEBgghjYXNoLmFwcDAKBggqhkjOPQQDAgNIADBF\n"
-        + "AiAyHHg1N6YDDQiY920+cnI5XSZwEGhAtb9PYWO8bLmkcQIhAI2CfEZf3V/obmdT\n"
-        + "yyaoEufLKVXhrTQhRfodTeigi4RX\n"
-        + "-----END CERTIFICATE-----\n";
-    String pkcs8Pem = ""
-        + "-----BEGIN PRIVATE KEY-----\n"
-        + "MEECAQAwEwYHKoZIzj0CAQYIKoZIzj0DAQcEJzAlAgEBBCA7ODT0xhGSNn4ESj6J\n"
-        + "lu/GJQZoU9lDrCPeUcQ28tzOWw==\n"
-        + "-----END PRIVATE KEY-----\n";
-
-    HeldCertificate heldCertificate = HeldCertificate.decode(certificatePem + pkcs8Pem);
-    assertThat(heldCertificate.certificatePem()).isEqualTo(certificatePem);
-    assertThat(heldCertificate.privateKeyPkcs8Pem()).isEqualTo(pkcs8Pem);
-
-    X509Certificate certificate = heldCertificate.certificate();
-    assertThat(certificate.getNotBefore().getTime()).isEqualTo(5_000L);
-    assertThat(certificate.getNotAfter().getTime()).isEqualTo(10_000L);
-
-    assertThat(certificate.getSubjectAlternativeNames()).containsExactly(
-        asList(GeneralName.iPAddress, "1.1.1.1"),
-        asList(GeneralName.dNSName, "cash.app"));
-
-    assertThat(certificate.getSubjectX500Principal().getName())
-        .isEqualTo("CN=cash.app,OU=engineering");
-  }
-
-  @Test public void decodeRsa512() throws Exception {
-    // The certificate + private key below was generated with OpenSSL. Never generate certificates
-    // with MD5 or 512-bit RSA; that's insecure!
-    //
-    // openssl req \
-    //   -x509 \
-    //   -md5 \
-    //   -nodes \
-    //   -days 1 \
-    //   -newkey rsa:512 \
-    //   -keyout privateKey.key \
-    //   -out certificate.crt
-
-    String certificatePem = ""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIBFzCBwgIJAIVAqagcVN7/MA0GCSqGSIb3DQEBBAUAMBMxETAPBgNVBAMMCGNh\n"
-        + "c2guYXBwMB4XDTE5MDkwNzAyMjg0NFoXDTE5MDkwODAyMjg0NFowEzERMA8GA1UE\n"
-        + "AwwIY2FzaC5hcHAwXDANBgkqhkiG9w0BAQEFAANLADBIAkEA8qAeoubm4mBTD9/J\n"
-        + "ujLQkfk/fuJt/T5pVQ1vUEqxfcMw0zYgszQ5C2MiIl7M6JkTRKU01q9hVFCR83wX\n"
-        + "zIdrLQIDAQABMA0GCSqGSIb3DQEBBAUAA0EAO1UpwhrkW3Ho1nZK/taoUQOoqz/n\n"
-        + "HFVMtyEkm5gBDgz8nJXwb3zbegclQyH+kVou02S8zC5WWzEtd0R8S0LsTA==\n"
-        + "-----END CERTIFICATE-----\n";
-    String pkcs8Pem = ""
-        + "-----BEGIN PRIVATE KEY-----\n"
-        + "MIIBVQIBADANBgkqhkiG9w0BAQEFAASCAT8wggE7AgEAAkEA8qAeoubm4mBTD9/J\n"
-        + "ujLQkfk/fuJt/T5pVQ1vUEqxfcMw0zYgszQ5C2MiIl7M6JkTRKU01q9hVFCR83wX\n"
-        + "zIdrLQIDAQABAkEA7dEA9o/5k77y68ZhRv9z7QEwucBcKzQ3rsSCbWMpYqg924F9\n"
-        + "L8Z76kzSedSO2PN8mg6y/OLL+qBuTeUK/yiowQIhAP0cknFMbqeNX6uvj/S+V7in\n"
-        + "bIhQkhcSdJjRw8fxMnJpAiEA9WTp9wzJpn+9etZo0jJ8wkM0+LTMNELo47Ctz7l1\n"
-        + "kiUCIQCi34vslD5wWyzBEcwUtZdFH5dbcF1Rs3KMFA9jzfWkYQIgHtiWiFV1K5a3\n"
-        + "DK/S8UkjYY/tIq4nVRJsD+LvlkLrwnkCIECcz4yF4HQgv+Tbzj/gGSBl1VIliTcB\n"
-        + "Rc5RUQ0mZJQF\n"
-        + "-----END PRIVATE KEY-----\n";
-
-    HeldCertificate heldCertificate = HeldCertificate.decode(pkcs8Pem + certificatePem);
-    assertThat(heldCertificate.certificatePem()).isEqualTo(certificatePem);
-    assertThat(heldCertificate.privateKeyPkcs8Pem()).isEqualTo(pkcs8Pem);
-
-    X509Certificate certificate = heldCertificate.certificate();
-    assertThat(certificate.getSubjectX500Principal().getName())
-        .isEqualTo("CN=cash.app");
-  }
-
-  @Test public void decodeRsa2048() throws Exception {
-    // The certificate + private key below was generated programmatically:
-    //
-    // HeldCertificate heldCertificate = new HeldCertificate.Builder()
-    //     .validityInterval(5_000L, 10_000L)
-    //     .addSubjectAlternativeName("1.1.1.1")
-    //     .addSubjectAlternativeName("cash.app")
-    //     .serialNumber(42L)
-    //     .commonName("cash.app")
-    //     .organizationalUnit("engineering")
-    //     .rsa2048()
-    //     .build();
-
-    String certificatePem = ""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIC7TCCAdWgAwIBAgIBKjANBgkqhkiG9w0BAQsFADApMRQwEgYDVQQLEwtlbmdp\n"
-        + "bmVlcmluZzERMA8GA1UEAxMIY2FzaC5hcHAwHhcNNzAwMTAxMDAwMDA1WhcNNzAw\n"
-        + "MTAxMDAwMDEwWjApMRQwEgYDVQQLEwtlbmdpbmVlcmluZzERMA8GA1UEAxMIY2Fz\n"
-        + "aC5hcHAwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCaU+vrUPL0APGI\n"
-        + "SXIuRX4xRrigXmGKx+GRPnWDWvGJwOm23Vpq/eZxQx6PbSUB1+QZzAwge20RpNAp\n"
-        + "2lt5/qFtgUpEon2j06rd/0+ODqqVJX+6d3SpmF1fPfKUB6AOZbxEkaJpBSTavoTg\n"
-        + "G2M/NMdjZjrcB3quNQcLg54mmI3HJm1zOd/8i2fZjvoiyVY30Inn2SmQsAotXw1u\n"
-        + "aE/319bnR2sQlnkp6MJU0eLEtKyRif/IODvY+mtRYYdkFtoeT6qQPMIh+gF/H3to\n"
-        + "5tjs3g59QC8k2TJDop4EFYUOwdrtnb8wUiBnLyURD1szASE2IO2Ftk1zaNOPKtrv\n"
-        + "VeJuB/mpAgMBAAGjIDAeMBwGA1UdEQEB/wQSMBCHBAEBAQGCCGNhc2guYXBwMA0G\n"
-        + "CSqGSIb3DQEBCwUAA4IBAQAPm7vfk+rxSucxxbFiimmFKBw+ymieLY/kznNh0lHJ\n"
-        + "q15fsMYK7TTTt2FFqyfVXhhRZegLrkrGb3+4Dz1uNtcRrjT4qo+T/JOuZGxtBLbm\n"
-        + "4/hkFSYavtd2FW+/CK7EnQKUyabgLOblb21IHOlcPwpSe6KkJjpwq0TV/ozzfk/q\n"
-        + "kGRA7/Ubn5TMRYyHWnod2SS14+BkItcWN03Z7kvyMYrpNZpu6vQRYsqJJFMcmpGZ\n"
-        + "sZQW31gO2arPmfNotkQdFdNL12c9YZKkJGhyK6NcpffD2l6O9NS5SRD5RnkvBxQw\n"
-        + "fX5DamL8je/YKSLQ4wgUA/5iVKlCiJGQi6fYIJ0kxayO\n"
-        + "-----END CERTIFICATE-----\n";
-    String pkcs8Pem = ""
-        + "-----BEGIN PRIVATE KEY-----\n"
-        + "MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQCaU+vrUPL0APGI\n"
-        + "SXIuRX4xRrigXmGKx+GRPnWDWvGJwOm23Vpq/eZxQx6PbSUB1+QZzAwge20RpNAp\n"
-        + "2lt5/qFtgUpEon2j06rd/0+ODqqVJX+6d3SpmF1fPfKUB6AOZbxEkaJpBSTavoTg\n"
-        + "G2M/NMdjZjrcB3quNQcLg54mmI3HJm1zOd/8i2fZjvoiyVY30Inn2SmQsAotXw1u\n"
-        + "aE/319bnR2sQlnkp6MJU0eLEtKyRif/IODvY+mtRYYdkFtoeT6qQPMIh+gF/H3to\n"
-        + "5tjs3g59QC8k2TJDop4EFYUOwdrtnb8wUiBnLyURD1szASE2IO2Ftk1zaNOPKtrv\n"
-        + "VeJuB/mpAgMBAAECggEAOlOXaYNZn1Cv+INRrR1EmVkSNEIXeX0bymohvbhka1zG\n"
-        + "t/8myiMVsh7c8PYeM3kl034j4y7ixPVWW0sUoaHT3vArYo9LDtzTyj1REu6GGAJp\n"
-        + "KM82/1X/jBx8jufm3SokIoIsMKbqC+ZPj+ep9dx7sxyTCE+nVSnjdL2Uyx+DDg3o\n"
-        + "na237HTScWIi+tMv5QGEwqLHS2q+NZYfjgnSxNY8BRw4XZCcIZRko9niuB5gUjj/\n"
-        + "y01HwvOCWuOMaSKZak1OdOaz3427/TkhYIqf6ft0ELF+ASRk3BLQA06pRt88H3u2\n"
-        + "3vsHJsWr2rkCN0h9uDp2o50ZQ5fvlxqG0QIZmvkIkQKBgQDOHeZKvXO5IxQ+S8ed\n"
-        + "09bC5SKiclCdW+Ry7N2x1MBfrxc4TTTTNaUN9Qdc6RXANG9bX2CJv0Dkh/0yH3z9\n"
-        + "Bdq6YcoP6DFCX46jwhCKvxMX9h9PFLvY7l2VSe7NfboGzvYLCy8ErsGuio8u9MHZ\n"
-        + "osX2ch6Gdhn1xUwLCw+T7rNwjQKBgQC/rWb0sWfgbKhEqV+u5oov+fFjooWmTQlQ\n"
-        + "jcj+lMWUOkitnPmX9TsH5JDa8I89Y0gJGu7Lfg8XSH+4FCCfX3mSLYwVH5vAIvmr\n"
-        + "TjMqRwSahQuTr/g+lx7alpcUHYv3z6b3WYIXFPPr3t7grWNJ14wMv9DnItWOg84H\n"
-        + "LlxAvXXsjQKBgQCRPPhdignVVyaYjwVl7TPTuWoiVbMAbxQW91lwSZ4UzmfqQF0M\n"
-        + "xyw7HYHGsmelPE2LcTWxWpb7cee0PgPwtwNdejLL6q1rO7JjKghF/EYUCFYff1iu\n"
-        + "j6hZ3fLr0cAXtBYjygmjnxDTUMd8KvO9y7j644cm8GlyiUgAMBcWAolmsQKBgQCT\n"
-        + "AJQTWfPGxM6QSi3d32VfwhsFROGnVzGrm/HofYTCV6jhraAmkKcDOKJ3p0LT286l\n"
-        + "XQiC/FzqiGmbbaRPVlPQbiofESzMQIamgMTwyaKYNy1XyP9kUVYSYqfff4GXPqRY\n"
-        + "00bYGPOxlC3utkuNmEgKhxnaCncqY5+hFkceR6+nCQKBgQC1Gonjhw0lYe43aHpp\n"
-        + "nDJKv3FnyN3wxjsR2c9sWpDzHA6CMVhSeLoXCB9ishmrSE/CygNlTU1TEy63xN22\n"
-        + "+dMHl5I/urMesjKKWiKZHdbWVIjJDv25r3jrN9VLr4q6AD9r1Su5G0o2j0N5ujVg\n"
-        + "SzpFHp+ZzhL/SANa8EqlcF6ItQ==\n"
-        + "-----END PRIVATE KEY-----\n";
-
-    HeldCertificate heldCertificate = HeldCertificate.decode(pkcs8Pem + certificatePem);
-    assertThat(heldCertificate.certificatePem()).isEqualTo(certificatePem);
-    assertThat(heldCertificate.privateKeyPkcs8Pem()).isEqualTo(pkcs8Pem);
-
-    X509Certificate certificate = heldCertificate.certificate();
-    assertThat(certificate.getNotBefore().getTime()).isEqualTo(5_000L);
-    assertThat(certificate.getNotAfter().getTime()).isEqualTo(10_000L);
-
-    assertThat(certificate.getSubjectAlternativeNames()).containsExactly(
-        asList(GeneralName.iPAddress, "1.1.1.1"),
-        asList(GeneralName.dNSName, "cash.app"));
-
-    assertThat(certificate.getSubjectX500Principal().getName())
-        .isEqualTo("CN=cash.app,OU=engineering");
-  }
-
-  @Test public void decodeWrongNumber() {
-    String certificatePem = ""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIBYTCCAQegAwIBAgIBKjAKBggqhkjOPQQDAjApMRQwEgYDVQQLEwtlbmdpbmVl\n"
-        + "cmluZzERMA8GA1UEAxMIY2FzaC5hcHAwHhcNNzAwMTAxMDAwMDA1WhcNNzAwMTAx\n"
-        + "MDAwMDEwWjApMRQwEgYDVQQLEwtlbmdpbmVlcmluZzERMA8GA1UEAxMIY2FzaC5h\n"
-        + "cHAwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASda8ChkQXxGELnrV/oBnIAx3dD\n"
-        + "ocUOJfdz4pOJTP6dVQB9U3UBiW5uSX/MoOD0LL5zG3bVyL3Y6pDwKuYvfLNhoyAw\n"
-        + "HjAcBgNVHREBAf8EEjAQhwQBAQEBgghjYXNoLmFwcDAKBggqhkjOPQQDAgNIADBF\n"
-        + "AiAyHHg1N6YDDQiY920+cnI5XSZwEGhAtb9PYWO8bLmkcQIhAI2CfEZf3V/obmdT\n"
-        + "yyaoEufLKVXhrTQhRfodTeigi4RX\n"
-        + "-----END CERTIFICATE-----\n";
-    String pkcs8Pem = ""
-        + "-----BEGIN PRIVATE KEY-----\n"
-        + "MEECAQAwEwYHKoZIzj0CAQYIKoZIzj0DAQcEJzAlAgEBBCA7ODT0xhGSNn4ESj6J\n"
-        + "lu/GJQZoU9lDrCPeUcQ28tzOWw==\n"
-        + "-----END PRIVATE KEY-----\n";
-
-    try {
-      HeldCertificate.decode(certificatePem);
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage("string does not include a private key");
-    }
-
-    try {
-      HeldCertificate.decode(pkcs8Pem);
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage("string does not include a certificate");
-    }
-
-    try {
-      HeldCertificate.decode(certificatePem + pkcs8Pem + certificatePem);
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage("string includes multiple certificates");
-    }
-
-    try {
-      HeldCertificate.decode(pkcs8Pem + certificatePem + pkcs8Pem);
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage("string includes multiple private keys");
-    }
-  }
-
-  @Test public void decodeWrongType() {
-    try {
-      HeldCertificate.decode(""
-          + "-----BEGIN CERTIFICATE-----\n"
-          + "MIIBmjCCAQOgAwIBAgIBATANBgkqhkiG9w0BAQsFADATMREwDwYDVQQDEwhjYXNo\n"
-          + "-----END CERTIFICATE-----\n"
-          + "-----BEGIN RSA PRIVATE KEY-----\n"
-          + "sXPVYAsGD1wizrXX+wFaL3chtF1oG1Fx/jcsSsG6BA==\n"
-          + "-----END RSA PRIVATE KEY-----\n");
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage("unexpected type: RSA PRIVATE KEY");
-    }
-  }
-
-  @Test public void decodeMalformed() {
-    try {
-      HeldCertificate.decode(""
-          + "-----BEGIN CERTIFICATE-----\n"
-          + "MIIBYTCCAQegAwIBAgIBKjAKBggqhkjOPQQDAjApMRQwEgYDVQQLEwtlbmdpbmVl\n"
-          + "-----END CERTIFICATE-----\n"
-          + "-----BEGIN PRIVATE KEY-----\n"
-          + "MEECAQAwEwYHKoZIzj0CAQYIKoZIzj0DAQcEJzAlAgEBBCA7ODT0xhGSNn4ESj6J\n"
-          + "lu/GJQZoU9lDrCPeUcQ28tzOWw==\n"
-          + "-----END PRIVATE KEY-----\n");
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage("failed to decode certificate");
-    }
-    try {
-      HeldCertificate.decode(""
-          + "-----BEGIN CERTIFICATE-----\n"
-          + "MIIBYTCCAQegAwIBAgIBKjAKBggqhkjOPQQDAjApMRQwEgYDVQQLEwtlbmdpbmVl\n"
-          + "cmluZzERMA8GA1UEAxMIY2FzaC5hcHAwHhcNNzAwMTAxMDAwMDA1WhcNNzAwMTAx\n"
-          + "MDAwMDEwWjApMRQwEgYDVQQLEwtlbmdpbmVlcmluZzERMA8GA1UEAxMIY2FzaC5h\n"
-          + "cHAwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAASda8ChkQXxGELnrV/oBnIAx3dD\n"
-          + "ocUOJfdz4pOJTP6dVQB9U3UBiW5uSX/MoOD0LL5zG3bVyL3Y6pDwKuYvfLNhoyAw\n"
-          + "HjAcBgNVHREBAf8EEjAQhwQBAQEBgghjYXNoLmFwcDAKBggqhkjOPQQDAgNIADBF\n"
-          + "AiAyHHg1N6YDDQiY920+cnI5XSZwEGhAtb9PYWO8bLmkcQIhAI2CfEZf3V/obmdT\n"
-          + "yyaoEufLKVXhrTQhRfodTeigi4RX\n"
-          + "-----END CERTIFICATE-----\n"
-          + "-----BEGIN PRIVATE KEY-----\n"
-          + "MEECAQAwEwYHKoZIzj0CAQYIKoZIzj0DAQcEJzAlAgEBBCA7ODT0xhGSNn4ESj6J\n"
-          + "-----END PRIVATE KEY-----\n");
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected).hasMessage("failed to decode private key");
-    }
-  }
-}
diff --git a/okhttp-urlconnection/README.md b/okhttp-urlconnection/README.md
deleted file mode 100644
index 56064181cb..0000000000
--- a/okhttp-urlconnection/README.md
+++ /dev/null
@@ -1,10 +0,0 @@
-OkHttp URLConnection
-====================
-
-This module integrates OkHttp with `Authenticator` and `CookieHandler` from `java.net`.
-
-### Download
-
-```kotlin
-testImplementation("com.squareup.okhttp3:okhttp-urlconnection:4.2.1")
-```
diff --git a/okhttp-urlconnection/build.gradle b/okhttp-urlconnection/build.gradle
deleted file mode 100644
index 5c8a1436c7..0000000000
--- a/okhttp-urlconnection/build.gradle
+++ /dev/null
@@ -1,33 +0,0 @@
-apply plugin: 'com.vanniktech.maven.publish'
-apply plugin: 'me.champeau.gradle.japicmp'
-
-jar {
-  manifest {
-    attributes('Automatic-Module-Name': 'okhttp3.urlconnection')
-  }
-}
-
-dependencies {
-  api project(':okhttp')
-  compileOnly deps.jsr305
-  compileOnly deps.animalSniffer
-
-}
-
-afterEvaluate { project ->
-  project.tasks.dokka {
-    outputDirectory = "$rootDir/docs/4.x"
-    outputFormat = 'gfm'
-  }
-}
-
-task japicmp(type: me.champeau.gradle.japicmp.JapicmpTask, dependsOn: 'jar') {
-  oldClasspath = files(baselineJar(project, baselineVersion))
-  newClasspath = files(jar.archivePath)
-  onlyBinaryIncompatibleModified = true
-  failOnModification = true
-  txtOutputFile = file("$buildDir/reports/japi.txt")
-  ignoreMissingClasses = true
-  includeSynthetic = true
-}
-check.dependsOn(japicmp)
diff --git a/okhttp-urlconnection/gradle.properties b/okhttp-urlconnection/gradle.properties
deleted file mode 100644
index 33c8a52a36..0000000000
--- a/okhttp-urlconnection/gradle.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-POM_ARTIFACT_ID=okhttp-urlconnection
-POM_NAME=okhttp-urlconnection
-POM_PACKAGING=jar
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.kt b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.kt
deleted file mode 100644
index edeba08462..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.kt
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3
-
-import java.io.IOException
-import java.net.Authenticator
-import java.net.InetAddress
-import java.net.InetSocketAddress
-import java.net.Proxy
-
-/**
- * Adapts [Authenticator] to [okhttp3.Authenticator]. Configure OkHttp to use [Authenticator] with
- * [OkHttpClient.Builder.authenticator] or [OkHttpClient.Builder.proxyAuthenticator].
- */
-class JavaNetAuthenticator : okhttp3.Authenticator {
-  @Throws(IOException::class)
-  override fun authenticate(route: Route?, response: Response): Request? {
-    val challenges = response.challenges()
-    val request = response.request
-    val url = request.url
-    val proxyAuthorization = response.code == 407
-    val proxy = route?.proxy ?: Proxy.NO_PROXY
-
-    for (challenge in challenges) {
-      if (!"Basic".equals(challenge.scheme, ignoreCase = true)) {
-        continue
-      }
-
-      val auth = if (proxyAuthorization) {
-        val proxyAddress = proxy.address() as InetSocketAddress
-        Authenticator.requestPasswordAuthentication(
-            proxyAddress.hostName,
-            proxy.connectToInetAddress(url),
-            proxyAddress.port,
-            url.scheme,
-            challenge.realm,
-            challenge.scheme,
-            url.toUrl(),
-            Authenticator.RequestorType.PROXY
-        )
-      } else {
-        Authenticator.requestPasswordAuthentication(
-            url.host,
-            proxy.connectToInetAddress(url),
-            url.port,
-            url.scheme,
-            challenge.realm,
-            challenge.scheme,
-            url.toUrl(),
-            Authenticator.RequestorType.SERVER
-        )
-      }
-
-      if (auth != null) {
-        val credentialHeader = if (proxyAuthorization) "Proxy-Authorization" else "Authorization"
-        val credential = Credentials.basic(
-            auth.userName, String(auth.password), challenge.charset)
-        return request.newBuilder()
-            .header(credentialHeader, credential)
-            .build()
-      }
-    }
-
-    return null // No challenges were satisfied!
-  }
-
-  @Throws(IOException::class)
-  private fun Proxy.connectToInetAddress(url: HttpUrl): InetAddress {
-    return when {
-      type() == Proxy.Type.DIRECT -> InetAddress.getByName(url.host)
-      else -> (address() as InetSocketAddress).address
-    }
-  }
-}
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.kt b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.kt
deleted file mode 100644
index ea8b2fb1ba..0000000000
--- a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetCookieJar.kt
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3
-
-import okhttp3.internal.cookieToString
-import okhttp3.internal.delimiterOffset
-import okhttp3.internal.platform.Platform
-import okhttp3.internal.platform.Platform.Companion.WARN
-import okhttp3.internal.trimSubstring
-import java.io.IOException
-import java.net.CookieHandler
-import java.net.HttpCookie
-import java.util.Collections
-
-/** A cookie jar that delegates to a [java.net.CookieHandler]. */
-class JavaNetCookieJar(private val cookieHandler: CookieHandler) : CookieJar {
-
-  override fun saveFromResponse(url: HttpUrl, cookies: List<Cookie>) {
-    val cookieStrings = mutableListOf<String>()
-    for (cookie in cookies) {
-      cookieStrings.add(cookieToString(cookie, true))
-    }
-    val multimap = mapOf("Set-Cookie" to cookieStrings)
-    try {
-      cookieHandler.put(url.toUri(), multimap)
-    } catch (e: IOException) {
-      Platform.get().log("Saving cookies failed for " + url.resolve("/...")!!, WARN, e)
-    }
-  }
-
-  override fun loadForRequest(url: HttpUrl): List<Cookie> {
-    val cookieHeaders = try {
-      // The RI passes all headers. We don't have 'em, so we don't pass 'em!
-      cookieHandler.get(url.toUri(), emptyMap<String, List<String>>())
-    } catch (e: IOException) {
-      Platform.get().log("Loading cookies failed for " + url.resolve("/...")!!, WARN, e)
-      return emptyList()
-    }
-
-    var cookies: MutableList<Cookie>? = null
-    for ((key, value) in cookieHeaders) {
-      if (("Cookie".equals(key, ignoreCase = true) || "Cookie2".equals(key, ignoreCase = true)) &&
-          value.isNotEmpty()) {
-        for (header in value) {
-          if (cookies == null) cookies = mutableListOf()
-          cookies.addAll(decodeHeaderAsJavaNetCookies(url, header))
-        }
-      }
-    }
-
-    return if (cookies != null) {
-      Collections.unmodifiableList(cookies)
-    } else {
-      emptyList()
-    }
-  }
-
-  /**
-   * Convert a request header to OkHttp's cookies via [HttpCookie]. That extra step handles
-   * multiple cookies in a single request header, which [Cookie.parse] doesn't support.
-   */
-  private fun decodeHeaderAsJavaNetCookies(url: HttpUrl, header: String): List<Cookie> {
-    val result = mutableListOf<Cookie>()
-    var pos = 0
-    val limit = header.length
-    var pairEnd: Int
-    while (pos < limit) {
-      pairEnd = header.delimiterOffset(";,", pos, limit)
-      val equalsSign = header.delimiterOffset('=', pos, pairEnd)
-      val name = header.trimSubstring(pos, equalsSign)
-      if (name.startsWith("$")) {
-        pos = pairEnd + 1
-        continue
-      }
-
-      // We have either name=value or just a name.
-      var value = if (equalsSign < pairEnd) {
-        header.trimSubstring(equalsSign + 1, pairEnd)
-      } else {
-        ""
-      }
-
-      // If the value is "quoted", drop the quotes.
-      if (value.startsWith("\"") && value.endsWith("\"")) {
-        value = value.substring(1, value.length - 1)
-      }
-
-      result.add(Cookie.Builder()
-          .name(name)
-          .value(value)
-          .domain(url.host)
-          .build())
-      pos = pairEnd + 1
-    }
-    return result
-  }
-}
diff --git a/okhttp/build.gradle b/okhttp/build.gradle
index 4af6912edf..b525e78d4a 100644
--- a/okhttp/build.gradle
+++ b/okhttp/build.gradle
@@ -11,17 +11,6 @@ sourceSets {
   main.java.srcDirs += "$buildDir/generated/sources/java-templates/java/main"
 }
 
-compileKotlin {
-  dependsOn 'copyJavaTemplates'
-}
-
-task copyJavaTemplates(type: Copy) {
-  from 'src/main/java-templates'
-  into "$buildDir/generated/sources/java-templates/java/main"
-  expand('projectVersion': "$VERSION_NAME")
-  filteringCharset = 'UTF-8'
-}
-
 dependencies {
   api deps.okio
   api deps.kotlinStdlib
diff --git a/okhttp/src/test/java/okhttp3/AddressTest.java b/okhttp/src/test/java/okhttp3/AddressTest.java
deleted file mode 100644
index 6453d93fa3..0000000000
--- a/okhttp/src/test/java/okhttp3/AddressTest.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.Proxy;
-import java.util.List;
-import javax.net.SocketFactory;
-import okhttp3.internal.http.RecordingProxySelector;
-import org.junit.Test;
-
-import static okhttp3.internal.Util.immutableListOf;
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class AddressTest {
-  private Dns dns = Dns.SYSTEM;
-  private SocketFactory socketFactory = SocketFactory.getDefault();
-  private Authenticator authenticator = Authenticator.NONE;
-  private List<Protocol> protocols = immutableListOf(Protocol.HTTP_1_1);
-  private List<ConnectionSpec> connectionSpecs = immutableListOf(ConnectionSpec.MODERN_TLS);
-  private RecordingProxySelector proxySelector = new RecordingProxySelector();
-
-  @Test public void equalsAndHashcode() throws Exception {
-    Address a = new Address("square.com", 80, dns, socketFactory, null, null, null,
-        authenticator, null, protocols, connectionSpecs, proxySelector);
-    Address b = new Address("square.com", 80, dns, socketFactory, null, null, null,
-        authenticator, null, protocols, connectionSpecs, proxySelector);
-    assertThat(b).isEqualTo(a);
-    assertThat(b.hashCode()).isEqualTo(a.hashCode());
-  }
-
-  @Test public void differentProxySelectorsAreDifferent() throws Exception {
-    Address a = new Address("square.com", 80, dns, socketFactory, null, null, null,
-        authenticator, null, protocols, connectionSpecs, new RecordingProxySelector());
-    Address b = new Address("square.com", 80, dns, socketFactory, null, null, null,
-        authenticator, null, protocols, connectionSpecs, new RecordingProxySelector());
-    assertThat(b).isNotEqualTo(a);
-  }
-
-  @Test public void addressToString() throws Exception {
-    Address address = new Address("square.com", 80, dns, socketFactory, null, null, null,
-        authenticator, null, protocols, connectionSpecs, proxySelector);
-    assertThat(address.toString()).isEqualTo(
-        "Address{square.com:80, proxySelector=RecordingProxySelector}");
-  }
-
-  @Test public void addressWithProxyToString() throws Exception {
-    Address address = new Address("square.com", 80, dns, socketFactory, null, null, null,
-        authenticator, Proxy.NO_PROXY, protocols, connectionSpecs, proxySelector);
-    assertThat(address.toString()).isEqualTo(
-        "Address{square.com:80, proxy=" + Proxy.NO_PROXY + "}");
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/AutobahnTester.java b/okhttp/src/test/java/okhttp3/AutobahnTester.java
deleted file mode 100644
index fa9763ce9a..0000000000
--- a/okhttp/src/test/java/okhttp3/AutobahnTester.java
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicLong;
-import java.util.concurrent.atomic.AtomicReference;
-import okhttp3.internal.Version;
-import okio.ByteString;
-
-/**
- * Exercises the web socket implementation against the <a
- * href="http://autobahn.ws/testsuite/">Autobahn Testsuite</a>.
- */
-public final class AutobahnTester {
-  private static final String HOST = "ws://localhost:9099";
-
-  public static void main(String... args) throws IOException {
-    new AutobahnTester().run();
-  }
-
-  final OkHttpClient client = new OkHttpClient();
-
-  private WebSocket newWebSocket(String path, WebSocketListener listener) {
-    Request request = new Request.Builder().url(HOST + path).build();
-    return client.newWebSocket(request, listener);
-  }
-
-  public void run() throws IOException {
-    try {
-      long count = getTestCount();
-      System.out.println("Test count: " + count);
-
-      for (long number = 1; number <= count; number++) {
-        runTest(number, count);
-      }
-
-      updateReports();
-    } finally {
-      client.dispatcher().executorService().shutdown();
-    }
-  }
-
-  private void runTest(final long number, final long count) {
-    final CountDownLatch latch = new CountDownLatch(1);
-    final AtomicLong startNanos = new AtomicLong();
-    newWebSocket("/runCase?case=" + number + "&agent=okhttp", new WebSocketListener() {
-      @Override public void onOpen(WebSocket webSocket, Response response) {
-        System.out.println("Executing test case " + number + "/" + count);
-        startNanos.set(System.nanoTime());
-      }
-
-      @Override public void onMessage(final WebSocket webSocket, final ByteString bytes) {
-        webSocket.send(bytes);
-      }
-
-      @Override public void onMessage(final WebSocket webSocket, final String text) {
-        webSocket.send(text);
-      }
-
-      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
-        webSocket.close(1000, null);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
-        t.printStackTrace(System.out);
-        latch.countDown();
-      }
-    });
-    try {
-      if (!latch.await(30, TimeUnit.SECONDS)) {
-        throw new IllegalStateException("Timed out waiting for test " + number + " to finish.");
-      }
-    } catch (InterruptedException e) {
-      throw new AssertionError();
-    }
-
-    long endNanos = System.nanoTime();
-    long tookMs = TimeUnit.NANOSECONDS.toMillis(endNanos - startNanos.get());
-    System.out.println("Took " + tookMs + "ms");
-  }
-
-  private long getTestCount() throws IOException {
-    final CountDownLatch latch = new CountDownLatch(1);
-    final AtomicLong countRef = new AtomicLong();
-    final AtomicReference<Throwable> failureRef = new AtomicReference<>();
-    newWebSocket("/getCaseCount", new WebSocketListener() {
-      @Override public void onMessage(WebSocket webSocket, String text) {
-        countRef.set(Long.parseLong(text));
-      }
-
-      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
-        webSocket.close(1000, null);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
-        failureRef.set(t);
-        latch.countDown();
-      }
-    });
-    try {
-      if (!latch.await(10, TimeUnit.SECONDS)) {
-        throw new IllegalStateException("Timed out waiting for count.");
-      }
-    } catch (InterruptedException e) {
-      throw new AssertionError();
-    }
-    Throwable failure = failureRef.get();
-    if (failure != null) {
-      throw new RuntimeException(failure);
-    }
-    return countRef.get();
-  }
-
-  private void updateReports() {
-    final CountDownLatch latch = new CountDownLatch(1);
-    newWebSocket("/updateReports?agent=" + Version.userAgent, new WebSocketListener() {
-      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
-        webSocket.close(1000, null);
-        latch.countDown();
-      }
-
-      @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
-        latch.countDown();
-      }
-    });
-    try {
-      if (!latch.await(10, TimeUnit.SECONDS)) {
-        throw new IllegalStateException("Timed out waiting for count.");
-      }
-    } catch (InterruptedException e) {
-      throw new AssertionError();
-    }
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/CacheControlTest.java b/okhttp/src/test/java/okhttp3/CacheControlTest.java
deleted file mode 100644
index e0f37e952b..0000000000
--- a/okhttp/src/test/java/okhttp3/CacheControlTest.java
+++ /dev/null
@@ -1,197 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.concurrent.TimeUnit;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class CacheControlTest {
-  @Test public void emptyBuilderIsEmpty() throws Exception {
-    CacheControl cacheControl = new CacheControl.Builder().build();
-    assertThat(cacheControl.toString()).isEqualTo("");
-    assertThat(cacheControl.noCache()).isFalse();
-    assertThat(cacheControl.noStore()).isFalse();
-    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(-1);
-    assertThat(cacheControl.sMaxAgeSeconds()).isEqualTo(-1);
-    assertThat(cacheControl.isPrivate()).isFalse();
-    assertThat(cacheControl.isPublic()).isFalse();
-    assertThat(cacheControl.mustRevalidate()).isFalse();
-    assertThat(cacheControl.maxStaleSeconds()).isEqualTo(-1);
-    assertThat(cacheControl.minFreshSeconds()).isEqualTo(-1);
-    assertThat(cacheControl.onlyIfCached()).isFalse();
-    assertThat(cacheControl.mustRevalidate()).isFalse();
-  }
-
-  @Test public void completeBuilder() throws Exception {
-    CacheControl cacheControl = new CacheControl.Builder()
-        .noCache()
-        .noStore()
-        .maxAge(1, TimeUnit.SECONDS)
-        .maxStale(2, TimeUnit.SECONDS)
-        .minFresh(3, TimeUnit.SECONDS)
-        .onlyIfCached()
-        .noTransform()
-        .immutable()
-        .build();
-    assertThat(cacheControl.toString()).isEqualTo(
-        ("no-cache, no-store, max-age=1, max-stale=2, min-fresh=3, only-if-cached, "
-        + "no-transform, immutable"));
-    assertThat(cacheControl.noCache()).isTrue();
-    assertThat(cacheControl.noStore()).isTrue();
-    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(1);
-    assertThat(cacheControl.maxStaleSeconds()).isEqualTo(2);
-    assertThat(cacheControl.minFreshSeconds()).isEqualTo(3);
-    assertThat(cacheControl.onlyIfCached()).isTrue();
-    assertThat(cacheControl.noTransform()).isTrue();
-    assertThat(cacheControl.immutable()).isTrue();
-
-    // These members are accessible to response headers only.
-    assertThat(cacheControl.sMaxAgeSeconds()).isEqualTo(-1);
-    assertThat(cacheControl.isPrivate()).isFalse();
-    assertThat(cacheControl.isPublic()).isFalse();
-    assertThat(cacheControl.mustRevalidate()).isFalse();
-  }
-
-  @Test public void parseEmpty() throws Exception {
-    CacheControl cacheControl = CacheControl.parse(
-        new Headers.Builder().set("Cache-Control", "").build());
-    assertThat(cacheControl.toString()).isEqualTo("");
-    assertThat(cacheControl.noCache()).isFalse();
-    assertThat(cacheControl.noStore()).isFalse();
-    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(-1);
-    assertThat(cacheControl.sMaxAgeSeconds()).isEqualTo(-1);
-    assertThat(cacheControl.isPublic()).isFalse();
-    assertThat(cacheControl.mustRevalidate()).isFalse();
-    assertThat(cacheControl.maxStaleSeconds()).isEqualTo(-1);
-    assertThat(cacheControl.minFreshSeconds()).isEqualTo(-1);
-    assertThat(cacheControl.onlyIfCached()).isFalse();
-    assertThat(cacheControl.mustRevalidate()).isFalse();
-  }
-
-  @Test public void parse() throws Exception {
-    String header = "no-cache, no-store, max-age=1, s-maxage=2, private, public, must-revalidate, "
-        + "max-stale=3, min-fresh=4, only-if-cached, no-transform";
-    CacheControl cacheControl = CacheControl.parse(new Headers.Builder()
-        .set("Cache-Control", header)
-        .build());
-    assertThat(cacheControl.noCache()).isTrue();
-    assertThat(cacheControl.noStore()).isTrue();
-    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(1);
-    assertThat(cacheControl.sMaxAgeSeconds()).isEqualTo(2);
-    assertThat(cacheControl.isPrivate()).isTrue();
-    assertThat(cacheControl.isPublic()).isTrue();
-    assertThat(cacheControl.mustRevalidate()).isTrue();
-    assertThat(cacheControl.maxStaleSeconds()).isEqualTo(3);
-    assertThat(cacheControl.minFreshSeconds()).isEqualTo(4);
-    assertThat(cacheControl.onlyIfCached()).isTrue();
-    assertThat(cacheControl.noTransform()).isTrue();
-    assertThat(cacheControl.toString()).isEqualTo(header);
-  }
-
-  @Test public void parseIgnoreCacheControlExtensions() throws Exception {
-    // Example from http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.6
-    String header = "private, community=\"UCI\"";
-    CacheControl cacheControl = CacheControl.parse(new Headers.Builder()
-        .set("Cache-Control", header)
-        .build());
-    assertThat(cacheControl.noCache()).isFalse();
-    assertThat(cacheControl.noStore()).isFalse();
-    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(-1);
-    assertThat(cacheControl.sMaxAgeSeconds()).isEqualTo(-1);
-    assertThat(cacheControl.isPrivate()).isTrue();
-    assertThat(cacheControl.isPublic()).isFalse();
-    assertThat(cacheControl.mustRevalidate()).isFalse();
-    assertThat(cacheControl.maxStaleSeconds()).isEqualTo(-1);
-    assertThat(cacheControl.minFreshSeconds()).isEqualTo(-1);
-    assertThat(cacheControl.onlyIfCached()).isFalse();
-    assertThat(cacheControl.noTransform()).isFalse();
-    assertThat(cacheControl.immutable()).isFalse();
-    assertThat(cacheControl.toString()).isEqualTo(header);
-  }
-
-  @Test public void parseCacheControlAndPragmaAreCombined() {
-    Headers headers =
-        Headers.of("Cache-Control", "max-age=12", "Pragma", "must-revalidate", "Pragma", "public");
-    CacheControl cacheControl = CacheControl.parse(headers);
-    assertThat(cacheControl.toString()).isEqualTo("max-age=12, public, must-revalidate");
-  }
-
-  @SuppressWarnings("RedundantStringConstructorCall") // Testing instance equality.
-  @Test public void parseCacheControlHeaderValueIsRetained() {
-    String value = new String("max-age=12");
-    Headers headers = Headers.of("Cache-Control", value);
-    CacheControl cacheControl = CacheControl.parse(headers);
-    assertThat(cacheControl.toString()).isSameAs(value);
-  }
-
-  @Test public void parseCacheControlHeaderValueInvalidatedByPragma() {
-    Headers headers = Headers.of(
-        "Cache-Control", "max-age=12",
-        "Pragma", "must-revalidate"
-    );
-    CacheControl cacheControl = CacheControl.parse(headers);
-    assertThat(cacheControl.toString()).isEqualTo("max-age=12, must-revalidate");
-  }
-
-  @Test public void parseCacheControlHeaderValueInvalidatedByTwoValues() {
-    Headers headers = Headers.of(
-        "Cache-Control", "max-age=12",
-        "Cache-Control", "must-revalidate"
-    );
-    CacheControl cacheControl = CacheControl.parse(headers);
-    assertThat(cacheControl.toString()).isEqualTo("max-age=12, must-revalidate");
-  }
-
-  @Test public void parsePragmaHeaderValueIsNotRetained() {
-    Headers headers = Headers.of("Pragma", "must-revalidate");
-    CacheControl cacheControl = CacheControl.parse(headers);
-    assertThat(cacheControl.toString()).isEqualTo("must-revalidate");
-  }
-
-  @Test public void computedHeaderValueIsCached() {
-    CacheControl cacheControl = new CacheControl.Builder()
-        .maxAge(2, TimeUnit.DAYS)
-        .build();
-    assertThat(cacheControl.toString()).isEqualTo("max-age=172800");
-    assertThat(cacheControl.toString()).isSameAs(cacheControl.toString());
-  }
-
-  @Test public void timeDurationTruncatedToMaxValue() throws Exception {
-    CacheControl cacheControl = new CacheControl.Builder()
-        .maxAge(365 * 100, TimeUnit.DAYS) // Longer than Integer.MAX_VALUE seconds.
-        .build();
-    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(Integer.MAX_VALUE);
-  }
-
-  @Test public void secondsMustBeNonNegative() throws Exception {
-    CacheControl.Builder builder = new CacheControl.Builder();
-    try {
-      builder.maxAge(-1, TimeUnit.SECONDS);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void timePrecisionIsTruncatedToSeconds() throws Exception {
-    CacheControl cacheControl = new CacheControl.Builder()
-        .maxAge(4999, TimeUnit.MILLISECONDS)
-        .build();
-    assertThat(cacheControl.maxAgeSeconds()).isEqualTo(4);
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/CacheTest.java b/okhttp/src/test/java/okhttp3/CacheTest.java
deleted file mode 100644
index 29090ec1a2..0000000000
--- a/okhttp/src/test/java/okhttp3/CacheTest.java
+++ /dev/null
@@ -1,2660 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3;
-
-import java.io.File;
-import java.io.IOException;
-import java.net.CookieManager;
-import java.net.HttpURLConnection;
-import java.net.ResponseCache;
-import java.security.Principal;
-import java.security.cert.Certificate;
-import java.text.DateFormat;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
-import java.util.NoSuchElementException;
-import java.util.TimeZone;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-import javax.net.ssl.HostnameVerifier;
-import okhttp3.internal.Internal;
-import okhttp3.internal.io.InMemoryFileSystem;
-import okhttp3.internal.platform.Platform;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.testing.PlatformRule;
-import okhttp3.tls.HandshakeCertificates;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.GzipSink;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static okhttp3.internal.Internal.cacheGet;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.data.Offset.offset;
-import static org.junit.Assert.fail;
-
-public final class CacheTest {
-  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = (name, session) -> true;
-
-  @Rule public MockWebServer server = new MockWebServer();
-  @Rule public MockWebServer server2 = new MockWebServer();
-  @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-  @Rule public final PlatformRule platform = new PlatformRule();
-
-  private final HandshakeCertificates handshakeCertificates = localhost();
-  private OkHttpClient client;
-  private Cache cache;
-  private final CookieManager cookieManager = new CookieManager();
-
-  @Before public void setUp() throws Exception {
-    platform.assumeNotOpenJSSE();
-
-    server.setProtocolNegotiationEnabled(false);
-    cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
-    client = clientTestRule.newClientBuilder()
-        .cache(cache)
-        .cookieJar(new JavaNetCookieJar(cookieManager))
-        .build();
-  }
-
-  @After public void tearDown() throws Exception {
-    ResponseCache.setDefault(null);
-
-    if (cache != null) {
-      cache.delete();
-    }
-  }
-
-  /**
-   * Test that response caching is consistent with the RI and the spec.
-   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4
-   */
-  @Test public void responseCachingByResponseCode() throws Exception {
-    // Test each documented HTTP/1.1 code, plus the first unused value in each range.
-    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html
-
-    // We can't test 100 because it's not really a response.
-    // assertCached(false, 100);
-    assertCached(false, 101);
-    assertCached(false, 102);
-    assertCached(true, 200);
-    assertCached(false, 201);
-    assertCached(false, 202);
-    assertCached(true, 203);
-    assertCached(true, 204);
-    assertCached(false, 205);
-    assertCached(false, 206); //Electing to not cache partial responses
-    assertCached(false, 207);
-    assertCached(true, 300);
-    assertCached(true, 301);
-    assertCached(true, 302);
-    assertCached(false, 303);
-    assertCached(false, 304);
-    assertCached(false, 305);
-    assertCached(false, 306);
-    assertCached(true, 307);
-    assertCached(true, 308);
-    assertCached(false, 400);
-    assertCached(false, 401);
-    assertCached(false, 402);
-    assertCached(false, 403);
-    assertCached(true, 404);
-    assertCached(true, 405);
-    assertCached(false, 406);
-    assertCached(false, 408);
-    assertCached(false, 409);
-    // the HTTP spec permits caching 410s, but the RI doesn't.
-    assertCached(true, 410);
-    assertCached(false, 411);
-    assertCached(false, 412);
-    assertCached(false, 413);
-    assertCached(true, 414);
-    assertCached(false, 415);
-    assertCached(false, 416);
-    assertCached(false, 417);
-    assertCached(false, 418);
-
-    assertCached(false, 500);
-    assertCached(true, 501);
-    assertCached(false, 502);
-    assertCached(false, 503);
-    assertCached(false, 504);
-    assertCached(false, 505);
-    assertCached(false, 506);
-  }
-
-  private void assertCached(boolean shouldPut, int responseCode) throws Exception {
-    int expectedResponseCode = responseCode;
-
-    server = new MockWebServer();
-    MockResponse mockResponse = new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(responseCode)
-        .setBody("ABCDE")
-        .addHeader("WWW-Authenticate: challenge");
-    if (responseCode == HttpURLConnection.HTTP_PROXY_AUTH) {
-      mockResponse.addHeader("Proxy-Authenticate: Basic realm=\"protected area\"");
-    } else if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
-      mockResponse.addHeader("WWW-Authenticate: Basic realm=\"protected area\"");
-    } else if (responseCode == HttpURLConnection.HTTP_NO_CONTENT
-        || responseCode == HttpURLConnection.HTTP_RESET) {
-      mockResponse.setBody(""); // We forbid bodies for 204 and 205.
-    }
-    server.enqueue(mockResponse);
-
-    if (responseCode == HttpURLConnection.HTTP_CLIENT_TIMEOUT) {
-      // 408's are a bit of an outlier because we may repeat the request if we encounter this
-      // response code. In this scenario, there are 2 responses: the initial 408 and then the 200
-      // because of the retry. We just want to ensure the initial 408 isn't cached.
-      expectedResponseCode = 200;
-      server.enqueue(new MockResponse()
-          .setHeader("Cache-Control", "no-store")
-          .setBody("FGHIJ"));
-    }
-
-    server.start();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.code()).isEqualTo(expectedResponseCode);
-
-    // Exhaust the content stream.
-    response.body().string();
-
-    Response cached = cacheGet(cache, request);
-    if (shouldPut) {
-      assertThat(cached).isNotNull();
-      cached.body().close();
-    } else {
-      assertThat(cached).isNull();
-    }
-    server.shutdown(); // tearDown() isn't sufficient; this test starts multiple servers
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
-    testResponseCaching(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithChunkedEncoding() throws IOException {
-    testResponseCaching(TransferKind.CHUNKED);
-  }
-
-  @Test public void responseCachingAndInputStreamSkipWithNoLengthHeaders() throws IOException {
-    testResponseCaching(TransferKind.END_OF_STREAM);
-  }
-
-  /**
-   * Skipping bytes in the input stream caused ResponseCache corruption.
-   * http://code.google.com/p/android/issues/detail?id=8175
-   */
-  private void testResponseCaching(TransferKind transferKind) throws IOException {
-    MockResponse mockResponse = new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setStatus("HTTP/1.1 200 Fantastic");
-    transferKind.setBody(mockResponse, "I love puppies but hate spiders", 1);
-    server.enqueue(mockResponse);
-
-    // Make sure that calling skip() doesn't omit bytes from the cache.
-    Request request = new Request.Builder().url(server.url("/")).build();
-    Response response1 = client.newCall(request).execute();
-
-    BufferedSource in1 = response1.body().source();
-    assertThat(in1.readUtf8("I love ".length())).isEqualTo("I love ");
-    in1.skip("puppies but hate ".length());
-    assertThat(in1.readUtf8("spiders".length())).isEqualTo("spiders");
-    assertThat(in1.exhausted()).isTrue();
-    in1.close();
-    assertThat(cache.writeSuccessCount()).isEqualTo(1);
-    assertThat(cache.writeAbortCount()).isEqualTo(0);
-
-    Response response2 = client.newCall(request).execute();
-    BufferedSource in2 = response2.body().source();
-    assertThat(in2.readUtf8("I love puppies but hate spiders".length())).isEqualTo(
-        "I love puppies but hate spiders");
-    assertThat(response2.code()).isEqualTo(200);
-    assertThat(response2.message()).isEqualTo("Fantastic");
-
-    assertThat(in2.exhausted()).isTrue();
-    in2.close();
-    assertThat(cache.writeSuccessCount()).isEqualTo(1);
-    assertThat(cache.writeAbortCount()).isEqualTo(0);
-    assertThat(cache.requestCount()).isEqualTo(2);
-    assertThat(cache.hitCount()).isEqualTo(1);
-  }
-
-  @Test public void secureResponseCaching() throws IOException {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
-        .build();
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-    Response response1 = client.newCall(request).execute();
-    BufferedSource in = response1.body().source();
-    assertThat(in.readUtf8()).isEqualTo("ABC");
-
-    // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
-    CipherSuite cipherSuite = response1.handshake().cipherSuite();
-    List<Certificate> localCerts = response1.handshake().localCertificates();
-    List<Certificate> serverCerts = response1.handshake().peerCertificates();
-    Principal peerPrincipal = response1.handshake().peerPrincipal();
-    Principal localPrincipal = response1.handshake().localPrincipal();
-
-    Response response2 = client.newCall(request).execute(); // Cached!
-    assertThat(response2.body().string()).isEqualTo("ABC");
-
-    assertThat(cache.requestCount()).isEqualTo(2);
-    assertThat(cache.networkCount()).isEqualTo(1);
-    assertThat(cache.hitCount()).isEqualTo(1);
-
-    assertThat(response2.handshake().cipherSuite()).isEqualTo(cipherSuite);
-    assertThat(response2.handshake().localCertificates()).isEqualTo(localCerts);
-    assertThat(response2.handshake().peerCertificates()).isEqualTo(serverCerts);
-    assertThat(response2.handshake().peerPrincipal()).isEqualTo(peerPrincipal);
-    assertThat(response2.handshake().localPrincipal()).isEqualTo(localPrincipal);
-  }
-
-  @Test public void responseCachingAndRedirects() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-    Response response1 = client.newCall(request).execute();
-    assertThat(response1.body().string()).isEqualTo("ABC");
-
-    Response response2 = client.newCall(request).execute(); // Cached!
-    assertThat(response2.body().string()).isEqualTo("ABC");
-
-    // 2 requests + 2 redirects
-    assertThat(cache.requestCount()).isEqualTo(4);
-    assertThat(cache.networkCount()).isEqualTo(2);
-    assertThat(cache.hitCount()).isEqualTo(2);
-  }
-
-  @Test public void redirectToCachedResult() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    Request request1 = new Request.Builder().url(server.url("/foo")).build();
-    Response response1 = client.newCall(request1).execute();
-    assertThat(response1.body().string()).isEqualTo("ABC");
-    RecordedRequest recordedRequest1 = server.takeRequest();
-    assertThat(recordedRequest1.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
-    assertThat(recordedRequest1.getSequenceNumber()).isEqualTo(0);
-
-    Request request2 = new Request.Builder().url(server.url("/bar")).build();
-    Response response2 = client.newCall(request2).execute();
-    assertThat(response2.body().string()).isEqualTo("ABC");
-    RecordedRequest recordedRequest2 = server.takeRequest();
-    assertThat(recordedRequest2.getRequestLine()).isEqualTo("GET /bar HTTP/1.1");
-    assertThat(recordedRequest2.getSequenceNumber()).isEqualTo(1);
-
-    // an unrelated request should reuse the pooled connection
-    Request request3 = new Request.Builder().url(server.url("/baz")).build();
-    Response response3 = client.newCall(request3).execute();
-    assertThat(response3.body().string()).isEqualTo("DEF");
-    RecordedRequest recordedRequest3 = server.takeRequest();
-    assertThat(recordedRequest3.getRequestLine()).isEqualTo("GET /baz HTTP/1.1");
-    assertThat(recordedRequest3.getSequenceNumber()).isEqualTo(2);
-  }
-
-  @Test public void secureResponseCachingAndRedirects() throws IOException {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
-        .build();
-
-    Response response1 = get(server.url("/"));
-    assertThat(response1.body().string()).isEqualTo("ABC");
-    assertThat(response1.handshake().cipherSuite()).isNotNull();
-
-    // Cached!
-    Response response2 = get(server.url("/"));
-    assertThat(response2.body().string()).isEqualTo("ABC");
-    assertThat(response2.handshake().cipherSuite()).isNotNull();
-
-    // 2 direct + 2 redirect = 4
-    assertThat(cache.requestCount()).isEqualTo(4);
-    assertThat(cache.hitCount()).isEqualTo(2);
-    assertThat(response2.handshake().cipherSuite()).isEqualTo(
-        response1.handshake().cipherSuite());
-  }
-
-  /**
-   * We've had bugs where caching and cross-protocol redirects yield class cast exceptions internal
-   * to the cache because we incorrectly assumed that HttpsURLConnection was always HTTPS and
-   * HttpURLConnection was always HTTP; in practice redirects mean that each can do either.
-   *
-   * https://github.com/square/okhttp/issues/214
-   */
-  @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
-    server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server2.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setBody("ABC"));
-    server2.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-        .addHeader("Location: " + server2.url("/")));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
-        .build();
-
-    Response response1 = get(server.url("/"));
-    assertThat(response1.body().string()).isEqualTo("ABC");
-
-    // Cached!
-    Response response2 = get(server.url("/"));
-    assertThat(response2.body().string()).isEqualTo("ABC");
-
-    // 2 direct + 2 redirect = 4
-    assertThat(cache.requestCount()).isEqualTo(4);
-    assertThat(cache.hitCount()).isEqualTo(2);
-  }
-
-  @Test public void foundCachedWithExpiresHeader() throws Exception {
-    temporaryRedirectCachedWithCachingHeader(302, "Expires", formatDate(1, TimeUnit.HOURS));
-  }
-
-  @Test public void foundCachedWithCacheControlHeader() throws Exception {
-    temporaryRedirectCachedWithCachingHeader(302, "Cache-Control", "max-age=60");
-  }
-
-  @Test public void temporaryRedirectCachedWithExpiresHeader() throws Exception {
-    temporaryRedirectCachedWithCachingHeader(307, "Expires", formatDate(1, TimeUnit.HOURS));
-  }
-
-  @Test public void temporaryRedirectCachedWithCacheControlHeader() throws Exception {
-    temporaryRedirectCachedWithCachingHeader(307, "Cache-Control", "max-age=60");
-  }
-
-  @Test public void foundNotCachedWithoutCacheHeader() throws Exception {
-    temporaryRedirectNotCachedWithoutCachingHeader(302);
-  }
-
-  @Test public void temporaryRedirectNotCachedWithoutCacheHeader() throws Exception {
-    temporaryRedirectNotCachedWithoutCachingHeader(307);
-  }
-
-  private void temporaryRedirectCachedWithCachingHeader(
-      int responseCode, String headerName, String headerValue) throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(responseCode)
-        .addHeader(headerName, headerValue)
-        .addHeader("Location", "/a"));
-    server.enqueue(new MockResponse()
-        .addHeader(headerName, headerValue)
-        .setBody("a"));
-    server.enqueue(new MockResponse()
-        .setBody("b"));
-    server.enqueue(new MockResponse()
-        .setBody("c"));
-
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("a");
-    assertThat(get(url).body().string()).isEqualTo("a");
-  }
-
-  private void temporaryRedirectNotCachedWithoutCachingHeader(int responseCode) throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(responseCode)
-        .addHeader("Location", "/a"));
-    server.enqueue(new MockResponse()
-        .setBody("a"));
-    server.enqueue(new MockResponse()
-        .setBody("b"));
-
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("a");
-    assertThat(get(url).body().string()).isEqualTo("b");
-  }
-
-  /** https://github.com/square/okhttp/issues/2198 */
-  @Test public void cachedRedirect() throws IOException {
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Location: /bar"));
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-
-    Request request1 = new Request.Builder().url(server.url("/")).build();
-    Response response1 = client.newCall(request1).execute();
-    assertThat(response1.body().string()).isEqualTo("ABC");
-
-    Request request2 = new Request.Builder().url(server.url("/")).build();
-    Response response2 = client.newCall(request2).execute();
-    assertThat(response2.body().string()).isEqualTo("ABC");
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
-    testServerPrematureDisconnect(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithChunkedEncoding() throws IOException {
-    testServerPrematureDisconnect(TransferKind.CHUNKED);
-  }
-
-  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() throws IOException {
-    // Intentionally empty. This case doesn't make sense because there's no
-    // such thing as a premature disconnect when the disconnect itself
-    // indicates the end of the data stream.
-  }
-
-  private void testServerPrematureDisconnect(TransferKind transferKind) throws IOException {
-    MockResponse mockResponse = new MockResponse();
-    transferKind.setBody(mockResponse, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 16);
-    server.enqueue(truncateViolently(mockResponse, 16));
-    server.enqueue(new MockResponse()
-        .setBody("Request #2"));
-
-    BufferedSource bodySource = get(server.url("/")).body().source();
-    assertThat(bodySource.readUtf8Line()).isEqualTo("ABCDE");
-    try {
-      bodySource.readUtf8(21);
-      fail("This implementation silently ignored a truncated HTTP body.");
-    } catch (IOException expected) {
-    } finally {
-      bodySource.close();
-    }
-
-    assertThat(cache.writeAbortCount()).isEqualTo(1);
-    assertThat(cache.writeSuccessCount()).isEqualTo(0);
-    Response response = get(server.url("/"));
-    assertThat(response.body().string()).isEqualTo("Request #2");
-    assertThat(cache.writeAbortCount()).isEqualTo(1);
-    assertThat(cache.writeSuccessCount()).isEqualTo(1);
-  }
-
-  @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
-    testClientPrematureDisconnect(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void clientPrematureDisconnectWithChunkedEncoding() throws IOException {
-    testClientPrematureDisconnect(TransferKind.CHUNKED);
-  }
-
-  @Test public void clientPrematureDisconnectWithNoLengthHeaders() throws IOException {
-    testClientPrematureDisconnect(TransferKind.END_OF_STREAM);
-  }
-
-  private void testClientPrematureDisconnect(TransferKind transferKind) throws IOException {
-    // Setting a low transfer speed ensures that stream discarding will time out.
-    MockResponse mockResponse = new MockResponse()
-        .throttleBody(6, 1, TimeUnit.SECONDS);
-    transferKind.setBody(mockResponse, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 1024);
-    server.enqueue(mockResponse);
-    server.enqueue(new MockResponse()
-        .setBody("Request #2"));
-
-    Response response1 = get(server.url("/"));
-    BufferedSource in = response1.body().source();
-    assertThat(in.readUtf8(5)).isEqualTo("ABCDE");
-    in.close();
-    try {
-      in.readByte();
-      fail("Expected an IllegalStateException because the source is closed.");
-    } catch (IllegalStateException expected) {
-    }
-
-    assertThat(cache.writeAbortCount()).isEqualTo(1);
-    assertThat(cache.writeSuccessCount()).isEqualTo(0);
-    Response response2 = get(server.url("/"));
-    assertThat(response2.body().string()).isEqualTo("Request #2");
-    assertThat(cache.writeAbortCount()).isEqualTo(1);
-    assertThat(cache.writeSuccessCount()).isEqualTo(1);
-  }
-
-  @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
-    //      last modified: 105 seconds ago
-    //             served:   5 seconds ago
-    //   default lifetime: (105 - 5) / 10 = 10 seconds
-    //            expires:  10 seconds from served date = 5 seconds from now
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
-        .setBody("A"));
-
-    HttpUrl url = server.url("/");
-    Response response1 = get(url);
-    assertThat(response1.body().string()).isEqualTo("A");
-
-    Response response2 = get(url);
-    assertThat(response2.body().string()).isEqualTo("A");
-    assertThat(response2.header("Warning")).isNull();
-  }
-
-  @Test public void defaultExpirationDateConditionallyCached() throws Exception {
-    //      last modified: 115 seconds ago
-    //             served:  15 seconds ago
-    //   default lifetime: (115 - 15) / 10 = 10 seconds
-    //            expires:  10 seconds from served date = 5 seconds ago
-    String lastModifiedDate = formatDate(-115, TimeUnit.SECONDS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
-    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isEqualTo(
-        lastModifiedDate);
-  }
-
-  @Test public void defaultExpirationDateFullyCachedForMoreThan24Hours() throws Exception {
-    //      last modified: 105 days ago
-    //             served:   5 days ago
-    //   default lifetime: (105 - 5) / 10 = 10 days
-    //            expires:  10 days from served date = 5 days from now
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.DAYS))
-        .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
-        .setBody("A"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    Response response = get(server.url("/"));
-    assertThat(response.body().string()).isEqualTo("A");
-    assertThat(response.header("Warning")).isEqualTo(
-        "113 HttpURLConnection \"Heuristic expiration\"");
-  }
-
-  @Test public void noDefaultExpirationForUrlsWithQueryString() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/").newBuilder().addQueryParameter("foo", "bar").build();
-    assertThat(get(url).body().string()).isEqualTo("A");
-    assertThat(get(url).body().string()).isEqualTo("B");
-  }
-
-  @Test public void expirationDateInThePastWithLastModifiedHeader() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isEqualTo(
-        lastModifiedDate);
-  }
-
-  @Test public void expirationDateInThePastWithNoLastModifiedHeader() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-  }
-
-  @Test public void expirationDateInTheFuture() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  @Test public void maxAgePreferredWithMaxAgeAndExpires() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInThePastWithDateAndLastModifiedHeaders() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Cache-Control: max-age=60"));
-    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isEqualTo(
-        lastModifiedDate);
-  }
-
-  @Test public void maxAgeInThePastWithDateHeaderButNoLastModifiedHeader() throws Exception {
-    // Chrome interprets max-age relative to the local clock. Both our cache
-    // and Firefox both use the earlier of the local and server's clock.
-    assertNotCached(new MockResponse()
-        .addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithDateHeader() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithNoDateHeader() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeWithLastModifiedButNoServedDate() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgeInTheFutureWithDateAndLastModifiedHeaders() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void maxAgePreferredOverLowerSharedMaxAge() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: s-maxage=60")
-        .addHeader("Cache-Control: max-age=180"));
-  }
-
-  @Test public void maxAgePreferredOverHigherMaxAge() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: s-maxage=180")
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void requestMethodOptionsIsNotCached() throws Exception {
-    testRequestMethod("OPTIONS", false);
-  }
-
-  @Test public void requestMethodGetIsCached() throws Exception {
-    testRequestMethod("GET", true);
-  }
-
-  @Test public void requestMethodHeadIsNotCached() throws Exception {
-    // We could support this but choose not to for implementation simplicity
-    testRequestMethod("HEAD", false);
-  }
-
-  @Test public void requestMethodPostIsNotCached() throws Exception {
-    // We could support this but choose not to for implementation simplicity
-    testRequestMethod("POST", false);
-  }
-
-  @Test public void requestMethodPutIsNotCached() throws Exception {
-    testRequestMethod("PUT", false);
-  }
-
-  @Test public void requestMethodDeleteIsNotCached() throws Exception {
-    testRequestMethod("DELETE", false);
-  }
-
-  @Test public void requestMethodTraceIsNotCached() throws Exception {
-    testRequestMethod("TRACE", false);
-  }
-
-  private void testRequestMethod(String requestMethod, boolean expectCached) throws Exception {
-    // 1. Seed the cache (potentially).
-    // 2. Expect a cache hit or miss.
-    server.enqueue(new MockResponse()
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("X-Response-ID: 1"));
-    server.enqueue(new MockResponse()
-        .addHeader("X-Response-ID: 2"));
-
-    HttpUrl url = server.url("/");
-
-    Request request = new Request.Builder()
-        .url(url)
-        .method(requestMethod, requestBodyOrNull(requestMethod))
-        .build();
-    Response response1 = client.newCall(request).execute();
-    response1.body().close();
-    assertThat(response1.header("X-Response-ID")).isEqualTo("1");
-
-    Response response2 = get(url);
-    response2.body().close();
-    if (expectCached) {
-      assertThat(response2.header("X-Response-ID")).isEqualTo("1");
-    } else {
-      assertThat(response2.header("X-Response-ID")).isEqualTo("2");
-    }
-  }
-
-  private RequestBody requestBodyOrNull(String requestMethod) {
-    return (requestMethod.equals("POST") || requestMethod.equals("PUT"))
-        ? RequestBody.create("foo", MediaType.get("text/plain"))
-        : null;
-  }
-
-  @Test public void postInvalidatesCache() throws Exception {
-    testMethodInvalidates("POST");
-  }
-
-  @Test public void putInvalidatesCache() throws Exception {
-    testMethodInvalidates("PUT");
-  }
-
-  @Test public void deleteMethodInvalidatesCache() throws Exception {
-    testMethodInvalidates("DELETE");
-  }
-
-  private void testMethodInvalidates(String requestMethod) throws Exception {
-    // 1. Seed the cache.
-    // 2. Invalidate it.
-    // 3. Expect a cache miss.
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-    server.enqueue(new MockResponse()
-        .setBody("C"));
-
-    HttpUrl url = server.url("/");
-
-    assertThat(get(url).body().string()).isEqualTo("A");
-
-    Request request = new Request.Builder()
-        .url(url)
-        .method(requestMethod, requestBodyOrNull(requestMethod))
-        .build();
-    Response invalidate = client.newCall(request).execute();
-    assertThat(invalidate.body().string()).isEqualTo("B");
-
-    assertThat(get(url).body().string()).isEqualTo("C");
-  }
-
-  @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
-    // 1. Seed the cache.
-    // 2. Invalidate it with an uncacheable response.
-    // 3. Expect a cache miss.
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setBody("B")
-        .setResponseCode(500));
-    server.enqueue(new MockResponse()
-        .setBody("C"));
-
-    HttpUrl url = server.url("/");
-
-    assertThat(get(url).body().string()).isEqualTo("A");
-
-    Request request = new Request.Builder()
-        .url(url)
-        .method("POST", requestBodyOrNull("POST"))
-        .build();
-    Response invalidate = client.newCall(request).execute();
-    assertThat(invalidate.body().string()).isEqualTo("B");
-
-    assertThat(get(url).body().string()).isEqualTo("C");
-  }
-
-  @Test public void putInvalidatesWithNoContentResponse() throws Exception {
-    // 1. Seed the cache.
-    // 2. Invalidate it.
-    // 3. Expect a cache miss.
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .setResponseCode(HttpURLConnection.HTTP_NO_CONTENT));
-    server.enqueue(new MockResponse()
-        .setBody("C"));
-
-    HttpUrl url = server.url("/");
-
-    assertThat(get(url).body().string()).isEqualTo("A");
-
-    Request request = new Request.Builder()
-        .url(url)
-        .put(RequestBody.create("foo", MediaType.get("text/plain")))
-        .build();
-    Response invalidate = client.newCall(request).execute();
-    assertThat(invalidate.body().string()).isEqualTo("");
-
-    assertThat(get(url).body().string()).isEqualTo("C");
-  }
-
-  @Test public void etag() throws Exception {
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("ETag: v1"));
-    assertThat(conditionalRequest.getHeader("If-None-Match")).isEqualTo("v1");
-  }
-
-  /** If both If-Modified-Since and If-None-Match conditions apply, send only If-None-Match. */
-  @Test public void etagAndExpirationDateInThePast() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("ETag: v1")
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    assertThat(conditionalRequest.getHeader("If-None-Match")).isEqualTo("v1");
-    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isNull();
-  }
-
-  @Test public void etagAndExpirationDateInTheFuture() throws Exception {
-    assertFullyCached(new MockResponse()
-        .addHeader("ETag: v1")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  @Test public void cacheControlNoCache() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Cache-Control: no-cache"));
-  }
-
-  @Test public void cacheControlNoCacheAndExpirationDateInTheFuture() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: no-cache"));
-    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isEqualTo(
-        lastModifiedDate);
-  }
-
-  @Test public void pragmaNoCache() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Pragma: no-cache"));
-  }
-
-  @Test public void pragmaNoCacheAndExpirationDateInTheFuture() throws Exception {
-    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Pragma: no-cache"));
-    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isEqualTo(
-        lastModifiedDate);
-  }
-
-  @Test public void cacheControlNoStore() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Cache-Control: no-store"));
-  }
-
-  @Test public void cacheControlNoStoreAndExpirationDateInTheFuture() throws Exception {
-    assertNotCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: no-store"));
-  }
-
-  @Test public void partialRangeResponsesDoNotCorruptCache() throws Exception {
-    // 1. Request a range.
-    // 2. Request a full document, expecting a cache miss.
-    server.enqueue(new MockResponse()
-        .setBody("AA")
-        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
-        .addHeader("Content-Range: bytes 1000-1001/2000"));
-    server.enqueue(new MockResponse()
-        .setBody("BB"));
-
-    HttpUrl url = server.url("/");
-
-    Request request = new Request.Builder()
-        .url(url)
-        .header("Range", "bytes=1000-1001")
-        .build();
-    Response range = client.newCall(request).execute();
-    assertThat(range.body().string()).isEqualTo("AA");
-
-    assertThat(get(url).body().string()).isEqualTo("BB");
-  }
-
-  /**
-   * When the server returns a full response body we will store it and return it regardless of what
-   * its Last-Modified date is. This behavior was different prior to OkHttp 3.5 when we would prefer
-   * the response with the later Last-Modified date.
-   *
-   * https://github.com/square/okhttp/issues/2886
-   */
-  @Test public void serverReturnsDocumentOlderThanCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setBody("B")
-        .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    HttpUrl url = server.url("/");
-
-    assertThat(get(url).body().string()).isEqualTo("A");
-    assertThat(get(url).body().string()).isEqualTo("B");
-    assertThat(get(url).body().string()).isEqualTo("B");
-  }
-
-  @Test public void clientSideNoStore() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("B"));
-
-    Request request1 = new Request.Builder()
-        .url(server.url("/"))
-        .cacheControl(new CacheControl.Builder().noStore().build())
-        .build();
-    Response response1 = client.newCall(request1).execute();
-    assertThat(response1.body().string()).isEqualTo("A");
-
-    Request request2 = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response2 = client.newCall(request2).execute();
-    assertThat(response2.body().string()).isEqualTo("B");
-  }
-
-  @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
-    assertNonIdentityEncodingCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-  }
-
-  @Test public void nonIdentityEncodingAndFullCache() throws Exception {
-    assertNonIdentityEncodingCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-  }
-
-  private void assertNonIdentityEncodingCached(MockResponse response) throws Exception {
-    server.enqueue(response
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    // At least three request/response pairs are required because after the first request is cached
-    // a different execution path might be taken. Thus modifications to the cache applied during
-    // the second request might not be visible until another request is performed.
-    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
-  }
-
-  @Test public void previouslyNotGzippedContentIsNotModifiedAndSpecifiesGzipEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-            .setBody("ABCABCABC")
-            .addHeader("Content-Type: text/plain")
-            .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-            .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
-            .addHeader("Content-Type: text/plain")
-            .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse()
-            .setBody("DEFDEFDEF"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("DEFDEFDEF");
-  }
-
-  @Test public void changedGzippedContentIsNotModifiedAndSpecifiesNewEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-            .setBody(gzip("ABCABCABC"))
-            .addHeader("Content-Type: text/plain")
-            .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS))
-            .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse()
-            .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
-            .addHeader("Content-Type: text/plain")
-            .addHeader("Content-Encoding: identity"));
-    server.enqueue(new MockResponse()
-            .setBody("DEFDEFDEF"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("DEFDEFDEF");
-  }
-
-  @Test public void notModifiedSpecifiesEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
-        .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse()
-        .setBody("DEFDEFDEF"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("DEFDEFDEF");
-  }
-
-  /** https://github.com/square/okhttp/issues/947 */
-  @Test public void gzipAndVaryOnAcceptEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip")
-        .addHeader("Vary: Accept-Encoding")
-        .addHeader("Cache-Control: max-age=60"));
-    server.enqueue(new MockResponse()
-        .setBody("FAIL"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("ABCABCABC");
-  }
-
-  @Test public void conditionalCacheHitIsNotDoublePooled() throws Exception {
-    clientTestRule.ensureAllConnectionsReleased();
-
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v1")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    assertThat(client.connectionPool().idleConnectionCount()).isEqualTo(1);
-  }
-
-  @Test public void expiresDateBeforeModifiedDate() throws Exception {
-    assertConditionallyCached(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Expires: " + formatDate(-2, TimeUnit.HOURS)));
-  }
-
-  @Test public void requestMaxAge() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
-        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES))
-        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "max-age=30")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("B");
-  }
-
-  @Test public void requestMinFresh() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "min-fresh=120")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("B");
-  }
-
-  @Test public void requestMaxStale() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=120")
-        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "max-stale=180")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("A");
-    assertThat(response.header("Warning")).isEqualTo(
-        "110 HttpURLConnection \"Response is stale\"");
-  }
-
-  @Test public void requestMaxStaleDirectiveWithNoValue() throws IOException {
-    // Add a stale response to the cache.
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=120")
-        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-
-    // With max-stale, we'll return that stale response.
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "max-stale")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("A");
-    assertThat(response.header("Warning")).isEqualTo(
-        "110 HttpURLConnection \"Response is stale\"");
-  }
-
-  @Test public void requestMaxStaleNotHonoredWithMustRevalidate() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=120, must-revalidate")
-        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "max-stale=180")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("B");
-  }
-
-  @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
-    // (no responses enqueued)
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "only-if-cached")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().source().exhausted()).isTrue();
-    assertThat(response.code()).isEqualTo(504);
-    assertThat(cache.requestCount()).isEqualTo(1);
-    assertThat(cache.networkCount()).isEqualTo(0);
-    assertThat(cache.hitCount()).isEqualTo(0);
-  }
-
-  @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "only-if-cached")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("A");
-    assertThat(cache.requestCount()).isEqualTo(2);
-    assertThat(cache.networkCount()).isEqualTo(1);
-    assertThat(cache.hitCount()).isEqualTo(1);
-  }
-
-  @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "only-if-cached")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().source().exhausted()).isTrue();
-    assertThat(response.code()).isEqualTo(504);
-    assertThat(cache.requestCount()).isEqualTo(2);
-    assertThat(cache.networkCount()).isEqualTo(1);
-    assertThat(cache.hitCount()).isEqualTo(0);
-  }
-
-  @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Cache-Control", "only-if-cached")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().source().exhausted()).isTrue();
-    assertThat(response.code()).isEqualTo(504);
-    assertThat(cache.requestCount()).isEqualTo(2);
-    assertThat(cache.networkCount()).isEqualTo(1);
-    assertThat(cache.hitCount()).isEqualTo(0);
-  }
-
-  @Test public void requestCacheControlNoCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("A");
-    Request request = new Request.Builder()
-        .url(url)
-        .header("Cache-Control", "no-cache")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("B");
-  }
-
-  @Test public void requestPragmaNoCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
-        .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("A");
-    Request request = new Request.Builder()
-        .url(url)
-        .header("Pragma", "no-cache")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("B");
-  }
-
-  @Test public void clientSuppliedIfModifiedSinceWithCachedResult() throws Exception {
-    MockResponse response = new MockResponse()
-        .addHeader("ETag: v3")
-        .addHeader("Cache-Control: max-age=0");
-    String ifModifiedSinceDate = formatDate(-24, TimeUnit.HOURS);
-    RecordedRequest request =
-        assertClientSuppliedCondition(response, "If-Modified-Since", ifModifiedSinceDate);
-    assertThat(request.getHeader("If-Modified-Since")).isEqualTo(ifModifiedSinceDate);
-    assertThat(request.getHeader("If-None-Match")).isNull();
-  }
-
-  @Test public void clientSuppliedIfNoneMatchSinceWithCachedResult() throws Exception {
-    String lastModifiedDate = formatDate(-3, TimeUnit.MINUTES);
-    MockResponse response = new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
-        .addHeader("Cache-Control: max-age=0");
-    RecordedRequest request = assertClientSuppliedCondition(response, "If-None-Match", "v1");
-    assertThat(request.getHeader("If-None-Match")).isEqualTo("v1");
-    assertThat(request.getHeader("If-Modified-Since")).isNull();
-  }
-
-  private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String conditionName,
-      String conditionValue) throws Exception {
-    server.enqueue(seed.setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("A");
-
-    Request request = new Request.Builder()
-        .url(url)
-        .header(conditionName, conditionValue)
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.code()).isEqualTo(HttpURLConnection.HTTP_NOT_MODIFIED);
-    assertThat(response.body().string()).isEqualTo("");
-
-    server.takeRequest(); // seed
-    return server.takeRequest();
-  }
-
-  /**
-   * For Last-Modified and Date headers, we should echo the date back in the exact format we were
-   * served.
-   */
-  @Test public void retainServedDateFormat() throws Exception {
-    // Serve a response with a non-standard date format that OkHttp supports.
-    Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
-    Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
-    DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
-    dateFormat.setTimeZone(TimeZone.getTimeZone("America/New_York"));
-    String lastModifiedString = dateFormat.format(lastModifiedDate);
-    String servedString = dateFormat.format(servedDate);
-
-    // This response should be conditionally cached.
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + lastModifiedString)
-        .addHeader("Expires: " + servedString)
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-
-    // The first request has no conditions.
-    RecordedRequest request1 = server.takeRequest();
-    assertThat(request1.getHeader("If-Modified-Since")).isNull();
-
-    // The 2nd request uses the server's date format.
-    RecordedRequest request2 = server.takeRequest();
-    assertThat(request2.getHeader("If-Modified-Since")).isEqualTo(lastModifiedString);
-  }
-
-  @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("If-Modified-Since", formatDate(-24, TimeUnit.HOURS))
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.code()).isEqualTo(HttpURLConnection.HTTP_NOT_MODIFIED);
-    assertThat(response.body().string()).isEqualTo("");
-  }
-
-  @Test public void authorizationRequestFullyCached() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    Request request = new Request.Builder()
-        .url(url)
-        .header("Authorization", "password")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("A");
-    assertThat(get(url).body().string()).isEqualTo("A");
-  }
-
-  @Test public void contentLocationDoesNotPopulateCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Content-Location: /bar")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertThat(get(server.url("/foo")).body().string()).isEqualTo("A");
-    assertThat(get(server.url("/bar")).body().string()).isEqualTo("B");
-  }
-
-  @Test public void connectionIsReturnedToPoolAfterConditionalSuccess() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertThat(get(server.url("/a")).body().string()).isEqualTo("A");
-    assertThat(get(server.url("/a")).body().string()).isEqualTo("A");
-    assertThat(get(server.url("/b")).body().string()).isEqualTo("B");
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
-  }
-
-  @Test public void statisticsConditionalCacheMiss() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-    server.enqueue(new MockResponse()
-        .setBody("C"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    assertThat(cache.requestCount()).isEqualTo(1);
-    assertThat(cache.networkCount()).isEqualTo(1);
-    assertThat(cache.hitCount()).isEqualTo(0);
-    assertThat(get(server.url("/")).body().string()).isEqualTo("B");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("C");
-    assertThat(cache.requestCount()).isEqualTo(3);
-    assertThat(cache.networkCount()).isEqualTo(3);
-    assertThat(cache.hitCount()).isEqualTo(0);
-  }
-
-  @Test public void statisticsConditionalCacheHit() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    assertThat(cache.requestCount()).isEqualTo(1);
-    assertThat(cache.networkCount()).isEqualTo(1);
-    assertThat(cache.hitCount()).isEqualTo(0);
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    assertThat(cache.requestCount()).isEqualTo(3);
-    assertThat(cache.networkCount()).isEqualTo(3);
-    assertThat(cache.hitCount()).isEqualTo(2);
-  }
-
-  @Test public void statisticsFullCacheHit() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    assertThat(cache.requestCount()).isEqualTo(1);
-    assertThat(cache.networkCount()).isEqualTo(1);
-    assertThat(cache.hitCount()).isEqualTo(0);
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    assertThat(cache.requestCount()).isEqualTo(3);
-    assertThat(cache.networkCount()).isEqualTo(1);
-    assertThat(cache.hitCount()).isEqualTo(2);
-  }
-
-  @Test public void varyMatchesChangedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    Request frRequest = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "fr-CA")
-        .build();
-    Response frResponse = client.newCall(frRequest).execute();
-    assertThat(frResponse.body().string()).isEqualTo("A");
-
-    Request enRequest = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "en-US")
-        .build();
-    Response enResponse = client.newCall(enRequest).execute();
-    assertThat(enResponse.body().string()).isEqualTo("B");
-  }
-
-  @Test public void varyMatchesUnchangedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    Request request = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "fr-CA")
-        .build();
-    Response response1 = client.newCall(request).execute();
-    assertThat(response1.body().string()).isEqualTo("A");
-    Request request1 = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "fr-CA")
-        .build();
-    Response response2 = client.newCall(request1).execute();
-    assertThat(response2.body().string()).isEqualTo("A");
-  }
-
-  @Test public void varyMatchesAbsentRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-  }
-
-  @Test public void varyMatchesAddedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    Request request = new Request.Builder()
-        .url(server.url("/")).header("Foo", "bar")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("B");
-  }
-
-  @Test public void varyMatchesRemovedRequestHeaderField() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Foo")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/")).header("Foo", "bar")
-        .build();
-    Response fooresponse = client.newCall(request).execute();
-    assertThat(fooresponse.body().string()).isEqualTo("A");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("B");
-  }
-
-  @Test public void varyFieldsAreCaseInsensitive() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: ACCEPT-LANGUAGE")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    Request request = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "fr-CA")
-        .build();
-    Response response1 = client.newCall(request).execute();
-    assertThat(response1.body().string()).isEqualTo("A");
-    Request request1 = new Request.Builder()
-        .url(url)
-        .header("accept-language", "fr-CA")
-        .build();
-    Response response2 = client.newCall(request1).execute();
-    assertThat(response2.body().string()).isEqualTo("A");
-  }
-
-  @Test public void varyMultipleFieldsWithMatch() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language, Accept-Charset")
-        .addHeader("Vary: Accept-Encoding")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    Request request = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "fr-CA")
-        .header("Accept-Charset", "UTF-8")
-        .header("Accept-Encoding", "identity")
-        .build();
-    Response response1 = client.newCall(request).execute();
-    assertThat(response1.body().string()).isEqualTo("A");
-    Request request1 = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "fr-CA")
-        .header("Accept-Charset", "UTF-8")
-        .header("Accept-Encoding", "identity")
-        .build();
-    Response response2 = client.newCall(request1).execute();
-    assertThat(response2.body().string()).isEqualTo("A");
-  }
-
-  @Test public void varyMultipleFieldsWithNoMatch() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language, Accept-Charset")
-        .addHeader("Vary: Accept-Encoding")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    Request frRequest = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "fr-CA")
-        .header("Accept-Charset", "UTF-8")
-        .header("Accept-Encoding", "identity")
-        .build();
-    Response frResponse = client.newCall(frRequest).execute();
-    assertThat(frResponse.body().string()).isEqualTo("A");
-    Request enRequest = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "en-CA")
-        .header("Accept-Charset", "UTF-8")
-        .header("Accept-Encoding", "identity")
-        .build();
-    Response enResponse = client.newCall(enRequest).execute();
-    assertThat(enResponse.body().string()).isEqualTo("B");
-  }
-
-  @Test public void varyMultipleFieldValuesWithMatch() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    Request request1 = new Request.Builder()
-        .url(url)
-        .addHeader("Accept-Language", "fr-CA, fr-FR")
-        .addHeader("Accept-Language", "en-US")
-        .build();
-    Response response1 = client.newCall(request1).execute();
-    assertThat(response1.body().string()).isEqualTo("A");
-
-    Request request2 = new Request.Builder()
-        .url(url)
-        .addHeader("Accept-Language", "fr-CA, fr-FR")
-        .addHeader("Accept-Language", "en-US")
-        .build();
-    Response response2 = client.newCall(request2).execute();
-    assertThat(response2.body().string()).isEqualTo("A");
-  }
-
-  @Test public void varyMultipleFieldValuesWithNoMatch() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    Request request1 = new Request.Builder()
-        .url(url)
-        .addHeader("Accept-Language", "fr-CA, fr-FR")
-        .addHeader("Accept-Language", "en-US")
-        .build();
-    Response response1 = client.newCall(request1).execute();
-    assertThat(response1.body().string()).isEqualTo("A");
-
-    Request request2 = new Request.Builder()
-        .url(url)
-        .addHeader("Accept-Language", "fr-CA")
-        .addHeader("Accept-Language", "en-US")
-        .build();
-    Response response2 = client.newCall(request2).execute();
-    assertThat(response2.body().string()).isEqualTo("B");
-  }
-
-  @Test public void varyAsterisk() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: *")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    assertThat(get(server.url("/")).body().string()).isEqualTo("B");
-  }
-
-  @Test public void varyAndHttps() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Language")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
-        .build();
-
-    HttpUrl url = server.url("/");
-    Request request1 = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "en-US")
-        .build();
-    Response response1 = client.newCall(request1).execute();
-    assertThat(response1.body().string()).isEqualTo("A");
-
-    Request request2 = new Request.Builder()
-        .url(url)
-        .header("Accept-Language", "en-US")
-        .build();
-    Response response2 = client.newCall(request2).execute();
-    assertThat(response2.body().string()).isEqualTo("A");
-  }
-
-  @Test public void cachePlusCookies() throws Exception {
-    RecordingCookieJar cookieJar = new RecordingCookieJar();
-    client = client.newBuilder()
-        .cookieJar(cookieJar)
-        .build();
-
-    server.enqueue(new MockResponse()
-        .addHeader("Set-Cookie: a=FIRST")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Set-Cookie: a=SECOND")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("A");
-    cookieJar.assertResponseCookies("a=FIRST; path=/");
-    assertThat(get(url).body().string()).isEqualTo("A");
-    cookieJar.assertResponseCookies("a=SECOND; path=/");
-  }
-
-  @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Allow: GET, HEAD")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Allow: GET, HEAD, PUT")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    Response response1 = get(server.url("/"));
-    assertThat(response1.body().string()).isEqualTo("A");
-    assertThat(response1.header("Allow")).isEqualTo("GET, HEAD");
-
-    Response response2 = get(server.url("/"));
-    assertThat(response2.body().string()).isEqualTo("A");
-    assertThat(response2.header("Allow")).isEqualTo("GET, HEAD, PUT");
-  }
-
-  @Test public void getHeadersReturnsCachedHopByHopHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Transfer-Encoding: identity")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Transfer-Encoding: none")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    Response response1 = get(server.url("/"));
-    assertThat(response1.body().string()).isEqualTo("A");
-    assertThat(response1.header("Transfer-Encoding")).isEqualTo("identity");
-
-    Response response2 = get(server.url("/"));
-    assertThat(response2.body().string()).isEqualTo("A");
-    assertThat(response2.header("Transfer-Encoding")).isEqualTo("identity");
-  }
-
-  @Test public void getHeadersDeletesCached100LevelWarnings() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Warning: 199 test danger")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    Response response1 = get(server.url("/"));
-    assertThat(response1.body().string()).isEqualTo("A");
-    assertThat(response1.header("Warning")).isEqualTo("199 test danger");
-
-    Response response2 = get(server.url("/"));
-    assertThat(response2.body().string()).isEqualTo("A");
-    assertThat(response2.header("Warning")).isNull();
-  }
-
-  @Test public void getHeadersRetainsCached200LevelWarnings() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Warning: 299 test danger")
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    Response response1 = get(server.url("/"));
-    assertThat(response1.body().string()).isEqualTo("A");
-    assertThat(response1.header("Warning")).isEqualTo("299 test danger");
-
-    Response response2 = get(server.url("/"));
-    assertThat(response2.body().string()).isEqualTo("A");
-    assertThat(response2.header("Warning")).isEqualTo("299 test danger");
-  }
-
-  @Test public void doNotCachePartialResponse() throws Exception {
-    assertNotCached(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
-        .addHeader("Content-Range: bytes 100-100/200")
-        .addHeader("Cache-Control: max-age=60"));
-  }
-
-  @Test public void conditionalHitUpdatesCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Allow: GET, HEAD")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    // A cache miss writes the cache.
-    long t0 = System.currentTimeMillis();
-    Response response1 = get(server.url("/a"));
-    assertThat(response1.body().string()).isEqualTo("A");
-    assertThat(response1.header("Allow")).isNull();
-    assertThat((double) (response1.receivedResponseAtMillis() - t0)).isCloseTo(
-        (double) 0, offset(250.0));
-
-    // A conditional cache hit updates the cache.
-    Thread.sleep(500); // Make sure t0 and t1 are distinct.
-    long t1 = System.currentTimeMillis();
-    Response response2 = get(server.url("/a"));
-    assertThat(response2.code()).isEqualTo(HttpURLConnection.HTTP_OK);
-    assertThat(response2.body().string()).isEqualTo("A");
-    assertThat(response2.header("Allow")).isEqualTo("GET, HEAD");
-    assertThat((double) (response2.receivedResponseAtMillis() - t1)).isCloseTo(
-        (double) 0, offset(250.0));
-
-    // A full cache hit reads the cache.
-    Thread.sleep(500); // Make sure t1 and t2 are distinct.
-    long t2 = System.currentTimeMillis();
-    Response response3 = get(server.url("/a"));
-    assertThat(response3.body().string()).isEqualTo("A");
-    assertThat(response3.header("Allow")).isEqualTo("GET, HEAD");
-    assertThat((double) (response3.receivedResponseAtMillis() - t1)).isCloseTo(
-        (double) 0, offset(250.0));
-
-    assertThat(server.getRequestCount()).isEqualTo(2);
-  }
-
-  @Test public void responseSourceHeaderCached() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    Request request = new Request.Builder()
-        .url(server.url("/")).header("Cache-Control", "only-if-cached")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("A");
-  }
-
-  @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(-31, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setBody("B")
-        .addHeader("Cache-Control: max-age=30")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    Response response = get(server.url("/"));
-    assertThat(response.body().string()).isEqualTo("B");
-  }
-
-  @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .addHeader("Cache-Control: max-age=0")
-        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
-    server.enqueue(new MockResponse()
-        .setResponseCode(304));
-
-    assertThat(get(server.url("/")).body().string()).isEqualTo("A");
-    Response response = get(server.url("/"));
-    assertThat(response.body().string()).isEqualTo("A");
-  }
-
-  @Test public void responseSourceHeaderFetched() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    Response response = get(server.url("/"));
-    assertThat(response.body().string()).isEqualTo("A");
-  }
-
-  @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
-    Headers.Builder headers = new Headers.Builder()
-        .add("Cache-Control: max-age=120");
-    Internal.addHeaderLenient(headers, ": A");
-    server.enqueue(new MockResponse()
-        .setHeaders(headers.build())
-        .setBody("body"));
-
-    Response response = get(server.url("/"));
-    assertThat(response.header("")).isEqualTo("A");
-    assertThat(response.body().string()).isEqualTo("body");
-  }
-
-  /**
-   * Old implementations of OkHttp's response cache wrote header fields like ":status: 200 OK". This
-   * broke our cached response parser because it split on the first colon. This regression test
-   * exists to help us read these old bad cache entries.
-   *
-   * https://github.com/square/okhttp/issues/227
-   */
-  @Test public void testGoldenCacheResponse() throws Exception {
-    cache.close();
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    HttpUrl url = server.url("/");
-    String urlKey = Cache.key(url);
-    String entryMetadata = ""
-        + "" + url + "\n"
-        + "GET\n"
-        + "0\n"
-        + "HTTP/1.1 200 OK\n"
-        + "7\n"
-        + ":status: 200 OK\n"
-        + ":version: HTTP/1.1\n"
-        + "etag: foo\n"
-        + "content-length: 3\n"
-        + "OkHttp-Received-Millis: " + System.currentTimeMillis() + "\n"
-        + "X-Android-Response-Source: NETWORK 200\n"
-        + "OkHttp-Sent-Millis: " + System.currentTimeMillis() + "\n"
-        + "\n"
-        + "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA\n"
-        + "1\n"
-        + "MIIBpDCCAQ2gAwIBAgIBATANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDEw1qd2lsc29uLmxvY2FsMB4XDTEzMDgy"
-        + "OTA1MDE1OVoXDTEzMDgzMDA1MDE1OVowGDEWMBQGA1UEAxMNandpbHNvbi5sb2NhbDCBnzANBgkqhkiG9w0BAQEF"
-        + "AAOBjQAwgYkCgYEAlFW+rGo/YikCcRghOyKkJanmVmJSce/p2/jH1QvNIFKizZdh8AKNwojt3ywRWaDULA/RlCUc"
-        + "ltF3HGNsCyjQI/+Lf40x7JpxXF8oim1E6EtDoYtGWAseelawus3IQ13nmo6nWzfyCA55KhAWf4VipelEy8DjcuFK"
-        + "v6L0xwXnI0ECAwEAATANBgkqhkiG9w0BAQsFAAOBgQAuluNyPo1HksU3+Mr/PyRQIQS4BI7pRXN8mcejXmqyscdP"
-        + "7S6J21FBFeRR8/XNjVOp4HT9uSc2hrRtTEHEZCmpyoxixbnM706ikTmC7SN/GgM+SmcoJ1ipJcNcl8N0X6zym4dm"
-        + "yFfXKHu2PkTo7QFdpOJFvP3lIigcSZXozfmEDg==\n"
-        + "-1\n";
-    String entryBody = "abc";
-    String journalBody = ""
-        + "libcore.io.DiskLruCache\n"
-        + "1\n"
-        + "201105\n"
-        + "2\n"
-        + "\n"
-        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
-    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
-    writeFile(cache.directory(), urlKey + ".1", entryBody);
-    writeFile(cache.directory(), "journal", journalBody);
-    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    Response response = get(url);
-    assertThat(response.body().string()).isEqualTo(entryBody);
-    assertThat(response.header("Content-Length")).isEqualTo("3");
-    assertThat(response.header("etag")).isEqualTo("foo");
-  }
-
-  /** Exercise the cache format in OkHttp 2.7 and all earlier releases. */
-  @Test public void testGoldenCacheHttpsResponseOkHttp27() throws Exception {
-    HttpUrl url = server.url("/");
-    String urlKey = Cache.key(url);
-    String prefix = Platform.get().getPrefix();
-    String entryMetadata = ""
-        + "" + url + "\n"
-        + "GET\n"
-        + "0\n"
-        + "HTTP/1.1 200 OK\n"
-        + "4\n"
-        + "Content-Length: 3\n"
-        + prefix + "-Received-Millis: " + System.currentTimeMillis() + "\n"
-        + prefix + "-Sent-Millis: " + System.currentTimeMillis() + "\n"
-        + "Cache-Control: max-age=60\n"
-        + "\n"
-        + "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n"
-        + "1\n"
-        + "MIIBnDCCAQWgAwIBAgIBATANBgkqhkiG9w0BAQsFADAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwHhcNMTUxMjIyMDEx"
-        + "MTQwWhcNMTUxMjIzMDExMTQwWjAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ"
-        + "AoGBAJTn2Dh8xYmegvpOSmsKb2Os6Cxf1L4fYbnHr/turInUD5r1P7ZAuxurY880q3GT5bUDoirS3IfucddrT1Ac"
-        + "AmUzEmk/FDjggiP8DlxFkY/XwXBlhRDVIp/mRuASPMGInckc0ZaixOkRFyrxADj+r1eaSmXCIvV5yTY6IaIokLj1"
-        + "AgMBAAEwDQYJKoZIhvcNAQELBQADgYEAFblnedqtfRqI9j2WDyPPoG0NTZf9xwjeUu+ju+Ktty8u9k7Lgrrd/DH2"
-        + "mQEtBD1Ctvp91MJfAClNg3faZzwClUyu5pd0QXRZEUwSwZQNen2QWDHRlVsItclBJ4t+AJLqTbwofWi4m4K8REOl"
-        + "593hD55E4+lY22JZiVQyjsQhe6I=\n"
-        + "0\n";
-    String entryBody = "abc";
-    String journalBody = ""
-        + "libcore.io.DiskLruCache\n"
-        + "1\n"
-        + "201105\n"
-        + "2\n"
-        + "\n"
-        + "DIRTY " + urlKey + "\n"
-        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
-    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
-    writeFile(cache.directory(), urlKey + ".1", entryBody);
-    writeFile(cache.directory(), "journal", journalBody);
-    cache.close();
-    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    Response response = get(url);
-    assertThat(response.body().string()).isEqualTo(entryBody);
-    assertThat(response.header("Content-Length")).isEqualTo("3");
-  }
-
-  /** The TLS version is present in OkHttp 3.0 and beyond. */
-  @Test public void testGoldenCacheHttpsResponseOkHttp30() throws Exception {
-    HttpUrl url = server.url("/");
-    String urlKey = Cache.key(url);
-    String prefix = Platform.get().getPrefix();
-    String entryMetadata = ""
-        + "" + url + "\n"
-        + "GET\n"
-        + "0\n"
-        + "HTTP/1.1 200 OK\n"
-        + "4\n"
-        + "Content-Length: 3\n"
-        + prefix + "-Received-Millis: " + System.currentTimeMillis() + "\n"
-        + prefix + "-Sent-Millis: " + System.currentTimeMillis() + "\n"
-        + "Cache-Control: max-age=60\n"
-        + "\n"
-        + "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n"
-        + "1\n"
-        + "MIIBnDCCAQWgAwIBAgIBATANBgkqhkiG9w0BAQsFADAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwHhcNMTUxMjIyMDEx"
-        + "MTQwWhcNMTUxMjIzMDExMTQwWjAUMRIwEAYDVQQDEwlsb2NhbGhvc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ"
-        + "AoGBAJTn2Dh8xYmegvpOSmsKb2Os6Cxf1L4fYbnHr/turInUD5r1P7ZAuxurY880q3GT5bUDoirS3IfucddrT1Ac"
-        + "AmUzEmk/FDjggiP8DlxFkY/XwXBlhRDVIp/mRuASPMGInckc0ZaixOkRFyrxADj+r1eaSmXCIvV5yTY6IaIokLj1"
-        + "AgMBAAEwDQYJKoZIhvcNAQELBQADgYEAFblnedqtfRqI9j2WDyPPoG0NTZf9xwjeUu+ju+Ktty8u9k7Lgrrd/DH2"
-        + "mQEtBD1Ctvp91MJfAClNg3faZzwClUyu5pd0QXRZEUwSwZQNen2QWDHRlVsItclBJ4t+AJLqTbwofWi4m4K8REOl"
-        + "593hD55E4+lY22JZiVQyjsQhe6I=\n"
-        + "0\n"
-        + "TLSv1.2\n";
-    String entryBody = "abc";
-    String journalBody = ""
-        + "libcore.io.DiskLruCache\n"
-        + "1\n"
-        + "201105\n"
-        + "2\n"
-        + "\n"
-        + "DIRTY " + urlKey + "\n"
-        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
-    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
-    writeFile(cache.directory(), urlKey + ".1", entryBody);
-    writeFile(cache.directory(), "journal", journalBody);
-    cache.close();
-    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    Response response = get(url);
-    assertThat(response.body().string()).isEqualTo(entryBody);
-    assertThat(response.header("Content-Length")).isEqualTo("3");
-  }
-
-  @Test public void testGoldenCacheHttpResponseOkHttp30() throws Exception {
-    HttpUrl url = server.url("/");
-    String urlKey = Cache.key(url);
-    String prefix = Platform.get().getPrefix();
-    String entryMetadata = ""
-        + "" + url + "\n"
-        + "GET\n"
-        + "0\n"
-        + "HTTP/1.1 200 OK\n"
-        + "4\n"
-        + "Cache-Control: max-age=60\n"
-        + "Content-Length: 3\n"
-        + prefix + "-Received-Millis: " + System.currentTimeMillis() + "\n"
-        + prefix + "-Sent-Millis: " + System.currentTimeMillis() + "\n";
-    String entryBody = "abc";
-    String journalBody = ""
-        + "libcore.io.DiskLruCache\n"
-        + "1\n"
-        + "201105\n"
-        + "2\n"
-        + "\n"
-        + "DIRTY " + urlKey + "\n"
-        + "CLEAN " + urlKey + " " + entryMetadata.length() + " " + entryBody.length() + "\n";
-    writeFile(cache.directory(), urlKey + ".0", entryMetadata);
-    writeFile(cache.directory(), urlKey + ".1", entryBody);
-    writeFile(cache.directory(), "journal", journalBody);
-    cache.close();
-    cache = new Cache(cache.directory(), Integer.MAX_VALUE, fileSystem);
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    Response response = get(url);
-    assertThat(response.body().string()).isEqualTo(entryBody);
-    assertThat(response.header("Content-Length")).isEqualTo("3");
-  }
-
-  @Test public void evictAll() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("A");
-    client.cache().evictAll();
-    assertThat(client.cache().size()).isEqualTo(0);
-    assertThat(get(url).body().string()).isEqualTo("B");
-  }
-
-  @Test public void networkInterceptorInvokedForConditionalGet() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v1")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    // Seed the cache.
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("A");
-
-    final AtomicReference<String> ifNoneMatch = new AtomicReference<>();
-    client = client.newBuilder()
-        .addNetworkInterceptor(chain -> {
-          ifNoneMatch.compareAndSet(null, chain.request().header("If-None-Match"));
-          return chain.proceed(chain.request());
-        })
-        .build();
-
-    // Confirm the value is cached and intercepted.
-    assertThat(get(url).body().string()).isEqualTo("A");
-    assertThat(ifNoneMatch.get()).isEqualTo("v1");
-  }
-
-  @Test public void networkInterceptorNotInvokedForFullyCached() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("A"));
-
-    // Seed the cache.
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("A");
-
-    // Confirm the interceptor isn't exercised.
-    client = client.newBuilder()
-        .addNetworkInterceptor(chain -> { throw new AssertionError(); })
-        .build();
-    assertThat(get(url).body().string()).isEqualTo("A");
-  }
-
-  @Test public void iterateCache() throws Exception {
-    // Put some responses in the cache.
-    server.enqueue(new MockResponse()
-        .setBody("a"));
-    HttpUrl urlA = server.url("/a");
-    assertThat(get(urlA).body().string()).isEqualTo("a");
-
-    server.enqueue(new MockResponse()
-        .setBody("b"));
-    HttpUrl urlB = server.url("/b");
-    assertThat(get(urlB).body().string()).isEqualTo("b");
-
-    server.enqueue(new MockResponse()
-        .setBody("c"));
-    HttpUrl urlC = server.url("/c");
-    assertThat(get(urlC).body().string()).isEqualTo("c");
-
-    // Confirm the iterator returns those responses...
-    Iterator<String> i = cache.urls();
-    assertThat(i.hasNext()).isTrue();
-    assertThat(i.next()).isEqualTo(urlA.toString());
-    assertThat(i.hasNext()).isTrue();
-    assertThat(i.next()).isEqualTo(urlB.toString());
-    assertThat(i.hasNext()).isTrue();
-    assertThat(i.next()).isEqualTo(urlC.toString());
-
-    // ... and nothing else.
-    assertThat(i.hasNext()).isFalse();
-    try {
-      i.next();
-      fail();
-    } catch (NoSuchElementException expected) {
-    }
-  }
-
-  @Test public void iteratorRemoveFromCache() throws Exception {
-    // Put a response in the cache.
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control: max-age=60")
-        .setBody("a"));
-    HttpUrl url = server.url("/a");
-    assertThat(get(url).body().string()).isEqualTo("a");
-
-    // Remove it with iteration.
-    Iterator<String> i = cache.urls();
-    assertThat(i.next()).isEqualTo(url.toString());
-    i.remove();
-
-    // Confirm that subsequent requests suffer a cache miss.
-    server.enqueue(new MockResponse()
-        .setBody("b"));
-    assertThat(get(url).body().string()).isEqualTo("b");
-  }
-
-  @Test public void iteratorRemoveWithoutNextThrows() throws Exception {
-    // Put a response in the cache.
-    server.enqueue(new MockResponse()
-        .setBody("a"));
-    HttpUrl url = server.url("/a");
-    assertThat(get(url).body().string()).isEqualTo("a");
-
-    Iterator<String> i = cache.urls();
-    assertThat(i.hasNext()).isTrue();
-    try {
-      i.remove();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void iteratorRemoveOncePerCallToNext() throws Exception {
-    // Put a response in the cache.
-    server.enqueue(new MockResponse()
-        .setBody("a"));
-    HttpUrl url = server.url("/a");
-    assertThat(get(url).body().string()).isEqualTo("a");
-
-    Iterator<String> i = cache.urls();
-    assertThat(i.next()).isEqualTo(url.toString());
-    i.remove();
-
-    // Too many calls to remove().
-    try {
-      i.remove();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void elementEvictedBetweenHasNextAndNext() throws Exception {
-    // Put a response in the cache.
-    server.enqueue(new MockResponse()
-        .setBody("a"));
-    HttpUrl url = server.url("/a");
-    assertThat(get(url).body().string()).isEqualTo("a");
-
-    // The URL will remain available if hasNext() returned true...
-    Iterator<String> i = cache.urls();
-    assertThat(i.hasNext()).isTrue();
-
-    // ...so even when we evict the element, we still get something back.
-    cache.evictAll();
-    assertThat(i.next()).isEqualTo(url.toString());
-
-    // Remove does nothing. But most importantly, it doesn't throw!
-    i.remove();
-  }
-
-  @Test public void elementEvictedBeforeHasNextIsOmitted() throws Exception {
-    // Put a response in the cache.
-    server.enqueue(new MockResponse()
-        .setBody("a"));
-    HttpUrl url = server.url("/a");
-    assertThat(get(url).body().string()).isEqualTo("a");
-
-    Iterator<String> i = cache.urls();
-    cache.evictAll();
-
-    // The URL was evicted before hasNext() made any promises.
-    assertThat(i.hasNext()).isFalse();
-    try {
-      i.next();
-      fail();
-    } catch (NoSuchElementException expected) {
-    }
-  }
-
-  /** Test https://github.com/square/okhttp/issues/1712. */
-  @Test public void conditionalMissUpdatesCache() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v1")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v2")
-        .setBody("B"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("A");
-    assertThat(get(url).body().string()).isEqualTo("A");
-    assertThat(get(url).body().string()).isEqualTo("B");
-    assertThat(get(url).body().string()).isEqualTo("B");
-
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v1");
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v1");
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v2");
-  }
-
-  @Test public void combinedCacheHeadersCanBeNonAscii() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
-        .addHeader("Cache-Control: max-age=0")
-        .addHeaderLenient("Alpha", "")
-        .addHeaderLenient("", "Beta")
-        .setBody("abcd"));
-    server.enqueue(new MockResponse()
-        .addHeader("Transfer-Encoding: none")
-        .addHeaderLenient("Gamma", "")
-        .addHeaderLenient("", "Delta")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    Response response1 = get(server.url("/"));
-    assertThat(response1.header("Alpha")).isEqualTo("");
-    assertThat(response1.header("")).isEqualTo("Beta");
-    assertThat(response1.body().string()).isEqualTo("abcd");
-
-    Response response2 = get(server.url("/"));
-    assertThat(response2.header("Alpha")).isEqualTo("");
-    assertThat(response2.header("")).isEqualTo("Beta");
-    assertThat(response2.header("Gamma")).isEqualTo("");
-    assertThat(response2.header("")).isEqualTo("Delta");
-    assertThat(response2.body().string()).isEqualTo("abcd");
-  }
-
-  @Test public void etagConditionCanBeNonAscii() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeaderLenient("Etag", "")
-        .addHeader("Cache-Control: max-age=0")
-        .setBody("abcd"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    Response response1 = get(server.url("/"));
-    assertThat(response1.body().string()).isEqualTo("abcd");
-
-    Response response2 = get(server.url("/"));
-    assertThat(response2.body().string()).isEqualTo("abcd");
-
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("");
-  }
-
-  @Test public void conditionalHitHeadersCombined() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Etag", "a")
-        .addHeader("Cache-Control: max-age=0")
-        .addHeader("A: a1")
-        .addHeader("B: b2")
-        .addHeader("B: b3")
-        .setBody("abcd"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
-        .addHeader("B: b4")
-        .addHeader("B: b5")
-        .addHeader("C: c6"));
-
-    Response response1 = get(server.url("/"));
-    assertThat(response1.body().string()).isEqualTo("abcd");
-    assertThat(response1.headers()).isEqualTo(Headers.of("Etag", "a", "Cache-Control", "max-age=0",
-        "A", "a1", "B", "b2", "B", "b3", "Content-Length", "4"));
-
-    // The original 'A' header is retained because the network response doesn't have one.
-    // The original 'B' headers are replaced by the network response.
-    // The network's 'C' header is added.
-    Response response2 = get(server.url("/"));
-    assertThat(response2.body().string()).isEqualTo("abcd");
-    assertThat(response2.headers()).isEqualTo(Headers.of("Etag", "a", "Cache-Control", "max-age=0",
-        "A", "a1", "Content-Length", "4", "B", "b4", "B", "b5", "C", "c6"));
-  }
-
-  private Response get(HttpUrl url) throws IOException {
-    Request request = new Request.Builder()
-        .url(url)
-        .build();
-    return client.newCall(request).execute();
-  }
-
-  private void writeFile(File directory, String file, String content) throws IOException {
-    BufferedSink sink = Okio.buffer(fileSystem.sink(new File(directory, file)));
-    sink.writeUtf8(content);
-    sink.close();
-  }
-
-  /**
-   * @param delta the offset from the current date to use. Negative values yield dates in the past;
-   * positive values yield dates in the future.
-   */
-  private String formatDate(long delta, TimeUnit timeUnit) {
-    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
-  }
-
-  private String formatDate(Date date) {
-    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
-    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
-    return rfc1123.format(date);
-  }
-
-  private void assertNotCached(MockResponse response) throws Exception {
-    server.enqueue(response.setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("A");
-    assertThat(get(url).body().string()).isEqualTo("B");
-  }
-
-  /** @return the request with the conditional get headers. */
-  private RecordedRequest assertConditionallyCached(MockResponse response) throws Exception {
-    // scenario 1: condition succeeds
-    server.enqueue(response.setBody("A").setStatus("HTTP/1.1 200 A-OK"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    // scenario 2: condition fails
-    server.enqueue(response.setBody("B")
-        .setStatus("HTTP/1.1 200 B-OK"));
-    server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 200 C-OK")
-        .setBody("C"));
-
-    HttpUrl valid = server.url("/valid");
-    Response response1 = get(valid);
-    assertThat(response1.body().string()).isEqualTo("A");
-    assertThat(response1.code()).isEqualTo(HttpURLConnection.HTTP_OK);
-    assertThat(response1.message()).isEqualTo("A-OK");
-    Response response2 = get(valid);
-    assertThat(response2.body().string()).isEqualTo("A");
-    assertThat(response2.code()).isEqualTo(HttpURLConnection.HTTP_OK);
-    assertThat(response2.message()).isEqualTo("A-OK");
-
-    HttpUrl invalid = server.url("/invalid");
-    Response response3 = get(invalid);
-    assertThat(response3.body().string()).isEqualTo("B");
-    assertThat(response3.code()).isEqualTo(HttpURLConnection.HTTP_OK);
-    assertThat(response3.message()).isEqualTo("B-OK");
-    Response response4 = get(invalid);
-    assertThat(response4.body().string()).isEqualTo("C");
-    assertThat(response4.code()).isEqualTo(HttpURLConnection.HTTP_OK);
-    assertThat(response4.message()).isEqualTo("C-OK");
-
-    server.takeRequest(); // regular get
-    return server.takeRequest(); // conditional get
-  }
-
-  @Test public void immutableIsCached() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control", "immutable, max-age=10")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("A");
-    assertThat(get(url).body().string()).isEqualTo("A");
-  }
-
-  @Test public void immutableIsCachedAfterMultipleCalls() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Cache-Control", "immutable, max-age=10")
-        .setBody("B"));
-    server.enqueue(new MockResponse()
-        .setBody("C"));
-
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("A");
-    assertThat(get(url).body().string()).isEqualTo("B");
-    assertThat(get(url).body().string()).isEqualTo("B");
-  }
-
-  @Test public void immutableIsNotCachedBeyondFreshnessLifetime() throws Exception {
-    //      last modified: 115 seconds ago
-    //             served:  15 seconds ago
-    //   default lifetime: (115 - 15) / 10 = 10 seconds
-    //            expires:  10 seconds from served date = 5 seconds ago
-    String lastModifiedDate = formatDate(-115, TimeUnit.SECONDS);
-    RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
-        .addHeader("Cache-Control: immutable")
-        .addHeader("Last-Modified: " + lastModifiedDate)
-        .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
-    assertThat(conditionalRequest.getHeader("If-Modified-Since")).isEqualTo(
-        lastModifiedDate);
-  }
-
-  private void assertFullyCached(MockResponse response) throws Exception {
-    server.enqueue(response.setBody("A"));
-    server.enqueue(response.setBody("B"));
-
-    HttpUrl url = server.url("/");
-    assertThat(get(url).body().string()).isEqualTo("A");
-    assertThat(get(url).body().string()).isEqualTo("A");
-  }
-
-  /**
-   * Shortens the body of {@code response} but not the corresponding headers. Only useful to test
-   * how clients respond to the premature conclusion of the HTTP body.
-   */
-  private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
-    response.setSocketPolicy(DISCONNECT_AT_END);
-    Headers headers = response.getHeaders();
-    Buffer truncatedBody = new Buffer();
-    truncatedBody.write(response.getBody(), numBytesToKeep);
-    response.setBody(truncatedBody);
-    response.setHeaders(headers);
-    return response;
-  }
-
-  enum TransferKind {
-    CHUNKED {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setChunkedBody(content, chunkSize);
-      }
-    },
-    FIXED_LENGTH {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-      }
-    },
-    END_OF_STREAM {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-        response.setSocketPolicy(DISCONNECT_AT_END);
-        response.removeHeader("Content-Length");
-      }
-    };
-
-    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
-
-    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
-      setBody(response, new Buffer().writeUtf8(content), chunkSize);
-    }
-  }
-
-  /** Returns a gzipped copy of {@code bytes}. */
-  public Buffer gzip(String data) throws IOException {
-    Buffer result = new Buffer();
-    BufferedSink sink = Okio.buffer(new GzipSink(result));
-    sink.writeUtf8(data);
-    sink.close();
-    return result;
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/CallKotlinTest.kt b/okhttp/src/test/java/okhttp3/CallKotlinTest.kt
deleted file mode 100644
index f70e6c46ad..0000000000
--- a/okhttp/src/test/java/okhttp3/CallKotlinTest.kt
+++ /dev/null
@@ -1,171 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3
-
-import okhttp3.MediaType.Companion.toMediaType
-import okhttp3.mockwebserver.MockResponse
-import okhttp3.mockwebserver.MockWebServer
-import okhttp3.testing.PlatformRule
-import okhttp3.tls.internal.TlsUtil.localhost
-import okio.BufferedSink
-import org.assertj.core.api.Assertions.assertThat
-import org.junit.Assert.assertEquals
-import org.junit.Assert.fail
-import org.junit.Rule
-import org.junit.Test
-import org.junit.rules.TestRule
-import org.junit.rules.Timeout
-import java.io.IOException
-import java.security.cert.X509Certificate
-import java.util.concurrent.TimeUnit
-
-class CallKotlinTest {
-  @JvmField @Rule val platform = PlatformRule()
-  @JvmField @Rule val timeout: TestRule = Timeout(30_000, TimeUnit.MILLISECONDS)
-  @JvmField @Rule val server = MockWebServer()
-  @JvmField @Rule val clientTestRule = OkHttpClientTestRule()
-
-  private var client = clientTestRule.newClient()
-  private val handshakeCertificates = localhost()
-
-  @Test
-  fun legalToExecuteTwiceCloning() {
-    server.enqueue(MockResponse().setBody("abc"))
-    server.enqueue(MockResponse().setBody("def"))
-
-    val request = Request.Builder()
-        .url(server.url("/"))
-        .build()
-
-    val call = client.newCall(request)
-    val response1 = call.execute()
-
-    val cloned = call.clone()
-    val response2 = cloned.execute()
-
-    assertThat("abc").isEqualTo(response1.body!!.string())
-    assertThat("def").isEqualTo(response2.body!!.string())
-  }
-
-  @Test
-  fun testMockWebserverRequest() {
-    enableTls()
-
-    server.enqueue(MockResponse().setBody("abc"))
-
-    val request = Request.Builder().url(server.url("/")).build()
-
-    val response = client.newCall(request).execute()
-
-    response.use {
-      assertEquals(200, response.code)
-      assertEquals("CN=localhost",
-          (response.handshake!!.peerCertificates.single() as X509Certificate).subjectDN.name)
-    }
-  }
-
-  private fun enableTls() {
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager)
-        .build()
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false)
-  }
-
-  @Test
-  fun testHeadAfterPut() {
-    class ErringRequestBody : RequestBody() {
-      override fun contentType(): MediaType {
-        return "application/xml".toMediaType()
-      }
-
-      override fun writeTo(sink: BufferedSink) {
-        sink.writeUtf8("<el")
-        sink.flush()
-        throw IOException("failed to stream the XML")
-      }
-    }
-
-    class ValidRequestBody : RequestBody() {
-      override fun contentType(): MediaType {
-        return "application/xml".toMediaType()
-      }
-
-      override fun writeTo(sink: BufferedSink) {
-        sink.writeUtf8("<element/>")
-        sink.flush()
-      }
-    }
-
-    server.enqueue(MockResponse().apply {
-      setResponseCode(201)
-    })
-    server.enqueue(MockResponse().apply {
-      setResponseCode(204)
-    })
-    server.enqueue(MockResponse().apply {
-      setResponseCode(204)
-    })
-
-    val endpointUrl = server.url("/endpoint")
-
-    var request = Request.Builder()
-        .url(endpointUrl)
-        .header("Content-Type", "application/xml")
-        .put(ValidRequestBody())
-        .build()
-    // 201
-    client.newCall(request).execute()
-
-    request = Request.Builder()
-        .url(endpointUrl)
-        .head()
-        .build()
-    // 204
-    client.newCall(request).execute()
-
-    request = Request.Builder()
-        .url(endpointUrl)
-        .header("Content-Type", "application/xml")
-        .put(ErringRequestBody())
-        .build()
-    try {
-      client.newCall(request).execute()
-      fail("test should always throw exception")
-    } catch (_: IOException) {
-      // NOTE: expected
-    }
-
-    request = Request.Builder()
-        .url(endpointUrl)
-        .head()
-        .build()
-
-    client.newCall(request).execute()
-
-    var recordedRequest = server.takeRequest()
-    assertEquals("PUT", recordedRequest.method)
-
-    recordedRequest = server.takeRequest()
-    assertEquals("HEAD", recordedRequest.method)
-
-    recordedRequest = server.takeRequest()
-    assertThat(recordedRequest.failure).isNotNull()
-
-    recordedRequest = server.takeRequest()
-    assertEquals("HEAD", recordedRequest.method)
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/CallTest.java b/okhttp/src/test/java/okhttp3/CallTest.java
deleted file mode 100644
index b0eb67dffb..0000000000
--- a/okhttp/src/test/java/okhttp3/CallTest.java
+++ /dev/null
@@ -1,3969 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InterruptedIOException;
-import java.net.CookieManager;
-import java.net.HttpCookie;
-import java.net.HttpURLConnection;
-import java.net.InetAddress;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.SocketException;
-import java.net.SocketTimeoutException;
-import java.net.UnknownHostException;
-import java.net.UnknownServiceException;
-import java.security.cert.Certificate;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Set;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import java.util.concurrent.SynchronousQueue;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import java.util.logging.SimpleFormatter;
-import javax.annotation.Nullable;
-import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLProtocolException;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.RecordingEventListener.CallEnd;
-import okhttp3.RecordingEventListener.ConnectionAcquired;
-import okhttp3.RecordingEventListener.ConnectionReleased;
-import okhttp3.RecordingEventListener.ResponseFailed;
-import okhttp3.internal.DoubleInetAddressDns;
-import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.Version;
-import okhttp3.internal.http.RecordingProxySelector;
-import okhttp3.internal.io.InMemoryFileSystem;
-import okhttp3.mockwebserver.Dispatcher;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.QueueDispatcher;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.testing.PlatformRule;
-import okhttp3.tls.HandshakeCertificates;
-import okhttp3.tls.HeldCertificate;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ForwardingSource;
-import okio.GzipSink;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TestRule;
-import org.junit.rules.Timeout;
-
-import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
-import static java.util.Arrays.asList;
-import static okhttp3.CipherSuite.TLS_DH_anon_WITH_AES_128_GCM_SHA256;
-import static okhttp3.TestUtil.awaitGarbageCollection;
-import static okhttp3.internal.Internal.addHeaderLenient;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.data.Offset.offset;
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeFalse;
-
-public final class CallTest {
-  @Rule public final PlatformRule platform = new PlatformRule();
-  @Rule public final TestRule timeout = new Timeout(30_000, TimeUnit.MILLISECONDS);
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final MockWebServer server2 = new MockWebServer();
-  @Rule public final InMemoryFileSystem fileSystem = new InMemoryFileSystem();
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  private RecordingEventListener listener = new RecordingEventListener();
-  private HandshakeCertificates handshakeCertificates = localhost();
-  private OkHttpClient client = clientTestRule.newClientBuilder()
-      .eventListener(listener)
-      .build();
-  private RecordingCallback callback = new RecordingCallback();
-  private TestLogHandler logHandler = new TestLogHandler();
-  private Cache cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
-  private Logger logger = Logger.getLogger(OkHttpClient.class.getName());
-
-  @Before public void setUp() {
-    platform.assumeNotOpenJSSE();
-
-    logger.addHandler(logHandler);
-  }
-
-  @After public void tearDown() throws Exception {
-    cache.delete();
-    logger.removeHandler(logHandler);
-  }
-
-  @Test public void get() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .clearHeaders()
-        .addHeader("content-type: text/plain")
-        .addHeader("content-length", "3"));
-
-    long sentAt = System.currentTimeMillis();
-    RecordedResponse recordedResponse = executeSynchronously("/", "User-Agent", "SyncApiTest");
-    long receivedAt = System.currentTimeMillis();
-
-    recordedResponse.assertCode(200)
-        .assertSuccessful()
-        .assertHeaders(new Headers.Builder()
-            .add("content-type", "text/plain")
-            .add("content-length", "3")
-            .build())
-        .assertBody("abc")
-        .assertSentRequestAtMillis(sentAt, receivedAt)
-        .assertReceivedResponseAtMillis(sentAt, receivedAt);
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo("GET");
-    assertThat(recordedRequest.getHeader("User-Agent")).isEqualTo("SyncApiTest");
-    assertThat(recordedRequest.getBody().size()).isEqualTo(0);
-    assertThat(recordedRequest.getHeader("Content-Length")).isNull();
-  }
-
-  @Test public void buildRequestUsingHttpUrl() throws Exception {
-    server.enqueue(new MockResponse());
-    executeSynchronously("/").assertSuccessful();
-  }
-
-  @Test public void invalidScheme() throws Exception {
-    Request.Builder requestBuilder = new Request.Builder();
-    try {
-      requestBuilder.url("ftp://hostname/path");
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "Expected URL scheme 'http' or 'https' but was 'ftp'");
-    }
-  }
-
-  @Test public void invalidPort() throws Exception {
-    Request.Builder requestBuilder = new Request.Builder();
-    try {
-      requestBuilder.url("http://localhost:65536/");
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo("Invalid URL port: \"65536\"");
-    }
-  }
-
-  @Test public void getReturns500() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(500));
-    executeSynchronously("/")
-        .assertCode(500)
-        .assertNotSuccessful();
-  }
-
-  @Test public void get_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    get();
-  }
-
-  @Test public void get_HTTPS() throws Exception {
-    enableTls();
-    get();
-  }
-
-  @Test public void repeatedHeaderNames() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("B", "123")
-        .addHeader("B", "234"));
-
-    executeSynchronously("/", "A", "345", "A", "456")
-        .assertCode(200)
-        .assertHeader("B", "123", "234");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getHeaders().values("A")).containsExactly("345", "456");
-  }
-
-  @Test public void repeatedHeaderNames_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    repeatedHeaderNames();
-  }
-
-  @Test public void getWithRequestBody() throws Exception {
-    server.enqueue(new MockResponse());
-
-    try {
-      new Request.Builder().method("GET", RequestBody.create("abc", MediaType.get("text/plain")));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void head() throws Exception {
-    server.enqueue(new MockResponse().addHeader("Content-Type: text/plain"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .head()
-        .header("User-Agent", "SyncApiTest")
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertHeader("Content-Type", "text/plain");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo("HEAD");
-    assertThat(recordedRequest.getHeader("User-Agent")).isEqualTo("SyncApiTest");
-    assertThat(recordedRequest.getBody().size()).isEqualTo(0);
-    assertThat(recordedRequest.getHeader("Content-Length")).isNull();
-  }
-
-  @Test public void headResponseContentLengthIsIgnored() throws Exception {
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .addHeader("Content-Length", "100"));
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    Request headRequest = new Request.Builder()
-        .url(server.url("/"))
-        .head()
-        .build();
-    Response response = client.newCall(headRequest).execute();
-    assertThat(response.code()).isEqualTo(200);
-    assertArrayEquals(new byte[0], response.body().bytes());
-
-    Request getRequest = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    executeSynchronously(getRequest)
-        .assertCode(200)
-        .assertBody("abc");
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void headResponseContentEncodingIsIgnored() throws Exception {
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .addHeader("Content-Encoding", "chunked"));
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    Request headRequest = new Request.Builder()
-        .url(server.url("/"))
-        .head()
-        .build();
-    executeSynchronously(headRequest)
-        .assertCode(200)
-        .assertHeader("Content-Encoding", "chunked")
-        .assertBody("");
-
-    Request getRequest = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    executeSynchronously(getRequest)
-        .assertCode(200)
-        .assertBody("abc");
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void head_HTTPS() throws Exception {
-    enableTls();
-    head();
-  }
-
-  @Test public void head_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    head();
-  }
-
-  @Test public void post() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create("def", MediaType.get("text/plain")))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo("POST");
-    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("def");
-    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("3");
-    assertThat(recordedRequest.getHeader("Content-Type")).isEqualTo(
-        "text/plain; charset=utf-8");
-  }
-
-  @Test public void post_HTTPS() throws Exception {
-    enableTls();
-    post();
-  }
-
-  @Test public void post_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    post();
-  }
-
-  @Test public void postZeroLength() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .method("POST", RequestBody.create(new byte[0], null))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo("POST");
-    assertThat(recordedRequest.getBody().size()).isEqualTo(0);
-    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("0");
-    assertThat(recordedRequest.getHeader("Content-Type")).isNull();
-  }
-
-  @Test public void postZerolength_HTTPS() throws Exception {
-    enableTls();
-    postZeroLength();
-  }
-
-  @Test public void postZerolength_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    postZeroLength();
-  }
-
-  @Test public void postBodyRetransmittedAfterAuthorizationFail() throws Exception {
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
-  @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTPS() throws Exception {
-    enableTls();
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
-  @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
-  /** Don't explode when resending an empty post. https://github.com/square/okhttp/issues/1131 */
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail() throws Exception {
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTPS() throws Exception {
-    enableTls();
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
-  private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(401));
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .method("POST", RequestBody.create(body, null))
-        .build();
-
-    String credential = Credentials.basic("jesse", "secret");
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential, null))
-        .build();
-
-    Response response = client.newCall(request).execute();
-    assertThat(response.code()).isEqualTo(200);
-    response.body().close();
-
-    RecordedRequest recordedRequest1 = server.takeRequest();
-    assertThat(recordedRequest1.getMethod()).isEqualTo("POST");
-    assertThat(recordedRequest1.getBody().readUtf8()).isEqualTo(body);
-    assertThat(recordedRequest1.getHeader("Authorization")).isNull();
-
-    RecordedRequest recordedRequest2 = server.takeRequest();
-    assertThat(recordedRequest2.getMethod()).isEqualTo("POST");
-    assertThat(recordedRequest2.getBody().readUtf8()).isEqualTo(body);
-    assertThat(recordedRequest2.getHeader("Authorization")).isEqualTo(credential);
-  }
-
-  @Test public void attemptAuthorization20Times() throws Exception {
-    for (int i = 0; i < 20; i++) {
-      server.enqueue(new MockResponse().setResponseCode(401));
-    }
-    server.enqueue(new MockResponse().setBody("Success!"));
-
-    String credential = Credentials.basic("jesse", "secret");
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential, null))
-        .build();
-
-    executeSynchronously("/")
-        .assertCode(200)
-        .assertBody("Success!");
-  }
-
-  @Test public void doesNotAttemptAuthorization21Times() throws Exception {
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse().setResponseCode(401));
-    }
-
-    String credential = Credentials.basic("jesse", "secret");
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential, null))
-        .build();
-
-    try {
-      client.newCall(new Request.Builder().url(server.url("/0")).build()).execute();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("Too many follow-up requests: 21");
-    }
-  }
-
-  /**
-   * We had a bug where we were passing a null route to the authenticator.
-   * https://github.com/square/okhttp/issues/3809
-   */
-  @Test public void authenticateWithNoConnection() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Connection: close")
-        .setResponseCode(401)
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
-
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(null, null);
-
-    client = client.newBuilder()
-        .authenticator(authenticator)
-        .build();
-
-    executeSynchronously("/")
-        .assertCode(401);
-
-    assertThat(authenticator.onlyRoute()).isNotNull();
-  }
-
-  @Test public void delete() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .delete()
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo("DELETE");
-    assertThat(recordedRequest.getBody().size()).isEqualTo(0);
-    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("0");
-    assertThat(recordedRequest.getHeader("Content-Type")).isNull();
-  }
-
-  @Test public void delete_HTTPS() throws Exception {
-    enableTls();
-    delete();
-  }
-
-  @Test public void delete_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    delete();
-  }
-
-  @Test public void deleteWithRequestBody() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .method("DELETE", RequestBody.create("def", MediaType.get("text/plain")))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo("DELETE");
-    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("def");
-  }
-
-  @Test public void put() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .put(RequestBody.create("def", MediaType.get("text/plain")))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo("PUT");
-    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("def");
-    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("3");
-    assertThat(recordedRequest.getHeader("Content-Type")).isEqualTo(
-        "text/plain; charset=utf-8");
-  }
-
-  @Test public void put_HTTPS() throws Exception {
-    enableTls();
-    put();
-  }
-
-  @Test public void put_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    put();
-  }
-
-  @Test public void patch() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .patch(RequestBody.create("def", MediaType.get("text/plain")))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo("PATCH");
-    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("def");
-    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("3");
-    assertThat(recordedRequest.getHeader("Content-Type")).isEqualTo(
-        "text/plain; charset=utf-8");
-  }
-
-  @Test public void patch_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    patch();
-  }
-
-  @Test public void patch_HTTPS() throws Exception {
-    enableTls();
-    patch();
-  }
-
-  @Test public void customMethodWithBody() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .method("CUSTOM", RequestBody.create("def", MediaType.get("text/plain")))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo("CUSTOM");
-    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("def");
-    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("3");
-    assertThat(recordedRequest.getHeader("Content-Type")).isEqualTo(
-        "text/plain; charset=utf-8");
-  }
-
-  @Test public void unspecifiedRequestBodyContentTypeDoesNotGetDefault() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .method("POST", RequestBody.create("abc", null))
-        .build();
-
-    executeSynchronously(request).assertCode(200);
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getHeader("Content-Type")).isNull();
-    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("3");
-    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("abc");
-  }
-
-  @Test public void illegalToExecuteTwice() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .addHeader("Content-Type: text/plain"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("User-Agent", "SyncApiTest")
-        .build();
-
-    Call call = client.newCall(request);
-    Response response = call.execute();
-    response.body().close();
-
-    try {
-      call.execute();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).isEqualTo("Already Executed");
-    }
-
-    try {
-      call.enqueue(callback);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).isEqualTo("Already Executed");
-    }
-
-    assertThat(server.takeRequest().getHeader("User-Agent")).isEqualTo("SyncApiTest");
-  }
-
-  @Test public void illegalToExecuteTwice_Async() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .addHeader("Content-Type: text/plain"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("User-Agent", "SyncApiTest")
-        .build();
-
-    Call call = client.newCall(request);
-    call.enqueue(callback);
-
-    try {
-      call.execute();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).isEqualTo("Already Executed");
-    }
-
-    try {
-      call.enqueue(callback);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).isEqualTo("Already Executed");
-    }
-
-    assertThat(server.takeRequest().getHeader("User-Agent")).isEqualTo("SyncApiTest");
-
-    callback.await(request.url()).assertSuccessful();
-  }
-
-  @Test public void legalToExecuteTwiceCloning() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Call call = client.newCall(request);
-    Response response1 = call.execute();
-
-    Call cloned = call.clone();
-    Response response2 = cloned.execute();
-
-    assertThat("abc").isEqualTo(response1.body().string());
-    assertThat("def").isEqualTo(response2.body().string());
-  }
-
-  @Test public void legalToExecuteTwiceCloning_Async() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Call call = client.newCall(request);
-    call.enqueue(callback);
-
-    Call cloned = call.clone();
-    cloned.enqueue(callback);
-
-    RecordedResponse firstResponse = callback.await(request.url()).assertSuccessful();
-    RecordedResponse secondResponse = callback.await(request.url()).assertSuccessful();
-
-    Set<String> bodies = new LinkedHashSet<>();
-    bodies.add(firstResponse.getBody());
-    bodies.add(secondResponse.getBody());
-
-    assertThat(bodies).contains("abc");
-    assertThat(bodies).contains("def");
-  }
-
-  @Test public void get_Async() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .addHeader("Content-Type: text/plain"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("User-Agent", "AsyncApiTest")
-        .build();
-    client.newCall(request).enqueue(callback);
-
-    callback.await(request.url())
-        .assertCode(200)
-        .assertHeader("Content-Type", "text/plain")
-        .assertBody("abc");
-
-    assertThat(server.takeRequest().getHeader("User-Agent")).isEqualTo("AsyncApiTest");
-  }
-
-  @Test public void exceptionThrownByOnResponseIsRedactedAndLogged() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder()
-        .url(server.url("/secret"))
-        .build();
-
-    client.newCall(request).enqueue(new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-        fail();
-      }
-
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        throw new IOException("a");
-      }
-    });
-
-    assertThat(logHandler.take()).isEqualTo(
-        ("INFO: Callback failure for call to " + server.url("/") + "..."));
-  }
-
-  @Test public void connectionPooling() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-    server.enqueue(new MockResponse().setBody("ghi"));
-
-    executeSynchronously("/a").assertBody("abc");
-    executeSynchronously("/b").assertBody("def");
-    executeSynchronously("/c").assertBody("ghi");
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
-  }
-
-  /**
-   * Each OkHttpClient used to get its own instance of NullProxySelector, and because these weren't
-   * equal their connections weren't pooled. That's a nasty performance bug!
-   *
-   * https://github.com/square/okhttp/issues/5519
-   */
-  @Test public void connectionPoolingWithFreshClientSamePool() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-    server.enqueue(new MockResponse().setBody("ghi"));
-
-    client = new OkHttpClient.Builder()
-        .connectionPool(client.connectionPool())
-        .proxy(server.toProxyAddress())
-        .build();
-    executeSynchronously("/a").assertBody("abc");
-
-    client = new OkHttpClient.Builder()
-        .connectionPool(client.connectionPool())
-        .proxy(server.toProxyAddress())
-        .build();
-    executeSynchronously("/b").assertBody("def");
-
-    client = new OkHttpClient.Builder()
-        .connectionPool(client.connectionPool())
-        .proxy(server.toProxyAddress())
-        .build();
-    executeSynchronously("/c").assertBody("ghi");
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
-  }
-
-  @Test public void connectionPoolingWithClientBuiltOffProxy() throws Exception {
-    client = new OkHttpClient.Builder()
-        .proxy(server.toProxyAddress())
-        .build();
-
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-    server.enqueue(new MockResponse().setBody("ghi"));
-
-    client = client.newBuilder().build();
-    executeSynchronously("/a").assertBody("abc");
-
-    client = client.newBuilder().build();
-    executeSynchronously("/b").assertBody("def");
-
-    client = client.newBuilder().build();
-    executeSynchronously("/c").assertBody("ghi");
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
-  }
-
-  @Test public void connectionPooling_Async() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-    server.enqueue(new MockResponse().setBody("ghi"));
-
-    client.newCall(new Request.Builder().url(server.url("/a")).build()).enqueue(callback);
-    callback.await(server.url("/a")).assertBody("abc");
-
-    client.newCall(new Request.Builder().url(server.url("/b")).build()).enqueue(callback);
-    callback.await(server.url("/b")).assertBody("def");
-
-    client.newCall(new Request.Builder().url(server.url("/c")).build()).enqueue(callback);
-    callback.await(server.url("/c")).assertBody("ghi");
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
-  }
-
-  @Test public void connectionReuseWhenResponseBodyConsumed_Async() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    Request request = new Request.Builder().url(server.url("/a")).build();
-    client.newCall(request).enqueue(new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-        throw new AssertionError();
-      }
-
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        InputStream bytes = response.body().byteStream();
-        assertThat(bytes.read()).isEqualTo('a');
-        assertThat(bytes.read()).isEqualTo('b');
-        assertThat(bytes.read()).isEqualTo('c');
-
-        // This request will share a connection with 'A' cause it's all done.
-        client.newCall(new Request.Builder().url(server.url("/b")).build()).enqueue(callback);
-      }
-    });
-
-    callback.await(server.url("/b")).assertCode(200).assertBody("def");
-    // New connection.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    // Connection reuse!
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void timeoutsUpdatedOnReusedConnections() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
-
-    // First request: time out after 1000ms.
-    client = client.newBuilder()
-        .readTimeout(1000, TimeUnit.MILLISECONDS)
-        .build();
-    executeSynchronously("/a").assertBody("abc");
-
-    // Second request: time out after 250ms.
-    client = client.newBuilder()
-        .readTimeout(250, TimeUnit.MILLISECONDS)
-        .build();
-    Request request = new Request.Builder().url(server.url("/b")).build();
-    Response response = client.newCall(request).execute();
-    BufferedSource bodySource = response.body().source();
-    assertThat(bodySource.readByte()).isEqualTo((byte) 'd');
-
-    // The second byte of this request will be delayed by 750ms so we should time out after 250ms.
-    long startNanos = System.nanoTime();
-    try {
-      bodySource.readByte();
-      fail();
-    } catch (IOException expected) {
-      // Timed out as expected.
-      long elapsedNanos = System.nanoTime() - startNanos;
-      long elapsedMillis = TimeUnit.NANOSECONDS.toMillis(elapsedNanos);
-      assertThat(elapsedMillis).isLessThan(500);
-    } finally {
-      bodySource.close();
-    }
-  }
-
-  /** https://github.com/square/okhttp/issues/442 */
-  @Test public void tlsTimeoutsNotRetried() throws Exception {
-    enableTls();
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.NO_RESPONSE));
-    server.enqueue(new MockResponse()
-        .setBody("unreachable!"));
-
-    client = client.newBuilder()
-        .readTimeout(100, TimeUnit.MILLISECONDS)
-        .build();
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-    try {
-      // If this succeeds, too many requests were made.
-      client.newCall(request).execute();
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
-  }
-
-  /**
-   * Make a request with two routes. The first route will time out because it's connecting to a
-   * special address that never connects. The automatic retry will succeed.
-   */
-  @Test public void connectTimeoutsAttemptsAlternateRoute() throws Exception {
-    RecordingProxySelector proxySelector = new RecordingProxySelector();
-    proxySelector.proxies.add(new Proxy(Proxy.Type.HTTP, TestUtil.UNREACHABLE_ADDRESS));
-    proxySelector.proxies.add(server.toProxyAddress());
-
-    server.enqueue(new MockResponse()
-        .setBody("success!"));
-    client = client.newBuilder()
-        .proxySelector(proxySelector)
-        .readTimeout(100, TimeUnit.MILLISECONDS)
-        .connectTimeout(100, TimeUnit.MILLISECONDS)
-        .build();
-
-    Request request = new Request.Builder().url("http://android.com/").build();
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("success!");
-  }
-
-  /** https://github.com/square/okhttp/issues/4875 */
-  @Test public void interceptorRecoversWhenRoutesExhausted() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_START));
-    server.enqueue(new MockResponse());
-
-    client = client.newBuilder()
-        .addInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            try {
-              chain.proceed(chain.request());
-              throw new AssertionError();
-            } catch (IOException expected) {
-              return chain.proceed(chain.request());
-            }
-          }
-        })
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    executeSynchronously(request)
-        .assertCode(200);
-  }
-
-  /** https://github.com/square/okhttp/issues/4761 */
-  @Test
-  public void interceptorCallsProceedWithoutClosingPriorResponse() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBodyDelay(250, TimeUnit.MILLISECONDS)
-        .setBody("abc"));
-    server.enqueue(new MockResponse()
-        .setBody("def"));
-
-    client = clientTestRule.newClientBuilder()
-        .addInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            Response response = chain.proceed(chain.request());
-            try {
-              chain.proceed(chain.request());
-              fail();
-            } catch (IllegalStateException expected) {
-              assertThat(expected).hasMessageContaining("please call response.close()");
-            }
-            return response;
-          }
-        })
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    executeSynchronously(request)
-        .assertFailure(SocketException.class);
-  }
-
-  /**
-   * Make a request with two routes. The first route will fail because the null server connects but
-   * never responds. The manual retry will succeed.
-   */
-  @Test public void readTimeoutFails() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.STALL_SOCKET_AT_START));
-    server2.enqueue(new MockResponse()
-        .setBody("success!"));
-
-    RecordingProxySelector proxySelector = new RecordingProxySelector();
-    proxySelector.proxies.add(server.toProxyAddress());
-    proxySelector.proxies.add(server2.toProxyAddress());
-
-    client = client.newBuilder()
-        .proxySelector(proxySelector)
-        .readTimeout(100, TimeUnit.MILLISECONDS)
-        .build();
-
-    Request request = new Request.Builder().url("http://android.com/").build();
-    executeSynchronously(request)
-        .assertFailure(SocketTimeoutException.class);
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertBody("success!");
-  }
-
-  /** https://github.com/square/okhttp/issues/1801 */
-  @Test public void asyncCallEngineInitialized() throws Exception {
-    OkHttpClient c = client.newBuilder()
-        .addInterceptor(chain -> { throw new IOException(); })
-        .build();
-    Request request = new Request.Builder().url(server.url("/")).build();
-    c.newCall(request).enqueue(callback);
-    RecordedResponse response = callback.await(request.url());
-    assertThat(response.request).isEqualTo(request);
-  }
-
-  @Test public void reusedSinksGetIndependentTimeoutInstances() throws Exception {
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-
-    // Call 1: set a deadline on the request body.
-    RequestBody requestBody1 = new RequestBody() {
-      @Override public MediaType contentType() {
-        return MediaType.get("text/plain");
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.writeUtf8("abc");
-        sink.timeout().deadline(5, TimeUnit.SECONDS);
-      }
-    };
-    Request request1 = new Request.Builder()
-        .url(server.url("/"))
-        .method("POST", requestBody1)
-        .build();
-    Response response1 = client.newCall(request1).execute();
-    assertThat(response1.code()).isEqualTo(200);
-
-    // Call 2: check for the absence of a deadline on the request body.
-    RequestBody requestBody2 = new RequestBody() {
-      @Override public MediaType contentType() {
-        return MediaType.get("text/plain");
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        assertThat(sink.timeout().hasDeadline()).isFalse();
-        sink.writeUtf8("def");
-      }
-    };
-    Request request2 = new Request.Builder()
-        .url(server.url("/"))
-        .method("POST", requestBody2)
-        .build();
-    Response response2 = client.newCall(request2).execute();
-    assertThat(response2.code()).isEqualTo(200);
-
-    // Use sequence numbers to confirm the connection was pooled.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void reusedSourcesGetIndependentTimeoutInstances() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    // Call 1: set a deadline on the response body.
-    Request request1 = new Request.Builder().url(server.url("/")).build();
-    Response response1 = client.newCall(request1).execute();
-    BufferedSource body1 = response1.body().source();
-    assertThat(body1.readUtf8()).isEqualTo("abc");
-    body1.timeout().deadline(5, TimeUnit.SECONDS);
-
-    // Call 2: check for the absence of a deadline on the request body.
-    Request request2 = new Request.Builder().url(server.url("/")).build();
-    Response response2 = client.newCall(request2).execute();
-    BufferedSource body2 = response2.body().source();
-    assertThat(body2.readUtf8()).isEqualTo("def");
-    assertThat(body2.timeout().hasDeadline()).isFalse();
-
-    // Use sequence numbers to confirm the connection was pooled.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void tls() throws Exception {
-    enableTls();
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .addHeader("Content-Type: text/plain"));
-
-    executeSynchronously("/").assertHandshake();
-  }
-
-  @Test public void tls_Async() throws Exception {
-    enableTls();
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .addHeader("Content-Type: text/plain"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    client.newCall(request).enqueue(callback);
-
-    callback.await(request.url()).assertHandshake();
-  }
-
-  @Test public void recoverWhenRetryOnConnectionFailureIsTrue() throws Exception {
-    // Set to 2 because the seeding request will count down before the retried request does.
-    CountDownLatch requestFinished = new CountDownLatch(2);
-
-    QueueDispatcher dispatcher = new QueueDispatcher() {
-      @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
-        if (peek().getSocketPolicy() == SocketPolicy.DISCONNECT_AFTER_REQUEST) {
-          requestFinished.await();
-        }
-        return super.dispatch(request);
-      }
-    };
-    dispatcher.enqueueResponse(new MockResponse().setBody("seed connection pool"));
-    dispatcher.enqueueResponse(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
-    dispatcher.enqueueResponse(new MockResponse().setBody("retry success"));
-    server.setDispatcher(dispatcher);
-
-    listener = new RecordingEventListener() {
-      @Override public void responseHeadersStart(Call call) {
-        requestFinished.countDown();
-        super.responseHeadersStart(call);
-      }
-    };
-
-    client = client.newBuilder()
-        .dns(new DoubleInetAddressDns())
-        .eventListener(listener)
-        .build();
-    assertThat(client.retryOnConnectionFailure()).isTrue();
-
-    executeSynchronously("/").assertBody("seed connection pool");
-    executeSynchronously("/").assertBody("retry success");
-
-    // The call that seeds the connection pool.
-    listener.removeUpToEvent(CallEnd.class);
-
-    // The ResponseFailed event is not necessarily fatal!
-    listener.removeUpToEvent(ConnectionAcquired.class);
-    listener.removeUpToEvent(ResponseFailed.class);
-    listener.removeUpToEvent(ConnectionReleased.class);
-    listener.removeUpToEvent(ConnectionAcquired.class);
-    listener.removeUpToEvent(ConnectionReleased.class);
-    listener.removeUpToEvent(CallEnd.class);
-  }
-
-  @Test public void recoverWhenRetryOnConnectionFailureIsTrue_HTTP2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    recoverWhenRetryOnConnectionFailureIsTrue();
-  }
-
-  @Test public void noRecoverWhenRetryOnConnectionFailureIsFalse() throws Exception {
-    server.enqueue(new MockResponse().setBody("seed connection pool"));
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
-    server.enqueue(new MockResponse().setBody("unreachable!"));
-
-    client = client.newBuilder()
-        .dns(new DoubleInetAddressDns())
-        .retryOnConnectionFailure(false)
-        .build();
-
-    executeSynchronously("/").assertBody("seed connection pool");
-
-    // If this succeeds, too many requests were made.
-    executeSynchronously("/")
-        .assertFailure(IOException.class)
-        .assertFailureMatches("stream was reset: CANCEL",
-            "unexpected end of stream on " + server.url("/").redact());
-  }
-
-  @Test public void recoverWhenRetryOnConnectionFailureIsFalse_HTTP2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    noRecoverWhenRetryOnConnectionFailureIsFalse();
-  }
-
-  @Test public void tlsHandshakeFailure_noFallbackByDefault() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse().setBody("response that will never be received"));
-    RecordedResponse response = executeSynchronously("/");
-    response.assertFailure(
-            SSLException.class, // JDK 11 response to the FAIL_HANDSHAKE
-            SSLProtocolException.class, // RI response to the FAIL_HANDSHAKE
-            SSLHandshakeException.class // Android's response to the FAIL_HANDSHAKE
-    );
-    assertThat(client.connectionSpecs()).doesNotContain(ConnectionSpec.COMPATIBLE_TLS);
-  }
-
-  @Test public void recoverFromTlsHandshakeFailure() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    client = client.newBuilder()
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
-        .connectionSpecs(asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
-        .sslSocketFactory(
-            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
-        .build();
-
-    executeSynchronously("/").assertBody("abc");
-  }
-
-  @Test public void recoverFromTlsHandshakeFailure_tlsFallbackScsvEnabled() throws Exception {
-    platform.assumeNotConscrypt();
-
-    final String tlsFallbackScsv = "TLS_FALLBACK_SCSV";
-    List<String> supportedCiphers =
-        asList(handshakeCertificates.sslSocketFactory().getSupportedCipherSuites());
-    if (!supportedCiphers.contains(tlsFallbackScsv)) {
-      // This only works if the client socket supports TLS_FALLBACK_SCSV.
-      return;
-    }
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-
-    RecordingSSLSocketFactory clientSocketFactory =
-        new RecordingSSLSocketFactory(handshakeCertificates.sslSocketFactory());
-    client = client.newBuilder()
-        .sslSocketFactory(clientSocketFactory, handshakeCertificates.trustManager())
-        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
-        .connectionSpecs(asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (SSLHandshakeException expected) {
-    }
-
-    List<SSLSocket> clientSockets = clientSocketFactory.getSocketsCreated();
-    SSLSocket firstSocket = clientSockets.get(0);
-    assertThat(asList(firstSocket.getEnabledCipherSuites())).doesNotContain(tlsFallbackScsv);
-    SSLSocket secondSocket = clientSockets.get(1);
-    assertThat(asList(secondSocket.getEnabledCipherSuites())).contains(tlsFallbackScsv);
-  }
-
-  @Test public void recoverFromTlsHandshakeFailure_Async() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    client = client.newBuilder()
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
-        .connectionSpecs(asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
-        .sslSocketFactory(
-            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    client.newCall(request).enqueue(callback);
-
-    callback.await(request.url()).assertBody("abc");
-  }
-
-  @Test public void noRecoveryFromTlsHandshakeFailureWhenTlsFallbackIsDisabled() throws Exception {
-    client = client.newBuilder()
-        .connectionSpecs(asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT))
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .sslSocketFactory(
-            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
-        .build();
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (SSLProtocolException expected) {
-      // RI response to the FAIL_HANDSHAKE
-    } catch (SSLHandshakeException expected) {
-      // Android's response to the FAIL_HANDSHAKE
-    } catch (SSLException expected) {
-      // JDK 11 response to the FAIL_HANDSHAKE
-      String jvmVersion = System.getProperty("java.specification.version");
-      assertThat(jvmVersion).isEqualTo("11");
-    }
-  }
-
-  @Test public void tlsHostnameVerificationFailure() throws Exception {
-    server.enqueue(new MockResponse());
-
-    HeldCertificate serverCertificate = new HeldCertificate.Builder()
-        .commonName("localhost") // Unusued for hostname verification.
-        .addSubjectAlternativeName("wronghostname")
-        .build();
-
-    HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
-        .heldCertificate(serverCertificate)
-        .build();
-
-    HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
-        .addTrustedCertificate(serverCertificate.certificate())
-        .build();
-
-    client = client.newBuilder()
-        .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
-        .build();
-    server.useHttps(serverCertificates.sslSocketFactory(), false);
-
-    executeSynchronously("/")
-        .assertFailureMatches("(?s)Hostname localhost not verified.*");
-  }
-
-  /**
-   * Anonymous cipher suites were disabled in OpenJDK because they're rarely used and permit
-   * man-in-the-middle attacks. https://bugs.openjdk.java.net/browse/JDK-8212823
-   */
-  @Test public void anonCipherSuiteUnsupported() throws Exception {
-    platform.assumeNotConscrypt();
-
-    // The _anon_ suites became unsupported in "1.8.0_201" and "11.0.2".
-    assumeFalse(System.getProperty("java.version", "unknown").matches("1\\.8\\.0_1\\d\\d"));
-
-    server.enqueue(new MockResponse());
-
-    CipherSuite cipherSuite = TLS_DH_anon_WITH_AES_128_GCM_SHA256;
-
-    HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
-        .build();
-    client = client.newBuilder()
-        .sslSocketFactory(
-            socketFactoryWithCipherSuite(clientCertificates.sslSocketFactory(), cipherSuite),
-            clientCertificates.trustManager())
-        .connectionSpecs(asList(new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-            .cipherSuites(cipherSuite)
-            .build()))
-        .build();
-
-    HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
-        .build();
-    server.useHttps(socketFactoryWithCipherSuite(
-        serverCertificates.sslSocketFactory(), cipherSuite), false);
-
-    executeSynchronously("/")
-        .assertFailure(SSLHandshakeException.class);
-  }
-
-  @Test public void cleartextCallsFailWhenCleartextIsDisabled() throws Exception {
-    // Configure the client with only TLS configurations. No cleartext!
-    client = client.newBuilder()
-        .connectionSpecs(asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
-        .build();
-
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (UnknownServiceException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "CLEARTEXT communication not enabled for client");
-    }
-  }
-
-  @Test public void httpsCallsFailWhenProtocolIsH2PriorKnowledge() throws Exception {
-    client = client.newBuilder()
-        .protocols(Collections.singletonList(Protocol.H2_PRIOR_KNOWLEDGE))
-        .build();
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    try {
-      call.execute();
-      fail();
-    } catch (UnknownServiceException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "H2_PRIOR_KNOWLEDGE cannot be used with HTTPS");
-    }
-  }
-
-  @Test public void setFollowSslRedirectsFalse() throws Exception {
-    enableTls();
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Location: http://square.com"));
-
-    client = client.newBuilder()
-        .followSslRedirects(false)
-        .build();
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.code()).isEqualTo(301);
-    response.body().close();
-  }
-
-  @Test public void matchingPinnedCertificate() throws Exception {
-    // Fails on 11.0.1 https://github.com/square/okhttp/issues/4703
-
-    enableTls();
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-
-    // Make a first request without certificate pinning. Use it to collect certificates to pin.
-    Request request1 = new Request.Builder().url(server.url("/")).build();
-    Response response1 = client.newCall(request1).execute();
-    CertificatePinner.Builder certificatePinnerBuilder = new CertificatePinner.Builder();
-    for (Certificate certificate : response1.handshake().peerCertificates()) {
-      certificatePinnerBuilder.add(server.getHostName(), CertificatePinner.pin(certificate));
-    }
-    response1.body().close();
-
-    // Make another request with certificate pinning. It should complete normally.
-    client = client.newBuilder()
-        .certificatePinner(certificatePinnerBuilder.build())
-        .build();
-    Request request2 = new Request.Builder().url(server.url("/")).build();
-    Response response2 = client.newCall(request2).execute();
-    assertThat(response1.handshake()).isNotSameAs(response2.handshake());
-    response2.body().close();
-  }
-
-  @Test public void unmatchingPinnedCertificate() throws Exception {
-    enableTls();
-    server.enqueue(new MockResponse());
-
-    // Pin publicobject.com's cert.
-    client = client.newBuilder()
-        .certificatePinner(new CertificatePinner.Builder()
-            .add(server.getHostName(), "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=")
-            .build())
-        .build();
-
-    // When we pin the wrong certificate, connectivity fails.
-    Request request = new Request.Builder().url(server.url("/")).build();
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (SSLPeerUnverifiedException expected) {
-      assertThat(expected.getMessage()).startsWith("Certificate pinning failure!");
-    }
-  }
-
-  @Test public void post_Async() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create("def", MediaType.get("text/plain")))
-        .build();
-    client.newCall(request).enqueue(callback);
-
-    callback.await(request.url())
-        .assertCode(200)
-        .assertBody("abc");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("def");
-    assertThat(recordedRequest.getHeader("Content-Length")).isEqualTo("3");
-    assertThat(recordedRequest.getHeader("Content-Type")).isEqualTo(
-        "text/plain; charset=utf-8");
-  }
-
-  @Test public void postBodyRetransmittedOnFailureRecovery() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    // Seed the connection pool so we have something that can fail.
-    Request request1 = new Request.Builder().url(server.url("/")).build();
-    Response response1 = client.newCall(request1).execute();
-    assertThat(response1.body().string()).isEqualTo("abc");
-
-    Request request2 = new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create("body!", MediaType.get("text/plain")))
-        .build();
-    Response response2 = client.newCall(request2).execute();
-    assertThat(response2.body().string()).isEqualTo("def");
-
-    RecordedRequest get = server.takeRequest();
-    assertThat(get.getSequenceNumber()).isEqualTo(0);
-
-    RecordedRequest post1 = server.takeRequest();
-    assertThat(post1.getBody().readUtf8()).isEqualTo("body!");
-    assertThat(post1.getSequenceNumber()).isEqualTo(1);
-
-    RecordedRequest post2 = server.takeRequest();
-    assertThat(post2.getBody().readUtf8()).isEqualTo("body!");
-    assertThat(post2.getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void postBodyRetransmittedOnFailureRecovery_HTTP2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    postBodyRetransmittedOnFailureRecovery();
-  }
-
-  @Test public void cacheHit() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v1")
-        .addHeader("Cache-Control: max-age=60")
-        .addHeader("Vary: Accept-Charset")
-        .setBody("A"));
-
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    // Store a response in the cache.
-    HttpUrl url = server.url("/");
-    long request1SentAt = System.currentTimeMillis();
-    executeSynchronously("/", "Accept-Language", "fr-CA", "Accept-Charset", "UTF-8")
-        .assertCode(200)
-        .assertBody("A");
-    long request1ReceivedAt = System.currentTimeMillis();
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
-
-    // Hit that stored response. It's different, but Vary says it doesn't matter.
-    Thread.sleep(10); // Make sure the timestamps are unique.
-    RecordedResponse cacheHit = executeSynchronously(
-        "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
-
-    // Check the merged response. The request is the application's original request.
-    cacheHit.assertCode(200)
-        .assertBody("A")
-        .assertHeaders(new Headers.Builder()
-            .add("ETag", "v1")
-            .add("Cache-Control", "max-age=60")
-            .add("Vary", "Accept-Charset")
-            .add("Content-Length", "1")
-            .build())
-        .assertRequestUrl(url)
-        .assertRequestHeader("Accept-Language", "en-US")
-        .assertRequestHeader("Accept-Charset", "UTF-8")
-        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
-        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
-
-    // Check the cached response. Its request contains only the saved Vary headers.
-    cacheHit.cacheResponse()
-        .assertCode(200)
-        .assertHeaders(new Headers.Builder()
-            .add("ETag", "v1")
-            .add("Cache-Control", "max-age=60")
-            .add("Vary", "Accept-Charset")
-            .add("Content-Length", "1")
-            .build())
-        .assertRequestMethod("GET")
-        .assertRequestUrl(url)
-        .assertRequestHeader("Accept-Language")
-        .assertRequestHeader("Accept-Charset", "UTF-8")
-        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
-        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
-
-    cacheHit.assertNoNetworkResponse();
-  }
-
-  @Test public void conditionalCacheHit() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v1")
-        .addHeader("Vary: Accept-Charset")
-        .addHeader("Donut: a")
-        .setBody("A"));
-    server.enqueue(new MockResponse().clearHeaders()
-        .addHeader("Donut: b")
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    // Store a response in the cache.
-    long request1SentAt = System.currentTimeMillis();
-    executeSynchronously("/", "Accept-Language", "fr-CA", "Accept-Charset", "UTF-8")
-        .assertCode(200)
-        .assertHeader("Donut", "a")
-        .assertBody("A");
-    long request1ReceivedAt = System.currentTimeMillis();
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
-
-    // Hit that stored response. It's different, but Vary says it doesn't matter.
-    Thread.sleep(10); // Make sure the timestamps are unique.
-    long request2SentAt = System.currentTimeMillis();
-    RecordedResponse cacheHit = executeSynchronously(
-        "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
-    long request2ReceivedAt = System.currentTimeMillis();
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v1");
-
-    // Check the merged response. The request is the application's original request.
-    cacheHit.assertCode(200)
-        .assertBody("A")
-        .assertHeader("Donut", "b")
-        .assertRequestUrl(server.url("/"))
-        .assertRequestHeader("Accept-Language", "en-US")
-        .assertRequestHeader("Accept-Charset", "UTF-8")
-        .assertRequestHeader("If-None-Match") // No If-None-Match on the user's request.
-        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
-        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
-
-    // Check the cached response. Its request contains only the saved Vary headers.
-    cacheHit.cacheResponse()
-        .assertCode(200)
-        .assertHeader("Donut", "a")
-        .assertHeader("ETag", "v1")
-        .assertRequestUrl(server.url("/"))
-        .assertRequestHeader("Accept-Language") // No Vary on Accept-Language.
-        .assertRequestHeader("Accept-Charset", "UTF-8") // Because of Vary on Accept-Charset.
-        .assertRequestHeader("If-None-Match") // This wasn't present in the original request.
-        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
-        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
-
-    // Check the network response. It has the caller's request, plus some caching headers.
-    cacheHit.networkResponse()
-        .assertCode(304)
-        .assertHeader("Donut", "b")
-        .assertRequestHeader("Accept-Language", "en-US")
-        .assertRequestHeader("Accept-Charset", "UTF-8")
-        .assertRequestHeader("If-None-Match", "v1") // If-None-Match in the validation request.
-        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
-        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
-  }
-
-  @Test public void conditionalCacheHit_Async() throws Exception {
-    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    Request request1 = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    client.newCall(request1).enqueue(callback);
-    callback.await(request1.url()).assertCode(200).assertBody("A");
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
-
-    Request request2 = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    client.newCall(request2).enqueue(callback);
-    callback.await(request2.url()).assertCode(200).assertBody("A");
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v1");
-  }
-
-  @Test public void conditionalCacheMiss() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v1")
-        .addHeader("Vary: Accept-Charset")
-        .addHeader("Donut: a")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .addHeader("Donut: b")
-        .setBody("B"));
-
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    long request1SentAt = System.currentTimeMillis();
-    executeSynchronously("/", "Accept-Language", "fr-CA", "Accept-Charset", "UTF-8")
-        .assertCode(200)
-        .assertBody("A");
-    long request1ReceivedAt = System.currentTimeMillis();
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
-
-    // Different request, but Vary says it doesn't matter.
-    Thread.sleep(10); // Make sure the timestamps are unique.
-    long request2SentAt = System.currentTimeMillis();
-    RecordedResponse cacheMiss = executeSynchronously(
-        "/", "Accept-Language", "en-US", "Accept-Charset", "UTF-8");
-    long request2ReceivedAt = System.currentTimeMillis();
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v1");
-
-    // Check the user response. It has the application's original request.
-    cacheMiss.assertCode(200)
-        .assertBody("B")
-        .assertHeader("Donut", "b")
-        .assertRequestUrl(server.url("/"))
-        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
-        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
-
-    // Check the cache response. Even though it's a miss, we used the cache.
-    cacheMiss.cacheResponse()
-        .assertCode(200)
-        .assertHeader("Donut", "a")
-        .assertHeader("ETag", "v1")
-        .assertRequestUrl(server.url("/"))
-        .assertSentRequestAtMillis(request1SentAt, request1ReceivedAt)
-        .assertReceivedResponseAtMillis(request1SentAt, request1ReceivedAt);
-
-    // Check the network response. It has the network request, plus caching headers.
-    cacheMiss.networkResponse()
-        .assertCode(200)
-        .assertHeader("Donut", "b")
-        .assertRequestHeader("If-None-Match", "v1")  // If-None-Match in the validation request.
-        .assertRequestUrl(server.url("/"))
-        .assertSentRequestAtMillis(request2SentAt, request2ReceivedAt)
-        .assertReceivedResponseAtMillis(request2SentAt, request2ReceivedAt);
-  }
-
-  @Test public void conditionalCacheMiss_Async() throws Exception {
-    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    Request request1 = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    client.newCall(request1).enqueue(callback);
-    callback.await(request1.url()).assertCode(200).assertBody("A");
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isNull();
-
-    Request request2 = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    client.newCall(request2).enqueue(callback);
-    callback.await(request2.url()).assertCode(200).assertBody("B");
-    assertThat(server.takeRequest().getHeader("If-None-Match")).isEqualTo("v1");
-  }
-
-  @Test public void onlyIfCachedReturns504WhenNotCached() throws Exception {
-    executeSynchronously("/", "Cache-Control", "only-if-cached")
-        .assertCode(504)
-        .assertBody("")
-        .assertNoNetworkResponse()
-        .assertNoCacheResponse();
-  }
-
-  @Test public void networkDropsOnConditionalGet() throws IOException {
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    // Seed the cache.
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v1")
-        .setBody("A"));
-    executeSynchronously("/")
-        .assertCode(200)
-        .assertBody("A");
-
-    // Attempt conditional cache validation and a DNS miss.
-    client = client.newBuilder()
-        .dns(new FakeDns())
-        .build();
-    executeSynchronously("/").assertFailure(UnknownHostException.class);
-  }
-
-  @Test public void redirect() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Location: /b")
-        .addHeader("Test", "Redirect from /a to /b")
-        .setBody("/a has moved!"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: /c")
-        .addHeader("Test", "Redirect from /b to /c")
-        .setBody("/b has moved!"));
-    server.enqueue(new MockResponse().setBody("C"));
-
-    executeSynchronously("/a")
-        .assertCode(200)
-        .assertBody("C")
-        .priorResponse()
-        .assertCode(302)
-        .assertHeader("Test", "Redirect from /b to /c")
-        .priorResponse()
-        .assertCode(301)
-        .assertHeader("Test", "Redirect from /a to /b");
-
-    // New connection.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    // Connection reused.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-    // Connection reused again!
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
-  }
-
-  @Test public void postRedirectsToGet() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /page2")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("Page 2"));
-
-    Response response = client.newCall(new Request.Builder()
-        .url(server.url("/page1"))
-        .post(RequestBody.create("Request Body", MediaType.get("text/plain")))
-        .build()).execute();
-    assertThat(response.body().string()).isEqualTo("Page 2");
-
-    RecordedRequest page1 = server.takeRequest();
-    assertThat(page1.getRequestLine()).isEqualTo("POST /page1 HTTP/1.1");
-    assertThat(page1.getBody().readUtf8()).isEqualTo("Request Body");
-
-    RecordedRequest page2 = server.takeRequest();
-    assertThat(page2.getRequestLine()).isEqualTo("GET /page2 HTTP/1.1");
-  }
-
-  @Test public void getClientRequestTimeout() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(408)
-        .setHeader("Connection", "Close")
-        .setBody("You took too long!"));
-    server.enqueue(new MockResponse().setBody("Body"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response = client.newCall(request).execute();
-
-    assertThat(response.body().string()).isEqualTo("Body");
-  }
-
-  @Test public void getClientRequestTimeoutWithBackPressure() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(408)
-        .setHeader("Connection", "Close")
-        .setHeader("Retry-After", "1")
-        .setBody("You took too long!"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response = client.newCall(request).execute();
-
-    assertThat(response.body().string()).isEqualTo("You took too long!");
-  }
-
-  @Test public void requestBodyRetransmittedOnClientRequestTimeout() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(408)
-        .setHeader("Connection", "Close")
-        .setBody("You took too long!"));
-    server.enqueue(new MockResponse().setBody("Body"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create("Hello", MediaType.get("text/plain")))
-        .build();
-    Response response = client.newCall(request).execute();
-
-    assertThat(response.body().string()).isEqualTo("Body");
-
-    RecordedRequest request1 = server.takeRequest();
-    assertThat(request1.getBody().readUtf8()).isEqualTo("Hello");
-
-    RecordedRequest request2 = server.takeRequest();
-    assertThat(request2.getBody().readUtf8()).isEqualTo("Hello");
-  }
-
-  @Test public void disableClientRequestTimeoutRetry() throws IOException {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(408)
-        .setHeader("Connection", "Close")
-        .setBody("You took too long!"));
-
-    client = client.newBuilder()
-        .retryOnConnectionFailure(false)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response = client.newCall(request).execute();
-
-    assertThat(response.code()).isEqualTo(408);
-    assertThat(response.body().string()).isEqualTo("You took too long!");
-  }
-
-  @Test public void maxClientRequestTimeoutRetries() throws IOException {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(408)
-        .setHeader("Connection", "Close")
-        .setBody("You took too long!"));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(408)
-        .setHeader("Connection", "Close")
-        .setBody("You took too long!"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response = client.newCall(request).execute();
-
-    assertThat(response.code()).isEqualTo(408);
-    assertThat(response.body().string()).isEqualTo("You took too long!");
-
-    assertThat(server.getRequestCount()).isEqualTo(2);
-  }
-
-  @Test public void maxUnavailableTimeoutRetries() throws IOException {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(503)
-        .setHeader("Connection", "Close")
-        .setHeader("Retry-After", "0")
-        .setBody("You took too long!"));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(503)
-        .setHeader("Connection", "Close")
-        .setHeader("Retry-After", "0")
-        .setBody("You took too long!"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response = client.newCall(request).execute();
-
-    assertThat(response.code()).isEqualTo(503);
-    assertThat(response.body().string()).isEqualTo("You took too long!");
-
-    assertThat(server.getRequestCount()).isEqualTo(2);
-  }
-
-  @Test public void retryOnUnavailableWith0RetryAfter() throws IOException {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(503)
-        .setHeader("Connection", "Close")
-        .setHeader("Retry-After", "0")
-        .setBody("You took too long!"));
-    server.enqueue(new MockResponse().setBody("Body"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response = client.newCall(request).execute();
-
-    assertThat(response.body().string()).isEqualTo("Body");
-  }
-
-  @Test public void canRetryNormalRequestBody() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(503)
-        .setHeader("Retry-After", "0")
-        .setBody("please retry"));
-    server.enqueue(new MockResponse()
-        .setBody("thank you for retrying"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(new RequestBody() {
-          int attempt = 0;
-
-          @Override public @Nullable MediaType contentType() {
-            return null;
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            sink.writeUtf8("attempt " + attempt++);
-          }
-        })
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.body().string()).isEqualTo("thank you for retrying");
-
-    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("attempt 0");
-    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("attempt 1");
-    assertThat(server.getRequestCount()).isEqualTo(2);
-  }
-
-  @Test public void cannotRetryOneShotRequestBody() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(503)
-        .setHeader("Retry-After", "0")
-        .setBody("please retry"));
-    server.enqueue(new MockResponse()
-        .setBody("thank you for retrying"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(new RequestBody() {
-          int attempt = 0;
-
-          @Override public @Nullable MediaType contentType() {
-            return null;
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            sink.writeUtf8("attempt " + attempt++);
-          }
-
-          @Override public boolean isOneShot() {
-            return true;
-          }
-        })
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.code()).isEqualTo(503);
-    assertThat(response.body().string()).isEqualTo("please retry");
-
-    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("attempt 0");
-    assertThat(server.getRequestCount()).isEqualTo(1);
-  }
-
-  @Test public void propfindRedirectsToPropfindAndMaintainsRequestBody() throws Exception {
-    // given
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /page2")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("Page 2"));
-
-    // when
-    Response response = client.newCall(new Request.Builder()
-        .url(server.url("/page1"))
-        .method("PROPFIND", RequestBody.create("Request Body", MediaType.get("text/plain")))
-        .build()).execute();
-
-    // then
-    assertThat(response.body().string()).isEqualTo("Page 2");
-
-    RecordedRequest page1 = server.takeRequest();
-    assertThat(page1.getRequestLine()).isEqualTo("PROPFIND /page1 HTTP/1.1");
-    assertThat(page1.getBody().readUtf8()).isEqualTo("Request Body");
-
-    RecordedRequest page2 = server.takeRequest();
-    assertThat(page2.getRequestLine()).isEqualTo("PROPFIND /page2 HTTP/1.1");
-    assertThat(page2.getBody().readUtf8()).isEqualTo("Request Body");
-  }
-
-  @Test public void responseCookies() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Set-Cookie", "a=b; Expires=Thu, 01 Jan 1970 00:00:00 GMT")
-        .addHeader("Set-Cookie", "c=d; Expires=Fri, 02 Jan 1970 23:59:59 GMT; path=/bar; secure"));
-
-    RecordingCookieJar cookieJar = new RecordingCookieJar();
-    client = client.newBuilder()
-        .cookieJar(cookieJar)
-        .build();
-
-    executeSynchronously("/").assertCode(200);
-
-    List<Cookie> responseCookies = cookieJar.takeResponseCookies();
-    assertThat(responseCookies.size()).isEqualTo(2);
-    assertThat(responseCookies.get(0).toString()).isEqualTo(
-        "a=b; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/");
-    assertThat(responseCookies.get(1).toString()).isEqualTo(
-        "c=d; expires=Fri, 02 Jan 1970 23:59:59 GMT; path=/bar; secure");
-  }
-
-  @Test public void requestCookies() throws Exception {
-    server.enqueue(new MockResponse());
-
-    RecordingCookieJar cookieJar = new RecordingCookieJar();
-
-    cookieJar.enqueueRequestCookies(
-        new Cookie.Builder().name("a").value("b").domain(server.getHostName()).build(),
-        new Cookie.Builder().name("c").value("d").domain(server.getHostName()).build());
-    client = client.newBuilder()
-        .cookieJar(cookieJar)
-        .build();
-
-    executeSynchronously("/").assertCode(200);
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getHeader("Cookie")).isEqualTo("a=b; c=d");
-  }
-
-  @Test public void redirectsDoNotIncludeTooManyCookies() throws Exception {
-    server2.enqueue(new MockResponse().setBody("Page 2"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/")));
-
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    HttpCookie cookie = new HttpCookie("c", "cookie");
-    cookie.setDomain(server.getHostName());
-    cookie.setPath("/");
-    String portList = Integer.toString(server.getPort());
-    cookie.setPortlist(portList);
-    cookieManager.getCookieStore().add(server.url("/").uri(), cookie);
-    client = client.newBuilder()
-        .cookieJar(new JavaNetCookieJar(cookieManager))
-        .build();
-
-    Response response = client.newCall(new Request.Builder()
-        .url(server.url("/page1"))
-        .build()).execute();
-    assertThat(response.body().string()).isEqualTo("Page 2");
-
-    RecordedRequest request1 = server.takeRequest();
-    assertThat(request1.getHeader("Cookie")).isEqualTo("c=cookie");
-
-    RecordedRequest request2 = server2.takeRequest();
-    assertThat(request2.getHeader("Cookie")).isNull();
-  }
-
-  @Test public void redirectsDoNotIncludeTooManyAuthHeaders() throws Exception {
-    server2.enqueue(new MockResponse().setBody("Page 2"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(401));
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: " + server2.url("/b")));
-
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret"), null))
-        .build();
-
-    Request request = new Request.Builder().url(server.url("/a")).build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("Page 2");
-
-    RecordedRequest redirectRequest = server2.takeRequest();
-    assertThat(redirectRequest.getHeader("Authorization")).isNull();
-    assertThat(redirectRequest.getPath()).isEqualTo("/b");
-  }
-
-  @Test public void redirect_Async() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Location: /b")
-        .addHeader("Test", "Redirect from /a to /b")
-        .setBody("/a has moved!"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: /c")
-        .addHeader("Test", "Redirect from /b to /c")
-        .setBody("/b has moved!"));
-    server.enqueue(new MockResponse().setBody("C"));
-
-    Request request = new Request.Builder().url(server.url("/a")).build();
-    client.newCall(request).enqueue(callback);
-
-    callback.await(server.url("/a"))
-        .assertCode(200)
-        .assertBody("C")
-        .priorResponse()
-        .assertCode(302)
-        .assertHeader("Test", "Redirect from /b to /c")
-        .priorResponse()
-        .assertCode(301)
-        .assertHeader("Test", "Redirect from /a to /b");
-
-    // New connection.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    // Connection reused.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-    // Connection reused again!
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
-  }
-
-  @Test public void follow20Redirects() throws Exception {
-    for (int i = 0; i < 20; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(301)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-    server.enqueue(new MockResponse().setBody("Success!"));
-
-    executeSynchronously("/0")
-        .assertCode(200)
-        .assertBody("Success!");
-  }
-
-  @Test public void follow20Redirects_Async() throws Exception {
-    for (int i = 0; i < 20; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(301)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-    server.enqueue(new MockResponse().setBody("Success!"));
-
-    Request request = new Request.Builder().url(server.url("/0")).build();
-    client.newCall(request).enqueue(callback);
-    callback.await(server.url("/0"))
-        .assertCode(200)
-        .assertBody("Success!");
-  }
-
-  @Test public void doesNotFollow21Redirects() throws Exception {
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(301)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-
-    try {
-      client.newCall(new Request.Builder().url(server.url("/0")).build()).execute();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("Too many follow-up requests: 21");
-    }
-  }
-
-  @Test public void doesNotFollow21Redirects_Async() throws Exception {
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(301)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-
-    Request request = new Request.Builder().url(server.url("/0")).build();
-    client.newCall(request).enqueue(callback);
-    callback.await(server.url("/0")).assertFailure("Too many follow-up requests: 21");
-  }
-
-  @Test public void http204WithBodyDisallowed() throws IOException {
-    server.enqueue(new MockResponse()
-        .setResponseCode(204)
-        .setBody("I'm not even supposed to be here today."));
-
-    executeSynchronously("/")
-        .assertFailure("HTTP 204 had non-zero Content-Length: 39");
-  }
-
-  @Test public void http205WithBodyDisallowed() throws IOException {
-    server.enqueue(new MockResponse()
-        .setResponseCode(205)
-        .setBody("I'm not even supposed to be here today."));
-
-    executeSynchronously("/")
-        .assertFailure("HTTP 205 had non-zero Content-Length: 39");
-  }
-
-  @Test public void httpWithExcessiveHeaders() throws IOException {
-    String longLine = "HTTP/1.1 200 " + stringFill('O', 256 * 1024) + "K";
-
-    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
-
-    server.enqueue(new MockResponse()
-        .setStatus(longLine)
-        .setBody("I'm not even supposed to be here today."));
-
-    executeSynchronously("/")
-        .assertFailureMatches(".*unexpected end of stream on " + server.url("/").redact());
-  }
-
-  private String stringFill(char fillChar, int length) {
-    char[] value = new char[length];
-    Arrays.fill(value, fillChar);
-    return new String(value);
-  }
-
-  @Test public void canceledBeforeExecute() throws Exception {
-    Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
-    call.cancel();
-
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-    assertThat(server.getRequestCount()).isEqualTo(0);
-  }
-
-  @Test public void cancelDuringHttpConnect() throws Exception {
-    cancelDuringConnect("http");
-  }
-
-  @Test public void cancelDuringHttpsConnect() throws Exception {
-    cancelDuringConnect("https");
-  }
-
-  /** Cancel a call that's waiting for connect to complete. */
-  private void cancelDuringConnect(String scheme) throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.STALL_SOCKET_AT_START));
-
-    long cancelDelayMillis = 300L;
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/").newBuilder().scheme(scheme).build())
-        .build());
-    cancelLater(call, cancelDelayMillis);
-
-    long startNanos = System.nanoTime();
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-    long elapsedNanos = System.nanoTime() - startNanos;
-    assertThat((float) TimeUnit.NANOSECONDS.toMillis(elapsedNanos)).isCloseTo(
-        (float) cancelDelayMillis, offset(100f));
-  }
-
-  @Test public void cancelImmediatelyAfterEnqueue() throws Exception {
-    server.enqueue(new MockResponse());
-    final CountDownLatch latch = new CountDownLatch(1);
-    client = client.newBuilder()
-        .addNetworkInterceptor(chain -> {
-          try {
-            latch.await();
-          } catch (InterruptedException e) {
-            throw new AssertionError(e);
-          }
-          return chain.proceed(chain.request());
-        })
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/a"))
-        .build());
-    call.enqueue(callback);
-    call.cancel();
-    latch.countDown();
-
-    callback.await(server.url("/a")).assertFailure("Canceled", "Socket closed", "Socket is closed");
-  }
-
-  @Test public void cancelAll() throws Exception {
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    call.enqueue(callback);
-    client.dispatcher().cancelAll();
-    callback.await(server.url("/")).assertFailure("Canceled", "Socket closed", "Socket is closed");
-  }
-
-  @Test
-  public void cancelWhileRequestHeadersAreSent() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    EventListener listener = new EventListener() {
-      @Override public void requestHeadersStart(Call call) {
-        try {
-          // Cancel call from another thread to avoid reentrance.
-          cancelLater(call, 0).join();
-        } catch (InterruptedException e) {
-          throw new AssertionError();
-        }
-      }
-    };
-    client = client.newBuilder().eventListener(listener).build();
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test
-  public void cancelWhileRequestHeadersAreSent_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    cancelWhileRequestHeadersAreSent();
-  }
-
-  @Test public void cancelBeforeBodyIsRead() throws Exception {
-    server.enqueue(new MockResponse().setBody("def").throttleBody(1, 750, TimeUnit.MILLISECONDS));
-
-    final Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
-    ExecutorService executor = Executors.newSingleThreadExecutor();
-    Future<Response> result = executor.submit(call::execute);
-
-    Thread.sleep(100); // wait for it to go in flight.
-
-    call.cancel();
-    try {
-      result.get().body().bytes();
-      fail();
-    } catch (IOException expected) {
-    }
-    assertThat(server.getRequestCount()).isEqualTo(1);
-  }
-
-  @Test public void cancelInFlightBeforeResponseReadThrowsIOE() throws Exception {
-    Request request = new Request.Builder().url(server.url("/a")).build();
-    final Call call = client.newCall(request);
-
-    server.setDispatcher(new Dispatcher() {
-      @Override public MockResponse dispatch(RecordedRequest request) {
-        call.cancel();
-        return new MockResponse().setBody("A");
-      }
-    });
-
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    assertThat(server.takeRequest().getPath()).isEqualTo("/a");
-  }
-
-  @Test public void cancelInFlightBeforeResponseReadThrowsIOE_HTTPS() throws Exception {
-    enableTls();
-    cancelInFlightBeforeResponseReadThrowsIOE();
-  }
-
-  @Test public void cancelInFlightBeforeResponseReadThrowsIOE_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    cancelInFlightBeforeResponseReadThrowsIOE();
-  }
-
-  /**
-   * This test puts a request in front of one that is to be canceled, so that it is canceled before
-   * I/O takes place.
-   */
-  @Test public void canceledBeforeIOSignalsOnFailure() throws Exception {
-    // Force requests to be executed serially.
-    okhttp3.Dispatcher dispatcher = new okhttp3.Dispatcher(client.dispatcher().executorService());
-    dispatcher.setMaxRequests(1);
-    client = client.newBuilder()
-        .dispatcher(dispatcher)
-        .build();
-
-    Request requestA = new Request.Builder().url(server.url("/a")).build();
-    Request requestB = new Request.Builder().url(server.url("/b")).build();
-    final Call callA = client.newCall(requestA);
-    final Call callB = client.newCall(requestB);
-
-    server.setDispatcher(new Dispatcher() {
-      char nextResponse = 'A';
-
-      @Override public MockResponse dispatch(RecordedRequest request) {
-        callB.cancel();
-        return new MockResponse().setBody(Character.toString(nextResponse++));
-      }
-    });
-
-    callA.enqueue(callback);
-    callB.enqueue(callback);
-    assertThat(server.takeRequest().getPath()).isEqualTo("/a");
-
-    callback.await(requestA.url()).assertBody("A");
-    // At this point we know the callback is ready, and that it will receive a cancel failure.
-    callback.await(requestB.url()).assertFailure("Canceled", "Socket closed");
-  }
-
-  @Test public void canceledBeforeIOSignalsOnFailure_HTTPS() throws Exception {
-    enableTls();
-    canceledBeforeIOSignalsOnFailure();
-  }
-
-  @Test public void canceledBeforeIOSignalsOnFailure_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    canceledBeforeIOSignalsOnFailure();
-  }
-
-  @Test public void canceledBeforeResponseReadSignalsOnFailure() throws Exception {
-    Request requestA = new Request.Builder().url(server.url("/a")).build();
-    final Call call = client.newCall(requestA);
-    server.setDispatcher(new Dispatcher() {
-      @Override public MockResponse dispatch(RecordedRequest request) {
-        call.cancel();
-        return new MockResponse().setBody("A");
-      }
-    });
-
-    call.enqueue(callback);
-    assertThat(server.takeRequest().getPath()).isEqualTo("/a");
-
-    callback.await(requestA.url()).assertFailure("Canceled", "stream was reset: CANCEL",
-        "Socket closed");
-  }
-
-  @Test public void canceledBeforeResponseReadSignalsOnFailure_HTTPS() throws Exception {
-    enableTls();
-    canceledBeforeResponseReadSignalsOnFailure();
-  }
-
-  @Test public void canceledBeforeResponseReadSignalsOnFailure_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    canceledBeforeResponseReadSignalsOnFailure();
-  }
-
-  /**
-   * There's a race condition where the cancel may apply after the stream has already been
-   * processed.
-   */
-  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    final AtomicReference<String> bodyRef = new AtomicReference<>();
-    final AtomicBoolean failureRef = new AtomicBoolean();
-
-    Request request = new Request.Builder().url(server.url("/a")).build();
-    final Call call = client.newCall(request);
-    call.enqueue(new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-        failureRef.set(true);
-        latch.countDown();
-      }
-
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        call.cancel();
-        try {
-          bodyRef.set(response.body().string());
-        } catch (IOException e) { // It is ok if this broke the stream.
-          bodyRef.set("A");
-          throw e; // We expect to not loop into onFailure in this case.
-        } finally {
-          latch.countDown();
-        }
-      }
-    });
-
-    latch.await();
-    assertThat(bodyRef.get()).isEqualTo("A");
-    assertThat(failureRef.get()).isFalse();
-  }
-
-  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_HTTPS()
-      throws Exception {
-    enableTls();
-    canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
-  }
-
-  @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_HTTP_2()
-      throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
-  }
-
-  @Test public void cancelWithInterceptor() throws Exception {
-    client = client.newBuilder()
-        .addInterceptor(chain -> {
-          chain.proceed(chain.request());
-          throw new AssertionError(); // We expect an exception.
-        })
-        .build();
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
-    call.cancel();
-
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-    assertThat(server.getRequestCount()).isEqualTo(0);
-  }
-
-  @Test public void gzip() throws Exception {
-    Buffer gzippedBody = gzip("abcabcabc");
-    String bodySize = Long.toString(gzippedBody.size());
-
-    server.enqueue(new MockResponse()
-        .setBody(gzippedBody)
-        .addHeader("Content-Encoding: gzip"));
-
-    // Confirm that the user request doesn't have Accept-Encoding, and the user
-    // response doesn't have a Content-Encoding or Content-Length.
-    RecordedResponse userResponse = executeSynchronously("/");
-    userResponse.assertCode(200)
-        .assertRequestHeader("Accept-Encoding")
-        .assertHeader("Content-Encoding")
-        .assertHeader("Content-Length")
-        .assertBody("abcabcabc");
-
-    // But the network request doesn't lie. OkHttp used gzip for this call.
-    userResponse.networkResponse()
-        .assertHeader("Content-Encoding", "gzip")
-        .assertHeader("Content-Length", bodySize)
-        .assertRequestHeader("Accept-Encoding", "gzip");
-  }
-
-  /** https://github.com/square/okhttp/issues/1927 */
-  @Test public void gzipResponseAfterAuthenticationChallenge() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(401));
-    server.enqueue(new MockResponse()
-        .setBody(gzip("abcabcabc"))
-        .addHeader("Content-Encoding: gzip"));
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator("password", null))
-        .build();
-
-    executeSynchronously("/").assertBody("abcabcabc");
-  }
-
-  @Test public void rangeHeaderPreventsAutomaticGzip() throws Exception {
-    Buffer gzippedBody = gzip("abcabcabc");
-
-    // Enqueue a gzipped response. Our request isn't expecting it, but that's okay.
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
-        .setBody(gzippedBody)
-        .addHeader("Content-Encoding: gzip")
-        .addHeader("Content-Range: bytes 0-" + (gzippedBody.size() - 1)));
-
-    // Make a range request.
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Range", "bytes=0-")
-        .build();
-    Call call = client.newCall(request);
-
-    // The response is not decompressed.
-    Response response = call.execute();
-    assertThat(response.header("Content-Encoding")).isEqualTo("gzip");
-    assertThat(response.body().source().readByteString()).isEqualTo(gzippedBody.snapshot());
-
-    // The request did not offer gzip support.
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getHeader("Accept-Encoding")).isNull();
-  }
-
-  @Test public void asyncResponseCanBeConsumedLater() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("User-Agent", "SyncApiTest")
-        .build();
-
-    final BlockingQueue<Response> responseRef = new SynchronousQueue<>();
-    client.newCall(request).enqueue(new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-        throw new AssertionError();
-      }
-
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        try {
-          responseRef.put(response);
-        } catch (InterruptedException e) {
-          throw new AssertionError();
-        }
-      }
-    });
-
-    Response response = responseRef.take();
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.body().string()).isEqualTo("abc");
-
-    // Make another request just to confirm that that connection can be reused...
-    executeSynchronously("/").assertBody("def");
-    // New connection.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    // Connection reused.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-
-    // ... even before we close the response body!
-    response.body().close();
-  }
-
-  @Test public void userAgentIsIncludedByDefault() throws Exception {
-    server.enqueue(new MockResponse());
-
-    executeSynchronously("/");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getHeader("User-Agent")).matches(Version.userAgent);
-  }
-
-  @Test public void setFollowRedirectsFalse() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: /b")
-        .setBody("A"));
-    server.enqueue(new MockResponse().setBody("B"));
-
-    client = client.newBuilder()
-        .followRedirects(false)
-        .build();
-    executeSynchronously("/a")
-        .assertBody("A")
-        .assertCode(302);
-  }
-
-  @Test public void expect100ContinueNonEmptyRequestBody() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Expect", "100-continue")
-        .post(RequestBody.create("abc", MediaType.get("text/plain")))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertSuccessful();
-
-    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("abc");
-  }
-
-  @Test public void expect100ContinueEmptyRequestBody() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Expect", "100-continue")
-        .post(RequestBody.create("", MediaType.get("text/plain")))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertSuccessful();
-  }
-
-  @Test public void expect100ContinueEmptyRequestBody_HTTP2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    expect100ContinueEmptyRequestBody();
-  }
-
-  @Test public void expect100ContinueTimesOutWithoutContinue() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.NO_RESPONSE));
-
-    client = client.newBuilder()
-        .readTimeout(500, TimeUnit.MILLISECONDS)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Expect", "100-continue")
-        .post(RequestBody.create("abc", MediaType.get("text/plain")))
-        .build();
-
-    Call call = client.newCall(request);
-    try {
-      call.execute();
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("");
-  }
-
-  @Test public void expect100ContinueTimesOutWithoutContinue_HTTP2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    expect100ContinueTimesOutWithoutContinue();
-  }
-
-  @Test public void serverRespondsWithUnsolicited100Continue() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.CONTINUE_ALWAYS));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create("abc", MediaType.get("text/plain")))
-        .build();
-
-    executeSynchronously(request)
-        .assertCode(200)
-        .assertSuccessful();
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("abc");
-  }
-
-  @Test public void serverRespondsWithUnsolicited100Continue_HTTP2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    serverRespondsWithUnsolicited100Continue();
-  }
-
-  @Test public void serverRespondsWith100ContinueOnly() throws Exception {
-    client = client.newBuilder()
-        .readTimeout(1, TimeUnit.SECONDS)
-        .build();
-
-    server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 100 Continue"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create("abc", MediaType.get("text/plain")))
-        .build();
-
-    Call call = client.newCall(request);
-    try {
-      call.execute();
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("abc");
-  }
-
-  @Test public void serverRespondsWith100ContinueOnly_HTTP2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    serverRespondsWith100ContinueOnly();
-  }
-
-  @Test public void successfulExpectContinuePermitsConnectionReuse() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE));
-    server.enqueue(new MockResponse());
-
-    executeSynchronously(new Request.Builder()
-        .url(server.url("/"))
-        .header("Expect", "100-continue")
-        .post(RequestBody.create("abc", MediaType.get("text/plain")))
-        .build());
-    executeSynchronously(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void successfulExpectContinuePermitsConnectionReuseWithHttp2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    successfulExpectContinuePermitsConnectionReuse();
-  }
-
-  @Test public void unsuccessfulExpectContinuePreventsConnectionReuse() throws Exception {
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-
-    executeSynchronously(new Request.Builder()
-        .url(server.url("/"))
-        .header("Expect", "100-continue")
-        .post(RequestBody.create("abc", MediaType.get("text/plain")))
-        .build());
-    executeSynchronously(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void unsuccessfulExpectContinuePermitsConnectionReuseWithHttp2() throws Exception {
-    platform.assumeHttp2Support();
-
-    enableProtocol(Protocol.HTTP_2);
-
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-
-    executeSynchronously(new Request.Builder()
-        .url(server.url("/"))
-        .header("Expect", "100-continue")
-        .post(RequestBody.create("abc", MediaType.get("text/plain")))
-        .build());
-    executeSynchronously(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  /** We forbid non-ASCII characters in outgoing request headers, but accept UTF-8. */
-  @Test public void responseHeaderParsingIsLenient() throws Exception {
-    Headers.Builder headersBuilder = new Headers.Builder();
-    headersBuilder.add("Content-Length", "0");
-    addHeaderLenient(headersBuilder, "a\tb: c\u007fd");
-    addHeaderLenient(headersBuilder, ": ef");
-    addHeaderLenient(headersBuilder, "\ud83c\udf69: \u2615\ufe0f");
-    Headers headers = headersBuilder.build();
-    server.enqueue(new MockResponse().setHeaders(headers));
-
-    executeSynchronously("/")
-        .assertHeader("a\tb", "c\u007fd")
-        .assertHeader("\ud83c\udf69", "\u2615\ufe0f")
-        .assertHeader("", "ef");
-  }
-
-  @Test public void customDns() throws Exception {
-    // Configure a DNS that returns our local MockWebServer for android.com.
-    FakeDns dns = new FakeDns();
-    dns.set("android.com", Dns.SYSTEM.lookup(server.url("/").host()));
-    client = client.newBuilder()
-        .dns(dns)
-        .build();
-
-    server.enqueue(new MockResponse());
-    Request request = new Request.Builder()
-        .url(server.url("/").newBuilder().host("android.com").build())
-        .build();
-    executeSynchronously(request).assertCode(200);
-
-    dns.assertRequests("android.com");
-  }
-  @Test public void dnsReturnsZeroIpAddresses() throws Exception {
-    // Configure a DNS that returns our local MockWebServer for android.com.
-    FakeDns dns = new FakeDns();
-    List<InetAddress> ipAddresses = new ArrayList<>();
-    dns.set("android.com", ipAddresses);
-    client = client.newBuilder()
-        .dns(dns)
-        .build();
-
-    server.enqueue(new MockResponse());
-    Request request = new Request.Builder()
-        .url(server.url("/").newBuilder().host("android.com").build())
-        .build();
-    executeSynchronously(request).assertFailure(dns + " returned no addresses for android.com");
-
-    dns.assertRequests("android.com");
-  }
-
-  /** We had a bug where failed HTTP/2 calls could break the entire connection. */
-  @Test public void failingCallsDoNotInterfereWithConnection() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-
-    server.enqueue(new MockResponse().setBody("Response 1"));
-    server.enqueue(new MockResponse().setBody("Response 2"));
-
-    RequestBody requestBody = new RequestBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.writeUtf8("abc");
-        sink.flush();
-
-        makeFailingCall();
-
-        sink.writeUtf8("def");
-        sink.flush();
-      }
-    };
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(requestBody)
-        .build());
-    assertThat(call.execute().body().string()).isEqualTo("Response 1");
-  }
-
-  /** Test which headers are sent unencrypted to the HTTP proxy. */
-  @Test public void proxyConnectOmitsApplicationHeaders() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("encrypted response from the origin server"));
-
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .proxy(server.toProxyAddress())
-        .hostnameVerifier(hostnameVerifier)
-        .build();
-
-    Request request = new Request.Builder()
-        .url("https://android.com/foo")
-        .header("Private", "Secret")
-        .header("User-Agent", "App 1.0")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo(
-        "encrypted response from the origin server");
-
-    RecordedRequest connect = server.takeRequest();
-    assertThat(connect.getHeader("Private")).isNull();
-    assertThat(connect.getHeader("User-Agent")).isEqualTo(Version.userAgent);
-    assertThat(connect.getHeader("Proxy-Connection")).isEqualTo("Keep-Alive");
-    assertThat(connect.getHeader("Host")).isEqualTo("android.com:443");
-
-    RecordedRequest get = server.takeRequest();
-    assertThat(get.getHeader("Private")).isEqualTo("Secret");
-    assertThat(get.getHeader("User-Agent")).isEqualTo("App 1.0");
-
-    assertThat(hostnameVerifier.calls).containsExactly("verify android.com");
-  }
-
-  /** Respond to a proxy authorization challenge. */
-  @Test public void proxyAuthenticateOnConnect() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.enqueue(new MockResponse()
-        .setResponseCode(407)
-        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("response body"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    Request request = new Request.Builder()
-        .url("https://android.com/foo")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("response body");
-
-    RecordedRequest connect1 = server.takeRequest();
-    assertThat(connect1.getRequestLine()).isEqualTo("CONNECT android.com:443 HTTP/1.1");
-    assertThat(connect1.getHeader("Proxy-Authorization")).isNull();
-
-    RecordedRequest connect2 = server.takeRequest();
-    assertThat(connect2.getRequestLine()).isEqualTo("CONNECT android.com:443 HTTP/1.1");
-    assertThat(connect2.getHeader("Proxy-Authorization")).isEqualTo("password");
-
-    RecordedRequest get = server.takeRequest();
-    assertThat(get.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
-    assertThat(get.getHeader("Proxy-Authorization")).isNull();
-  }
-
-  /** Confirm that the proxy authenticator works for unencrypted HTTP proxies. */
-  @Test public void httpProxyAuthenticate() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(407)
-        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
-    server.enqueue(new MockResponse()
-        .setBody("response body"));
-
-    client = client.newBuilder()
-        .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
-        .build();
-
-    Request request = new Request.Builder()
-        .url("http://android.com/foo")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("response body");
-
-    RecordedRequest get1 = server.takeRequest();
-    assertThat(get1.getRequestLine()).isEqualTo("GET http://android.com/foo HTTP/1.1");
-    assertThat(get1.getHeader("Proxy-Authorization")).isNull();
-
-    RecordedRequest get2 = server.takeRequest();
-    assertThat(get2.getRequestLine()).isEqualTo("GET http://android.com/foo HTTP/1.1");
-    assertThat(get2.getHeader("Proxy-Authorization")).isEqualTo("password");
-  }
-
-  /**
-   * OkHttp has a bug where a `Connection: close` response header is not honored when establishing a
-   * TLS tunnel. https://github.com/square/okhttp/issues/2426
-   */
-  @Test public void proxyAuthenticateOnConnectWithConnectionClose() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
-    server.enqueue(new MockResponse()
-        .setResponseCode(407)
-        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\"")
-        .addHeader("Connection: close"));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("response body"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    Request request = new Request.Builder()
-        .url("https://android.com/foo")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("response body");
-
-    // First CONNECT call needs a new connection.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-
-    // Second CONNECT call needs a new connection.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-
-    // GET reuses the connection from the second connect.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void tooManyProxyAuthFailuresWithConnectionClose() throws IOException {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(407)
-          .addHeader("Proxy-Authenticate: Basic realm=\"localhost\"")
-          .addHeader("Connection: close"));
-    }
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    Request request = new Request.Builder()
-        .url("https://android.com/foo")
-        .build();
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  /**
-   * Confirm that we don't send the Proxy-Authorization header from the request to the proxy server.
-   * We used to have that behavior but it is problematic because unrelated requests end up sharing
-   * credentials. Worse, that approach leaks proxy credentials to the origin server.
-   */
-  @Test public void noPreemptiveProxyAuthorization() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("response body"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .proxy(server.toProxyAddress())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    Request request = new Request.Builder()
-        .url("https://android.com/foo")
-        .header("Proxy-Authorization", "password")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("response body");
-
-    RecordedRequest connect1 = server.takeRequest();
-    assertThat(connect1.getHeader("Proxy-Authorization")).isNull();
-
-    RecordedRequest connect2 = server.takeRequest();
-    assertThat(connect2.getHeader("Proxy-Authorization")).isEqualTo("password");
-  }
-
-  /** Confirm that we can send authentication information without being prompted first. */
-  @Test public void preemptiveProxyAuthentication() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("encrypted response from the origin server"));
-
-    final String credential = Credentials.basic("jesse", "password1");
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .proxy(server.toProxyAddress())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .proxyAuthenticator((route, response) -> {
-          assertThat(response.request().method()).isEqualTo("CONNECT");
-          assertThat(response.code()).isEqualTo(HttpURLConnection.HTTP_PROXY_AUTH);
-          assertThat(response.request().url().host()).isEqualTo("android.com");
-
-          List<Challenge> challenges = response.challenges();
-          assertThat(challenges.get(0).scheme()).isEqualTo("OkHttp-Preemptive");
-
-          return response.request().newBuilder()
-              .header("Proxy-Authorization", credential)
-              .build();
-        })
-        .build();
-
-    Request request = new Request.Builder()
-        .url("https://android.com/foo")
-        .build();
-
-    executeSynchronously(request).assertSuccessful();
-
-    RecordedRequest connect = server.takeRequest();
-    assertThat(connect.getMethod()).isEqualTo("CONNECT");
-    assertThat(connect.getHeader("Proxy-Authorization")).isEqualTo(credential);
-    assertThat(connect.getPath()).isEqualTo("/");
-
-    RecordedRequest get = server.takeRequest();
-    assertThat(get.getMethod()).isEqualTo("GET");
-    assertThat(get.getHeader("Proxy-Authorization")).isNull();
-    assertThat(get.getPath()).isEqualTo("/foo");
-  }
-
-  @Test public void preemptiveThenReactiveProxyAuthentication() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_PROXY_AUTH)
-        .addHeader("Proxy-Authenticate", "Basic realm=\"localhost\"")
-        .setBody("proxy auth required"));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse());
-
-    final List<String> challengeSchemes = new ArrayList<>();
-    final String credential = Credentials.basic("jesse", "password1");
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .proxy(server.toProxyAddress())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .proxyAuthenticator((route, response) -> {
-          List<Challenge> challenges = response.challenges();
-          challengeSchemes.add(challenges.get(0).scheme());
-          return response.request().newBuilder()
-              .header("Proxy-Authorization", credential)
-              .build();
-        })
-        .build();
-
-    Request request = new Request.Builder()
-        .url("https://android.com/foo")
-        .build();
-
-    executeSynchronously(request).assertSuccessful();
-
-    RecordedRequest connect1 = server.takeRequest();
-    assertThat(connect1.getMethod()).isEqualTo("CONNECT");
-    assertThat(connect1.getHeader("Proxy-Authorization")).isEqualTo(credential);
-
-    RecordedRequest connect2 = server.takeRequest();
-    assertThat(connect2.getMethod()).isEqualTo("CONNECT");
-    assertThat(connect2.getHeader("Proxy-Authorization")).isEqualTo(credential);
-
-    assertThat(challengeSchemes).containsExactly("OkHttp-Preemptive", "Basic");
-  }
-
-  /** https://github.com/square/okhttp/issues/4915 */
-  @Test @Ignore public void proxyDisconnectsAfterRequest() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .proxy(server.toProxyAddress())
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    try {
-      Response response = client.newCall(request).execute();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void interceptorGetsHttp2() throws Exception {
-    platform.assumeHttp2Support();
-
-    enableProtocol(Protocol.HTTP_2);
-
-    // Capture the protocol as it is observed by the interceptor.
-    final AtomicReference<Protocol> protocolRef = new AtomicReference<>();
-    Interceptor interceptor = chain -> {
-      protocolRef.set(chain.connection().protocol());
-      return chain.proceed(chain.request());
-    };
-    client = client.newBuilder()
-        .addNetworkInterceptor(interceptor)
-        .build();
-
-    // Make an HTTP/2 request and confirm that the protocol matches.
-    server.enqueue(new MockResponse());
-    executeSynchronously("/");
-    assertThat(protocolRef.get()).isEqualTo(Protocol.HTTP_2);
-  }
-
-  @Test public void serverSendsInvalidResponseHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .setStatus("HTP/1.1 200 OK"));
-
-    executeSynchronously("/")
-        .assertFailure("Unexpected status line: HTP/1.1 200 OK");
-  }
-
-  @Test public void serverSendsInvalidCodeTooLarge() throws Exception {
-    server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 2147483648 OK"));
-
-    executeSynchronously("/")
-        .assertFailure("Unexpected status line: HTTP/1.1 2147483648 OK");
-  }
-
-  @Test public void serverSendsInvalidCodeNotANumber() throws Exception {
-    server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 00a OK"));
-
-    executeSynchronously("/")
-        .assertFailure("Unexpected status line: HTTP/1.1 00a OK");
-  }
-
-  @Test public void serverSendsUnnecessaryWhitespace() throws Exception {
-    server.enqueue(new MockResponse()
-        .setStatus(" HTTP/1.1 200 OK"));
-
-    executeSynchronously("/")
-        .assertFailure("Unexpected status line:  HTTP/1.1 200 OK");
-  }
-
-  @Test public void requestHeaderNameWithSpaceForbidden() throws Exception {
-    try {
-      new Request.Builder().addHeader("a b", "c");
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "Unexpected char 0x20 at 1 in header name: a b");
-    }
-  }
-
-  @Test public void requestHeaderNameWithTabForbidden() throws Exception {
-    try {
-      new Request.Builder().addHeader("a\tb", "c");
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "Unexpected char 0x09 at 1 in header name: a\tb");
-    }
-  }
-
-  @Test public void responseHeaderNameWithSpacePermitted() throws Exception {
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .addHeader("content-length: 0")
-        .addHeaderLenient("a b", "c"));
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    Response response = call.execute();
-    assertThat(response.header("a b")).isEqualTo("c");
-  }
-
-  @Test public void responseHeaderNameWithTabPermitted() throws Exception {
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .addHeader("content-length: 0")
-        .addHeaderLenient("a\tb", "c"));
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    Response response = call.execute();
-    assertThat(response.header("a\tb")).isEqualTo("c");
-  }
-
-  @Test public void connectFails() throws Exception {
-    server.shutdown();
-
-    executeSynchronously("/")
-        .assertFailure(IOException.class);
-  }
-
-  @Test public void requestBodySurvivesRetries() throws Exception {
-    server.enqueue(new MockResponse());
-
-    // Enable a misconfigured proxy selector to guarantee that the request is retried.
-    client = client.newBuilder()
-        .proxySelector(new FakeProxySelector()
-            .addProxy(server2.toProxyAddress())
-            .addProxy(Proxy.NO_PROXY))
-        .build();
-    server2.shutdown();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create("abc", MediaType.get("text/plain")))
-        .build();
-
-    executeSynchronously(request);
-    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("abc");
-  }
-
-  @Ignore // This may fail in DNS lookup, which we don't have timeouts for.
-  @Test public void invalidHost() throws Exception {
-    Request request = new Request.Builder()
-        .url(HttpUrl.get("http://1234.1.1.1/"))
-        .build();
-
-    executeSynchronously(request)
-        .assertFailure(UnknownHostException.class);
-  }
-
-  @Test public void uploadBodySmallChunkedEncoding() throws Exception {
-    upload(true, 1048576, 256);
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getBodySize()).isEqualTo(1048576);
-    assertThat(recordedRequest.getChunkSizes()).isNotEmpty();
-  }
-
-  @Test public void uploadBodyLargeChunkedEncoding() throws Exception {
-    upload(true, 1048576, 65536);
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getBodySize()).isEqualTo(1048576);
-    assertThat(recordedRequest.getChunkSizes()).isNotEmpty();
-  }
-
-  @Test public void uploadBodySmallFixedLength() throws Exception {
-    upload(false, 1048576, 256);
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getBodySize()).isEqualTo(1048576);
-    assertThat(recordedRequest.getChunkSizes()).isEmpty();
-  }
-
-  @Test public void uploadBodyLargeFixedLength() throws Exception {
-    upload(false, 1048576, 65536);
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getBodySize()).isEqualTo(1048576);
-    assertThat(recordedRequest.getChunkSizes()).isEmpty();
-  }
-
-  private void upload(
-      final boolean chunked, final int size, final int writeSize) throws Exception {
-    server.enqueue(new MockResponse());
-    executeSynchronously(new Request.Builder()
-        .url(server.url("/"))
-        .post(requestBody(chunked, size, writeSize))
-        .build());
-  }
-
-  /** https://github.com/square/okhttp/issues/2344 */
-  @Test public void ipv6HostHasSquareBraces() throws Exception {
-    // Use a proxy to fake IPv6 connectivity, even if localhost doesn't have IPv6.
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("response body"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .proxy(server.toProxyAddress())
-        .build();
-
-    Request request = new Request.Builder()
-        .url("https://[::1]/")
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("response body");
-
-    RecordedRequest connect = server.takeRequest();
-    assertThat(connect.getRequestLine()).isEqualTo("CONNECT [::1]:443 HTTP/1.1");
-    assertThat(connect.getHeader("Host")).isEqualTo("[::1]:443");
-
-    RecordedRequest get = server.takeRequest();
-    assertThat(get.getRequestLine()).isEqualTo("GET / HTTP/1.1");
-    assertThat(get.getHeader("Host")).isEqualTo("[::1]");
-  }
-
-  private RequestBody requestBody(final boolean chunked, final long size, final int writeSize) {
-    final byte[] buffer = new byte[writeSize];
-    Arrays.fill(buffer, (byte) 'x');
-
-    return new RequestBody() {
-      @Override public MediaType contentType() {
-        return MediaType.get("text/plain; charset=utf-8");
-      }
-
-      @Override public long contentLength() throws IOException {
-        return chunked ? -1L : size;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        for (int count = 0; count < size; count += writeSize) {
-          sink.write(buffer, 0, (int) Math.min(size - count, writeSize));
-        }
-      }
-    };
-  }
-
-  @Test public void emptyResponseBody() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("abc", "def"));
-    executeSynchronously("/")
-        .assertCode(200)
-        .assertHeader("abc", "def")
-        .assertBody("");
-  }
-
-  @Test public void leakedResponseBodyLogsStackTrace() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("This gets leaked."));
-
-    client = clientTestRule.newClientBuilder()
-        .connectionPool(new ConnectionPool(0, 10, TimeUnit.MILLISECONDS))
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Level original = logger.getLevel();
-    logger.setLevel(Level.FINE);
-    logHandler.setFormatter(new SimpleFormatter());
-    try {
-      client.newCall(request).execute(); // Ignore the response so it gets leaked then GC'd.
-      awaitGarbageCollection();
-
-      String message = logHandler.take();
-      assertThat(message).contains("A connection to " + server.url("/") + " was leaked."
-            + " Did you forget to close a response body?");
-      assertThat(message).contains("okhttp3.RealCall.execute(");
-      assertThat(message).contains("okhttp3.CallTest.leakedResponseBodyLogsStackTrace(");
-    } finally {
-      logger.setLevel(original);
-    }
-  }
-
-  @Test public void asyncLeakedResponseBodyLogsStackTrace() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("This gets leaked."));
-
-    client = clientTestRule.newClientBuilder()
-        .connectionPool(new ConnectionPool(0, 10, TimeUnit.MILLISECONDS))
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Level original = logger.getLevel();
-    logger.setLevel(Level.FINE);
-    logHandler.setFormatter(new SimpleFormatter());
-    try {
-      final CountDownLatch latch = new CountDownLatch(1);
-      client.newCall(request).enqueue(new Callback() {
-        @Override public void onFailure(Call call, IOException e) {
-          fail();
-        }
-
-        @Override public void onResponse(Call call, Response response) throws IOException {
-          // Ignore the response so it gets leaked then GC'd.
-          latch.countDown();
-        }
-      });
-      latch.await();
-      // There's some flakiness when triggering a GC for objects in a separate thread. Adding a
-      // small delay appears to ensure the objects will get GC'd.
-      Thread.sleep(200);
-      awaitGarbageCollection();
-
-      String message = logHandler.take();
-      assertThat(message).contains("A connection to " + server.url("/") + " was leaked."
-            + " Did you forget to close a response body?");
-      assertThat(message).contains("okhttp3.RealCall.enqueue(");
-      assertThat(message).contains("okhttp3.CallTest.asyncLeakedResponseBodyLogsStackTrace(");
-    } finally {
-      logger.setLevel(original);
-    }
-  }
-
-  @Test public void failedAuthenticatorReleasesConnection() throws IOException {
-    server.enqueue(new MockResponse()
-        .setResponseCode(401));
-
-    client = client.newBuilder()
-        .authenticator((route, response) -> { throw new IOException("IOException!"); })
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    executeSynchronously(request)
-        .assertFailure(IOException.class);
-
-    assertThat(client.connectionPool().idleConnectionCount()).isEqualTo(1);
-  }
-
-  @Test public void failedProxyAuthenticatorReleasesConnection() throws IOException {
-    server.enqueue(new MockResponse()
-        .setResponseCode(407));
-
-    client = client.newBuilder()
-        .proxyAuthenticator((route, response) -> { throw new IOException("IOException!"); })
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    executeSynchronously(request)
-        .assertFailure(IOException.class);
-
-    assertThat(client.connectionPool().idleConnectionCount()).isEqualTo(1);
-  }
-
-  @Test public void httpsWithIpAddress() throws Exception {
-    String localIpAddress = InetAddress.getLoopbackAddress().getHostAddress();
-
-    // Create a certificate with an IP address in the subject alt name.
-    HeldCertificate heldCertificate = new HeldCertificate.Builder()
-        .commonName("example.com")
-        .addSubjectAlternativeName(localIpAddress)
-        .build();
-    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
-        .heldCertificate(heldCertificate)
-        .addTrustedCertificate(heldCertificate.certificate())
-        .build();
-
-    // Use that certificate on the server and trust it on the client.
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .protocols(Collections.singletonList(Protocol.HTTP_1_1))
-        .build();
-
-    // Make a request.
-    server.enqueue(new MockResponse());
-    HttpUrl url = server.url("/").newBuilder()
-        .host(localIpAddress)
-        .build();
-    Request request = new Request.Builder()
-        .url(url)
-        .build();
-    executeSynchronously(request)
-        .assertCode(200);
-
-    // Confirm that the IP address was used in the host header.
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getHeader("Host")).isEqualTo(
-        (localIpAddress + ":" + server.getPort()));
-  }
-
-  @Test public void postWithFileNotFound() throws Exception {
-    final AtomicInteger called = new AtomicInteger(0);
-
-    RequestBody body = new RequestBody() {
-      @Nullable @Override public MediaType contentType() {
-        return MediaType.get("application/octet-stream");
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        called.incrementAndGet();
-        throw new FileNotFoundException();
-      }
-    };
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(body)
-        .build();
-
-    client = client.newBuilder()
-        .dns(new DoubleInetAddressDns())
-        .build();
-
-    executeSynchronously(request)
-        .assertFailure(FileNotFoundException.class);
-
-    assertThat(called.get()).isEqualTo(1L);
-  }
-
-  @Test public void clientReadsHeadersDataTrailersHttp1ChunkedTransferEncoding() throws Exception {
-    MockResponse mockResponse = new MockResponse()
-        .clearHeaders()
-        .addHeader("h1", "v1")
-        .addHeader("h2", "v2")
-        .setChunkedBody("HelloBonjour", 1024)
-        .setTrailers(Headers.of("trailers", "boom"));
-    server.enqueue(mockResponse);
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    Response response = call.execute();
-    BufferedSource source = response.body().source();
-
-    assertThat(response.header("h1")).isEqualTo("v1");
-    assertThat(response.header("h2")).isEqualTo("v2");
-
-    assertThat(source.readUtf8(5)).isEqualTo("Hello");
-    assertThat(source.readUtf8(7)).isEqualTo("Bonjour");
-
-    assertThat(source.exhausted()).isTrue();
-    assertThat(response.trailers()).isEqualTo(Headers.of("trailers", "boom"));
-  }
-
-  @Test public void clientReadsHeadersDataTrailersHttp2() throws IOException {
-    platform.assumeHttp2Support();
-
-    MockResponse mockResponse = new MockResponse()
-        .clearHeaders()
-        .addHeader("h1", "v1")
-        .addHeader("h2", "v2")
-        .setBody("HelloBonjour")
-        .setTrailers(Headers.of("trailers", "boom"));
-    server.enqueue(mockResponse);
-    enableProtocol(Protocol.HTTP_2);
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    try (Response response = call.execute()) {
-      BufferedSource source = response.body().source();
-
-      assertThat(response.header("h1")).isEqualTo("v1");
-      assertThat(response.header("h2")).isEqualTo("v2");
-
-      assertThat(source.readUtf8(5)).isEqualTo("Hello");
-      assertThat(source.readUtf8(7)).isEqualTo("Bonjour");
-
-      assertThat(source.exhausted()).isTrue();
-      assertThat(response.trailers()).isEqualTo(Headers.of("trailers", "boom"));
-    }
-  }
-
-  @Test public void requestBodyThrowsUnrelatedToNetwork() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(new RequestBody() {
-          @Override public @Nullable MediaType contentType() {
-            return null;
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            sink.flush(); // For determinism, always send a partial request to the server.
-            throw new IOException("boom");
-          }
-        })
-        .build();
-
-    executeSynchronously(request).assertFailure("boom");
-
-    assertThat(server.takeRequest().getFailure()).isNotNull();
-  }
-
-  @Test public void requestBodyThrowsUnrelatedToNetwork_HTTP2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    requestBodyThrowsUnrelatedToNetwork();
-  }
-
-  /** https://github.com/square/okhttp/issues/4583 */
-  @Test public void lateCancelCallsOnFailure() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    AtomicBoolean closed = new AtomicBoolean();
-
-    client = client.newBuilder()
-        .addInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            Response response = chain.proceed(chain.request());
-            chain.call().cancel(); // Cancel after we have the response.
-            ForwardingSource closeTrackingSource = new ForwardingSource(response.body().source()) {
-              @Override public void close() throws IOException {
-                closed.set(true);
-                super.close();
-              }
-            };
-            return response.newBuilder()
-                .body(ResponseBody.create(Okio.buffer(closeTrackingSource), null, -1L))
-                .build();
-          }
-        })
-        .build();
-
-    executeSynchronously("/").assertFailure("Canceled");
-    assertThat(closed.get()).isTrue();
-  }
-
-  private void makeFailingCall() {
-    RequestBody requestBody = new RequestBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() throws IOException {
-        return 1;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.flush(); // For determinism, always send a partial request to the server.
-        throw new IOException("write body fail!");
-      }
-    };
-    OkHttpClient nonRetryingClient = client.newBuilder()
-        .retryOnConnectionFailure(false)
-        .build();
-    Call call = nonRetryingClient.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(requestBody)
-        .build());
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("write body fail!");
-    }
-  }
-
-  private RecordedResponse executeSynchronously(String path, String... headers) throws IOException {
-    Request.Builder builder = new Request.Builder();
-    builder.url(server.url(path));
-    for (int i = 0, size = headers.length; i < size; i += 2) {
-      builder.addHeader(headers[i], headers[i + 1]);
-    }
-    return executeSynchronously(builder.build());
-  }
-
-  private RecordedResponse executeSynchronously(Request request) throws IOException {
-    Call call = client.newCall(request);
-    try {
-      Response response = call.execute();
-      String bodyString = response.body().string();
-      return new RecordedResponse(request, response, null, bodyString, null);
-    } catch (IOException e) {
-      return new RecordedResponse(request, null, null, null, e);
-    }
-  }
-
-  /**
-   * Tests that use this will fail unless boot classpath is set. Ex. {@code
-   * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
-   */
-  private void enableProtocol(Protocol protocol) {
-    enableTls();
-    client = client.newBuilder()
-        .protocols(asList(protocol, Protocol.HTTP_1_1))
-        .build();
-    server.setProtocols(client.protocols());
-  }
-
-  private void enableTls() {
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-  }
-
-  private Buffer gzip(String data) throws IOException {
-    Buffer result = new Buffer();
-    BufferedSink sink = Okio.buffer(new GzipSink(result));
-    sink.writeUtf8(data);
-    sink.close();
-    return result;
-  }
-
-  private Thread cancelLater(final Call call, final long delay) {
-    Thread thread = new Thread("canceler") {
-      @Override public void run() {
-        try {
-          Thread.sleep(delay);
-        } catch (InterruptedException e) {
-          throw new AssertionError();
-        }
-        call.cancel();
-      }
-    };
-    thread.start();
-    return thread;
-  }
-
-  private SSLSocketFactory socketFactoryWithCipherSuite(
-      final SSLSocketFactory sslSocketFactory, final CipherSuite cipherSuite) {
-    return new DelegatingSSLSocketFactory(sslSocketFactory) {
-      @Override protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
-        sslSocket.setEnabledCipherSuites(new String[] { cipherSuite.javaName() });
-        return super.configureSocket(sslSocket);
-      }
-    };
-  }
-
-  private static class RecordingSSLSocketFactory extends DelegatingSSLSocketFactory {
-
-    private List<SSLSocket> socketsCreated = new ArrayList<>();
-
-    public RecordingSSLSocketFactory(SSLSocketFactory delegate) {
-      super(delegate);
-    }
-
-    @Override
-    protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
-      socketsCreated.add(sslSocket);
-      return sslSocket;
-    }
-
-    public List<SSLSocket> getSocketsCreated() {
-      return socketsCreated;
-    }
-  }
-
-  /**
-   * Used during tests that involve TLS connection fallback attempts. OkHttp includes the
-   * TLS_FALLBACK_SCSV cipher on fallback connections. See {@link FallbackTestClientSocketFactory}
-   * for details.
-   */
-  private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
-    return new FallbackTestClientSocketFactory(handshakeCertificates.sslSocketFactory());
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/CertificateChainCleanerTest.java b/okhttp/src/test/java/okhttp3/CertificateChainCleanerTest.java
deleted file mode 100644
index 45625df17a..0000000000
--- a/okhttp/src/test/java/okhttp3/CertificateChainCleanerTest.java
+++ /dev/null
@@ -1,274 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.List;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.internal.tls.CertificateChainCleaner;
-import okhttp3.tls.HandshakeCertificates;
-import okhttp3.tls.HeldCertificate;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class CertificateChainCleanerTest {
-  @Test public void equalsFromCertificate() {
-    HeldCertificate rootA = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .build();
-    HeldCertificate rootB = new HeldCertificate.Builder()
-        .serialNumber(2L)
-        .build();
-    assertThat(CertificateChainCleaner.Companion.get(rootB.certificate(), rootA.certificate()))
-        .isEqualTo(CertificateChainCleaner.Companion.get(rootA.certificate(), rootB.certificate()));
-  }
-
-  @Test public void equalsFromTrustManager() {
-    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder().build();
-    X509TrustManager x509TrustManager = handshakeCertificates.trustManager();
-    assertThat(CertificateChainCleaner.Companion.get(x509TrustManager)).isEqualTo(
-        CertificateChainCleaner.Companion.get(x509TrustManager));
-  }
-
-  @Test public void normalizeSingleSelfSignedCertificate() throws Exception {
-    HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .build();
-    CertificateChainCleaner cleaner = CertificateChainCleaner.Companion.get(root.certificate());
-    assertThat(cleaner.clean(list(root), "hostname")).isEqualTo(list(root));
-  }
-
-  @Test public void normalizeUnknownSelfSignedCertificate() {
-    HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .build();
-    CertificateChainCleaner cleaner = CertificateChainCleaner.Companion.get();
-
-    try {
-      cleaner.clean(list(root), "hostname");
-      fail();
-    } catch (SSLPeerUnverifiedException expected) {
-    }
-  }
-
-  @Test public void orderedChainOfCertificatesWithRoot() throws Exception {
-    HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .build();
-    HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber(2L)
-        .signedBy(root)
-        .build();
-    HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber(3L)
-        .signedBy(certA)
-        .build();
-
-    CertificateChainCleaner cleaner = CertificateChainCleaner.Companion.get(root.certificate());
-    assertThat(cleaner.clean(list(certB, certA, root), "hostname")).isEqualTo(
-        list(certB, certA, root));
-  }
-
-  @Test public void orderedChainOfCertificatesWithoutRoot() throws Exception {
-    HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .build();
-    HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber(2L)
-        .signedBy(root)
-        .build();
-    HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber(3L)
-        .signedBy(certA)
-        .build();
-
-    CertificateChainCleaner cleaner = CertificateChainCleaner.Companion.get(root.certificate());
-    // Root is added!
-    assertThat(cleaner.clean(list(certB, certA), "hostname")).isEqualTo(
-        list(certB, certA, root));
-  }
-
-  @Test public void unorderedChainOfCertificatesWithRoot() throws Exception {
-    HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .build();
-    HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber(2L)
-        .signedBy(root)
-        .build();
-    HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber(3L)
-        .signedBy(certA)
-        .build();
-    HeldCertificate certC = new HeldCertificate.Builder()
-        .serialNumber(4L)
-        .signedBy(certB)
-        .build();
-
-    CertificateChainCleaner cleaner = CertificateChainCleaner.Companion.get(root.certificate());
-    assertThat(cleaner.clean(list(certC, certA, root, certB), "hostname")).isEqualTo(
-        list(certC, certB, certA, root));
-  }
-
-  @Test public void unorderedChainOfCertificatesWithoutRoot() throws Exception {
-    HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .build();
-    HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber(2L)
-        .signedBy(root)
-        .build();
-    HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber(3L)
-        .signedBy(certA)
-        .build();
-    HeldCertificate certC = new HeldCertificate.Builder()
-        .serialNumber(4L)
-        .signedBy(certB)
-        .build();
-
-    CertificateChainCleaner cleaner = CertificateChainCleaner.Companion.get(root.certificate());
-    assertThat(cleaner.clean(list(certC, certA, certB), "hostname")).isEqualTo(
-        list(certC, certB, certA, root));
-  }
-
-  @Test public void unrelatedCertificatesAreOmitted() throws Exception {
-    HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .build();
-    HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber(2L)
-        .signedBy(root)
-        .build();
-    HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber(3L)
-        .signedBy(certA)
-        .build();
-    HeldCertificate certUnnecessary = new HeldCertificate.Builder()
-        .serialNumber(4L)
-        .build();
-
-    CertificateChainCleaner cleaner = CertificateChainCleaner.Companion.get(root.certificate());
-    assertThat(cleaner.clean(list(certB, certUnnecessary, certA, root), "hostname")).isEqualTo(
-        list(certB, certA, root));
-  }
-
-  @Test public void chainGoesAllTheWayToSelfSignedRoot() throws Exception {
-    HeldCertificate selfSigned = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .build();
-    HeldCertificate trusted = new HeldCertificate.Builder()
-        .serialNumber(2L)
-        .signedBy(selfSigned)
-        .build();
-    HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber(3L)
-        .signedBy(trusted)
-        .build();
-    HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber(4L)
-        .signedBy(certA)
-        .build();
-
-    CertificateChainCleaner cleaner = CertificateChainCleaner.Companion.get(
-        selfSigned.certificate(), trusted.certificate());
-    assertThat(cleaner.clean(list(certB, certA), "hostname")).isEqualTo(
-        list(certB, certA, trusted, selfSigned));
-    assertThat(cleaner.clean(list(certB, certA, trusted), "hostname")).isEqualTo(
-        list(certB, certA, trusted, selfSigned));
-    assertThat(cleaner.clean(list(certB, certA, trusted, selfSigned), "hostname")).isEqualTo(
-        list(certB, certA, trusted, selfSigned));
-  }
-
-  @Test public void trustedRootNotSelfSigned() throws Exception {
-    HeldCertificate unknownSigner = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .build();
-    HeldCertificate trusted = new HeldCertificate.Builder()
-        .signedBy(unknownSigner)
-        .serialNumber(2L)
-        .build();
-    HeldCertificate intermediateCa = new HeldCertificate.Builder()
-        .signedBy(trusted)
-        .serialNumber(3L)
-        .build();
-    HeldCertificate certificate = new HeldCertificate.Builder()
-        .signedBy(intermediateCa)
-        .serialNumber(4L)
-        .build();
-
-    CertificateChainCleaner cleaner = CertificateChainCleaner.Companion.get(trusted.certificate());
-    assertThat(cleaner.clean(list(certificate, intermediateCa), "hostname")).isEqualTo(
-        list(certificate, intermediateCa, trusted));
-    assertThat(cleaner.clean(list(certificate, intermediateCa, trusted), "hostname")).isEqualTo(
-        list(certificate, intermediateCa, trusted));
-  }
-
-  @Test public void chainMaxLength() throws Exception {
-    List<HeldCertificate> heldCertificates = chainOfLength(10);
-    List<Certificate> certificates = new ArrayList<>();
-    for (HeldCertificate heldCertificate : heldCertificates) {
-      certificates.add(heldCertificate.certificate());
-    }
-
-    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate();
-    CertificateChainCleaner cleaner = CertificateChainCleaner.Companion.get(root);
-    assertThat(cleaner.clean(certificates, "hostname")).isEqualTo(certificates);
-    assertThat(cleaner.clean(certificates.subList(0, 9), "hostname")).isEqualTo(
-        certificates);
-  }
-
-  @Test public void chainTooLong() {
-    List<HeldCertificate> heldCertificates = chainOfLength(11);
-    List<Certificate> certificates = new ArrayList<>();
-    for (HeldCertificate heldCertificate : heldCertificates) {
-      certificates.add(heldCertificate.certificate());
-    }
-
-    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate();
-    CertificateChainCleaner cleaner = CertificateChainCleaner.Companion.get(root);
-    try {
-      cleaner.clean(certificates, "hostname");
-      fail();
-    } catch (SSLPeerUnverifiedException expected) {
-    }
-  }
-
-  /** Returns a chain starting at the leaf certificate and progressing to the root. */
-  private List<HeldCertificate> chainOfLength(int length) {
-    List<HeldCertificate> result = new ArrayList<>();
-    for (int i = 1; i <= length; i++) {
-      result.add(0, new HeldCertificate.Builder()
-          .signedBy(!result.isEmpty() ? result.get(0) : null)
-          .serialNumber(i)
-          .build());
-    }
-    return result;
-  }
-
-  private List<Certificate> list(HeldCertificate... heldCertificates) {
-    List<Certificate> result = new ArrayList<>();
-    for (HeldCertificate heldCertificate : heldCertificates) {
-      result.add(heldCertificate.certificate());
-    }
-    return result;
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/CertificatePinnerKotlinTest.kt b/okhttp/src/test/java/okhttp3/CertificatePinnerKotlinTest.kt
deleted file mode 100644
index 8de9cea1de..0000000000
--- a/okhttp/src/test/java/okhttp3/CertificatePinnerKotlinTest.kt
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3
-
-import okhttp3.CertificatePinner.Companion.newPin
-import okhttp3.CertificatePinner.Companion.toSha1ByteString
-import okhttp3.tls.HeldCertificate
-import org.assertj.core.api.Assertions.assertThat
-import org.junit.Test
-
-class CertificatePinnerKotlinTest {
-
-  @Test
-  fun successfulCheckSha1Pin() {
-    val certificatePinner = CertificatePinner.Builder()
-        .add("example.com", "sha1/" + certA1.certificate.toSha1ByteString().base64())
-        .build()
-
-    certificatePinner.check("example.com", listOf(certA1.certificate))
-  }
-
-  @Test fun successfulFindMatchingPins() {
-    val certificatePinner = CertificatePinner.Builder()
-        .add("first.com", certA1Sha256Pin, certB1Sha256Pin)
-        .add("second.com", certC1Sha256Pin)
-        .build()
-
-    val expectedPins = listOf(
-        newPin("first.com", certA1Sha256Pin),
-        newPin("first.com", certB1Sha256Pin))
-    assertThat(certificatePinner.findMatchingPins("first.com")).isEqualTo(expectedPins)
-  }
-
-  @Test fun successfulFindMatchingPinsForWildcardAndDirectCertificates() {
-    val certificatePinner = CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin)
-        .add("a.example.com", certB1Sha256Pin)
-        .add("b.example.com", certC1Sha256Pin)
-        .build()
-
-    val expectedPins = listOf(
-        newPin("*.example.com", certA1Sha256Pin),
-        newPin("a.example.com", certB1Sha256Pin))
-    assertThat(certificatePinner.findMatchingPins("a.example.com")).isEqualTo(expectedPins)
-  }
-
-  @Test
-  fun wildcardHostnameShouldNotMatchThroughDot() {
-    val certificatePinner = CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin)
-        .build()
-
-    assertThat(certificatePinner.findMatchingPins("example.com")).isEmpty()
-    assertThat(certificatePinner.findMatchingPins("a.b.example.com")).isEmpty()
-  }
-
-  @Test fun successfulFindMatchingPinsIgnoresCase() {
-    val certificatePinner = CertificatePinner.Builder()
-        .add("EXAMPLE.com", certA1Sha256Pin)
-        .add("*.MyExample.Com", certB1Sha256Pin)
-        .build()
-
-    val expectedPin1 = listOf(newPin("EXAMPLE.com", certA1Sha256Pin))
-    assertThat(certificatePinner.findMatchingPins("example.com")).isEqualTo(expectedPin1)
-
-    val expectedPin2 = listOf(newPin("*.MyExample.Com", certB1Sha256Pin))
-    assertThat(certificatePinner.findMatchingPins("a.myexample.com")).isEqualTo(expectedPin2)
-  }
-
-  @Test fun successfulFindMatchingPinPunycode() {
-    val certificatePinner = CertificatePinner.Builder()
-        .add("khttp.com", certA1Sha256Pin)
-        .build()
-
-    val expectedPin = listOf(newPin("khttp.com", certA1Sha256Pin))
-    assertThat(certificatePinner.findMatchingPins("xn--khttp-fde.com")).isEqualTo(expectedPin)
-  }
-
-  /** https://github.com/square/okhttp/issues/3324  */
-  @Test
-  fun checkSubstringMatch() {
-    val certificatePinner = CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin)
-        .build()
-
-    assertThat(certificatePinner.findMatchingPins("a.example.com.notexample.com")).isEmpty()
-    assertThat(certificatePinner.findMatchingPins("example.com.notexample.com")).isEmpty()
-    assertThat(certificatePinner.findMatchingPins("notexample.com")).isEmpty()
-    assertThat(certificatePinner.findMatchingPins("example.com")).isEmpty()
-    assertThat(certificatePinner.findMatchingPins("a.b.example.com")).isEmpty()
-    assertThat(certificatePinner.findMatchingPins("ple.com")).isEmpty()
-    assertThat(certificatePinner.findMatchingPins("com")).isEmpty()
-
-    val expectedPin = newPin("*.example.com", certA1Sha256Pin)
-    assertThat(certificatePinner.findMatchingPins("a.example.com")).containsExactly(expectedPin)
-    assertThat(certificatePinner.findMatchingPins("example.example.com"))
-        .containsExactly(expectedPin)
-  }
-
-  companion object {
-    internal var certA1: HeldCertificate = HeldCertificate.Builder()
-        .serialNumber(100L)
-        .build()
-    internal var certA1Sha256Pin = CertificatePinner.pin(certA1.certificate)
-
-    private var certB1 = HeldCertificate.Builder()
-        .serialNumber(200L)
-        .build()
-    internal var certB1Sha256Pin = CertificatePinner.pin(certB1.certificate)
-
-    private var certC1 = HeldCertificate.Builder()
-        .serialNumber(300L)
-        .build()
-    internal var certC1Sha256Pin = CertificatePinner.pin(certC1.certificate)
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/CertificatePinnerTest.java b/okhttp/src/test/java/okhttp3/CertificatePinnerTest.java
deleted file mode 100644
index 77dacfe9bb..0000000000
--- a/okhttp/src/test/java/okhttp3/CertificatePinnerTest.java
+++ /dev/null
@@ -1,192 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import javax.net.ssl.SSLPeerUnverifiedException;
-import okhttp3.tls.HeldCertificate;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class CertificatePinnerTest {
-  static HeldCertificate certA1 = new HeldCertificate.Builder()
-      .serialNumber(100L)
-      .build();
-  static String certA1Sha256Pin = CertificatePinner.pin(certA1.certificate());
-
-  static HeldCertificate certB1 = new HeldCertificate.Builder()
-      .serialNumber(200L)
-      .build();
-  static String certB1Sha256Pin = CertificatePinner.pin(certB1.certificate());
-
-  static HeldCertificate certC1 = new HeldCertificate.Builder()
-      .serialNumber(300L)
-      .build();
-  static String certC1Sha256Pin = CertificatePinner.pin(certC1.certificate());
-
-  @Test public void malformedPin() throws Exception {
-    CertificatePinner.Builder builder = new CertificatePinner.Builder();
-    try {
-      builder.add("example.com", "md5/DmxUShsZuNiqPQsX2Oi9uv2sCnw=");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void malformedBase64() throws Exception {
-    CertificatePinner.Builder builder = new CertificatePinner.Builder();
-    try {
-      builder.add("example.com", "sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw*");
-      fail();
-    } catch (NullPointerException expected) {
-    }
-  }
-
-  /** Multiple certificates generated from the same keypair have the same pin. */
-  @Test public void sameKeypairSamePin() throws Exception {
-    HeldCertificate heldCertificateA2 = new HeldCertificate.Builder()
-        .keyPair(certA1.keyPair())
-        .serialNumber(101L)
-        .build();
-    String keypairACertificate2Pin = CertificatePinner.pin(heldCertificateA2.certificate());
-
-    HeldCertificate heldCertificateB2 = new HeldCertificate.Builder()
-        .keyPair(certB1.keyPair())
-        .serialNumber(201L)
-        .build();
-    String keypairBCertificate2Pin = CertificatePinner.pin(heldCertificateB2.certificate());
-
-    assertThat(keypairACertificate2Pin).isEqualTo(certA1Sha256Pin);
-    assertThat(keypairBCertificate2Pin).isEqualTo(certB1Sha256Pin);
-    assertThat(certB1Sha256Pin).isNotEqualTo(certA1Sha256Pin);
-  }
-
-  @Test public void successfulCheck() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certA1Sha256Pin)
-        .build();
-
-    certificatePinner.check("example.com", certA1.certificate());
-  }
-
-  @Test public void successfulMatchAcceptsAnyMatchingCertificate() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certB1Sha256Pin)
-        .build();
-
-    certificatePinner.check("example.com", certA1.certificate(), certB1.certificate());
-  }
-
-  @Test public void unsuccessfulCheck() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certA1Sha256Pin)
-        .build();
-
-    try {
-      certificatePinner.check("example.com", certB1.certificate());
-      fail();
-    } catch (SSLPeerUnverifiedException expected) {
-    }
-  }
-
-  @Test public void multipleCertificatesForOneHostname() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certA1Sha256Pin, certB1Sha256Pin)
-        .build();
-
-    certificatePinner.check("example.com", certA1.certificate());
-    certificatePinner.check("example.com", certB1.certificate());
-  }
-
-  @Test public void multipleHostnamesForOneCertificate() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", certA1Sha256Pin)
-        .add("www.example.com", certA1Sha256Pin)
-        .build();
-
-    certificatePinner.check("example.com", certA1.certificate());
-    certificatePinner.check("www.example.com", certA1.certificate());
-  }
-
-  @Test public void absentHostnameMatches() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder().build();
-    certificatePinner.check("example.com", certA1.certificate());
-  }
-
-  @Test public void successfulCheckForWildcardHostname() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin)
-        .build();
-
-    certificatePinner.check("a.example.com", certA1.certificate());
-  }
-
-  @Test public void successfulMatchAcceptsAnyMatchingCertificateForWildcardHostname()
-      throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certB1Sha256Pin)
-        .build();
-
-    certificatePinner.check("a.example.com", certA1.certificate(), certB1.certificate());
-  }
-
-  @Test public void unsuccessfulCheckForWildcardHostname() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin)
-        .build();
-
-    try {
-      certificatePinner.check("a.example.com", certB1.certificate());
-      fail();
-    } catch (SSLPeerUnverifiedException expected) {
-    }
-  }
-
-  @Test public void multipleCertificatesForOneWildcardHostname() throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin, certB1Sha256Pin)
-        .build();
-
-    certificatePinner.check("a.example.com", certA1.certificate());
-    certificatePinner.check("a.example.com", certB1.certificate());
-  }
-
-  @Test public void successfulCheckForOneHostnameWithWildcardAndDirectCertificate()
-      throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin)
-        .add("a.example.com", certB1Sha256Pin)
-        .build();
-
-    certificatePinner.check("a.example.com", certA1.certificate());
-    certificatePinner.check("a.example.com", certB1.certificate());
-  }
-
-  @Test public void unsuccessfulCheckForOneHostnameWithWildcardAndDirectCertificate()
-      throws Exception {
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("*.example.com", certA1Sha256Pin)
-        .add("a.example.com", certB1Sha256Pin)
-        .build();
-
-    try {
-      certificatePinner.check("a.example.com", certC1.certificate());
-      fail();
-    } catch (SSLPeerUnverifiedException expected) {
-    }
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/CipherSuiteTest.java b/okhttp/src/test/java/okhttp3/CipherSuiteTest.java
deleted file mode 100644
index d70d7d4b17..0000000000
--- a/okhttp/src/test/java/okhttp3/CipherSuiteTest.java
+++ /dev/null
@@ -1,222 +0,0 @@
-/*
- * Copyright (C) 2016 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import org.junit.Test;
-
-import static okhttp3.CipherSuite.TLS_KRB5_WITH_DES_CBC_MD5;
-import static okhttp3.CipherSuite.TLS_RSA_EXPORT_WITH_RC4_40_MD5;
-import static okhttp3.CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA256;
-import static okhttp3.CipherSuite.forJavaName;
-import static okhttp3.internal.Internal.applyConnectionSpec;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.fail;
-
-public class CipherSuiteTest {
-  @Test public void nullCipherName() {
-    try {
-      forJavaName(null);
-      fail("Should have thrown");
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void hashCode_usesIdentityHashCode_legacyCase() {
-    CipherSuite cs = TLS_RSA_EXPORT_WITH_RC4_40_MD5; // This one's javaName starts with "SSL_".
-    assertThat(cs.hashCode()).overridingErrorMessage(cs.toString()).isEqualTo(
-        System.identityHashCode(cs));
-  }
-
-  @Test public void hashCode_usesIdentityHashCode_regularCase() {
-    CipherSuite cs = TLS_RSA_WITH_AES_128_CBC_SHA256; // This one's javaName matches the identifier.
-    assertThat(cs.hashCode()).overridingErrorMessage(cs.toString()).isEqualTo(
-        System.identityHashCode(cs));
-  }
-
-  @Test public void instancesAreInterned() {
-    assertThat(forJavaName("TestCipherSuite")).isSameAs(forJavaName("TestCipherSuite"));
-    assertThat(forJavaName(TLS_KRB5_WITH_DES_CBC_MD5.javaName()))
-        .isSameAs(TLS_KRB5_WITH_DES_CBC_MD5);
-  }
-
-  /**
-   * Tests that interned CipherSuite instances remain the case across garbage collections, even if
-   * the String used to construct them is no longer strongly referenced outside of the CipherSuite.
-   */
-  @SuppressWarnings("RedundantStringConstructorCall")
-  @Test public void instancesAreInterned_survivesGarbageCollection() {
-    // We're not holding onto a reference to this String instance outside of the CipherSuite...
-    CipherSuite cs = forJavaName(new String("FakeCipherSuite_instancesAreInterned"));
-    System.gc(); // Unless cs references the String instance, it may now be garbage collected.
-    assertThat(forJavaName(new String(cs.javaName()))).isSameAs(cs);
-  }
-
-  @Test public void equals() {
-    assertThat(forJavaName("cipher")).isEqualTo(forJavaName("cipher"));
-    assertThat(forJavaName("cipherB")).isNotEqualTo(forJavaName("cipherA"));
-    assertThat(TLS_RSA_EXPORT_WITH_RC4_40_MD5).isEqualTo(
-        forJavaName("SSL_RSA_EXPORT_WITH_RC4_40_MD5"));
-    assertThat(TLS_RSA_WITH_AES_128_CBC_SHA256).isNotEqualTo(
-        TLS_RSA_EXPORT_WITH_RC4_40_MD5);
-  }
-
-  @Test public void forJavaName_acceptsArbitraryStrings() {
-    // Shouldn't throw.
-    forJavaName("example CipherSuite name that is not in the whitelist");
-  }
-
-  @Test public void javaName_examples() {
-    assertThat(TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName()).isEqualTo(
-        "SSL_RSA_EXPORT_WITH_RC4_40_MD5");
-    assertThat(TLS_RSA_WITH_AES_128_CBC_SHA256.javaName()).isEqualTo(
-        "TLS_RSA_WITH_AES_128_CBC_SHA256");
-    assertThat(forJavaName("TestCipherSuite").javaName()).isEqualTo("TestCipherSuite");
-  }
-
-  @Test public void javaName_equalsToString() {
-    assertThat(TLS_RSA_EXPORT_WITH_RC4_40_MD5.toString()).isEqualTo(
-        TLS_RSA_EXPORT_WITH_RC4_40_MD5.javaName());
-    assertThat(TLS_RSA_WITH_AES_128_CBC_SHA256.toString()).isEqualTo(
-        TLS_RSA_WITH_AES_128_CBC_SHA256.javaName());
-  }
-
-  /**
-   * On the Oracle JVM some older cipher suites have the "SSL_" prefix and others have the "TLS_"
-   * prefix. On the IBM JVM all cipher suites have the "SSL_" prefix.
-   *
-   * <p>Prior to OkHttp 3.3.1 we accepted either form and consider them equivalent. And since OkHttp
-   * 3.7.0 this is also true. But OkHttp 3.3.1 through 3.6.0 treated these as different.
-   */
-  @Test public void forJavaName_fromLegacyEnumName() {
-    // These would have been considered equal in OkHttp 3.3.1, but now aren't.
-    assertThat(forJavaName("SSL_RSA_EXPORT_WITH_RC4_40_MD5")).isEqualTo(
-        forJavaName("TLS_RSA_EXPORT_WITH_RC4_40_MD5"));
-    assertThat(forJavaName("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA")).isEqualTo(
-        forJavaName("TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"));
-    assertThat(forJavaName("SSL_FAKE_NEW_CIPHER")).isEqualTo(
-        forJavaName("TLS_FAKE_NEW_CIPHER"));
-  }
-
-  @Test public void applyIntersectionRetainsSslPrefixes() throws Exception {
-    FakeSslSocket socket = new FakeSslSocket();
-    socket.setEnabledProtocols(new String[] { "TLSv1" });
-    socket.setSupportedCipherSuites(new String[] { "SSL_A", "SSL_B", "SSL_C", "SSL_D", "SSL_E" });
-    socket.setEnabledCipherSuites(new String[] { "SSL_A", "SSL_B", "SSL_C" });
-
-    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
-        .tlsVersions(TlsVersion.TLS_1_0)
-        .cipherSuites("TLS_A", "TLS_C", "TLS_E")
-        .build();
-    applyConnectionSpec(connectionSpec, socket, false);
-
-    assertArrayEquals(new String[] { "SSL_A", "SSL_C" }, socket.enabledCipherSuites);
-  }
-
-  @Test public void applyIntersectionRetainsTlsPrefixes() throws Exception {
-    FakeSslSocket socket = new FakeSslSocket();
-    socket.setEnabledProtocols(new String[] { "TLSv1" });
-    socket.setSupportedCipherSuites(new String[] { "TLS_A", "TLS_B", "TLS_C", "TLS_D", "TLS_E" });
-    socket.setEnabledCipherSuites(new String[] { "TLS_A", "TLS_B", "TLS_C" });
-
-    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
-        .tlsVersions(TlsVersion.TLS_1_0)
-        .cipherSuites("SSL_A", "SSL_C", "SSL_E")
-        .build();
-    applyConnectionSpec(connectionSpec, socket, false);
-
-    assertArrayEquals(new String[] { "TLS_A", "TLS_C" }, socket.enabledCipherSuites);
-  }
-
-  @Test public void applyIntersectionAddsSslScsvForFallback() throws Exception {
-    FakeSslSocket socket = new FakeSslSocket();
-    socket.setEnabledProtocols(new String[] { "TLSv1" });
-    socket.setSupportedCipherSuites(new String[] { "SSL_A", "SSL_FALLBACK_SCSV" });
-    socket.setEnabledCipherSuites(new String[] { "SSL_A" });
-
-    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
-        .tlsVersions(TlsVersion.TLS_1_0)
-        .cipherSuites("SSL_A")
-        .build();
-    applyConnectionSpec(connectionSpec, socket, true);
-
-    assertArrayEquals(new String[] { "SSL_A", "SSL_FALLBACK_SCSV" }, socket.enabledCipherSuites);
-  }
-
-  @Test public void applyIntersectionAddsTlsScsvForFallback() throws Exception {
-    FakeSslSocket socket = new FakeSslSocket();
-    socket.setEnabledProtocols(new String[] { "TLSv1" });
-    socket.setSupportedCipherSuites(new String[] { "TLS_A", "TLS_FALLBACK_SCSV" });
-    socket.setEnabledCipherSuites(new String[] { "TLS_A" });
-
-    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
-        .tlsVersions(TlsVersion.TLS_1_0)
-        .cipherSuites("TLS_A")
-        .build();
-    applyConnectionSpec(connectionSpec, socket, true);
-
-    assertArrayEquals(new String[] { "TLS_A", "TLS_FALLBACK_SCSV" }, socket.enabledCipherSuites);
-  }
-
-  @Test public void applyIntersectionToProtocolVersion() throws Exception {
-    FakeSslSocket socket = new FakeSslSocket();
-    socket.setEnabledProtocols(new String[] { "TLSv1", "TLSv1.1", "TLSv1.2" });
-    socket.setSupportedCipherSuites(new String[] { "TLS_A" });
-    socket.setEnabledCipherSuites(new String[] { "TLS_A" });
-
-    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
-        .tlsVersions(TlsVersion.TLS_1_1, TlsVersion.TLS_1_2, TlsVersion.TLS_1_3)
-        .cipherSuites("TLS_A")
-        .build();
-    applyConnectionSpec(connectionSpec, socket, false);
-
-    assertArrayEquals(new String[] { "TLSv1.1", "TLSv1.2" }, socket.enabledProtocols);
-  }
-
-  static final class FakeSslSocket extends DelegatingSSLSocket {
-    private String[] enabledProtocols;
-    private String[] supportedCipherSuites;
-    private String[] enabledCipherSuites;
-
-    FakeSslSocket() {
-      super(null);
-    }
-
-    @Override public String[] getEnabledProtocols() {
-      return enabledProtocols;
-    }
-
-    @Override public void setEnabledProtocols(String[] enabledProtocols) {
-      this.enabledProtocols = enabledProtocols;
-    }
-
-    @Override public String[] getSupportedCipherSuites() {
-      return supportedCipherSuites;
-    }
-
-    public void setSupportedCipherSuites(String[] supportedCipherSuites) {
-      this.supportedCipherSuites = supportedCipherSuites;
-    }
-
-    @Override public String[] getEnabledCipherSuites() {
-      return enabledCipherSuites;
-    }
-
-    @Override public void setEnabledCipherSuites(String[] enabledCipherSuites) {
-      this.enabledCipherSuites = enabledCipherSuites;
-    }
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/ConnectionCoalescingTest.java b/okhttp/src/test/java/okhttp3/ConnectionCoalescingTest.java
deleted file mode 100644
index 0895bbe11c..0000000000
--- a/okhttp/src/test/java/okhttp3/ConnectionCoalescingTest.java
+++ /dev/null
@@ -1,416 +0,0 @@
-/*
- * Copyright (C) 2017 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.util.Collections;
-import java.util.List;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.concurrent.atomic.AtomicReference;
-import javax.net.ssl.HostnameVerifier;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.testing.PlatformRule;
-import okhttp3.tls.HandshakeCertificates;
-import okhttp3.tls.HeldCertificate;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static java.util.Arrays.asList;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class ConnectionCoalescingTest {
-  @Rule public final PlatformRule platform = new PlatformRule();
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  private OkHttpClient client;
-
-  private HeldCertificate rootCa;
-  private HeldCertificate certificate;
-  private FakeDns dns = new FakeDns();
-  private HttpUrl url;
-  private List<InetAddress> serverIps;
-
-  @Before public void setUp() throws Exception {
-    platform.assumeHttp2Support();
-
-    rootCa = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .certificateAuthority(0)
-        .commonName("root")
-        .build();
-    certificate = new HeldCertificate.Builder()
-        .signedBy(rootCa)
-        .serialNumber(2L)
-        .commonName(server.getHostName())
-        .addSubjectAlternativeName(server.getHostName())
-        .addSubjectAlternativeName("san.com")
-        .addSubjectAlternativeName("*.wildcard.com")
-        .addSubjectAlternativeName("differentdns.com")
-        .build();
-
-    serverIps = Dns.SYSTEM.lookup(server.getHostName());
-
-    dns.set(server.getHostName(), serverIps);
-    dns.set("san.com", serverIps);
-    dns.set("nonsan.com", serverIps);
-    dns.set("www.wildcard.com", serverIps);
-    dns.set("differentdns.com", Collections.emptyList());
-
-    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
-        .addTrustedCertificate(rootCa.certificate())
-        .build();
-
-    client = clientTestRule.newClientBuilder()
-        .dns(dns)
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .build();
-
-    HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
-        .heldCertificate(certificate)
-        .build();
-    server.useHttps(serverHandshakeCertificates.sslSocketFactory(), false);
-
-    url = server.url("/robots.txt");
-  }
-
-  /**
-   * Test connecting to the main host then an alternative, although only subject alternative names
-   * are used if present no special consideration of common name.
-   */
-  @Test public void commonThenAlternative() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(200));
-    server.enqueue(new MockResponse().setResponseCode(200));
-
-    assert200Http2Response(execute(url), server.getHostName());
-
-    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
-    assert200Http2Response(execute(sanUrl), "san.com");
-
-    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
-  }
-
-  /**
-   * Test connecting to an alternative host then common name, although only subject alternative
-   * names are used if present no special consideration of common name.
-   */
-  @Test public void alternativeThenCommon() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(200));
-    server.enqueue(new MockResponse().setResponseCode(200));
-
-    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
-    assert200Http2Response(execute(sanUrl), "san.com");
-
-    assert200Http2Response(execute(url), server.getHostName());
-
-    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
-  }
-
-  /** Test a previously coalesced connection that's no longer healthy. */
-  @Test public void staleCoalescedConnection() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(200));
-    server.enqueue(new MockResponse().setResponseCode(200));
-
-    AtomicReference<Connection> connection = new AtomicReference<>();
-    client = client.newBuilder()
-        .addNetworkInterceptor(chain -> {
-          connection.set(chain.connection());
-          return chain.proceed(chain.request());
-        })
-        .build();
-    dns.set("san.com", Dns.SYSTEM.lookup(server.getHostName()).subList(0, 1));
-
-    assert200Http2Response(execute(url), server.getHostName());
-
-    // Simulate a stale connection in the pool.
-    connection.get().socket().close();
-
-    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
-    assert200Http2Response(execute(sanUrl), "san.com");
-
-    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
-  }
-
-  /**
-   * This is an extraordinary test case. Here's what it's trying to simulate.
-   * - 2 requests happen concurrently to a host that can be coalesced onto a single connection.
-   * - Both request discover no existing connection. They both make a connection.
-   * - The first request "wins the race".
-   * - The second request discovers it "lost the race" and closes the connection it just opened.
-   * - The second request uses the coalesced connection from request1.
-   * - The coalesced connection is violently closed after servicing the first request.
-   * - The second request discovers the coalesced connection is unhealthy just after acquiring it.
-   */
-  @Test public void coalescedConnectionDestroyedAfterAcquire() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(200));
-    server.enqueue(new MockResponse().setResponseCode(200));
-
-    dns.set("san.com", Dns.SYSTEM.lookup(server.getHostName()).subList(0, 1));
-    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
-
-    CountDownLatch latch1 = new CountDownLatch(1);
-    CountDownLatch latch2 = new CountDownLatch(1);
-    CountDownLatch latch3 = new CountDownLatch(1);
-    CountDownLatch latch4 = new CountDownLatch(1);
-    EventListener listener1 = new EventListener() {
-      @Override public void connectStart(Call call, InetSocketAddress inetSocketAddress,
-          Proxy proxy) {
-        try {
-          // Wait for request2 to guarantee we make 2 separate connections to the server.
-          latch1.await();
-        } catch (InterruptedException e) {
-          throw new AssertionError(e);
-        }
-      }
-
-      @Override public void connectionAcquired(Call call, Connection connection) {
-        // We have the connection and it's in the pool. Let request2 proceed to make a connection.
-        latch2.countDown();
-      }
-    };
-
-    EventListener request2Listener = new EventListener() {
-      @Override public void connectStart(Call call, InetSocketAddress inetSocketAddress,
-          Proxy proxy) {
-        // Let request1 proceed to make a connection.
-        latch1.countDown();
-        try {
-          // Wait until request1 makes the connection and puts it in the connection pool.
-          latch2.await();
-        } catch (InterruptedException e) {
-          throw new AssertionError(e);
-        }
-      }
-
-      @Override public void connectionAcquired(Call call, Connection connection) {
-        // We obtained the coalesced connection. Let request1 violently destroy it.
-        latch3.countDown();
-        try {
-          latch4.await();
-        } catch (InterruptedException e) {
-          throw new AssertionError(e);
-        }
-      }
-    };
-
-    // Get a reference to the connection so we can violently destroy it.
-    AtomicReference<Connection> connection = new AtomicReference<>();
-    OkHttpClient client1 = client.newBuilder()
-        .addNetworkInterceptor(chain -> {
-          connection.set(chain.connection());
-          return chain.proceed(chain.request());
-        })
-        .eventListener(listener1)
-        .build();
-
-    Request request = new Request.Builder().url(sanUrl).build();
-    Call call1 = client1.newCall(request);
-    call1.enqueue(new Callback() {
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        try {
-          // Wait until request2 acquires the connection before we destroy it violently.
-          latch3.await();
-        } catch (InterruptedException e) {
-          throw new AssertionError(e);
-        }
-        assert200Http2Response(response, "san.com");
-        connection.get().socket().close();
-        latch4.countDown();
-      }
-
-      @Override public void onFailure(Call call, IOException e) {
-        fail();
-      }
-    });
-
-    OkHttpClient client2 = client.newBuilder()
-        .eventListener(request2Listener)
-        .build();
-    Call call2 = client2.newCall(request);
-    Response response = call2.execute();
-
-    assert200Http2Response(response, "san.com");
-  }
-
-  /** If the existing connection matches a SAN but not a match for DNS then skip. */
-  @Test public void skipsWhenDnsDontMatch() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(200));
-
-    assert200Http2Response(execute(url), server.getHostName());
-
-    HttpUrl differentDnsUrl = url.newBuilder().host("differentdns.com").build();
-    try {
-      execute(differentDnsUrl);
-      fail("expected a failed attempt to connect");
-    } catch (IOException expected) {
-    }
-  }
-
-  /** Not in the certificate SAN. */
-  @Test public void skipsWhenNotSubjectAltName() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(200));
-
-    assert200Http2Response(execute(url), server.getHostName());
-
-    HttpUrl nonsanUrl = url.newBuilder().host("nonsan.com").build();
-
-    try {
-      execute(nonsanUrl);
-      fail("expected a failed attempt to connect");
-    } catch (IOException expected) {
-    }
-  }
-
-  /** Can still coalesce when pinning is used if pins match. */
-  @Test public void coalescesWhenCertificatePinsMatch() throws Exception {
-    CertificatePinner pinner = new CertificatePinner.Builder()
-        .add("san.com", CertificatePinner.pin(certificate.certificate()))
-        .build();
-    client = client.newBuilder().certificatePinner(pinner).build();
-
-    server.enqueue(new MockResponse().setResponseCode(200));
-    server.enqueue(new MockResponse().setResponseCode(200));
-
-    assert200Http2Response(execute(url), server.getHostName());
-
-    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
-
-    assert200Http2Response(execute(sanUrl), "san.com");
-
-    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
-  }
-
-  /** Certificate pinning used and not a match will avoid coalescing and try to connect. */
-  @Test public void skipsWhenCertificatePinningFails() throws Exception {
-    CertificatePinner pinner = new CertificatePinner.Builder()
-        .add("san.com", "sha1/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
-        .build();
-    client = client.newBuilder().certificatePinner(pinner).build();
-
-    server.enqueue(new MockResponse().setResponseCode(200));
-
-    assert200Http2Response(execute(url), server.getHostName());
-
-    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
-
-    try {
-      execute(sanUrl);
-      fail("expected a failed attempt to connect");
-    } catch (IOException expected) {
-    }
-  }
-
-  /**
-   * Skips coalescing when hostname verifier is overridden since the intention of the hostname
-   * verification is a black box.
-   */
-  @Test public void skipsWhenHostnameVerifierUsed() throws Exception {
-    HostnameVerifier verifier = (name, session) -> true;
-    client = client.newBuilder().hostnameVerifier(verifier).build();
-
-    server.enqueue(new MockResponse().setResponseCode(200));
-    server.enqueue(new MockResponse().setResponseCode(200));
-
-    assert200Http2Response(execute(url), server.getHostName());
-
-    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
-
-    assert200Http2Response(execute(sanUrl), "san.com");
-
-    assertThat(client.connectionPool().connectionCount()).isEqualTo(2);
-  }
-
-  /**
-   * Check we would use an existing connection to a later DNS result instead of connecting to the
-   * first DNS result for the first time.
-   */
-  @Test public void prefersExistingCompatible() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(200));
-    server.enqueue(new MockResponse().setResponseCode(200));
-
-    AtomicInteger connectCount = new AtomicInteger();
-    EventListener listener = new EventListener() {
-      @Override public void connectStart(
-          Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
-        connectCount.getAndIncrement();
-      }
-    };
-    client = client.newBuilder()
-        .eventListener(listener)
-        .build();
-
-    assert200Http2Response(execute(url), server.getHostName());
-
-    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
-    dns.set("san.com",
-        asList(InetAddress.getByAddress("san.com", new byte[] {0, 0, 0, 0}),
-            serverIps.get(0)));
-    assert200Http2Response(execute(sanUrl), "san.com");
-
-    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
-    assertThat(connectCount.get()).isEqualTo(1);
-  }
-
-  /** Check that wildcard SANs are supported. */
-  @Test public void commonThenWildcard() throws Exception {
-
-    server.enqueue(new MockResponse().setResponseCode(200));
-    server.enqueue(new MockResponse().setResponseCode(200));
-
-    assert200Http2Response(execute(url), server.getHostName());
-
-    HttpUrl sanUrl = url.newBuilder().host("www.wildcard.com").build();
-    assert200Http2Response(execute(sanUrl), "www.wildcard.com");
-
-    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
-  }
-
-  /** Network interceptors check for changes to target. */
-  @Test public void worksWithNetworkInterceptors() throws Exception {
-    client = client.newBuilder()
-        .addNetworkInterceptor(chain -> chain.proceed(chain.request()))
-        .build();
-
-    server.enqueue(new MockResponse().setResponseCode(200));
-    server.enqueue(new MockResponse().setResponseCode(200));
-
-    assert200Http2Response(execute(url), server.getHostName());
-
-    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
-    assert200Http2Response(execute(sanUrl), "san.com");
-
-    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
-  }
-
-  private Response execute(HttpUrl url) throws IOException {
-    return client.newCall(new Request.Builder().url(url).build()).execute();
-  }
-
-  private void assert200Http2Response(Response response, String expectedHost) {
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.request().url().host()).isEqualTo(expectedHost);
-    assertThat(response.protocol()).isEqualTo(Protocol.HTTP_2);
-    response.body().close();
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/ConnectionReuseTest.java b/okhttp/src/test/java/okhttp3/ConnectionReuseTest.java
deleted file mode 100644
index ea1a635f9e..0000000000
--- a/okhttp/src/test/java/okhttp3/ConnectionReuseTest.java
+++ /dev/null
@@ -1,382 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import javax.net.ssl.SSLException;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.testing.PlatformRule;
-import okhttp3.tls.HandshakeCertificates;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TestRule;
-import org.junit.rules.Timeout;
-
-import static java.util.Arrays.asList;
-import static okhttp3.internal.Util.closeQuietly;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class ConnectionReuseTest {
-  @Rule public final PlatformRule platform = new PlatformRule();
-  @Rule public final TestRule timeout = new Timeout(30_000);
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  private HandshakeCertificates handshakeCertificates = localhost();
-  private OkHttpClient client = clientTestRule.newClient();
-
-  @Test public void connectionsAreReused() throws Exception {
-    server.enqueue(new MockResponse().setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    assertConnectionReused(request, request);
-  }
-
-  @Test public void connectionsAreReusedWithHttp2() throws Exception {
-    enableHttp2();
-    server.enqueue(new MockResponse().setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    assertConnectionReused(request, request);
-  }
-
-  @Test public void connectionsAreNotReusedWithRequestConnectionClose() throws Exception {
-    server.enqueue(new MockResponse().setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Request requestA = new Request.Builder()
-        .url(server.url("/"))
-        .header("Connection", "close")
-        .build();
-    Request requestB = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    assertConnectionNotReused(requestA, requestB);
-  }
-
-  @Test public void connectionsAreNotReusedWithResponseConnectionClose() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Connection", "close")
-        .setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Request requestA = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Request requestB = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    assertConnectionNotReused(requestA, requestB);
-  }
-
-  @Test public void connectionsAreNotReusedWithUnknownLengthResponseBody() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("a")
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    assertConnectionNotReused(request, request);
-  }
-
-  @Test public void connectionsAreNotReusedIfPoolIsSizeZero() throws Exception {
-    client = client.newBuilder()
-        .connectionPool(new ConnectionPool(0, 5, TimeUnit.SECONDS))
-        .build();
-    server.enqueue(new MockResponse().setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    assertConnectionNotReused(request, request);
-  }
-
-  @Test public void connectionsReusedWithRedirectEvenIfPoolIsSizeZero() throws Exception {
-    client = client.newBuilder()
-        .connectionPool(new ConnectionPool(0, 5, TimeUnit.SECONDS))
-        .build();
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Location: /b")
-        .setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("b");
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void connectionsNotReusedWithRedirectIfDiscardingResponseIsSlow() throws Exception {
-    client = client.newBuilder()
-        .connectionPool(new ConnectionPool(0, 5, TimeUnit.SECONDS))
-        .build();
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Location: /b")
-        .setBodyDelay(1, TimeUnit.SECONDS)
-        .setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("b");
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void silentRetryWhenIdempotentRequestFailsOnReusedConnection() throws Exception {
-    server.enqueue(new MockResponse().setBody("a"));
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_AFTER_REQUEST));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Response responseA = client.newCall(request).execute();
-    assertThat(responseA.body().string()).isEqualTo("a");
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-
-    Response responseB = client.newCall(request).execute();
-    assertThat(responseB.body().string()).isEqualTo("b");
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void staleConnectionNotReusedForNonIdempotentRequest() throws Exception {
-    server.enqueue(new MockResponse().setBody("a")
-        .setSocketPolicy(SocketPolicy.SHUTDOWN_OUTPUT_AT_END));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Request requestA = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response responseA = client.newCall(requestA).execute();
-    assertThat(responseA.body().string()).isEqualTo("a");
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-
-    // Give the socket a chance to become stale.
-    Thread.sleep(250);
-
-    Request requestB = new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create("b", MediaType.get("text/plain")))
-        .build();
-    Response responseB = client.newCall(requestB).execute();
-    assertThat(responseB.body().string()).isEqualTo("b");
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void http2ConnectionsAreSharedBeforeResponseIsConsumed() throws Exception {
-    enableHttp2();
-    server.enqueue(new MockResponse().setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Response response1 = client.newCall(request).execute();
-    Response response2 = client.newCall(request).execute();
-    response1.body().string(); // Discard the response body.
-    response2.body().string(); // Discard the response body.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void connectionsAreEvicted() throws Exception {
-    server.enqueue(new MockResponse().setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    client = client.newBuilder()
-        .connectionPool(new ConnectionPool(5, 250, TimeUnit.MILLISECONDS))
-        .build();
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Response response1 = client.newCall(request).execute();
-    assertThat(response1.body().string()).isEqualTo("a");
-
-    // Give the thread pool a chance to evict.
-    Thread.sleep(500);
-
-    Response response2 = client.newCall(request).execute();
-    assertThat(response2.body().string()).isEqualTo("b");
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void connectionsAreNotReusedIfSslSocketFactoryChanges() throws Exception {
-    enableHttps();
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Response response = client.newCall(request).execute();
-    response.body().close();
-
-    // This client shares a connection pool but has a different SSL socket factory.
-    HandshakeCertificates handshakeCertificates2 = new HandshakeCertificates.Builder().build();
-    OkHttpClient anotherClient = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates2.sslSocketFactory(), handshakeCertificates2.trustManager())
-        .build();
-
-    // This client fails to connect because the new SSL socket factory refuses.
-    try {
-      anotherClient.newCall(request).execute();
-      fail();
-    } catch (SSLException expected) {
-    }
-  }
-
-  @Test public void connectionsAreNotReusedIfHostnameVerifierChanges() throws Exception {
-    enableHttps();
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Response response1 = client.newCall(request).execute();
-    response1.body().close();
-
-    // This client shares a connection pool but has a different SSL socket factory.
-    OkHttpClient anotherClient = client.newBuilder()
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    Response response2 = anotherClient.newCall(request).execute();
-    response2.body().close();
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  /**
-   * Regression test for an edge case where closing response body in the HTTP engine doesn't release
-   * the corresponding stream allocation. This test keeps those response bodies alive and reads
-   * them after the redirect has completed. This forces a connection to not be reused where it would
-   * be otherwise.
-   *
-   * <p>This test leaks a response body by not closing it.
-   *
-   * https://github.com/square/okhttp/issues/2409
-   */
-  @Test public void connectionsAreNotReusedIfNetworkInterceptorInterferes() throws Exception {
-    List<Response> responsesNotClosed = new ArrayList<>();
-
-    client = client.newBuilder()
-        // Since this test knowingly leaks a connection, avoid using the default shared connection
-        // pool, which should remain clean for subsequent tests.
-        .connectionPool(new ConnectionPool())
-        .addNetworkInterceptor(chain -> {
-          Response response = chain.proceed(chain.request());
-          responsesNotClosed.add(response);
-          return response
-              .newBuilder()
-              .body(ResponseBody.create("unrelated response body!", null))
-              .build();
-        })
-        .build();
-
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Location: /b")
-        .setBody("/a has moved!"));
-    server.enqueue(new MockResponse()
-        .setBody("/b is here"));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Call call = client.newCall(request);
-    try (Response response = call.execute()) {
-      assertThat(response.body().string()).isEqualTo("unrelated response body!");
-    }
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    // No connection reuse.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-
-    for (Response response : responsesNotClosed) {
-      closeQuietly(response);
-    }
-  }
-
-  private void enableHttps() {
-    enableHttpsAndAlpn(Protocol.HTTP_1_1);
-  }
-
-  private void enableHttp2() {
-    platform.assumeHttp2Support();
-    enableHttpsAndAlpn(Protocol.HTTP_2, Protocol.HTTP_1_1);
-  }
-
-  private void enableHttpsAndAlpn(Protocol... protocols) {
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .protocols(asList(protocols))
-        .build();
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.setProtocols(client.protocols());
-  }
-
-  private void assertConnectionReused(Request... requests) throws Exception {
-    for (int i = 0; i < requests.length; i++) {
-      Response response = client.newCall(requests[i]).execute();
-      response.body().string(); // Discard the response body.
-      assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(i);
-    }
-  }
-
-  private void assertConnectionNotReused(Request... requests) throws Exception {
-    for (Request request : requests) {
-      Response response = client.newCall(request).execute();
-      response.body().string(); // Discard the response body.
-      assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    }
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/ConnectionSpecTest.java b/okhttp/src/test/java/okhttp3/ConnectionSpecTest.java
deleted file mode 100644
index 6663416032..0000000000
--- a/okhttp/src/test/java/okhttp3/ConnectionSpecTest.java
+++ /dev/null
@@ -1,319 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Set;
-import java.util.concurrent.CopyOnWriteArraySet;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.testing.PlatformRule;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static java.util.Arrays.asList;
-import static okhttp3.internal.Internal.applyConnectionSpec;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class ConnectionSpecTest {
-  @Rule public final PlatformRule platform = new PlatformRule();
-
-  @Test public void noTlsVersions() {
-    try {
-      new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-          .tlsVersions(new TlsVersion[0])
-          .build();
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo("At least one TLS version is required");
-    }
-  }
-
-  @Test public void noCipherSuites() {
-    try {
-      new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-          .cipherSuites(new CipherSuite[0])
-          .build();
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo("At least one cipher suite is required");
-    }
-  }
-
-  @Test public void cleartextBuilder() {
-    ConnectionSpec cleartextSpec = new ConnectionSpec.Builder(false).build();
-    assertThat(cleartextSpec.isTls()).isFalse();
-  }
-
-  @Test public void tlsBuilder_explicitCiphers() throws Exception {
-    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
-        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
-        .tlsVersions(TlsVersion.TLS_1_2)
-        .supportsTlsExtensions(true)
-        .build();
-    assertThat(tlsSpec.cipherSuites()).containsExactly(CipherSuite.TLS_RSA_WITH_RC4_128_MD5);
-    assertThat(tlsSpec.tlsVersions()).containsExactly(TlsVersion.TLS_1_2);
-    assertThat(tlsSpec.supportsTlsExtensions()).isTrue();
-  }
-
-  @Test public void tlsBuilder_defaultCiphers() throws Exception {
-    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
-        .tlsVersions(TlsVersion.TLS_1_2)
-        .supportsTlsExtensions(true)
-        .build();
-    assertThat(tlsSpec.cipherSuites()).isNull();
-    assertThat(tlsSpec.tlsVersions()).containsExactly(TlsVersion.TLS_1_2);
-    assertThat(tlsSpec.supportsTlsExtensions()).isTrue();
-  }
-
-  @Test public void tls_defaultCiphers_noFallbackIndicator() throws Exception {
-    platform.assumeNotConscrypt();
-
-    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
-        .tlsVersions(TlsVersion.TLS_1_2)
-        .supportsTlsExtensions(false)
-        .build();
-
-    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
-    socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName(),
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName(),
-    });
-    socket.setEnabledProtocols(new String[] {
-        TlsVersion.TLS_1_2.javaName(),
-        TlsVersion.TLS_1_1.javaName(),
-    });
-
-    assertThat(tlsSpec.isCompatible(socket)).isTrue();
-    applyConnectionSpec(tlsSpec, socket, false /* isFallback */);
-
-    assertThat(socket.getEnabledProtocols()).containsExactly(TlsVersion.TLS_1_2.javaName());
-
-    assertThat(socket.getEnabledCipherSuites()).containsExactlyInAnyOrder(
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName(),
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName());
-  }
-
-  @Test public void tls_defaultCiphers_withFallbackIndicator() throws Exception {
-    platform.assumeNotConscrypt();
-
-    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
-        .tlsVersions(TlsVersion.TLS_1_2)
-        .supportsTlsExtensions(false)
-        .build();
-
-    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
-    socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName(),
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName(),
-    });
-    socket.setEnabledProtocols(new String[] {
-        TlsVersion.TLS_1_2.javaName(),
-        TlsVersion.TLS_1_1.javaName(),
-    });
-
-    assertThat(tlsSpec.isCompatible(socket)).isTrue();
-    applyConnectionSpec(tlsSpec, socket, true /* isFallback */);
-
-    assertThat(socket.getEnabledProtocols()).containsExactly(TlsVersion.TLS_1_2.javaName());
-
-    List<String> expectedCipherSuites = new ArrayList<>();
-    expectedCipherSuites.add(CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName());
-    expectedCipherSuites.add(CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName());
-    if (asList(socket.getSupportedCipherSuites()).contains("TLS_FALLBACK_SCSV")) {
-      expectedCipherSuites.add("TLS_FALLBACK_SCSV");
-    }
-    assertThat(socket.getEnabledCipherSuites()).containsExactlyElementsOf(expectedCipherSuites);
-  }
-
-  @Test public void tls_explicitCiphers() throws Exception {
-    platform.assumeNotConscrypt();
-
-    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
-        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
-        .tlsVersions(TlsVersion.TLS_1_2)
-        .supportsTlsExtensions(false)
-        .build();
-
-    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
-    socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName(),
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName(),
-    });
-    socket.setEnabledProtocols(new String[] {
-        TlsVersion.TLS_1_2.javaName(),
-        TlsVersion.TLS_1_1.javaName(),
-    });
-
-    assertThat(tlsSpec.isCompatible(socket)).isTrue();
-    applyConnectionSpec(tlsSpec, socket, true /* isFallback */);
-
-    assertThat(socket.getEnabledProtocols()).containsExactly(TlsVersion.TLS_1_2.javaName());
-
-    List<String> expectedCipherSuites = new ArrayList<>();
-    expectedCipherSuites.add(CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName());
-    if (asList(socket.getSupportedCipherSuites()).contains("TLS_FALLBACK_SCSV")) {
-      expectedCipherSuites.add("TLS_FALLBACK_SCSV");
-    }
-    assertThat(socket.getEnabledCipherSuites()).containsExactlyElementsOf(expectedCipherSuites);
-  }
-
-  @Test public void tls_stringCiphersAndVersions() throws Exception {
-    // Supporting arbitrary input strings allows users to enable suites and versions that are not
-    // yet known to the library, but are supported by the platform.
-    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-        .cipherSuites("MAGIC-CIPHER")
-        .tlsVersions("TLS9k")
-        .build();
-  }
-
-  @Test public void tls_missingRequiredCipher() throws Exception {
-    platform.assumeNotConscrypt();
-
-    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
-        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
-        .tlsVersions(TlsVersion.TLS_1_2)
-        .supportsTlsExtensions(false)
-        .build();
-
-    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
-    socket.setEnabledProtocols(new String[] {
-        TlsVersion.TLS_1_2.javaName(),
-        TlsVersion.TLS_1_1.javaName(),
-    });
-
-    socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName(),
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName(),
-    });
-    assertThat(tlsSpec.isCompatible(socket)).isTrue();
-
-    socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName(),
-    });
-    assertThat(tlsSpec.isCompatible(socket)).isFalse();
-  }
-
-  @Test public void allEnabledCipherSuites() throws Exception {
-    platform.assumeNotConscrypt();
-
-    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-        .allEnabledCipherSuites()
-        .build();
-    assertThat(tlsSpec.cipherSuites()).isNull();
-
-    SSLSocket sslSocket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
-    sslSocket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName(),
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName(),
-    });
-
-    applyConnectionSpec(tlsSpec, sslSocket, false);
-    assertThat(sslSocket.getEnabledCipherSuites()).containsExactly(
-        CipherSuite.TLS_RSA_WITH_RC4_128_SHA.javaName(),
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName());
-  }
-
-  @Test public void allEnabledTlsVersions() throws Exception {
-    platform.assumeNotConscrypt();
-
-    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-        .allEnabledTlsVersions()
-        .build();
-    assertThat(tlsSpec.tlsVersions()).isNull();
-
-    SSLSocket sslSocket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
-    sslSocket.setEnabledProtocols(new String[] {
-        TlsVersion.SSL_3_0.javaName(),
-        TlsVersion.TLS_1_1.javaName()
-    });
-
-    applyConnectionSpec(tlsSpec, sslSocket, false);
-    assertThat(sslSocket.getEnabledProtocols()).containsExactly(
-        TlsVersion.SSL_3_0.javaName(), TlsVersion.TLS_1_1.javaName());
-  }
-
-  @Test public void tls_missingTlsVersion() throws Exception {
-    platform.assumeNotConscrypt();
-
-    ConnectionSpec tlsSpec = new ConnectionSpec.Builder(true)
-        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
-        .tlsVersions(TlsVersion.TLS_1_2)
-        .supportsTlsExtensions(false)
-        .build();
-
-    SSLSocket socket = (SSLSocket) SSLSocketFactory.getDefault().createSocket();
-    socket.setEnabledCipherSuites(new String[] {
-        CipherSuite.TLS_RSA_WITH_RC4_128_MD5.javaName(),
-    });
-
-    socket.setEnabledProtocols(
-        new String[] {TlsVersion.TLS_1_2.javaName(), TlsVersion.TLS_1_1.javaName()});
-    assertThat(tlsSpec.isCompatible(socket)).isTrue();
-
-    socket.setEnabledProtocols(new String[] {TlsVersion.TLS_1_1.javaName()});
-    assertThat(tlsSpec.isCompatible(socket)).isFalse();
-  }
-
-  @Test public void equalsAndHashCode() throws Exception {
-    ConnectionSpec allCipherSuites = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-        .allEnabledCipherSuites()
-        .build();
-    ConnectionSpec allTlsVersions = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-        .allEnabledTlsVersions()
-        .build();
-
-    Set<Object> set = new CopyOnWriteArraySet<>();
-    assertThat(set.add(ConnectionSpec.MODERN_TLS)).isTrue();
-    assertThat(set.add(ConnectionSpec.COMPATIBLE_TLS)).isTrue();
-    assertThat(set.add(ConnectionSpec.CLEARTEXT)).isTrue();
-    assertThat(set.add(allTlsVersions)).isTrue();
-    assertThat(set.add(allCipherSuites)).isTrue();
-    allCipherSuites.hashCode();
-    assertThat(allCipherSuites.equals(null)).isFalse();
-
-    assertThat(set.remove(ConnectionSpec.MODERN_TLS)).isTrue();
-    assertThat(set.remove(ConnectionSpec.COMPATIBLE_TLS)).isTrue();
-    assertThat(set.remove(ConnectionSpec.CLEARTEXT)).isTrue();
-    assertThat(set.remove(allTlsVersions)).isTrue();
-    assertThat(set.remove(allCipherSuites)).isTrue();
-    assertThat(set).isEmpty();
-    allTlsVersions.hashCode();
-    assertThat(allTlsVersions.equals(null)).isFalse();
-  }
-
-  @Test public void allEnabledToString() throws Exception {
-    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-        .allEnabledTlsVersions()
-        .allEnabledCipherSuites()
-        .build();
-    assertThat(connectionSpec.toString()).isEqualTo(
-        ("ConnectionSpec(cipherSuites=[all enabled], tlsVersions=[all enabled], "
-        + "supportsTlsExtensions=true)"));
-  }
-
-  @Test public void simpleToString() throws Exception {
-    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-        .tlsVersions(TlsVersion.TLS_1_2)
-        .cipherSuites(CipherSuite.TLS_RSA_WITH_RC4_128_MD5)
-        .build();
-    assertThat(connectionSpec.toString()).isEqualTo(
-        ("ConnectionSpec(cipherSuites=[SSL_RSA_WITH_RC4_128_MD5], tlsVersions=[TLS_1_2], "
-        + "supportsTlsExtensions=true)"));
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/ConscryptTest.kt b/okhttp/src/test/java/okhttp3/ConscryptTest.kt
deleted file mode 100644
index b2a53ef0b9..0000000000
--- a/okhttp/src/test/java/okhttp3/ConscryptTest.kt
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3
-
-import okhttp3.TestUtil.assumeNetwork
-import okhttp3.internal.platform.ConscryptPlatform
-import okhttp3.internal.platform.Platform
-import okhttp3.testing.PlatformRule
-import org.assertj.core.api.Assertions.assertThat
-import org.conscrypt.Conscrypt
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertTrue
-import org.junit.Before
-import org.junit.Ignore
-import org.junit.Rule
-import org.junit.Test
-
-class ConscryptTest {
-  @Suppress("RedundantVisibilityModifier")
-  @JvmField
-  @Rule public val platform = PlatformRule.conscrypt()
-
-  @JvmField @Rule val clientTestRule = OkHttpClientTestRule()
-
-  private val client = clientTestRule.newClient()
-
-  @Before fun setUp() {
-    platform.assumeConscrypt()
-  }
-
-  @Test
-  fun testTrustManager() {
-    assertThat(Conscrypt.isConscrypt(Platform.get().platformTrustManager())).isTrue()
-  }
-
-  @Test
-  @Ignore
-  fun testMozilla() {
-    assumeNetwork()
-
-    val request = Request.Builder().url("https://mozilla.org/robots.txt").build()
-
-    client.newCall(request).execute().use {
-      assertThat(it.protocol).isEqualTo(Protocol.HTTP_2)
-      assertThat(it.handshake!!.tlsVersion).isEqualTo(TlsVersion.TLS_1_3)
-    }
-  }
-
-  @Test
-  @Ignore
-  fun testGoogle() {
-    assumeNetwork()
-
-    val request = Request.Builder().url("https://google.com/robots.txt").build()
-
-    client.newCall(request).execute().use {
-      assertThat(it.protocol).isEqualTo(Protocol.HTTP_2)
-      if (it.handshake!!.tlsVersion != TlsVersion.TLS_1_3) {
-        System.err.println("Flaky TLSv1.3 with google")
-//    assertThat(it.handshake()!!.tlsVersion).isEqualTo(TlsVersion.TLS_1_3)
-      }
-    }
-  }
-
-  @Test
-  fun testBuildIfSupported() {
-    val actual = ConscryptPlatform.buildIfSupported()
-    assertThat(actual).isNotNull
-  }
-
-  @Test
-  fun testVersion() {
-    val version = Conscrypt.version()
-
-    assertTrue(ConscryptPlatform.atLeastVersion(1, 4, 9))
-    assertTrue(ConscryptPlatform.atLeastVersion(version.major()))
-    assertTrue(ConscryptPlatform.atLeastVersion(version.major(), version.minor()))
-    assertTrue(ConscryptPlatform.atLeastVersion(version.major(), version.minor(), version.patch()))
-    assertFalse(ConscryptPlatform.atLeastVersion(version.major(), version.minor(), version.patch() + 1))
-    assertFalse(ConscryptPlatform.atLeastVersion(version.major(), version.minor() + 1))
-    assertFalse(ConscryptPlatform.atLeastVersion(version.major() + 1))
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/CookieTest.java b/okhttp/src/test/java/okhttp3/CookieTest.java
deleted file mode 100644
index bf2add65e3..0000000000
--- a/okhttp/src/test/java/okhttp3/CookieTest.java
+++ /dev/null
@@ -1,590 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.List;
-import java.util.Objects;
-import okhttp3.internal.Util;
-import org.junit.Test;
-
-import static java.util.Arrays.asList;
-import static okhttp3.internal.Internal.parseCookie;
-import static okhttp3.internal.http.DatesKt.MAX_DATE;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class CookieTest {
-  HttpUrl url = HttpUrl.get("https://example.com/");
-
-  @Test public void simpleCookie() throws Exception {
-    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42");
-    assertThat(cookie.toString()).isEqualTo("SID=31d4d96e407aad42; path=/");
-  }
-
-  @Test public void noEqualsSign() throws Exception {
-    assertThat(Cookie.parse(url, "foo")).isNull();
-    assertThat(Cookie.parse(url, "foo; Path=/")).isNull();
-  }
-
-  @Test public void emptyName() throws Exception {
-    assertThat(Cookie.parse(url, "=b")).isNull();
-    assertThat(Cookie.parse(url, " =b")).isNull();
-    assertThat(Cookie.parse(url, "\r\t \n=b")).isNull();
-  }
-
-  @Test public void spaceInName() throws Exception {
-    assertThat(Cookie.parse(url, "a b=cd").name()).isEqualTo("a b");
-  }
-
-  @Test public void spaceInValue() throws Exception {
-    assertThat(Cookie.parse(url, "ab=c d").value()).isEqualTo("c d");
-  }
-
-  @Test public void trimLeadingAndTrailingWhitespaceFromName() throws Exception {
-    assertThat(Cookie.parse(url, " a=b").name()).isEqualTo("a");
-    assertThat(Cookie.parse(url, "a =b").name()).isEqualTo("a");
-    assertThat(Cookie.parse(url, "\r\t \na\n\t \n=b").name()).isEqualTo("a");
-  }
-
-  @Test public void emptyValue() throws Exception {
-    assertThat(Cookie.parse(url, "a=").value()).isEqualTo("");
-    assertThat(Cookie.parse(url, "a= ").value()).isEqualTo("");
-    assertThat(Cookie.parse(url, "a=\r\t \n").value()).isEqualTo("");
-  }
-
-  @Test public void trimLeadingAndTrailingWhitespaceFromValue() throws Exception {
-    assertThat(Cookie.parse(url, "a= ").value()).isEqualTo("");
-    assertThat(Cookie.parse(url, "a= b").value()).isEqualTo("b");
-    assertThat(Cookie.parse(url, "a=b ").value()).isEqualTo("b");
-    assertThat(Cookie.parse(url, "a=\r\t \nb\n\t \n").value()).isEqualTo("b");
-  }
-
-  @Test public void invalidCharacters() throws Exception {
-    assertThat(Cookie.parse(url, "a\u0000b=cd")).isNull();
-    assertThat(Cookie.parse(url, "ab=c\u0000d")).isNull();
-    assertThat(Cookie.parse(url, "a\u0001b=cd")).isNull();
-    assertThat(Cookie.parse(url, "ab=c\u0001d")).isNull();
-    assertThat(Cookie.parse(url, "a\u0009b=cd")).isNull();
-    assertThat(Cookie.parse(url, "ab=c\u0009d")).isNull();
-    assertThat(Cookie.parse(url, "a\u001fb=cd")).isNull();
-    assertThat(Cookie.parse(url, "ab=c\u001fd")).isNull();
-    assertThat(Cookie.parse(url, "a\u007fb=cd")).isNull();
-    assertThat(Cookie.parse(url, "ab=c\u007fd")).isNull();
-    assertThat(Cookie.parse(url, "a\u0080b=cd")).isNull();
-    assertThat(Cookie.parse(url, "ab=c\u0080d")).isNull();
-    assertThat(Cookie.parse(url, "a\u00ffb=cd")).isNull();
-    assertThat(Cookie.parse(url, "ab=c\u00ffd")).isNull();
-  }
-
-  @Test public void maxAge() throws Exception {
-    assertThat(parseCookie(50000L, url, "a=b; Max-Age=1").expiresAt())
-        .isEqualTo(51000L);
-    assertThat(parseCookie(50000L, url, "a=b; Max-Age=9223372036854724").expiresAt())
-        .isEqualTo(MAX_DATE);
-    assertThat(parseCookie(50000L, url, "a=b; Max-Age=9223372036854725").expiresAt())
-        .isEqualTo(MAX_DATE);
-    assertThat(parseCookie(50000L, url, "a=b; Max-Age=9223372036854726").expiresAt())
-        .isEqualTo(MAX_DATE);
-    assertThat(parseCookie(9223372036854773807L, url, "a=b; Max-Age=1").expiresAt())
-        .isEqualTo(MAX_DATE);
-    assertThat(parseCookie(9223372036854773807L, url, "a=b; Max-Age=2").expiresAt())
-        .isEqualTo(MAX_DATE);
-    assertThat(parseCookie(9223372036854773807L, url, "a=b; Max-Age=3").expiresAt())
-        .isEqualTo(MAX_DATE);
-    assertThat(parseCookie(50000L, url, "a=b; Max-Age=10000000000000000000").expiresAt())
-        .isEqualTo(MAX_DATE);
-  }
-
-  @Test public void maxAgeNonPositive() throws Exception {
-    assertThat(parseCookie(50000L, url, "a=b; Max-Age=-1").expiresAt())
-        .isEqualTo(Long.MIN_VALUE);
-    assertThat(parseCookie(50000L, url, "a=b; Max-Age=0").expiresAt())
-        .isEqualTo(Long.MIN_VALUE);
-    assertThat(parseCookie(50000L, url, "a=b; Max-Age=-9223372036854775808").expiresAt())
-        .isEqualTo(Long.MIN_VALUE);
-    assertThat(parseCookie(50000L, url, "a=b; Max-Age=-9223372036854775809").expiresAt())
-        .isEqualTo(Long.MIN_VALUE);
-    assertThat(parseCookie(50000L, url, "a=b; Max-Age=-10000000000000000000").expiresAt())
-        .isEqualTo(Long.MIN_VALUE);
-  }
-
-  @Test public void domainAndPath() throws Exception {
-    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42; Path=/; Domain=example.com");
-    assertThat(cookie.domain()).isEqualTo("example.com");
-    assertThat(cookie.path()).isEqualTo("/");
-    assertThat(cookie.hostOnly()).isFalse();
-    assertThat(cookie.toString()).isEqualTo(
-        "SID=31d4d96e407aad42; domain=example.com; path=/");
-  }
-
-  @Test public void secureAndHttpOnly() throws Exception {
-    Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42; Path=/; Secure; HttpOnly");
-    assertThat(cookie.secure()).isTrue();
-    assertThat(cookie.httpOnly()).isTrue();
-    assertThat(cookie.toString()).isEqualTo(
-        "SID=31d4d96e407aad42; path=/; secure; httponly");
-  }
-
-  @Test public void expiresDate() throws Exception {
-    assertThat(new Date(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:00 GMT")
-        .expiresAt())).isEqualTo(date("1970-01-01T00:00:00.000+0000"));
-    assertThat(new Date(Cookie.parse(url, "a=b; Expires=Wed, 09 Jun 2021 10:18:14 GMT")
-        .expiresAt())).isEqualTo(date("2021-06-09T10:18:14.000+0000"));
-    assertThat(new Date(Cookie.parse(url, "a=b; Expires=Sun, 06 Nov 1994 08:49:37 GMT")
-        .expiresAt())).isEqualTo(date("1994-11-06T08:49:37.000+0000"));
-  }
-
-  @Test public void awkwardDates() throws Exception {
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 70 00:00:00 GMT").expiresAt())
-        .isEqualTo(0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 January 1970 00:00:00 GMT").expiresAt())
-        .isEqualTo(0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Janucember 1970 00:00:00 GMT").expiresAt())
-        .isEqualTo(0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 1 Jan 1970 00:00:00 GMT").expiresAt())
-        .isEqualTo(0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 0:00:00 GMT").expiresAt())
-        .isEqualTo(0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:0:00 GMT").expiresAt())
-        .isEqualTo(0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:0 GMT").expiresAt())
-        .isEqualTo(0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=00:00:00 Thu, 01 Jan 1970 GMT").expiresAt())
-        .isEqualTo(0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=00:00:00 1970 Jan 01").expiresAt())
-        .isEqualTo(0L);
-    assertThat(Cookie.parse(url, "a=b; Expires=00:00:00 1970 Jan 1").expiresAt())
-        .isEqualTo(0L);
-  }
-
-  @Test public void invalidYear() throws Exception {
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1600 00:00:00 GMT").expiresAt())
-        .isEqualTo(MAX_DATE);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 19999 00:00:00 GMT").expiresAt())
-        .isEqualTo(MAX_DATE);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 00:00:00 GMT").expiresAt())
-        .isEqualTo(MAX_DATE);
-  }
-
-  @Test public void invalidMonth() throws Exception {
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Foo 1970 00:00:00 GMT").expiresAt())
-        .isEqualTo(MAX_DATE);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Foocember 1970 00:00:00 GMT").expiresAt())
-        .isEqualTo(MAX_DATE);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 1970 00:00:00 GMT").expiresAt())
-        .isEqualTo(MAX_DATE);
-  }
-
-  @Test public void invalidDayOfMonth() throws Exception {
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 32 Jan 1970 00:00:00 GMT").expiresAt())
-        .isEqualTo(MAX_DATE);
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, Jan 1970 00:00:00 GMT").expiresAt())
-        .isEqualTo(MAX_DATE);
-  }
-
-  @Test public void invalidHour() throws Exception {
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 24:00:00 GMT").expiresAt())
-        .isEqualTo(MAX_DATE);
-  }
-
-  @Test public void invalidMinute() throws Exception {
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:60:00 GMT").expiresAt())
-        .isEqualTo(MAX_DATE);
-  }
-
-  @Test public void invalidSecond() throws Exception {
-    assertThat(Cookie.parse(url, "a=b; Expires=Thu, 01 Jan 1970 00:00:60 GMT").expiresAt())
-        .isEqualTo(MAX_DATE);
-  }
-
-  @Test public void domainMatches() throws Exception {
-    Cookie cookie = Cookie.parse(url, "a=b; domain=example.com");
-    assertThat(cookie.matches(HttpUrl.get("http://example.com"))).isTrue();
-    assertThat(cookie.matches(HttpUrl.get("http://www.example.com"))).isTrue();
-    assertThat(cookie.matches(HttpUrl.get("http://square.com"))).isFalse();
-  }
-
-  /** If no domain is present, match only the origin domain. */
-  @Test public void domainMatchesNoDomain() throws Exception {
-    Cookie cookie = Cookie.parse(url, "a=b");
-    assertThat(cookie.matches(HttpUrl.get("http://example.com"))).isTrue();
-    assertThat(cookie.matches(HttpUrl.get("http://www.example.com"))).isFalse();
-    assertThat(cookie.matches(HttpUrl.get("http://square.com"))).isFalse();
-  }
-
-  /** Ignore an optional leading `.` in the domain. */
-  @Test public void domainMatchesIgnoresLeadingDot() throws Exception {
-    Cookie cookie = Cookie.parse(url, "a=b; domain=.example.com");
-    assertThat(cookie.matches(HttpUrl.get("http://example.com"))).isTrue();
-    assertThat(cookie.matches(HttpUrl.get("http://www.example.com"))).isTrue();
-    assertThat(cookie.matches(HttpUrl.get("http://square.com"))).isFalse();
-  }
-
-  /** Ignore the entire attribute if the domain ends with `.`. */
-  @Test public void domainIgnoredWithTrailingDot() throws Exception {
-    Cookie cookie = Cookie.parse(url, "a=b; domain=example.com.");
-    assertThat(cookie.matches(HttpUrl.get("http://example.com"))).isTrue();
-    assertThat(cookie.matches(HttpUrl.get("http://www.example.com"))).isFalse();
-    assertThat(cookie.matches(HttpUrl.get("http://square.com"))).isFalse();
-  }
-
-  @Test public void idnDomainMatches() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.get("http://.net/"), "a=b; domain=.net");
-    assertThat(cookie.matches(HttpUrl.get("http://.net/"))).isTrue();
-    assertThat(cookie.matches(HttpUrl.get("http://xn--n3h.net/"))).isTrue();
-    assertThat(cookie.matches(HttpUrl.get("http://www..net/"))).isTrue();
-    assertThat(cookie.matches(HttpUrl.get("http://www.xn--n3h.net/"))).isTrue();
-  }
-
-  @Test public void punycodeDomainMatches() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.get("http://xn--n3h.net/"), "a=b; domain=xn--n3h.net");
-    assertThat(cookie.matches(HttpUrl.get("http://.net/"))).isTrue();
-    assertThat(cookie.matches(HttpUrl.get("http://xn--n3h.net/"))).isTrue();
-    assertThat(cookie.matches(HttpUrl.get("http://www..net/"))).isTrue();
-    assertThat(cookie.matches(HttpUrl.get("http://www.xn--n3h.net/"))).isTrue();
-  }
-
-  @Test public void domainMatchesIpAddress() throws Exception {
-    HttpUrl urlWithIp = HttpUrl.get("http://123.45.234.56/");
-    assertThat(Cookie.parse(urlWithIp, "a=b; domain=234.56")).isNull();
-    assertThat(Cookie.parse(urlWithIp, "a=b; domain=123.45.234.56").domain()).isEqualTo(
-        "123.45.234.56");
-  }
-
-  @Test public void domainMatchesIpv6Address() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.get("http://[::1]/"), "a=b; domain=::1");
-    assertThat(cookie.domain()).isEqualTo("::1");
-    assertThat(cookie.matches(HttpUrl.get("http://[::1]/"))).isTrue();
-  }
-
-  @Test public void domainMatchesIpv6AddressWithCompression() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.get("http://[0001:0000::]/"), "a=b; domain=0001:0000::");
-    assertThat(cookie.domain()).isEqualTo("1::");
-    assertThat(cookie.matches(HttpUrl.get("http://[1::]/"))).isTrue();
-  }
-
-  @Test public void domainMatchesIpv6AddressWithIpv4Suffix() throws Exception {
-    Cookie cookie = Cookie.parse(
-        HttpUrl.get("http://[::1:ffff:ffff]/"), "a=b; domain=::1:255.255.255.255");
-    assertThat(cookie.domain()).isEqualTo("::1:ffff:ffff");
-    assertThat(cookie.matches(HttpUrl.get("http://[::1:ffff:ffff]/"))).isTrue();
-  }
-
-  @Test public void ipv6AddressDoesntMatch() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.get("http://[::1]/"), "a=b; domain=::2");
-    assertThat(cookie).isNull();
-  }
-
-  @Test public void ipv6AddressMalformed() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.get("http://[::1]/"), "a=b; domain=::2::2");
-    assertThat(cookie.domain()).isEqualTo("::1");
-  }
-
-  /**
-   * These public suffixes were selected by inspecting the publicsuffix.org list. It's possible they
-   * may change in the future. If this test begins to fail, please double check they are still
-   * present in the public suffix list.
-   */
-  @Test public void domainIsPublicSuffix() {
-    HttpUrl ascii = HttpUrl.get("https://foo1.foo.bar.elb.amazonaws.com");
-    assertThat(Cookie.parse(ascii, "a=b; domain=foo.bar.elb.amazonaws.com")).isNotNull();
-    assertThat(Cookie.parse(ascii, "a=b; domain=bar.elb.amazonaws.com")).isNull();
-    assertThat(Cookie.parse(ascii, "a=b; domain=com")).isNull();
-
-    HttpUrl unicode = HttpUrl.get("https://...jp");
-    assertThat(Cookie.parse(unicode, "a=b; domain=..jp")).isNotNull();
-    assertThat(Cookie.parse(unicode, "a=b; domain=.jp")).isNull();
-
-    HttpUrl punycode = HttpUrl.get("https://xn--ue5a.xn--ue5a.xn--8ltr62k.jp");
-    assertThat(Cookie.parse(punycode, "a=b; domain=xn--ue5a.xn--8ltr62k.jp")).isNotNull();
-    assertThat(Cookie.parse(punycode, "a=b; domain=xn--8ltr62k.jp")).isNull();
-  }
-
-  @Test public void hostOnly() throws Exception {
-    assertThat(Cookie.parse(url, "a=b").hostOnly()).isTrue();
-    assertThat(Cookie.parse(url, "a=b; domain=example.com").hostOnly()).isFalse();
-  }
-
-  @Test public void defaultPath() throws Exception {
-    assertThat(Cookie.parse(HttpUrl.get("http://example.com/foo/bar"), "a=b").path()).isEqualTo(
-        "/foo");
-    assertThat(Cookie.parse(HttpUrl.get("http://example.com/foo/"), "a=b").path()).isEqualTo(
-        "/foo");
-    assertThat(Cookie.parse(HttpUrl.get("http://example.com/foo"), "a=b").path()).isEqualTo(
-        "/");
-    assertThat(Cookie.parse(HttpUrl.get("http://example.com/"), "a=b").path()).isEqualTo(
-        "/");
-  }
-
-  @Test public void defaultPathIsUsedIfPathDoesntHaveLeadingSlash() throws Exception {
-    assertThat(Cookie.parse(HttpUrl.get("http://example.com/foo/bar"),
-        "a=b; path=quux").path()).isEqualTo("/foo");
-    assertThat(Cookie.parse(HttpUrl.get("http://example.com/foo/bar"),
-        "a=b; path=").path()).isEqualTo("/foo");
-  }
-
-  @Test public void pathAttributeDoesntNeedToMatch() throws Exception {
-    assertThat(Cookie.parse(HttpUrl.get("http://example.com/"),
-        "a=b; path=/quux").path()).isEqualTo("/quux");
-    assertThat(Cookie.parse(HttpUrl.get("http://example.com/foo/bar"),
-        "a=b; path=/quux").path()).isEqualTo("/quux");
-  }
-
-  @Test public void httpOnly() throws Exception {
-    assertThat(Cookie.parse(url, "a=b").httpOnly()).isFalse();
-    assertThat(Cookie.parse(url, "a=b; HttpOnly").httpOnly()).isTrue();
-  }
-
-  @Test public void secure() throws Exception {
-    assertThat(Cookie.parse(url, "a=b").secure()).isFalse();
-    assertThat(Cookie.parse(url, "a=b; Secure").secure()).isTrue();
-  }
-
-  @Test public void maxAgeTakesPrecedenceOverExpires() throws Exception {
-    // Max-Age = 1, Expires = 2. In either order.
-    assertThat(parseCookie(
-        0L, url, "a=b; Max-Age=1; Expires=Thu, 01 Jan 1970 00:00:02 GMT").expiresAt()).isEqualTo(
-        1000L);
-    assertThat(parseCookie(
-        0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:02 GMT; Max-Age=1").expiresAt()).isEqualTo(
-        1000L);
-    // Max-Age = 2, Expires = 1. In either order.
-    assertThat(parseCookie(
-        0L, url, "a=b; Max-Age=2; Expires=Thu, 01 Jan 1970 00:00:01 GMT").expiresAt()).isEqualTo(
-        2000L);
-    assertThat(parseCookie(
-        0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:01 GMT; Max-Age=2").expiresAt()).isEqualTo(
-        2000L);
-  }
-
-  /** If a cookie incorrectly defines multiple 'Max-Age' attributes, the last one defined wins. */
-  @Test public void lastMaxAgeWins() throws Exception {
-    assertThat(parseCookie(
-        0L, url, "a=b; Max-Age=2; Max-Age=4; Max-Age=1; Max-Age=3").expiresAt()).isEqualTo(3000L);
-  }
-
-  /** If a cookie incorrectly defines multiple 'Expires' attributes, the last one defined wins. */
-  @Test public void lastExpiresAtWins() throws Exception {
-    assertThat(parseCookie(0L, url, "a=b; "
-        + "Expires=Thu, 01 Jan 1970 00:00:02 GMT; "
-        + "Expires=Thu, 01 Jan 1970 00:00:04 GMT; "
-        + "Expires=Thu, 01 Jan 1970 00:00:01 GMT; "
-        + "Expires=Thu, 01 Jan 1970 00:00:03 GMT").expiresAt()).isEqualTo(3000L);
-  }
-
-  @Test public void maxAgeOrExpiresMakesCookiePersistent() throws Exception {
-    assertThat(parseCookie(0L, url, "a=b").persistent()).isFalse();
-    assertThat(parseCookie(0L, url, "a=b; Max-Age=1").persistent()).isTrue();
-    assertThat(parseCookie(0L, url, "a=b; Expires=Thu, 01 Jan 1970 00:00:01 GMT").persistent())
-        .isTrue();
-  }
-
-  @Test public void parseAll() throws Exception {
-    Headers headers = new Headers.Builder()
-        .add("Set-Cookie: a=b")
-        .add("Set-Cookie: c=d")
-        .build();
-    List<Cookie> cookies = Cookie.parseAll(url, headers);
-    assertThat(cookies.size()).isEqualTo(2);
-    assertThat(cookies.get(0).toString()).isEqualTo("a=b; path=/");
-    assertThat(cookies.get(1).toString()).isEqualTo("c=d; path=/");
-  }
-
-  @Test public void builder() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .domain("example.com")
-        .build();
-    assertThat(cookie.name()).isEqualTo("a");
-    assertThat(cookie.value()).isEqualTo("b");
-    assertThat(cookie.expiresAt()).isEqualTo(MAX_DATE);
-    assertThat(cookie.domain()).isEqualTo("example.com");
-    assertThat(cookie.path()).isEqualTo("/");
-    assertThat(cookie.secure()).isFalse();
-    assertThat(cookie.httpOnly()).isFalse();
-    assertThat(cookie.persistent()).isFalse();
-    assertThat(cookie.hostOnly()).isFalse();
-  }
-
-  @Test public void builderNameValidation() throws Exception {
-    try {
-      new Cookie.Builder().name(null);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      new Cookie.Builder().name(" a ");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void builderValueValidation() throws Exception {
-    try {
-      new Cookie.Builder().value(null);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      new Cookie.Builder().value(" b ");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void builderClampsMaxDate() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("example.com")
-        .expiresAt(Long.MAX_VALUE)
-        .build();
-    assertThat(cookie.toString()).isEqualTo(
-        "a=b; expires=Fri, 31 Dec 9999 23:59:59 GMT; path=/");
-  }
-
-  @Test public void builderExpiresAt() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("example.com")
-        .expiresAt(date("1970-01-01T00:00:01.000+0000").getTime())
-        .build();
-    assertThat(cookie.toString()).isEqualTo(
-        "a=b; expires=Thu, 01 Jan 1970 00:00:01 GMT; path=/");
-  }
-
-  @Test public void builderClampsMinDate() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("example.com")
-        .expiresAt(date("1970-01-01T00:00:00.000+0000").getTime())
-        .build();
-    assertThat(cookie.toString()).isEqualTo("a=b; max-age=0; path=/");
-  }
-
-  @Test public void builderDomainValidation() throws Exception {
-    try {
-      new Cookie.Builder().hostOnlyDomain(null);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      new Cookie.Builder().hostOnlyDomain("a/b");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void builderDomain() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("squareup.com")
-        .build();
-    assertThat(cookie.domain()).isEqualTo("squareup.com");
-    assertThat(cookie.hostOnly()).isTrue();
-  }
-
-  @Test public void builderPath() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("example.com")
-        .path("/foo")
-        .build();
-    assertThat(cookie.path()).isEqualTo("/foo");
-  }
-
-  @Test public void builderPathValidation() throws Exception {
-    try {
-      new Cookie.Builder().path(null);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      new Cookie.Builder().path("foo");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void builderSecure() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("example.com")
-        .secure()
-        .build();
-    assertThat(cookie.secure()).isTrue();
-  }
-
-  @Test public void builderHttpOnly() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .hostOnlyDomain("example.com")
-        .httpOnly()
-        .build();
-    assertThat(cookie.httpOnly()).isTrue();
-  }
-
-  @Test public void builderIpv6() throws Exception {
-    Cookie cookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .domain("0:0:0:0:0:0:0:1")
-        .build();
-    assertThat(cookie.domain()).isEqualTo("::1");
-  }
-
-  @Test public void equalsAndHashCode() throws Exception {
-    List<String> cookieStrings = asList(
-        "a=b; Path=/c; Domain=example.com; Max-Age=5; Secure; HttpOnly",
-        "a= ; Path=/c; Domain=example.com; Max-Age=5; Secure; HttpOnly",
-        "a=b;          Domain=example.com; Max-Age=5; Secure; HttpOnly",
-        "a=b; Path=/c;                     Max-Age=5; Secure; HttpOnly",
-        "a=b; Path=/c; Domain=example.com;            Secure; HttpOnly",
-        "a=b; Path=/c; Domain=example.com; Max-Age=5;         HttpOnly",
-        "a=b; Path=/c; Domain=example.com; Max-Age=5; Secure;         "
-    );
-    for (String stringA : cookieStrings) {
-      Cookie cookieA = parseCookie(0, url, stringA);
-      for (String stringB : cookieStrings) {
-        Cookie cookieB = parseCookie(0, url, stringB);
-        if (Objects.equals(stringA, stringB)) {
-          assertThat(cookieB.hashCode()).isEqualTo(cookieA.hashCode());
-          assertThat(cookieB).isEqualTo(cookieA);
-        } else {
-          assertThat(cookieB.hashCode()).isNotEqualTo((long) cookieA.hashCode());
-          assertThat(cookieB).isNotEqualTo(cookieA);
-        }
-      }
-      assertThat(cookieA).isNotEqualTo(null);
-    }
-  }
-
-  private Date date(String s) throws ParseException {
-    SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
-    format.setTimeZone(Util.UTC);
-    return format.parse(s);
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/CookiesTest.java b/okhttp/src/test/java/okhttp3/CookiesTest.java
deleted file mode 100644
index 44ac99fd12..0000000000
--- a/okhttp/src/test/java/okhttp3/CookiesTest.java
+++ /dev/null
@@ -1,331 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3;
-
-import java.io.IOException;
-import java.net.CookieHandler;
-import java.net.CookieManager;
-import java.net.HttpCookie;
-import java.net.HttpURLConnection;
-import java.net.InetAddress;
-import java.net.URI;
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
-import static java.util.Arrays.asList;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.data.Offset.offset;
-import static org.junit.Assert.fail;
-
-/** Derived from Android's CookiesTest. */
-public class CookiesTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  private OkHttpClient client = clientTestRule.newClient();
-
-  @Test
-  public void testNetscapeResponse() throws Exception {
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    client = client.newBuilder()
-        .cookieJar(new JavaNetCookieJar(cookieManager))
-        .build();
-
-    HttpUrl urlWithIpAddress = urlWithIpAddress(server, "/path/foo");
-    server.enqueue(new MockResponse().addHeader("Set-Cookie: a=android; "
-        + "expires=Fri, 31-Dec-9999 23:59:59 GMT; "
-        + "path=/path; "
-        + "domain=" + urlWithIpAddress.host() + "; "
-        + "secure"));
-    get(urlWithIpAddress);
-
-    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
-    assertThat(cookies.size()).isEqualTo(1);
-    HttpCookie cookie = cookies.get(0);
-    assertThat(cookie.getName()).isEqualTo("a");
-    assertThat(cookie.getValue()).isEqualTo("android");
-    assertThat(cookie.getComment()).isNull();
-    assertThat(cookie.getCommentURL()).isNull();
-    assertThat(cookie.getDiscard()).isFalse();
-    assertThat(cookie.getMaxAge()).isGreaterThan(100000000000L);
-    assertThat(cookie.getPath()).isEqualTo("/path");
-    assertThat(cookie.getSecure()).isTrue();
-    assertThat(cookie.getVersion()).isEqualTo(0);
-  }
-
-  @Test public void testRfc2109Response() throws Exception {
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    client = client.newBuilder()
-        .cookieJar(new JavaNetCookieJar(cookieManager))
-        .build();
-
-    HttpUrl urlWithIpAddress = urlWithIpAddress(server, "/path/foo");
-    server.enqueue(new MockResponse().addHeader("Set-Cookie: a=android; "
-        + "Comment=this cookie is delicious; "
-        + "Domain=" + urlWithIpAddress.host() + "; "
-        + "Max-Age=60; "
-        + "Path=/path; "
-        + "Secure; "
-        + "Version=1"));
-    get(urlWithIpAddress);
-
-    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
-    assertThat(cookies.size()).isEqualTo(1);
-    HttpCookie cookie = cookies.get(0);
-    assertThat(cookie.getName()).isEqualTo("a");
-    assertThat(cookie.getValue()).isEqualTo("android");
-    assertThat(cookie.getCommentURL()).isNull();
-    assertThat(cookie.getDiscard()).isFalse();
-    // Converting to a fixed date can cause rounding!
-    assertThat((double) cookie.getMaxAge()).isCloseTo(60.0, offset(5.0));
-    assertThat(cookie.getPath()).isEqualTo("/path");
-    assertThat(cookie.getSecure()).isTrue();
-  }
-
-  @Test public void testQuotedAttributeValues() throws Exception {
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    client = client.newBuilder()
-        .cookieJar(new JavaNetCookieJar(cookieManager))
-        .build();
-
-    HttpUrl urlWithIpAddress = urlWithIpAddress(server, "/path/foo");
-    server.enqueue(new MockResponse().addHeader("Set-Cookie: a=\"android\"; "
-        + "Comment=\"this cookie is delicious\"; "
-        + "CommentURL=\"http://google.com/\"; "
-        + "Discard; "
-        + "Domain=" + urlWithIpAddress.host() + "; "
-        + "Max-Age=60; "
-        + "Path=\"/path\"; "
-        + "Port=\"80,443," + server.getPort() + "\"; "
-        + "Secure; "
-        + "Version=\"1\""));
-    get(urlWithIpAddress);
-
-    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
-    assertThat(cookies.size()).isEqualTo(1);
-    HttpCookie cookie = cookies.get(0);
-    assertThat(cookie.getName()).isEqualTo("a");
-    assertThat(cookie.getValue()).isEqualTo("android");
-    // Converting to a fixed date can cause rounding!
-    assertThat((double) cookie.getMaxAge()).isCloseTo(60.0, offset(1.0));
-    assertThat(cookie.getPath()).isEqualTo("/path");
-    assertThat(cookie.getSecure()).isTrue();
-  }
-
-  @Test public void testSendingCookiesFromStore() throws Exception {
-    server.enqueue(new MockResponse());
-    HttpUrl serverUrl = urlWithIpAddress(server, "/");
-
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    HttpCookie cookieA = new HttpCookie("a", "android");
-    cookieA.setDomain(serverUrl.host());
-    cookieA.setPath("/");
-    cookieManager.getCookieStore().add(serverUrl.uri(), cookieA);
-    HttpCookie cookieB = new HttpCookie("b", "banana");
-    cookieB.setDomain(serverUrl.host());
-    cookieB.setPath("/");
-    cookieManager.getCookieStore().add(serverUrl.uri(), cookieB);
-    client = client.newBuilder()
-        .cookieJar(new JavaNetCookieJar(cookieManager))
-        .build();
-
-    get(serverUrl);
-    RecordedRequest request = server.takeRequest();
-
-    assertThat(request.getHeader("Cookie")).isEqualTo("a=android; b=banana");
-  }
-
-  @Test public void cookieHandlerLikeAndroid() throws Exception {
-    server.enqueue(new MockResponse());
-    final HttpUrl serverUrl = urlWithIpAddress(server, "/");
-
-    CookieHandler androidCookieHandler = new CookieHandler() {
-      @Override public Map<String, List<String>> get(URI uri, Map<String, List<String>> map)
-          throws IOException {
-        return Collections.singletonMap("Cookie", Collections.singletonList("$Version=\"1\"; "
-            + "a=\"android\";$Path=\"/\";$Domain=\"" + serverUrl.host() + "\"; "
-            + "b=\"banana\";$Path=\"/\";$Domain=\"" + serverUrl.host() + "\""));
-      }
-
-      @Override public void put(URI uri, Map<String, List<String>> map) throws IOException {
-      }
-    };
-
-    client = client.newBuilder()
-        .cookieJar(new JavaNetCookieJar(androidCookieHandler))
-        .build();
-
-    get(serverUrl);
-    RecordedRequest request = server.takeRequest();
-
-    assertThat(request.getHeader("Cookie")).isEqualTo("a=android; b=banana");
-  }
-
-  @Test public void receiveAndSendMultipleCookies() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Set-Cookie", "a=android")
-        .addHeader("Set-Cookie", "b=banana"));
-    server.enqueue(new MockResponse());
-
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    client = client.newBuilder()
-        .cookieJar(new JavaNetCookieJar(cookieManager))
-        .build();
-
-    get(urlWithIpAddress(server, "/"));
-    RecordedRequest request1 = server.takeRequest();
-    assertThat(request1.getHeader("Cookie")).isNull();
-
-    get(urlWithIpAddress(server, "/"));
-    RecordedRequest request2 = server.takeRequest();
-    assertThat(request2.getHeader("Cookie")).isEqualTo("a=android; b=banana");
-  }
-
-  @Test public void testRedirectsDoNotIncludeTooManyCookies() throws Exception {
-    MockWebServer redirectTarget = new MockWebServer();
-    redirectTarget.enqueue(new MockResponse().setBody("A"));
-    redirectTarget.start();
-    HttpUrl redirectTargetUrl = urlWithIpAddress(redirectTarget, "/");
-
-    MockWebServer redirectSource = new MockWebServer();
-    redirectSource.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + redirectTargetUrl));
-    redirectSource.start();
-    HttpUrl redirectSourceUrl = urlWithIpAddress(redirectSource, "/");
-
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    HttpCookie cookie = new HttpCookie("c", "cookie");
-    cookie.setDomain(redirectSourceUrl.host());
-    cookie.setPath("/");
-    String portList = Integer.toString(redirectSource.getPort());
-    cookie.setPortlist(portList);
-    cookieManager.getCookieStore().add(redirectSourceUrl.uri(), cookie);
-    client = client.newBuilder()
-        .cookieJar(new JavaNetCookieJar(cookieManager))
-        .build();
-
-    get(redirectSourceUrl);
-    RecordedRequest request = redirectSource.takeRequest();
-
-    assertThat(request.getHeader("Cookie")).isEqualTo("c=cookie");
-
-    for (String header : redirectTarget.takeRequest().getHeaders().names()) {
-      if (header.startsWith("Cookie")) {
-        fail(header);
-      }
-    }
-  }
-
-  @Test public void testCookiesSentIgnoresCase() throws Exception {
-    client = client.newBuilder()
-        .cookieJar(new JavaNetCookieJar(new CookieManager() {
-          @Override public Map<String, List<String>> get(URI uri,
-              Map<String, List<String>> requestHeaders) throws IOException {
-            Map<String, List<String>> result = new LinkedHashMap<>();
-            result.put("COOKIE", Collections.singletonList("Bar=bar"));
-            result.put("cooKIE2", Collections.singletonList("Baz=baz"));
-            return result;
-          }
-        }))
-        .build();
-
-    server.enqueue(new MockResponse());
-
-    get(server.url("/"));
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getHeader("Cookie")).isEqualTo("Bar=bar; Baz=baz");
-    assertThat(request.getHeader("Cookie2")).isNull();
-    assertThat(request.getHeader("Quux")).isNull();
-  }
-
-  @Test public void acceptOriginalServerMatchesSubdomain() throws Exception {
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
-
-    HttpUrl url = HttpUrl.get("https://www.squareup.com/");
-    cookieJar.saveFromResponse(url, asList(
-        Cookie.parse(url, "a=android; Domain=squareup.com")));
-    List<Cookie> actualCookies = cookieJar.loadForRequest(url);
-    assertThat(actualCookies.size()).isEqualTo(1);
-    assertThat(actualCookies.get(0).name()).isEqualTo("a");
-    assertThat(actualCookies.get(0).value()).isEqualTo("android");
-  }
-
-  @Test public void acceptOriginalServerMatchesRfc2965Dot() throws Exception {
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
-
-    HttpUrl url = HttpUrl.get("https://www.squareup.com/");
-    cookieJar.saveFromResponse(url, asList(
-        Cookie.parse(url, "a=android; Domain=.squareup.com")));
-    List<Cookie> actualCookies = cookieJar.loadForRequest(url);
-    assertThat(actualCookies.size()).isEqualTo(1);
-    assertThat(actualCookies.get(0).name()).isEqualTo("a");
-    assertThat(actualCookies.get(0).value()).isEqualTo("android");
-  }
-
-  @Test public void acceptOriginalServerMatchesExactly() throws Exception {
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
-
-    HttpUrl url = HttpUrl.get("https://squareup.com/");
-    cookieJar.saveFromResponse(url, asList(
-        Cookie.parse(url, "a=android; Domain=squareup.com")));
-    List<Cookie> actualCookies = cookieJar.loadForRequest(url);
-    assertThat(actualCookies.size()).isEqualTo(1);
-    assertThat(actualCookies.get(0).name()).isEqualTo("a");
-    assertThat(actualCookies.get(0).value()).isEqualTo("android");
-  }
-
-  @Test public void acceptOriginalServerDoesNotMatchDifferentServer() throws Exception {
-    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
-    JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
-
-    HttpUrl url1 = HttpUrl.get("https://api.squareup.com/");
-    cookieJar.saveFromResponse(url1, asList(
-        Cookie.parse(url1, "a=android; Domain=api.squareup.com")));
-
-    HttpUrl url2 = HttpUrl.get("https://www.squareup.com/");
-    List<Cookie> actualCookies = cookieJar.loadForRequest(url2);
-    assertThat(actualCookies).isEmpty();
-  }
-
-  private HttpUrl urlWithIpAddress(MockWebServer server, String path) throws Exception {
-    return server.url(path)
-        .newBuilder()
-        .host(InetAddress.getByName(server.getHostName()).getHostAddress())
-        .build();
-  }
-
-  private void get(HttpUrl url) throws Exception {
-    Call call = client.newCall(new Request.Builder()
-        .url(url)
-        .build());
-    Response response = call.execute();
-    response.body().close();
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/DelegatingSSLSession.java b/okhttp/src/test/java/okhttp3/DelegatingSSLSession.java
deleted file mode 100644
index 0e15e825b9..0000000000
--- a/okhttp/src/test/java/okhttp3/DelegatingSSLSession.java
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright 2019 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.security.Principal;
-import java.security.cert.Certificate;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSession;
-import javax.net.ssl.SSLSessionContext;
-import javax.security.cert.X509Certificate;
-
-/** An {@link SSLSession} that delegates all calls. */
-public abstract class DelegatingSSLSession implements SSLSession {
-  protected final SSLSession delegate;
-
-  public DelegatingSSLSession(SSLSession delegate) {
-    this.delegate = delegate;
-  }
-
-  @Override public byte[] getId() {
-    return delegate.getId();
-  }
-
-  @Override public SSLSessionContext getSessionContext() {
-    return delegate.getSessionContext();
-  }
-
-  @Override public long getCreationTime() {
-    return delegate.getCreationTime();
-  }
-
-  @Override public long getLastAccessedTime() {
-    return delegate.getLastAccessedTime();
-  }
-
-  @Override public void invalidate() {
-    delegate.invalidate();
-  }
-
-  @Override public boolean isValid() {
-    return delegate.isValid();
-  }
-
-  @Override public void putValue(String s, Object o) {
-    delegate.putValue(s, o);
-  }
-
-  @Override public Object getValue(String s) {
-    return delegate.getValue(s);
-  }
-
-  @Override public void removeValue(String s) {
-    delegate.removeValue(s);
-  }
-
-  @Override public String[] getValueNames() {
-    return delegate.getValueNames();
-  }
-
-  @Override public Certificate[] getPeerCertificates() throws SSLPeerUnverifiedException {
-    return delegate.getPeerCertificates();
-  }
-
-  @Override public Certificate[] getLocalCertificates() {
-    return delegate.getLocalCertificates();
-  }
-
-  @Override public X509Certificate[] getPeerCertificateChain() throws SSLPeerUnverifiedException {
-    return delegate.getPeerCertificateChain();
-  }
-
-  @Override public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-    return delegate.getPeerPrincipal();
-  }
-
-  @Override public Principal getLocalPrincipal() {
-    return delegate.getLocalPrincipal();
-  }
-
-  @Override public String getCipherSuite() {
-    return delegate.getCipherSuite();
-  }
-
-  @Override public String getProtocol() {
-    return delegate.getProtocol();
-  }
-
-  @Override public String getPeerHost() {
-    return delegate.getPeerHost();
-  }
-
-  @Override public int getPeerPort() {
-    return delegate.getPeerPort();
-  }
-
-  @Override public int getPacketBufferSize() {
-    return delegate.getPacketBufferSize();
-  }
-
-  @Override public int getApplicationBufferSize() {
-    return delegate.getApplicationBufferSize();
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/DelegatingSSLSocket.java b/okhttp/src/test/java/okhttp3/DelegatingSSLSocket.java
deleted file mode 100644
index 8a772e7a1c..0000000000
--- a/okhttp/src/test/java/okhttp3/DelegatingSSLSocket.java
+++ /dev/null
@@ -1,348 +0,0 @@
-/*
- * Copyright 2014 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.lang.reflect.InvocationTargetException;
-import java.net.InetAddress;
-import java.net.Socket;
-import java.net.SocketAddress;
-import java.net.SocketException;
-import java.net.SocketOption;
-import java.nio.channels.SocketChannel;
-import java.util.Set;
-import javax.net.ssl.HandshakeCompletedListener;
-import javax.net.ssl.SSLParameters;
-import javax.net.ssl.SSLSession;
-import javax.net.ssl.SSLSocket;
-
-/** An {@link SSLSocket} that delegates all calls. */
-public abstract class DelegatingSSLSocket extends SSLSocket {
-  protected final SSLSocket delegate;
-
-  public DelegatingSSLSocket(SSLSocket delegate) {
-    this.delegate = delegate;
-  }
-
-  @Override public void shutdownInput() throws IOException {
-    delegate.shutdownInput();
-  }
-
-  @Override public void shutdownOutput() throws IOException {
-    delegate.shutdownOutput();
-  }
-
-  @Override public String[] getSupportedCipherSuites() {
-    return delegate.getSupportedCipherSuites();
-  }
-
-  @Override public String[] getEnabledCipherSuites() {
-    return delegate.getEnabledCipherSuites();
-  }
-
-  @Override public void setEnabledCipherSuites(String[] suites) {
-    delegate.setEnabledCipherSuites(suites);
-  }
-
-  @Override public String[] getSupportedProtocols() {
-    return delegate.getSupportedProtocols();
-  }
-
-  @Override public String[] getEnabledProtocols() {
-    return delegate.getEnabledProtocols();
-  }
-
-  @Override public void setEnabledProtocols(String[] protocols) {
-    delegate.setEnabledProtocols(protocols);
-  }
-
-  @Override public SSLSession getSession() {
-    return delegate.getSession();
-  }
-
-  @Override public void addHandshakeCompletedListener(HandshakeCompletedListener listener) {
-    delegate.addHandshakeCompletedListener(listener);
-  }
-
-  @Override public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) {
-    delegate.removeHandshakeCompletedListener(listener);
-  }
-
-  @Override public void startHandshake() throws IOException {
-    delegate.startHandshake();
-  }
-
-  @Override public void setUseClientMode(boolean mode) {
-    delegate.setUseClientMode(mode);
-  }
-
-  @Override public boolean getUseClientMode() {
-    return delegate.getUseClientMode();
-  }
-
-  @Override public void setNeedClientAuth(boolean need) {
-    delegate.setNeedClientAuth(need);
-  }
-
-  @Override public void setWantClientAuth(boolean want) {
-    delegate.setWantClientAuth(want);
-  }
-
-  @Override public boolean getNeedClientAuth() {
-    return delegate.getNeedClientAuth();
-  }
-
-  @Override public boolean getWantClientAuth() {
-    return delegate.getWantClientAuth();
-  }
-
-  @Override public void setEnableSessionCreation(boolean flag) {
-    delegate.setEnableSessionCreation(flag);
-  }
-
-  @Override public boolean getEnableSessionCreation() {
-    return delegate.getEnableSessionCreation();
-  }
-
-  @Override public SSLParameters getSSLParameters() {
-    return delegate.getSSLParameters();
-  }
-
-  @Override public void setSSLParameters(SSLParameters p) {
-    delegate.setSSLParameters(p);
-  }
-
-  @Override public void close() throws IOException {
-    delegate.close();
-  }
-
-  @Override public InetAddress getInetAddress() {
-    return delegate.getInetAddress();
-  }
-
-  @Override public InputStream getInputStream() throws IOException {
-    return delegate.getInputStream();
-  }
-
-  @Override public boolean getKeepAlive() throws SocketException {
-    return delegate.getKeepAlive();
-  }
-
-  @Override public InetAddress getLocalAddress() {
-    return delegate.getLocalAddress();
-  }
-
-  @Override public int getLocalPort() {
-    return delegate.getLocalPort();
-  }
-
-  @Override public OutputStream getOutputStream() throws IOException {
-    return delegate.getOutputStream();
-  }
-
-  @Override public int getPort() {
-    return delegate.getPort();
-  }
-
-  @Override public int getSoLinger() throws SocketException {
-    return delegate.getSoLinger();
-  }
-
-  @Override public int getReceiveBufferSize() throws SocketException {
-    return delegate.getReceiveBufferSize();
-  }
-
-  @Override public int getSendBufferSize() throws SocketException {
-    return delegate.getSendBufferSize();
-  }
-
-  @Override public int getSoTimeout() throws SocketException {
-    return delegate.getSoTimeout();
-  }
-
-  @Override public boolean getTcpNoDelay() throws SocketException {
-    return delegate.getTcpNoDelay();
-  }
-
-  @Override public void setKeepAlive(boolean keepAlive) throws SocketException {
-    delegate.setKeepAlive(keepAlive);
-  }
-
-  @Override public void setSendBufferSize(int size) throws SocketException {
-    delegate.setSendBufferSize(size);
-  }
-
-  @Override public void setReceiveBufferSize(int size) throws SocketException {
-    delegate.setReceiveBufferSize(size);
-  }
-
-  @Override public void setSoLinger(boolean on, int timeout) throws SocketException {
-    delegate.setSoLinger(on, timeout);
-  }
-
-  @Override public void setSoTimeout(int timeout) throws SocketException {
-    delegate.setSoTimeout(timeout);
-  }
-
-  @Override public void setTcpNoDelay(boolean on) throws SocketException {
-    delegate.setTcpNoDelay(on);
-  }
-
-  @Override public String toString() {
-    return delegate.toString();
-  }
-
-  @Override public SocketAddress getLocalSocketAddress() {
-    return delegate.getLocalSocketAddress();
-  }
-
-  @Override public SocketAddress getRemoteSocketAddress() {
-    return delegate.getRemoteSocketAddress();
-  }
-
-  @Override public boolean isBound() {
-    return delegate.isBound();
-  }
-
-  @Override public boolean isConnected() {
-    return delegate.isConnected();
-  }
-
-  @Override public boolean isClosed() {
-    return delegate.isClosed();
-  }
-
-  @Override public void bind(SocketAddress localAddr) throws IOException {
-    delegate.bind(localAddr);
-  }
-
-  @Override public void connect(SocketAddress remoteAddr) throws IOException {
-    delegate.connect(remoteAddr);
-  }
-
-  @Override public void connect(SocketAddress remoteAddr, int timeout) throws IOException {
-    delegate.connect(remoteAddr, timeout);
-  }
-
-  @Override public boolean isInputShutdown() {
-    return delegate.isInputShutdown();
-  }
-
-  @Override public boolean isOutputShutdown() {
-    return delegate.isOutputShutdown();
-  }
-
-  @Override public void setReuseAddress(boolean reuse) throws SocketException {
-    delegate.setReuseAddress(reuse);
-  }
-
-  @Override public boolean getReuseAddress() throws SocketException {
-    return delegate.getReuseAddress();
-  }
-
-  @Override public void setOOBInline(boolean oobinline) throws SocketException {
-    delegate.setOOBInline(oobinline);
-  }
-
-  @Override public boolean getOOBInline() throws SocketException {
-    return delegate.getOOBInline();
-  }
-
-  @Override public void setTrafficClass(int value) throws SocketException {
-    delegate.setTrafficClass(value);
-  }
-
-  @Override public int getTrafficClass() throws SocketException {
-    return delegate.getTrafficClass();
-  }
-
-  @Override public void sendUrgentData(int value) throws IOException {
-    delegate.sendUrgentData(value);
-  }
-
-  @Override public SocketChannel getChannel() {
-    return delegate.getChannel();
-  }
-
-  @Override public void setPerformancePreferences(int connectionTime, int latency, int bandwidth) {
-    delegate.setPerformancePreferences(connectionTime, latency, bandwidth);
-  }
-
-  // Java 9 methods.
-
-  @SuppressWarnings("MissingOverride") // Can only override with JDK 9+
-  public SSLSession getHandshakeSession() {
-    try {
-      return (SSLSession) SSLSocket.class.getMethod("getHandshakeSession").invoke(delegate);
-    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
-      throw new AssertionError();
-    }
-  }
-
-  @SuppressWarnings("MissingOverride") // Can only override with JDK 9+
-  public String getApplicationProtocol() {
-    try {
-      return (String) SSLSocket.class.getMethod("getApplicationProtocol").invoke(delegate);
-    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
-      throw new AssertionError();
-    }
-  }
-
-  @SuppressWarnings("MissingOverride") // Can only override with JDK 9+
-  public String getHandshakeApplicationProtocol() {
-    try {
-      return (String) SSLSocket.class.getMethod("getHandshakeApplicationProtocol").invoke(delegate);
-    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
-      throw new AssertionError();
-    }
-  }
-
-  @SuppressWarnings("MissingOverride") // Can only override with JDK 9+
-  public <T> Socket setOption(SocketOption<T> name, T value) throws IOException {
-    try {
-      SSLSocket.class.getMethod("setOption", SocketOption.class, Object.class).invoke(delegate, name, value);
-      return this;
-    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
-      throw new AssertionError();
-    }
-  }
-
-  @SuppressWarnings({
-      "MissingOverride", // Can only override with JDK 9+
-      "unchecked" // Using reflection to delegate.
-  })
-  public <T> T getOption(SocketOption<T> name) throws IOException {
-    try {
-      return (T) SSLSocket.class.getMethod("getOption", SocketOption.class).invoke(delegate, name);
-    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
-      throw new AssertionError();
-    }
-  }
-
-  @SuppressWarnings({
-      "MissingOverride", // Can only override with JDK 9+
-      "unchecked" // Using reflection to delegate.
-  })
-  public Set<SocketOption<?>> supportedOptions() {
-    try {
-      return (Set<SocketOption<?>>) SSLSocket.class.getMethod("supportedOptions").invoke(delegate);
-    } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
-      throw new AssertionError();
-    }
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/DelegatingSSLSocketFactory.java b/okhttp/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
deleted file mode 100644
index 5a5a3dc20a..0000000000
--- a/okhttp/src/test/java/okhttp3/DelegatingSSLSocketFactory.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.Socket;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-
-/**
- * A {@link SSLSocketFactory} that delegates calls. Sockets can be configured after creation by
- * overriding {@link #configureSocket(javax.net.ssl.SSLSocket)}.
- */
-public class DelegatingSSLSocketFactory extends SSLSocketFactory {
-
-  private final SSLSocketFactory delegate;
-
-  public DelegatingSSLSocketFactory(SSLSocketFactory delegate) {
-    this.delegate = delegate;
-  }
-
-  @Override public SSLSocket createSocket() throws IOException {
-    SSLSocket sslSocket = (SSLSocket) delegate.createSocket();
-    return configureSocket(sslSocket);
-  }
-
-  @Override public SSLSocket createSocket(String host, int port) throws IOException {
-    SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port);
-    return configureSocket(sslSocket);
-  }
-
-  @Override public SSLSocket createSocket(
-      String host, int port, InetAddress localAddress, int localPort) throws IOException {
-    SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port, localAddress, localPort);
-    return configureSocket(sslSocket);
-  }
-
-  @Override public SSLSocket createSocket(InetAddress host, int port) throws IOException {
-    SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port);
-    return configureSocket(sslSocket);
-  }
-
-  @Override public SSLSocket createSocket(
-      InetAddress host, int port, InetAddress localAddress, int localPort) throws IOException {
-    SSLSocket sslSocket = (SSLSocket) delegate.createSocket(host, port, localAddress, localPort);
-    return configureSocket(sslSocket);
-  }
-
-  @Override public String[] getDefaultCipherSuites() {
-    return delegate.getDefaultCipherSuites();
-  }
-
-  @Override public String[] getSupportedCipherSuites() {
-    return delegate.getSupportedCipherSuites();
-  }
-
-  @Override public SSLSocket createSocket(
-      Socket socket, String host, int port, boolean autoClose) throws IOException {
-    SSLSocket sslSocket = (SSLSocket) delegate.createSocket(socket, host, port, autoClose);
-    return configureSocket(sslSocket);
-  }
-
-  protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
-    // No-op by default.
-    return sslSocket;
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/DelegatingServerSocketFactory.java b/okhttp/src/test/java/okhttp3/DelegatingServerSocketFactory.java
deleted file mode 100644
index 09b3a25d09..0000000000
--- a/okhttp/src/test/java/okhttp3/DelegatingServerSocketFactory.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.ServerSocket;
-import javax.net.ServerSocketFactory;
-
-/**
- * A {@link ServerSocketFactory} that delegates calls. Sockets can be configured after creation by
- * overriding {@link #configureServerSocket(java.net.ServerSocket)}.
- */
-public class DelegatingServerSocketFactory extends ServerSocketFactory {
-
-  private final ServerSocketFactory delegate;
-
-  public DelegatingServerSocketFactory(ServerSocketFactory delegate) {
-    this.delegate = delegate;
-  }
-
-  @Override
-  public ServerSocket createServerSocket() throws IOException {
-    ServerSocket serverSocket = delegate.createServerSocket();
-    return configureServerSocket(serverSocket);
-  }
-
-  @Override
-  public ServerSocket createServerSocket(int port) throws IOException {
-    ServerSocket serverSocket = delegate.createServerSocket(port);
-    return configureServerSocket(serverSocket);
-  }
-
-  @Override
-  public ServerSocket createServerSocket(int port, int backlog) throws IOException {
-    ServerSocket serverSocket = delegate.createServerSocket(port, backlog);
-    return configureServerSocket(serverSocket);
-  }
-
-  @Override
-  public ServerSocket createServerSocket(int port, int backlog, InetAddress ifAddress)
-      throws IOException {
-    ServerSocket serverSocket = delegate.createServerSocket(port, backlog, ifAddress);
-    return configureServerSocket(serverSocket);
-  }
-
-  protected ServerSocket configureServerSocket(ServerSocket serverSocket) throws IOException {
-    // No-op by default.
-    return serverSocket;
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/DelegatingSocketFactory.java b/okhttp/src/test/java/okhttp3/DelegatingSocketFactory.java
deleted file mode 100644
index 33ac2f4e1a..0000000000
--- a/okhttp/src/test/java/okhttp3/DelegatingSocketFactory.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.Socket;
-import javax.net.SocketFactory;
-
-/**
- * A {@link SocketFactory} that delegates calls. Sockets can be configured after creation by
- * overriding {@link #configureSocket(java.net.Socket)}.
- */
-public class DelegatingSocketFactory extends SocketFactory {
-  private final SocketFactory delegate;
-
-  public DelegatingSocketFactory(SocketFactory delegate) {
-    this.delegate = delegate;
-  }
-
-  @Override public Socket createSocket() throws IOException {
-    Socket socket = delegate.createSocket();
-    return configureSocket(socket);
-  }
-
-  @Override public Socket createSocket(String host, int port) throws IOException {
-    Socket socket = delegate.createSocket(host, port);
-    return configureSocket(socket);
-  }
-
-  @Override public Socket createSocket(String host, int port, InetAddress localAddress,
-      int localPort) throws IOException {
-    Socket socket = delegate.createSocket(host, port, localAddress, localPort);
-    return configureSocket(socket);
-  }
-
-  @Override public Socket createSocket(InetAddress host, int port) throws IOException {
-    Socket socket = delegate.createSocket(host, port);
-    return configureSocket(socket);
-  }
-
-  @Override public Socket createSocket(InetAddress host, int port, InetAddress localAddress,
-      int localPort) throws IOException {
-    Socket socket = delegate.createSocket(host, port, localAddress, localPort);
-    return configureSocket(socket);
-  }
-
-  protected Socket configureSocket(Socket socket) throws IOException {
-    // No-op by default.
-    return socket;
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/DispatcherTest.java b/okhttp/src/test/java/okhttp3/DispatcherTest.java
deleted file mode 100644
index edcd981c8a..0000000000
--- a/okhttp/src/test/java/okhttp3/DispatcherTest.java
+++ /dev/null
@@ -1,331 +0,0 @@
-package okhttp3;
-
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.atomic.AtomicBoolean;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static java.util.concurrent.TimeUnit.SECONDS;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class DispatcherTest {
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  RecordingExecutor executor = new RecordingExecutor(this);
-  RecordingCallback callback = new RecordingCallback();
-  RecordingWebSocketListener webSocketListener = new RecordingWebSocketListener();
-  Dispatcher dispatcher = new Dispatcher(executor);
-  RecordingEventListener listener = new RecordingEventListener();
-  OkHttpClient client = clientTestRule.newClientBuilder()
-      .dispatcher(dispatcher)
-      .eventListener(listener)
-      .build();
-
-  @Before public void setUp() throws Exception {
-    dispatcher.setMaxRequests(20);
-    dispatcher.setMaxRequestsPerHost(10);
-    listener.forbidLock(dispatcher);
-  }
-
-  @Test public void maxRequestsZero() throws Exception {
-    try {
-      dispatcher.setMaxRequests(0);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void maxPerHostZero() throws Exception {
-    try {
-      dispatcher.setMaxRequestsPerHost(0);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void enqueuedJobsRunImmediately() throws Exception {
-    client.newCall(newRequest("http://a/1")).enqueue(callback);
-    executor.assertJobs("http://a/1");
-  }
-
-  @Test public void maxRequestsEnforced() throws Exception {
-    dispatcher.setMaxRequests(3);
-    client.newCall(newRequest("http://a/1")).enqueue(callback);
-    client.newCall(newRequest("http://a/2")).enqueue(callback);
-    client.newCall(newRequest("http://b/1")).enqueue(callback);
-    client.newCall(newRequest("http://b/2")).enqueue(callback);
-    executor.assertJobs("http://a/1", "http://a/2", "http://b/1");
-  }
-
-  @Test public void maxPerHostEnforced() throws Exception {
-    dispatcher.setMaxRequestsPerHost(2);
-    client.newCall(newRequest("http://a/1")).enqueue(callback);
-    client.newCall(newRequest("http://a/2")).enqueue(callback);
-    client.newCall(newRequest("http://a/3")).enqueue(callback);
-    executor.assertJobs("http://a/1", "http://a/2");
-  }
-
-  @Test public void maxPerHostNotEnforcedForWebSockets() {
-    dispatcher.setMaxRequestsPerHost(2);
-    client.newWebSocket(newRequest("http://a/1"), webSocketListener);
-    client.newWebSocket(newRequest("http://a/2"), webSocketListener);
-    client.newWebSocket(newRequest("http://a/3"), webSocketListener);
-    executor.assertJobs("http://a/1", "http://a/2", "http://a/3");
-  }
-
-  @Test public void increasingMaxRequestsPromotesJobsImmediately() throws Exception {
-    dispatcher.setMaxRequests(2);
-    client.newCall(newRequest("http://a/1")).enqueue(callback);
-    client.newCall(newRequest("http://b/1")).enqueue(callback);
-    client.newCall(newRequest("http://c/1")).enqueue(callback);
-    client.newCall(newRequest("http://a/2")).enqueue(callback);
-    client.newCall(newRequest("http://b/2")).enqueue(callback);
-    dispatcher.setMaxRequests(4);
-    executor.assertJobs("http://a/1", "http://b/1", "http://c/1", "http://a/2");
-  }
-
-  @Test public void increasingMaxPerHostPromotesJobsImmediately() throws Exception {
-    dispatcher.setMaxRequestsPerHost(2);
-    client.newCall(newRequest("http://a/1")).enqueue(callback);
-    client.newCall(newRequest("http://a/2")).enqueue(callback);
-    client.newCall(newRequest("http://a/3")).enqueue(callback);
-    client.newCall(newRequest("http://a/4")).enqueue(callback);
-    client.newCall(newRequest("http://a/5")).enqueue(callback);
-    dispatcher.setMaxRequestsPerHost(4);
-    executor.assertJobs("http://a/1", "http://a/2", "http://a/3", "http://a/4");
-  }
-
-  @Test public void oldJobFinishesNewJobCanRunDifferentHost() throws Exception {
-    dispatcher.setMaxRequests(1);
-    client.newCall(newRequest("http://a/1")).enqueue(callback);
-    client.newCall(newRequest("http://b/1")).enqueue(callback);
-    executor.finishJob("http://a/1");
-    executor.assertJobs("http://b/1");
-  }
-
-  @Test public void oldJobFinishesNewJobWithSameHostStarts() throws Exception {
-    dispatcher.setMaxRequests(2);
-    dispatcher.setMaxRequestsPerHost(1);
-    client.newCall(newRequest("http://a/1")).enqueue(callback);
-    client.newCall(newRequest("http://b/1")).enqueue(callback);
-    client.newCall(newRequest("http://b/2")).enqueue(callback);
-    client.newCall(newRequest("http://a/2")).enqueue(callback);
-    executor.finishJob("http://a/1");
-    executor.assertJobs("http://b/1", "http://a/2");
-  }
-
-  @Test public void oldJobFinishesNewJobCantRunDueToHostLimit() throws Exception {
-    dispatcher.setMaxRequestsPerHost(1);
-    client.newCall(newRequest("http://a/1")).enqueue(callback);
-    client.newCall(newRequest("http://b/1")).enqueue(callback);
-    client.newCall(newRequest("http://a/2")).enqueue(callback);
-    executor.finishJob("http://b/1");
-    executor.assertJobs("http://a/1");
-  }
-
-  @Test public void enqueuedCallsStillRespectMaxCallsPerHost() throws Exception {
-    dispatcher.setMaxRequests(1);
-    dispatcher.setMaxRequestsPerHost(1);
-    client.newCall(newRequest("http://a/1")).enqueue(callback);
-    client.newCall(newRequest("http://b/1")).enqueue(callback);
-    client.newCall(newRequest("http://b/2")).enqueue(callback);
-    client.newCall(newRequest("http://b/3")).enqueue(callback);
-    dispatcher.setMaxRequests(3);
-    executor.finishJob("http://a/1");
-    executor.assertJobs("http://b/1");
-  }
-
-  @Test public void cancelingRunningJobTakesNoEffectUntilJobFinishes() throws Exception {
-    dispatcher.setMaxRequests(1);
-    Call c1 = client.newCall(newRequest("http://a/1", "tag1"));
-    Call c2 = client.newCall(newRequest("http://a/2"));
-    c1.enqueue(callback);
-    c2.enqueue(callback);
-    c1.cancel();
-    executor.assertJobs("http://a/1");
-    executor.finishJob("http://a/1");
-    executor.assertJobs("http://a/2");
-  }
-
-  @Test public void asyncCallAccessors() throws Exception {
-    dispatcher.setMaxRequests(3);
-    Call a1 = client.newCall(newRequest("http://a/1"));
-    Call a2 = client.newCall(newRequest("http://a/2"));
-    Call a3 = client.newCall(newRequest("http://a/3"));
-    Call a4 = client.newCall(newRequest("http://a/4"));
-    Call a5 = client.newCall(newRequest("http://a/5"));
-    a1.enqueue(callback);
-    a2.enqueue(callback);
-    a3.enqueue(callback);
-    a4.enqueue(callback);
-    a5.enqueue(callback);
-    assertThat(dispatcher.runningCallsCount()).isEqualTo(3);
-    assertThat(dispatcher.queuedCallsCount()).isEqualTo(2);
-    assertThat(dispatcher.runningCalls()).containsExactlyInAnyOrder(a1, a2, a3);
-    assertThat(dispatcher.queuedCalls()).containsExactlyInAnyOrder(a4, a5);
-  }
-
-  @Test public void synchronousCallAccessors() throws Exception {
-    CountDownLatch ready = new CountDownLatch(2);
-    CountDownLatch waiting = new CountDownLatch(1);
-    client = client.newBuilder()
-        .addInterceptor(chain -> {
-          try {
-            ready.countDown();
-            waiting.await();
-          } catch (InterruptedException e) {
-            throw new AssertionError();
-          }
-          throw new IOException();
-        })
-        .build();
-
-    Call a1 = client.newCall(newRequest("http://a/1"));
-    Call a2 = client.newCall(newRequest("http://a/2"));
-    Call a3 = client.newCall(newRequest("http://a/3"));
-    Call a4 = client.newCall(newRequest("http://a/4"));
-    Thread t1 = makeSynchronousCall(a1);
-    Thread t2 = makeSynchronousCall(a2);
-
-    // We created 4 calls and started 2 of them. That's 2 running calls and 0 queued.
-    ready.await();
-    assertThat(dispatcher.runningCallsCount()).isEqualTo(2);
-    assertThat(dispatcher.queuedCallsCount()).isEqualTo(0);
-    assertThat(dispatcher.runningCalls()).containsExactlyInAnyOrder(a1, a2);
-    assertThat(dispatcher.queuedCalls()).isEmpty();
-
-    // Cancel some calls. That doesn't impact running or queued.
-    a2.cancel();
-    a3.cancel();
-    assertThat(dispatcher.runningCalls()).containsExactlyInAnyOrder(a1, a2);
-    assertThat(dispatcher.queuedCalls()).isEmpty();
-
-    // Let the calls finish.
-    waiting.countDown();
-    t1.join();
-    t2.join();
-
-    // Now we should have 0 running calls and 0 queued calls.
-    assertThat(dispatcher.runningCallsCount()).isEqualTo(0);
-    assertThat(dispatcher.queuedCallsCount()).isEqualTo(0);
-    assertThat(dispatcher.runningCalls()).isEmpty();
-    assertThat(dispatcher.queuedCalls()).isEmpty();
-
-    assertThat(a1.isExecuted()).isTrue();
-    assertThat(a1.isCanceled()).isFalse();
-
-    assertThat(a2.isExecuted()).isTrue();
-    assertThat(a2.isCanceled()).isTrue();
-
-    assertThat(a3.isExecuted()).isFalse();
-    assertThat(a3.isCanceled()).isTrue();
-
-    assertThat(a4.isExecuted()).isFalse();
-    assertThat(a4.isCanceled()).isFalse();
-  }
-
-  @Test public void idleCallbackInvokedWhenIdle() throws Exception {
-    AtomicBoolean idle = new AtomicBoolean();
-    dispatcher.setIdleCallback(() -> idle.set(true));
-
-    client.newCall(newRequest("http://a/1")).enqueue(callback);
-    client.newCall(newRequest("http://a/2")).enqueue(callback);
-    executor.finishJob("http://a/1");
-    assertThat(idle.get()).isFalse();
-
-    CountDownLatch ready = new CountDownLatch(1);
-    CountDownLatch proceed = new CountDownLatch(1);
-    client = client.newBuilder()
-        .addInterceptor(chain -> {
-          ready.countDown();
-          try {
-            proceed.await(5, SECONDS);
-          } catch (InterruptedException e) {
-            throw new RuntimeException(e);
-          }
-          return chain.proceed(chain.request());
-        })
-        .build();
-
-    Thread t1 = makeSynchronousCall(client.newCall(newRequest("http://a/3")));
-    ready.await(5, SECONDS);
-    executor.finishJob("http://a/2");
-    assertThat(idle.get()).isFalse();
-
-    proceed.countDown();
-    t1.join();
-    assertThat(idle.get()).isTrue();
-  }
-
-  @Test public void executionRejectedImmediately() throws Exception {
-    Request request = newRequest("http://a/1");
-    executor.shutdown();
-    client.newCall(request).enqueue(callback);
-    callback.await(request.url()).assertFailure(InterruptedIOException.class);
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "CallFailed");
-  }
-
-  @Test public void executionRejectedAfterMaxRequestsChange() throws Exception {
-    Request request1 = newRequest("http://a/1");
-    Request request2 = newRequest("http://a/2");
-    dispatcher.setMaxRequests(1);
-    client.newCall(request1).enqueue(callback);
-    executor.shutdown();
-    client.newCall(request2).enqueue(callback);
-    dispatcher.setMaxRequests(2); // Trigger promotion.
-    callback.await(request2.url()).assertFailure(InterruptedIOException.class);
-
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "CallStart",
-        "CallFailed");
-  }
-
-  @Test public void executionRejectedAfterMaxRequestsPerHostChange() throws Exception {
-    Request request1 = newRequest("http://a/1");
-    Request request2 = newRequest("http://a/2");
-    dispatcher.setMaxRequestsPerHost(1);
-    client.newCall(request1).enqueue(callback);
-    executor.shutdown();
-    client.newCall(request2).enqueue(callback);
-    dispatcher.setMaxRequestsPerHost(2); // Trigger promotion.
-    callback.await(request2.url()).assertFailure(InterruptedIOException.class);
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "CallStart",
-        "CallFailed");
-  }
-
-  @Test public void executionRejectedAfterPrecedingCallFinishes() throws Exception {
-    Request request1 = newRequest("http://a/1");
-    Request request2 = newRequest("http://a/2");
-    dispatcher.setMaxRequests(1);
-    client.newCall(request1).enqueue(callback);
-    executor.shutdown();
-    client.newCall(request2).enqueue(callback);
-    executor.finishJob("http://a/1"); // Trigger promotion.
-    callback.await(request2.url()).assertFailure(InterruptedIOException.class);
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "CallStart",
-        "CallFailed");
-  }
-
-  private Thread makeSynchronousCall(Call call) {
-    Thread thread = new Thread(() -> {
-      try {
-        call.execute();
-        throw new AssertionError();
-      } catch (IOException expected) {
-      }
-    });
-    thread.start();
-    return thread;
-  }
-
-  private Request newRequest(String url) {
-    return new Request.Builder().url(url).build();
-  }
-
-  private Request newRequest(String url, String tag) {
-    return new Request.Builder().url(url).tag(tag).build();
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/DuplexTest.java b/okhttp/src/test/java/okhttp3/DuplexTest.java
deleted file mode 100644
index d33b3e8b61..0000000000
--- a/okhttp/src/test/java/okhttp3/DuplexTest.java
+++ /dev/null
@@ -1,535 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.ProtocolException;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.duplex.AsyncRequestBody;
-import okhttp3.internal.duplex.MwsDuplexAccess;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.mockwebserver.internal.duplex.MockDuplexResponseBody;
-import okhttp3.testing.PlatformRule;
-import okhttp3.tls.HandshakeCertificates;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TestRule;
-import org.junit.rules.Timeout;
-
-import static java.util.Arrays.asList;
-import static junit.framework.TestCase.assertTrue;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class DuplexTest {
-  @Rule public final PlatformRule platform = new PlatformRule();
-  @Rule public final TestRule timeout = new Timeout(30_000, TimeUnit.MILLISECONDS);
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  private RecordingEventListener listener = new RecordingEventListener();
-  private HandshakeCertificates handshakeCertificates = localhost();
-  private OkHttpClient client = clientTestRule.newClientBuilder()
-      .eventListener(listener)
-      .build();
-
-  @Before public void setUp() {
-    platform.assumeNotOpenJSSE();
-    platform.assumeHttp2Support();
-  }
-
-  @Test public void http1DoesntSupportDuplex() throws IOException {
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(new AsyncRequestBody())
-        .build());
-    try {
-      call.execute();
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  @Test public void trueDuplexClientWritesFirst() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
-        new MockResponse()
-            .clearHeaders(),
-        new MockDuplexResponseBody()
-            .receiveRequest("request A\n")
-            .sendResponse("response B\n")
-            .receiveRequest("request C\n")
-            .sendResponse("response D\n")
-            .receiveRequest("request E\n")
-            .sendResponse("response F\n")
-            .exhaustRequest()
-            .exhaustResponse());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(new AsyncRequestBody())
-        .build());
-
-    try (Response response = call.execute()) {
-      BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
-      requestBody.writeUtf8("request A\n");
-      requestBody.flush();
-
-      BufferedSource responseBody = response.body().source();
-      assertThat(responseBody.readUtf8Line()).isEqualTo("response B");
-
-      requestBody.writeUtf8("request C\n");
-      requestBody.flush();
-      assertThat(responseBody.readUtf8Line()).isEqualTo("response D");
-
-      requestBody.writeUtf8("request E\n");
-      requestBody.flush();
-      assertThat(responseBody.readUtf8Line()).isEqualTo("response F");
-
-      requestBody.close();
-      assertThat(responseBody.readUtf8Line()).isNull();
-    }
-
-    mockDuplexResponseBody.awaitSuccess();
-  }
-
-  @Test public void trueDuplexServerWritesFirst() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
-        new MockResponse()
-            .clearHeaders(),
-        new MockDuplexResponseBody()
-            .sendResponse("response A\n")
-            .receiveRequest("request B\n")
-            .sendResponse("response C\n")
-            .receiveRequest("request D\n")
-            .sendResponse("response E\n")
-            .receiveRequest("request F\n")
-            .exhaustResponse()
-            .exhaustRequest());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(new AsyncRequestBody())
-        .build());
-
-    try (Response response = call.execute()) {
-      BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
-      BufferedSource responseBody = response.body().source();
-
-      assertThat(responseBody.readUtf8Line()).isEqualTo("response A");
-      requestBody.writeUtf8("request B\n");
-      requestBody.flush();
-
-      assertThat(responseBody.readUtf8Line()).isEqualTo("response C");
-      requestBody.writeUtf8("request D\n");
-      requestBody.flush();
-
-      assertThat(responseBody.readUtf8Line()).isEqualTo("response E");
-      requestBody.writeUtf8("request F\n");
-      requestBody.flush();
-
-      assertThat(responseBody.readUtf8Line()).isNull();
-      requestBody.close();
-    }
-
-    mockDuplexResponseBody.awaitSuccess();
-  }
-
-  @Test public void clientReadsHeadersDataTrailers() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
-        new MockResponse()
-            .clearHeaders()
-            .addHeader("h1", "v1")
-            .addHeader("h2", "v2")
-            .setTrailers(Headers.of("trailers", "boom")),
-        new MockDuplexResponseBody()
-            .sendResponse("ok")
-            .exhaustResponse());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    try (Response response = call.execute()) {
-      assertThat(response.headers()).isEqualTo(Headers.of("h1", "v1", "h2", "v2"));
-
-      BufferedSource responseBody = response.body().source();
-      assertThat(responseBody.readUtf8(2)).isEqualTo("ok");
-      assertTrue(responseBody.exhausted());
-      assertThat(response.trailers()).isEqualTo(Headers.of("trailers", "boom"));
-    }
-
-    mockDuplexResponseBody.awaitSuccess();
-  }
-
-  @Test public void serverReadsHeadersData() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
-        new MockResponse()
-            .clearHeaders()
-            .addHeader("h1", "v1")
-            .addHeader("h2", "v2"),
-        new MockDuplexResponseBody()
-            .exhaustResponse()
-            .receiveRequest("hey\n")
-            .receiveRequest("whats going on\n")
-            .exhaustRequest());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .method("POST", new AsyncRequestBody())
-        .build();
-    Call call = client.newCall(request);
-
-    try (Response response = call.execute()) {
-      BufferedSink sink = ((AsyncRequestBody) request.body()).takeSink();
-      sink.writeUtf8("hey\n");
-      sink.writeUtf8("whats going on\n");
-      sink.close();
-    }
-
-    mockDuplexResponseBody.awaitSuccess();
-  }
-
-  @Test public void requestBodyEndsAfterResponseBody() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
-        new MockResponse()
-            .clearHeaders(),
-        new MockDuplexResponseBody()
-            .exhaustResponse()
-            .receiveRequest("request A\n")
-            .exhaustRequest());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(new AsyncRequestBody())
-        .build());
-
-    try (Response response = call.execute()) {
-      BufferedSource responseBody = response.body().source();
-      assertTrue(responseBody.exhausted());
-
-      BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
-      requestBody.writeUtf8("request A\n");
-      requestBody.close();
-    }
-
-    mockDuplexResponseBody.awaitSuccess();
-
-    assertThat(listener.recordedEventTypes()).containsExactly(
-        "CallStart", "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd", "ConnectStart",
-        "SecureConnectStart", "SecureConnectEnd", "ConnectEnd", "ConnectionAcquired",
-        "RequestHeadersStart", "RequestHeadersEnd", "RequestBodyStart", "ResponseHeadersStart",
-        "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "RequestBodyEnd",
-        "ConnectionReleased", "CallEnd");
-  }
-
-  @Test public void duplexWith100Continue() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-
-    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
-        new MockResponse()
-            .clearHeaders()
-            .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE),
-        new MockDuplexResponseBody()
-            .receiveRequest("request body\n")
-            .sendResponse("response body\n")
-            .exhaustRequest());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .header("Expect", "100-continue")
-        .post(new AsyncRequestBody())
-        .build());
-
-    try (Response response = call.execute()) {
-      BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
-      requestBody.writeUtf8("request body\n");
-      requestBody.flush();
-
-      BufferedSource responseBody = response.body().source();
-      assertThat(responseBody.readUtf8Line()).isEqualTo("response body");
-
-      requestBody.close();
-      assertThat(responseBody.readUtf8Line()).isNull();
-    }
-
-    mockDuplexResponseBody.awaitSuccess();
-  }
-
-  /**
-   * Duplex calls that have follow-ups are weird. By the time we know there's a follow-up we've
-   * already split off another thread to stream the request body. Because we permit at most one
-   * exchange at a time we break the request stream out from under that writer.
-   */
-  @Test public void duplexWithRedirect() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-
-    CountDownLatch duplexResponseSent = new CountDownLatch(1);
-    listener = new RecordingEventListener() {
-      @Override public void responseHeadersEnd(Call call, Response response) {
-        try {
-          // Wait for the server to send the duplex response before acting on the 301 response
-          // and resetting the stream.
-          duplexResponseSent.await();
-        } catch (InterruptedException e) {
-          throw new AssertionError();
-        }
-        super.responseHeadersEnd(call, response);
-      }
-    };
-
-    client = client.newBuilder()
-        .eventListener(listener)
-        .build();
-
-    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
-        new MockResponse()
-            .clearHeaders()
-            .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
-            .addHeader("Location: /b"),
-        new MockDuplexResponseBody()
-            .sendResponse("/a has moved!\n", duplexResponseSent)
-            .requestIOException()
-            .exhaustResponse());
-    server.enqueue(new MockResponse()
-        .setBody("this is /b"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(new AsyncRequestBody())
-        .build());
-
-    try (Response response = call.execute()) {
-      BufferedSource responseBody = response.body().source();
-      assertThat(responseBody.readUtf8Line()).isEqualTo("this is /b");
-    }
-
-    BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
-    try {
-      requestBody.writeUtf8("request body\n");
-      requestBody.flush();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("stream was reset: CANCEL");
-    }
-
-    mockDuplexResponseBody.awaitSuccess();
-
-    assertThat(listener.recordedEventTypes()).containsExactly(
-        "CallStart", "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd", "ConnectStart",
-        "SecureConnectStart", "SecureConnectEnd", "ConnectEnd", "ConnectionAcquired",
-        "RequestHeadersStart", "RequestHeadersEnd", "RequestBodyStart", "ResponseHeadersStart",
-        "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "RequestHeadersStart",
-        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ResponseBodyEnd", "ConnectionReleased", "CallEnd", "RequestFailed");
-  }
-
-  /**
-   * Auth requires follow-ups. Unlike redirects, the auth follow-up also has a request body. This
-   * test makes a single call with two duplex requests!
-   */
-  @Test public void duplexWithAuthChallenge() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-
-    String credential = Credentials.basic("jesse", "secret");
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential, null))
-        .build();
-
-    MockDuplexResponseBody mockResponseBody1 = enqueueResponseWithBody(
-        new MockResponse()
-            .clearHeaders()
-            .setResponseCode(HttpURLConnection.HTTP_UNAUTHORIZED),
-        new MockDuplexResponseBody()
-            .sendResponse("please authenticate!\n")
-            .requestIOException()
-            .exhaustResponse());
-    MockDuplexResponseBody mockResponseBody2 = enqueueResponseWithBody(
-        new MockResponse()
-            .clearHeaders(),
-        new MockDuplexResponseBody()
-            .sendResponse("response body\n")
-            .exhaustResponse()
-            .receiveRequest("request body\n")
-            .exhaustRequest());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(new AsyncRequestBody())
-        .build());
-
-    Response response2 = call.execute();
-
-    // First duplex request is detached with violence.
-    BufferedSink requestBody1 = ((AsyncRequestBody) call.request().body()).takeSink();
-    try {
-      requestBody1.writeUtf8("not authenticated\n");
-      requestBody1.flush();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("stream was reset: CANCEL");
-    }
-    mockResponseBody1.awaitSuccess();
-
-    // Second duplex request proceeds normally.
-    BufferedSink requestBody2 = ((AsyncRequestBody) call.request().body()).takeSink();
-    requestBody2.writeUtf8("request body\n");
-    requestBody2.close();
-    BufferedSource responseBody2 = response2.body().source();
-    assertThat(responseBody2.readUtf8Line()).isEqualTo("response body");
-    assertTrue(responseBody2.exhausted());
-    mockResponseBody2.awaitSuccess();
-
-    // No more requests attempted!
-    ((AsyncRequestBody) call.request().body()).assertNoMoreSinks();
-  }
-
-  @Test public void fullCallTimeoutAppliesToSetup() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-
-    server.enqueue(new MockResponse()
-        .setHeadersDelay(500, TimeUnit.MILLISECONDS));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(new AsyncRequestBody())
-        .build();
-
-    Call call = client.newCall(request);
-    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("timeout");
-      assertTrue(call.isCanceled());
-    }
-  }
-
-  @Test public void fullCallTimeoutDoesNotApplyOnceConnected() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-
-    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
-        new MockResponse()
-            .clearHeaders(),
-        new MockDuplexResponseBody()
-            .sendResponse("response A\n")
-            .sleep(750, TimeUnit.MILLISECONDS)
-            .sendResponse("response B\n")
-            .receiveRequest("request C\n")
-            .exhaustResponse()
-            .exhaustRequest());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(new AsyncRequestBody())
-        .build();
-
-    Call call = client.newCall(request);
-    call.timeout().timeout(500, TimeUnit.MILLISECONDS); // Long enough for the first TLS handshake.
-
-    try (Response response = call.execute()) {
-      BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
-
-      BufferedSource responseBody = response.body().source();
-      assertThat(responseBody.readUtf8Line()).isEqualTo("response A");
-      assertThat(responseBody.readUtf8Line()).isEqualTo("response B");
-
-      requestBody.writeUtf8("request C\n");
-      requestBody.close();
-      assertThat(responseBody.readUtf8Line()).isNull();
-    }
-
-    mockDuplexResponseBody.awaitSuccess();
-  }
-
-  @Test public void duplexWithRewriteInterceptors() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    MockDuplexResponseBody mockDuplexResponseBody = enqueueResponseWithBody(
-        new MockResponse()
-            .clearHeaders(),
-        new MockDuplexResponseBody()
-            .receiveRequest("REQUEST A\n")
-            .sendResponse("response B\n")
-            .exhaustRequest()
-            .exhaustResponse());
-
-    client = client.newBuilder()
-        .addInterceptor(new UppercaseRequestInterceptor())
-        .addInterceptor(new UppercaseResponseInterceptor())
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(new AsyncRequestBody())
-        .build());
-
-    try (Response response = call.execute()) {
-      BufferedSink requestBody = ((AsyncRequestBody) call.request().body()).takeSink();
-      requestBody.writeUtf8("request A\n");
-      requestBody.flush();
-
-      BufferedSource responseBody = response.body().source();
-      assertThat(responseBody.readUtf8Line()).isEqualTo("RESPONSE B");
-
-      requestBody.close();
-      assertThat(responseBody.readUtf8Line()).isNull();
-    }
-
-    mockDuplexResponseBody.awaitSuccess();
-  }
-
-  private MockDuplexResponseBody enqueueResponseWithBody(
-      MockResponse response, MockDuplexResponseBody body) {
-    MwsDuplexAccess.instance.setBody(response, body);
-    server.enqueue(response);
-    return body;
-  }
-
-  /**
-   * Tests that use this will fail unless boot classpath is set. Ex. {@code
-   * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
-   */
-  private void enableProtocol(Protocol protocol) {
-    enableTls();
-    client = client.newBuilder()
-        .protocols(asList(protocol, Protocol.HTTP_1_1))
-        .build();
-    server.setProtocols(client.protocols());
-  }
-
-  private void enableTls() {
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/EventListenerTest.java b/okhttp/src/test/java/okhttp3/EventListenerTest.java
deleted file mode 100644
index f5a8fb3ae9..0000000000
--- a/okhttp/src/test/java/okhttp3/EventListenerTest.java
+++ /dev/null
@@ -1,1282 +0,0 @@
-/*
- * Copyright (C) 2017 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.net.UnknownHostException;
-import java.util.Collections;
-import java.util.List;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import okhttp3.RecordingEventListener.CallEnd;
-import okhttp3.RecordingEventListener.CallFailed;
-import okhttp3.RecordingEventListener.ConnectEnd;
-import okhttp3.RecordingEventListener.ConnectFailed;
-import okhttp3.RecordingEventListener.ConnectStart;
-import okhttp3.RecordingEventListener.ConnectionAcquired;
-import okhttp3.RecordingEventListener.DnsEnd;
-import okhttp3.RecordingEventListener.DnsStart;
-import okhttp3.RecordingEventListener.RequestBodyEnd;
-import okhttp3.RecordingEventListener.RequestHeadersEnd;
-import okhttp3.RecordingEventListener.ResponseBodyEnd;
-import okhttp3.RecordingEventListener.ResponseFailed;
-import okhttp3.RecordingEventListener.ResponseHeadersEnd;
-import okhttp3.RecordingEventListener.SecureConnectEnd;
-import okhttp3.RecordingEventListener.SecureConnectStart;
-import okhttp3.internal.DoubleInetAddressDns;
-import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.connection.RealConnectionPool;
-import okhttp3.logging.HttpLoggingInterceptor;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.testing.PlatformRule;
-import okhttp3.tls.HandshakeCertificates;
-import okio.Buffer;
-import okio.BufferedSink;
-import org.hamcrest.BaseMatcher;
-import org.hamcrest.CoreMatchers;
-import org.hamcrest.Description;
-import org.hamcrest.Matcher;
-import org.junit.After;
-import org.junit.Assert;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.Timeout;
-
-import static java.util.Arrays.asList;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.hamcrest.CoreMatchers.any;
-import static org.hamcrest.CoreMatchers.equalTo;
-import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeThat;
-
-public final class EventListenerTest {
-  public static final Matcher<Response> anyResponse = CoreMatchers.any(Response.class);
-
-  @Rule public final PlatformRule platform = new PlatformRule();
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-  @Rule public final Timeout timeoutRule = new Timeout(20, TimeUnit.SECONDS);
-
-  private final RecordingEventListener listener = new RecordingEventListener();
-  private final HandshakeCertificates handshakeCertificates = localhost();
-
-  private OkHttpClient client = clientTestRule.newClientBuilder()
-      .eventListener(listener)
-      .build();
-  private SocksProxy socksProxy;
-
-  @Before public void setUp() {
-    platform.assumeNotOpenJSSE();
-
-    listener.forbidLock(RealConnectionPool.Companion.get(client.connectionPool()));
-    listener.forbidLock(client.dispatcher());
-  }
-
-  @After public void tearDown() throws Exception {
-    if (socksProxy != null) {
-      socksProxy.shutdown();
-    }
-  }
-
-  @Test public void successfulCallEventSequence() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.body().string()).isEqualTo("abc");
-    response.body().close();
-
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
-        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
-        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
-        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-  }
-
-  @Test public void successfulCallEventSequenceForEnqueue() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    final CountDownLatch completionLatch = new CountDownLatch(1);
-    Callback callback = new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-        completionLatch.countDown();
-      }
-
-      @Override public void onResponse(Call call, Response response) {
-        response.close();
-        completionLatch.countDown();
-      }
-    };
-
-    call.enqueue(callback);
-
-    completionLatch.await();
-
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
-        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
-        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
-        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-  }
-
-  @Test public void failedCallEventSequence() {
-    server.enqueue(new MockResponse().setHeadersDelay(2, TimeUnit.SECONDS));
-
-    client = client.newBuilder().readTimeout(250, TimeUnit.MILLISECONDS).build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isIn("timeout", "Read timed out");
-    }
-
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
-        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
-        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
-        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseFailed", "ConnectionReleased",
-        "CallFailed");
-  }
-
-  @Test public void failedDribbledCallEventSequence() throws IOException {
-    server.enqueue(new MockResponse().setBody("0123456789")
-        .throttleBody(2, 100, TimeUnit.MILLISECONDS)
-        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
-
-    client = client.newBuilder()
-        .protocols(Collections.singletonList(Protocol.HTTP_1_1))
-        .readTimeout(250, TimeUnit.MILLISECONDS)
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    Response response = call.execute();
-    try {
-      response.body().string();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("unexpected end of stream");
-    }
-
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
-        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
-        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
-        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ResponseFailed", "ConnectionReleased", "CallFailed");
-    ResponseFailed responseFailed = listener.removeUpToEvent(ResponseFailed.class);
-    assertThat(responseFailed.ioe.getMessage()).isEqualTo("unexpected end of stream");
-  }
-
-  @Test public void canceledCallEventSequence() {
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    call.cancel();
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("Canceled");
-    }
-
-    assertThat(listener.recordedEventTypes())
-        .containsExactly("CallStart", "ProxySelectStart", "ProxySelectEnd", "CallFailed");
-  }
-
-  private void assertSuccessfulEventOrder(Matcher<Response> responseMatcher) throws IOException {
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertThat(response.code()).isEqualTo(200);
-    response.body().string();
-    response.body().close();
-
-    assumeThat(response, responseMatcher);
-
-    assertThat(listener.recordedEventTypes()).containsExactly(
-        "CallStart", "ProxySelectStart", "ProxySelectEnd",
-        "DnsStart", "DnsEnd", "ConnectStart",
-        "SecureConnectStart", "SecureConnectEnd", "ConnectEnd", "ConnectionAcquired",
-        "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd",
-        "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-  }
-
-  @Test public void secondCallEventSequence() throws IOException {
-    enableTlsWithTunnel(false);
-    server.setProtocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-
-    client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build()).execute().close();
-
-    listener.removeUpToEvent(CallEnd.class);
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    response.close();
-
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
-        "ProxySelectStart", "ProxySelectEnd", "ConnectionAcquired",
-        "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd",
-        "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-  }
-
-  private void assertBytesReadWritten(RecordingEventListener listener,
-      @Nullable Matcher<Long> requestHeaderLength, @Nullable Matcher<Long> requestBodyBytes,
-      @Nullable Matcher<Long> responseHeaderLength, @Nullable Matcher<Long> responseBodyBytes) {
-
-    if (requestHeaderLength != null) {
-      RequestHeadersEnd responseHeadersEnd = listener.removeUpToEvent(RequestHeadersEnd.class);
-      Assert.assertThat("request header length", responseHeadersEnd.headerLength,
-          requestHeaderLength);
-    } else {
-      assertThat(listener.recordedEventTypes()).doesNotContain("RequestHeadersEnd");
-    }
-
-    if (requestBodyBytes != null) {
-      RequestBodyEnd responseBodyEnd = listener.removeUpToEvent(RequestBodyEnd.class);
-      Assert.assertThat("request body bytes", responseBodyEnd.bytesWritten, requestBodyBytes);
-    } else {
-      assertThat(listener.recordedEventTypes()).doesNotContain("RequestBodyEnd");
-    }
-
-    if (responseHeaderLength != null) {
-      ResponseHeadersEnd responseHeadersEnd = listener.removeUpToEvent(ResponseHeadersEnd.class);
-      Assert.assertThat("response header length", responseHeadersEnd.headerLength,
-          responseHeaderLength);
-    } else {
-      assertThat(listener.recordedEventTypes()).doesNotContain("ResponseHeadersEnd");
-    }
-
-    if (responseBodyBytes != null) {
-      ResponseBodyEnd responseBodyEnd = listener.removeUpToEvent(ResponseBodyEnd.class);
-      Assert.assertThat("response body bytes", responseBodyEnd.bytesRead, responseBodyBytes);
-    } else {
-      assertThat(listener.recordedEventTypes()).doesNotContain("ResponseBodyEnd");
-    }
-  }
-
-  private Matcher<Long> greaterThan(final long value) {
-    return new BaseMatcher<Long>() {
-      @Override public void describeTo(Description description) {
-        description.appendText("> " + value);
-      }
-
-      @Override public boolean matches(Object o) {
-        return ((Long) o) > value;
-      }
-    };
-  }
-
-  private Matcher<Long> lessThan(final long value) {
-    return new BaseMatcher<Long>() {
-      @Override public void describeTo(Description description) {
-        description.appendText("< " + value);
-      }
-
-      @Override public boolean matches(Object o) {
-        return ((Long) o) < value;
-      }
-    };
-  }
-
-  private Matcher<Response> matchesProtocol(final Protocol protocol) {
-    return new BaseMatcher<Response>() {
-      @Override public void describeTo(Description description) {
-        description.appendText("is HTTP/2");
-      }
-
-      @Override public boolean matches(Object o) {
-        return ((Response) o).protocol() == protocol;
-      }
-    };
-  }
-
-  @Test public void successfulEmptyH2CallEventSequence() throws IOException {
-    enableTlsWithTunnel(false);
-    server.setProtocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
-    server.enqueue(new MockResponse());
-
-    assertSuccessfulEventOrder(matchesProtocol(Protocol.HTTP_2));
-
-    assertBytesReadWritten(listener, any(Long.class), null, greaterThan(0L),
-        equalTo(0L));
-  }
-
-  @Test public void successfulEmptyHttpsCallEventSequence() throws IOException {
-    enableTlsWithTunnel(false);
-    server.setProtocols(asList(Protocol.HTTP_1_1));
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    assertSuccessfulEventOrder(anyResponse);
-
-    assertBytesReadWritten(listener, any(Long.class), null, greaterThan(0L),
-        equalTo(3L));
-  }
-
-  @Test public void successfulChunkedHttpsCallEventSequence() throws IOException {
-    enableTlsWithTunnel(false);
-    server.setProtocols(asList(Protocol.HTTP_1_1));
-    server.enqueue(
-        new MockResponse().setBodyDelay(100, TimeUnit.MILLISECONDS).setChunkedBody("Hello!", 2));
-
-    assertSuccessfulEventOrder(anyResponse);
-
-    assertBytesReadWritten(listener, any(Long.class), null, greaterThan(0L),
-        equalTo(6L));
-  }
-
-  @Test public void successfulChunkedH2CallEventSequence() throws IOException {
-    enableTlsWithTunnel(false);
-    server.setProtocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
-    server.enqueue(
-        new MockResponse().setBodyDelay(100, TimeUnit.MILLISECONDS).setChunkedBody("Hello!", 2));
-
-    assertSuccessfulEventOrder(matchesProtocol(Protocol.HTTP_2));
-
-    assertBytesReadWritten(listener, any(Long.class), null, equalTo(0L),
-        greaterThan(6L));
-  }
-
-  @Test public void successfulDnsLookup() throws IOException {
-    server.enqueue(new MockResponse());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertThat(response.code()).isEqualTo(200);
-    response.body().close();
-
-    DnsStart dnsStart = listener.removeUpToEvent(DnsStart.class);
-    assertThat(dnsStart.call).isSameAs(call);
-    assertThat(dnsStart.domainName).isEqualTo(server.getHostName());
-
-    DnsEnd dnsEnd = listener.removeUpToEvent(DnsEnd.class);
-    assertThat(dnsEnd.call).isSameAs(call);
-    assertThat(dnsEnd.domainName).isEqualTo(server.getHostName());
-    assertThat(dnsEnd.inetAddressList.size()).isEqualTo(1);
-  }
-
-  @Test public void noDnsLookupOnPooledConnection() throws IOException {
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-
-    // Seed the pool.
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-    assertThat(response1.code()).isEqualTo(200);
-    response1.body().close();
-
-    listener.clearAllEvents();
-
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    assertThat(response2.code()).isEqualTo(200);
-    response2.body().close();
-
-    List<String> recordedEvents = listener.recordedEventTypes();
-    assertThat(recordedEvents).doesNotContain("DnsStart");
-    assertThat(recordedEvents).doesNotContain("DnsEnd");
-  }
-
-  @Test public void multipleDnsLookupsForSingleCall() throws IOException {
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .setHeader("Location", "http://www.fakeurl:" + server.getPort()));
-    server.enqueue(new MockResponse());
-
-    FakeDns dns = new FakeDns();
-    dns.set("fakeurl", client.dns().lookup(server.getHostName()));
-    dns.set("www.fakeurl", client.dns().lookup(server.getHostName()));
-
-    client = client.newBuilder()
-        .dns(dns)
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url("http://fakeurl:" + server.getPort())
-        .build());
-    Response response = call.execute();
-    assertThat(response.code()).isEqualTo(200);
-    response.body().close();
-
-    listener.removeUpToEvent(DnsStart.class);
-    listener.removeUpToEvent(DnsEnd.class);
-    listener.removeUpToEvent(DnsStart.class);
-    listener.removeUpToEvent(DnsEnd.class);
-  }
-
-  @Test public void failedDnsLookup() {
-    client = client.newBuilder()
-        .dns(new FakeDns())
-        .build();
-    Call call = client.newCall(new Request.Builder()
-        .url("http://fakeurl/")
-        .build());
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    listener.removeUpToEvent(DnsStart.class);
-
-    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
-    assertThat(callFailed.call).isSameAs(call);
-    assertThat(callFailed.ioe).isInstanceOf(UnknownHostException.class);
-  }
-
-  @Test public void emptyDnsLookup() {
-    Dns emptyDns = hostname -> Collections.emptyList();
-
-    client = client.newBuilder()
-        .dns(emptyDns)
-        .build();
-    Call call = client.newCall(new Request.Builder()
-        .url("http://fakeurl/")
-        .build());
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    listener.removeUpToEvent(DnsStart.class);
-
-    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
-    assertThat(callFailed.call).isSameAs(call);
-    assertThat(callFailed.ioe).isInstanceOf(UnknownHostException.class);
-  }
-
-  @Test public void successfulConnect() throws IOException {
-    server.enqueue(new MockResponse());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertThat(response.code()).isEqualTo(200);
-    response.body().close();
-
-    InetAddress address = client.dns().lookup(server.getHostName()).get(0);
-    InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
-
-    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
-    assertThat(connectStart.call).isSameAs(call);
-    assertThat(connectStart.inetSocketAddress).isEqualTo(expectedAddress);
-    assertThat(connectStart.proxy).isEqualTo(Proxy.NO_PROXY);
-
-    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
-    assertThat(connectEnd.call).isSameAs(call);
-    assertThat(connectEnd.inetSocketAddress).isEqualTo(expectedAddress);
-    assertThat(connectEnd.protocol).isEqualTo(Protocol.HTTP_1_1);
-  }
-
-  @Test public void failedConnect() throws UnknownHostException {
-    enableTlsWithTunnel(false);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    InetAddress address = client.dns().lookup(server.getHostName()).get(0);
-    InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
-
-    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
-    assertThat(connectStart.call).isSameAs(call);
-    assertThat(connectStart.inetSocketAddress).isEqualTo(expectedAddress);
-    assertThat(connectStart.proxy).isEqualTo(Proxy.NO_PROXY);
-
-    ConnectFailed connectFailed = listener.removeUpToEvent(ConnectFailed.class);
-    assertThat(connectFailed.call).isSameAs(call);
-    assertThat(connectFailed.inetSocketAddress).isEqualTo(expectedAddress);
-    assertThat(connectFailed.protocol).isNull();
-    assertThat(connectFailed.ioe).isNotNull();
-  }
-
-  @Test public void multipleConnectsForSingleCall() throws IOException {
-    enableTlsWithTunnel(false);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse());
-
-    client = client.newBuilder()
-        .dns(new DoubleInetAddressDns())
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertThat(response.code()).isEqualTo(200);
-    response.body().close();
-
-    listener.removeUpToEvent(ConnectStart.class);
-    listener.removeUpToEvent(ConnectFailed.class);
-    listener.removeUpToEvent(ConnectStart.class);
-    listener.removeUpToEvent(ConnectEnd.class);
-  }
-
-  @Test public void successfulHttpProxyConnect() throws IOException {
-    server.enqueue(new MockResponse());
-
-    client = client.newBuilder()
-        .proxy(server.toProxyAddress())
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url("http://www.fakeurl")
-        .build());
-    Response response = call.execute();
-    assertThat(response.code()).isEqualTo(200);
-    response.body().close();
-
-    InetAddress address = client.dns().lookup(server.getHostName()).get(0);
-    InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
-
-    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
-    assertThat(connectStart.call).isSameAs(call);
-    assertThat(connectStart.inetSocketAddress).isEqualTo(expectedAddress);
-    assertThat(connectStart.proxy).isEqualTo(server.toProxyAddress());
-
-    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
-    assertThat(connectEnd.call).isSameAs(call);
-    assertThat(connectEnd.inetSocketAddress).isEqualTo(expectedAddress);
-    assertThat(connectEnd.protocol).isEqualTo(Protocol.HTTP_1_1);
-  }
-
-  @Test public void successfulSocksProxyConnect() throws Exception {
-    server.enqueue(new MockResponse());
-
-    socksProxy = new SocksProxy();
-    socksProxy.play();
-    Proxy proxy = socksProxy.proxy();
-
-    client = client.newBuilder()
-        .proxy(proxy)
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url("http://" + SocksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS + ":" + server.getPort())
-        .build());
-    Response response = call.execute();
-    assertThat(response.code()).isEqualTo(200);
-    response.body().close();
-
-    InetSocketAddress expectedAddress = InetSocketAddress.createUnresolved(
-        SocksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS, server.getPort());
-
-    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
-    assertThat(connectStart.call).isSameAs(call);
-    assertThat(connectStart.inetSocketAddress).isEqualTo(expectedAddress);
-    assertThat(connectStart.proxy).isEqualTo(proxy);
-
-    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
-    assertThat(connectEnd.call).isSameAs(call);
-    assertThat(connectEnd.inetSocketAddress).isEqualTo(expectedAddress);
-    assertThat(connectEnd.protocol).isEqualTo(Protocol.HTTP_1_1);
-  }
-
-  @Test public void authenticatingTunnelProxyConnect() throws IOException {
-    enableTlsWithTunnel(true);
-    server.enqueue(new MockResponse()
-        .setResponseCode(407)
-        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\"")
-        .addHeader("Connection: close"));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END));
-    server.enqueue(new MockResponse());
-
-    client = client.newBuilder()
-        .proxy(server.toProxyAddress())
-        .proxyAuthenticator(new RecordingOkAuthenticator("password", "Basic"))
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertThat(response.code()).isEqualTo(200);
-    response.body().close();
-
-    listener.removeUpToEvent(ConnectStart.class);
-
-    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
-    assertThat(connectEnd.protocol).isNull();
-
-    listener.removeUpToEvent(ConnectStart.class);
-    listener.removeUpToEvent(ConnectEnd.class);
-  }
-
-  @Test public void successfulSecureConnect() throws IOException {
-    enableTlsWithTunnel(false);
-    server.enqueue(new MockResponse());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertThat(response.code()).isEqualTo(200);
-    response.body().close();
-
-    SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
-    assertThat(secureStart.call).isSameAs(call);
-
-    SecureConnectEnd secureEnd = listener.removeUpToEvent(SecureConnectEnd.class);
-    assertThat(secureEnd.call).isSameAs(call);
-    assertThat(secureEnd.handshake).isNotNull();
-  }
-
-  @Test public void failedSecureConnect() {
-    enableTlsWithTunnel(false);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
-    assertThat(secureStart.call).isSameAs(call);
-
-    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
-    assertThat(callFailed.call).isSameAs(call);
-    assertThat(callFailed.ioe).isNotNull();
-  }
-
-  @Test public void secureConnectWithTunnel() throws IOException {
-    enableTlsWithTunnel(true);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END));
-    server.enqueue(new MockResponse());
-
-    client = client.newBuilder()
-        .proxy(server.toProxyAddress())
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertThat(response.code()).isEqualTo(200);
-    response.body().close();
-
-    SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
-    assertThat(secureStart.call).isSameAs(call);
-
-    SecureConnectEnd secureEnd = listener.removeUpToEvent(SecureConnectEnd.class);
-    assertThat(secureEnd.call).isSameAs(call);
-    assertThat(secureEnd.handshake).isNotNull();
-  }
-
-  @Test public void multipleSecureConnectsForSingleCall() throws IOException {
-    enableTlsWithTunnel(false);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse());
-
-    client = client.newBuilder()
-        .dns(new DoubleInetAddressDns())
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertThat(response.code()).isEqualTo(200);
-    response.body().close();
-
-    listener.removeUpToEvent(SecureConnectStart.class);
-    listener.removeUpToEvent(ConnectFailed.class);
-
-    listener.removeUpToEvent(SecureConnectStart.class);
-    listener.removeUpToEvent(SecureConnectEnd.class);
-  }
-
-  @Test public void noSecureConnectsOnPooledConnection() throws IOException {
-    enableTlsWithTunnel(false);
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-
-    client = client.newBuilder()
-        .dns(new DoubleInetAddressDns())
-        .build();
-
-    // Seed the pool.
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-    assertThat(response1.code()).isEqualTo(200);
-    response1.body().close();
-
-    listener.clearAllEvents();
-
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    assertThat(response2.code()).isEqualTo(200);
-    response2.body().close();
-
-    List<String> recordedEvents = listener.recordedEventTypes();
-    assertThat(recordedEvents).doesNotContain("SecureConnectStart");
-    assertThat(recordedEvents).doesNotContain("SecureConnectEnd");
-  }
-
-  @Test public void successfulConnectionFound() throws IOException {
-    server.enqueue(new MockResponse());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertThat(response.code()).isEqualTo(200);
-    response.body().close();
-
-    ConnectionAcquired connectionAcquired = listener.removeUpToEvent(ConnectionAcquired.class);
-    assertThat(connectionAcquired.call).isSameAs(call);
-    assertThat(connectionAcquired.connection).isNotNull();
-  }
-
-  @Test public void noConnectionFoundOnFollowUp() throws IOException {
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Location", "/foo"));
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertThat(response.body().string()).isEqualTo("ABC");
-
-    listener.removeUpToEvent(ConnectionAcquired.class);
-
-    List<String> remainingEvents = listener.recordedEventTypes();
-    assertThat(remainingEvents).doesNotContain("ConnectionAcquired");
-  }
-
-  @Test public void pooledConnectionFound() throws IOException {
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-
-    // Seed the pool.
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-    assertThat(response1.code()).isEqualTo(200);
-    response1.body().close();
-
-    ConnectionAcquired connectionAcquired1 = listener.removeUpToEvent(ConnectionAcquired.class);
-    listener.clearAllEvents();
-
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    assertThat(response2.code()).isEqualTo(200);
-    response2.body().close();
-
-    ConnectionAcquired connectionAcquired2 = listener.removeUpToEvent(ConnectionAcquired.class);
-    assertThat(connectionAcquired2.connection).isSameAs(
-        connectionAcquired1.connection);
-  }
-
-  @Test public void multipleConnectionsFoundForSingleCall() throws IOException {
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Location", "/foo")
-        .addHeader("Connection", "Close"));
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertThat(response.body().string()).isEqualTo("ABC");
-
-    listener.removeUpToEvent(ConnectionAcquired.class);
-    listener.removeUpToEvent(ConnectionAcquired.class);
-  }
-
-  @Test public void responseBodyFailHttp1OverHttps() throws IOException {
-    enableTlsWithTunnel(false);
-    server.setProtocols(asList(Protocol.HTTP_1_1));
-    responseBodyFail(Protocol.HTTP_1_1);
-  }
-
-  @Test public void responseBodyFailHttp2OverHttps() throws IOException {
-    platform.assumeHttp2Support();
-
-    enableTlsWithTunnel(false);
-    server.setProtocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
-    responseBodyFail(Protocol.HTTP_2);
-  }
-
-  @Test public void responseBodyFailHttp() throws IOException {
-    responseBodyFail(Protocol.HTTP_1_1);
-  }
-
-  private void responseBodyFail(Protocol expectedProtocol) throws IOException {
-    // Use a 2 MiB body so the disconnect won't happen until the client has read some data.
-    int responseBodySize = 2 * 1024 * 1024; // 2 MiB
-    server.enqueue(new MockResponse()
-        .setBody(new Buffer().write(new byte[responseBodySize]))
-        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    if (expectedProtocol == Protocol.HTTP_2) {
-      // soft failure since client may not support depending on Platform
-      assumeThat(response, matchesProtocol(Protocol.HTTP_2));
-    }
-    assertThat(response.protocol()).isEqualTo(expectedProtocol);
-    try {
-      response.body().string();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
-    assertThat(callFailed.ioe).isNotNull();
-  }
-
-  @Test public void emptyResponseBody() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("")
-        .setBodyDelay(1, TimeUnit.SECONDS)
-        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    response.body().close();
-
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
-        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
-        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
-        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-  }
-
-  @Test public void emptyResponseBodyConnectionClose() throws IOException {
-    server.enqueue(new MockResponse()
-        .addHeader("Connection", "close")
-        .setBody(""));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    response.body().close();
-
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
-        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
-        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
-        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-  }
-
-  @Test public void responseBodyClosedClosedWithoutReadingAllData() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .setBodyDelay(1, TimeUnit.SECONDS)
-        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    response.body().close();
-
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
-        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
-        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
-        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-  }
-
-  @Test public void requestBodyFailHttp1OverHttps() {
-    enableTlsWithTunnel(false);
-    server.setProtocols(asList(Protocol.HTTP_1_1));
-
-    requestBodyFail(Protocol.HTTP_1_1);
-  }
-
-  @Test public void requestBodyFailHttp2OverHttps() {
-    platform.assumeHttp2Support();
-
-    enableTlsWithTunnel(false);
-    server.setProtocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
-
-    requestBodyFail(Protocol.HTTP_2);
-  }
-
-  @Test public void requestBodyFailHttp() {
-    requestBodyFail(null);
-  }
-
-  private void requestBodyFail(@Nullable Protocol expectedProtocol) {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_REQUEST_BODY));
-
-    NonCompletingRequestBody request = new NonCompletingRequestBody();
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(request)
-        .build());
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    if (expectedProtocol != null) {
-      ConnectionAcquired connectionAcquired = listener.removeUpToEvent(ConnectionAcquired.class);
-      assertThat(connectionAcquired.connection.protocol()).isEqualTo(expectedProtocol);
-    }
-
-    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
-    assertThat(callFailed.ioe).isNotNull();
-
-    assertThat(request.ioe).isNotNull();
-  }
-
-  private class NonCompletingRequestBody extends RequestBody {
-    IOException ioe;
-
-    @Override public MediaType contentType() {
-      return MediaType.get("text/plain");
-    }
-
-    @Override public long contentLength() {
-      return 1024 * 1024 * 4;
-    }
-
-    @Override public void writeTo(BufferedSink sink) throws IOException {
-      try {
-        writeChunk(sink);
-        writeChunk(sink);
-        writeChunk(sink);
-        writeChunk(sink);
-        Thread.sleep(1000);
-        writeChunk(sink);
-        writeChunk(sink);
-      } catch (IOException e) {
-        ioe = e;
-      } catch (InterruptedException e) {
-      }
-    }
-
-    private void writeChunk(BufferedSink sink) throws IOException {
-      sink.write(new byte[1024 * 512]);
-      sink.flush();
-    }
-  }
-
-  @Test public void requestBodyMultipleFailuresReportedOnlyOnce() {
-    RequestBody requestBody = new RequestBody() {
-      @Override public MediaType contentType() {
-        return MediaType.get("text/plain");
-      }
-
-      @Override public long contentLength() {
-        return 1024 * 1024 * 256;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        int failureCount = 0;
-        for (int i = 0; i < 1024; i++) {
-          try {
-            sink.write(new byte[1024 * 256]);
-            sink.flush();
-          } catch (IOException e) {
-            failureCount++;
-            if (failureCount == 3) throw e;
-          }
-        }
-      }
-    };
-
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_REQUEST_BODY));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(requestBody)
-        .build());
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    assertThat(listener.recordedEventTypes()).containsExactly(
-        "CallStart", "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd", "ConnectStart",
-        "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd",
-        "RequestBodyStart", "RequestFailed", "ConnectionReleased", "CallFailed");
-  }
-
-  @Test public void requestBodySuccessHttp1OverHttps() throws IOException {
-    enableTlsWithTunnel(false);
-    server.setProtocols(asList(Protocol.HTTP_1_1));
-    requestBodySuccess(RequestBody.create("Hello", MediaType.get("text/plain")), equalTo(5L),
-        equalTo(19L));
-  }
-
-  @Test public void requestBodySuccessHttp2OverHttps() throws IOException {
-    platform.assumeHttp2Support();
-
-    enableTlsWithTunnel(false);
-    server.setProtocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
-    requestBodySuccess(RequestBody.create("Hello", MediaType.get("text/plain")), equalTo(5L),
-        equalTo(19L));
-  }
-
-  @Test public void requestBodySuccessHttp() throws IOException {
-    requestBodySuccess(RequestBody.create("Hello", MediaType.get("text/plain")), equalTo(5L),
-        equalTo(19L));
-  }
-
-  @Test public void requestBodySuccessStreaming() throws IOException {
-    RequestBody requestBody = new RequestBody() {
-      @Override public MediaType contentType() {
-        return MediaType.get("text/plain");
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.write(new byte[8192]);
-        sink.flush();
-      }
-    };
-
-    requestBodySuccess(requestBody, equalTo(8192L), equalTo(19L));
-  }
-
-  @Test public void requestBodySuccessEmpty() throws IOException {
-    requestBodySuccess(RequestBody.create("", MediaType.get("text/plain")), equalTo(0L),
-        equalTo(19L));
-  }
-
-  @Test public void successfulCallEventSequenceWithListener() throws IOException {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    client = client.newBuilder()
-        .addNetworkInterceptor(new HttpLoggingInterceptor()
-            .setLevel(HttpLoggingInterceptor.Level.BODY))
-        .build();
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.body().string()).isEqualTo("abc");
-    response.body().close();
-
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
-        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
-        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
-        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-  }
-
-  private void requestBodySuccess(RequestBody body, Matcher<Long> requestBodyBytes,
-      Matcher<Long> responseHeaderLength) throws IOException {
-    server.enqueue(new MockResponse().setResponseCode(200).setBody("World!"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(body)
-        .build());
-    Response response = call.execute();
-    assertThat(response.body().string()).isEqualTo("World!");
-
-    assertBytesReadWritten(listener, any(Long.class), requestBodyBytes, responseHeaderLength,
-        equalTo(6L));
-  }
-
-  private void enableTlsWithTunnel(boolean tunnelProxy) {
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-    server.useHttps(handshakeCertificates.sslSocketFactory(), tunnelProxy);
-  }
-
-  @Test public void redirectUsingSameConnectionEventSequence() throws IOException {
-    server.enqueue(
-        new MockResponse()
-            .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-            .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse());
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    call.execute();
-
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
-        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
-        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
-        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ResponseBodyEnd", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
-        "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased",
-        "CallEnd");
-  }
-
-  @Test
-  public void redirectUsingNewConnectionEventSequence() throws IOException {
-    MockWebServer otherServer = new MockWebServer();
-    server.enqueue(
-        new MockResponse()
-            .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-            .addHeader("Location: " + otherServer.url("/foo")));
-    otherServer.enqueue(new MockResponse());
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    call.execute();
-
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
-        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
-        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
-        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ResponseBodyEnd", "ConnectionReleased", "ProxySelectStart", "ProxySelectEnd",
-        "DnsStart", "DnsEnd", "ConnectStart", "ConnectEnd",
-        "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
-        "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased",
-        "CallEnd");
-  }
-
-  @Test public void applicationInterceptorProceedsMultipleTimes() throws Exception {
-    server.enqueue(new MockResponse().setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    client = client.newBuilder()
-        .addInterceptor(chain -> {
-          try (Response a = chain.proceed(chain.request())) {
-            assertThat(a.body().string()).isEqualTo("a");
-          }
-          return chain.proceed(chain.request());
-        })
-        .build();
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    Response response = call.execute();
-    assertThat(response.body().string()).isEqualTo("b");
-
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart",
-        "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd",
-        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
-        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
-        "ResponseBodyEnd", "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart",
-        "ResponseHeadersEnd", "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased",
-        "CallEnd");
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void applicationInterceptorShortCircuit() throws Exception {
-    client = client.newBuilder()
-        .addInterceptor(chain -> new Response.Builder()
-            .request(chain.request())
-            .protocol(Protocol.HTTP_1_1)
-            .code(200)
-            .message("OK")
-            .body(ResponseBody.create("a", null))
-            .build())
-        .build();
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    Response response = call.execute();
-    assertThat(response.body().string()).isEqualTo("a");
-
-    assertThat(listener.recordedEventTypes()).containsExactly("CallStart", "CallEnd");
-  }
-
-  /** Response headers start, then the entire request body, then response headers end. */
-  @Test public void expectContinueStartsResponseHeadersEarly() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("Expect", "100-continue")
-        .post(RequestBody.create("abc", MediaType.get("text/plain")))
-        .build();
-
-    Call call = client.newCall(request);
-    call.execute();
-
-    assertThat(listener.recordedEventTypes()).containsExactly(
-        "CallStart", "ProxySelectStart", "ProxySelectEnd", "DnsStart", "DnsEnd", "ConnectStart",
-        "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart", "RequestHeadersEnd",
-        "ResponseHeadersStart", "RequestBodyStart", "RequestBodyEnd", "ResponseHeadersEnd",
-        "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/FallbackTestClientSocketFactory.java b/okhttp/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
deleted file mode 100644
index d829566e20..0000000000
--- a/okhttp/src/test/java/okhttp3/FallbackTestClientSocketFactory.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright 2014 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-
-/**
- * An SSLSocketFactory that delegates calls. Sockets created by the delegate are wrapped with ones
- * that will not accept the {@link #TLS_FALLBACK_SCSV} cipher, thus bypassing server-side fallback
- * checks on platforms that support it. Unfortunately this wrapping will disable any
- * reflection-based calls to SSLSocket from Platform.
- */
-public class FallbackTestClientSocketFactory extends DelegatingSSLSocketFactory {
-  /**
-   * The cipher suite used during TLS connection fallback to indicate a fallback. See
-   * https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
-   */
-  public static final String TLS_FALLBACK_SCSV = "TLS_FALLBACK_SCSV";
-
-  public FallbackTestClientSocketFactory(SSLSocketFactory delegate) {
-    super(delegate);
-  }
-
-  @Override protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
-    return new TlsFallbackScsvDisabledSSLSocket(sslSocket);
-  }
-
-  private static class TlsFallbackScsvDisabledSSLSocket extends DelegatingSSLSocket {
-
-    public TlsFallbackScsvDisabledSSLSocket(SSLSocket socket) {
-      super(socket);
-    }
-
-    @Override public void setEnabledCipherSuites(String[] suites) {
-      List<String> enabledCipherSuites = new ArrayList<>(suites.length);
-      for (String suite : suites) {
-        if (!suite.equals(TLS_FALLBACK_SCSV)) {
-          enabledCipherSuites.add(suite);
-        }
-      }
-      delegate.setEnabledCipherSuites(
-          enabledCipherSuites.toArray(new String[enabledCipherSuites.size()]));
-    }
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/FormBodyTest.java b/okhttp/src/test/java/okhttp3/FormBodyTest.java
deleted file mode 100644
index e352298f0e..0000000000
--- a/okhttp/src/test/java/okhttp3/FormBodyTest.java
+++ /dev/null
@@ -1,218 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import okio.Buffer;
-import org.junit.Test;
-import java.nio.charset.Charset;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class FormBodyTest {
-  @Test public void urlEncoding() throws Exception {
-    FormBody body = new FormBody.Builder()
-        .add("a+=& b", "c+=& d")
-        .add("space, the", "final frontier")
-        .add("%25", "%25")
-        .build();
-
-    assertThat(body.size()).isEqualTo(3);
-
-    assertThat(body.encodedName(0)).isEqualTo("a%2B%3D%26%20b");
-    assertThat(body.encodedName(1)).isEqualTo("space%2C%20the");
-    assertThat(body.encodedName(2)).isEqualTo("%2525");
-
-    assertThat(body.name(0)).isEqualTo("a+=& b");
-    assertThat(body.name(1)).isEqualTo("space, the");
-    assertThat(body.name(2)).isEqualTo("%25");
-
-    assertThat(body.encodedValue(0)).isEqualTo("c%2B%3D%26%20d");
-    assertThat(body.encodedValue(1)).isEqualTo("final%20frontier");
-    assertThat(body.encodedValue(2)).isEqualTo("%2525");
-
-    assertThat(body.value(0)).isEqualTo("c+=& d");
-    assertThat(body.value(1)).isEqualTo("final frontier");
-    assertThat(body.value(2)).isEqualTo("%25");
-
-    assertThat(body.contentType().toString()).isEqualTo(
-        "application/x-www-form-urlencoded");
-
-    String expected = "a%2B%3D%26%20b=c%2B%3D%26%20d&space%2C%20the=final%20frontier&%2525=%2525";
-    assertThat(body.contentLength()).isEqualTo(expected.length());
-
-    Buffer out = new Buffer();
-    body.writeTo(out);
-    assertThat(out.readUtf8()).isEqualTo(expected);
-  }
-
-  @Test public void addEncoded() throws Exception {
-    FormBody body = new FormBody.Builder()
-        .addEncoded("a+=& b", "c+=& d")
-        .addEncoded("e+=& f", "g+=& h")
-        .addEncoded("%25", "%25")
-        .build();
-
-    String expected = "a+%3D%26%20b=c+%3D%26%20d&e+%3D%26%20f=g+%3D%26%20h&%25=%25";
-    Buffer out = new Buffer();
-    body.writeTo(out);
-    assertThat(out.readUtf8()).isEqualTo(expected);
-  }
-
-  @Test public void encodedPair() throws Exception {
-    FormBody body = new FormBody.Builder()
-        .add("sim", "ple")
-        .build();
-
-    String expected = "sim=ple";
-    assertThat(body.contentLength()).isEqualTo(expected.length());
-
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    assertThat(buffer.readUtf8()).isEqualTo(expected);
-  }
-
-  @Test public void encodeMultiplePairs() throws Exception {
-    FormBody body = new FormBody.Builder()
-        .add("sim", "ple")
-        .add("hey", "there")
-        .add("help", "me")
-        .build();
-
-    String expected = "sim=ple&hey=there&help=me";
-    assertThat(body.contentLength()).isEqualTo(expected.length());
-
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    assertThat(buffer.readUtf8()).isEqualTo(expected);
-  }
-
-  @Test public void buildEmptyForm() throws Exception {
-    FormBody body = new FormBody.Builder().build();
-
-    String expected = "";
-    assertThat(body.contentLength()).isEqualTo(expected.length());
-
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    assertThat(buffer.readUtf8()).isEqualTo(expected);
-  }
-
-  @Test public void characterEncoding() throws Exception {
-    // Browsers convert '\u0000' to '%EF%BF%BD'.
-    assertThat(formEncode(0)).isEqualTo("%00");
-    assertThat(formEncode(1)).isEqualTo("%01");
-    assertThat(formEncode(2)).isEqualTo("%02");
-    assertThat(formEncode(3)).isEqualTo("%03");
-    assertThat(formEncode(4)).isEqualTo("%04");
-    assertThat(formEncode(5)).isEqualTo("%05");
-    assertThat(formEncode(6)).isEqualTo("%06");
-    assertThat(formEncode(7)).isEqualTo("%07");
-    assertThat(formEncode(8)).isEqualTo("%08");
-    assertThat(formEncode(9)).isEqualTo("%09");
-    // Browsers convert '\n' to '\r\n'
-    assertThat(formEncode(10)).isEqualTo("%0A");
-    assertThat(formEncode(11)).isEqualTo("%0B");
-    assertThat(formEncode(12)).isEqualTo("%0C");
-    // Browsers convert '\r' to '\r\n'
-    assertThat(formEncode(13)).isEqualTo("%0D");
-    assertThat(formEncode(14)).isEqualTo("%0E");
-    assertThat(formEncode(15)).isEqualTo("%0F");
-    assertThat(formEncode(16)).isEqualTo("%10");
-    assertThat(formEncode(17)).isEqualTo("%11");
-    assertThat(formEncode(18)).isEqualTo("%12");
-    assertThat(formEncode(19)).isEqualTo("%13");
-    assertThat(formEncode(20)).isEqualTo("%14");
-    assertThat(formEncode(21)).isEqualTo("%15");
-    assertThat(formEncode(22)).isEqualTo("%16");
-    assertThat(formEncode(23)).isEqualTo("%17");
-    assertThat(formEncode(24)).isEqualTo("%18");
-    assertThat(formEncode(25)).isEqualTo("%19");
-    assertThat(formEncode(26)).isEqualTo("%1A");
-    assertThat(formEncode(27)).isEqualTo("%1B");
-    assertThat(formEncode(28)).isEqualTo("%1C");
-    assertThat(formEncode(29)).isEqualTo("%1D");
-    assertThat(formEncode(30)).isEqualTo("%1E");
-    assertThat(formEncode(31)).isEqualTo("%1F");
-    // Browsers use '+' for space.
-    assertThat(formEncode(32)).isEqualTo("%20");
-    assertThat(formEncode(33)).isEqualTo("%21");
-    assertThat(formEncode(34)).isEqualTo("%22");
-    assertThat(formEncode(35)).isEqualTo("%23");
-    assertThat(formEncode(36)).isEqualTo("%24");
-    assertThat(formEncode(37)).isEqualTo("%25");
-    assertThat(formEncode(38)).isEqualTo("%26");
-    assertThat(formEncode(39)).isEqualTo("%27");
-    assertThat(formEncode(40)).isEqualTo("%28");
-    assertThat(formEncode(41)).isEqualTo("%29");
-    assertThat(formEncode(42)).isEqualTo("*");
-    assertThat(formEncode(43)).isEqualTo("%2B");
-    assertThat(formEncode(44)).isEqualTo("%2C");
-    assertThat(formEncode(45)).isEqualTo("-");
-    assertThat(formEncode(46)).isEqualTo(".");
-    assertThat(formEncode(47)).isEqualTo("%2F");
-    assertThat(formEncode(48)).isEqualTo("0");
-    assertThat(formEncode(57)).isEqualTo("9");
-    assertThat(formEncode(58)).isEqualTo("%3A");
-    assertThat(formEncode(59)).isEqualTo("%3B");
-    assertThat(formEncode(60)).isEqualTo("%3C");
-    assertThat(formEncode(61)).isEqualTo("%3D");
-    assertThat(formEncode(62)).isEqualTo("%3E");
-    assertThat(formEncode(63)).isEqualTo("%3F");
-    assertThat(formEncode(64)).isEqualTo("%40");
-    assertThat(formEncode(65)).isEqualTo("A");
-    assertThat(formEncode(90)).isEqualTo("Z");
-    assertThat(formEncode(91)).isEqualTo("%5B");
-    assertThat(formEncode(92)).isEqualTo("%5C");
-    assertThat(formEncode(93)).isEqualTo("%5D");
-    assertThat(formEncode(94)).isEqualTo("%5E");
-    assertThat(formEncode(95)).isEqualTo("_");
-    assertThat(formEncode(96)).isEqualTo("%60");
-    assertThat(formEncode(97)).isEqualTo("a");
-    assertThat(formEncode(122)).isEqualTo("z");
-    assertThat(formEncode(123)).isEqualTo("%7B");
-    assertThat(formEncode(124)).isEqualTo("%7C");
-    assertThat(formEncode(125)).isEqualTo("%7D");
-    assertThat(formEncode(126)).isEqualTo("%7E");
-    assertThat(formEncode(127)).isEqualTo("%7F");
-    assertThat(formEncode(128)).isEqualTo("%C2%80");
-    assertThat(formEncode(255)).isEqualTo("%C3%BF");
-  }
-
-  private String formEncode(int codePoint) throws IOException {
-    // Wrap the codepoint with regular printable characters to prevent trimming.
-    FormBody body = new FormBody.Builder()
-        .add("a", new String(new int[] {'b', codePoint, 'c'}, 0, 3))
-        .build();
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    buffer.skip(3); // Skip "a=b" prefix.
-    return buffer.readUtf8(buffer.size() - 1); // Skip the "c" suffix.
-  }
-
-  @Test public void manualCharset() throws Exception {
-    FormBody body = new FormBody.Builder(Charset.forName("ISO-8859-1"))
-        .add("name", "Nicols")
-        .build();
-
-    String expected = "name=Nicol%E1s";
-    assertThat(body.contentLength()).isEqualTo(expected.length());
-
-    Buffer out = new Buffer();
-    body.writeTo(out);
-    assertThat(out.readUtf8()).isEqualTo(expected);
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/HandshakeTest.kt b/okhttp/src/test/java/okhttp3/HandshakeTest.kt
deleted file mode 100644
index 80e6bcc032..0000000000
--- a/okhttp/src/test/java/okhttp3/HandshakeTest.kt
+++ /dev/null
@@ -1,126 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3
-
-import okhttp3.Handshake.Companion.handshake
-import okhttp3.tls.HeldCertificate
-import org.assertj.core.api.Assertions.assertThat
-import org.junit.Assert.fail
-import org.junit.Test
-import java.io.IOException
-import java.security.cert.Certificate
-
-class HandshakeTest {
-  val serverRoot = HeldCertificate.Builder()
-      .certificateAuthority(1)
-      .build()
-  val serverIntermediate = HeldCertificate.Builder()
-      .certificateAuthority(0)
-      .signedBy(serverRoot)
-      .build()
-  val serverCertificate = HeldCertificate.Builder()
-      .signedBy(serverIntermediate)
-      .build()
-
-  @Test
-  fun createFromParts() {
-    val handshake = Handshake.get(
-        tlsVersion = TlsVersion.TLS_1_3,
-        cipherSuite = CipherSuite.TLS_AES_128_GCM_SHA256,
-        peerCertificates = listOf(serverCertificate.certificate, serverIntermediate.certificate),
-        localCertificates = listOf()
-    )
-
-    assertThat(handshake.tlsVersion).isEqualTo(TlsVersion.TLS_1_3)
-    assertThat(handshake.cipherSuite).isEqualTo(CipherSuite.TLS_AES_128_GCM_SHA256)
-    assertThat(handshake.peerCertificates).containsExactly(
-        serverCertificate.certificate, serverIntermediate.certificate)
-    assertThat(handshake.localPrincipal).isNull()
-    assertThat(handshake.peerPrincipal)
-        .isEqualTo(serverCertificate.certificate.subjectX500Principal)
-    assertThat(handshake.localCertificates).isEmpty()
-  }
-
-  @Test
-  fun createFromSslSession() {
-    val sslSession = FakeSSLSession(
-        "TLSv1.3",
-        "TLS_AES_128_GCM_SHA256",
-        arrayOf(serverCertificate.certificate, serverIntermediate.certificate),
-        null
-    )
-
-    val handshake = sslSession.handshake()
-
-    assertThat(handshake.tlsVersion).isEqualTo(TlsVersion.TLS_1_3)
-    assertThat(handshake.cipherSuite).isEqualTo(CipherSuite.TLS_AES_128_GCM_SHA256)
-    assertThat(handshake.peerCertificates).containsExactly(
-        serverCertificate.certificate, serverIntermediate.certificate)
-    assertThat(handshake.localPrincipal).isNull()
-    assertThat(handshake.peerPrincipal)
-        .isEqualTo(serverCertificate.certificate.subjectX500Principal)
-    assertThat(handshake.localCertificates).isEmpty()
-  }
-
-  @Test
-  fun sslWithNullNullNull() {
-    val sslSession = FakeSSLSession(
-        "TLSv1.3",
-        "SSL_NULL_WITH_NULL_NULL",
-        arrayOf(serverCertificate.certificate, serverIntermediate.certificate),
-        null
-    )
-
-    try {
-      sslSession.handshake()
-      fail()
-    } catch (expected: IOException) {
-      assertThat(expected).hasMessage("cipherSuite == SSL_NULL_WITH_NULL_NULL")
-    }
-  }
-
-  @Test
-  fun tlsWithNullNullNull() {
-    val sslSession = FakeSSLSession(
-        "TLSv1.3",
-        "TLS_NULL_WITH_NULL_NULL",
-        arrayOf(serverCertificate.certificate, serverIntermediate.certificate),
-        null
-    )
-
-    try {
-      sslSession.handshake()
-      fail()
-    } catch (expected: IOException) {
-      assertThat(expected).hasMessage("cipherSuite == TLS_NULL_WITH_NULL_NULL")
-    }
-  }
-
-  class FakeSSLSession(
-    private val protocol: String,
-    private val cipherSuite: String,
-    private val peerCertificates: Array<Certificate>?,
-    private val localCertificates: Array<Certificate>?
-  ) : DelegatingSSLSession(null) {
-    override fun getProtocol() = protocol
-
-    override fun getCipherSuite() = cipherSuite
-
-    override fun getPeerCertificates() = peerCertificates
-
-    override fun getLocalCertificates() = localCertificates
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/HeadersKotlinTest.kt b/okhttp/src/test/java/okhttp3/HeadersKotlinTest.kt
deleted file mode 100644
index 73b54ff1dd..0000000000
--- a/okhttp/src/test/java/okhttp3/HeadersKotlinTest.kt
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3
-
-import okhttp3.Headers.Companion.headersOf
-import org.assertj.core.api.Assertions.assertThat
-import org.junit.Test
-import java.time.Instant
-import java.util.Date
-
-class HeadersKotlinTest {
-  @Test fun getOperator() {
-    val headers = headersOf("a", "b", "c", "d")
-    assertThat(headers["a"]).isEqualTo("b")
-    assertThat(headers["c"]).isEqualTo("d")
-    assertThat(headers["e"]).isNull()
-  }
-
-  @Test fun iteratorOperator() {
-    val headers = headersOf("a", "b", "c", "d")
-
-    val pairs = mutableListOf<Pair<String, String>>()
-    for ((name, value) in headers) {
-      pairs += name to value
-    }
-
-    assertThat(pairs).containsExactly("a" to "b", "c" to "d")
-  }
-
-  @Test fun builderGetOperator() {
-    val builder = Headers.Builder()
-    builder.add("a", "b")
-    builder.add("c", "d")
-    assertThat(builder["a"]).isEqualTo("b")
-    assertThat(builder["c"]).isEqualTo("d")
-    assertThat(builder["e"]).isNull()
-  }
-
-  @Test fun builderSetOperator() {
-    val builder = Headers.Builder()
-    builder["a"] = "b"
-    builder["c"] = "d"
-    builder["e"] = Date(0L)
-    builder["g"] = Instant.EPOCH
-    assertThat(builder.get("a")).isEqualTo("b")
-    assertThat(builder.get("c")).isEqualTo("d")
-    assertThat(builder.get("e")).isEqualTo("Thu, 01 Jan 1970 00:00:00 GMT")
-    assertThat(builder.get("g")).isEqualTo("Thu, 01 Jan 1970 00:00:00 GMT")
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/HeadersTest.java b/okhttp/src/test/java/okhttp3/HeadersTest.java
deleted file mode 100644
index 4e10c46c12..0000000000
--- a/okhttp/src/test/java/okhttp3/HeadersTest.java
+++ /dev/null
@@ -1,896 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.time.Instant;
-import java.util.Collections;
-import java.util.Date;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import kotlin.TypeCastException;
-import okhttp3.internal.Util;
-import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.http2.Header;
-import okhttp3.internal.http2.Http2ExchangeCodec;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import static java.util.Collections.emptyList;
-import static java.util.Collections.emptyMap;
-import static java.util.Collections.singletonList;
-import static java.util.Collections.singletonMap;
-import static okhttp3.TestUtil.headerEntries;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class HeadersTest {
-  @Test public void readNameValueBlockDropsForbiddenHeadersHttp2() {
-    Headers headerBlock = Headers.of(
-        ":status", "200 OK",
-        ":version", "HTTP/1.1",
-        "connection", "close");
-    Request request = new Request.Builder().url("http://square.com/").build();
-    Response response = Http2ExchangeCodec.Companion.readHttp2HeadersList(headerBlock, Protocol.HTTP_2).request(request).build();
-    Headers headers = response.headers();
-    assertThat(headers.size()).isEqualTo(1);
-    assertThat(headers.name(0)).isEqualTo(":version");
-    assertThat(headers.value(0)).isEqualTo("HTTP/1.1");
-  }
-
-  @Test public void http2HeadersListDropsForbiddenHeadersHttp2() {
-    Request request = new Request.Builder()
-        .url("http://square.com/")
-        .header("Connection", "upgrade")
-        .header("Upgrade", "websocket")
-        .header("Host", "square.com")
-        .header("TE", "gzip")
-        .build();
-    List<Header> expected = headerEntries(
-        ":method", "GET",
-        ":path", "/",
-        ":authority", "square.com",
-        ":scheme", "http");
-    assertThat(Http2ExchangeCodec.Companion.http2HeadersList(request)).isEqualTo(expected);
-  }
-
-  @Test public void http2HeadersListDontDropTeIfTrailersHttp2() {
-    Request request = new Request.Builder()
-        .url("http://square.com/")
-        .header("TE", "trailers")
-        .build();
-    List<Header> expected = headerEntries(
-        ":method", "GET",
-        ":path", "/",
-        ":scheme", "http",
-        "te", "trailers");
-    assertThat(Http2ExchangeCodec.Companion.http2HeadersList(request)).isEqualTo(expected);
-  }
-
-  @Test public void ofTrims() {
-    Headers headers = Headers.of("\t User-Agent \n", " \r OkHttp ");
-    assertThat(headers.name(0)).isEqualTo("User-Agent");
-    assertThat(headers.value(0)).isEqualTo("OkHttp");
-  }
-
-  @Test public void addParsing() {
-    Headers headers = new Headers.Builder()
-        .add("foo: bar")
-        .add(" foo: baz") // Name leading whitespace is trimmed.
-        .add("foo : bak") // Name trailing whitespace is trimmed.
-        .add("\tkey\t:\tvalue\t") // '\t' also counts as whitespace
-        .add("ping:  pong  ") // Value whitespace is trimmed.
-        .add("kit:kat") // Space after colon is not required.
-        .build();
-    assertThat(headers.values("foo")).containsExactly("bar", "baz", "bak");
-    assertThat(headers.values("key")).containsExactly("value");
-    assertThat(headers.values("ping")).containsExactly("pong");
-    assertThat(headers.values("kit")).containsExactly("kat");
-  }
-
-  @Test public void addThrowsOnEmptyName() {
-    try {
-      new Headers.Builder().add(": bar");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      new Headers.Builder().add(" : bar");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void addThrowsOnNoColon() {
-    try {
-      new Headers.Builder().add("foo bar");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void addThrowsOnMultiColon() {
-    try {
-      new Headers.Builder().add(":status: 200 OK");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void addUnsafeNonAsciiRejectsUnicodeName() {
-    try {
-      Headers headers = new Headers.Builder()
-          .addUnsafeNonAscii("hader1", "value1")
-          .build();
-      fail("Should have complained about invalid value");
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "Unexpected char 0xe9 at 1 in header name: hader1");
-    }
-  }
-
-  @Test public void addUnsafeNonAsciiAcceptsUnicodeValue() {
-    Headers headers = new Headers.Builder()
-        .addUnsafeNonAscii("header1", "valu1")
-        .build();
-    assertThat(headers.toString()).isEqualTo("header1: valu1\n");
-  }
-
-  @Test public void ofThrowsOddNumberOfHeaders() {
-    try {
-      Headers.of("User-Agent", "OkHttp", "Content-Length");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void ofThrowsOnNull() {
-    try {
-      Headers.of("User-Agent", null);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void ofThrowsOnEmptyName() {
-    try {
-      Headers.of("", "OkHttp");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void ofAcceptsEmptyValue() {
-    Headers headers = Headers.of("User-Agent", "");
-    assertThat(headers.value(0)).isEqualTo("");
-  }
-
-  @Test public void ofMakesDefensiveCopy() {
-    String[] namesAndValues = {
-        "User-Agent",
-        "OkHttp"
-    };
-    Headers headers = Headers.of(namesAndValues);
-    namesAndValues[1] = "Chrome";
-    assertThat(headers.value(0)).isEqualTo("OkHttp");
-  }
-
-  @Test public void ofRejectsNullChar() {
-    try {
-      Headers.of("User-Agent", "Square\u0000OkHttp");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void ofMapThrowsOnNull() {
-    try {
-      Headers.of(Collections.singletonMap("User-Agent", null));
-      fail();
-    } catch (TypeCastException expected) {
-    }
-  }
-
-  @Test public void ofMapThrowsOnEmptyName() {
-    try {
-      Headers.of(singletonMap("", "OkHttp"));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void ofMapThrowsOnBlankName() {
-    try {
-      Headers.of(singletonMap(" ", "OkHttp"));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void ofMapAcceptsEmptyValue() {
-    Headers headers = Headers.of(singletonMap("User-Agent", ""));
-    assertThat(headers.value(0)).isEqualTo("");
-  }
-
-  @Test public void ofMapTrimsKey() {
-    Headers headers = Headers.of(singletonMap(" User-Agent ", "OkHttp"));
-    assertThat(headers.name(0)).isEqualTo("User-Agent");
-  }
-
-  @Test public void ofMapTrimsValue() {
-    Headers headers = Headers.of(singletonMap("User-Agent", " OkHttp "));
-    assertThat(headers.value(0)).isEqualTo("OkHttp");
-  }
-
-  @Test public void ofMapMakesDefensiveCopy() {
-    Map<String, String> namesAndValues = new LinkedHashMap<>();
-    namesAndValues.put("User-Agent", "OkHttp");
-
-    Headers headers = Headers.of(namesAndValues);
-    namesAndValues.put("User-Agent", "Chrome");
-    assertThat(headers.value(0)).isEqualTo("OkHttp");
-  }
-
-  @Test public void ofMapRejectsNullCharInName() {
-    try {
-      Headers.of(singletonMap("User-\u0000Agent", "OkHttp"));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void ofMapRejectsNullCharInValue() {
-    try {
-      Headers.of(singletonMap("User-Agent", "Square\u0000OkHttp"));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void toMultimapGroupsHeaders() {
-    Headers headers = Headers.of(
-        "cache-control", "no-cache",
-        "cache-control", "no-store",
-        "user-agent", "OkHttp");
-    Map<String, List<String>> headerMap = headers.toMultimap();
-    assertThat(headerMap.get("cache-control").size()).isEqualTo(2);
-    assertThat(headerMap.get("user-agent").size()).isEqualTo(1);
-  }
-
-  @Test public void toMultimapUsesCanonicalCase() {
-    Headers headers = Headers.of(
-        "cache-control", "no-store",
-        "Cache-Control", "no-cache",
-        "User-Agent", "OkHttp");
-    Map<String, List<String>> headerMap = headers.toMultimap();
-    assertThat(headerMap.get("cache-control").size()).isEqualTo(2);
-    assertThat(headerMap.get("user-agent").size()).isEqualTo(1);
-  }
-
-  @Test public void toMultimapAllowsCaseInsensitiveGet() {
-    Headers headers = Headers.of(
-        "cache-control", "no-store",
-        "Cache-Control", "no-cache");
-    Map<String, List<String>> headerMap = headers.toMultimap();
-    assertThat(headerMap.get("cache-control").size()).isEqualTo(2);
-    assertThat(headerMap.get("Cache-Control").size()).isEqualTo(2);
-  }
-
-  @Test public void nameIndexesAreStrict() {
-    Headers headers = Headers.of("a", "b", "c", "d");
-    try {
-      headers.name(-1);
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-    assertThat(headers.name(0)).isEqualTo("a");
-    assertThat(headers.name(1)).isEqualTo("c");
-    try {
-      headers.name(2);
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-  }
-
-  @Test public void valueIndexesAreStrict() {
-    Headers headers = Headers.of("a", "b", "c", "d");
-    try {
-      headers.value(-1);
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-    assertThat(headers.value(0)).isEqualTo("b");
-    assertThat(headers.value(1)).isEqualTo("d");
-    try {
-      headers.value(2);
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-  }
-
-  @Test public void builderRejectsUnicodeInHeaderName() {
-    try {
-      new Headers.Builder().add("hader1", "value1");
-      fail("Should have complained about invalid name");
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "Unexpected char 0xe9 at 1 in header name: hader1");
-    }
-  }
-
-  @Test public void builderRejectsUnicodeInHeaderValue() {
-    try {
-      new Headers.Builder().add("header1", "valu1");
-      fail("Should have complained about invalid value");
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "Unexpected char 0xe9 at 4 in header1 value: valu1");
-    }
-  }
-
-  @Test public void varargFactoryRejectsUnicodeInHeaderName() {
-    try {
-      Headers.of("hader1", "value1");
-      fail("Should have complained about invalid value");
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "Unexpected char 0xe9 at 1 in header name: hader1");
-    }
-  }
-
-  @Test public void varargFactoryRejectsUnicodeInHeaderValue() {
-    try {
-      Headers.of("header1", "valu1");
-      fail("Should have complained about invalid value");
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "Unexpected char 0xe9 at 4 in header1 value: valu1");
-    }
-  }
-
-  @Test public void mapFactoryRejectsUnicodeInHeaderName() {
-    try {
-      Headers.of(singletonMap("hader1", "value1"));
-      fail("Should have complained about invalid value");
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "Unexpected char 0xe9 at 1 in header name: hader1");
-    }
-  }
-
-  @Test public void mapFactoryRejectsUnicodeInHeaderValue() {
-    try {
-      Headers.of(singletonMap("header1", "valu1"));
-      fail("Should have complained about invalid value");
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "Unexpected char 0xe9 at 4 in header1 value: valu1");
-    }
-  }
-
-  @Test public void headersEquals() {
-    Headers headers1 = new Headers.Builder()
-        .add("Connection", "close")
-        .add("Transfer-Encoding", "chunked")
-        .build();
-    Headers headers2 = new Headers.Builder()
-        .add("Connection", "close")
-        .add("Transfer-Encoding", "chunked")
-        .build();
-    assertThat(headers2).isEqualTo(headers1);
-    assertThat(headers2.hashCode()).isEqualTo(headers1.hashCode());
-  }
-
-  @Test public void headersNotEquals() {
-    Headers headers1 = new Headers.Builder()
-        .add("Connection", "close")
-        .add("Transfer-Encoding", "chunked")
-        .build();
-    Headers headers2 = new Headers.Builder()
-        .add("Connection", "keep-alive")
-        .add("Transfer-Encoding", "chunked")
-        .build();
-    assertThat(headers2).isNotEqualTo(headers1);
-    assertThat(headers2.hashCode()).isNotEqualTo((long) headers1.hashCode());
-  }
-
-  @Test public void headersToString() {
-    Headers headers = new Headers.Builder()
-        .add("A", "a")
-        .add("B", "bb")
-        .build();
-    assertThat(headers.toString()).isEqualTo("A: a\nB: bb\n");
-  }
-
-  @Test public void headersAddAll() {
-    Headers sourceHeaders = new Headers.Builder()
-        .add("A", "aa")
-        .add("a", "aa")
-        .add("B", "bb")
-        .build();
-    Headers headers = new Headers.Builder()
-        .add("A", "a")
-        .addAll(sourceHeaders)
-        .add("C", "c")
-        .build();
-    assertThat(headers.toString()).isEqualTo("A: a\nA: aa\na: aa\nB: bb\nC: c\n");
-  }
-
-  /** See https://github.com/square/okhttp/issues/2780. */
-  @Test public void testDigestChallengeWithStrictRfc2617Header() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest realm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaks"
-            + "jdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
-        .build();
-    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertThat(challenges.size()).isEqualTo(1);
-    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
-    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
-    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
-    expectedAuthParams.put("realm", "myrealm");
-    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
-    expectedAuthParams.put("qop", "auth");
-    expectedAuthParams.put("stale", "FALSE");
-    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
-  }
-
-  @Test public void testDigestChallengeWithDifferentlyOrderedAuthParams() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest qop=\"auth\", realm=\"myrealm\", nonce=\"fjalskdflwejrlask"
-            + "dfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
-        .build();
-    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertThat(challenges.size()).isEqualTo(1);
-    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
-    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
-    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
-    expectedAuthParams.put("realm", "myrealm");
-    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
-    expectedAuthParams.put("qop", "auth");
-    expectedAuthParams.put("stale", "FALSE");
-    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
-  }
-
-  @Test public void testDigestChallengeWithDifferentlyOrderedAuthParams2() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest qop=\"auth\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaksjdflk"
-            + "asdf\", realm=\"myrealm\", stale=\"FALSE\"")
-        .build();
-    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertThat(challenges.size()).isEqualTo(1);
-    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
-    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
-    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
-    expectedAuthParams.put("realm", "myrealm");
-    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
-    expectedAuthParams.put("qop", "auth");
-    expectedAuthParams.put("stale", "FALSE");
-    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
-  }
-
-  @Test public void testDigestChallengeWithMissingRealm() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest qop=\"auth\", underrealm=\"myrealm\", nonce=\"fjalskdflwej"
-            + "rlaskdfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
-        .build();
-    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertThat(challenges.size()).isEqualTo(1);
-    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
-    assertThat(challenges.get(0).realm()).isNull();
-    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
-    expectedAuthParams.put("underrealm", "myrealm");
-    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
-    expectedAuthParams.put("qop", "auth");
-    expectedAuthParams.put("stale", "FALSE");
-    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
-  }
-
-  @Test public void testDigestChallengeWithAdditionalSpaces() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest qop=\"auth\",    realm=\"myrealm\", nonce=\"fjalskdflwejrl"
-            + "askdfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
-        .build();
-    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertThat(challenges.size()).isEqualTo(1);
-    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
-    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
-    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
-    expectedAuthParams.put("realm", "myrealm");
-    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
-    expectedAuthParams.put("qop", "auth");
-    expectedAuthParams.put("stale", "FALSE");
-    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
-  }
-
-  @Test public void testDigestChallengeWithAdditionalSpacesBeforeFirstAuthParam() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest    realm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjfl"
-            + "aksjdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
-        .build();
-    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertThat(challenges.size()).isEqualTo(1);
-    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
-    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
-    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
-    expectedAuthParams.put("realm", "myrealm");
-    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
-    expectedAuthParams.put("qop", "auth");
-    expectedAuthParams.put("stale", "FALSE");
-    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
-  }
-
-  @Test public void testDigestChallengeWithCamelCasedNames() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "DiGeSt qop=\"auth\", rEaLm=\"myrealm\", nonce=\"fjalskdflwejrlask"
-            + "dfjlaskdjflaksjdflkasdf\", stale=\"FALSE\"")
-        .build();
-    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertThat(challenges.size()).isEqualTo(1);
-    assertThat(challenges.get(0).scheme()).isEqualTo("DiGeSt");
-    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
-    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
-    expectedAuthParams.put("realm", "myrealm");
-    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
-    expectedAuthParams.put("qop", "auth");
-    expectedAuthParams.put("stale", "FALSE");
-    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
-  }
-
-  @Test public void testDigestChallengeWithCamelCasedNames2() {
-    // Strict RFC 2617 camelcased.
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "DIgEsT rEaLm=\"myrealm\", nonce=\"fjalskdflwejrlaskdfjlaskdjflaks"
-            + "jdflkasdf\", qop=\"auth\", stale=\"FALSE\"")
-        .build();
-    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertThat(challenges.size()).isEqualTo(1);
-    assertThat(challenges.get(0).scheme()).isEqualTo("DIgEsT");
-    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
-    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
-    expectedAuthParams.put("realm", "myrealm");
-    expectedAuthParams.put("nonce", "fjalskdflwejrlaskdfjlaskdjflaksjdflkasdf");
-    expectedAuthParams.put("qop", "auth");
-    expectedAuthParams.put("stale", "FALSE");
-    assertThat(challenges.get(0).authParams()).isEqualTo(expectedAuthParams);
-  }
-
-  @Test public void testDigestChallengeWithTokenFormOfAuthParam() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest realm=myrealm").build();
-    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertThat(challenges.size()).isEqualTo(1);
-    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
-    assertThat(challenges.get(0).realm()).isEqualTo("myrealm");
-    assertThat(challenges.get(0).authParams()).isEqualTo(singletonMap("realm", "myrealm"));
-  }
-
-  @Test public void testDigestChallengeWithoutAuthParams() {
-    // Scheme only.
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest").build();
-    List<Challenge> challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
-    assertThat(challenges.size()).isEqualTo(1);
-    assertThat(challenges.get(0).scheme()).isEqualTo("Digest");
-    assertThat(challenges.get(0).realm()).isNull();
-    assertThat(challenges.get(0).authParams()).isEqualTo(emptyMap());
-  }
-
-  @Test public void basicChallenge() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate: Basic realm=\"protected area\"")
-        .build();
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
-        singletonList(new Challenge("Basic", singletonMap("realm", "protected area"))));
-  }
-
-  @Test public void basicChallengeWithCharset() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate: Basic realm=\"protected area\", charset=\"UTF-8\"")
-        .build();
-    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
-    expectedAuthParams.put("realm", "protected area");
-    expectedAuthParams.put("charset", "UTF-8");
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
-        singletonList(new Challenge("Basic", expectedAuthParams)));
-  }
-
-  @Test public void basicChallengeWithUnexpectedCharset() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate: Basic realm=\"protected area\", charset=\"US-ASCII\"")
-        .build();
-
-    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
-    expectedAuthParams.put("realm", "protected area");
-    expectedAuthParams.put("charset", "US-ASCII");
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
-        singletonList(new Challenge("Basic", expectedAuthParams)));
-  }
-
-  @Test public void separatorsBeforeFirstChallenge() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", " ,  , Basic realm=myrealm")
-        .build();
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
-        singletonList(new Challenge("Basic", singletonMap("realm", "myrealm"))));
-  }
-
-  @Test public void spacesAroundKeyValueSeparator() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Basic realm = \"myrealm\"")
-        .build();
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
-        singletonList(new Challenge("Basic", singletonMap("realm", "myrealm"))));
-  }
-
-  @Test public void multipleChallengesInOneHeader() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Basic realm = \"myrealm\",Digest")
-        .build();
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
-        new Challenge("Basic", singletonMap("realm", "myrealm")),
-        new Challenge("Digest", Collections.emptyMap()));
-  }
-
-  @Test public void multipleChallengesWithSameSchemeButDifferentRealmInOneHeader() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Basic realm = \"myrealm\",Basic realm=myotherrealm")
-        .build();
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
-        new Challenge("Basic", singletonMap("realm", "myrealm")),
-        new Challenge("Basic", singletonMap("realm", "myotherrealm")));
-  }
-
-  @Test public void separatorsBeforeFirstAuthParam() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest, Basic ,,realm=\"myrealm\"")
-        .build();
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
-        new Challenge("Digest", Collections.emptyMap()),
-        new Challenge("Basic", singletonMap("realm", "myrealm")));
-  }
-
-  @Test public void onlyCommaBetweenChallenges() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest,Basic realm=\"myrealm\"")
-        .build();
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
-        new Challenge("Digest", Collections.emptyMap()),
-        new Challenge("Basic", singletonMap("realm", "myrealm")));
-  }
-
-  @Test public void multipleSeparatorsBetweenChallenges() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest,,,, Basic ,,realm=\"myrealm\"")
-        .build();
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
-        new Challenge("Digest", Collections.emptyMap()),
-        new Challenge("Basic", singletonMap("realm", "myrealm")));
-  }
-
-  @Test public void unknownAuthParams() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest,,,, Basic ,,foo=bar,realm=\"myrealm\"")
-        .build();
-
-    Map<String, String> expectedAuthParams = new LinkedHashMap<>();
-    expectedAuthParams.put("realm", "myrealm");
-    expectedAuthParams.put("foo", "bar");
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
-        new Challenge("Digest", Collections.emptyMap()),
-        new Challenge("Basic", expectedAuthParams));
-  }
-
-  @Test public void escapedCharactersInQuotedString() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=\"my\\\\\\\"r\\ealm\"")
-        .build();
-
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
-        new Challenge("Digest", Collections.emptyMap()),
-        new Challenge("Basic", singletonMap("realm", "my\\\"realm")));
-  }
-
-  @Test public void commaInQuotedStringAndBeforeFirstChallenge() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", ",Digest,,,, Basic ,,,realm=\"my, realm,\"")
-        .build();
-
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
-        new Challenge("Digest", Collections.emptyMap()),
-        new Challenge("Basic", singletonMap("realm", "my, realm,")));
-  }
-
-  @Test public void unescapedDoubleQuoteInQuotedStringWithEvenNumberOfBackslashesInFront() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=\"my\\\\\\\\\"r\\ealm\"")
-        .build();
-
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
-        new Challenge("Digest", Collections.emptyMap()));
-  }
-
-  @Test public void unescapedDoubleQuoteInQuotedString() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=\"my\"realm\"")
-        .build();
-
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
-        new Challenge("Digest", Collections.emptyMap()));
-  }
-
-  @Ignore("TODO(jwilson): reject parameters that use invalid characters")
-  @Test public void doubleQuoteInToken() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest,,,, Basic ,,,realm=my\"realm")
-        .build();
-
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
-        new Challenge("Digest", Collections.emptyMap()));
-  }
-
-  @Test public void token68InsteadOfAuthParams() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Other abc==")
-        .build();
-
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
-        singletonList(
-        new Challenge("Other", singletonMap(null, "abc=="))));
-  }
-
-  @Test public void token68AndAuthParams() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Other abc==, realm=myrealm")
-        .build();
-
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
-        new Challenge("Other", singletonMap(null, "abc==")));
-  }
-
-  @Test public void repeatedAuthParamKey() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Other realm=myotherrealm, realm=myrealm")
-        .build();
-
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).isEqualTo(
-        emptyList());
-  }
-
-  @Test public void multipleAuthenticateHeaders() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Digest")
-        .add("WWW-Authenticate", "Basic realm=myrealm")
-        .build();
-
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
-        new Challenge("Digest", Collections.emptyMap()),
-        new Challenge("Basic", singletonMap("realm", "myrealm")));
-  }
-
-  @Test public void multipleAuthenticateHeadersInDifferentOrder() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Basic realm=myrealm")
-        .add("WWW-Authenticate", "Digest")
-        .build();
-
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
-        new Challenge("Basic", singletonMap("realm", "myrealm")),
-        new Challenge("Digest", Collections.emptyMap()));
-  }
-
-  @Test public void multipleBasicAuthenticateHeaders() {
-    Headers headers = new Headers.Builder()
-        .add("WWW-Authenticate", "Basic realm=myrealm")
-        .add("WWW-Authenticate", "Basic realm=myotherrealm")
-        .build();
-
-    assertThat(HttpHeaders.parseChallenges(headers, "WWW-Authenticate")).containsExactly(
-        new Challenge("Basic", singletonMap("realm", "myrealm")),
-        new Challenge("Basic", singletonMap("realm", "myotherrealm")));
-  }
-
-  @Test public void byteCount() {
-    assertThat(Util.EMPTY_HEADERS.byteCount()).isEqualTo(0L);
-    assertThat(new Headers.Builder()
-        .add("abc", "def")
-        .build()
-        .byteCount()).isEqualTo(10L);
-    assertThat(new Headers.Builder()
-        .add("abc", "def")
-        .add("ghi", "jkl")
-        .build()
-        .byteCount()).isEqualTo(20L);
-  }
-
-  @Test public void addDate() {
-    Date expected = new Date(0L);
-    Headers headers = new Headers.Builder()
-        .add("testDate", expected)
-        .build();
-    assertThat(headers.get("testDate")).isEqualTo("Thu, 01 Jan 1970 00:00:00 GMT");
-    assertThat(headers.getDate("testDate")).isEqualTo(new Date(0L));
-  }
-
-  @Test public void addDateNull() {
-    try {
-      new Headers.Builder()
-          .add("testDate", (Date) null)
-          .build();
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void addInstant() {
-    Instant expected = Instant.ofEpochMilli(0L);
-    Headers headers = new Headers.Builder()
-        .add("Test-Instant", expected)
-        .build();
-    assertThat(headers.get("Test-Instant")).isEqualTo("Thu, 01 Jan 1970 00:00:00 GMT");
-    assertThat(headers.getInstant("Test-Instant")).isEqualTo(expected);
-  }
-
-  @Test public void addInstantNull() {
-    try {
-      new Headers.Builder()
-          .add("Test-Instant", (Instant) null)
-          .build();
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setDate() {
-    Date expected = new Date(1000);
-    Headers headers = new Headers.Builder()
-        .add("testDate", new Date(0L))
-        .set("testDate", expected)
-        .build();
-    assertThat(headers.get("testDate")).isEqualTo("Thu, 01 Jan 1970 00:00:01 GMT");
-    assertThat(headers.getDate("testDate")).isEqualTo(expected);
-  }
-
-  @Test public void setDateNull() {
-    try {
-      new Headers.Builder()
-          .set("testDate", (Date) null)
-          .build();
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setInstant() {
-    Instant expected = Instant.ofEpochMilli(1000L);
-    Headers headers = new Headers.Builder()
-        .add("Test-Instant", Instant.ofEpochMilli(0L))
-        .set("Test-Instant", expected)
-        .build();
-    assertThat(headers.get("Test-Instant")).isEqualTo("Thu, 01 Jan 1970 00:00:01 GMT");
-    assertThat(headers.getInstant("Test-Instant")).isEqualTo(expected);
-  }
-
-  @Test public void setInstantNull() {
-    try {
-      new Headers.Builder()
-          .set("Test-Instant", (Instant) null)
-          .build();
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/HttpUrlTest.java b/okhttp/src/test/java/okhttp3/HttpUrlTest.java
deleted file mode 100644
index c522044012..0000000000
--- a/okhttp/src/test/java/okhttp3/HttpUrlTest.java
+++ /dev/null
@@ -1,1727 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.URI;
-import java.net.URL;
-import java.util.Collection;
-import java.util.Collections;
-import okhttp3.UrlComponentEncodingTester.Component;
-import okhttp3.UrlComponentEncodingTester.Encoding;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-
-import static java.util.Arrays.asList;
-import static java.util.Collections.singletonList;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-@RunWith(Parameterized.class)
-public final class HttpUrlTest {
-  @Parameterized.Parameters(name = "Use get = {0}")
-  public static Collection<Object[]> parameters() {
-    return asList(
-        new Object[] { true },
-        new Object[] { false }
-    );
-  }
-
-  @Parameterized.Parameter
-  public boolean useGet;
-
-  HttpUrl parse(String url) {
-    return useGet
-        ? HttpUrl.get(url)
-        : HttpUrl.parse(url);
-  }
-
-  @Test public void parseTrimsAsciiWhitespace() throws Exception {
-    HttpUrl expected = parse("http://host/");
-    // Leading.
-    assertThat(parse("http://host/\f\n\t \r")).isEqualTo(expected);
-    // Trailing.
-    assertThat(parse("\r\n\f \thttp://host/")).isEqualTo(expected);
-    // Both.
-    assertThat(parse(" http://host/ ")).isEqualTo(expected);
-    // Both.
-    assertThat(parse("    http://host/    ")).isEqualTo(expected);
-    assertThat(parse("http://host/").resolve("   ")).isEqualTo(expected);
-    assertThat(parse("http://host/").resolve("  .  ")).isEqualTo(expected);
-  }
-
-  @Test public void parseHostAsciiNonPrintable() throws Exception {
-    String host = "host\u0001";
-    assertInvalid("http://" + host + "/", "Invalid URL host: \"host\u0001\"");
-    // TODO make exception message escape non-printable characters
-  }
-
-  @Test public void parseDoesNotTrimOtherWhitespaceCharacters() throws Exception {
-    // Whitespace characters list from Google's Guava team: http://goo.gl/IcR9RD
-    // line tabulation
-    assertThat(parse("http://h/\u000b").encodedPath()).isEqualTo("/%0B");
-    // information separator 4
-    assertThat(parse("http://h/\u001c").encodedPath()).isEqualTo("/%1C");
-    // information separator 3
-    assertThat(parse("http://h/\u001d").encodedPath()).isEqualTo("/%1D");
-    // information separator 2
-    assertThat(parse("http://h/\u001e").encodedPath()).isEqualTo("/%1E");
-    // information separator 1
-    assertThat(parse("http://h/\u001f").encodedPath()).isEqualTo("/%1F");
-    // next line
-    assertThat(parse("http://h/\u0085").encodedPath()).isEqualTo("/%C2%85");
-    // non-breaking space
-    assertThat(parse("http://h/\u00a0").encodedPath()).isEqualTo("/%C2%A0");
-    // ogham space mark
-    assertThat(parse("http://h/\u1680").encodedPath()).isEqualTo("/%E1%9A%80");
-    // mongolian vowel separator
-    assertThat(parse("http://h/\u180e").encodedPath()).isEqualTo("/%E1%A0%8E");
-    // en quad
-    assertThat(parse("http://h/\u2000").encodedPath()).isEqualTo("/%E2%80%80");
-    // em quad
-    assertThat(parse("http://h/\u2001").encodedPath()).isEqualTo("/%E2%80%81");
-    // en space
-    assertThat(parse("http://h/\u2002").encodedPath()).isEqualTo("/%E2%80%82");
-    // em space
-    assertThat(parse("http://h/\u2003").encodedPath()).isEqualTo("/%E2%80%83");
-    // three-per-em space
-    assertThat(parse("http://h/\u2004").encodedPath()).isEqualTo("/%E2%80%84");
-    // four-per-em space
-    assertThat(parse("http://h/\u2005").encodedPath()).isEqualTo("/%E2%80%85");
-    // six-per-em space
-    assertThat(parse("http://h/\u2006").encodedPath()).isEqualTo("/%E2%80%86");
-    // figure space
-    assertThat(parse("http://h/\u2007").encodedPath()).isEqualTo("/%E2%80%87");
-    // punctuation space
-    assertThat(parse("http://h/\u2008").encodedPath()).isEqualTo("/%E2%80%88");
-    // thin space
-    assertThat(parse("http://h/\u2009").encodedPath()).isEqualTo("/%E2%80%89");
-    // hair space
-    assertThat(parse("http://h/\u200a").encodedPath()).isEqualTo("/%E2%80%8A");
-    // zero-width space
-    assertThat(parse("http://h/\u200b").encodedPath()).isEqualTo("/%E2%80%8B");
-    // zero-width non-joiner
-    assertThat(parse("http://h/\u200c").encodedPath()).isEqualTo("/%E2%80%8C");
-    // zero-width joiner
-    assertThat(parse("http://h/\u200d").encodedPath()).isEqualTo("/%E2%80%8D");
-    // left-to-right mark
-    assertThat(parse("http://h/\u200e").encodedPath()).isEqualTo("/%E2%80%8E");
-    // right-to-left mark
-    assertThat(parse("http://h/\u200f").encodedPath()).isEqualTo("/%E2%80%8F");
-    // line separator
-    assertThat(parse("http://h/\u2028").encodedPath()).isEqualTo("/%E2%80%A8");
-    // paragraph separator
-    assertThat(parse("http://h/\u2029").encodedPath()).isEqualTo("/%E2%80%A9");
-    // narrow non-breaking space
-    assertThat(parse("http://h/\u202f").encodedPath()).isEqualTo("/%E2%80%AF");
-    // medium mathematical space
-    assertThat(parse("http://h/\u205f").encodedPath()).isEqualTo("/%E2%81%9F");
-    // ideographic space
-    assertThat(parse("http://h/\u3000").encodedPath()).isEqualTo("/%E3%80%80");
-  }
-
-  @Test public void scheme() throws Exception {
-    assertThat(parse("http://host/")).isEqualTo(parse("http://host/"));
-    assertThat(parse("Http://host/")).isEqualTo(parse("http://host/"));
-    assertThat(parse("http://host/")).isEqualTo(parse("http://host/"));
-    assertThat(parse("HTTP://host/")).isEqualTo(parse("http://host/"));
-    assertThat(parse("https://host/")).isEqualTo(parse("https://host/"));
-    assertThat(parse("HTTPS://host/")).isEqualTo(parse("https://host/"));
-
-    assertInvalid("image640://480.png", "Expected URL scheme 'http' or 'https' but was 'image640'");
-    assertInvalid("httpp://host/", "Expected URL scheme 'http' or 'https' but was 'httpp'");
-    assertInvalid("0ttp://host/", "Expected URL scheme 'http' or 'https' but no colon was found");
-    assertInvalid("ht+tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht+tp'");
-    assertInvalid("ht.tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht.tp'");
-    assertInvalid("ht-tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht-tp'");
-    assertInvalid("ht1tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht1tp'");
-    assertInvalid("httpss://host/", "Expected URL scheme 'http' or 'https' but was 'httpss'");
-  }
-
-  @Test public void parseNoScheme() throws Exception {
-    assertInvalid("//host", "Expected URL scheme 'http' or 'https' but no colon was found");
-    assertInvalid("/path", "Expected URL scheme 'http' or 'https' but no colon was found");
-    assertInvalid("path", "Expected URL scheme 'http' or 'https' but no colon was found");
-    assertInvalid("?query", "Expected URL scheme 'http' or 'https' but no colon was found");
-    assertInvalid("#fragment", "Expected URL scheme 'http' or 'https' but no colon was found");
-  }
-
-  @Test public void newBuilderResolve() throws Exception {
-    // Non-exhaustive tests because implementation is the same as resolve.
-    HttpUrl base = parse("http://host/a/b");
-    assertThat(base.newBuilder("https://host2").build()).isEqualTo(parse("https://host2/"));
-    assertThat(base.newBuilder("//host2").build()).isEqualTo(parse("http://host2/"));
-    assertThat(base.newBuilder("/path").build()).isEqualTo(parse("http://host/path"));
-    assertThat(base.newBuilder("path").build()).isEqualTo(parse("http://host/a/path"));
-    assertThat(base.newBuilder("?query").build()).isEqualTo(parse("http://host/a/b?query"));
-    assertThat(base.newBuilder("#fragment").build())
-        .isEqualTo(parse("http://host/a/b#fragment"));
-    assertThat(base.newBuilder("").build()).isEqualTo(parse("http://host/a/b"));
-    assertThat(base.newBuilder("ftp://b")).isNull();
-    assertThat(base.newBuilder("ht+tp://b")).isNull();
-    assertThat(base.newBuilder("ht-tp://b")).isNull();
-    assertThat(base.newBuilder("ht.tp://b")).isNull();
-  }
-
-  @Test public void redactedUrl() {
-    HttpUrl baseWithPasswordAndUsername = parse("http://username:password@host/a/b#fragment");
-    HttpUrl baseWithUsernameOnly = parse("http://username@host/a/b#fragment");
-    HttpUrl baseWithPasswordOnly = parse("http://password@host/a/b#fragment");
-    assertThat(baseWithPasswordAndUsername.redact()).isEqualTo("http://host/...");
-    assertThat(baseWithUsernameOnly.redact()).isEqualTo("http://host/...");
-    assertThat(baseWithPasswordOnly.redact()).isEqualTo("http://host/...");
-  }
-
-  @Test public void resolveNoScheme() throws Exception {
-    HttpUrl base = parse("http://host/a/b");
-    assertThat(base.resolve("//host2")).isEqualTo(parse("http://host2/"));
-    assertThat(base.resolve("/path")).isEqualTo(parse("http://host/path"));
-    assertThat(base.resolve("path")).isEqualTo(parse("http://host/a/path"));
-    assertThat(base.resolve("?query")).isEqualTo(parse("http://host/a/b?query"));
-    assertThat(base.resolve("#fragment")).isEqualTo(parse("http://host/a/b#fragment"));
-    assertThat(base.resolve("")).isEqualTo(parse("http://host/a/b"));
-    assertThat(base.resolve("\\path")).isEqualTo(parse("http://host/path"));
-  }
-
-  @Test public void resolveUnsupportedScheme() throws Exception {
-    HttpUrl base = parse("http://a/");
-    assertThat(base.resolve("ftp://b")).isNull();
-    assertThat(base.resolve("ht+tp://b")).isNull();
-    assertThat(base.resolve("ht-tp://b")).isNull();
-    assertThat(base.resolve("ht.tp://b")).isNull();
-  }
-
-  @Test public void resolveSchemeLikePath() throws Exception {
-    HttpUrl base = parse("http://a/");
-    assertThat(base.resolve("http//b/")).isEqualTo(parse("http://a/http//b/"));
-    assertThat(base.resolve("ht+tp//b/")).isEqualTo(parse("http://a/ht+tp//b/"));
-    assertThat(base.resolve("ht-tp//b/")).isEqualTo(parse("http://a/ht-tp//b/"));
-    assertThat(base.resolve("ht.tp//b/")).isEqualTo(parse("http://a/ht.tp//b/"));
-  }
-
-  /** https://tools.ietf.org/html/rfc3986#section-5.4.1 */
-  @Test public void rfc3886NormalExamples() {
-    HttpUrl url = parse("http://a/b/c/d;p?q");
-    // No 'g:' scheme in HttpUrl.
-    assertThat(url.resolve("g:h")).isNull();
-    assertThat(url.resolve("g")).isEqualTo(parse("http://a/b/c/g"));
-    assertThat(url.resolve("./g")).isEqualTo(parse("http://a/b/c/g"));
-    assertThat(url.resolve("g/")).isEqualTo(parse("http://a/b/c/g/"));
-    assertThat(url.resolve("/g")).isEqualTo(parse("http://a/g"));
-    assertThat(url.resolve("//g")).isEqualTo(parse("http://g"));
-    assertThat(url.resolve("?y")).isEqualTo(parse("http://a/b/c/d;p?y"));
-    assertThat(url.resolve("g?y")).isEqualTo(parse("http://a/b/c/g?y"));
-    assertThat(url.resolve("#s")).isEqualTo(parse("http://a/b/c/d;p?q#s"));
-    assertThat(url.resolve("g#s")).isEqualTo(parse("http://a/b/c/g#s"));
-    assertThat(url.resolve("g?y#s")).isEqualTo(parse("http://a/b/c/g?y#s"));
-    assertThat(url.resolve(";x")).isEqualTo(parse("http://a/b/c/;x"));
-    assertThat(url.resolve("g;x")).isEqualTo(parse("http://a/b/c/g;x"));
-    assertThat(url.resolve("g;x?y#s")).isEqualTo(parse("http://a/b/c/g;x?y#s"));
-    assertThat(url.resolve("")).isEqualTo(parse("http://a/b/c/d;p?q"));
-    assertThat(url.resolve(".")).isEqualTo(parse("http://a/b/c/"));
-    assertThat(url.resolve("./")).isEqualTo(parse("http://a/b/c/"));
-    assertThat(url.resolve("..")).isEqualTo(parse("http://a/b/"));
-    assertThat(url.resolve("../")).isEqualTo(parse("http://a/b/"));
-    assertThat(url.resolve("../g")).isEqualTo(parse("http://a/b/g"));
-    assertThat(url.resolve("../..")).isEqualTo(parse("http://a/"));
-    assertThat(url.resolve("../../")).isEqualTo(parse("http://a/"));
-    assertThat(url.resolve("../../g")).isEqualTo(parse("http://a/g"));
-  }
-
-  /** https://tools.ietf.org/html/rfc3986#section-5.4.2 */
-  @Test public void rfc3886AbnormalExamples() {
-    HttpUrl url = parse("http://a/b/c/d;p?q");
-    assertThat(url.resolve("../../../g")).isEqualTo(parse("http://a/g"));
-    assertThat(url.resolve("../../../../g")).isEqualTo(parse("http://a/g"));
-    assertThat(url.resolve("/./g")).isEqualTo(parse("http://a/g"));
-    assertThat(url.resolve("/../g")).isEqualTo(parse("http://a/g"));
-    assertThat(url.resolve("g.")).isEqualTo(parse("http://a/b/c/g."));
-    assertThat(url.resolve(".g")).isEqualTo(parse("http://a/b/c/.g"));
-    assertThat(url.resolve("g..")).isEqualTo(parse("http://a/b/c/g.."));
-    assertThat(url.resolve("..g")).isEqualTo(parse("http://a/b/c/..g"));
-    assertThat(url.resolve("./../g")).isEqualTo(parse("http://a/b/g"));
-    assertThat(url.resolve("./g/.")).isEqualTo(parse("http://a/b/c/g/"));
-    assertThat(url.resolve("g/./h")).isEqualTo(parse("http://a/b/c/g/h"));
-    assertThat(url.resolve("g/../h")).isEqualTo(parse("http://a/b/c/h"));
-    assertThat(url.resolve("g;x=1/./y")).isEqualTo(parse("http://a/b/c/g;x=1/y"));
-    assertThat(url.resolve("g;x=1/../y")).isEqualTo(parse("http://a/b/c/y"));
-    assertThat(url.resolve("g?y/./x")).isEqualTo(parse("http://a/b/c/g?y/./x"));
-    assertThat(url.resolve("g?y/../x")).isEqualTo(parse("http://a/b/c/g?y/../x"));
-    assertThat(url.resolve("g#s/./x")).isEqualTo(parse("http://a/b/c/g#s/./x"));
-    assertThat(url.resolve("g#s/../x")).isEqualTo(parse("http://a/b/c/g#s/../x"));
-    // "http:g" also okay.
-    assertThat(url.resolve("http:g")).isEqualTo(parse("http://a/b/c/g"));
-  }
-
-  @Test public void parseAuthoritySlashCountDoesntMatter() throws Exception {
-    assertThat(parse("http:host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(parse("http:/host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(parse("http:\\host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(parse("http://host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(parse("http:\\/host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(parse("http:/\\host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(parse("http:\\\\host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(parse("http:///host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(parse("http:\\//host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(parse("http:/\\/host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(parse("http://\\host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(parse("http:\\\\/host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(parse("http:/\\\\host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(parse("http:\\\\\\host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(parse("http:////host/path")).isEqualTo(parse("http://host/path"));
-  }
-
-  @Test public void resolveAuthoritySlashCountDoesntMatterWithDifferentScheme() throws Exception {
-    HttpUrl base = parse("https://a/b/c");
-    assertThat(base.resolve("http:host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(base.resolve("http:/host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(base.resolve("http:\\host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(base.resolve("http://host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(base.resolve("http:\\/host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(base.resolve("http:/\\host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(base.resolve("http:\\\\host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(base.resolve("http:///host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(base.resolve("http:\\//host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(base.resolve("http:/\\/host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(base.resolve("http://\\host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(base.resolve("http:\\\\/host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(base.resolve("http:/\\\\host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(base.resolve("http:\\\\\\host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(base.resolve("http:////host/path")).isEqualTo(parse("http://host/path"));
-  }
-
-  @Test public void resolveAuthoritySlashCountMattersWithSameScheme() throws Exception {
-    HttpUrl base = parse("http://a/b/c");
-    assertThat(base.resolve("http:host/path")).isEqualTo(parse("http://a/b/host/path"));
-    assertThat(base.resolve("http:/host/path")).isEqualTo(parse("http://a/host/path"));
-    assertThat(base.resolve("http:\\host/path")).isEqualTo(parse("http://a/host/path"));
-    assertThat(base.resolve("http://host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(base.resolve("http:\\/host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(base.resolve("http:/\\host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(base.resolve("http:\\\\host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(base.resolve("http:///host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(base.resolve("http:\\//host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(base.resolve("http:/\\/host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(base.resolve("http://\\host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(base.resolve("http:\\\\/host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(base.resolve("http:/\\\\host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(base.resolve("http:\\\\\\host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(base.resolve("http:////host/path")).isEqualTo(parse("http://host/path"));
-  }
-
-  @Test public void username() throws Exception {
-    assertThat(parse("http://@host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(parse("http://user@host/path")).isEqualTo(parse("http://user@host/path"));
-  }
-
-  /** Given multiple '@' characters, the last one is the delimiter. */
-  @Test public void authorityWithMultipleAtSigns() throws Exception {
-    HttpUrl httpUrl = parse("http://foo@bar@baz/path");
-    assertThat(httpUrl.username()).isEqualTo("foo@bar");
-    assertThat(httpUrl.password()).isEqualTo("");
-    assertThat(httpUrl).isEqualTo(parse("http://foo%40bar@baz/path"));
-  }
-
-  /** Given multiple ':' characters, the first one is the delimiter. */
-  @Test public void authorityWithMultipleColons() throws Exception {
-    HttpUrl httpUrl = parse("http://foo:pass1@bar:pass2@baz/path");
-    assertThat(httpUrl.username()).isEqualTo("foo");
-    assertThat(httpUrl.password()).isEqualTo("pass1@bar:pass2");
-    assertThat(httpUrl).isEqualTo(parse("http://foo:pass1%40bar%3Apass2@baz/path"));
-  }
-
-  @Test public void usernameAndPassword() throws Exception {
-    assertThat(parse("http://username:password@host/path"))
-        .isEqualTo(parse("http://username:password@host/path"));
-    assertThat(parse("http://username:@host/path"))
-        .isEqualTo(parse("http://username@host/path"));
-  }
-
-  @Test public void passwordWithEmptyUsername() throws Exception {
-    // Chrome doesn't mind, but Firefox rejects URLs with empty usernames and non-empty passwords.
-    assertThat(parse("http://:@host/path")).isEqualTo(parse("http://host/path"));
-    assertThat(parse("http://:password@@host/path").encodedPassword())
-        .isEqualTo("password%40");
-  }
-
-  @Test public void unprintableCharactersArePercentEncoded() throws Exception {
-    assertThat(parse("http://host/\u0000").encodedPath()).isEqualTo("/%00");
-    assertThat(parse("http://host/\u0008").encodedPath()).isEqualTo("/%08");
-    assertThat(parse("http://host/\ufffd").encodedPath()).isEqualTo("/%EF%BF%BD");
-  }
-
-  @Test public void usernameCharacters() throws Exception {
-    new UrlComponentEncodingTester()
-        .override(Encoding.PERCENT, '[', ']', '{', '}', '|', '^', '\'', ';', '=', '@')
-        .override(Encoding.SKIP, ':', '/', '\\', '?', '#')
-        .skipForUri('%')
-        .test(Component.USER);
-  }
-
-  @Test public void passwordCharacters() throws Exception {
-    new UrlComponentEncodingTester()
-        .override(Encoding.PERCENT, '[', ']', '{', '}', '|', '^', '\'', ':', ';', '=', '@')
-        .override(Encoding.SKIP, '/', '\\', '?', '#')
-        .skipForUri('%')
-        .test(Component.PASSWORD);
-  }
-
-  @Test public void hostContainsIllegalCharacter() throws Exception {
-    assertInvalid("http://\n/", "Invalid URL host: \"\n\"");
-    assertInvalid("http:// /", "Invalid URL host: \" \"");
-    assertInvalid("http://%20/", "Invalid URL host: \"%20\"");
-  }
-
-  @Test public void hostnameLowercaseCharactersMappedDirectly() throws Exception {
-    assertThat(parse("http://abcd").host()).isEqualTo("abcd");
-    assertThat(parse("http://").host()).isEqualTo("xn--4xa");
-  }
-
-  @Test public void hostnameUppercaseCharactersConvertedToLowercase() throws Exception {
-    assertThat(parse("http://ABCD").host()).isEqualTo("abcd");
-    assertThat(parse("http://").host()).isEqualTo("xn--4xa");
-  }
-
-  @Test public void hostnameIgnoredCharacters() throws Exception {
-    // The soft hyphen () should be ignored.
-    assertThat(parse("http://AB\u00adCD").host()).isEqualTo("abcd");
-  }
-
-  @Test public void hostnameMultipleCharacterMapping() throws Exception {
-    // Map the single character telephone symbol () to the string "tel".
-    assertThat(parse("http://\u2121").host()).isEqualTo("tel");
-  }
-
-  @Test public void hostnameMappingLastMappedCodePoint() throws Exception {
-    assertThat(parse("http://\uD87E\uDE1D").host()).isEqualTo("xn--pu5l");
-  }
-
-  @Ignore("The java.net.IDN implementation doesn't ignore characters that it should.")
-  @Test public void hostnameMappingLastIgnoredCodePoint() throws Exception {
-    assertThat(parse("http://ab\uDB40\uDDEFcd").host()).isEqualTo("abcd");
-  }
-
-  @Test public void hostnameMappingLastDisallowedCodePoint() throws Exception {
-    assertInvalid("http://\uDBFF\uDFFF", "Invalid URL host: \"\uDBFF\uDFFF\"");
-  }
-
-  @Test public void hostIpv6() throws Exception {
-    // Square braces are absent from host()...
-    assertThat(parse("http://[::1]/").host()).isEqualTo("::1");
-
-    // ... but they're included in toString().
-    assertThat(parse("http://[::1]/").toString()).isEqualTo("http://[::1]/");
-
-    // IPv6 colons don't interfere with port numbers or passwords.
-    assertThat(parse("http://[::1]:8080/").port()).isEqualTo(8080);
-    assertThat(parse("http://user:password@[::1]/").password()).isEqualTo("password");
-    assertThat(parse("http://user:password@[::1]:8080/").host()).isEqualTo("::1");
-
-    // Permit the contents of IPv6 addresses to be percent-encoded...
-    assertThat(parse("http://[%3A%3A%31]/").host()).isEqualTo("::1");
-
-    // Including the Square braces themselves! (This is what Chrome does.)
-    assertThat(parse("http://%5B%3A%3A1%5D/").host()).isEqualTo("::1");
-  }
-
-  @Test public void hostIpv6AddressDifferentFormats() throws Exception {
-    // Multiple representations of the same address; see http://tools.ietf.org/html/rfc5952.
-    String a3 = "2001:db8::1:0:0:1";
-    assertThat(parse("http://[2001:db8:0:0:1:0:0:1]").host()).isEqualTo(a3);
-    assertThat(parse("http://[2001:0db8:0:0:1:0:0:1]").host()).isEqualTo(a3);
-    assertThat(parse("http://[2001:db8::1:0:0:1]").host()).isEqualTo(a3);
-    assertThat(parse("http://[2001:db8::0:1:0:0:1]").host()).isEqualTo(a3);
-    assertThat(parse("http://[2001:0db8::1:0:0:1]").host()).isEqualTo(a3);
-    assertThat(parse("http://[2001:db8:0:0:1::1]").host()).isEqualTo(a3);
-    assertThat(parse("http://[2001:db8:0000:0:1::1]").host()).isEqualTo(a3);
-    assertThat(parse("http://[2001:DB8:0:0:1::1]").host()).isEqualTo(a3);
-  }
-
-  @Test public void hostIpv6AddressLeadingCompression() throws Exception {
-    assertThat(parse("http://[::0001]").host()).isEqualTo("::1");
-    assertThat(parse("http://[0000::0001]").host()).isEqualTo("::1");
-    assertThat(parse("http://[0000:0000:0000:0000:0000:0000:0000:0001]").host())
-        .isEqualTo("::1");
-    assertThat(parse("http://[0000:0000:0000:0000:0000:0000::0001]").host())
-        .isEqualTo("::1");
-  }
-
-  @Test public void hostIpv6AddressTrailingCompression() throws Exception {
-    assertThat(parse("http://[0001:0000::]").host()).isEqualTo("1::");
-    assertThat(parse("http://[0001::0000]").host()).isEqualTo("1::");
-    assertThat(parse("http://[0001::]").host()).isEqualTo("1::");
-    assertThat(parse("http://[1::]").host()).isEqualTo("1::");
-  }
-
-  @Test public void hostIpv6AddressTooManyDigitsInGroup() throws Exception {
-    assertInvalid("http://[00000:0000:0000:0000:0000:0000:0000:0001]",
-        "Invalid URL host: \"[00000:0000:0000:0000:0000:0000:0000:0001]\"");
-    assertInvalid("http://[::00001]", "Invalid URL host: \"[::00001]\"");
-  }
-
-  @Test public void hostIpv6AddressMisplacedColons() throws Exception {
-    assertInvalid("http://[:0000:0000:0000:0000:0000:0000:0000:0001]",
-        "Invalid URL host: \"[:0000:0000:0000:0000:0000:0000:0000:0001]\"");
-    assertInvalid("http://[:::0000:0000:0000:0000:0000:0000:0000:0001]",
-        "Invalid URL host: \"[:::0000:0000:0000:0000:0000:0000:0000:0001]\"");
-    assertInvalid("http://[:1]", "Invalid URL host: \"[:1]\"");
-    assertInvalid("http://[:::1]", "Invalid URL host: \"[:::1]\"");
-    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0001:]",
-        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0001:]\"");
-    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0001:]",
-        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0001:]\"");
-    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0001::]",
-        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0001::]\"");
-    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0001:::]",
-        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0001:::]\"");
-    assertInvalid("http://[1:]", "Invalid URL host: \"[1:]\"");
-    assertInvalid("http://[1:::]", "Invalid URL host: \"[1:::]\"");
-    assertInvalid("http://[1:::1]", "Invalid URL host: \"[1:::1]\"");
-    assertInvalid("http://[0000:0000:0000:0000::0000:0000:0000:0001]",
-        "Invalid URL host: \"[0000:0000:0000:0000::0000:0000:0000:0001]\"");
-  }
-
-  @Test public void hostIpv6AddressTooManyGroups() throws Exception {
-    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0000:0001]",
-        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0000:0001]\"");
-  }
-
-  @Test public void hostIpv6AddressTooMuchCompression() throws Exception {
-    assertInvalid("http://[0000::0000:0000:0000:0000::0001]",
-        "Invalid URL host: \"[0000::0000:0000:0000:0000::0001]\"");
-    assertInvalid("http://[::0000:0000:0000:0000::0001]",
-        "Invalid URL host: \"[::0000:0000:0000:0000::0001]\"");
-  }
-
-  @Test public void hostIpv6ScopedAddress() throws Exception {
-    // java.net.InetAddress parses scoped addresses. These aren't valid in URLs.
-    assertInvalid("http://[::1%2544]", "Invalid URL host: \"[::1%2544]\"");
-  }
-
-  @Test public void hostIpv6AddressTooManyLeadingZeros() throws Exception {
-    // Guava's been buggy on this case. https://github.com/google/guava/issues/3116
-    assertInvalid("http://[2001:db8:0:0:1:0:0:00001]",
-        "Invalid URL host: \"[2001:db8:0:0:1:0:0:00001]\"");
-  }
-
-  @Test public void hostIpv6WithIpv4Suffix() throws Exception {
-    assertThat(parse("http://[::1:255.255.255.255]/").host()).isEqualTo("::1:ffff:ffff");
-    assertThat(parse("http://[0:0:0:0:0:1:0.0.0.0]/").host()).isEqualTo("::1:0:0");
-  }
-
-  @Test public void hostIpv6WithIpv4SuffixWithOctalPrefix() throws Exception {
-    // Chrome interprets a leading '0' as octal; Firefox rejects them. (We reject them.)
-    assertInvalid("http://[0:0:0:0:0:1:0.0.0.000000]/",
-        "Invalid URL host: \"[0:0:0:0:0:1:0.0.0.000000]\"");
-    assertInvalid("http://[0:0:0:0:0:1:0.010.0.010]/",
-        "Invalid URL host: \"[0:0:0:0:0:1:0.010.0.010]\"");
-    assertInvalid("http://[0:0:0:0:0:1:0.0.0.000001]/",
-        "Invalid URL host: \"[0:0:0:0:0:1:0.0.0.000001]\"");
-  }
-
-  @Test public void hostIpv6WithIpv4SuffixWithHexadecimalPrefix() throws Exception {
-    // Chrome interprets a leading '0x' as hexadecimal; Firefox rejects them. (We reject them.)
-    assertInvalid("http://[0:0:0:0:0:1:0.0x10.0.0x10]/",
-        "Invalid URL host: \"[0:0:0:0:0:1:0.0x10.0.0x10]\"");
-  }
-
-  @Test public void hostIpv6WithMalformedIpv4Suffix() throws Exception {
-    assertInvalid("http://[0:0:0:0:0:1:0.0:0.0]/", "Invalid URL host: \"[0:0:0:0:0:1:0.0:0.0]\"");
-    assertInvalid("http://[0:0:0:0:0:1:0.0-0.0]/", "Invalid URL host: \"[0:0:0:0:0:1:0.0-0.0]\"");
-    assertInvalid("http://[0:0:0:0:0:1:.255.255.255]/",
-        "Invalid URL host: \"[0:0:0:0:0:1:.255.255.255]\"");
-    assertInvalid("http://[0:0:0:0:0:1:255..255.255]/",
-        "Invalid URL host: \"[0:0:0:0:0:1:255..255.255]\"");
-    assertInvalid("http://[0:0:0:0:0:1:255.255..255]/",
-        "Invalid URL host: \"[0:0:0:0:0:1:255.255..255]\"");
-    assertInvalid("http://[0:0:0:0:0:0:1:255.255]/",
-        "Invalid URL host: \"[0:0:0:0:0:0:1:255.255]\"");
-    assertInvalid("http://[0:0:0:0:0:1:256.255.255.255]/",
-        "Invalid URL host: \"[0:0:0:0:0:1:256.255.255.255]\"");
-    assertInvalid("http://[0:0:0:0:0:1:ff.255.255.255]/",
-        "Invalid URL host: \"[0:0:0:0:0:1:ff.255.255.255]\"");
-    assertInvalid("http://[0:0:0:0:0:0:1:255.255.255.255]/",
-        "Invalid URL host: \"[0:0:0:0:0:0:1:255.255.255.255]\"");
-    assertInvalid("http://[0:0:0:0:1:255.255.255.255]/",
-        "Invalid URL host: \"[0:0:0:0:1:255.255.255.255]\"");
-    assertInvalid("http://[0:0:0:0:1:0.0.0.0:1]/", "Invalid URL host: \"[0:0:0:0:1:0.0.0.0:1]\"");
-    assertInvalid("http://[0:0.0.0.0:1:0:0:0:0:1]/",
-        "Invalid URL host: \"[0:0.0.0.0:1:0:0:0:0:1]\"");
-    assertInvalid("http://[0.0.0.0:0:0:0:0:0:1]/", "Invalid URL host: \"[0.0.0.0:0:0:0:0:0:1]\"");
-  }
-
-  @Test public void hostIpv6WithIncompleteIpv4Suffix() throws Exception {
-    // To Chrome & Safari these are well-formed; Firefox disagrees. (We're consistent with Firefox).
-    assertInvalid("http://[0:0:0:0:0:1:255.255.255.]/",
-        "Invalid URL host: \"[0:0:0:0:0:1:255.255.255.]\"");
-    assertInvalid("http://[0:0:0:0:0:1:255.255.255]/",
-        "Invalid URL host: \"[0:0:0:0:0:1:255.255.255]\"");
-  }
-
-  @Test public void hostIpv6Malformed() throws Exception {
-    assertInvalid("http://[::g]/", "Invalid URL host: \"[::g]\"");
-  }
-
-  @Test public void hostIpv6CanonicalForm() throws Exception {
-    assertThat(parse("http://[abcd:ef01:2345:6789:abcd:ef01:2345:6789]/").host())
-        .isEqualTo("abcd:ef01:2345:6789:abcd:ef01:2345:6789");
-    assertThat(parse("http://[a:0:0:0:b:0:0:0]/").host()).isEqualTo("a::b:0:0:0");
-    assertThat(parse("http://[a:b:0:0:c:0:0:0]/").host()).isEqualTo("a:b:0:0:c::");
-    assertThat(parse("http://[a:b:0:0:0:c:0:0]/").host()).isEqualTo("a:b::c:0:0");
-    assertThat(parse("http://[a:0:0:0:b:0:0:0]/").host()).isEqualTo("a::b:0:0:0");
-    assertThat(parse("http://[0:0:0:a:b:0:0:0]/").host()).isEqualTo("::a:b:0:0:0");
-    assertThat(parse("http://[0:0:0:a:0:0:0:b]/").host()).isEqualTo("::a:0:0:0:b");
-    assertThat(parse("http://[0:a:b:c:d:e:f:1]/").host()).isEqualTo("0:a:b:c:d:e:f:1");
-    assertThat(parse("http://[a:b:c:d:e:f:1:0]/").host()).isEqualTo("a:b:c:d:e:f:1:0");
-    assertThat(parse("http://[FF01:0:0:0:0:0:0:101]/").host()).isEqualTo("ff01::101");
-    assertThat(parse("http://[2001:db8::1]/").host()).isEqualTo("2001:db8::1");
-    assertThat(parse("http://[2001:db8:0:0:0:0:2:1]/").host()).isEqualTo("2001:db8::2:1");
-    assertThat(parse("http://[2001:db8:0:1:1:1:1:1]/").host())
-        .isEqualTo("2001:db8:0:1:1:1:1:1");
-    assertThat(parse("http://[2001:db8:0:0:1:0:0:1]/").host())
-        .isEqualTo("2001:db8::1:0:0:1");
-    assertThat(parse("http://[2001:0:0:1:0:0:0:1]/").host()).isEqualTo("2001:0:0:1::1");
-    assertThat(parse("http://[1:0:0:0:0:0:0:0]/").host()).isEqualTo("1::");
-    assertThat(parse("http://[0:0:0:0:0:0:0:1]/").host()).isEqualTo("::1");
-    assertThat(parse("http://[0:0:0:0:0:0:0:0]/").host()).isEqualTo("::");
-    assertThat(parse("http://[::ffff:c0a8:1fe]/").host()).isEqualTo("192.168.1.254");
-  }
-
-  /** The builder permits square braces but does not require them. */
-  @Test public void hostIpv6Builder() throws Exception {
-    HttpUrl base = parse("http://example.com/");
-    assertThat(base.newBuilder().host("[::1]").build().toString())
-        .isEqualTo("http://[::1]/");
-    assertThat(base.newBuilder().host("[::0001]").build().toString())
-        .isEqualTo("http://[::1]/");
-    assertThat(base.newBuilder().host("::1").build().toString()).isEqualTo("http://[::1]/");
-    assertThat(base.newBuilder().host("::0001").build().toString())
-        .isEqualTo("http://[::1]/");
-  }
-
-  @Test public void hostIpv4CanonicalForm() throws Exception {
-    assertThat(parse("http://255.255.255.255/").host()).isEqualTo("255.255.255.255");
-    assertThat(parse("http://1.2.3.4/").host()).isEqualTo("1.2.3.4");
-    assertThat(parse("http://0.0.0.0/").host()).isEqualTo("0.0.0.0");
-  }
-
-  @Test public void hostWithTrailingDot() throws Exception {
-    assertThat(parse("http://host./").host()).isEqualTo("host.");
-  }
-
-  @Test public void port() throws Exception {
-    assertThat(parse("http://host:80/")).isEqualTo(parse("http://host/"));
-    assertThat(parse("http://host:99/")).isEqualTo(parse("http://host:99/"));
-    assertThat(parse("http://host:/")).isEqualTo(parse("http://host/"));
-    assertThat(parse("http://host:65535/").port()).isEqualTo(65535);
-    assertInvalid("http://host:0/", "Invalid URL port: \"0\"");
-    assertInvalid("http://host:65536/", "Invalid URL port: \"65536\"");
-    assertInvalid("http://host:-1/", "Invalid URL port: \"-1\"");
-    assertInvalid("http://host:a/", "Invalid URL port: \"a\"");
-    assertInvalid("http://host:%39%39/", "Invalid URL port: \"%39%39\"");
-  }
-
-  @Test public void pathCharacters() throws Exception {
-    new UrlComponentEncodingTester()
-        .override(Encoding.PERCENT, '^', '{', '}', '|')
-        .override(Encoding.SKIP, '\\', '?', '#')
-        .skipForUri('%', '[', ']')
-        .test(Component.PATH);
-  }
-
-  @Test public void queryCharacters() throws Exception {
-    new UrlComponentEncodingTester()
-        .override(Encoding.IDENTITY, '?', '`')
-        .override(Encoding.PERCENT, '\'')
-        .override(Encoding.SKIP, '#', '+')
-        .skipForUri('%', '\\', '^', '`', '{', '|', '}')
-        .test(Component.QUERY);
-  }
-
-  @Test public void queryValueCharacters() throws Exception {
-    new UrlComponentEncodingTester()
-        .override(Encoding.IDENTITY, '?', '`')
-        .override(Encoding.PERCENT, '\'')
-        .override(Encoding.SKIP, '#', '+')
-        .skipForUri('%', '\\', '^', '`', '{', '|', '}')
-        .test(Component.QUERY_VALUE);
-  }
-
-  @Test public void fragmentCharacters() throws Exception {
-    new UrlComponentEncodingTester()
-        .override(Encoding.IDENTITY, ' ', '"', '#', '<', '>', '?', '`')
-        .skipForUri('%', ' ', '"', '#', '<', '>', '\\', '^', '`', '{', '|', '}')
-        .identityForNonAscii()
-        .test(Component.FRAGMENT);
-  }
-
-  @Test public void fragmentNonAscii() throws Exception {
-    HttpUrl url = parse("http://host/#");
-    assertThat(url.toString()).isEqualTo("http://host/#");
-    assertThat(url.fragment()).isEqualTo("");
-    assertThat(url.encodedFragment()).isEqualTo("");
-    assertThat(url.uri().toString()).isEqualTo("http://host/#");
-  }
-
-  @Test public void fragmentNonAsciiThatOffendsJavaNetUri() throws Exception {
-    HttpUrl url = parse("http://host/#\u0080");
-    assertThat(url.toString()).isEqualTo("http://host/#\u0080");
-    assertThat(url.fragment()).isEqualTo("\u0080");
-    assertThat(url.encodedFragment()).isEqualTo("\u0080");
-    // Control characters may be stripped!
-    assertThat(url.uri()).isEqualTo(new URI("http://host/#"));
-  }
-
-  @Test public void fragmentPercentEncodedNonAscii() throws Exception {
-    HttpUrl url = parse("http://host/#%C2%80");
-    assertThat(url.toString()).isEqualTo("http://host/#%C2%80");
-    assertThat(url.fragment()).isEqualTo("\u0080");
-    assertThat(url.encodedFragment()).isEqualTo("%C2%80");
-    assertThat(url.uri().toString()).isEqualTo("http://host/#%C2%80");
-  }
-
-  @Test public void fragmentPercentEncodedPartialCodePoint() throws Exception {
-    HttpUrl url = parse("http://host/#%80");
-    assertThat(url.toString()).isEqualTo("http://host/#%80");
-    // Unicode replacement character.
-    assertThat(url.fragment()).isEqualTo("\ufffd");
-    assertThat(url.encodedFragment()).isEqualTo("%80");
-    assertThat(url.uri().toString()).isEqualTo("http://host/#%80");
-  }
-
-  @Test public void relativePath() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertThat(base.resolve("d/e/f")).isEqualTo(parse("http://host/a/b/d/e/f"));
-    assertThat(base.resolve("../../d/e/f")).isEqualTo(parse("http://host/d/e/f"));
-    assertThat(base.resolve("..")).isEqualTo(parse("http://host/a/"));
-    assertThat(base.resolve("../..")).isEqualTo(parse("http://host/"));
-    assertThat(base.resolve("../../..")).isEqualTo(parse("http://host/"));
-    assertThat(base.resolve(".")).isEqualTo(parse("http://host/a/b/"));
-    assertThat(base.resolve("././..")).isEqualTo(parse("http://host/a/"));
-    assertThat(base.resolve("c/d/../e/../")).isEqualTo(parse("http://host/a/b/c/"));
-    assertThat(base.resolve("..e/")).isEqualTo(parse("http://host/a/b/..e/"));
-    assertThat(base.resolve("e/f../")).isEqualTo(parse("http://host/a/b/e/f../"));
-    assertThat(base.resolve("%2E.")).isEqualTo(parse("http://host/a/"));
-    assertThat(base.resolve(".%2E")).isEqualTo(parse("http://host/a/"));
-    assertThat(base.resolve("%2E%2E")).isEqualTo(parse("http://host/a/"));
-    assertThat(base.resolve("%2e.")).isEqualTo(parse("http://host/a/"));
-    assertThat(base.resolve(".%2e")).isEqualTo(parse("http://host/a/"));
-    assertThat(base.resolve("%2e%2e")).isEqualTo(parse("http://host/a/"));
-    assertThat(base.resolve("%2E")).isEqualTo(parse("http://host/a/b/"));
-    assertThat(base.resolve("%2e")).isEqualTo(parse("http://host/a/b/"));
-  }
-
-  @Test public void relativePathWithTrailingSlash() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c/");
-    assertThat(base.resolve("..")).isEqualTo(parse("http://host/a/b/"));
-    assertThat(base.resolve("../")).isEqualTo(parse("http://host/a/b/"));
-    assertThat(base.resolve("../..")).isEqualTo(parse("http://host/a/"));
-    assertThat(base.resolve("../../")).isEqualTo(parse("http://host/a/"));
-    assertThat(base.resolve("../../..")).isEqualTo(parse("http://host/"));
-    assertThat(base.resolve("../../../")).isEqualTo(parse("http://host/"));
-    assertThat(base.resolve("../../../..")).isEqualTo(parse("http://host/"));
-    assertThat(base.resolve("../../../../")).isEqualTo(parse("http://host/"));
-    assertThat(base.resolve("../../../../a")).isEqualTo(parse("http://host/a"));
-    assertThat(base.resolve("../../../../a/..")).isEqualTo(parse("http://host/"));
-    assertThat(base.resolve("../../../../a/b/..")).isEqualTo(parse("http://host/a/"));
-  }
-
-  @Test public void pathWithBackslash() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertThat(base.resolve("d\\e\\f")).isEqualTo(parse("http://host/a/b/d/e/f"));
-    assertThat(base.resolve("../..\\d\\e\\f")).isEqualTo(parse("http://host/d/e/f"));
-    assertThat(base.resolve("..\\..")).isEqualTo(parse("http://host/"));
-  }
-
-  @Test public void relativePathWithSameScheme() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertThat(base.resolve("http:d/e/f")).isEqualTo(parse("http://host/a/b/d/e/f"));
-    assertThat(base.resolve("http:../../d/e/f")).isEqualTo(parse("http://host/d/e/f"));
-  }
-
-  @Test public void decodeUsername() {
-    assertThat(parse("http://user@host/").username()).isEqualTo("user");
-    assertThat(parse("http://%F0%9F%8D%A9@host/").username()).isEqualTo("\uD83C\uDF69");
-  }
-
-  @Test public void decodePassword() {
-    assertThat(parse("http://user:password@host/").password()).isEqualTo("password");
-    assertThat(parse("http://user:@host/").password()).isEqualTo("");
-    assertThat(parse("http://user:%F0%9F%8D%A9@host/").password())
-        .isEqualTo("\uD83C\uDF69");
-  }
-
-  @Test public void decodeSlashCharacterInDecodedPathSegment() {
-    assertThat(parse("http://host/a%2Fb%2Fc").pathSegments()).containsExactly("a/b/c");
-  }
-
-  @Test public void decodeEmptyPathSegments() {
-    assertThat(parse("http://host/").pathSegments()).containsExactly("");
-  }
-
-  @Test public void percentDecode() throws Exception {
-    assertThat(parse("http://host/%00").pathSegments()).containsExactly("\u0000");
-    assertThat(parse("http://host/a/%E2%98%83/c").pathSegments()).containsExactly("a", "\u2603", "c");
-    assertThat(parse("http://host/a/%F0%9F%8D%A9/c").pathSegments()).containsExactly("a", "\uD83C\uDF69", "c");
-    assertThat(parse("http://host/a/%62/c").pathSegments()).containsExactly("a", "b", "c");
-    assertThat(parse("http://host/a/%7A/c").pathSegments()).containsExactly("a", "z", "c");
-    assertThat(parse("http://host/a/%7a/c").pathSegments()).containsExactly("a", "z", "c");
-  }
-
-  @Test public void malformedPercentEncoding() {
-    assertThat(parse("http://host/a%f/b").pathSegments()).containsExactly("a%f", "b");
-    assertThat(parse("http://host/%/b").pathSegments()).containsExactly("%", "b");
-    assertThat(parse("http://host/%").pathSegments()).containsExactly("%");
-    assertThat(parse("http://github.com/%%30%30").pathSegments()).containsExactly("%00");
-  }
-
-  @Test public void malformedUtf8Encoding() {
-    // Replace a partial UTF-8 sequence with the Unicode replacement character.
-    assertThat(parse("http://host/a/%E2%98x/c").pathSegments())
-        .containsExactly("a", "\ufffdx", "c");
-  }
-
-  @Test public void incompleteUrlComposition() throws Exception {
-    try {
-      new HttpUrl.Builder().scheme("http").build();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertThat(expected.getMessage()).isEqualTo("host == null");
-    }
-    try {
-      new HttpUrl.Builder().host("host").build();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertThat(expected.getMessage()).isEqualTo("scheme == null");
-    }
-  }
-
-  @Test public void builderToString() {
-    assertThat(parse("https://host.com/path").newBuilder().toString())
-        .isEqualTo("https://host.com/path");
-  }
-
-  @Test public void incompleteBuilderToString() {
-    assertThat(new HttpUrl.Builder().scheme("https").encodedPath("/path").toString())
-        .isEqualTo("https:///path");
-    assertThat(new HttpUrl.Builder().host("host.com").encodedPath("/path").toString())
-        .isEqualTo("//host.com/path");
-    assertThat(new HttpUrl.Builder().host("host.com").encodedPath("/path").port(8080).toString())
-        .isEqualTo("//host.com:8080/path");
-  }
-
-  @Test public void minimalUrlComposition() throws Exception {
-    HttpUrl url = new HttpUrl.Builder().scheme("http").host("host").build();
-    assertThat(url.toString()).isEqualTo("http://host/");
-    assertThat(url.scheme()).isEqualTo("http");
-    assertThat(url.username()).isEqualTo("");
-    assertThat(url.password()).isEqualTo("");
-    assertThat(url.host()).isEqualTo("host");
-    assertThat(url.port()).isEqualTo(80);
-    assertThat(url.encodedPath()).isEqualTo("/");
-    assertThat(url.query()).isNull();
-    assertThat(url.fragment()).isNull();
-  }
-
-  @Test public void fullUrlComposition() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .username("username")
-        .password("password")
-        .host("host")
-        .port(8080)
-        .addPathSegment("path")
-        .query("query")
-        .fragment("fragment")
-        .build();
-    assertThat(url.toString())
-        .isEqualTo("http://username:password@host:8080/path?query#fragment");
-    assertThat(url.scheme()).isEqualTo("http");
-    assertThat(url.username()).isEqualTo("username");
-    assertThat(url.password()).isEqualTo("password");
-    assertThat(url.host()).isEqualTo("host");
-    assertThat(url.port()).isEqualTo(8080);
-    assertThat(url.encodedPath()).isEqualTo("/path");
-    assertThat(url.query()).isEqualTo("query");
-    assertThat(url.fragment()).isEqualTo("fragment");
-  }
-
-  @Test public void changingSchemeChangesDefaultPort() throws Exception {
-    assertThat(parse("http://example.com")
-        .newBuilder()
-        .scheme("https")
-        .build().port()).isEqualTo(443);
-
-    assertThat(parse("https://example.com")
-        .newBuilder()
-        .scheme("http")
-        .build().port()).isEqualTo(80);
-
-    assertThat(parse("https://example.com:1234")
-        .newBuilder()
-        .scheme("http")
-        .build().port()).isEqualTo(1234);
-  }
-
-  @Test public void composeEncodesWhitespace() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .username("a\r\n\f\t b")
-        .password("c\r\n\f\t d")
-        .host("host")
-        .addPathSegment("e\r\n\f\t f")
-        .query("g\r\n\f\t h")
-        .fragment("i\r\n\f\t j")
-        .build();
-    assertThat(url.toString()).isEqualTo(("http://a%0D%0A%0C%09%20b:c%0D%0A%0C%09%20d@host"
-        + "/e%0D%0A%0C%09%20f?g%0D%0A%0C%09%20h#i%0D%0A%0C%09 j"));
-    assertThat(url.username()).isEqualTo("a\r\n\f\t b");
-    assertThat(url.password()).isEqualTo("c\r\n\f\t d");
-    assertThat(url.pathSegments().get(0)).isEqualTo("e\r\n\f\t f");
-    assertThat(url.query()).isEqualTo("g\r\n\f\t h");
-    assertThat(url.fragment()).isEqualTo("i\r\n\f\t j");
-  }
-
-  @Test public void composeFromUnencodedComponents() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .username("a:\u0001@/\\?#%b")
-        .password("c:\u0001@/\\?#%d")
-        .host("ef")
-        .port(8080)
-        .addPathSegment("g:\u0001@/\\?#%h")
-        .query("i:\u0001@/\\?#%j")
-        .fragment("k:\u0001@/\\?#%l")
-        .build();
-    assertThat(url.toString())
-        .isEqualTo(("http://a%3A%01%40%2F%5C%3F%23%25b:c%3A%01%40%2F%5C%3F%23%25d@ef:8080/"
-        + "g:%01@%2F%5C%3F%23%25h?i:%01@/\\?%23%25j#k:%01@/\\?#%25l"));
-    assertThat(url.scheme()).isEqualTo("http");
-    assertThat(url.username()).isEqualTo("a:\u0001@/\\?#%b");
-    assertThat(url.password()).isEqualTo("c:\u0001@/\\?#%d");
-    assertThat(url.pathSegments()).containsExactly("g:\u0001@/\\?#%h");
-    assertThat(url.query()).isEqualTo("i:\u0001@/\\?#%j");
-    assertThat(url.fragment()).isEqualTo("k:\u0001@/\\?#%l");
-    assertThat(url.encodedUsername()).isEqualTo("a%3A%01%40%2F%5C%3F%23%25b");
-    assertThat(url.encodedPassword()).isEqualTo("c%3A%01%40%2F%5C%3F%23%25d");
-    assertThat(url.encodedPath()).isEqualTo("/g:%01@%2F%5C%3F%23%25h");
-    assertThat(url.encodedQuery()).isEqualTo("i:%01@/\\?%23%25j");
-    assertThat(url.encodedFragment()).isEqualTo("k:%01@/\\?#%25l");
-  }
-
-  @Test public void composeFromEncodedComponents() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .encodedUsername("a:\u0001@/\\?#%25b")
-        .encodedPassword("c:\u0001@/\\?#%25d")
-        .host("ef")
-        .port(8080)
-        .addEncodedPathSegment("g:\u0001@/\\?#%25h")
-        .encodedQuery("i:\u0001@/\\?#%25j")
-        .encodedFragment("k:\u0001@/\\?#%25l")
-        .build();
-    assertThat(url.toString())
-        .isEqualTo(("http://a%3A%01%40%2F%5C%3F%23%25b:c%3A%01%40%2F%5C%3F%23%25d@ef:8080/"
-        + "g:%01@%2F%5C%3F%23%25h?i:%01@/\\?%23%25j#k:%01@/\\?#%25l"));
-    assertThat(url.scheme()).isEqualTo("http");
-    assertThat(url.username()).isEqualTo("a:\u0001@/\\?#%b");
-    assertThat(url.password()).isEqualTo("c:\u0001@/\\?#%d");
-    assertThat(url.pathSegments()).containsExactly("g:\u0001@/\\?#%h");
-    assertThat(url.query()).isEqualTo("i:\u0001@/\\?#%j");
-    assertThat(url.fragment()).isEqualTo("k:\u0001@/\\?#%l");
-    assertThat(url.encodedUsername()).isEqualTo("a%3A%01%40%2F%5C%3F%23%25b");
-    assertThat(url.encodedPassword()).isEqualTo("c%3A%01%40%2F%5C%3F%23%25d");
-    assertThat(url.encodedPath()).isEqualTo("/g:%01@%2F%5C%3F%23%25h");
-    assertThat(url.encodedQuery()).isEqualTo("i:%01@/\\?%23%25j");
-    assertThat(url.encodedFragment()).isEqualTo("k:%01@/\\?#%25l");
-  }
-
-  @Test public void composeWithEncodedPath() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .encodedPath("/a%2Fb/c")
-        .build();
-    assertThat(url.toString()).isEqualTo("http://host/a%2Fb/c");
-    assertThat(url.encodedPath()).isEqualTo("/a%2Fb/c");
-    assertThat(url.pathSegments()).containsExactly("a/b", "c");
-  }
-
-  @Test public void composeMixingPathSegments() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .encodedPath("/a%2fb/c")
-        .addPathSegment("d%25e")
-        .addEncodedPathSegment("f%25g")
-        .build();
-    assertThat(url.toString()).isEqualTo("http://host/a%2fb/c/d%2525e/f%25g");
-    assertThat(url.encodedPath()).isEqualTo("/a%2fb/c/d%2525e/f%25g");
-    assertThat(url.encodedPathSegments()).containsExactly("a%2fb", "c", "d%2525e", "f%25g");
-    assertThat(url.pathSegments()).containsExactly("a/b", "c", "d%25e", "f%g");
-  }
-
-  @Test public void composeWithAddSegment() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertThat(base.newBuilder().addPathSegment("").build().encodedPath())
-        .isEqualTo("/a/b/c/");
-    assertThat(base.newBuilder().addPathSegment("").addPathSegment("d").build().encodedPath())
-        .isEqualTo("/a/b/c/d");
-    assertThat(base.newBuilder().addPathSegment("..").build().encodedPath())
-        .isEqualTo("/a/b/");
-    assertThat(base.newBuilder().addPathSegment("").addPathSegment("..").build().encodedPath())
-        .isEqualTo("/a/b/");
-    assertThat(base.newBuilder().addPathSegment("").addPathSegment("").build().encodedPath())
-        .isEqualTo("/a/b/c/");
-  }
-
-  @Test public void pathSize() throws Exception {
-    assertThat(parse("http://host/").pathSize()).isEqualTo(1);
-    assertThat(parse("http://host/a/b/c").pathSize()).isEqualTo(3);
-  }
-
-  @Test public void addPathSegments() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-
-    // Add a string with zero slashes: resulting URL gains one slash.
-    assertThat(base.newBuilder().addPathSegments("").build().encodedPath())
-        .isEqualTo("/a/b/c/");
-    assertThat(base.newBuilder().addPathSegments("d").build().encodedPath())
-        .isEqualTo("/a/b/c/d");
-
-    // Add a string with one slash: resulting URL gains two slashes.
-    assertThat(base.newBuilder().addPathSegments("/").build().encodedPath())
-        .isEqualTo("/a/b/c//");
-    assertThat(base.newBuilder().addPathSegments("d/").build().encodedPath())
-        .isEqualTo("/a/b/c/d/");
-    assertThat(base.newBuilder().addPathSegments("/d").build().encodedPath())
-        .isEqualTo("/a/b/c//d");
-
-    // Add a string with two slashes: resulting URL gains three slashes.
-    assertThat(base.newBuilder().addPathSegments("//").build().encodedPath())
-        .isEqualTo("/a/b/c///");
-    assertThat(base.newBuilder().addPathSegments("/d/").build().encodedPath())
-        .isEqualTo("/a/b/c//d/");
-    assertThat(base.newBuilder().addPathSegments("d//").build().encodedPath())
-        .isEqualTo("/a/b/c/d//");
-    assertThat(base.newBuilder().addPathSegments("//d").build().encodedPath())
-        .isEqualTo("/a/b/c///d");
-    assertThat(base.newBuilder().addPathSegments("d/e/f").build().encodedPath())
-        .isEqualTo("/a/b/c/d/e/f");
-  }
-
-  @Test public void addPathSegmentsOntoTrailingSlash() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c/");
-
-    // Add a string with zero slashes: resulting URL gains zero slashes.
-    assertThat(base.newBuilder().addPathSegments("").build().encodedPath())
-        .isEqualTo("/a/b/c/");
-    assertThat(base.newBuilder().addPathSegments("d").build().encodedPath())
-        .isEqualTo("/a/b/c/d");
-
-    // Add a string with one slash: resulting URL gains one slash.
-    assertThat(base.newBuilder().addPathSegments("/").build().encodedPath())
-        .isEqualTo("/a/b/c//");
-    assertThat(base.newBuilder().addPathSegments("d/").build().encodedPath())
-        .isEqualTo("/a/b/c/d/");
-    assertThat(base.newBuilder().addPathSegments("/d").build().encodedPath())
-        .isEqualTo("/a/b/c//d");
-
-    // Add a string with two slashes: resulting URL gains two slashes.
-    assertThat(base.newBuilder().addPathSegments("//").build().encodedPath())
-        .isEqualTo("/a/b/c///");
-    assertThat(base.newBuilder().addPathSegments("/d/").build().encodedPath())
-        .isEqualTo("/a/b/c//d/");
-    assertThat(base.newBuilder().addPathSegments("d//").build().encodedPath())
-        .isEqualTo("/a/b/c/d//");
-    assertThat(base.newBuilder().addPathSegments("//d").build().encodedPath())
-        .isEqualTo("/a/b/c///d");
-    assertThat(base.newBuilder().addPathSegments("d/e/f").build().encodedPath())
-        .isEqualTo("/a/b/c/d/e/f");
-  }
-
-  @Test public void addPathSegmentsWithBackslash() throws Exception {
-    HttpUrl base = parse("http://host/");
-    assertThat(base.newBuilder().addPathSegments("d\\e").build().encodedPath())
-        .isEqualTo("/d/e");
-    assertThat(base.newBuilder().addEncodedPathSegments("d\\e").build().encodedPath())
-        .isEqualTo("/d/e");
-  }
-
-  @Test public void addPathSegmentsWithEmptyPaths() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertThat(base.newBuilder().addPathSegments("/d/e///f").build().encodedPath())
-        .isEqualTo("/a/b/c//d/e///f");
-  }
-
-  @Test public void addEncodedPathSegments() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertThat(
-        (Object) base.newBuilder().addEncodedPathSegments("d/e/%20/\n").build().encodedPath())
-        .isEqualTo("/a/b/c/d/e/%20/");
-  }
-
-  @Test public void addPathSegmentDotDoesNothing() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertThat(base.newBuilder().addPathSegment(".").build().encodedPath())
-        .isEqualTo("/a/b/c");
-  }
-
-  @Test public void addPathSegmentEncodes() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertThat(base.newBuilder().addPathSegment("%2e").build().encodedPath())
-        .isEqualTo("/a/b/c/%252e");
-    assertThat(base.newBuilder().addPathSegment("%2e%2e").build().encodedPath())
-        .isEqualTo("/a/b/c/%252e%252e");
-  }
-
-  @Test public void addPathSegmentDotDotPopsDirectory() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertThat(base.newBuilder().addPathSegment("..").build().encodedPath())
-        .isEqualTo("/a/b/");
-  }
-
-  @Test public void addPathSegmentDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertThat(base.newBuilder().addPathSegment(".\n").build().encodedPath())
-        .isEqualTo("/a/b/c/.%0A");
-  }
-
-  @Test public void addEncodedPathSegmentDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertThat(base.newBuilder().addEncodedPathSegment(".\n").build().encodedPath())
-        .isEqualTo("/a/b/c");
-  }
-
-  @Test public void addEncodedPathSegmentDotDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertThat(base.newBuilder().addEncodedPathSegment("..\n").build().encodedPath())
-        .isEqualTo("/a/b/");
-  }
-
-  @Test public void setPathSegment() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertThat(base.newBuilder().setPathSegment(0, "d").build().encodedPath())
-        .isEqualTo("/d/b/c");
-    assertThat(base.newBuilder().setPathSegment(1, "d").build().encodedPath())
-        .isEqualTo("/a/d/c");
-    assertThat(base.newBuilder().setPathSegment(2, "d").build().encodedPath())
-        .isEqualTo("/a/b/d");
-  }
-
-  @Test public void setPathSegmentEncodes() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertThat(base.newBuilder().setPathSegment(0, "%25").build().encodedPath())
-        .isEqualTo("/%2525/b/c");
-    assertThat(base.newBuilder().setPathSegment(0, ".\n").build().encodedPath())
-        .isEqualTo("/.%0A/b/c");
-    assertThat(base.newBuilder().setPathSegment(0, "%2e").build().encodedPath())
-        .isEqualTo("/%252e/b/c");
-  }
-
-  @Test public void setPathSegmentAcceptsEmpty() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertThat(base.newBuilder().setPathSegment(0, "").build().encodedPath())
-        .isEqualTo("//b/c");
-    assertThat(base.newBuilder().setPathSegment(2, "").build().encodedPath())
-        .isEqualTo("/a/b/");
-  }
-
-  @Test public void setPathSegmentRejectsDot() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    try {
-      base.newBuilder().setPathSegment(0, ".");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setPathSegmentRejectsDotDot() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    try {
-      base.newBuilder().setPathSegment(0, "..");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setPathSegmentWithSlash() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    HttpUrl url = base.newBuilder().setPathSegment(1, "/").build();
-    assertThat(url.encodedPath()).isEqualTo("/a/%2F/c");
-  }
-
-  @Test public void setPathSegmentOutOfBounds() throws Exception {
-    try {
-      new HttpUrl.Builder().setPathSegment(1, "a");
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-  }
-
-  @Test public void setEncodedPathSegmentEncodes() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    assertThat(base.newBuilder().setEncodedPathSegment(0, "%25").build().encodedPath())
-        .isEqualTo("/%25/b/c");
-  }
-
-  @Test public void setEncodedPathSegmentRejectsDot() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    try {
-      base.newBuilder().setEncodedPathSegment(0, ".");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setEncodedPathSegmentRejectsDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    try {
-      base.newBuilder().setEncodedPathSegment(0, ".\n");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setEncodedPathSegmentRejectsDotDot() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    try {
-      base.newBuilder().setEncodedPathSegment(0, "..");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setEncodedPathSegmentRejectsDotDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    try {
-      base.newBuilder().setEncodedPathSegment(0, "..\n");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setEncodedPathSegmentWithSlash() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    HttpUrl url = base.newBuilder().setEncodedPathSegment(1, "/").build();
-    assertThat(url.encodedPath()).isEqualTo("/a/%2F/c");
-  }
-
-  @Test public void setEncodedPathSegmentOutOfBounds() throws Exception {
-    try {
-      new HttpUrl.Builder().setEncodedPathSegment(1, "a");
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-  }
-
-  @Test public void removePathSegment() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    HttpUrl url = base.newBuilder()
-        .removePathSegment(0)
-        .build();
-    assertThat(url.encodedPath()).isEqualTo("/b/c");
-  }
-
-  @Test public void removePathSegmentDoesntRemovePath() throws Exception {
-    HttpUrl base = parse("http://host/a/b/c");
-    HttpUrl url = base.newBuilder()
-        .removePathSegment(0)
-        .removePathSegment(0)
-        .removePathSegment(0)
-        .build();
-    assertThat(url.pathSegments()).containsExactly("");
-    assertThat(url.encodedPath()).isEqualTo("/");
-  }
-
-  @Test public void removePathSegmentOutOfBounds() throws Exception {
-    try {
-      new HttpUrl.Builder().removePathSegment(1);
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-  }
-
-  @Test public void toJavaNetUrl() throws Exception {
-    HttpUrl httpUrl = parse("http://username:password@host/path?query#fragment");
-    URL javaNetUrl = httpUrl.url();
-    assertThat(javaNetUrl.toString())
-        .isEqualTo("http://username:password@host/path?query#fragment");
-  }
-
-  @Test public void toUri() throws Exception {
-    HttpUrl httpUrl = parse("http://username:password@host/path?query#fragment");
-    URI uri = httpUrl.uri();
-    assertThat(uri.toString())
-        .isEqualTo("http://username:password@host/path?query#fragment");
-  }
-
-  @Test public void toUriSpecialQueryCharacters() throws Exception {
-    HttpUrl httpUrl = parse("http://host/?d=abc!@[]^`{}|\\");
-    URI uri = httpUrl.uri();
-    assertThat(uri.toString()).isEqualTo("http://host/?d=abc!@[]%5E%60%7B%7D%7C%5C");
-  }
-
-  @Test public void toUriWithUsernameNoPassword() throws Exception {
-    HttpUrl httpUrl = new HttpUrl.Builder()
-        .scheme("http")
-        .username("user")
-        .host("host")
-        .build();
-    assertThat(httpUrl.toString()).isEqualTo("http://user@host/");
-    assertThat(httpUrl.uri().toString()).isEqualTo("http://user@host/");
-  }
-
-  @Test public void toUriUsernameSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .username("=[]:;\"~|?#@^/$%*")
-        .build();
-    assertThat(url.toString())
-        .isEqualTo("http://%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/");
-    assertThat(url.uri().toString())
-        .isEqualTo("http://%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/");
-  }
-
-  @Test public void toUriPasswordSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .username("user")
-        .password("=[]:;\"~|?#@^/$%*")
-        .build();
-    assertThat(url.toString())
-        .isEqualTo("http://user:%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/");
-    assertThat(url.uri().toString())
-        .isEqualTo("http://user:%3D%5B%5D%3A%3B%22~%7C%3F%23%40%5E%2F$%25*@host/");
-  }
-
-  @Test public void toUriPathSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .addPathSegment("=[]:;\"~|?#@^/$%*")
-        .build();
-    assertThat(url.toString()).isEqualTo("http://host/=[]:;%22~%7C%3F%23@%5E%2F$%25*");
-    assertThat(url.uri().toString())
-        .isEqualTo("http://host/=%5B%5D:;%22~%7C%3F%23@%5E%2F$%25*");
-  }
-
-  @Test public void toUriQueryParameterNameSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .addQueryParameter("=[]:;\"~|?#@^/$%*", "a")
-        .build();
-    assertThat(url.toString())
-        .isEqualTo("http://host/?%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*=a");
-    assertThat(url.uri().toString())
-        .isEqualTo("http://host/?%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*=a");
-    assertThat(url.queryParameter("=[]:;\"~|?#@^/$%*")).isEqualTo("a");
-  }
-
-  @Test public void toUriQueryParameterValueSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .addQueryParameter("a", "=[]:;\"~|?#@^/$%*")
-        .build();
-    assertThat(url.toString())
-        .isEqualTo("http://host/?a=%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*");
-    assertThat(url.uri().toString())
-        .isEqualTo("http://host/?a=%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*");
-    assertThat(url.queryParameter("a")).isEqualTo("=[]:;\"~|?#@^/$%*");
-  }
-
-  @Test public void toUriQueryValueSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .query("=[]:;\"~|?#@^/$%*")
-        .build();
-    assertThat(url.toString()).isEqualTo("http://host/?=[]:;%22~|?%23@^/$%25*");
-    assertThat(url.uri().toString()).isEqualTo("http://host/?=[]:;%22~%7C?%23@%5E/$%25*");
-  }
-
-  @Test public void queryCharactersEncodedWhenComposed() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .addQueryParameter("a", "!$(),/:;?@[]\\^`{|}~")
-        .build();
-    assertThat(url.toString())
-        .isEqualTo("http://host/?a=%21%24%28%29%2C%2F%3A%3B%3F%40%5B%5D%5C%5E%60%7B%7C%7D%7E");
-    assertThat(url.queryParameter("a")).isEqualTo("!$(),/:;?@[]\\^`{|}~");
-  }
-
-  /**
-   * When callers use {@code addEncodedQueryParameter()} we only encode what's strictly required.
-   * We retain the encoded (or non-encoded) state of the input.
-   */
-  @Test public void queryCharactersNotReencodedWhenComposedWithAddEncoded() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .addEncodedQueryParameter("a", "!$(),/:;?@[]\\^`{|}~")
-        .build();
-    assertThat(url.toString()).isEqualTo("http://host/?a=!$(),/:;?@[]\\^`{|}~");
-    assertThat(url.queryParameter("a")).isEqualTo("!$(),/:;?@[]\\^`{|}~");
-  }
-
-  /**
-   * When callers parse a URL with query components that aren't encoded, we shouldn't convert them
-   * into a canonical form because doing so could be semantically different.
-   */
-  @Test public void queryCharactersNotReencodedWhenParsed() throws Exception {
-    HttpUrl url = parse("http://host/?a=!$(),/:;?@[]\\^`{|}~");
-    assertThat(url.toString()).isEqualTo("http://host/?a=!$(),/:;?@[]\\^`{|}~");
-    assertThat(url.queryParameter("a")).isEqualTo("!$(),/:;?@[]\\^`{|}~");
-  }
-
-  @Test public void toUriFragmentSpecialCharacters() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .host("host")
-        .fragment("=[]:;\"~|?#@^/$%*")
-        .build();
-    assertThat(url.toString()).isEqualTo("http://host/#=[]:;\"~|?#@^/$%25*");
-    assertThat(url.uri().toString()).isEqualTo("http://host/#=[]:;%22~%7C?%23@%5E/$%25*");
-  }
-
-  @Test public void toUriWithControlCharacters() throws Exception {
-    // Percent-encoded in the path.
-    assertThat(parse("http://host/a\u0000b").uri()).isEqualTo(new URI("http://host/a%00b"));
-    assertThat(parse("http://host/a\u0080b").uri())
-        .isEqualTo(new URI("http://host/a%C2%80b"));
-    assertThat(parse("http://host/a\u009fb").uri())
-        .isEqualTo(new URI("http://host/a%C2%9Fb"));
-    // Percent-encoded in the query.
-    assertThat(parse("http://host/?a\u0000b").uri())
-        .isEqualTo(new URI("http://host/?a%00b"));
-    assertThat(parse("http://host/?a\u0080b").uri())
-        .isEqualTo(new URI("http://host/?a%C2%80b"));
-    assertThat(parse("http://host/?a\u009fb").uri())
-        .isEqualTo(new URI("http://host/?a%C2%9Fb"));
-    // Stripped from the fragment.
-    assertThat(parse("http://host/#a\u0000b").uri())
-        .isEqualTo(new URI("http://host/#a%00b"));
-    assertThat(parse("http://host/#a\u0080b").uri()).isEqualTo(new URI("http://host/#ab"));
-    assertThat(parse("http://host/#a\u009fb").uri()).isEqualTo(new URI("http://host/#ab"));
-  }
-
-  @Test public void toUriWithSpaceCharacters() throws Exception {
-    // Percent-encoded in the path.
-    assertThat(parse("http://host/a\u000bb").uri()).isEqualTo(new URI("http://host/a%0Bb"));
-    assertThat(parse("http://host/a b").uri()).isEqualTo(new URI("http://host/a%20b"));
-    assertThat(parse("http://host/a\u2009b").uri())
-        .isEqualTo(new URI("http://host/a%E2%80%89b"));
-    assertThat(parse("http://host/a\u3000b").uri())
-        .isEqualTo(new URI("http://host/a%E3%80%80b"));
-    // Percent-encoded in the query.
-    assertThat(parse("http://host/?a\u000bb").uri())
-        .isEqualTo(new URI("http://host/?a%0Bb"));
-    assertThat(parse("http://host/?a b").uri()).isEqualTo(new URI("http://host/?a%20b"));
-    assertThat(parse("http://host/?a\u2009b").uri())
-        .isEqualTo(new URI("http://host/?a%E2%80%89b"));
-    assertThat(parse("http://host/?a\u3000b").uri())
-        .isEqualTo(new URI("http://host/?a%E3%80%80b"));
-    // Stripped from the fragment.
-    assertThat(parse("http://host/#a\u000bb").uri())
-        .isEqualTo(new URI("http://host/#a%0Bb"));
-    assertThat(parse("http://host/#a b").uri()).isEqualTo(new URI("http://host/#a%20b"));
-    assertThat(parse("http://host/#a\u2009b").uri()).isEqualTo(new URI("http://host/#ab"));
-    assertThat(parse("http://host/#a\u3000b").uri()).isEqualTo(new URI("http://host/#ab"));
-  }
-
-  @Test public void toUriWithNonHexPercentEscape() throws Exception {
-    assertThat(parse("http://host/%xx").uri()).isEqualTo(new URI("http://host/%25xx"));
-  }
-
-  @Test public void toUriWithTruncatedPercentEscape() throws Exception {
-    assertThat(parse("http://host/%a").uri()).isEqualTo(new URI("http://host/%25a"));
-    assertThat(parse("http://host/%").uri()).isEqualTo(new URI("http://host/%25"));
-  }
-
-  @Test public void fromJavaNetUrl() throws Exception {
-    URL javaNetUrl = new URL("http://username:password@host/path?query#fragment");
-    HttpUrl httpUrl = HttpUrl.get(javaNetUrl);
-    assertThat(httpUrl.toString())
-        .isEqualTo("http://username:password@host/path?query#fragment");
-  }
-
-  @Test public void fromJavaNetUrlUnsupportedScheme() throws Exception {
-    URL javaNetUrl = new URL("mailto:user@example.com");
-    assertThat(HttpUrl.get(javaNetUrl)).isNull();
-  }
-
-  @Test public void fromUri() throws Exception {
-    URI uri = new URI("http://username:password@host/path?query#fragment");
-    HttpUrl httpUrl = HttpUrl.get(uri);
-    assertThat(httpUrl.toString())
-        .isEqualTo("http://username:password@host/path?query#fragment");
-  }
-
-  @Test public void fromUriUnsupportedScheme() throws Exception {
-    URI uri = new URI("mailto:user@example.com");
-    assertThat(HttpUrl.get(uri)).isNull();
-  }
-
-  @Test public void fromUriPartial() throws Exception {
-    URI uri = new URI("/path");
-    assertThat(HttpUrl.get(uri)).isNull();
-  }
-
-  @Test public void composeQueryWithComponents() throws Exception {
-    HttpUrl base = parse("http://host/");
-    HttpUrl url = base.newBuilder().addQueryParameter("a+=& b", "c+=& d").build();
-    assertThat(url.toString()).isEqualTo("http://host/?a%2B%3D%26%20b=c%2B%3D%26%20d");
-    assertThat(url.queryParameterValue(0)).isEqualTo("c+=& d");
-    assertThat(url.queryParameterName(0)).isEqualTo("a+=& b");
-    assertThat(url.queryParameter("a+=& b")).isEqualTo("c+=& d");
-    assertThat(url.queryParameterNames()).isEqualTo(Collections.singleton("a+=& b"));
-    assertThat(url.queryParameterValues("a+=& b")).isEqualTo(singletonList("c+=& d"));
-    assertThat(url.querySize()).isEqualTo(1);
-    // Ambiguous! (Though working as designed.)
-    assertThat(url.query()).isEqualTo("a+=& b=c+=& d");
-    assertThat(url.encodedQuery()).isEqualTo("a%2B%3D%26%20b=c%2B%3D%26%20d");
-  }
-
-  @Test public void composeQueryWithEncodedComponents() throws Exception {
-    HttpUrl base = parse("http://host/");
-    HttpUrl url = base.newBuilder().addEncodedQueryParameter("a+=& b", "c+=& d").build();
-    assertThat(url.toString()).isEqualTo("http://host/?a+%3D%26%20b=c+%3D%26%20d");
-    assertThat(url.queryParameter("a =& b")).isEqualTo("c =& d");
-  }
-
-  @Test public void composeQueryRemoveQueryParameter() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
-        .addQueryParameter("a+=& b", "c+=& d")
-        .removeAllQueryParameters("a+=& b")
-        .build();
-    assertThat(url.toString()).isEqualTo("http://host/");
-    assertThat(url.queryParameter("a+=& b")).isNull();
-  }
-
-  @Test public void composeQueryRemoveEncodedQueryParameter() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
-        .addEncodedQueryParameter("a+=& b", "c+=& d")
-        .removeAllEncodedQueryParameters("a+=& b")
-        .build();
-    assertThat(url.toString()).isEqualTo("http://host/");
-    assertThat(url.queryParameter("a =& b")).isNull();
-  }
-
-  @Test public void composeQuerySetQueryParameter() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
-        .addQueryParameter("a+=& b", "c+=& d")
-        .setQueryParameter("a+=& b", "ef")
-        .build();
-    assertThat(url.toString()).isEqualTo("http://host/?a%2B%3D%26%20b=ef");
-    assertThat(url.queryParameter("a+=& b")).isEqualTo("ef");
-  }
-
-  @Test public void composeQuerySetEncodedQueryParameter() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
-        .addEncodedQueryParameter("a+=& b", "c+=& d")
-        .setEncodedQueryParameter("a+=& b", "ef")
-        .build();
-    assertThat(url.toString()).isEqualTo("http://host/?a+%3D%26%20b=ef");
-    assertThat(url.queryParameter("a =& b")).isEqualTo("ef");
-  }
-
-  @Test public void composeQueryMultipleEncodedValuesForParameter() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
-        .addQueryParameter("a+=& b", "c+=& d")
-        .addQueryParameter("a+=& b", "e+=& f")
-        .build();
-    assertThat(url.toString())
-        .isEqualTo("http://host/?a%2B%3D%26%20b=c%2B%3D%26%20d&a%2B%3D%26%20b=e%2B%3D%26%20f");
-    assertThat(url.querySize()).isEqualTo(2);
-    assertThat(url.queryParameterNames()).isEqualTo(Collections.singleton("a+=& b"));
-    assertThat(url.queryParameterValues("a+=& b")).containsExactly("c+=& d", "e+=& f");
-  }
-
-  @Test public void absentQueryIsZeroNameValuePairs() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
-        .query(null)
-        .build();
-    assertThat(url.querySize()).isEqualTo(0);
-  }
-
-  @Test public void emptyQueryIsSingleNameValuePairWithEmptyKey() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
-        .query("")
-        .build();
-    assertThat(url.querySize()).isEqualTo(1);
-    assertThat(url.queryParameterName(0)).isEqualTo("");
-    assertThat(url.queryParameterValue(0)).isNull();
-  }
-
-  @Test public void ampersandQueryIsTwoNameValuePairsWithEmptyKeys() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
-        .query("&")
-        .build();
-    assertThat(url.querySize()).isEqualTo(2);
-    assertThat(url.queryParameterName(0)).isEqualTo("");
-    assertThat(url.queryParameterValue(0)).isNull();
-    assertThat(url.queryParameterName(1)).isEqualTo("");
-    assertThat(url.queryParameterValue(1)).isNull();
-  }
-
-  @Test public void removeAllDoesNotRemoveQueryIfNoParametersWereRemoved() throws Exception {
-    HttpUrl url = parse("http://host/").newBuilder()
-        .query("")
-        .removeAllQueryParameters("a")
-        .build();
-    assertThat(url.toString()).isEqualTo("http://host/?");
-  }
-
-  @Test public void queryParametersWithoutValues() throws Exception {
-    HttpUrl url = parse("http://host/?foo&bar&baz");
-    assertThat(url.querySize()).isEqualTo(3);
-    assertThat(url.queryParameterNames()).containsExactly("foo", "bar", "baz");
-    assertThat(url.queryParameterValue(0)).isNull();
-    assertThat(url.queryParameterValue(1)).isNull();
-    assertThat(url.queryParameterValue(2)).isNull();
-    assertThat(url.queryParameterValues("foo")).isEqualTo(singletonList((String) null));
-    assertThat(url.queryParameterValues("bar")).isEqualTo(singletonList((String) null));
-    assertThat(url.queryParameterValues("baz")).isEqualTo(singletonList((String) null));
-  }
-
-  @Test public void queryParametersWithEmptyValues() throws Exception {
-    HttpUrl url = parse("http://host/?foo=&bar=&baz=");
-    assertThat(url.querySize()).isEqualTo(3);
-    assertThat(url.queryParameterNames()).containsExactly("foo", "bar", "baz");
-    assertThat(url.queryParameterValue(0)).isEqualTo("");
-    assertThat(url.queryParameterValue(1)).isEqualTo("");
-    assertThat(url.queryParameterValue(2)).isEqualTo("");
-    assertThat(url.queryParameterValues("foo")).isEqualTo(singletonList(""));
-    assertThat(url.queryParameterValues("bar")).isEqualTo(singletonList(""));
-    assertThat(url.queryParameterValues("baz")).isEqualTo(singletonList(""));
-  }
-
-  @Test public void queryParametersWithRepeatedName() throws Exception {
-    HttpUrl url = parse("http://host/?foo[]=1&foo[]=2&foo[]=3");
-    assertThat(url.querySize()).isEqualTo(3);
-    assertThat(url.queryParameterNames()).isEqualTo(Collections.singleton("foo[]"));
-    assertThat(url.queryParameterValue(0)).isEqualTo("1");
-    assertThat(url.queryParameterValue(1)).isEqualTo("2");
-    assertThat(url.queryParameterValue(2)).isEqualTo("3");
-    assertThat(url.queryParameterValues("foo[]")).containsExactly("1", "2", "3");
-  }
-
-  @Test public void queryParameterLookupWithNonCanonicalEncoding() throws Exception {
-    HttpUrl url = parse("http://host/?%6d=m&+=%20");
-    assertThat(url.queryParameterName(0)).isEqualTo("m");
-    assertThat(url.queryParameterName(1)).isEqualTo(" ");
-    assertThat(url.queryParameter("m")).isEqualTo("m");
-    assertThat(url.queryParameter(" ")).isEqualTo(" ");
-  }
-
-  @Test public void parsedQueryDoesntIncludeFragment() {
-    HttpUrl url = parse("http://host/?#fragment");
-    assertThat(url.fragment()).isEqualTo("fragment");
-    assertThat(url.query()).isEqualTo("");
-    assertThat(url.encodedQuery()).isEqualTo("");
-  }
-
-  @Test public void roundTripBuilder() throws Exception {
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme("http")
-        .username("%")
-        .password("%")
-        .host("host")
-        .addPathSegment("%")
-        .query("%")
-        .fragment("%")
-        .build();
-    assertThat(url.toString()).isEqualTo("http://%25:%25@host/%25?%25#%25");
-    assertThat(url.newBuilder().build().toString())
-        .isEqualTo("http://%25:%25@host/%25?%25#%25");
-    assertThat(url.resolve("").toString()).isEqualTo("http://%25:%25@host/%25?%25");
-  }
-
-  /**
-   * Although HttpUrl prefers percent-encodings in uppercase, it should preserve the exact structure
-   * of the original encoding.
-   */
-  @Test public void rawEncodingRetained() throws Exception {
-    String urlString = "http://%6d%6D:%6d%6D@host/%6d%6D?%6d%6D#%6d%6D";
-    HttpUrl url = parse(urlString);
-    assertThat(url.encodedUsername()).isEqualTo("%6d%6D");
-    assertThat(url.encodedPassword()).isEqualTo("%6d%6D");
-    assertThat(url.encodedPath()).isEqualTo("/%6d%6D");
-    assertThat(url.encodedPathSegments()).containsExactly("%6d%6D");
-    assertThat(url.encodedQuery()).isEqualTo("%6d%6D");
-    assertThat(url.encodedFragment()).isEqualTo("%6d%6D");
-    assertThat(url.toString()).isEqualTo(urlString);
-    assertThat(url.newBuilder().build().toString()).isEqualTo(urlString);
-    assertThat(url.resolve("").toString())
-        .isEqualTo("http://%6d%6D:%6d%6D@host/%6d%6D?%6d%6D");
-  }
-
-  @Test public void clearFragment() throws Exception {
-    HttpUrl url = parse("http://host/#fragment")
-        .newBuilder()
-        .fragment(null)
-        .build();
-    assertThat(url.toString()).isEqualTo("http://host/");
-    assertThat(url.fragment()).isNull();
-    assertThat(url.encodedFragment()).isNull();
-  }
-
-  @Test public void clearEncodedFragment() throws Exception {
-    HttpUrl url = parse("http://host/#fragment")
-        .newBuilder()
-        .encodedFragment(null)
-        .build();
-    assertThat(url.toString()).isEqualTo("http://host/");
-    assertThat(url.fragment()).isNull();
-    assertThat(url.encodedFragment()).isNull();
-  }
-
-  @Test public void topPrivateDomain() {
-    assertThat(parse("https://google.com").topPrivateDomain()).isEqualTo("google.com");
-    assertThat(parse("https://adwords.google.co.uk").topPrivateDomain())
-        .isEqualTo("google.co.uk");
-    assertThat(parse("https://..jp").topPrivateDomain())
-        .isEqualTo("xn--ewv.xn--4pvxs.jp");
-    assertThat(parse("https://xn--ewv.xn--4pvxs.jp").topPrivateDomain())
-        .isEqualTo("xn--ewv.xn--4pvxs.jp");
-
-    assertThat(parse("https://co.uk").topPrivateDomain()).isNull();
-    assertThat(parse("https://square").topPrivateDomain()).isNull();
-    assertThat(parse("https://.jp").topPrivateDomain()).isNull();
-    assertThat(parse("https://xn--4pvxs.jp").topPrivateDomain()).isNull();
-    assertThat(parse("https://localhost").topPrivateDomain()).isNull();
-    assertThat(parse("https://127.0.0.1").topPrivateDomain()).isNull();
-  }
-
-  private void assertInvalid(String string, String exceptionMessage) {
-    if (useGet) {
-      try {
-        parse(string);
-        fail("Expected get of \"" + string + "\" to throw with: " + exceptionMessage);
-      } catch (IllegalArgumentException e) {
-        assertThat(e.getMessage()).isEqualTo(exceptionMessage);
-      }
-    } else {
-      assertThat(parse(string)).overridingErrorMessage(string).isNull();
-    }
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/InterceptorTest.java b/okhttp/src/test/java/okhttp3/InterceptorTest.java
deleted file mode 100644
index b85efb6bd5..0000000000
--- a/okhttp/src/test/java/okhttp3/InterceptorTest.java
+++ /dev/null
@@ -1,912 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.net.SocketTimeoutException;
-import java.util.Locale;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.SynchronousQueue;
-import java.util.concurrent.ThreadPoolExecutor;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.mockwebserver.SocketPolicy;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.ForwardingSink;
-import okio.ForwardingSource;
-import okio.GzipSink;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class InterceptorTest {
-  @Rule public MockWebServer server = new MockWebServer();
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  private OkHttpClient client = clientTestRule.newClient();
-  private RecordingCallback callback = new RecordingCallback();
-
-  @Test public void applicationInterceptorsCanShortCircuitResponses() throws Exception {
-    server.shutdown(); // Accept no connections.
-
-    Request request = new Request.Builder()
-        .url("https://localhost:1/")
-        .build();
-
-    Response interceptorResponse = new Response.Builder()
-        .request(request)
-        .protocol(Protocol.HTTP_1_1)
-        .code(200)
-        .message("Intercepted!")
-        .body(ResponseBody.create("abc", MediaType.get("text/plain; charset=utf-8")))
-        .build();
-
-    client = client.newBuilder()
-        .addInterceptor(chain -> interceptorResponse)
-        .build();
-
-    Response response = client.newCall(request).execute();
-    assertThat(response).isSameAs(interceptorResponse);
-  }
-
-  @Test public void networkInterceptorsCannotShortCircuitResponses() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(500));
-
-    Interceptor interceptor = chain -> new Response.Builder()
-        .request(chain.request())
-        .protocol(Protocol.HTTP_1_1)
-        .code(200)
-        .message("Intercepted!")
-        .body(ResponseBody.create("abc", MediaType.get("text/plain; charset=utf-8")))
-        .build();
-    client = client.newBuilder()
-        .addNetworkInterceptor(interceptor)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          ("network interceptor " + interceptor + " must call proceed() exactly once"));
-    }
-  }
-
-  @Test public void networkInterceptorsCannotCallProceedMultipleTimes() throws Exception {
-    server.enqueue(new MockResponse());
-    server.enqueue(new MockResponse());
-
-    Interceptor interceptor = chain -> {
-      chain.proceed(chain.request());
-      return chain.proceed(chain.request());
-    };
-    client = client.newBuilder()
-        .addNetworkInterceptor(interceptor)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          ("network interceptor " + interceptor + " must call proceed() exactly once"));
-    }
-  }
-
-  @Test public void networkInterceptorsCannotChangeServerAddress() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(500));
-
-    Interceptor interceptor = chain -> {
-      Address address = chain.connection().route().address();
-      String sameHost = address.url().host();
-      int differentPort = address.url().port() + 1;
-      return chain.proceed(chain.request().newBuilder()
-          .url("http://" + sameHost + ":" + differentPort + "/")
-          .build());
-    };
-    client = client.newBuilder()
-        .addNetworkInterceptor(interceptor)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          ("network interceptor " + interceptor + " must retain the same host and port"));
-    }
-  }
-
-  @Test public void networkInterceptorsHaveConnectionAccess() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Interceptor interceptor = chain -> {
-      Connection connection = chain.connection();
-      assertThat(connection).isNotNull();
-      return chain.proceed(chain.request());
-    };
-    client = client.newBuilder()
-        .addNetworkInterceptor(interceptor)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    client.newCall(request).execute();
-  }
-
-  @Test public void networkInterceptorsObserveNetworkHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(gzip("abcabcabc"))
-        .addHeader("Content-Encoding: gzip"));
-
-    Interceptor interceptor = chain -> {
-      // The network request has everything: User-Agent, Host, Accept-Encoding.
-      Request networkRequest = chain.request();
-      assertThat(networkRequest.header("User-Agent")).isNotNull();
-      assertThat(networkRequest.header("Host")).isEqualTo(
-          (server.getHostName() + ":" + server.getPort()));
-      assertThat(networkRequest.header("Accept-Encoding")).isNotNull();
-
-      // The network response also has everything, including the raw gzipped content.
-      Response networkResponse = chain.proceed(networkRequest);
-      assertThat(networkResponse.header("Content-Encoding")).isEqualTo("gzip");
-      return networkResponse;
-    };
-    client = client.newBuilder()
-        .addNetworkInterceptor(interceptor)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    // No extra headers in the application's request.
-    assertThat(request.header("User-Agent")).isNull();
-    assertThat(request.header("Host")).isNull();
-    assertThat(request.header("Accept-Encoding")).isNull();
-
-    // No extra headers in the application's response.
-    Response response = client.newCall(request).execute();
-    assertThat(request.header("Content-Encoding")).isNull();
-    assertThat(response.body().string()).isEqualTo("abcabcabc");
-  }
-
-  @Test public void networkInterceptorsCanChangeRequestMethodFromGetToPost() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Interceptor interceptor = chain -> {
-      Request originalRequest = chain.request();
-      MediaType mediaType = MediaType.get("text/plain");
-      RequestBody body = RequestBody.create("abc", mediaType);
-      return chain.proceed(originalRequest.newBuilder()
-          .method("POST", body)
-          .header("Content-Type", mediaType.toString())
-          .header("Content-Length", Long.toString(body.contentLength()))
-          .build());
-    };
-    client = client.newBuilder()
-        .addNetworkInterceptor(interceptor)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .get()
-        .build();
-
-    client.newCall(request).execute();
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo("POST");
-    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("abc");
-  }
-
-  @Test public void applicationInterceptorsRewriteRequestToServer() throws Exception {
-    rewriteRequestToServer(false);
-  }
-
-  @Test public void networkInterceptorsRewriteRequestToServer() throws Exception {
-    rewriteRequestToServer(true);
-  }
-
-  private void rewriteRequestToServer(boolean network) throws Exception {
-    server.enqueue(new MockResponse());
-
-    addInterceptor(network, chain -> {
-      Request originalRequest = chain.request();
-      return chain.proceed(originalRequest.newBuilder()
-          .method("POST", uppercase(originalRequest.body()))
-          .addHeader("OkHttp-Intercepted", "yep")
-          .build());
-    });
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .addHeader("Original-Header", "foo")
-        .method("PUT", RequestBody.create("abc", MediaType.get("text/plain")))
-        .build();
-
-    client.newCall(request).execute();
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("ABC");
-    assertThat(recordedRequest.getHeader("Original-Header")).isEqualTo("foo");
-    assertThat(recordedRequest.getHeader("OkHttp-Intercepted")).isEqualTo("yep");
-    assertThat(recordedRequest.getMethod()).isEqualTo("POST");
-  }
-
-  @Test public void applicationInterceptorsRewriteResponseFromServer() throws Exception {
-    rewriteResponseFromServer(false);
-  }
-
-  @Test public void networkInterceptorsRewriteResponseFromServer() throws Exception {
-    rewriteResponseFromServer(true);
-  }
-
-  private void rewriteResponseFromServer(boolean network) throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Original-Header: foo")
-        .setBody("abc"));
-
-    addInterceptor(network, chain -> {
-      Response originalResponse = chain.proceed(chain.request());
-      return originalResponse.newBuilder()
-          .body(uppercase(originalResponse.body()))
-          .addHeader("OkHttp-Intercepted", "yep")
-          .build();
-    });
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("ABC");
-    assertThat(response.header("OkHttp-Intercepted")).isEqualTo("yep");
-    assertThat(response.header("Original-Header")).isEqualTo("foo");
-  }
-
-  @Test public void multipleApplicationInterceptors() throws Exception {
-    multipleInterceptors(false);
-  }
-
-  @Test public void multipleNetworkInterceptors() throws Exception {
-    multipleInterceptors(true);
-  }
-
-  private void multipleInterceptors(boolean network) throws Exception {
-    server.enqueue(new MockResponse());
-
-    addInterceptor(network, chain -> {
-      Request originalRequest = chain.request();
-      Response originalResponse = chain.proceed(originalRequest.newBuilder()
-          .addHeader("Request-Interceptor", "Android") // 1. Added first.
-          .build());
-      return originalResponse.newBuilder()
-          .addHeader("Response-Interceptor", "Donut") // 4. Added last.
-          .build();
-    });
-    addInterceptor(network, chain -> {
-      Request originalRequest = chain.request();
-      Response originalResponse = chain.proceed(originalRequest.newBuilder()
-          .addHeader("Request-Interceptor", "Bob") // 2. Added second.
-          .build());
-      return originalResponse.newBuilder()
-          .addHeader("Response-Interceptor", "Cupcake") // 3. Added third.
-          .build();
-    });
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Response response = client.newCall(request).execute();
-    assertThat(response.headers("Response-Interceptor")).containsExactly("Cupcake", "Donut");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getHeaders().values("Request-Interceptor"))
-        .containsExactly("Android", "Bob");
-  }
-
-  @Test public void asyncApplicationInterceptors() throws Exception {
-    asyncInterceptors(false);
-  }
-
-  @Test public void asyncNetworkInterceptors() throws Exception {
-    asyncInterceptors(true);
-  }
-
-  private void asyncInterceptors(boolean network) throws Exception {
-    server.enqueue(new MockResponse());
-
-    addInterceptor(network, chain -> {
-      Response originalResponse = chain.proceed(chain.request());
-      return originalResponse.newBuilder()
-          .addHeader("OkHttp-Intercepted", "yep")
-          .build();
-    });
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    client.newCall(request).enqueue(callback);
-
-    callback.await(request.url())
-        .assertCode(200)
-        .assertHeader("OkHttp-Intercepted", "yep");
-  }
-
-  @Test public void applicationInterceptorsCanMakeMultipleRequestsToServer() throws Exception {
-    server.enqueue(new MockResponse().setBody("a"));
-    server.enqueue(new MockResponse().setBody("b"));
-
-    client = client.newBuilder()
-        .addInterceptor(chain -> {
-          Response response1 = chain.proceed(chain.request());
-          response1.body().close();
-          return chain.proceed(chain.request());
-        })
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Response response = client.newCall(request).execute();
-    assertThat("b").isEqualTo(response.body().string());
-  }
-
-  /** Make sure interceptors can interact with the OkHttp client. */
-  @Test public void interceptorMakesAnUnrelatedRequest() throws Exception {
-    server.enqueue(new MockResponse().setBody("a")); // Fetched by interceptor.
-    server.enqueue(new MockResponse().setBody("b")); // Fetched directly.
-
-    client = client.newBuilder()
-        .addInterceptor(chain -> {
-          if (chain.request().url().encodedPath().equals("/b")) {
-            Request requestA = new Request.Builder()
-                .url(server.url("/a"))
-                .build();
-            Response responseA = client.newCall(requestA).execute();
-            assertThat(responseA.body().string()).isEqualTo("a");
-          }
-
-          return chain.proceed(chain.request());
-        })
-        .build();
-
-    Request requestB = new Request.Builder()
-        .url(server.url("/b"))
-        .build();
-    Response responseB = client.newCall(requestB).execute();
-    assertThat(responseB.body().string()).isEqualTo("b");
-  }
-
-  /** Make sure interceptors can interact with the OkHttp client asynchronously. */
-  @Test public void interceptorMakesAnUnrelatedAsyncRequest() throws Exception {
-    server.enqueue(new MockResponse().setBody("a")); // Fetched by interceptor.
-    server.enqueue(new MockResponse().setBody("b")); // Fetched directly.
-
-    client = client.newBuilder()
-        .addInterceptor(chain -> {
-          if (chain.request().url().encodedPath().equals("/b")) {
-            Request requestA = new Request.Builder()
-                .url(server.url("/a"))
-                .build();
-
-            try {
-              RecordingCallback callbackA = new RecordingCallback();
-              client.newCall(requestA).enqueue(callbackA);
-              callbackA.await(requestA.url()).assertBody("a");
-            } catch (Exception e) {
-              throw new RuntimeException(e);
-            }
-          }
-
-          return chain.proceed(chain.request());
-        })
-        .build();
-
-    Request requestB = new Request.Builder()
-        .url(server.url("/b"))
-        .build();
-    RecordingCallback callbackB = new RecordingCallback();
-    client.newCall(requestB).enqueue(callbackB);
-    callbackB.await(requestB.url()).assertBody("b");
-  }
-
-  @Test public void applicationInterceptorThrowsRuntimeExceptionSynchronous() throws Exception {
-    interceptorThrowsRuntimeExceptionSynchronous(false);
-  }
-
-  @Test public void networkInterceptorThrowsRuntimeExceptionSynchronous() throws Exception {
-    interceptorThrowsRuntimeExceptionSynchronous(true);
-  }
-
-  /**
-   * When an interceptor throws an unexpected exception, synchronous callers can catch it and deal
-   * with it.
-   */
-  private void interceptorThrowsRuntimeExceptionSynchronous(boolean network) throws Exception {
-    addInterceptor(network, chain -> { throw new RuntimeException("boom!"); });
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (RuntimeException expected) {
-      assertThat(expected.getMessage()).isEqualTo("boom!");
-    }
-  }
-
-  @Test public void networkInterceptorModifiedRequestIsReturned() throws IOException {
-    server.enqueue(new MockResponse());
-
-    Interceptor modifyHeaderInterceptor = chain -> {
-      Request modifiedRequest = chain.request()
-          .newBuilder()
-          .header("User-Agent", "intercepted request")
-          .build();
-      return chain.proceed(modifiedRequest);
-    };
-
-    client = client.newBuilder()
-        .addNetworkInterceptor(modifyHeaderInterceptor)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .header("User-Agent", "user request")
-        .build();
-
-    Response response = client.newCall(request).execute();
-    assertThat(response.request().header("User-Agent")).isNotNull();
-    assertThat(response.request().header("User-Agent")).isEqualTo("user request");
-    assertThat(response.networkResponse().request().header("User-Agent")).isEqualTo(
-        "intercepted request");
-  }
-
-  @Test public void applicationInterceptorThrowsRuntimeExceptionAsynchronous() throws Exception {
-    interceptorThrowsRuntimeExceptionAsynchronous(false);
-  }
-
-  @Test public void networkInterceptorThrowsRuntimeExceptionAsynchronous() throws Exception {
-    interceptorThrowsRuntimeExceptionAsynchronous(true);
-  }
-
-  /**
-   * When an interceptor throws an unexpected exception, asynchronous calls are canceled. The
-   * exception goes to the uncaught exception handler.
-   */
-  private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) throws Exception {
-    RuntimeException boom = new RuntimeException("boom!");
-    addInterceptor(network, chain -> { throw boom; });
-
-    ExceptionCatchingExecutor executor = new ExceptionCatchingExecutor();
-    client = client.newBuilder()
-        .dispatcher(new Dispatcher(executor))
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Call call = client.newCall(request);
-    call.enqueue(callback);
-    RecordedResponse recordedResponse = callback.await(server.url("/"));
-    assertThat(recordedResponse.failure)
-        .hasMessage("canceled due to java.lang.RuntimeException: boom!");
-    assertThat(recordedResponse.failure).hasSuppressedException(boom);
-    assertThat(call.isCanceled()).isTrue();
-
-    assertThat(executor.takeException()).isEqualTo(boom);
-  }
-
-  @Test public void applicationInterceptorReturnsNull() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Interceptor interceptor = chain -> {
-      chain.proceed(chain.request());
-      return null;
-    };
-    client = client.newBuilder()
-        .addInterceptor(interceptor)
-        .build();
-
-    ExceptionCatchingExecutor executor = new ExceptionCatchingExecutor();
-    client = client.newBuilder()
-        .dispatcher(new Dispatcher(executor))
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (NullPointerException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          ("interceptor " + interceptor + " returned null"));
-    }
-  }
-
-  @Test public void networkInterceptorReturnsNull() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Interceptor interceptor = chain -> {
-      chain.proceed(chain.request());
-      return null;
-    };
-    client = client.newBuilder()
-        .addNetworkInterceptor(interceptor)
-        .build();
-
-    ExceptionCatchingExecutor executor = new ExceptionCatchingExecutor();
-    client = client.newBuilder()
-        .dispatcher(new Dispatcher(executor))
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (NullPointerException expected) {
-      expected.printStackTrace();
-      assertThat(expected.getMessage()).isEqualTo(
-          ("interceptor " + interceptor + " returned null"));
-    }
-  }
-
-  @Test public void networkInterceptorReturnsConnectionOnEmptyBody() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .addHeader("Connection", "Close"));
-
-    Interceptor interceptor = chain -> {
-      Response response = chain.proceed(chain.request());
-      assertThat(chain.connection()).isNotNull();
-      return response;
-    };
-
-    client = client.newBuilder()
-        .addNetworkInterceptor(interceptor)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Response response = client.newCall(request).execute();
-    response.body().close();
-  }
-
-  @Test public void applicationInterceptorResponseMustHaveBody() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Interceptor interceptor = chain -> {
-      Response response = chain.proceed(chain.request());
-      return response.newBuilder()
-          .body(null)
-          .build();
-    };
-    client = client.newBuilder()
-        .addInterceptor(interceptor)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          ("interceptor " + interceptor + " returned a response with no body"));
-    }
-  }
-
-  @Test public void networkInterceptorResponseMustHaveBody() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Interceptor interceptor = chain -> {
-      Response response = chain.proceed(chain.request());
-      return response.newBuilder()
-          .body(null)
-          .build();
-    };
-    client = client.newBuilder()
-        .addNetworkInterceptor(interceptor)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    try {
-      client.newCall(request).execute();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          ("interceptor " + interceptor + " returned a response with no body"));
-    }
-  }
-
-  @Test public void connectTimeout() throws Exception {
-    Interceptor interceptor1 = chainA -> {
-      assertThat(chainA.connectTimeoutMillis()).isEqualTo(5000);
-
-      Interceptor.Chain chainB = chainA.withConnectTimeout(100, TimeUnit.MILLISECONDS);
-      assertThat(chainB.connectTimeoutMillis()).isEqualTo(100);
-
-      return chainB.proceed(chainA.request());
-    };
-
-    Interceptor interceptor2 = chain -> {
-      assertThat(chain.connectTimeoutMillis()).isEqualTo(100);
-      return chain.proceed(chain.request());
-    };
-
-    InetAddress localhost = InetAddress.getLoopbackAddress();
-    ServerSocket serverSocket = new ServerSocket(0, 1, localhost);
-    // Fill backlog queue with this request so subsequent requests will be blocked.
-    new Socket().connect(serverSocket.getLocalSocketAddress());
-
-    client = client.newBuilder()
-        .connectTimeout(5, TimeUnit.SECONDS)
-        .addInterceptor(interceptor1)
-        .addInterceptor(interceptor2)
-        .build();
-
-    Request request1 =
-        new Request.Builder()
-            .url(
-                "http://"
-                    + serverSocket.getInetAddress().getCanonicalHostName()
-                    + ":"
-                    + serverSocket.getLocalPort())
-            .build();
-    Call call = client.newCall(request1);
-
-    try {
-      call.execute();
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-
-    serverSocket.close();
-  }
-
-  @Test public void chainWithReadTimeout() throws Exception {
-    Interceptor interceptor1 = chainA -> {
-      assertThat(chainA.readTimeoutMillis()).isEqualTo(5000);
-
-      Interceptor.Chain chainB = chainA.withReadTimeout(100, TimeUnit.MILLISECONDS);
-      assertThat(chainB.readTimeoutMillis()).isEqualTo(100);
-
-      return chainB.proceed(chainA.request());
-    };
-
-    Interceptor interceptor2 = chain -> {
-      assertThat(chain.readTimeoutMillis()).isEqualTo(100);
-      return chain.proceed(chain.request());
-    };
-
-    client = client.newBuilder()
-        .readTimeout(5, TimeUnit.SECONDS)
-        .addInterceptor(interceptor1)
-        .addInterceptor(interceptor2)
-        .build();
-
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .throttleBody(1, 1, TimeUnit.SECONDS));
-
-    Request request1 = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Call call = client.newCall(request1);
-    Response response = call.execute();
-    ResponseBody body = response.body();
-    try {
-      body.string();
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-  }
-
-  @Test public void chainWithWriteTimeout() throws Exception {
-    Interceptor interceptor1 = chainA -> {
-      assertThat(chainA.writeTimeoutMillis()).isEqualTo(5000);
-
-      Interceptor.Chain chainB = chainA.withWriteTimeout(100, TimeUnit.MILLISECONDS);
-      assertThat(chainB.writeTimeoutMillis()).isEqualTo(100);
-
-      return chainB.proceed(chainA.request());
-    };
-
-    Interceptor interceptor2 = chain -> {
-      assertThat(chain.writeTimeoutMillis()).isEqualTo(100);
-      return chain.proceed(chain.request());
-    };
-
-    client = client.newBuilder()
-        .writeTimeout(5, TimeUnit.SECONDS)
-        .addInterceptor(interceptor1)
-        .addInterceptor(interceptor2)
-        .build();
-
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .throttleBody(1, 1, TimeUnit.SECONDS));
-
-    byte[] data = new byte[2 * 1024 * 1024]; // 2 MiB.
-    Request request1 = new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create(data, MediaType.get("text/plain")))
-        .build();
-    Call call = client.newCall(request1);
-
-    try {
-      call.execute(); // we want this call to throw a SocketTimeoutException
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-  }
-
-  @Test public void chainCanCancelCall() throws Exception {
-    AtomicReference<Call> callRef = new AtomicReference<>();
-
-    Interceptor interceptor = chain -> {
-      Call call = chain.call();
-      callRef.set(call);
-
-      assertThat(call.isCanceled()).isFalse();
-      call.cancel();
-      assertThat(call.isCanceled()).isTrue();
-
-      return chain.proceed(chain.request());
-    };
-
-    client = client.newBuilder()
-        .addInterceptor(interceptor)
-        .build();
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Call call = client.newCall(request);
-
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    assertThat(callRef.get()).isSameAs(call);
-  }
-
-  private RequestBody uppercase(RequestBody original) {
-    return new RequestBody() {
-      @Override public MediaType contentType() {
-        return original.contentType();
-      }
-
-      @Override public long contentLength() throws IOException {
-        return original.contentLength();
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        Sink uppercase = uppercase(sink);
-        BufferedSink bufferedSink = Okio.buffer(uppercase);
-        original.writeTo(bufferedSink);
-        bufferedSink.emit();
-      }
-    };
-  }
-
-  private Sink uppercase(BufferedSink original) {
-    return new ForwardingSink(original) {
-      @Override public void write(Buffer source, long byteCount) throws IOException {
-        original.writeUtf8(source.readUtf8(byteCount).toUpperCase(Locale.US));
-      }
-    };
-  }
-
-  static ResponseBody uppercase(ResponseBody original) throws IOException {
-    return ResponseBody.create(Okio.buffer(uppercase(original.source())),
-        original.contentType(), original.contentLength());
-  }
-
-  private static Source uppercase(Source original) {
-    return new ForwardingSource(original) {
-      @Override public long read(Buffer sink, long byteCount) throws IOException {
-        Buffer mixedCase = new Buffer();
-        long count = original.read(mixedCase, byteCount);
-        sink.writeUtf8(mixedCase.readUtf8().toUpperCase(Locale.US));
-        return count;
-      }
-    };
-  }
-
-  private Buffer gzip(String data) throws IOException {
-    Buffer result = new Buffer();
-    BufferedSink sink = Okio.buffer(new GzipSink(result));
-    sink.writeUtf8(data);
-    sink.close();
-    return result;
-  }
-
-  private void addInterceptor(boolean network, Interceptor interceptor) {
-    OkHttpClient.Builder builder = client.newBuilder();
-    if (network) {
-      builder.addNetworkInterceptor(interceptor);
-    } else {
-      builder.addInterceptor(interceptor);
-    }
-    client = builder.build();
-  }
-
-  /** Catches exceptions that are otherwise headed for the uncaught exception handler. */
-  private static class ExceptionCatchingExecutor extends ThreadPoolExecutor {
-    private final BlockingQueue<Exception> exceptions = new LinkedBlockingQueue<>();
-
-    public ExceptionCatchingExecutor() {
-      super(1, 1, 0, TimeUnit.SECONDS, new SynchronousQueue<>());
-    }
-
-    @Override public void execute(Runnable runnable) {
-      super.execute(() -> {
-        try {
-          runnable.run();
-        } catch (Exception e) {
-          exceptions.add(e);
-        }
-      });
-    }
-
-    public Exception takeException() throws Exception {
-      return exceptions.take();
-    }
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/KotlinSourceModernTest.kt b/okhttp/src/test/java/okhttp3/KotlinSourceModernTest.kt
deleted file mode 100644
index 2d76da8ed8..0000000000
--- a/okhttp/src/test/java/okhttp3/KotlinSourceModernTest.kt
+++ /dev/null
@@ -1,1202 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3
-
-import okhttp3.Handshake.Companion.handshake
-import okhttp3.Headers.Companion.headersOf
-import okhttp3.Headers.Companion.toHeaders
-import okhttp3.HttpUrl.Companion.toHttpUrl
-import okhttp3.HttpUrl.Companion.toHttpUrlOrNull
-import okhttp3.MediaType.Companion.toMediaType
-import okhttp3.MediaType.Companion.toMediaTypeOrNull
-import okhttp3.RequestBody.Companion.toRequestBody
-import okhttp3.RequestBody.Companion.asRequestBody
-import okhttp3.ResponseBody.Companion.toResponseBody
-import okhttp3.ResponseBody.Companion.asResponseBody
-import okhttp3.internal.http2.Settings
-import okhttp3.internal.proxy.NullProxySelector
-import okhttp3.internal.tls.OkHostnameVerifier
-import okhttp3.logging.HttpLoggingInterceptor
-import okhttp3.logging.LoggingEventListener
-import okhttp3.mockwebserver.MockResponse
-import okhttp3.mockwebserver.MockWebServer
-import okhttp3.mockwebserver.PushPromise
-import okhttp3.mockwebserver.QueueDispatcher
-import okhttp3.mockwebserver.RecordedRequest
-import okhttp3.mockwebserver.SocketPolicy
-import okhttp3.tls.HandshakeCertificates
-import okhttp3.tls.HeldCertificate
-import okhttp3.tls.internal.TlsUtil.localhost
-import okio.Buffer
-import okio.BufferedSink
-import okio.BufferedSource
-import okio.ByteString
-import okio.Timeout
-import org.junit.Ignore
-import org.junit.Test
-import java.io.File
-import java.io.IOException
-import java.math.BigInteger
-import java.net.CookieHandler
-import java.net.InetAddress
-import java.net.InetSocketAddress
-import java.net.Proxy
-import java.net.ProxySelector
-import java.net.Socket
-import java.net.URI
-import java.net.URL
-import java.nio.charset.Charset
-import java.security.KeyPair
-import java.security.KeyPairGenerator
-import java.security.Principal
-import java.security.cert.Certificate
-import java.security.cert.X509Certificate
-import java.time.Duration
-import java.time.Instant
-import java.util.Date
-import java.util.concurrent.ExecutorService
-import java.util.concurrent.Executors
-import java.util.concurrent.TimeUnit
-import javax.net.ServerSocketFactory
-import javax.net.SocketFactory
-import javax.net.ssl.HostnameVerifier
-import javax.net.ssl.SSLContext
-import javax.net.ssl.SSLSocket
-import javax.net.ssl.SSLSocketFactory
-import javax.net.ssl.X509KeyManager
-import javax.net.ssl.X509TrustManager
-
-/**
- * Access every type, function, and property from Kotlin to defend against unexpected regressions in
- * modern 4.0.x kotlin source-compatibility.
- */
-@Suppress(
-    "ASSIGNED_BUT_NEVER_ACCESSED_VARIABLE",
-    "UNUSED_ANONYMOUS_PARAMETER",
-    "UNUSED_VALUE",
-    "UNUSED_VARIABLE",
-    "VARIABLE_WITH_REDUNDANT_INITIALIZER",
-    "RedundantLambdaArrow",
-    "RedundantExplicitType",
-    "IMPLICIT_NOTHING_AS_TYPE_PARAMETER"
-)
-class KotlinSourceModernTest {
-  @Test @Ignore
-  fun address() {
-    val address: Address = newAddress()
-    val url: HttpUrl = address.url
-    val dns: Dns = address.dns
-    val socketFactory: SocketFactory = address.socketFactory
-    val proxyAuthenticator: Authenticator = address.proxyAuthenticator
-    val protocols: List<Protocol> = address.protocols
-    val connectionSpecs: List<ConnectionSpec> = address.connectionSpecs
-    val proxySelector: ProxySelector = address.proxySelector
-    val sslSocketFactory: SSLSocketFactory? = address.sslSocketFactory
-    val hostnameVerifier: HostnameVerifier? = address.hostnameVerifier
-    val certificatePinner: CertificatePinner? = address.certificatePinner
-  }
-
-  @Test @Ignore
-  fun authenticator() {
-    var authenticator: Authenticator = object : Authenticator {
-      override fun authenticate(route: Route?, response: Response): Request? = TODO()
-    }
-  }
-
-  @Test @Ignore
-  fun cache() {
-    val cache = Cache(File("/cache/"), Integer.MAX_VALUE.toLong())
-    cache.initialize()
-    cache.delete()
-    cache.evictAll()
-    val urls: MutableIterator<String> = cache.urls()
-    val writeAbortCount: Int = cache.writeAbortCount()
-    val writeSuccessCount: Int = cache.writeSuccessCount()
-    val size: Long = cache.size()
-    val maxSize: Long = cache.maxSize()
-    cache.flush()
-    cache.close()
-    val directory: File = cache.directory
-    val networkCount: Int = cache.networkCount()
-    val hitCount: Int = cache.hitCount()
-    val requestCount: Int = cache.requestCount()
-  }
-
-  @Test @Ignore
-  fun cacheControl() {
-    val cacheControl: CacheControl = CacheControl.Builder().build()
-    val noCache: Boolean = cacheControl.noCache
-    val noStore: Boolean = cacheControl.noStore
-    val maxAgeSeconds: Int = cacheControl.maxAgeSeconds
-    val sMaxAgeSeconds: Int = cacheControl.sMaxAgeSeconds
-    val mustRevalidate: Boolean = cacheControl.mustRevalidate
-    val maxStaleSeconds: Int = cacheControl.maxStaleSeconds
-    val minFreshSeconds: Int = cacheControl.minFreshSeconds
-    val onlyIfCached: Boolean = cacheControl.onlyIfCached
-    val noTransform: Boolean = cacheControl.noTransform
-    val immutable: Boolean = cacheControl.immutable
-    val forceCache: CacheControl = CacheControl.FORCE_CACHE
-    val forceNetwork: CacheControl = CacheControl.FORCE_NETWORK
-    val parse: CacheControl = CacheControl.parse(headersOf())
-  }
-
-  @Test @Ignore
-  fun cacheControlBuilder() {
-    var builder: CacheControl.Builder = CacheControl.Builder()
-    builder = builder.noCache()
-    builder = builder.noStore()
-    builder = builder.maxAge(0, TimeUnit.MILLISECONDS)
-    builder = builder.maxStale(0, TimeUnit.MILLISECONDS)
-    builder = builder.minFresh(0, TimeUnit.MILLISECONDS)
-    builder = builder.onlyIfCached()
-    builder = builder.noTransform()
-    builder = builder.immutable()
-    val cacheControl: CacheControl = builder.build()
-  }
-
-  @Test @Ignore
-  fun call() {
-    val call: Call = newCall()
-  }
-
-  @Test @Ignore
-  fun callback() {
-    val callback = object : Callback {
-      override fun onFailure(call: Call, e: IOException) = TODO()
-      override fun onResponse(call: Call, response: Response) = TODO()
-    }
-  }
-
-  @Test @Ignore
-  fun certificatePinner() {
-    val heldCertificate: HeldCertificate = HeldCertificate.Builder().build()
-    val certificate: X509Certificate = heldCertificate.certificate
-    val certificatePinner: CertificatePinner = CertificatePinner.Builder().build()
-    val certificates: List<Certificate> = listOf()
-    certificatePinner.check("", listOf(certificate))
-    certificatePinner.check("", arrayOf<Certificate>(certificate, certificate).toList())
-    val pin: String = CertificatePinner.pin(certificate)
-    val default: CertificatePinner = CertificatePinner.DEFAULT
-  }
-
-  @Test @Ignore
-  fun certificatePinnerBuilder() {
-    val builder: CertificatePinner.Builder = CertificatePinner.Builder()
-    builder.add("", "pin1", "pin2")
-  }
-
-  @Test @Ignore
-  fun challenge() {
-    var challenge = Challenge("", mapOf<String?, String>("" to ""))
-    challenge = Challenge("", "")
-    val scheme: String = challenge.scheme
-    val authParams: Map<String?, String> = challenge.authParams
-    val realm: String? = challenge.realm
-    val charset: Charset = challenge.charset
-    val utf8: Challenge = challenge.withCharset(Charsets.UTF_8)
-  }
-
-  @Test @Ignore
-  fun cipherSuite() {
-    var cipherSuite: CipherSuite = CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
-    cipherSuite = CipherSuite.forJavaName("")
-    val javaName: String = cipherSuite.javaName
-  }
-
-  @Test @Ignore
-  fun connection() {
-    val connection = object : Connection {
-      override fun route(): Route = TODO()
-      override fun socket(): Socket = TODO()
-      override fun handshake(): Handshake? = TODO()
-      override fun protocol(): Protocol = TODO()
-    }
-  }
-
-  @Test @Ignore
-  fun connectionPool() {
-    var connectionPool = ConnectionPool()
-    connectionPool = ConnectionPool(0, 0L, TimeUnit.SECONDS)
-    val idleConnectionCount: Int = connectionPool.idleConnectionCount()
-    val connectionCount: Int = connectionPool.connectionCount()
-    connectionPool.evictAll()
-  }
-
-  @Test @Ignore
-  fun connectionSpec() {
-    var connectionSpec: ConnectionSpec = ConnectionSpec.RESTRICTED_TLS
-    connectionSpec = ConnectionSpec.MODERN_TLS
-    connectionSpec = ConnectionSpec.COMPATIBLE_TLS
-    connectionSpec = ConnectionSpec.CLEARTEXT
-    val tlsVersions: List<TlsVersion>? = connectionSpec.tlsVersions
-    val cipherSuites: List<CipherSuite>? = connectionSpec.cipherSuites
-    val supportsTlsExtensions: Boolean = connectionSpec.supportsTlsExtensions
-    val compatible: Boolean = connectionSpec.isCompatible(
-        localhost().sslSocketFactory().createSocket() as SSLSocket)
-  }
-
-  @Test @Ignore
-  fun connectionSpecBuilder() {
-    var builder = ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-    builder = builder.allEnabledCipherSuites()
-    builder = builder.cipherSuites(CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256)
-    builder = builder.cipherSuites("", "")
-    builder = builder.allEnabledTlsVersions()
-    builder = builder.tlsVersions(TlsVersion.TLS_1_3)
-    builder = builder.tlsVersions("", "")
-    val connectionSpec: ConnectionSpec = builder.build()
-  }
-
-  @Test @Ignore
-  fun cookie() {
-    val cookie: Cookie = Cookie.Builder().build()
-    val name: String = cookie.name
-    val value: String = cookie.value
-    val persistent: Boolean = cookie.persistent
-    val expiresAt: Long = cookie.expiresAt
-    val hostOnly: Boolean = cookie.hostOnly
-    val domain: String = cookie.domain
-    val path: String = cookie.path
-    val httpOnly: Boolean = cookie.httpOnly
-    val secure: Boolean = cookie.secure
-    val matches: Boolean = cookie.matches("".toHttpUrl())
-    val parsedCookie: Cookie? = Cookie.parse("".toHttpUrl(), "")
-    val cookies: List<Cookie> = Cookie.parseAll("".toHttpUrl(), headersOf())
-  }
-
-  @Test @Ignore
-  fun cookieBuilder() {
-    var builder: Cookie.Builder = Cookie.Builder()
-    builder = builder.name("")
-    builder = builder.value("")
-    builder = builder.expiresAt(0L)
-    builder = builder.domain("")
-    builder = builder.hostOnlyDomain("")
-    builder = builder.path("")
-    builder = builder.secure()
-    builder = builder.httpOnly()
-    val cookie: Cookie = builder.build()
-  }
-
-  @Test @Ignore
-  fun cookieJar() {
-    val cookieJar = object : CookieJar {
-      override fun saveFromResponse(url: HttpUrl, cookies: List<Cookie>) = TODO()
-      override fun loadForRequest(url: HttpUrl): List<Cookie> = TODO()
-    }
-  }
-
-  @Test @Ignore
-  fun credentials() {
-    val basic: String = Credentials.basic("", "")
-  }
-
-  @Test @Ignore
-  fun dispatcher() {
-    var dispatcher = Dispatcher()
-    dispatcher = Dispatcher(Executors.newCachedThreadPool())
-    val maxRequests: Int = dispatcher.maxRequests
-    dispatcher.maxRequests = 0
-    val maxRequestsPerHost: Int = dispatcher.maxRequestsPerHost
-    dispatcher.maxRequestsPerHost = 0
-    val executorService: ExecutorService = dispatcher.executorService
-    dispatcher.idleCallback = Runnable { ({ TODO() })() }
-    val queuedCalls: List<Call> = dispatcher.queuedCalls()
-    val runningCalls: List<Call> = dispatcher.runningCalls()
-    val queuedCallsCount: Int = dispatcher.queuedCallsCount()
-    val runningCallsCount: Int = dispatcher.runningCallsCount()
-    dispatcher.cancelAll()
-  }
-
-  @Test @Ignore
-  fun dispatcherFromMockWebServer() {
-    val dispatcher = object : okhttp3.mockwebserver.Dispatcher() {
-      override fun dispatch(request: RecordedRequest): MockResponse = TODO()
-      override fun peek(): MockResponse = TODO()
-      override fun shutdown() = TODO()
-    }
-  }
-
-  @Test @Ignore
-  fun dns() {
-    var dns: Dns = object : Dns {
-      override fun lookup(hostname: String): List<InetAddress> = TODO()
-    }
-
-    val system: Dns = Dns.SYSTEM
-  }
-
-  @Test @Ignore
-  fun eventListener() {
-    val eventListener = object : EventListener() {
-      override fun callStart(call: Call) = TODO()
-      override fun dnsStart(call: Call, domainName: String) = TODO()
-      override fun dnsEnd(
-        call: Call,
-        domainName: String,
-        inetAddressList: List<InetAddress>
-      ) = TODO()
-
-      override fun connectStart(
-        call: Call,
-        inetSocketAddress: InetSocketAddress,
-        proxy: Proxy
-      ) = TODO()
-
-      override fun secureConnectStart(call: Call) = TODO()
-      override fun secureConnectEnd(call: Call, handshake: Handshake?) = TODO()
-      override fun connectEnd(
-        call: Call,
-        inetSocketAddress: InetSocketAddress,
-        proxy: Proxy,
-        protocol: Protocol?
-      ) = TODO()
-
-      override fun connectFailed(
-        call: Call,
-        inetSocketAddress: InetSocketAddress,
-        proxy: Proxy,
-        protocol: Protocol?,
-        ioe: IOException
-      ) = TODO()
-
-      override fun connectionAcquired(call: Call, connection: Connection) = TODO()
-      override fun connectionReleased(call: Call, connection: Connection) = TODO()
-      override fun requestHeadersStart(call: Call) = TODO()
-      override fun requestHeadersEnd(call: Call, request: Request) = TODO()
-      override fun requestBodyStart(call: Call) = TODO()
-      override fun requestBodyEnd(call: Call, byteCount: Long) = TODO()
-      override fun requestFailed(call: Call, ioe: IOException) = TODO()
-      override fun responseHeadersStart(call: Call) = TODO()
-      override fun responseHeadersEnd(call: Call, response: Response) = TODO()
-      override fun responseBodyStart(call: Call) = TODO()
-      override fun responseBodyEnd(call: Call, byteCount: Long) = TODO()
-      override fun responseFailed(call: Call, ioe: IOException) = TODO()
-      override fun callEnd(call: Call) = TODO()
-      override fun callFailed(call: Call, ioe: IOException) = TODO()
-    }
-    val none: EventListener = EventListener.NONE
-  }
-
-  @Test @Ignore
-  fun eventListenerBuilder() {
-    var builder: EventListener.Factory = object : EventListener.Factory {
-      override fun create(call: Call): EventListener = TODO()
-    }
-  }
-
-  @Test @Ignore
-  fun formBody() {
-    val formBody: FormBody = FormBody.Builder().build()
-    val size: Int = formBody.size
-    val encodedName: String = formBody.encodedName(0)
-    val name: String = formBody.name(0)
-    val encodedValue: String = formBody.encodedValue(0)
-    val value: String = formBody.value(0)
-    val contentType: MediaType? = formBody.contentType()
-    val contentLength: Long = formBody.contentLength()
-    formBody.writeTo(Buffer())
-    val requestBody: RequestBody = formBody
-  }
-
-  @Test @Ignore
-  fun formBodyBuilder() {
-    var builder: FormBody.Builder = FormBody.Builder()
-    builder = FormBody.Builder(Charsets.UTF_8)
-    builder = builder.add("", "")
-    builder = builder.addEncoded("", "")
-    val formBody: FormBody = builder.build()
-  }
-
-  @Test @Ignore
-  fun handshake() {
-    var handshake: Handshake =
-        (localhost().sslSocketFactory().createSocket() as SSLSocket).session.handshake()
-    val listOfCertificates: List<Certificate> = listOf()
-    handshake = Handshake.get(
-        TlsVersion.TLS_1_3,
-        CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
-        listOfCertificates,
-        listOfCertificates
-    )
-    val tlsVersion: TlsVersion = handshake.tlsVersion
-    val cipherSuite: CipherSuite = handshake.cipherSuite
-    val peerCertificates: List<Certificate> = handshake.peerCertificates
-    val peerPrincipal: Principal? = handshake.peerPrincipal
-    val localCertificates: List<Certificate> = handshake.localCertificates
-    val localPrincipal: Principal? = handshake.localPrincipal
-  }
-
-  @Test @Ignore
-  fun headers() {
-    var headers: Headers = headersOf("", "")
-    headers = mapOf("" to "").toHeaders()
-    val get: String? = headers.get("")
-    val date: Date? = headers.getDate("")
-    val instant: Instant? = headers.getInstant("")
-    val size: Int = headers.size
-    val name: String = headers.name(0)
-    val value: String = headers.value(0)
-    val names: Set<String> = headers.names()
-    val values: List<String> = headers.values("")
-    val byteCount: Long = headers.byteCount()
-    val builder: Headers.Builder = headers.newBuilder()
-    val multimap: Map<String, List<String>> = headers.toMultimap()
-  }
-
-  @Test @Ignore
-  fun headersBuilder() {
-    var builder: Headers.Builder = Headers.Builder()
-    builder = builder.add("")
-    builder = builder.add("", "")
-    builder = builder.addUnsafeNonAscii("", "")
-    builder = builder.addAll(headersOf())
-    builder = builder.add("", Date(0L))
-    builder = builder.add("", Instant.EPOCH)
-    builder = builder.set("", "")
-    builder = builder.set("", Date(0L))
-    builder = builder.set("", Instant.EPOCH)
-    builder = builder.removeAll("")
-    val get: String? = builder.get("")
-    val headers: Headers = builder.build()
-  }
-
-  @Test @Ignore
-  fun httpLoggingInterceptor() {
-    var interceptor: HttpLoggingInterceptor = HttpLoggingInterceptor()
-    interceptor = HttpLoggingInterceptor(HttpLoggingInterceptor.Logger.DEFAULT)
-    interceptor.redactHeader("")
-    interceptor.level = HttpLoggingInterceptor.Level.BASIC
-    var level: HttpLoggingInterceptor.Level = interceptor.level
-    interceptor.intercept(newInterceptorChain())
-  }
-
-  @Test @Ignore
-  fun httpLoggingInterceptorLevel() {
-    val none: HttpLoggingInterceptor.Level = HttpLoggingInterceptor.Level.NONE
-    val basic: HttpLoggingInterceptor.Level = HttpLoggingInterceptor.Level.BASIC
-    val headers: HttpLoggingInterceptor.Level = HttpLoggingInterceptor.Level.HEADERS
-    val body: HttpLoggingInterceptor.Level = HttpLoggingInterceptor.Level.BODY
-  }
-
-  @Test @Ignore
-  fun httpLoggingInterceptorLogger() {
-    var logger: HttpLoggingInterceptor.Logger = object : HttpLoggingInterceptor.Logger {
-      override fun log(message: String) = TODO()
-    }
-    val default: HttpLoggingInterceptor.Logger = HttpLoggingInterceptor.Logger.DEFAULT
-  }
-
-  @Test @Ignore
-  fun httpUrl() {
-    val httpUrl: HttpUrl = "".toHttpUrl()
-    val isHttps: Boolean = httpUrl.isHttps
-    val url: URL = httpUrl.toUrl()
-    val uri: URI = httpUrl.toUri()
-    val scheme: String = httpUrl.scheme
-    val encodedUsername: String = httpUrl.encodedUsername
-    val username: String = httpUrl.username
-    val encodedPassword: String = httpUrl.encodedPassword
-    val password: String = httpUrl.password
-    val host: String = httpUrl.host
-    val port: Int = httpUrl.port
-    val pathSize: Int = httpUrl.pathSize
-    val encodedPath: String = httpUrl.encodedPath
-    val encodedPathSegments: List<String> = httpUrl.encodedPathSegments
-    val pathSegments: List<String> = httpUrl.pathSegments
-    val encodedQuery: String? = httpUrl.encodedQuery
-    val query: String? = httpUrl.query
-    val querySize: Int = httpUrl.querySize
-    val queryParameter: String? = httpUrl.queryParameter("")
-    val queryParameterNames: Set<String> = httpUrl.queryParameterNames
-    val queryParameterValues: List<String?> = httpUrl.queryParameterValues("")
-    val queryParameterName: String = httpUrl.queryParameterName(0)
-    val queryParameterValue: String? = httpUrl.queryParameterValue(0)
-    val encodedFragment: String? = httpUrl.encodedFragment
-    val fragment: String? = httpUrl.fragment
-    val redact: String = httpUrl.redact()
-    var builder: HttpUrl.Builder = httpUrl.newBuilder()
-    var resolveBuilder: HttpUrl.Builder? = httpUrl.newBuilder("")
-    val topPrivateDomain: String? = httpUrl.topPrivateDomain()
-    val resolve: HttpUrl? = httpUrl.resolve("")
-    val getFromUrl: HttpUrl? = URL("").toHttpUrlOrNull()
-    val getFromUri: HttpUrl? = URI("").toHttpUrlOrNull()
-    val parse: HttpUrl? = "".toHttpUrlOrNull()
-    val defaultPort: Int = HttpUrl.defaultPort("")
-  }
-
-  @Test @Ignore
-  fun httpUrlBuilder() {
-    var builder: HttpUrl.Builder = HttpUrl.Builder()
-    builder = builder.scheme("")
-    builder = builder.username("")
-    builder = builder.encodedUsername("")
-    builder = builder.password("")
-    builder = builder.encodedPassword("")
-    builder = builder.host("")
-    builder = builder.port(0)
-    builder = builder.addPathSegment("")
-    builder = builder.addPathSegments("")
-    builder = builder.addEncodedPathSegment("")
-    builder = builder.addEncodedPathSegments("")
-    builder = builder.setPathSegment(0, "")
-    builder = builder.setEncodedPathSegment(0, "")
-    builder = builder.removePathSegment(0)
-    builder = builder.encodedPath("")
-    builder = builder.query("")
-    builder = builder.encodedQuery("")
-    builder = builder.addQueryParameter("", "")
-    builder = builder.addEncodedQueryParameter("", "")
-    builder = builder.setQueryParameter("", "")
-    builder = builder.setEncodedQueryParameter("", "")
-    builder = builder.removeAllQueryParameters("")
-    builder = builder.removeAllEncodedQueryParameters("")
-    builder = builder.fragment("")
-    builder = builder.encodedFragment("")
-    val httpUrl: HttpUrl = builder.build()
-  }
-
-  @Test @Ignore
-  fun interceptor() {
-    var interceptor: Interceptor = object : Interceptor {
-      override fun intercept(chain: Interceptor.Chain): Response = TODO()
-    }
-    interceptor = Interceptor { it: Interceptor.Chain -> TODO() }
-  }
-
-  @Test @Ignore
-  fun interceptorChain() {
-    val chain: Interceptor.Chain = newInterceptorChain()
-  }
-
-  @Test @Ignore
-  fun handshakeCertificates() {
-    val handshakeCertificates = HandshakeCertificates.Builder().build()
-    val keyManager: X509KeyManager = handshakeCertificates.keyManager
-    val trustManager: X509TrustManager = handshakeCertificates.trustManager
-    val sslSocketFactory: SSLSocketFactory = handshakeCertificates.sslSocketFactory()
-    val sslContext: SSLContext = handshakeCertificates.sslContext()
-  }
-
-  @Test @Ignore
-  fun handshakeCertificatesBuilder() {
-    var builder: HandshakeCertificates.Builder = HandshakeCertificates.Builder()
-    val heldCertificate = HeldCertificate.Builder().build()
-    builder = builder.heldCertificate(heldCertificate, heldCertificate.certificate)
-    builder = builder.addTrustedCertificate(heldCertificate.certificate)
-    builder = builder.addPlatformTrustedCertificates()
-    val handshakeCertificates: HandshakeCertificates = builder.build()
-  }
-
-  @Test @Ignore
-  fun heldCertificate() {
-    val heldCertificate: HeldCertificate = HeldCertificate.Builder().build()
-    val certificate: X509Certificate = heldCertificate.certificate
-    val keyPair: KeyPair = heldCertificate.keyPair
-    val certificatePem: String = heldCertificate.certificatePem()
-    val privateKeyPkcs8Pem: String = heldCertificate.privateKeyPkcs8Pem()
-    val privateKeyPkcs1Pem: String = heldCertificate.privateKeyPkcs1Pem()
-  }
-
-  @Test @Ignore
-  fun heldCertificateBuilder() {
-    val keyPair: KeyPair = KeyPairGenerator.getInstance("").genKeyPair()
-    var builder: HeldCertificate.Builder = HeldCertificate.Builder()
-    builder = builder.validityInterval(0L, 0L)
-    builder = builder.duration(0L, TimeUnit.SECONDS)
-    builder = builder.addSubjectAlternativeName("")
-    builder = builder.commonName("")
-    builder = builder.organizationalUnit("")
-    builder = builder.serialNumber(BigInteger.ZERO)
-    builder = builder.serialNumber(0L)
-    builder = builder.keyPair(keyPair)
-    builder = builder.keyPair(keyPair.public, keyPair.private)
-    builder = builder.signedBy(HeldCertificate.Builder().build())
-    builder = builder.certificateAuthority(0)
-    builder = builder.ecdsa256()
-    builder = builder.rsa2048()
-    val heldCertificate: HeldCertificate = builder.build()
-  }
-
-  @Test @Ignore
-  fun javaNetAuthenticator() {
-    val authenticator = JavaNetAuthenticator()
-    val response = Response.Builder().build()
-    var request: Request? = authenticator.authenticate(newRoute(), response)
-    request = authenticator.authenticate(null, response)
-  }
-
-  @Test @Ignore
-  fun javaNetCookieJar() {
-    val cookieJar: JavaNetCookieJar = JavaNetCookieJar(newCookieHandler())
-    val httpUrl = "".toHttpUrl()
-    val loadForRequest: List<Cookie> = cookieJar.loadForRequest(httpUrl)
-    cookieJar.saveFromResponse(httpUrl, listOf(Cookie.Builder().build()))
-  }
-
-  @Test @Ignore
-  fun loggingEventListener() {
-    var loggingEventListener: EventListener = LoggingEventListener.Factory().create(newCall())
-  }
-
-  @Test @Ignore
-  fun loggingEventListenerFactory() {
-    var factory: LoggingEventListener.Factory = LoggingEventListener.Factory()
-    factory = LoggingEventListener.Factory(HttpLoggingInterceptor.Logger.DEFAULT)
-    factory = object : LoggingEventListener.Factory() {
-      override fun create(call: Call): EventListener = TODO()
-    }
-    val eventListener: EventListener = factory.create(newCall())
-  }
-
-  @Test @Ignore
-  fun mediaType() {
-    val mediaType: MediaType = "".toMediaType()
-    val defaultCharset: Charset? = mediaType.charset()
-    val charset: Charset? = mediaType.charset(Charsets.UTF_8)
-    val type: String = mediaType.type
-    val subtype: String = mediaType.subtype
-    val parse: MediaType? = "".toMediaTypeOrNull()
-  }
-
-  @Test @Ignore
-  fun mockResponse() {
-    var mockResponse: MockResponse = MockResponse()
-    var status: String = mockResponse.status
-    status = mockResponse.status
-    mockResponse.status = ""
-    mockResponse = mockResponse.setResponseCode(0)
-    var headers: Headers = mockResponse.headers
-    var trailers: Headers = mockResponse.trailers
-    mockResponse = mockResponse.clearHeaders()
-    mockResponse = mockResponse.addHeader("")
-    mockResponse = mockResponse.addHeader("", "")
-    mockResponse = mockResponse.addHeaderLenient("", Any())
-    mockResponse = mockResponse.setHeader("", Any())
-    mockResponse.headers = headersOf()
-    mockResponse.trailers = headersOf()
-    mockResponse = mockResponse.removeHeader("")
-    var body: Buffer? = mockResponse.getBody()
-    mockResponse = mockResponse.setBody(Buffer())
-    mockResponse = mockResponse.setChunkedBody(Buffer(), 0)
-    mockResponse = mockResponse.setChunkedBody("", 0)
-    var socketPolicy: SocketPolicy = mockResponse.socketPolicy
-    mockResponse.socketPolicy = SocketPolicy.KEEP_OPEN
-    var http2ErrorCode: Int = mockResponse.http2ErrorCode
-    mockResponse.http2ErrorCode = 0
-    mockResponse = mockResponse.throttleBody(0L, 0L, TimeUnit.SECONDS)
-    var throttleBytesPerPeriod: Long = mockResponse.throttleBytesPerPeriod
-    throttleBytesPerPeriod = mockResponse.throttleBytesPerPeriod
-    var throttlePeriod: Long = mockResponse.getThrottlePeriod(TimeUnit.SECONDS)
-    mockResponse = mockResponse.setBodyDelay(0L, TimeUnit.SECONDS)
-    val bodyDelay: Long = mockResponse.getBodyDelay(TimeUnit.SECONDS)
-    mockResponse = mockResponse.setHeadersDelay(0L, TimeUnit.SECONDS)
-    val headersDelay: Long = mockResponse.getHeadersDelay(TimeUnit.SECONDS)
-    mockResponse = mockResponse.withPush(PushPromise("", "", headersOf(), MockResponse()))
-    var pushPromises: List<PushPromise> = mockResponse.pushPromises
-    pushPromises = mockResponse.pushPromises
-    mockResponse = mockResponse.withSettings(Settings())
-    var settings: Settings = mockResponse.settings
-    settings = mockResponse.settings
-    mockResponse = mockResponse.withWebSocketUpgrade(object : WebSocketListener() {
-    })
-    var webSocketListener: WebSocketListener? = mockResponse.webSocketListener
-    webSocketListener = mockResponse.webSocketListener
-  }
-
-  @Test @Ignore
-  fun mockWebServer() {
-    val mockWebServer: MockWebServer = MockWebServer()
-    var port: Int = mockWebServer.port
-    var hostName: String = mockWebServer.hostName
-    hostName = mockWebServer.hostName
-    val toProxyAddress: Proxy = mockWebServer.toProxyAddress()
-    mockWebServer.serverSocketFactory = ServerSocketFactory.getDefault()
-    val url: HttpUrl = mockWebServer.url("")
-    mockWebServer.bodyLimit = 0L
-    mockWebServer.protocolNegotiationEnabled = false
-    mockWebServer.protocols = listOf()
-    val protocols: List<Protocol> = mockWebServer.protocols
-    mockWebServer.useHttps(SSLSocketFactory.getDefault() as SSLSocketFactory, false)
-    mockWebServer.noClientAuth()
-    mockWebServer.requestClientAuth()
-    mockWebServer.requireClientAuth()
-    val request: RecordedRequest = mockWebServer.takeRequest()
-    val nullableRequest: RecordedRequest? = mockWebServer.takeRequest(0L, TimeUnit.SECONDS)
-    var requestCount: Int = mockWebServer.requestCount
-    mockWebServer.enqueue(MockResponse())
-    mockWebServer.start()
-    mockWebServer.start(0)
-    mockWebServer.start(InetAddress.getLocalHost(), 0)
-    mockWebServer.shutdown()
-    var dispatcher: okhttp3.mockwebserver.Dispatcher = mockWebServer.dispatcher
-    dispatcher = mockWebServer.dispatcher
-    mockWebServer.dispatcher = QueueDispatcher()
-    mockWebServer.dispatcher = QueueDispatcher()
-    mockWebServer.close()
-  }
-
-  @Test @Ignore
-  fun multipartBody() {
-    val multipartBody: MultipartBody = MultipartBody.Builder().build()
-    val type: MediaType = multipartBody.type
-    val boundary: String = multipartBody.boundary
-    val size: Int = multipartBody.size
-    val parts: List<MultipartBody.Part> = multipartBody.parts
-    val part: MultipartBody.Part = multipartBody.part(0)
-    val contentType: MediaType? = multipartBody.contentType()
-    val contentLength: Long = multipartBody.contentLength()
-    multipartBody.writeTo(Buffer())
-    val mixed: MediaType = MultipartBody.MIXED
-    val alternative: MediaType = MultipartBody.ALTERNATIVE
-    val digest: MediaType = MultipartBody.DIGEST
-    val parallel: MediaType = MultipartBody.PARALLEL
-    val form: MediaType = MultipartBody.FORM
-  }
-
-  @Test @Ignore
-  fun multipartBodyPart() {
-    val requestBody: RequestBody = "".toRequestBody(null)
-    var part: MultipartBody.Part = MultipartBody.Part.create(null, requestBody)
-    part = MultipartBody.Part.create(headersOf(), requestBody)
-    part = MultipartBody.Part.create(requestBody)
-    part = MultipartBody.Part.createFormData("", "")
-    part = MultipartBody.Part.createFormData("", "", requestBody)
-    part = MultipartBody.Part.createFormData("", null, requestBody)
-    val headers: Headers? = part.headers
-    val body: RequestBody = part.body
-  }
-
-  @Test @Ignore
-  fun multipartBodyBuilder() {
-    val requestBody = "".toRequestBody(null)
-    var builder: MultipartBody.Builder = MultipartBody.Builder()
-    builder = MultipartBody.Builder("")
-    builder = builder.setType("".toMediaType())
-    builder = builder.addPart(requestBody)
-    builder = builder.addPart(headersOf(), requestBody)
-    builder = builder.addPart(null, requestBody)
-    builder = builder.addFormDataPart("", "")
-    builder = builder.addFormDataPart("", "", requestBody)
-    builder = builder.addFormDataPart("", null, requestBody)
-    builder = builder.addPart(MultipartBody.Part.create(requestBody))
-    val multipartBody: MultipartBody = builder.build()
-  }
-
-  @Test @Ignore
-  fun okHttpClient() {
-    val client: OkHttpClient = OkHttpClient()
-    val dispatcher: Dispatcher = client.dispatcher
-    val proxy: Proxy? = client.proxy
-    val protocols: List<Protocol> = client.protocols
-    val connectionSpecs: List<ConnectionSpec> = client.connectionSpecs
-    val interceptors: List<Interceptor> = client.interceptors
-    val networkInterceptors: List<Interceptor> = client.networkInterceptors
-    val eventListenerFactory: EventListener.Factory = client.eventListenerFactory
-    val proxySelector: ProxySelector = client.proxySelector
-    val cookieJar: CookieJar = client.cookieJar
-    val cache: Cache? = client.cache
-    val socketFactory: SocketFactory = client.socketFactory
-    val sslSocketFactory: SSLSocketFactory = client.sslSocketFactory
-    val hostnameVerifier: HostnameVerifier = client.hostnameVerifier
-    val certificatePinner: CertificatePinner = client.certificatePinner
-    val proxyAuthenticator: Authenticator = client.proxyAuthenticator
-    val authenticator: Authenticator = client.authenticator
-    val connectionPool: ConnectionPool = client.connectionPool
-    val dns: Dns = client.dns
-    val followSslRedirects: Boolean = client.followSslRedirects
-    val followRedirects: Boolean = client.followRedirects
-    val retryOnConnectionFailure: Boolean = client.retryOnConnectionFailure
-    val callTimeoutMillis: Int = client.callTimeoutMillis
-    val connectTimeoutMillis: Int = client.connectTimeoutMillis
-    val readTimeoutMillis: Int = client.readTimeoutMillis
-    val writeTimeoutMillis: Int = client.writeTimeoutMillis
-    val pingIntervalMillis: Int = client.pingIntervalMillis
-    val call: Call = client.newCall(Request.Builder().build())
-    val webSocket: WebSocket = client.newWebSocket(
-        Request.Builder().build(),
-        object : WebSocketListener() {
-        })
-    val newBuilder: OkHttpClient.Builder = client.newBuilder()
-  }
-
-  @Test @Ignore
-  fun okHttpClientBuilder() {
-    var builder: OkHttpClient.Builder = OkHttpClient.Builder()
-    builder = builder.callTimeout(0L, TimeUnit.SECONDS)
-    builder = builder.callTimeout(Duration.ofSeconds(0L))
-    builder = builder.connectTimeout(0L, TimeUnit.SECONDS)
-    builder = builder.connectTimeout(Duration.ofSeconds(0L))
-    builder = builder.readTimeout(0L, TimeUnit.SECONDS)
-    builder = builder.readTimeout(Duration.ofSeconds(0L))
-    builder = builder.writeTimeout(0L, TimeUnit.SECONDS)
-    builder = builder.writeTimeout(Duration.ofSeconds(0L))
-    builder = builder.pingInterval(0L, TimeUnit.SECONDS)
-    builder = builder.pingInterval(Duration.ofSeconds(0L))
-    builder = builder.proxy(Proxy.NO_PROXY)
-    builder = builder.proxySelector(NullProxySelector)
-    builder = builder.cookieJar(CookieJar.NO_COOKIES)
-    builder = builder.cache(Cache(File("/cache/"), Integer.MAX_VALUE.toLong()))
-    builder = builder.dns(Dns.SYSTEM)
-    builder = builder.socketFactory(SocketFactory.getDefault())
-    builder = builder.sslSocketFactory(localhost().sslSocketFactory(), localhost().trustManager)
-    builder = builder.hostnameVerifier(OkHostnameVerifier)
-    builder = builder.certificatePinner(CertificatePinner.DEFAULT)
-    builder = builder.authenticator(Authenticator.NONE)
-    builder = builder.proxyAuthenticator(Authenticator.NONE)
-    builder = builder.connectionPool(ConnectionPool(0, 0, TimeUnit.SECONDS))
-    builder = builder.followSslRedirects(false)
-    builder = builder.followRedirects(false)
-    builder = builder.retryOnConnectionFailure(false)
-    builder = builder.dispatcher(Dispatcher())
-    builder = builder.protocols(listOf(Protocol.HTTP_1_1))
-    builder = builder.connectionSpecs(listOf(ConnectionSpec.MODERN_TLS))
-    val interceptors: List<Interceptor> = builder.interceptors()
-    builder = builder.addInterceptor(object : Interceptor {
-      override fun intercept(chain: Interceptor.Chain): Response = TODO()
-    })
-    builder = builder.addInterceptor { it: Interceptor.Chain -> TODO() }
-    val networkInterceptors: List<Interceptor> = builder.networkInterceptors()
-    builder = builder.addNetworkInterceptor(object : Interceptor {
-      override fun intercept(chain: Interceptor.Chain): Response = TODO()
-    })
-    builder = builder.addNetworkInterceptor { it: Interceptor.Chain -> TODO() }
-    builder = builder.eventListener(EventListener.NONE)
-    builder = builder.eventListenerFactory(object : EventListener.Factory {
-      override fun create(call: Call): EventListener = TODO()
-    })
-    val client: OkHttpClient = builder.build()
-  }
-
-  @Test @Ignore
-  fun testAddInterceptor() {
-    val builder = OkHttpClient.Builder()
-
-    val i = HttpLoggingInterceptor()
-
-    builder.interceptors().add(i)
-    builder.networkInterceptors().add(i)
-  }
-
-  @Test @Ignore
-  fun protocol() {
-    var protocol: Protocol = Protocol.HTTP_2
-    protocol = Protocol.get("")
-  }
-
-  @Test @Ignore
-  fun pushPromise() {
-    val pushPromise: PushPromise = PushPromise("", "", headersOf(), MockResponse())
-    val method: String = pushPromise.method
-    val path: String = pushPromise.path
-    val headers: Headers = pushPromise.headers
-    val response: MockResponse = pushPromise.response
-  }
-
-  @Test @Ignore
-  fun queueDispatcher() {
-    var queueDispatcher: QueueDispatcher = object : QueueDispatcher() {
-      override fun dispatch(request: RecordedRequest): MockResponse = TODO()
-      override fun peek(): MockResponse = TODO()
-      override fun enqueueResponse(response: MockResponse) = TODO()
-      override fun shutdown() = TODO()
-      override fun setFailFast(failFast: Boolean) = TODO()
-      override fun setFailFast(failFastResponse: MockResponse?) = TODO()
-    }
-    queueDispatcher = QueueDispatcher()
-    var mockResponse: MockResponse = queueDispatcher.dispatch(
-        RecordedRequest("", headersOf(), listOf(), 0L, Buffer(), 0, Socket()))
-    mockResponse = queueDispatcher.peek()
-    queueDispatcher.enqueueResponse(MockResponse())
-    queueDispatcher.shutdown()
-    queueDispatcher.setFailFast(false)
-    queueDispatcher.setFailFast(MockResponse())
-  }
-
-  @Test @Ignore
-  fun recordedRequest() {
-    var recordedRequest: RecordedRequest = RecordedRequest(
-        "", headersOf(), listOf(), 0L, Buffer(), 0, Socket())
-    recordedRequest = RecordedRequest("", headersOf(), listOf(), 0L, Buffer(), 0, Socket())
-    var requestUrl: HttpUrl? = recordedRequest.requestUrl
-    var requestLine: String = recordedRequest.requestLine
-    var method: String? = recordedRequest.method
-    var path: String? = recordedRequest.path
-    var headers: Headers = recordedRequest.headers
-    val header: String? = recordedRequest.getHeader("")
-    var chunkSizes: List<Int> = recordedRequest.chunkSizes
-    var bodySize: Long = recordedRequest.bodySize
-    var body: Buffer = recordedRequest.body
-    var utf8Body: String = recordedRequest.body.readUtf8()
-    var sequenceNumber: Int = recordedRequest.sequenceNumber
-    var tlsVersion: TlsVersion? = recordedRequest.tlsVersion
-    var handshake: Handshake? = recordedRequest.handshake
-  }
-
-  @Test @Ignore
-  fun request() {
-    val request: Request = Request.Builder().build()
-    val isHttps: Boolean = request.isHttps
-    val url: HttpUrl = request.url
-    val method: String = request.method
-    val headers: Headers = request.headers
-    val header: String? = request.header("")
-    val headersForName: List<String> = request.headers("")
-    val body: RequestBody? = request.body
-    var tag: Any? = request.tag()
-    tag = request.tag(Any::class.java)
-    val builder: Request.Builder = request.newBuilder()
-    val cacheControl: CacheControl = request.cacheControl
-  }
-
-  @Test @Ignore
-  fun requestBuilder() {
-    val requestBody = "".toRequestBody(null)
-    var builder = Request.Builder()
-    builder = builder.url("".toHttpUrl())
-    builder = builder.url("")
-    builder = builder.url(URL(""))
-    builder = builder.header("", "")
-    builder = builder.addHeader("", "")
-    builder = builder.removeHeader("")
-    builder = builder.headers(headersOf())
-    builder = builder.cacheControl(CacheControl.FORCE_CACHE)
-    builder = builder.get()
-    builder = builder.head()
-    builder = builder.post(requestBody)
-    builder = builder.delete(requestBody)
-    builder = builder.delete(null)
-    builder = builder.put(requestBody)
-    builder = builder.patch(requestBody)
-    builder = builder.method("", requestBody)
-    builder = builder.method("", null)
-    builder = builder.tag("")
-    builder = builder.tag(null)
-    builder = builder.tag(String::class.java, "")
-    builder = builder.tag(String::class.java, null)
-    val request: Request = builder.build()
-  }
-
-  @Test @Ignore
-  fun requestBody() {
-    var requestBody: RequestBody = object : RequestBody() {
-      override fun contentType(): MediaType? = TODO()
-      override fun contentLength(): Long = TODO()
-      override fun isDuplex(): Boolean = TODO()
-      override fun isOneShot(): Boolean = TODO()
-      override fun writeTo(sink: BufferedSink) = TODO()
-    }
-    requestBody = "".toRequestBody(null)
-    requestBody = "".toRequestBody("".toMediaTypeOrNull())
-    requestBody = ByteString.EMPTY.toRequestBody(null)
-    requestBody = ByteString.EMPTY.toRequestBody("".toMediaTypeOrNull())
-    requestBody = byteArrayOf(0, 1).toRequestBody(null, 0, 2)
-    requestBody = byteArrayOf(0, 1).toRequestBody("".toMediaTypeOrNull(), 0, 2)
-    requestBody = byteArrayOf(0, 1).toRequestBody(null, 0, 2)
-    requestBody = byteArrayOf(0, 1).toRequestBody("".toMediaTypeOrNull(), 0, 2)
-    requestBody = File("").asRequestBody(null)
-    requestBody = File("").asRequestBody("".toMediaTypeOrNull())
-  }
-
-  @Test @Ignore
-  fun response() {
-    val response: Response = Response.Builder().build()
-    val request: Request = response.request
-    val protocol: Protocol = response.protocol
-    val code: Int = response.code
-    val successful: Boolean = response.isSuccessful
-    val message: String = response.message
-    val handshake: Handshake? = response.handshake
-    val headersForName: List<String> = response.headers("")
-    val header: String? = response.header("")
-    val headers: Headers = response.headers
-    val trailers: Headers = response.trailers()
-    val peekBody: ResponseBody = response.peekBody(0L)
-    val body: ResponseBody? = response.body
-    val builder: Response.Builder = response.newBuilder()
-    val redirect: Boolean = response.isRedirect
-    val networkResponse: Response? = response.networkResponse
-    val cacheResponse: Response? = response.cacheResponse
-    val priorResponse: Response? = response.priorResponse
-    val challenges: List<Challenge> = response.challenges()
-    val cacheControl: CacheControl = response.cacheControl
-    val sentRequestAtMillis: Long = response.sentRequestAtMillis
-    val receivedResponseAtMillis: Long = response.receivedResponseAtMillis
-  }
-
-  @Test @Ignore
-  fun responseBuilder() {
-    var builder: Response.Builder = Response.Builder()
-    builder = builder.request(Request.Builder().build())
-    builder = builder.protocol(Protocol.HTTP_2)
-    builder = builder.code(0)
-    builder = builder.message("")
-    builder = builder.handshake(Handshake.get(
-        TlsVersion.TLS_1_3,
-        CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
-        listOf(),
-        listOf())
-    )
-    builder = builder.handshake(null)
-    builder = builder.header("", "")
-    builder = builder.addHeader("", "")
-    builder = builder.removeHeader("")
-    builder = builder.headers(headersOf())
-    builder = builder.body("".toResponseBody(null))
-    builder = builder.body(null)
-    builder = builder.networkResponse(Response.Builder().build())
-    builder = builder.networkResponse(null)
-    builder = builder.cacheResponse(Response.Builder().build())
-    builder = builder.cacheResponse(null)
-    builder = builder.priorResponse(Response.Builder().build())
-    builder = builder.priorResponse(null)
-    builder = builder.sentRequestAtMillis(0L)
-    builder = builder.receivedResponseAtMillis(0L)
-    val response: Response = builder.build()
-  }
-
-  @Test @Ignore
-  fun responseBody() {
-    var responseBody: ResponseBody = object : ResponseBody() {
-      override fun contentType(): MediaType? = TODO()
-      override fun contentLength(): Long = TODO()
-      override fun source(): BufferedSource = TODO()
-      override fun close() = TODO()
-    }
-    val byteStream = responseBody.byteStream()
-    val source = responseBody.source()
-    val bytes = responseBody.bytes()
-    val charStream = responseBody.charStream()
-    val string = responseBody.string()
-    responseBody.close()
-    responseBody = "".toResponseBody("".toMediaType())
-    responseBody = "".toResponseBody(null)
-    responseBody = ByteString.EMPTY.toResponseBody("".toMediaType())
-    responseBody = ByteString.EMPTY.toResponseBody(null)
-    responseBody = byteArrayOf(0, 1).toResponseBody("".toMediaType())
-    responseBody = byteArrayOf(0, 1).toResponseBody(null)
-    responseBody = Buffer().asResponseBody("".toMediaType(), 0L)
-    responseBody = Buffer().asResponseBody(null, 0L)
-  }
-
-  @Test @Ignore
-  fun route() {
-    val route: Route = newRoute()
-    val address: Address = route.address
-    val proxy: Proxy = route.proxy
-    val inetSocketAddress: InetSocketAddress = route.socketAddress
-    val requiresTunnel: Boolean = route.requiresTunnel()
-  }
-
-  @Test @Ignore
-  fun socketPolicy() {
-    val socketPolicy: SocketPolicy = SocketPolicy.KEEP_OPEN
-  }
-
-  @Test @Ignore
-  fun tlsVersion() {
-    var tlsVersion: TlsVersion = TlsVersion.TLS_1_3
-    val javaName: String = tlsVersion.javaName
-    tlsVersion = TlsVersion.forJavaName("")
-  }
-
-  @Test @Ignore
-  fun webSocket() {
-    val webSocket = object : WebSocket {
-      override fun request(): Request = TODO()
-      override fun queueSize(): Long = TODO()
-      override fun send(text: String): Boolean = TODO()
-      override fun send(bytes: ByteString): Boolean = TODO()
-      override fun close(code: Int, reason: String?): Boolean = TODO()
-      override fun cancel() = TODO()
-    }
-  }
-
-  @Test @Ignore
-  fun webSocketListener() {
-    val webSocketListener = object : WebSocketListener() {
-      override fun onOpen(webSocket: WebSocket, response: Response) = TODO()
-      override fun onMessage(webSocket: WebSocket, text: String) = TODO()
-      override fun onMessage(webSocket: WebSocket, bytes: ByteString) = TODO()
-      override fun onClosing(webSocket: WebSocket, code: Int, reason: String) = TODO()
-      override fun onClosed(webSocket: WebSocket, code: Int, reason: String) = TODO()
-      override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) = TODO()
-    }
-  }
-
-  private fun newAddress(): Address {
-    return Address(
-        "",
-        0,
-        Dns.SYSTEM,
-        SocketFactory.getDefault(),
-        localhost().sslSocketFactory(),
-        OkHostnameVerifier,
-        CertificatePinner.DEFAULT,
-        Authenticator.NONE,
-        Proxy.NO_PROXY,
-        listOf(Protocol.HTTP_1_1),
-        listOf(ConnectionSpec.MODERN_TLS),
-        NullProxySelector
-    )
-  }
-
-  private fun newCall(): Call {
-    return object : Call {
-      override fun request(): Request = TODO()
-      override fun execute(): Response = TODO()
-      override fun enqueue(responseCallback: Callback) = TODO()
-      override fun cancel() = TODO()
-      override fun isExecuted(): Boolean = TODO()
-      override fun isCanceled(): Boolean = TODO()
-      override fun timeout(): Timeout = TODO()
-      override fun clone(): Call = TODO()
-    }
-  }
-
-  private fun newCookieHandler(): CookieHandler {
-    return object : CookieHandler() {
-      override fun put(
-        uri: URI?,
-        responseHeaders: MutableMap<String, MutableList<String>>?
-      ) = TODO()
-
-      override fun get(
-        uri: URI?,
-        requestHeaders: MutableMap<String, MutableList<String>>?
-      ): MutableMap<String, MutableList<String>> = TODO()
-    }
-  }
-
-  private fun newInterceptorChain(): Interceptor.Chain {
-    return object : Interceptor.Chain {
-      override fun request(): Request = TODO()
-      override fun proceed(request: Request): Response = TODO()
-      override fun connection(): Connection? = TODO()
-      override fun call(): Call = TODO()
-      override fun connectTimeoutMillis(): Int = TODO()
-      override fun withConnectTimeout(timeout: Int, unit: TimeUnit): Interceptor.Chain = TODO()
-      override fun readTimeoutMillis(): Int = TODO()
-      override fun withReadTimeout(timeout: Int, unit: TimeUnit): Interceptor.Chain = TODO()
-      override fun writeTimeoutMillis(): Int = TODO()
-      override fun withWriteTimeout(timeout: Int, unit: TimeUnit): Interceptor.Chain = TODO()
-    }
-  }
-
-  private fun newRoute(): Route {
-    return Route(newAddress(), Proxy.NO_PROXY, InetSocketAddress.createUnresolved("", 0))
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/MediaTypeTest.java b/okhttp/src/test/java/okhttp3/MediaTypeTest.java
deleted file mode 100644
index a74bc9a05b..0000000000
--- a/okhttp/src/test/java/okhttp3/MediaTypeTest.java
+++ /dev/null
@@ -1,221 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- * Copyright (C) 2011 The Guava Authors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.nio.charset.Charset;
-import java.util.Collection;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static java.util.Arrays.asList;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-/**
- * Test MediaType API and parsing.
- *
- * <p>This test includes tests from <a href="https://code.google.com/p/guava-libraries/">Guava's</a>
- * MediaTypeTest.
- */
-@RunWith(Parameterized.class)
-public class MediaTypeTest {
-  @Parameterized.Parameters(name = "Use get = {0}")
-  public static Collection<Object[]> parameters() {
-    return asList(
-        new Object[] { true },
-        new Object[] { false }
-    );
-  }
-
-  @Parameterized.Parameter
-  public boolean useGet;
-
-  private MediaType parse(String string) {
-    return useGet
-        ? MediaType.get(string)
-        : MediaType.parse(string);
-  }
-
-  @Test public void testParse() throws Exception {
-    MediaType mediaType = parse("text/plain;boundary=foo;charset=utf-8");
-    assertThat(mediaType.type()).isEqualTo("text");
-    assertThat(mediaType.subtype()).isEqualTo("plain");
-    assertThat(mediaType.charset().name()).isEqualTo("UTF-8");
-    assertThat(mediaType.toString()).isEqualTo("text/plain;boundary=foo;charset=utf-8");
-    assertThat(parse("text/plain;boundary=foo;charset=utf-8")).isEqualTo(mediaType);
-    assertThat(parse("text/plain;boundary=foo;charset=utf-8").hashCode()).isEqualTo(
-        (long) mediaType.hashCode());
-  }
-
-  @Test public void testValidParse() throws Exception {
-    assertMediaType("text/plain");
-    assertMediaType("application/atom+xml; charset=utf-8");
-    assertMediaType("application/atom+xml; a=1; a=2; b=3");
-    assertMediaType("image/gif; foo=bar");
-    assertMediaType("text/plain; a=1");
-    assertMediaType("text/plain; a=1; a=2; b=3");
-    assertMediaType("text/plain; charset=utf-16");
-    assertMediaType("text/plain; \t \n \r a=b");
-    assertMediaType("text/plain;");
-    assertMediaType("text/plain; ");
-    assertMediaType("text/plain; a=1;");
-    assertMediaType("text/plain; a=1; ");
-    assertMediaType("text/plain; a=1;; b=2");
-    assertMediaType("text/plain;;");
-    assertMediaType("text/plain; ;");
-  }
-
-  @Test public void testInvalidParse() throws Exception {
-    assertInvalid("", "No subtype found for: \"\"");
-    assertInvalid("/", "No subtype found for: \"/\"");
-    assertInvalid("text", "No subtype found for: \"text\"");
-    assertInvalid("text/", "No subtype found for: \"text/\"");
-    assertInvalid("te<t/plain", "No subtype found for: \"te<t/plain\"");
-    assertInvalid(" text/plain", "No subtype found for: \" text/plain\"");
-    assertInvalid("te xt/plain", "No subtype found for: \"te xt/plain\"");
-    assertInvalid("text /plain", "No subtype found for: \"text /plain\"");
-    assertInvalid("text/ plain", "No subtype found for: \"text/ plain\"");
-
-    assertInvalid("text/pl@in",
-        "Parameter is not formatted correctly: \"@in\" for: \"text/pl@in\"");
-    assertInvalid("text/plain; a",
-        "Parameter is not formatted correctly: \"a\" for: \"text/plain; a\"");
-    assertInvalid("text/plain; a=",
-        "Parameter is not formatted correctly: \"a=\" for: \"text/plain; a=\"");
-    assertInvalid("text/plain; a=@",
-        "Parameter is not formatted correctly: \"a=@\" for: \"text/plain; a=@\"");
-    assertInvalid("text/plain; a=\"@",
-        "Parameter is not formatted correctly: \"a=\"@\" for: \"text/plain; a=\"@\"");
-    assertInvalid("text/plain; a=1; b",
-        "Parameter is not formatted correctly: \"b\" for: \"text/plain; a=1; b\"");
-    assertInvalid("text/plain; a=1; b=",
-        "Parameter is not formatted correctly: \"b=\" for: \"text/plain; a=1; b=\"");
-    assertInvalid("text/plain; a=\u2025",
-        "Parameter is not formatted correctly: \"a=\" for: \"text/plain; a=\"");
-    assertInvalid("text/pl ain",
-        "Parameter is not formatted correctly: \" ain\" for: \"text/pl ain\"");
-    assertInvalid("text/plain ",
-        "Parameter is not formatted correctly: \" \" for: \"text/plain \"");
-    assertInvalid("text/plain ; a=1",
-        "Parameter is not formatted correctly: \" ; a=1\" for: \"text/plain ; a=1\"");
-  }
-
-  @Test public void testDoubleQuotesAreSpecial() throws Exception {
-    MediaType mediaType = parse("text/plain;a=\";charset=utf-8;b=\"");
-    assertThat(mediaType.charset()).isNull();
-  }
-
-  @Test public void testSingleQuotesAreNotSpecial() throws Exception {
-    MediaType mediaType = parse("text/plain;a=';charset=utf-8;b='");
-    assertThat(mediaType.charset().name()).isEqualTo("UTF-8");
-  }
-
-  @Test public void testParseWithSpecialCharacters() throws Exception {
-    MediaType mediaType = parse("!#$%&'*+-.{|}~/!#$%&'*+-.{|}~; !#$%&'*+-.{|}~=!#$%&'*+-.{|}~");
-    assertThat(mediaType.type()).isEqualTo("!#$%&'*+-.{|}~");
-    assertThat(mediaType.subtype()).isEqualTo("!#$%&'*+-.{|}~");
-  }
-
-  @Test public void testCharsetIsOneOfManyParameters() throws Exception {
-    MediaType mediaType = parse("text/plain;a=1;b=2;charset=utf-8;c=3");
-    assertThat(mediaType.type()).isEqualTo("text");
-    assertThat(mediaType.subtype()).isEqualTo("plain");
-    assertThat(mediaType.charset().name()).isEqualTo("UTF-8");
-  }
-
-  @Test public void testCharsetAndQuoting() throws Exception {
-    MediaType mediaType = parse(
-        "text/plain;a=\";charset=us-ascii\";charset=\"utf-8\";b=\"iso-8859-1\"");
-    assertThat(mediaType.charset().name()).isEqualTo("UTF-8");
-  }
-
-  @Test public void testDuplicatedCharsets() {
-    MediaType mediaType = parse("text/plain; charset=utf-8; charset=UTF-8");
-    assertThat(mediaType.charset().name()).isEqualTo("UTF-8");
-  }
-
-  @Test public void testMultipleCharsets() {
-    assertInvalid("text/plain; charset=utf-8; charset=utf-16",
-        "Multiple charsets defined: \"utf-8\" and: \"utf-16\" for: \"text/plain; charset=utf-8; charset=utf-16\"");
-  }
-
-  @Test public void testIllegalCharsetName() {
-    MediaType mediaType = parse("text/plain; charset=\"!@#$%^&*()\"");
-    assertThat(mediaType.charset()).isNull();
-  }
-
-  @Test public void testUnsupportedCharset() {
-    MediaType mediaType = parse("text/plain; charset=utf-wtf");
-    assertThat(mediaType.charset()).isNull();
-  }
-
-  /**
-   * This is invalid according to RFC 822. But it's what Chrome does and it avoids a potentially
-   * unpleasant IllegalCharsetNameException.
-   */
-  @Test public void testCharsetNameIsSingleQuoted() throws Exception {
-    MediaType mediaType = parse("text/plain;charset='utf-8'");
-    assertThat(mediaType.charset().name()).isEqualTo("UTF-8");
-  }
-
-  @Test public void testCharsetNameIsDoubleQuotedAndSingleQuoted() throws Exception {
-    MediaType mediaType = parse("text/plain;charset=\"'utf-8'\"");
-    assertThat(mediaType.charset()).isNull();
-  }
-
-  @Test public void testCharsetNameIsDoubleQuotedSingleQuote() throws Exception {
-    MediaType mediaType = parse("text/plain;charset=\"'\"");
-    assertThat(mediaType.charset()).isNull();
-  }
-
-  @Test public void testDefaultCharset() throws Exception {
-    MediaType noCharset = parse("text/plain");
-    assertThat(noCharset.charset(UTF_8).name()).isEqualTo("UTF-8");
-    assertThat(noCharset.charset(Charset.forName("US-ASCII")).name()).isEqualTo("US-ASCII");
-
-    MediaType charset = parse("text/plain; charset=iso-8859-1");
-    assertThat(charset.charset(UTF_8).name()).isEqualTo("ISO-8859-1");
-    assertThat(charset.charset(Charset.forName("US-ASCII")).name()).isEqualTo("ISO-8859-1");
-  }
-
-  @Test public void testParseDanglingSemicolon() throws Exception {
-    MediaType mediaType = parse("text/plain;");
-    assertThat(mediaType.type()).isEqualTo("text");
-    assertThat(mediaType.subtype()).isEqualTo("plain");
-    assertThat(mediaType.charset()).isNull();
-    assertThat(mediaType.toString()).isEqualTo("text/plain;");
-  }
-
-  private void assertMediaType(String string) {
-    assertThat(parse(string).toString()).isEqualTo(string);
-  }
-
-  private void assertInvalid(String string, String exceptionMessage) {
-    if (useGet) {
-      try {
-        parse(string);
-        fail("Expected get of \"" + string + "\" to throw with: " + exceptionMessage);
-      } catch (IllegalArgumentException e) {
-        assertThat(e.getMessage()).isEqualTo(exceptionMessage);
-      }
-    } else {
-      assertThat(parse(string)).overridingErrorMessage(string).isNull();
-    }
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/MultipartBodyTest.java b/okhttp/src/test/java/okhttp3/MultipartBodyTest.java
deleted file mode 100644
index 8b05917ab3..0000000000
--- a/okhttp/src/test/java/okhttp3/MultipartBodyTest.java
+++ /dev/null
@@ -1,296 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import okio.Buffer;
-import okio.BufferedSink;
-import org.junit.Test;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class MultipartBodyTest {
-  @Test public void onePartRequired() throws Exception {
-    try {
-      new MultipartBody.Builder().build();
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).isEqualTo("Multipart body must have at least one part.");
-    }
-  }
-
-  @Test public void singlePart() throws Exception {
-    String expected = ""
-        + "--123\r\n"
-        + "Content-Length: 13\r\n"
-        + "\r\n"
-        + "Hello, World!\r\n"
-        + "--123--\r\n";
-
-    MultipartBody body = new MultipartBody.Builder("123")
-        .addPart(RequestBody.create("Hello, World!", null))
-        .build();
-
-    assertThat(body.boundary()).isEqualTo("123");
-    assertThat(body.type()).isEqualTo(MultipartBody.MIXED);
-    assertThat(body.contentType().toString()).isEqualTo("multipart/mixed; boundary=123");
-    assertThat(body.parts().size()).isEqualTo(1);
-    assertThat(body.contentLength()).isEqualTo(53);
-
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    assertThat(body.contentLength()).isEqualTo(buffer.size());
-    assertThat(buffer.readUtf8()).isEqualTo(expected);
-  }
-
-  @Test public void threeParts() throws Exception {
-    String expected = ""
-        + "--123\r\n"
-        + "Content-Length: 5\r\n"
-        + "\r\n"
-        + "Quick\r\n"
-        + "--123\r\n"
-        + "Content-Length: 5\r\n"
-        + "\r\n"
-        + "Brown\r\n"
-        + "--123\r\n"
-        + "Content-Length: 3\r\n"
-        + "\r\n"
-        + "Fox\r\n"
-        + "--123--\r\n";
-
-    MultipartBody body = new MultipartBody.Builder("123")
-        .addPart(RequestBody.create("Quick", null))
-        .addPart(RequestBody.create("Brown", null))
-        .addPart(RequestBody.create("Fox", null))
-        .build();
-
-    assertThat(body.boundary()).isEqualTo("123");
-    assertThat(body.type()).isEqualTo(MultipartBody.MIXED);
-    assertThat(body.contentType().toString()).isEqualTo("multipart/mixed; boundary=123");
-    assertThat(body.parts().size()).isEqualTo(3);
-    assertThat(body.contentLength()).isEqualTo(112);
-
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    assertThat(body.contentLength()).isEqualTo(buffer.size());
-    assertThat(buffer.readUtf8()).isEqualTo(expected);
-  }
-
-  @Test public void fieldAndTwoFiles() throws Exception {
-    String expected = ""
-        + "--AaB03x\r\n"
-        + "Content-Disposition: form-data; name=\"submit-name\"\r\n"
-        + "Content-Length: 5\r\n"
-        + "\r\n"
-        + "Larry\r\n"
-        + "--AaB03x\r\n"
-        + "Content-Disposition: form-data; name=\"files\"\r\n"
-        + "Content-Type: multipart/mixed; boundary=BbC04y\r\n"
-        + "Content-Length: 337\r\n"
-        + "\r\n"
-        + "--BbC04y\r\n"
-        + "Content-Disposition: file; filename=\"file1.txt\"\r\n"
-        + "Content-Type: text/plain; charset=utf-8\r\n"
-        + "Content-Length: 29\r\n"
-        + "\r\n"
-        + "... contents of file1.txt ...\r\n"
-        + "--BbC04y\r\n"
-        + "Content-Disposition: file; filename=\"file2.gif\"\r\n"
-        + "Content-Transfer-Encoding: binary\r\n"
-        + "Content-Type: image/gif\r\n"
-        + "Content-Length: 29\r\n"
-        + "\r\n"
-        + "... contents of file2.gif ...\r\n"
-        + "--BbC04y--\r\n"
-        + "\r\n"
-        + "--AaB03x--\r\n";
-
-    MultipartBody body = new MultipartBody.Builder("AaB03x")
-        .setType(MultipartBody.FORM)
-        .addFormDataPart("submit-name", "Larry")
-        .addFormDataPart("files", null,
-            new MultipartBody.Builder("BbC04y")
-                .addPart(
-                    Headers.of("Content-Disposition", "file; filename=\"file1.txt\""),
-                    RequestBody.create(
-                        "... contents of file1.txt ...", MediaType.get("text/plain")))
-                .addPart(
-                    Headers.of(
-                        "Content-Disposition", "file; filename=\"file2.gif\"",
-                        "Content-Transfer-Encoding", "binary"),
-                    RequestBody.create(
-                        "... contents of file2.gif ...".getBytes(UTF_8),
-                        MediaType.get("image/gif")))
-                .build())
-        .build();
-
-    assertThat(body.boundary()).isEqualTo("AaB03x");
-    assertThat(body.type()).isEqualTo(MultipartBody.FORM);
-    assertThat(body.contentType().toString()).isEqualTo(
-        "multipart/form-data; boundary=AaB03x");
-    assertThat(body.parts().size()).isEqualTo(2);
-    assertThat(body.contentLength()).isEqualTo(568);
-
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    assertThat(body.contentLength()).isEqualTo(buffer.size());
-    assertThat(buffer.readUtf8()).isEqualTo(expected);
-  }
-
-  @Test public void stringEscapingIsWeird() throws Exception {
-    String expected = ""
-        + "--AaB03x\r\n"
-        + "Content-Disposition: form-data; name=\"field with spaces\"; filename=\"filename with spaces.txt\"\r\n"
-        + "Content-Type: text/plain; charset=utf-8\r\n"
-        + "Content-Length: 4\r\n"
-        + "\r\n"
-        + "okay\r\n"
-        + "--AaB03x\r\n"
-        + "Content-Disposition: form-data; name=\"field with %22\"\r\n"
-        + "Content-Length: 1\r\n"
-        + "\r\n"
-        + "\"\r\n"
-        + "--AaB03x\r\n"
-        + "Content-Disposition: form-data; name=\"field with %22\"\r\n"
-        + "Content-Length: 3\r\n"
-        + "\r\n"
-        + "%22\r\n"
-        + "--AaB03x\r\n"
-        + "Content-Disposition: form-data; name=\"field with \u007e\"\r\n"
-        + "Content-Length: 5\r\n"
-        + "\r\n"
-        + "Alpha\r\n"
-        + "--AaB03x--\r\n";
-
-    MultipartBody body = new MultipartBody.Builder("AaB03x")
-        .setType(MultipartBody.FORM)
-        .addFormDataPart("field with spaces", "filename with spaces.txt",
-            RequestBody.create("okay", MediaType.get("text/plain; charset=utf-8")))
-        .addFormDataPart("field with \"", "\"")
-        .addFormDataPart("field with %22", "%22")
-        .addFormDataPart("field with \u007e", "Alpha")
-        .build();
-
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    assertThat(buffer.readUtf8()).isEqualTo(expected);
-  }
-
-  @Test public void streamingPartHasNoLength() throws Exception {
-    class StreamingBody extends RequestBody {
-      private final String body;
-
-      StreamingBody(String body) {
-        this.body = body;
-      }
-
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.writeUtf8(body);
-      }
-    }
-
-    String expected = ""
-        + "--123\r\n"
-        + "Content-Length: 5\r\n"
-        + "\r\n"
-        + "Quick\r\n"
-        + "--123\r\n"
-        + "\r\n"
-        + "Brown\r\n"
-        + "--123\r\n"
-        + "Content-Length: 3\r\n"
-        + "\r\n"
-        + "Fox\r\n"
-        + "--123--\r\n";
-
-    MultipartBody body = new MultipartBody.Builder("123")
-        .addPart(RequestBody.create("Quick", null))
-        .addPart(new StreamingBody("Brown"))
-        .addPart(RequestBody.create("Fox", null))
-        .build();
-
-    assertThat(body.boundary()).isEqualTo("123");
-    assertThat(body.type()).isEqualTo(MultipartBody.MIXED);
-    assertThat(body.contentType().toString()).isEqualTo("multipart/mixed; boundary=123");
-    assertThat(body.parts().size()).isEqualTo(3);
-    assertThat(body.contentLength()).isEqualTo(-1);
-
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    assertThat(buffer.readUtf8()).isEqualTo(expected);
-  }
-
-  @Test public void contentTypeHeaderIsForbidden() throws Exception {
-    MultipartBody.Builder multipart = new MultipartBody.Builder();
-    try {
-      multipart.addPart(Headers.of("Content-Type", "text/plain"),
-          RequestBody.create("Hello, World!", null));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void contentLengthHeaderIsForbidden() throws Exception {
-    MultipartBody.Builder multipart = new MultipartBody.Builder();
-    try {
-      multipart.addPart(Headers.of("Content-Length", "13"),
-          RequestBody.create("Hello, World!", null));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void partAccessors() throws IOException {
-    MultipartBody body = new MultipartBody.Builder()
-        .addPart(Headers.of("Foo", "Bar"), RequestBody.create("Baz", null))
-        .build();
-    assertThat(body.parts().size()).isEqualTo(1);
-
-    Buffer part1Buffer = new Buffer();
-    MultipartBody.Part part1 = body.part(0);
-    part1.body().writeTo(part1Buffer);
-    assertThat(part1.headers()).isEqualTo(Headers.of("Foo", "Bar"));
-    assertThat(part1Buffer.readUtf8()).isEqualTo("Baz");
-  }
-
-  @Test public void nonAsciiFilename() throws Exception {
-    String expected = ""
-        + "--AaB03x\r\n"
-        + "Content-Disposition: form-data; name=\"attachment\"; filename=\"resum.pdf\"\r\n"
-        + "Content-Type: application/pdf; charset=utf-8\r\n"
-        + "Content-Length: 17\r\n"
-        + "\r\n"
-        + "Jesses Resum\r\n"
-        + "--AaB03x--\r\n";
-
-    MultipartBody body = new MultipartBody.Builder("AaB03x")
-        .setType(MultipartBody.FORM)
-        .addFormDataPart("attachment", "resum.pdf",
-            RequestBody.create("Jesses Resum", MediaType.parse("application/pdf")))
-        .build();
-
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    assertThat(buffer.readUtf8()).isEqualTo(expected);
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/OkHttpClientTest.java b/okhttp/src/test/java/okhttp3/OkHttpClientTest.java
deleted file mode 100644
index 421cdf12e8..0000000000
--- a/okhttp/src/test/java/okhttp3/OkHttpClientTest.java
+++ /dev/null
@@ -1,304 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.CookieHandler;
-import java.net.CookieManager;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.ResponseCache;
-import java.util.AbstractList;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.internal.proxy.NullProxySelector;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import org.junit.After;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static java.util.Arrays.asList;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
-public final class OkHttpClientTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  private static final ProxySelector DEFAULT_PROXY_SELECTOR = ProxySelector.getDefault();
-  private static final CookieHandler DEFAULT_COOKIE_HANDLER = CookieManager.getDefault();
-  private static final ResponseCache DEFAULT_RESPONSE_CACHE = ResponseCache.getDefault();
-
-  @After public void tearDown() throws Exception {
-    ProxySelector.setDefault(DEFAULT_PROXY_SELECTOR);
-    CookieManager.setDefault(DEFAULT_COOKIE_HANDLER);
-    ResponseCache.setDefault(DEFAULT_RESPONSE_CACHE);
-  }
-
-  @Test public void durationDefaults() {
-    OkHttpClient client = clientTestRule.newClient();
-    assertThat(client.callTimeoutMillis()).isEqualTo(0);
-    assertThat(client.connectTimeoutMillis()).isEqualTo(10_000);
-    assertThat(client.readTimeoutMillis()).isEqualTo(10_000);
-    assertThat(client.writeTimeoutMillis()).isEqualTo(10_000);
-    assertThat(client.pingIntervalMillis()).isEqualTo(0);
-  }
-
-  @Test public void timeoutValidRange() {
-    OkHttpClient.Builder builder = new OkHttpClient.Builder();
-    try {
-      builder.callTimeout(1, TimeUnit.NANOSECONDS);
-    } catch (IllegalArgumentException ignored) {
-    }
-    try {
-      builder.connectTimeout(1, TimeUnit.NANOSECONDS);
-    } catch (IllegalArgumentException ignored) {
-    }
-    try {
-      builder.writeTimeout(1, TimeUnit.NANOSECONDS);
-    } catch (IllegalArgumentException ignored) {
-    }
-    try {
-      builder.readTimeout(1, TimeUnit.NANOSECONDS);
-    } catch (IllegalArgumentException ignored) {
-    }
-    try {
-      builder.callTimeout(365, TimeUnit.DAYS);
-    } catch (IllegalArgumentException ignored) {
-    }
-    try {
-      builder.connectTimeout(365, TimeUnit.DAYS);
-    } catch (IllegalArgumentException ignored) {
-    }
-    try {
-      builder.writeTimeout(365, TimeUnit.DAYS);
-    } catch (IllegalArgumentException ignored) {
-    }
-    try {
-      builder.readTimeout(365, TimeUnit.DAYS);
-    } catch (IllegalArgumentException ignored) {
-    }
-  }
-
-  @Test public void clonedInterceptorsListsAreIndependent() throws Exception {
-    Interceptor interceptor = chain -> chain.proceed(chain.request());
-    OkHttpClient original = clientTestRule.newClient();
-    original.newBuilder()
-        .addInterceptor(interceptor)
-        .addNetworkInterceptor(interceptor)
-        .build();
-    assertThat(original.interceptors().size()).isEqualTo(0);
-    assertThat(original.networkInterceptors().size()).isEqualTo(0);
-  }
-
-  /**
-   * When copying the client, stateful things like the connection pool are shared across all
-   * clients.
-   */
-  @Test public void cloneSharesStatefulInstances() throws Exception {
-    OkHttpClient client = clientTestRule.newClient();
-
-    // Values should be non-null.
-    OkHttpClient a = client.newBuilder().build();
-    assertThat(a.dispatcher()).isNotNull();
-    assertThat(a.connectionPool()).isNotNull();
-    assertThat(a.sslSocketFactory()).isNotNull();
-    assertThat(a.x509TrustManager()).isNotNull();
-
-    // Multiple clients share the instances.
-    OkHttpClient b = client.newBuilder().build();
-    assertThat(b.dispatcher()).isSameAs(a.dispatcher());
-    assertThat(b.connectionPool()).isSameAs(a.connectionPool());
-    assertThat(b.sslSocketFactory()).isSameAs(a.sslSocketFactory());
-    assertThat(b.x509TrustManager()).isSameAs(a.x509TrustManager());
-  }
-
-  @Test public void setProtocolsRejectsHttp10() throws Exception {
-    OkHttpClient.Builder builder = new OkHttpClient.Builder();
-    try {
-      builder.protocols(asList(Protocol.HTTP_1_0, Protocol.HTTP_1_1));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void certificatePinnerEquality() {
-    OkHttpClient clientA = clientTestRule.newClient();
-    OkHttpClient clientB = clientTestRule.newClient();
-    assertThat(clientB.certificatePinner()).isEqualTo(clientA.certificatePinner());
-  }
-
-  @Test public void nullInterceptor() {
-    OkHttpClient.Builder builder = new OkHttpClient.Builder();
-    try {
-      builder.addInterceptor(null);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void nullNetworkInterceptor() {
-    OkHttpClient.Builder builder = new OkHttpClient.Builder();
-    try {
-      builder.addNetworkInterceptor(null);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void nullInterceptorInList() {
-    OkHttpClient.Builder builder = new OkHttpClient.Builder();
-    builder.interceptors().add(null);
-    try {
-      builder.build();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertThat(expected.getMessage()).isEqualTo("Null interceptor: [null]");
-    }
-  }
-
-  @Test public void nullNetworkInterceptorInList() {
-    OkHttpClient.Builder builder = new OkHttpClient.Builder();
-    builder.networkInterceptors().add(null);
-    try {
-      builder.build();
-      fail();
-    } catch (IllegalStateException expected) {
-      assertThat(expected.getMessage()).isEqualTo("Null network interceptor: [null]");
-    }
-  }
-
-  @Test public void testH2PriorKnowledgeOkHttpClientConstructionFallback() {
-    try {
-      new OkHttpClient.Builder()
-          .protocols(asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_1_1));
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          ("protocols containing h2_prior_knowledge cannot use other protocols: "
-            + "[h2_prior_knowledge, http/1.1]"));
-    }
-  }
-
-  @Test public void testH2PriorKnowledgeOkHttpClientConstructionDuplicates() {
-    try {
-      new OkHttpClient.Builder()
-          .protocols(asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.H2_PRIOR_KNOWLEDGE));
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          ("protocols containing h2_prior_knowledge cannot use other protocols: "
-            + "[h2_prior_knowledge, h2_prior_knowledge]"));
-    }
-  }
-
-  @Test public void testH2PriorKnowledgeOkHttpClientConstructionSuccess() {
-    OkHttpClient okHttpClient = new OkHttpClient.Builder()
-        .protocols(asList(Protocol.H2_PRIOR_KNOWLEDGE))
-        .build();
-    assertThat(okHttpClient.protocols().size()).isEqualTo(1);
-    assertThat(okHttpClient.protocols().get(0)).isEqualTo(Protocol.H2_PRIOR_KNOWLEDGE);
-  }
-
-  @Test public void nullDefaultProxySelector() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    ProxySelector.setDefault(null);
-
-    OkHttpClient client = clientTestRule.newClient();
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("abc");
-  }
-
-  @Test public void sslSocketFactorySetAsSocketFactory() throws Exception {
-    OkHttpClient.Builder builder = new OkHttpClient.Builder();
-    try {
-      builder.socketFactory(SSLSocketFactory.getDefault());
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void noSslSocketFactoryConfigured() throws Exception {
-    OkHttpClient client = new OkHttpClient.Builder()
-        .connectionSpecs(asList(ConnectionSpec.CLEARTEXT))
-        .build();
-    try {
-      client.sslSocketFactory();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void nullHostileProtocolList() {
-    List<Protocol> nullHostileProtocols = new AbstractList<Protocol>() {
-      @Override public boolean contains(Object o) {
-        if (o == null) throw new NullPointerException();
-        return super.contains(o);
-      }
-
-      @Override public int indexOf(Object o) {
-        if (o == null) throw new NullPointerException();
-        return super.indexOf(o);
-      }
-
-      @Override public Protocol get(int index) {
-        if (index != 0) throw new IndexOutOfBoundsException();
-        return Protocol.HTTP_1_1;
-      }
-
-      @Override public int size() {
-        return 1;
-      }
-    };
-
-    OkHttpClient client = new OkHttpClient.Builder()
-        .protocols(nullHostileProtocols)
-        .build();
-    assertEquals(asList(Protocol.HTTP_1_1), client.protocols());
-  }
-
-  @Test public void nullProtocolInList() {
-    List<Protocol> protocols = new ArrayList<>();
-    protocols.add(Protocol.HTTP_1_1);
-    protocols.add(null);
-    try {
-      new OkHttpClient.Builder().protocols(protocols);
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo("protocols must not contain null");
-    }
-  }
-
-  @Test public void testProxyDefaults() {
-    OkHttpClient client = new OkHttpClient.Builder().build();
-    assertThat(client.proxy()).isNull();
-    assertThat(client.proxySelector()).isNotInstanceOf(NullProxySelector.class);
-
-    client = new OkHttpClient.Builder().proxy(Proxy.NO_PROXY).build();
-    assertThat(client.proxy()).isSameAs(Proxy.NO_PROXY);
-    assertThat(client.proxySelector()).isInstanceOf(NullProxySelector.class);
-
-    client = new OkHttpClient.Builder().proxySelector(new FakeProxySelector()).build();
-    assertThat(client.proxy()).isNull();
-    assertThat(client.proxySelector()).isInstanceOf(FakeProxySelector.class);
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/OpenJSSETest.kt b/okhttp/src/test/java/okhttp3/OpenJSSETest.kt
deleted file mode 100644
index 8b4ac73922..0000000000
--- a/okhttp/src/test/java/okhttp3/OpenJSSETest.kt
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3
-
-import okhttp3.TestUtil.assumeNetwork
-import okhttp3.internal.platform.OpenJSSEPlatform
-import okhttp3.mockwebserver.MockResponse
-import okhttp3.mockwebserver.MockWebServer
-import okhttp3.testing.PlatformRule
-import okhttp3.tls.HandshakeCertificates
-import okhttp3.tls.HeldCertificate
-import org.assertj.core.api.Assertions.assertThat
-import org.junit.Assert.assertEquals
-import org.junit.Before
-import org.junit.Ignore
-import org.junit.Rule
-import org.junit.Test
-import org.openjsse.sun.security.ssl.SSLSocketFactoryImpl
-import org.openjsse.sun.security.ssl.SSLSocketImpl
-import java.net.InetAddress
-
-class OpenJSSETest {
-  @JvmField @Rule var platform = PlatformRule()
-  @JvmField @Rule val clientTestRule = OkHttpClientTestRule()
-  @JvmField @Rule val server = MockWebServer()
-  var client = clientTestRule.newClient()
-
-  @Before
-  fun setUp() {
-    platform.assumeOpenJSSE()
-  }
-
-  @Test
-  fun testTlsv13Works() {
-    enableTls()
-
-    server.enqueue(MockResponse().setBody("abc"))
-
-    val request = Request.Builder().url(server.url("/")).build()
-
-    val response = client.newCall(request).execute()
-
-    response.use {
-      assertEquals(200, response.code)
-      assertEquals(TlsVersion.TLS_1_3, response.handshake?.tlsVersion)
-      assertEquals(Protocol.HTTP_2, response.protocol)
-
-      assertThat(response.exchange?.connection()?.socket()).isInstanceOf(SSLSocketImpl::class.java)
-    }
-  }
-
-  @Test
-  fun testSupportedProtocols() {
-    val factory = SSLSocketFactoryImpl()
-    val s = factory.createSocket() as SSLSocketImpl
-
-    assertEquals(listOf("TLSv1.3", "TLSv1.2", "TLSv1.1", "TLSv1"), s.enabledProtocols.toList())
-  }
-
-  @Test
-  @Ignore
-  fun testMozilla() {
-    assumeNetwork()
-
-    val request = Request.Builder().url("https://mozilla.org/robots.txt").build()
-
-    client.newCall(request).execute().use {
-      assertThat(it.protocol).isEqualTo(Protocol.HTTP_2)
-      assertThat(it.handshake!!.tlsVersion).isEqualTo(TlsVersion.TLS_1_3)
-    }
-  }
-
-  @Test
-  fun testBuildIfSupported() {
-    val actual = OpenJSSEPlatform.buildIfSupported()
-    assertThat(actual).isNotNull
-  }
-
-  private fun enableTls() {
-    // Generate a self-signed cert for the server to serve and the client to trust.
-    // can't use TlsUtil.localhost with a non OpenJSSE trust manager
-    val heldCertificate = HeldCertificate.Builder()
-        .commonName("localhost")
-        .addSubjectAlternativeName(InetAddress.getByName("localhost").canonicalHostName)
-        .build()
-    val handshakeCertificates = HandshakeCertificates.Builder()
-        .heldCertificate(heldCertificate)
-        .addTrustedCertificate(heldCertificate.certificate)
-        .build()
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager)
-        .build()
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false)
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/ProtocolTest.java b/okhttp/src/test/java/okhttp3/ProtocolTest.java
deleted file mode 100644
index ffced6eacf..0000000000
--- a/okhttp/src/test/java/okhttp3/ProtocolTest.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class ProtocolTest {
-  @Test
-  public void testGetKnown() throws IOException {
-    assertThat(Protocol.get("http/1.0")).isEqualTo(Protocol.HTTP_1_0);
-    assertThat(Protocol.get("http/1.1")).isEqualTo(Protocol.HTTP_1_1);
-    assertThat(Protocol.get("spdy/3.1")).isEqualTo(Protocol.SPDY_3);
-    assertThat(Protocol.get("h2")).isEqualTo(Protocol.HTTP_2);
-    assertThat(Protocol.get("h2_prior_knowledge")).isEqualTo(Protocol.H2_PRIOR_KNOWLEDGE);
-    assertThat(Protocol.get("quic")).isEqualTo(Protocol.QUIC);
-  }
-
-  @Test(expected = IOException.class)
-  public void testGetUnknown() throws IOException {
-    Protocol.get("tcp");
-  }
-
-  @Test
-  public void testToString() throws IOException {
-    assertThat(Protocol.HTTP_1_0.toString()).isEqualTo("http/1.0");
-    assertThat(Protocol.HTTP_1_1.toString()).isEqualTo("http/1.1");
-    assertThat(Protocol.SPDY_3.toString()).isEqualTo("spdy/3.1");
-    assertThat(Protocol.HTTP_2.toString()).isEqualTo("h2");
-    assertThat(Protocol.H2_PRIOR_KNOWLEDGE.toString()).isEqualTo("h2_prior_knowledge");
-    assertThat(Protocol.QUIC.toString()).isEqualTo("quic");
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/PublicInternalApiTest.java b/okhttp/src/test/java/okhttp3/PublicInternalApiTest.java
deleted file mode 100644
index 7421931867..0000000000
--- a/okhttp/src/test/java/okhttp3/PublicInternalApiTest.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import okhttp3.internal.http.HttpHeaders;
-import okhttp3.internal.http.HttpMethod;
-import org.junit.Test;
-
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-@SuppressWarnings("ALL") public class PublicInternalApiTest {
-  @Test public void permitsRequestBody() {
-    assertTrue(HttpMethod.permitsRequestBody("POST"));
-    assertFalse(HttpMethod.permitsRequestBody("GET"));
-  }
-
-  @Test public void requiresRequestBody() {
-    assertTrue(HttpMethod.requiresRequestBody("PUT"));
-    assertFalse(HttpMethod.requiresRequestBody("GET"));
-  }
-
-  @Test public void hasBody() {
-    Request request = new Request.Builder().url("http://example.com").build();
-    Response response = new Response.Builder().code(200)
-        .message("OK")
-        .request(request)
-        .protocol(Protocol.HTTP_2)
-        .build();
-    assertTrue(HttpHeaders.hasBody(response));
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/RecordedResponse.java b/okhttp/src/test/java/okhttp3/RecordedResponse.java
deleted file mode 100644
index a33ec8dfb1..0000000000
--- a/okhttp/src/test/java/okhttp3/RecordedResponse.java
+++ /dev/null
@@ -1,197 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Date;
-import javax.annotation.Nullable;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-/**
- * A received response or failure recorded by the response recorder.
- */
-public final class RecordedResponse {
-  public final Request request;
-  public final @Nullable Response response;
-  public final @Nullable WebSocket webSocket;
-  public final @Nullable String body;
-  public final @Nullable IOException failure;
-
-  public RecordedResponse(Request request, @Nullable Response response,
-      @Nullable WebSocket webSocket, @Nullable String body, @Nullable IOException failure) {
-    this.request = request;
-    this.response = response;
-    this.webSocket = webSocket;
-    this.body = body;
-    this.failure = failure;
-  }
-
-  public RecordedResponse assertRequestUrl(HttpUrl url) {
-    assertThat(request.url()).isEqualTo(url);
-    return this;
-  }
-
-  public RecordedResponse assertRequestMethod(String method) {
-    assertThat(request.method()).isEqualTo(method);
-    return this;
-  }
-
-  public RecordedResponse assertRequestHeader(String name, String... values) {
-    assertThat(request.headers(name)).containsExactly(values);
-    return this;
-  }
-
-  public RecordedResponse assertCode(int expectedCode) {
-    assertThat(response.code()).isEqualTo(expectedCode);
-    return this;
-  }
-
-  public RecordedResponse assertSuccessful() {
-    assertThat(failure).isNull();
-    assertThat(response.isSuccessful()).isTrue();
-    return this;
-  }
-
-  public RecordedResponse assertNotSuccessful() {
-    assertThat(response.isSuccessful()).isFalse();
-    return this;
-  }
-
-  public RecordedResponse assertHeader(String name, String... values) {
-    assertThat(response.headers(name)).containsExactly(values);
-    return this;
-  }
-
-  public RecordedResponse assertHeaders(Headers headers) {
-    assertThat(response.headers()).isEqualTo(headers);
-    return this;
-  }
-
-  public RecordedResponse assertBody(String expectedBody) {
-    assertThat(body).isEqualTo(expectedBody);
-    return this;
-  }
-
-  public RecordedResponse assertHandshake() {
-    Handshake handshake = response.handshake();
-    assertThat(handshake.tlsVersion()).isNotNull();
-    assertThat(handshake.cipherSuite()).isNotNull();
-    assertThat(handshake.peerPrincipal()).isNotNull();
-    assertThat(handshake.peerCertificates().size()).isEqualTo(1);
-    assertThat(handshake.localPrincipal()).isNull();
-    assertThat(handshake.localCertificates().size()).isEqualTo(0);
-    return this;
-  }
-
-  /**
-   * Asserts that the current response was redirected and returns the prior response.
-   */
-  public RecordedResponse priorResponse() {
-    Response priorResponse = response.priorResponse();
-    assertThat(priorResponse).isNotNull();
-    assertThat(priorResponse.body()).isNull();
-    return new RecordedResponse(priorResponse.request(), priorResponse, null, null, null);
-  }
-
-  /**
-   * Asserts that the current response used the network and returns the network response.
-   */
-  public RecordedResponse networkResponse() {
-    Response networkResponse = response.networkResponse();
-    assertThat(networkResponse).isNotNull();
-    assertThat(networkResponse.body()).isNull();
-    return new RecordedResponse(networkResponse.request(), networkResponse, null, null, null);
-  }
-
-  /** Asserts that the current response didn't use the network. */
-  public RecordedResponse assertNoNetworkResponse() {
-    assertThat(response.networkResponse()).isNull();
-    return this;
-  }
-
-  /** Asserts that the current response didn't use the cache. */
-  public RecordedResponse assertNoCacheResponse() {
-    assertThat(response.cacheResponse()).isNull();
-    return this;
-  }
-
-  /**
-   * Asserts that the current response used the cache and returns the cache response.
-   */
-  public RecordedResponse cacheResponse() {
-    Response cacheResponse = response.cacheResponse();
-    assertThat(cacheResponse).isNotNull();
-    assertThat(cacheResponse.body()).isNull();
-    return new RecordedResponse(cacheResponse.request(), cacheResponse, null, null, null);
-  }
-
-  public RecordedResponse assertFailure(Class<?>... allowedExceptionTypes) {
-    boolean found = false;
-    for (Class expectedClass : allowedExceptionTypes) {
-      if (expectedClass.isInstance(failure)) {
-        found = true;
-        break;
-      }
-    }
-    assertThat(found)
-        .overridingErrorMessage("Expected exception type among "
-            + Arrays.toString(allowedExceptionTypes) + ", got " + failure)
-        .isTrue();
-    return this;
-  }
-
-  public RecordedResponse assertFailure(String... messages) {
-    assertThat(failure).overridingErrorMessage("No failure found").isNotNull();
-    assertThat(messages).contains(failure.getMessage());
-    return this;
-  }
-
-  public RecordedResponse assertFailureMatches(String... patterns) {
-    assertThat(failure).isNotNull();
-    for (String pattern : patterns) {
-      if (failure.getMessage().matches(pattern)) return this;
-    }
-    throw new AssertionError(failure.getMessage());
-  }
-
-  public RecordedResponse assertSentRequestAtMillis(long minimum, long maximum) {
-    assertDateInRange(minimum, response.sentRequestAtMillis(), maximum);
-    return this;
-  }
-
-  public RecordedResponse assertReceivedResponseAtMillis(long minimum, long maximum) {
-    assertDateInRange(minimum, response.receivedResponseAtMillis(), maximum);
-    return this;
-  }
-
-  private void assertDateInRange(long minimum, long actual, long maximum) {
-    assertThat(actual)
-        .overridingErrorMessage("%s <= %s <= %s", format(minimum), format(actual), format(maximum))
-        .isBetween(minimum, maximum);
-
-  }
-
-  private String format(long time) {
-    return new SimpleDateFormat("HH:mm:ss.SSS").format(new Date(time));
-  }
-
-  public String getBody() {
-    return body;
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/RecordingCallback.java b/okhttp/src/test/java/okhttp3/RecordingCallback.java
deleted file mode 100644
index 56a1d7e003..0000000000
--- a/okhttp/src/test/java/okhttp3/RecordingCallback.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-
-/**
- * Records received HTTP responses so they can be later retrieved by tests.
- */
-public class RecordingCallback implements Callback {
-  public static final long TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(10);
-
-  private final List<RecordedResponse> responses = new ArrayList<>();
-
-  @Override public synchronized void onFailure(Call call, IOException e) {
-    responses.add(new RecordedResponse(call.request(), null, null, null, e));
-    notifyAll();
-  }
-
-  @Override public synchronized void onResponse(Call call, Response response) throws IOException {
-    String body = response.body().string();
-    responses.add(new RecordedResponse(call.request(), response, null, body, null));
-    notifyAll();
-  }
-
-  /**
-   * Returns the recorded response triggered by {@code request}. Throws if the response isn't
-   * enqueued before the timeout.
-   */
-  public synchronized RecordedResponse await(HttpUrl url) throws Exception {
-    long timeoutMillis = TimeUnit.NANOSECONDS.toMillis(System.nanoTime()) + TIMEOUT_MILLIS;
-    while (true) {
-      for (Iterator<RecordedResponse> i = responses.iterator(); i.hasNext(); ) {
-        RecordedResponse recordedResponse = i.next();
-        if (recordedResponse.request.url().equals(url)) {
-          i.remove();
-          return recordedResponse;
-        }
-      }
-
-      long nowMillis = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());
-      if (nowMillis >= timeoutMillis) break;
-      wait(timeoutMillis - nowMillis);
-    }
-
-    throw new AssertionError("Timed out waiting for response to " + url);
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/RecordingExecutor.kt b/okhttp/src/test/java/okhttp3/RecordingExecutor.kt
deleted file mode 100644
index 3b57f15640..0000000000
--- a/okhttp/src/test/java/okhttp3/RecordingExecutor.kt
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3
-
-import org.assertj.core.api.Assertions.assertThat
-import java.util.concurrent.AbstractExecutorService
-import java.util.concurrent.RejectedExecutionException
-import java.util.concurrent.TimeUnit
-
-internal class RecordingExecutor(
-  private val dispatcherTest: DispatcherTest
-) : AbstractExecutorService() {
-  private var shutdown: Boolean = false
-  private val calls = mutableListOf<RealCall.AsyncCall>()
-
-  override fun execute(command: Runnable) {
-    if (shutdown) throw RejectedExecutionException()
-    calls.add(command as RealCall.AsyncCall)
-  }
-
-  fun assertJobs(vararg expectedUrls: String) {
-    val actualUrls = calls.map { it.request().url.toString() }
-    assertThat(actualUrls).containsExactly(*expectedUrls)
-  }
-
-  fun finishJob(url: String) {
-    val i = calls.iterator()
-    while (i.hasNext()) {
-      val call = i.next()
-      if (call.request().url.toString() == url) {
-        i.remove()
-        dispatcherTest.dispatcher.finished(call)
-        return
-      }
-    }
-    throw AssertionError("No such job: $url")
-  }
-
-  override fun shutdown() {
-    shutdown = true
-  }
-
-  override fun shutdownNow(): List<Runnable> {
-    throw UnsupportedOperationException()
-  }
-
-  override fun isShutdown(): Boolean {
-    throw UnsupportedOperationException()
-  }
-
-  override fun isTerminated(): Boolean {
-    throw UnsupportedOperationException()
-  }
-
-  override fun awaitTermination(timeout: Long, unit: TimeUnit): Boolean {
-    throw UnsupportedOperationException()
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/RecordingWebSocketListener.java b/okhttp/src/test/java/okhttp3/RecordingWebSocketListener.java
deleted file mode 100644
index 45a13c4786..0000000000
--- a/okhttp/src/test/java/okhttp3/RecordingWebSocketListener.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import javax.annotation.Nullable;
-import okio.ByteString;
-
-public final class RecordingWebSocketListener extends WebSocketListener {
-  @Override public void onOpen(WebSocket webSocket, Response response) {
-    // TODO
-  }
-
-  @Override public void onMessage(WebSocket webSocket, String text) {
-    // TODO
-  }
-
-  @Override public void onMessage(WebSocket webSocket, ByteString bytes) {
-    // TODO
-  }
-
-  @Override public void onClosing(WebSocket webSocket, int code, String reason) {
-    // TODO
-  }
-
-  @Override public void onClosed(WebSocket webSocket, int code, String reason) {
-    // TODO
-  }
-
-  @Override public void onFailure(WebSocket webSocket, Throwable t, @Nullable Response response) {
-    // TODO
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/RequestTest.java b/okhttp/src/test/java/okhttp3/RequestTest.java
deleted file mode 100644
index 9638b3ba40..0000000000
--- a/okhttp/src/test/java/okhttp3/RequestTest.java
+++ /dev/null
@@ -1,371 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.File;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.net.URI;
-import java.util.UUID;
-import okio.Buffer;
-import okio.ByteString;
-import org.junit.Test;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class RequestTest {
-  @Test public void string() throws Exception {
-    MediaType contentType = MediaType.get("text/plain; charset=utf-8");
-    RequestBody body = RequestBody.create("abc".getBytes(UTF_8), contentType);
-    assertThat(body.contentType()).isEqualTo(contentType);
-    assertThat(body.contentLength()).isEqualTo(3);
-    assertThat(bodyToHex(body)).isEqualTo("616263");
-    assertThat(bodyToHex(body)).overridingErrorMessage("Retransmit body").isEqualTo(
-        "616263");
-  }
-
-  @Test public void stringWithDefaultCharsetAdded() throws Exception {
-    MediaType contentType = MediaType.get("text/plain");
-    RequestBody body = RequestBody.create("\u0800", contentType);
-    assertThat(body.contentType()).isEqualTo(MediaType.get("text/plain; charset=utf-8"));
-    assertThat(body.contentLength()).isEqualTo(3);
-    assertThat(bodyToHex(body)).isEqualTo("e0a080");
-  }
-
-  @Test public void stringWithNonDefaultCharsetSpecified() throws Exception {
-    MediaType contentType = MediaType.get("text/plain; charset=utf-16be");
-    RequestBody body = RequestBody.create("\u0800", contentType);
-    assertThat(body.contentType()).isEqualTo(contentType);
-    assertThat(body.contentLength()).isEqualTo(2);
-    assertThat(bodyToHex(body)).isEqualTo("0800");
-  }
-
-  @Test public void byteArray() throws Exception {
-    MediaType contentType = MediaType.get("text/plain");
-    RequestBody body = RequestBody.create("abc".getBytes(UTF_8), contentType);
-    assertThat(body.contentType()).isEqualTo(contentType);
-    assertThat(body.contentLength()).isEqualTo(3);
-    assertThat(bodyToHex(body)).isEqualTo("616263");
-    assertThat(bodyToHex(body)).overridingErrorMessage("Retransmit body").isEqualTo(
-        "616263");
-  }
-
-  @Test public void byteArrayRange() throws Exception {
-    MediaType contentType = MediaType.get("text/plain");
-    RequestBody body = RequestBody.create(".abcd".getBytes(UTF_8), contentType, 1, 3);
-    assertThat(body.contentType()).isEqualTo(contentType);
-    assertThat(body.contentLength()).isEqualTo(3);
-    assertThat(bodyToHex(body)).isEqualTo("616263");
-    assertThat(bodyToHex(body)).overridingErrorMessage("Retransmit body").isEqualTo(
-        "616263");
-  }
-
-  @Test public void byteString() throws Exception {
-    MediaType contentType = MediaType.get("text/plain");
-    RequestBody body = RequestBody.create(ByteString.encodeUtf8("Hello"), contentType);
-    assertThat(body.contentType()).isEqualTo(contentType);
-    assertThat(body.contentLength()).isEqualTo(5);
-    assertThat(bodyToHex(body)).isEqualTo("48656c6c6f");
-    assertThat(bodyToHex(body)).overridingErrorMessage("Retransmit body").isEqualTo(
-        "48656c6c6f");
-  }
-
-  @Test public void file() throws Exception {
-    File file = File.createTempFile("RequestTest", "tmp");
-    FileWriter writer = new FileWriter(file);
-    writer.write("abc");
-    writer.close();
-
-    MediaType contentType = MediaType.get("text/plain");
-    RequestBody body = RequestBody.create(file, contentType);
-    assertThat(body.contentType()).isEqualTo(contentType);
-    assertThat(body.contentLength()).isEqualTo(3);
-    assertThat(bodyToHex(body)).isEqualTo("616263");
-    assertThat(bodyToHex(body)).overridingErrorMessage("Retransmit body").isEqualTo(
-        "616263");
-  }
-
-  /** Common verbs used for apis such as GitHub, AWS, and Google Cloud. */
-  @Test public void crudVerbs() throws IOException {
-    MediaType contentType = MediaType.get("application/json");
-    RequestBody body = RequestBody.create("{}", contentType);
-
-    Request get = new Request.Builder().url("http://localhost/api").get().build();
-    assertThat(get.method()).isEqualTo("GET");
-    assertThat(get.body()).isNull();
-
-    Request head = new Request.Builder().url("http://localhost/api").head().build();
-    assertThat(head.method()).isEqualTo("HEAD");
-    assertThat(head.body()).isNull();
-
-    Request delete = new Request.Builder().url("http://localhost/api").delete().build();
-    assertThat(delete.method()).isEqualTo("DELETE");
-    assertThat(delete.body().contentLength()).isEqualTo(0L);
-
-    Request post = new Request.Builder().url("http://localhost/api").post(body).build();
-    assertThat(post.method()).isEqualTo("POST");
-    assertThat(post.body()).isEqualTo(body);
-
-    Request put = new Request.Builder().url("http://localhost/api").put(body).build();
-    assertThat(put.method()).isEqualTo("PUT");
-    assertThat(put.body()).isEqualTo(body);
-
-    Request patch = new Request.Builder().url("http://localhost/api").patch(body).build();
-    assertThat(patch.method()).isEqualTo("PATCH");
-    assertThat(patch.body()).isEqualTo(body);
-  }
-
-  @Test public void uninitializedURI() throws Exception {
-    Request request = new Request.Builder().url("http://localhost/api").build();
-    assertThat(request.url().uri()).isEqualTo(new URI("http://localhost/api"));
-    assertThat(request.url()).isEqualTo(HttpUrl.get("http://localhost/api"));
-  }
-
-  @Test public void newBuilderUrlResetsUrl() {
-    Request requestWithoutCache = new Request.Builder().url("http://localhost/api").build();
-    Request builtRequestWithoutCache =
-        requestWithoutCache.newBuilder().url("http://localhost/api/foo").build();
-    assertThat(builtRequestWithoutCache.url()).isEqualTo(
-        HttpUrl.get("http://localhost/api/foo"));
-
-    Request requestWithCache = new Request.Builder().url("http://localhost/api").build();
-    // cache url object
-    requestWithCache.url();
-    Request builtRequestWithCache = requestWithCache.newBuilder().url(
-        "http://localhost/api/foo").build();
-    assertThat(builtRequestWithCache.url()).isEqualTo(
-        HttpUrl.get("http://localhost/api/foo"));
-  }
-
-  @Test public void cacheControl() {
-    Request request = new Request.Builder()
-        .cacheControl(new CacheControl.Builder().noCache().build())
-        .url("https://square.com")
-        .build();
-    assertThat(request.headers("Cache-Control")).containsExactly("no-cache");
-    assertThat(request.cacheControl().noCache()).isTrue();
-  }
-
-  @Test public void emptyCacheControlClearsAllCacheControlHeaders() {
-    Request request = new Request.Builder()
-        .header("Cache-Control", "foo")
-        .cacheControl(new CacheControl.Builder().build())
-        .url("https://square.com")
-        .build();
-    assertThat(request.headers("Cache-Control")).isEmpty();
-  }
-
-  @Test public void headerAcceptsPermittedCharacters() {
-    Request.Builder builder = new Request.Builder();
-    builder.header("AZab09~", "AZab09 ~");
-    builder.addHeader("AZab09~", "AZab09 ~");
-  }
-
-  @Test public void emptyNameForbidden() {
-    Request.Builder builder = new Request.Builder();
-    try {
-      builder.header("", "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      builder.addHeader("", "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void headerForbidsNullArguments() {
-    Request.Builder builder = new Request.Builder();
-    try {
-      builder.header(null, "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      builder.addHeader(null, "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      builder.header("Name", null);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      builder.addHeader("Name", null);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void headerAllowsTabOnlyInValues() {
-    Request.Builder builder = new Request.Builder();
-    builder.header("key", "sample\tvalue");
-    try {
-      builder.header("sample\tkey", "value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void headerForbidsControlCharacters() {
-    assertForbiddenHeader("\u0000");
-    assertForbiddenHeader("\r");
-    assertForbiddenHeader("\n");
-    assertForbiddenHeader("\u001f");
-    assertForbiddenHeader("\u007f");
-    assertForbiddenHeader("\u0080");
-    assertForbiddenHeader("\ud83c\udf69");
-  }
-
-  private void assertForbiddenHeader(String s) {
-    Request.Builder builder = new Request.Builder();
-    try {
-      builder.header(s, "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      builder.addHeader(s, "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      builder.header("Name", s);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      builder.addHeader("Name", s);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void noTag() {
-    Request request = new Request.Builder()
-        .url("https://square.com")
-        .build();
-    assertThat(request.tag()).isNull();
-    assertThat(request.tag(Object.class)).isNull();
-    assertThat(request.tag(UUID.class)).isNull();
-    assertThat(request.tag(String.class)).isNull();
-  }
-
-  @Test public void defaultTag() {
-    UUID tag = UUID.randomUUID();
-    Request request = new Request.Builder()
-        .url("https://square.com")
-        .tag(tag)
-        .build();
-    assertThat(request.tag()).isSameAs(tag);
-    assertThat(request.tag(Object.class)).isSameAs(tag);
-    assertThat(request.tag(UUID.class)).isNull();
-    assertThat(request.tag(String.class)).isNull();
-  }
-
-  @Test public void nullRemovesTag() {
-    Request request = new Request.Builder()
-        .url("https://square.com")
-        .tag("a")
-        .tag(null)
-        .build();
-    assertThat(request.tag()).isNull();
-  }
-
-  @Test public void removeAbsentTag() {
-    Request request = new Request.Builder()
-        .url("https://square.com")
-        .tag(null)
-        .build();
-    assertThat(request.tag()).isNull();
-  }
-
-  @Test public void objectTag() {
-    UUID tag = UUID.randomUUID();
-    Request request = new Request.Builder()
-        .url("https://square.com")
-        .tag(Object.class, tag)
-        .build();
-    assertThat(request.tag()).isSameAs(tag);
-    assertThat(request.tag(Object.class)).isSameAs(tag);
-    assertThat(request.tag(UUID.class)).isNull();
-    assertThat(request.tag(String.class)).isNull();
-  }
-
-  @Test public void typedTag() {
-    UUID uuidTag = UUID.randomUUID();
-    Request request = new Request.Builder()
-        .url("https://square.com")
-        .tag(UUID.class, uuidTag)
-        .build();
-    assertThat(request.tag()).isNull();
-    assertThat(request.tag(Object.class)).isNull();
-    assertThat(request.tag(UUID.class)).isSameAs(uuidTag);
-    assertThat(request.tag(String.class)).isNull();
-  }
-
-  @Test public void replaceOnlyTag() {
-    UUID uuidTag1 = UUID.randomUUID();
-    UUID uuidTag2 = UUID.randomUUID();
-    Request request = new Request.Builder()
-        .url("https://square.com")
-        .tag(UUID.class, uuidTag1)
-        .tag(UUID.class, uuidTag2)
-        .build();
-    assertThat(request.tag(UUID.class)).isSameAs(uuidTag2);
-  }
-
-  @Test public void multipleTags() {
-    UUID uuidTag = UUID.randomUUID();
-    String stringTag = "dilophosaurus";
-    Long longTag = 20170815L;
-    Object objectTag = new Object();
-    Request request = new Request.Builder()
-        .url("https://square.com")
-        .tag(Object.class, objectTag)
-        .tag(UUID.class, uuidTag)
-        .tag(String.class, stringTag)
-        .tag(Long.class, longTag)
-        .build();
-    assertThat(request.tag()).isSameAs(objectTag);
-    assertThat(request.tag(Object.class)).isSameAs(objectTag);
-    assertThat(request.tag(UUID.class)).isSameAs(uuidTag);
-    assertThat(request.tag(String.class)).isSameAs(stringTag);
-    assertThat(request.tag(Long.class)).isSameAs(longTag);
-  }
-
-  /** Confirm that we don't accidentally share the backing map between objects. */
-  @Test public void tagsAreImmutable() {
-    Request.Builder builder = new Request.Builder()
-        .url("https://square.com");
-    Request requestA = builder.tag(String.class, "a").build();
-    Request requestB = builder.tag(String.class, "b").build();
-    Request requestC = requestA.newBuilder().tag(String.class, "c").build();
-    assertThat(requestA.tag(String.class)).isSameAs("a");
-    assertThat(requestB.tag(String.class)).isSameAs("b");
-    assertThat(requestC.tag(String.class)).isSameAs("c");
-  }
-
-  private String bodyToHex(RequestBody body) throws IOException {
-    Buffer buffer = new Buffer();
-    body.writeTo(buffer);
-    return buffer.readByteString().hex();
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/ResponseBodyTest.java b/okhttp/src/test/java/okhttp3/ResponseBodyTest.java
deleted file mode 100644
index 2ff9851268..0000000000
--- a/okhttp/src/test/java/okhttp3/ResponseBodyTest.java
+++ /dev/null
@@ -1,497 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.util.concurrent.atomic.AtomicBoolean;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.ForwardingSource;
-import okio.Okio;
-import org.junit.Test;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class ResponseBodyTest {
-  @Test public void stringEmpty() throws IOException {
-    ResponseBody body = body("");
-    assertThat(body.string()).isEqualTo("");
-  }
-
-  @Test public void stringLooksLikeBomButTooShort() throws IOException {
-    ResponseBody body = body("000048");
-    assertThat(body.string()).isEqualTo("\0\0H");
-  }
-
-  @Test public void stringDefaultsToUtf8() throws IOException {
-    ResponseBody body = body("68656c6c6f");
-    assertThat(body.string()).isEqualTo("hello");
-  }
-
-  @Test public void stringExplicitCharset() throws IOException {
-    ResponseBody body = body("00000068000000650000006c0000006c0000006f", "utf-32be");
-    assertThat(body.string()).isEqualTo("hello");
-  }
-
-  @Test public void stringBomOverridesExplicitCharset() throws IOException {
-    ResponseBody body = body("0000ffff00000068000000650000006c0000006c0000006f", "utf-8");
-    assertThat(body.string()).isEqualTo("hello");
-  }
-
-  @Test public void stringBomUtf8() throws IOException {
-    ResponseBody body = body("efbbbf68656c6c6f");
-    assertThat(body.string()).isEqualTo("hello");
-  }
-
-  @Test public void stringBomUtf16Be() throws IOException {
-    ResponseBody body = body("feff00680065006c006c006f");
-    assertThat(body.string()).isEqualTo("hello");
-  }
-
-  @Test public void stringBomUtf16Le() throws IOException {
-    ResponseBody body = body("fffe680065006c006c006f00");
-    assertThat(body.string()).isEqualTo("hello");
-  }
-
-  @Test public void stringBomUtf32Be() throws IOException {
-    ResponseBody body = body("0000ffff00000068000000650000006c0000006c0000006f");
-    assertThat(body.string()).isEqualTo("hello");
-  }
-
-  @Test public void stringBomUtf32Le() throws IOException {
-    ResponseBody body = body("ffff000068000000650000006c0000006c0000006f000000");
-    assertThat(body.string()).isEqualTo("hello");
-  }
-
-  @Test public void stringClosesUnderlyingSource() throws IOException {
-    final AtomicBoolean closed = new AtomicBoolean();
-    ResponseBody body = new ResponseBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return 5;
-      }
-
-      @Override public BufferedSource source() {
-        Buffer source = new Buffer().writeUtf8("hello");
-        return Okio.buffer(new ForwardingSource(source) {
-          @Override public void close() throws IOException {
-            closed.set(true);
-            super.close();
-          }
-        });
-      }
-    };
-    assertThat(body.string()).isEqualTo("hello");
-    assertThat(closed.get()).isTrue();
-  }
-
-  @Test public void readerEmpty() throws IOException {
-    ResponseBody body = body("");
-    assertThat(exhaust(body.charStream())).isEqualTo("");
-  }
-
-  @Test public void readerLooksLikeBomButTooShort() throws IOException {
-    ResponseBody body = body("000048");
-    assertThat(exhaust(body.charStream())).isEqualTo("\0\0H");
-  }
-
-  @Test public void readerDefaultsToUtf8() throws IOException {
-    ResponseBody body = body("68656c6c6f");
-    assertThat(exhaust(body.charStream())).isEqualTo("hello");
-  }
-
-  @Test public void readerExplicitCharset() throws IOException {
-    ResponseBody body = body("00000068000000650000006c0000006c0000006f", "utf-32be");
-    assertThat(exhaust(body.charStream())).isEqualTo("hello");
-  }
-
-  @Test public void readerBomUtf8() throws IOException {
-    ResponseBody body = body("efbbbf68656c6c6f");
-    assertThat(exhaust(body.charStream())).isEqualTo("hello");
-  }
-
-  @Test public void readerBomUtf16Be() throws IOException {
-    ResponseBody body = body("feff00680065006c006c006f");
-    assertThat(exhaust(body.charStream())).isEqualTo("hello");
-  }
-
-  @Test public void readerBomUtf16Le() throws IOException {
-    ResponseBody body = body("fffe680065006c006c006f00");
-    assertThat(exhaust(body.charStream())).isEqualTo("hello");
-  }
-
-  @Test public void readerBomUtf32Be() throws IOException {
-    ResponseBody body = body("0000ffff00000068000000650000006c0000006c0000006f");
-    assertThat(exhaust(body.charStream())).isEqualTo("hello");
-  }
-
-  @Test public void readerBomUtf32Le() throws IOException {
-    ResponseBody body = body("ffff000068000000650000006c0000006c0000006f000000");
-    assertThat(exhaust(body.charStream())).isEqualTo("hello");
-  }
-
-  @Test public void readerClosedBeforeBomClosesUnderlyingSource() throws IOException {
-    final AtomicBoolean closed = new AtomicBoolean();
-    ResponseBody body = new ResponseBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return 5;
-      }
-
-      @Override public BufferedSource source() {
-        ResponseBody body = body("fffe680065006c006c006f00");
-        return Okio.buffer(new ForwardingSource(body.source()) {
-          @Override public void close() throws IOException {
-            closed.set(true);
-            super.close();
-          }
-        });
-      }
-    };
-    body.charStream().close();
-    assertThat(closed.get()).isTrue();
-  }
-
-  @Test public void readerClosedAfterBomClosesUnderlyingSource() throws IOException {
-    final AtomicBoolean closed = new AtomicBoolean();
-    ResponseBody body = new ResponseBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return 5;
-      }
-
-      @Override public BufferedSource source() {
-        ResponseBody body = body("fffe680065006c006c006f00");
-        return Okio.buffer(new ForwardingSource(body.source()) {
-          @Override public void close() throws IOException {
-            closed.set(true);
-            super.close();
-          }
-        });
-      }
-    };
-    Reader reader = body.charStream();
-    assertThat(reader.read()).isEqualTo('h');
-    reader.close();
-    assertThat(closed.get()).isTrue();
-  }
-
-  @Test public void sourceEmpty() throws IOException {
-    ResponseBody body = body("");
-    BufferedSource source = body.source();
-    assertThat(source.exhausted()).isTrue();
-    assertThat(source.readUtf8()).isEqualTo("");
-  }
-
-  @Test public void sourceSeesBom() throws IOException {
-    ResponseBody body = body("efbbbf68656c6c6f");
-    BufferedSource source = body.source();
-    assertThat((source.readByte() & 0xff)).isEqualTo(0xef);
-    assertThat((source.readByte() & 0xff)).isEqualTo(0xbb);
-    assertThat((source.readByte() & 0xff)).isEqualTo(0xbf);
-    assertThat(source.readUtf8()).isEqualTo("hello");
-  }
-
-  @Test public void sourceClosesUnderlyingSource() throws IOException {
-    final AtomicBoolean closed = new AtomicBoolean();
-    ResponseBody body = new ResponseBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return 5;
-      }
-
-      @Override public BufferedSource source() {
-        Buffer source = new Buffer().writeUtf8("hello");
-        return Okio.buffer(new ForwardingSource(source) {
-          @Override public void close() throws IOException {
-            closed.set(true);
-            super.close();
-          }
-        });
-      }
-    };
-    body.source().close();
-    assertThat(closed.get()).isTrue();
-  }
-
-  @Test public void bytesEmpty() throws IOException {
-    ResponseBody body = body("");
-    assertThat(body.bytes().length).isEqualTo(0);
-  }
-
-  @Test public void bytesSeesBom() throws IOException {
-    ResponseBody body = body("efbbbf68656c6c6f");
-    byte[] bytes = body.bytes();
-    assertThat((bytes[0] & 0xff)).isEqualTo(0xef);
-    assertThat((bytes[1] & 0xff)).isEqualTo(0xbb);
-    assertThat((bytes[2] & 0xff)).isEqualTo(0xbf);
-    assertThat(new String(bytes, 3, 5, UTF_8)).isEqualTo("hello");
-  }
-
-  @Test public void bytesClosesUnderlyingSource() throws IOException {
-    final AtomicBoolean closed = new AtomicBoolean();
-    ResponseBody body = new ResponseBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return 5;
-      }
-
-      @Override public BufferedSource source() {
-        Buffer source = new Buffer().writeUtf8("hello");
-        return Okio.buffer(new ForwardingSource(source) {
-          @Override public void close() throws IOException {
-            closed.set(true);
-            super.close();
-          }
-        });
-      }
-    };
-    assertThat(body.bytes().length).isEqualTo(5);
-    assertThat(closed.get()).isTrue();
-  }
-
-  @Test public void bytesThrowsWhenLengthsDisagree() {
-    ResponseBody body = new ResponseBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return 10;
-      }
-
-      @Override public BufferedSource source() {
-        return new Buffer().writeUtf8("hello");
-      }
-    };
-    try {
-      body.bytes();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "Content-Length (10) and stream length (5) disagree");
-    }
-  }
-
-  @Test public void bytesThrowsMoreThanIntMaxValue() {
-    ResponseBody body = new ResponseBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return Integer.MAX_VALUE + 1L;
-      }
-
-      @Override public BufferedSource source() {
-        throw new AssertionError();
-      }
-    };
-    try {
-      body.bytes();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "Cannot buffer entire body for content length: 2147483648");
-    }
-  }
-
-  @Test public void byteStringEmpty() throws IOException {
-    ResponseBody body = body("");
-    assertThat(body.byteString()).isEqualTo(ByteString.EMPTY);
-  }
-
-  @Test public void byteStringSeesBom() throws IOException {
-    ResponseBody body = body("efbbbf68656c6c6f");
-    ByteString actual = body.byteString();
-    ByteString expected = ByteString.decodeHex("efbbbf68656c6c6f");
-    assertThat(actual).isEqualTo(expected);
-  }
-
-  @Test public void byteStringClosesUnderlyingSource() throws IOException {
-    final AtomicBoolean closed = new AtomicBoolean();
-    ResponseBody body = new ResponseBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return 5;
-      }
-
-      @Override public BufferedSource source() {
-        Buffer source = new Buffer().writeUtf8("hello");
-        return Okio.buffer(new ForwardingSource(source) {
-          @Override public void close() throws IOException {
-            closed.set(true);
-            super.close();
-          }
-        });
-      }
-    };
-    assertThat(body.byteString().size()).isEqualTo(5);
-    assertThat(closed.get()).isTrue();
-  }
-
-  @Test public void byteStringThrowsWhenLengthsDisagree() {
-    ResponseBody body = new ResponseBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return 10;
-      }
-
-      @Override public BufferedSource source() {
-        return new Buffer().writeUtf8("hello");
-      }
-    };
-    try {
-      body.byteString();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "Content-Length (10) and stream length (5) disagree");
-    }
-  }
-
-  @Test public void byteStringThrowsMoreThanIntMaxValue() {
-    ResponseBody body = new ResponseBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return Integer.MAX_VALUE + 1L;
-      }
-
-      @Override public BufferedSource source() {
-        throw new AssertionError();
-      }
-    };
-    try {
-      body.byteString();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "Cannot buffer entire body for content length: 2147483648");
-    }
-  }
-
-  @Test public void byteStreamEmpty() throws IOException {
-    ResponseBody body = body("");
-    InputStream bytes = body.byteStream();
-    assertThat(bytes.read()).isEqualTo(-1);
-  }
-
-  @Test public void byteStreamSeesBom() throws IOException {
-    ResponseBody body = body("efbbbf68656c6c6f");
-    InputStream bytes = body.byteStream();
-    assertThat(bytes.read()).isEqualTo(0xef);
-    assertThat(bytes.read()).isEqualTo(0xbb);
-    assertThat(bytes.read()).isEqualTo(0xbf);
-    assertThat(exhaust(new InputStreamReader(bytes, UTF_8))).isEqualTo("hello");
-  }
-
-  @Test public void byteStreamClosesUnderlyingSource() throws IOException {
-    final AtomicBoolean closed = new AtomicBoolean();
-    ResponseBody body = new ResponseBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return 5;
-      }
-
-      @Override public BufferedSource source() {
-        Buffer source = new Buffer().writeUtf8("hello");
-        return Okio.buffer(new ForwardingSource(source) {
-          @Override public void close() throws IOException {
-            closed.set(true);
-            super.close();
-          }
-        });
-      }
-    };
-    body.byteStream().close();
-    assertThat(closed.get()).isTrue();
-  }
-
-  @Test public void throwingUnderlyingSourceClosesQuietly() throws IOException {
-    ResponseBody body = new ResponseBody() {
-      @Override public MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return 5;
-      }
-
-      @Override public BufferedSource source() {
-        Buffer source = new Buffer().writeUtf8("hello");
-        return Okio.buffer(new ForwardingSource(source) {
-          @Override public void close() throws IOException {
-            throw new IOException("Broken!");
-          }
-        });
-      }
-    };
-    assertThat(body.source().readUtf8()).isEqualTo("hello");
-    body.close();
-  }
-
-  static ResponseBody body(String hex) {
-    return body(hex, null);
-  }
-
-  static ResponseBody body(String hex, String charset) {
-    MediaType mediaType = charset == null ? null : MediaType.get("any/thing; charset=" + charset);
-    return ResponseBody.create(ByteString.decodeHex(hex), mediaType);
-  }
-
-  static String exhaust(Reader reader) throws IOException {
-    StringBuilder builder = new StringBuilder();
-    char[] buf = new char[10];
-    int read;
-    while ((read = reader.read(buf)) != -1) {
-      builder.append(buf, 0, read);
-    }
-    return builder.toString();
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/ResponseTest.java b/okhttp/src/test/java/okhttp3/ResponseTest.java
deleted file mode 100644
index 3fca5712a7..0000000000
--- a/okhttp/src/test/java/okhttp3/ResponseTest.java
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.Okio;
-import okio.Source;
-import okio.Timeout;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatThrownBy;
-import static org.junit.Assert.fail;
-
-public final class ResponseTest {
-  @Test public void peekShorterThanResponse() throws Exception {
-    Response response = newResponse(responseBody("abcdef"));
-    ResponseBody peekedBody = response.peekBody(3);
-    assertThat(peekedBody.string()).isEqualTo("abc");
-    assertThat(response.body().string()).isEqualTo("abcdef");
-  }
-
-  @Test public void peekLongerThanResponse() throws Exception {
-    Response response = newResponse(responseBody("abc"));
-    ResponseBody peekedBody = response.peekBody(6);
-    assertThat(peekedBody.string()).isEqualTo("abc");
-    assertThat(response.body().string()).isEqualTo("abc");
-  }
-
-  @Test public void peekAfterReadingResponse() throws Exception {
-    Response response = newResponse(responseBody("abc"));
-    assertThat(response.body().string()).isEqualTo("abc");
-
-    try {
-      response.peekBody(3);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void eachPeakIsIndependent() throws Exception {
-    Response response = newResponse(responseBody("abcdef"));
-    ResponseBody p1 = response.peekBody(4);
-    ResponseBody p2 = response.peekBody(2);
-    assertThat(response.body().string()).isEqualTo("abcdef");
-    assertThat(p1.string()).isEqualTo("abcd");
-    assertThat(p2.string()).isEqualTo("ab");
-  }
-
-  @Test public void negativeStatusCodeThrowsIllegalStateException() {
-    assertThatThrownBy(() -> newResponse(responseBody("set status code -1"), -1))
-        .isInstanceOf(IllegalStateException.class);
-  }
-
-  @Test public void zeroStatusCodeIsValid() {
-    Response response = newResponse(responseBody("set status code 0"), 0);
-    assertThat(response.code()).isEqualTo(0);
-  }
-
-  /**
-   * Returns a new response body that refuses to be read once it has been closed. This is true of
-   * most {@link BufferedSource} instances, but not of {@link Buffer}.
-   */
-  private ResponseBody responseBody(String content) {
-    final Buffer data = new Buffer().writeUtf8(content);
-
-    Source source = new Source() {
-      boolean closed;
-
-      @Override public void close() throws IOException {
-        closed = true;
-      }
-
-      @Override public long read(Buffer sink, long byteCount) throws IOException {
-        if (closed) throw new IllegalStateException();
-        return data.read(sink, byteCount);
-      }
-
-      @Override public Timeout timeout() {
-        return Timeout.NONE;
-      }
-    };
-
-    return ResponseBody.create(Okio.buffer(source), null, -1);
-  }
-
-  private Response newResponse(ResponseBody responseBody) {
-    return newResponse(responseBody, 200);
-  }
-
-  private Response newResponse(ResponseBody responseBody, int code) {
-    return new Response.Builder()
-        .request(new Request.Builder()
-            .url("https://example.com/")
-            .build())
-        .protocol(Protocol.HTTP_1_1)
-        .code(code)
-        .message("OK")
-        .body(responseBody)
-        .build();
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/SocksProxy.java b/okhttp/src/test/java/okhttp3/SocksProxy.java
deleted file mode 100644
index dd3e932f1d..0000000000
--- a/okhttp/src/test/java/okhttp3/SocksProxy.java
+++ /dev/null
@@ -1,253 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.net.SocketException;
-import java.util.Collections;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.Okio;
-
-import static okhttp3.internal.Util.closeQuietly;
-
-/**
- * A limited implementation of SOCKS Protocol Version 5, intended to be similar to MockWebServer.
- * See <a href="https://www.ietf.org/rfc/rfc1928.txt">RFC 1928</a>.
- */
-public final class SocksProxy {
-  public static final String HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS = "onlyProxyCanResolveMe.org";
-
-  private static final int VERSION_5 = 5;
-  private static final int METHOD_NONE = 0xff;
-  private static final int METHOD_NO_AUTHENTICATION_REQUIRED = 0;
-  private static final int ADDRESS_TYPE_IPV4 = 1;
-  private static final int ADDRESS_TYPE_DOMAIN_NAME = 3;
-  private static final int COMMAND_CONNECT = 1;
-  private static final int REPLY_SUCCEEDED = 0;
-
-  private static final Logger logger = Logger.getLogger(SocksProxy.class.getName());
-
-  private final ExecutorService executor = Executors.newCachedThreadPool(
-      Util.threadFactory("SocksProxy", false));
-
-  private ServerSocket serverSocket;
-  private AtomicInteger connectionCount = new AtomicInteger();
-  private final Set<Socket> openSockets = Collections.newSetFromMap(new ConcurrentHashMap<>());
-
-  public void play() throws IOException {
-    serverSocket = new ServerSocket(0);
-    executor.execute(() -> {
-      String threadName = "SocksProxy " + serverSocket.getLocalPort();
-      Thread.currentThread().setName(threadName);
-      try {
-        while (true) {
-          Socket socket = serverSocket.accept();
-          connectionCount.incrementAndGet();
-          service(socket);
-        }
-      } catch (SocketException e) {
-        logger.info(threadName + " done accepting connections: " + e.getMessage());
-      } catch (IOException e) {
-        logger.log(Level.WARNING, threadName + " failed unexpectedly", e);
-      } finally {
-        for (Socket socket : openSockets) {
-          closeQuietly(socket);
-        }
-        Thread.currentThread().setName("SocksProxy");
-      }
-    });
-  }
-
-  public Proxy proxy() {
-    return new Proxy(Proxy.Type.SOCKS, InetSocketAddress.createUnresolved(
-        "localhost", serverSocket.getLocalPort()));
-  }
-
-  public int connectionCount() {
-    return connectionCount.get();
-  }
-
-  public void shutdown() throws Exception {
-    serverSocket.close();
-    executor.shutdown();
-    if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
-      throw new IOException("Gave up waiting for executor to shut down");
-    }
-  }
-
-  private void service(final Socket from) {
-    executor.execute(() -> {
-      String threadName = "SocksProxy " + from.getRemoteSocketAddress();
-      Thread.currentThread().setName(threadName);
-      try {
-        BufferedSource fromSource = Okio.buffer(Okio.source(from));
-        BufferedSink fromSink = Okio.buffer(Okio.sink(from));
-        hello(fromSource, fromSink);
-        acceptCommand(from.getInetAddress(), fromSource, fromSink);
-        openSockets.add(from);
-      } catch (IOException e) {
-        logger.log(Level.WARNING, threadName + " failed", e);
-        closeQuietly(from);
-      } finally {
-        Thread.currentThread().setName("SocksProxy");
-      }
-    });
-  }
-
-  private void hello(BufferedSource fromSource, BufferedSink fromSink) throws IOException {
-    int version = fromSource.readByte() & 0xff;
-    int methodCount = fromSource.readByte() & 0xff;
-    int selectedMethod = METHOD_NONE;
-
-    if (version != VERSION_5) {
-      throw new ProtocolException("unsupported version: " + version);
-    }
-
-    for (int i = 0; i < methodCount; i++) {
-      int candidateMethod = fromSource.readByte() & 0xff;
-      if (candidateMethod == METHOD_NO_AUTHENTICATION_REQUIRED) {
-        selectedMethod = candidateMethod;
-      }
-    }
-
-    switch (selectedMethod) {
-      case METHOD_NO_AUTHENTICATION_REQUIRED:
-        fromSink.writeByte(VERSION_5);
-        fromSink.writeByte(selectedMethod);
-        fromSink.emit();
-        break;
-
-      default:
-        throw new ProtocolException("unsupported method: " + selectedMethod);
-    }
-  }
-
-  private void acceptCommand(InetAddress fromAddress, BufferedSource fromSource,
-      BufferedSink fromSink) throws IOException {
-    // Read the command.
-    int version = fromSource.readByte() & 0xff;
-    if (version != VERSION_5) throw new ProtocolException("unexpected version: " + version);
-    int command = fromSource.readByte() & 0xff;
-    int reserved = fromSource.readByte() & 0xff;
-    if (reserved != 0) throw new ProtocolException("unexpected reserved: " + reserved);
-
-    int addressType = fromSource.readByte() & 0xff;
-    InetAddress toAddress;
-    switch (addressType) {
-      case ADDRESS_TYPE_IPV4:
-        toAddress = InetAddress.getByAddress(fromSource.readByteArray(4L));
-        break;
-
-      case ADDRESS_TYPE_DOMAIN_NAME:
-        int domainNameLength = fromSource.readByte() & 0xff;
-        String domainName = fromSource.readUtf8(domainNameLength);
-        // Resolve HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS to localhost.
-        toAddress = domainName.equalsIgnoreCase(HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS)
-            ? InetAddress.getByName("localhost")
-            : InetAddress.getByName(domainName);
-        break;
-
-      default:
-        throw new ProtocolException("unsupported address type: " + addressType);
-    }
-
-    int port = fromSource.readShort() & 0xffff;
-
-    switch (command) {
-      case COMMAND_CONNECT:
-        Socket toSocket = new Socket(toAddress, port);
-        byte[] localAddress = toSocket.getLocalAddress().getAddress();
-        if (localAddress.length != 4) {
-          throw new ProtocolException("unexpected address: " + toSocket.getLocalAddress());
-        }
-
-        // Write the reply.
-        fromSink.writeByte(VERSION_5);
-        fromSink.writeByte(REPLY_SUCCEEDED);
-        fromSink.writeByte(0);
-        fromSink.writeByte(ADDRESS_TYPE_IPV4);
-        fromSink.write(localAddress);
-        fromSink.writeShort(toSocket.getLocalPort());
-        fromSink.emit();
-
-        logger.log(Level.INFO, "SocksProxy connected " + fromAddress + " to " + toAddress);
-
-        // Copy sources to sinks in both directions.
-        BufferedSource toSource = Okio.buffer(Okio.source(toSocket));
-        BufferedSink toSink = Okio.buffer(Okio.sink(toSocket));
-        openSockets.add(toSocket);
-
-        transfer(fromAddress, toAddress, fromSource, toSink);
-        transfer(fromAddress, toAddress, toSource, fromSink);
-        break;
-
-      default:
-        throw new ProtocolException("unexpected command: " + command);
-    }
-  }
-
-  private void transfer(final InetAddress fromAddress, final InetAddress toAddress,
-      final BufferedSource source, final BufferedSink sink) {
-    executor.execute(() -> {
-      String threadName = "SocksProxy " + fromAddress + " to " + toAddress;
-      Thread.currentThread().setName(threadName);
-      Buffer buffer = new Buffer();
-      try {
-        while (true) {
-          long byteCount = source.read(buffer, 8192L);
-          if (byteCount == -1L) break;
-          sink.write(buffer, byteCount);
-          sink.emit();
-        }
-      } catch (SocketException e) {
-        logger.info(threadName + " done: " + e.getMessage());
-      } catch (IOException e) {
-        logger.log(Level.WARNING, threadName + " failed", e);
-      }
-
-      try {
-        source.close();
-      } catch (IOException e) {
-        logger.log(Level.WARNING, threadName + " failed", e);
-      }
-
-      try {
-        sink.close();
-      } catch (IOException e) {
-        logger.log(Level.WARNING, threadName + " failed", e);
-      }
-
-      Thread.currentThread().setName("SocksProxy");
-    });
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/SocksProxyTest.java b/okhttp/src/test/java/okhttp3/SocksProxyTest.java
deleted file mode 100644
index 89dd9cbed2..0000000000
--- a/okhttp/src/test/java/okhttp3/SocksProxyTest.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.SocketAddress;
-import java.net.URI;
-import java.util.Collections;
-import java.util.List;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class SocksProxyTest {
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  private final SocksProxy socksProxy = new SocksProxy();
-
-  @Before public void setUp() throws Exception {
-    socksProxy.play();
-  }
-
-  @After public void tearDown() throws Exception {
-    socksProxy.shutdown();
-  }
-
-  @Test public void proxy() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-    server.enqueue(new MockResponse().setBody("def"));
-
-    OkHttpClient client = clientTestRule.newClientBuilder()
-        .proxy(socksProxy.proxy())
-        .build();
-
-    Request request1 = new Request.Builder().url(server.url("/")).build();
-    Response response1 = client.newCall(request1).execute();
-    assertThat(response1.body().string()).isEqualTo("abc");
-
-    Request request2 = new Request.Builder().url(server.url("/")).build();
-    Response response2 = client.newCall(request2).execute();
-    assertThat(response2.body().string()).isEqualTo("def");
-
-    // The HTTP calls should share a single connection.
-    assertThat(socksProxy.connectionCount()).isEqualTo(1);
-  }
-
-  @Test public void proxySelector() throws Exception {
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    ProxySelector proxySelector = new ProxySelector() {
-      @Override public List<Proxy> select(URI uri) {
-        return Collections.singletonList(socksProxy.proxy());
-      }
-
-      @Override public void connectFailed(URI uri, SocketAddress socketAddress, IOException e) {
-        throw new AssertionError();
-      }
-    };
-
-    OkHttpClient client = clientTestRule.newClientBuilder()
-        .proxySelector(proxySelector)
-        .build();
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-    Response response = client.newCall(request).execute();
-    assertThat(response.body().string()).isEqualTo("abc");
-
-    assertThat(socksProxy.connectionCount()).isEqualTo(1);
-  }
-
-  @Test public void checkRemoteDNSResolve() throws Exception {
-    // This testcase will fail if the target is resolved locally instead of through the proxy.
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    OkHttpClient client = clientTestRule.newClientBuilder()
-        .proxy(socksProxy.proxy())
-        .build();
-
-    HttpUrl url = server.url("/")
-        .newBuilder()
-        .host(SocksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS)
-        .build();
-
-    Request request = new Request.Builder().url(url).build();
-    Response response1 = client.newCall(request).execute();
-    assertThat(response1.body().string()).isEqualTo("abc");
-
-    assertThat(socksProxy.connectionCount()).isEqualTo(1);
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/TestLogHandler.java b/okhttp/src/test/java/okhttp3/TestLogHandler.java
deleted file mode 100644
index 055b25e226..0000000000
--- a/okhttp/src/test/java/okhttp3/TestLogHandler.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
-import java.util.logging.Handler;
-import java.util.logging.LogRecord;
-
-/**
- * A log handler that records which log messages were published so that a calling test can make
- * assertions about them.
- */
-public final class TestLogHandler extends Handler {
-  private final BlockingQueue<String> logs = new LinkedBlockingQueue<>();
-
-  @Override public void publish(LogRecord logRecord) {
-    if (getFormatter() == null) {
-      logs.add(logRecord.getLevel() + ": " + logRecord.getMessage());
-    } else {
-      logs.add(getFormatter().format(logRecord));
-    }
-  }
-
-  @Override public void flush() {
-  }
-
-  @Override public void close() {
-  }
-
-  public List<String> takeAll() {
-    List<String> list = new ArrayList<>();
-    logs.drainTo(list);
-    return list;
-  }
-
-  public String take() throws Exception {
-    String message = logs.poll(10, TimeUnit.SECONDS);
-    if (message == null) {
-      throw new AssertionError("Timed out waiting for log message.");
-    }
-    return message;
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/TestTls13Request.java b/okhttp/src/test/java/okhttp3/TestTls13Request.java
deleted file mode 100644
index 797dcde7a9..0000000000
--- a/okhttp/src/test/java/okhttp3/TestTls13Request.java
+++ /dev/null
@@ -1,106 +0,0 @@
-package okhttp3;
-
-import java.io.IOException;
-import java.security.Security;
-import java.util.List;
-import okhttp3.internal.platform.Platform;
-import org.conscrypt.Conscrypt;
-
-import static java.util.Arrays.asList;
-
-public class TestTls13Request {
-
-  // TLS 1.3
-  private static final CipherSuite[] TLS13_CIPHER_SUITES = new CipherSuite[] {
-      CipherSuite.TLS_AES_128_GCM_SHA256,
-      CipherSuite.TLS_AES_256_GCM_SHA384,
-      CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
-      CipherSuite.TLS_AES_128_CCM_SHA256,
-      CipherSuite.TLS_AES_128_CCM_8_SHA256
-  };
-
-  /**
-   * A TLS 1.3 only Connection Spec. This will be eventually be exposed
-   * as part of MODERN_TLS or folded into the default OkHttp client once published and
-   * available in JDK11 or Conscrypt.
-   */
-  private static final ConnectionSpec TLS_13 = new ConnectionSpec.Builder(true)
-      .cipherSuites(TLS13_CIPHER_SUITES)
-      .tlsVersions(TlsVersion.TLS_1_3)
-      .build();
-
-
-  private static final ConnectionSpec TLS_12 =
-      new ConnectionSpec.Builder(ConnectionSpec.RESTRICTED_TLS).tlsVersions(TlsVersion.TLS_1_2)
-          .build();
-
-  private TestTls13Request() {
-  }
-
-  public static void main(String[] args) {
-    //System.setProperty("javax.net.debug", "ssl:handshake:verbose");
-    Security.insertProviderAt(Conscrypt.newProviderBuilder().provideTrustManager().build(), 1);
-
-    System.out.println(
-        "Running tests using " + Platform.get() + " " + System.getProperty("java.vm.version"));
-
-    // https://github.com/tlswg/tls13-spec/wiki/Implementations
-    List<String> urls =
-        asList("https://enabled.tls13.com", "https://www.howsmyssl.com/a/check",
-            "https://tls13.cloudflare.com", "https://www.allizom.org/robots.txt",
-            "https://tls13.crypto.mozilla.org/", "https://tls.ctf.network/robots.txt",
-            "https://rustls.jbp.io/", "https://h2o.examp1e.net", "https://mew.org/",
-            "https://tls13.baishancloud.com/", "https://tls13.akamai.io/", "https://swifttls.org/",
-            "https://www.googleapis.com/robots.txt", "https://graph.facebook.com/robots.txt",
-            "https://api.twitter.com/robots.txt", "https://connect.squareup.com/robots.txt");
-
-    System.out.println("TLS1.3+TLS1.2");
-    testClient(urls, buildClient(ConnectionSpec.RESTRICTED_TLS));
-
-    System.out.println("\nTLS1.3 only");
-    testClient(urls, buildClient(TLS_13));
-
-    System.out.println("\nTLS1.3 then fallback");
-    testClient(urls, buildClient(TLS_13, TLS_12));
-  }
-
-  private static void testClient(List<String> urls, OkHttpClient client) {
-    try {
-      for (String url : urls) {
-        sendRequest(client, url);
-      }
-    } finally {
-      client.dispatcher().executorService().shutdownNow();
-      client.connectionPool().evictAll();
-    }
-  }
-
-  private static OkHttpClient buildClient(ConnectionSpec... specs) {
-    return new OkHttpClient.Builder().connectionSpecs(asList(specs)).build();
-  }
-
-  private static void sendRequest(OkHttpClient client, String url) {
-    System.out.printf("%-40s ", url);
-    System.out.flush();
-
-    System.out.println(Platform.get());
-
-    Request request = new Request.Builder().url(url).build();
-
-    try (Response response = client.newCall(request).execute()) {
-      Handshake handshake = response.handshake();
-      System.out.println(handshake.tlsVersion()
-          + " "
-          + handshake.cipherSuite()
-          + " "
-          + response.protocol()
-          + " "
-          + response.code()
-          + " "
-          + response.body().bytes().length
-          + "b");
-    } catch (IOException ioe) {
-      System.out.println(ioe.toString());
-    }
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/URLConnectionTest.java b/okhttp/src/test/java/okhttp3/URLConnectionTest.java
deleted file mode 100644
index 230bf4495f..0000000000
--- a/okhttp/src/test/java/okhttp3/URLConnectionTest.java
+++ /dev/null
@@ -1,3875 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.Authenticator;
-import java.net.ConnectException;
-import java.net.CookieManager;
-import java.net.HttpURLConnection;
-import java.net.InetAddress;
-import java.net.PasswordAuthentication;
-import java.net.ProtocolException;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.net.SocketAddress;
-import java.net.SocketException;
-import java.net.SocketTimeoutException;
-import java.net.URI;
-import java.net.URL;
-import java.net.URLConnection;
-import java.net.UnknownHostException;
-import java.security.KeyStore;
-import java.security.cert.CertificateException;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.EnumSet;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.zip.GZIPInputStream;
-import javax.annotation.Nullable;
-import javax.net.ServerSocketFactory;
-import javax.net.SocketFactory;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLProtocolException;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.internal.Internal;
-import okhttp3.internal.RecordingAuthenticator;
-import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.Version;
-import okhttp3.internal.platform.Platform;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.testing.Flaky;
-import okhttp3.testing.PlatformRule;
-import okhttp3.tls.HandshakeCertificates;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.GzipSink;
-import okio.Okio;
-import okio.Utf8;
-import org.junit.After;
-import org.junit.AssumptionViolatedException;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static java.util.Arrays.asList;
-import static java.util.Locale.US;
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static java.util.concurrent.TimeUnit.NANOSECONDS;
-import static okhttp3.internal.Internal.addHeaderLenient;
-import static okhttp3.internal.Util.immutableListOf;
-import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
-import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
-import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
-import static okhttp3.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
-import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
-import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
-import static okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-/** Android's URLConnectionTest, ported to exercise OkHttp's Call API. */
-public final class URLConnectionTest {
-  @Rule public final PlatformRule platform = new PlatformRule();
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final MockWebServer server2 = new MockWebServer();
-  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  private HandshakeCertificates handshakeCertificates = localhost();
-  private OkHttpClient client = clientTestRule.newClient();
-  private @Nullable Cache cache;
-
-  @Before public void setUp() {
-    server.setProtocolNegotiationEnabled(false);
-  }
-
-  @After public void tearDown() throws Exception {
-    Authenticator.setDefault(null);
-    System.clearProperty("proxyHost");
-    System.clearProperty("proxyPort");
-    System.clearProperty("http.proxyHost");
-    System.clearProperty("http.proxyPort");
-    System.clearProperty("https.proxyHost");
-    System.clearProperty("https.proxyPort");
-    if (cache != null) {
-      cache.delete();
-    }
-  }
-
-  @Test public void requestHeaders() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .addHeader("D", "e")
-        .addHeader("D", "f")
-        .build();
-    assertThat(request.header("D")).isEqualTo("f");
-    assertThat(request.header("d")).isEqualTo("f");
-    Headers requestHeaders = request.headers();
-    assertThat(new LinkedHashSet<>(requestHeaders.values("D"))).isEqualTo(
-        newSet("e", "f"));
-    assertThat(new LinkedHashSet<>(requestHeaders.values("d"))).isEqualTo(
-        newSet("e", "f"));
-    try {
-      new Request.Builder()
-          .header(null, "j");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      new Request.Builder()
-          .addHeader(null, "k");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      new Request.Builder()
-          .addHeader("NullValue", null);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      new Request.Builder()
-          .addHeader("AnotherNullValue", null);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-
-    Response response = getResponse(request);
-    response.close();
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getHeaders().values("D")).isEqualTo(
-        asList("e", "f"));
-    assertThat(recordedRequest.getHeader("G")).isNull();
-    assertThat(recordedRequest.getHeader("null")).isNull();
-  }
-
-  @Test public void getRequestPropertyReturnsLastValue() {
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .addHeader("A", "value1")
-        .addHeader("A", "value2")
-        .build();
-    assertThat(request.header("A")).isEqualTo("value2");
-  }
-
-  @Test public void responseHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.0 200 Fantastic")
-        .addHeader("A: c")
-        .addHeader("B: d")
-        .addHeader("A: e")
-        .setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8));
-
-    Request request = newRequest("/");
-    Response response = getResponse(request);
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.message()).isEqualTo("Fantastic");
-    try {
-      response.header(null);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    Headers responseHeaders = response.headers();
-    assertThat(new LinkedHashSet<>(responseHeaders.values("A"))).isEqualTo(
-        newSet("c", "e"));
-    assertThat(new LinkedHashSet<>(responseHeaders.values("a"))).isEqualTo(
-        newSet("c", "e"));
-    assertThat(responseHeaders.name(0)).isEqualTo("A");
-    assertThat(responseHeaders.value(0)).isEqualTo("c");
-    assertThat(responseHeaders.name(1)).isEqualTo("B");
-    assertThat(responseHeaders.value(1)).isEqualTo("d");
-    assertThat(responseHeaders.name(2)).isEqualTo("A");
-    assertThat(responseHeaders.value(2)).isEqualTo("e");
-    response.body().close();
-  }
-
-  @Test public void serverSendsInvalidStatusLine() {
-    server.enqueue(new MockResponse().setStatus("HTP/1.1 200 OK"));
-
-    Request request = newRequest("/");
-
-    try {
-      getResponse(request);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void serverSendsInvalidCodeTooLarge() {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 2147483648 OK"));
-
-    Request request = newRequest("/");
-
-    try {
-      getResponse(request);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void serverSendsInvalidCodeNotANumber() {
-    server.enqueue(new MockResponse().setStatus("HTTP/1.1 00a OK"));
-
-    Request request = newRequest("/");
-    try {
-      getResponse(request);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void serverSendsUnnecessaryWhitespace() {
-    server.enqueue(new MockResponse().setStatus(" HTTP/1.1 2147483648 OK"));
-
-    Request request = newRequest("/");
-    try {
-      getResponse(request);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void connectRetriesUntilConnectedOrFailed() throws Exception {
-    Request request = newRequest("/foo");
-    server.shutdown();
-
-    try {
-      getResponse(request);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void requestBodySurvivesRetriesWithFixedLength() throws Exception {
-    testRequestBodySurvivesRetries(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void requestBodySurvivesRetriesWithChunkedStreaming() throws Exception {
-    testRequestBodySurvivesRetries(TransferKind.CHUNKED);
-  }
-
-  private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    // Use a misconfigured proxy to guarantee that the request is retried.
-    client = client.newBuilder()
-        .proxySelector(new FakeProxySelector()
-            .addProxy(server2.toProxyAddress())
-            .addProxy(Proxy.NO_PROXY))
-        .build();
-    server2.shutdown();
-
-    Request request = new Request.Builder()
-        .url(server.url("/def"))
-        .post(transferKind.newRequestBody("body"))
-        .build();
-    Response response = getResponse(request);
-    assertContent("abc", response);
-
-    assertThat(server.takeRequest().getBody().readUtf8()).isEqualTo("body");
-  }
-
-  // Check that if we don't read to the end of a response, the next request on the
-  // recycled connection doesn't get the unread tail of the first request's response.
-  // http://code.google.com/p/android/issues/detail?id=2939
-  @Test public void bug2939() throws Exception {
-    MockResponse response = new MockResponse()
-        .setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8);
-
-    server.enqueue(response);
-    server.enqueue(response);
-
-    Request request = newRequest("/");
-    Response c1 = getResponse(request);
-    assertContent("ABCDE", c1, 5);
-    Response c2 = getResponse(request);
-    assertContent("ABCDE", c2, 5);
-
-    c1.close();
-    c2.close();
-  }
-
-  @Test public void connectionsArePooled() throws Exception {
-    MockResponse response = new MockResponse()
-        .setBody("ABCDEFGHIJKLMNOPQR");
-
-    server.enqueue(response);
-    server.enqueue(response);
-    server.enqueue(response);
-
-    assertContent("ABCDEFGHIJKLMNOPQR", getResponse(newRequest("/foo")));
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertContent("ABCDEFGHIJKLMNOPQR", getResponse(newRequest("/bar?baz=quux")));
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-    assertContent("ABCDEFGHIJKLMNOPQR", getResponse(newRequest("/z")));
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
-  }
-
-  @Test public void chunkedConnectionsArePooled() throws Exception {
-    MockResponse response = new MockResponse()
-        .setChunkedBody("ABCDEFGHIJKLMNOPQR", 5);
-
-    server.enqueue(response);
-    server.enqueue(response);
-    server.enqueue(response);
-
-    assertContent("ABCDEFGHIJKLMNOPQR", getResponse(newRequest("/foo")));
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertContent("ABCDEFGHIJKLMNOPQR", getResponse(newRequest("/bar?baz=quux")));
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-    assertContent("ABCDEFGHIJKLMNOPQR", getResponse(newRequest("/z")));
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
-  }
-
-  @Test public void serverClosesSocket() throws Exception {
-    testServerClosesOutput(DISCONNECT_AT_END);
-  }
-
-  @Test public void serverShutdownInput() throws Exception {
-    testServerClosesOutput(SHUTDOWN_INPUT_AT_END);
-  }
-
-  @Test public void serverShutdownOutput() throws Exception {
-    testServerClosesOutput(SHUTDOWN_OUTPUT_AT_END);
-  }
-
-  @Test public void invalidHost() throws Exception {
-    // Note that 1234.1.1.1 is an invalid host in a URI, but URL isn't as strict.
-    client = client.newBuilder()
-        .dns(new FakeDns())
-        .build();
-    try {
-      getResponse(new Request.Builder()
-          .url(HttpUrl.get("http://1234.1.1.1/index.html"))
-          .build());
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  private void testServerClosesOutput(SocketPolicy socketPolicy) throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("This connection won't pool properly")
-        .setSocketPolicy(socketPolicy));
-    MockResponse responseAfter = new MockResponse()
-        .setBody("This comes after a busted connection");
-    server.enqueue(responseAfter);
-    server.enqueue(responseAfter); // Enqueue 2x because the broken connection may be reused.
-
-    Response response1 = getResponse(newRequest("/a"));
-    response1.body().source().timeout().timeout(100, MILLISECONDS);
-    assertContent("This connection won't pool properly", response1);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-
-    // Give the server time to enact the socket policy if it's one that could happen after the
-    // client has received the response.
-    Thread.sleep(500);
-
-    Response response2 = getResponse(newRequest("/b"));
-    response1.body().source().timeout().timeout(100, MILLISECONDS);
-    assertContent("This comes after a busted connection", response2);
-
-    // Check that a fresh connection was created, either immediately or after attempting reuse.
-    // We know that a fresh connection was created if the server recorded a request with sequence
-    // number 0. Since the client may have attempted to reuse the broken connection just before
-    // creating a fresh connection, the server may have recorded 2 requests at this point. The order
-    // of recording is non-deterministic.
-    RecordedRequest requestAfter = server.takeRequest();
-    assertThat(requestAfter.getSequenceNumber() == 0
-        || server.getRequestCount() == 3 && server.takeRequest().getSequenceNumber() == 0).isTrue();
-  }
-
-  enum WriteKind {BYTE_BY_BYTE, SMALL_BUFFERS, LARGE_BUFFERS}
-
-  @Test public void chunkedUpload_byteByByte() throws Exception {
-    doUpload(TransferKind.CHUNKED, WriteKind.BYTE_BY_BYTE);
-  }
-
-  @Test public void chunkedUpload_smallBuffers() throws Exception {
-    doUpload(TransferKind.CHUNKED, WriteKind.SMALL_BUFFERS);
-  }
-
-  @Test public void chunkedUpload_largeBuffers() throws Exception {
-    doUpload(TransferKind.CHUNKED, WriteKind.LARGE_BUFFERS);
-  }
-
-  @Test public void fixedLengthUpload_byteByByte() throws Exception {
-    doUpload(TransferKind.FIXED_LENGTH, WriteKind.BYTE_BY_BYTE);
-  }
-
-  @Test public void fixedLengthUpload_smallBuffers() throws Exception {
-    doUpload(TransferKind.FIXED_LENGTH, WriteKind.SMALL_BUFFERS);
-  }
-
-  @Test public void fixedLengthUpload_largeBuffers() throws Exception {
-    doUpload(TransferKind.FIXED_LENGTH, WriteKind.LARGE_BUFFERS);
-  }
-
-  private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Exception {
-    int n = 512 * 1024;
-    server.setBodyLimit(0);
-    server.enqueue(new MockResponse());
-
-    RequestBody requestBody = new RequestBody() {
-      @Override public @Nullable MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return uploadKind == TransferKind.CHUNKED ? -1L : n;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        if (writeKind == WriteKind.BYTE_BY_BYTE) {
-          for (int i = 0; i < n; ++i) {
-            sink.writeByte('x');
-          }
-        } else {
-          byte[] buf = new byte[writeKind == WriteKind.SMALL_BUFFERS ? 256 : 64 * 1024];
-          Arrays.fill(buf, (byte) 'x');
-          for (int i = 0; i < n; i += buf.length) {
-            sink.write(buf, 0, Math.min(buf.length, n - i));
-          }
-        }
-      }
-    };
-
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .post(requestBody)
-        .build());
-    assertThat(response.code()).isEqualTo(200);
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBodySize()).isEqualTo(n);
-    if (uploadKind == TransferKind.CHUNKED) {
-      assertThat(request.getChunkSizes()).isNotEmpty();
-    } else {
-      assertThat(request.getChunkSizes()).isEmpty();
-    }
-  }
-
-  @Test public void connectViaHttps() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setBody("this response comes via HTTPS"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    Response response = getResponse(newRequest("/foo"));
-    assertContent("this response comes via HTTPS", response);
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
-  }
-
-  @Test public void connectViaHttpsReusingConnections() throws Exception {
-    connectViaHttpsReusingConnections(false);
-  }
-
-  @Test public void connectViaHttpsReusingConnectionsAfterRebuildingClient() throws Exception {
-    connectViaHttpsReusingConnections(true);
-  }
-
-  private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setBody("this response comes via HTTPS"));
-    server.enqueue(new MockResponse()
-        .setBody("another response via HTTPS"));
-
-    // The pool will only reuse sockets if the SSL socket factories are the same.
-    SSLSocketFactory clientSocketFactory = handshakeCertificates.sslSocketFactory();
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    CookieJar cookieJar = new JavaNetCookieJar(new CookieManager());
-    ConnectionPool connectionPool = new ConnectionPool();
-
-    client = new OkHttpClient.Builder()
-        .cache(cache)
-        .connectionPool(connectionPool)
-        .cookieJar(cookieJar)
-        .sslSocketFactory(clientSocketFactory, handshakeCertificates.trustManager())
-        .hostnameVerifier(hostnameVerifier)
-        .build();
-    Response response1 = getResponse(newRequest("/"));
-    assertContent("this response comes via HTTPS", response1);
-
-    if (rebuildClient) {
-      client = new OkHttpClient.Builder()
-          .cache(cache)
-          .connectionPool(connectionPool)
-          .cookieJar(cookieJar)
-          .sslSocketFactory(clientSocketFactory, handshakeCertificates.trustManager())
-          .hostnameVerifier(hostnameVerifier)
-          .build();
-    }
-
-    Response response2 = getResponse(newRequest("/"));
-    assertContent("another response via HTTPS", response2);
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void connectViaHttpsReusingConnectionsDifferentFactories() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setBody("this response comes via HTTPS"));
-    server.enqueue(new MockResponse()
-        .setBody("another response via HTTPS"));
-
-    // install a custom SSL socket factory so the server can be authorized
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-    Response response1 = getResponse(newRequest("/"));
-    assertContent("this response comes via HTTPS", response1);
-
-    SSLContext sslContext2 = Platform.get().newSSLContext();
-    sslContext2.init(null, null, null);
-    SSLSocketFactory sslSocketFactory2 = sslContext2.getSocketFactory();
-
-    TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-        TrustManagerFactory.getDefaultAlgorithm());
-    trustManagerFactory.init((KeyStore) null);
-    X509TrustManager trustManager = (X509TrustManager) trustManagerFactory.getTrustManagers()[0];
-
-    client = client.newBuilder()
-        .sslSocketFactory(sslSocketFactory2, trustManager)
-        .build();
-    try {
-      getResponse(newRequest("/"));
-      fail("without an SSL socket factory, the connection should fail");
-    } catch (SSLException expected) {
-    }
-  }
-
-  // TODO(jwilson): tests below this marker need to be migrated to OkHttp's request/response API.
-
-  @Test public void connectViaHttpsWithSSLFallback() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse()
-        .setBody("this response comes via SSL"));
-
-    client = client.newBuilder()
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
-        .connectionSpecs(asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
-        .sslSocketFactory(
-            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
-        .build();
-    Response response = getResponse(newRequest("/foo"));
-
-    assertContent("this response comes via SSL", response);
-
-    RecordedRequest failHandshakeRequest = server.takeRequest();
-    assertThat(failHandshakeRequest.getRequestLine()).isEmpty();
-
-    RecordedRequest fallbackRequest = server.takeRequest();
-    assertThat(fallbackRequest.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
-    assertThat(fallbackRequest.getTlsVersion()).isIn(TlsVersion.TLS_1_2, TlsVersion.TLS_1_3);
-  }
-
-  @Test public void connectViaHttpsWithSSLFallbackFailuresRecorded() {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(FAIL_HANDSHAKE));
-
-    client = client.newBuilder()
-        .connectionSpecs(asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .sslSocketFactory(
-            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
-        .build();
-
-    try {
-      getResponse(newRequest("/foo"));
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getSuppressed().length).isEqualTo(1);
-    }
-  }
-
-  /**
-   * When a pooled connection fails, don't blame the route. Otherwise pooled connection failures can
-   * cause unnecessary SSL fallbacks.
-   *
-   * https://github.com/square/okhttp/issues/515
-   */
-  @Test public void sslFallbackNotUsedWhenRecycledConnectionFails() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .setSocketPolicy(DISCONNECT_AT_END));
-    server.enqueue(new MockResponse()
-        .setBody("def"));
-
-    client = client.newBuilder()
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .sslSocketFactory(
-            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
-        .build();
-
-    assertContent("abc", getResponse(newRequest("/")));
-
-    // Give the server time to disconnect.
-    Thread.sleep(500);
-
-    assertContent("def", getResponse(newRequest("/")));
-
-    Set<TlsVersion> tlsVersions =
-        EnumSet.of(TlsVersion.TLS_1_0, TlsVersion.TLS_1_2,
-            TlsVersion.TLS_1_3); // v1.2 on OpenJDK 8.
-
-    RecordedRequest request1 = server.takeRequest();
-    assertThat(tlsVersions).contains(request1.getTlsVersion());
-
-    RecordedRequest request2 = server.takeRequest();
-    assertThat(tlsVersions).contains(request2.getTlsVersion());
-  }
-
-  /**
-   * Verify that we don't retry connections on certificate verification errors.
-   *
-   * http://code.google.com/p/android/issues/detail?id=13178
-   */
-  @Flaky
-  @Test public void connectViaHttpsToUntrustedServer() throws Exception {
-    // Flaky https://github.com/square/okhttp/issues/5222
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()); // unused
-
-    try {
-      getResponse(newRequest("/foo"));
-      fail();
-    } catch (SSLHandshakeException expected) {
-      // Allow conscrypt to fail in different ways
-      if (!platform.isConscrypt()) {
-        assertThat(expected.getCause()).isInstanceOf(CertificateException.class);
-      }
-    }
-    assertThat(server.getRequestCount()).isEqualTo(0);
-  }
-
-  @Test public void connectViaProxyUsingProxyArg() throws Exception {
-    testConnectViaProxy(ProxyConfig.CREATE_ARG);
-  }
-
-  @Test public void connectViaProxyUsingProxySystemProperty() throws Exception {
-    testConnectViaProxy(ProxyConfig.PROXY_SYSTEM_PROPERTY);
-  }
-
-  @Test public void connectViaProxyUsingHttpProxySystemProperty() throws Exception {
-    testConnectViaProxy(ProxyConfig.HTTP_PROXY_SYSTEM_PROPERTY);
-  }
-
-  private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
-    MockResponse mockResponse = new MockResponse()
-        .setBody("this response comes via a proxy");
-    server.enqueue(mockResponse);
-
-    HttpUrl url = HttpUrl.parse("http://android.com/foo");
-    Response response = proxyConfig.connect(server, client, url).execute();
-    assertContent("this response comes via a proxy", response);
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getRequestLine()).isEqualTo(
-        "GET http://android.com/foo HTTP/1.1");
-    assertThat(request.getHeader("Host")).isEqualTo("android.com");
-  }
-
-  @Test public void contentDisagreesWithContentLengthHeaderBodyTooLong() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("abc\r\nYOU SHOULD NOT SEE THIS")
-        .clearHeaders()
-        .addHeader("Content-Length: 3"));
-    assertContent("abc", getResponse(newRequest("/")));
-  }
-
-  @Test public void contentDisagreesWithContentLengthHeaderBodyTooShort() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .setHeader("Content-Length", "5")
-        .setSocketPolicy(DISCONNECT_AT_END));
-    try {
-      Response response = getResponse(newRequest("/"));
-      response.body().source().readUtf8(5);
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-
-  private void testConnectViaSocketFactory(boolean useHttps) throws IOException {
-    SocketFactory uselessSocketFactory = new SocketFactory() {
-      @Override public Socket createSocket() {
-        throw new IllegalArgumentException("useless");
-      }
-
-      @Override public Socket createSocket(InetAddress host, int port) {
-        return null;
-      }
-
-      @Override public Socket createSocket(InetAddress address, int port, InetAddress localAddress,
-          int localPort) {
-        return null;
-      }
-
-      @Override public Socket createSocket(String host, int port) {
-        return null;
-      }
-
-      @Override public Socket createSocket(String host, int port, InetAddress localHost, int localPort) {
-        return null;
-      }
-    };
-
-    if (useHttps) {
-      server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-      client = client.newBuilder()
-          .sslSocketFactory(
-              handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-          .hostnameVerifier(new RecordingHostnameVerifier())
-          .build();
-    }
-
-    server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 200 OK"));
-
-    client = client.newBuilder()
-        .socketFactory(uselessSocketFactory)
-        .build();
-    try {
-      getResponse(newRequest("/"));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-
-    client = client.newBuilder()
-        .socketFactory(SocketFactory.getDefault())
-        .build();
-    Response response = getResponse(newRequest("/"));
-    assertThat(response.code()).isEqualTo(200);
-  }
-
-  @Test public void connectHttpViaSocketFactory() throws Exception {
-    testConnectViaSocketFactory(false);
-  }
-
-  @Test public void connectHttpsViaSocketFactory() throws Exception {
-    testConnectViaSocketFactory(true);
-  }
-
-  @Test public void contentDisagreesWithChunkedHeaderBodyTooLong() throws IOException {
-    MockResponse mockResponse = new MockResponse()
-        .setChunkedBody("abc", 3);
-    Buffer buffer = mockResponse.getBody();
-    buffer.writeUtf8("\r\nYOU SHOULD NOT SEE THIS");
-    mockResponse.setBody(buffer);
-    mockResponse.clearHeaders();
-    mockResponse.addHeader("Transfer-encoding: chunked");
-
-    server.enqueue(mockResponse);
-
-    assertContent("abc", getResponse(newRequest("/")));
-  }
-
-  @Test public void contentDisagreesWithChunkedHeaderBodyTooShort() {
-    MockResponse mockResponse = new MockResponse()
-        .setChunkedBody("abcdefg", 5);
-
-    Buffer truncatedBody = new Buffer();
-    Buffer fullBody = mockResponse.getBody();
-    truncatedBody.write(fullBody, 4);
-    mockResponse.setBody(truncatedBody);
-
-    mockResponse.clearHeaders();
-    mockResponse.addHeader("Transfer-encoding: chunked");
-    mockResponse.setSocketPolicy(DISCONNECT_AT_END);
-
-    server.enqueue(mockResponse);
-
-    try {
-      Response response = getResponse(newRequest("/"));
-      response.body().source().readUtf8(7);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingProxyArgWithNoProxy() throws Exception {
-    testConnectViaDirectProxyToHttps(ProxyConfig.NO_PROXY);
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingHttpProxySystemProperty() throws Exception {
-    // https should not use http proxy
-    testConnectViaDirectProxyToHttps(ProxyConfig.HTTP_PROXY_SYSTEM_PROPERTY);
-  }
-
-  private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setBody("this response comes via HTTPS"));
-
-    HttpUrl url = server.url("/foo");
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-    Call call = proxyConfig.connect(server, client, url);
-
-    assertContent("this response comes via HTTPS", call.execute());
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingProxyArg() throws Exception {
-    testConnectViaHttpProxyToHttps(ProxyConfig.CREATE_ARG);
-  }
-
-  /**
-   * We weren't honoring all of the appropriate proxy system properties when connecting via HTTPS.
-   * http://b/3097518
-   */
-  @Test public void connectViaHttpProxyToHttpsUsingProxySystemProperty() throws Exception {
-    testConnectViaHttpProxyToHttps(ProxyConfig.PROXY_SYSTEM_PROPERTY);
-  }
-
-  @Test public void connectViaHttpProxyToHttpsUsingHttpsProxySystemProperty() throws Exception {
-    testConnectViaHttpProxyToHttps(ProxyConfig.HTTPS_PROXY_SYSTEM_PROPERTY);
-  }
-
-  /**
-   * We were verifying the wrong hostname when connecting to an HTTPS site through a proxy.
-   * http://b/3097277
-   */
-  private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exception {
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("this response comes via a secure proxy"));
-
-    HttpUrl url = HttpUrl.parse("https://android.com/foo");
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(hostnameVerifier)
-        .build();
-    Call call = proxyConfig.connect(server, client, url);
-
-    assertContent("this response comes via a secure proxy", call.execute());
-
-    RecordedRequest connect = server.takeRequest();
-    assertThat(connect.getRequestLine()).overridingErrorMessage(
-        "Connect line failure on proxy").isEqualTo("CONNECT android.com:443 HTTP/1.1");
-    assertThat(connect.getHeader("Host")).isEqualTo("android.com:443");
-
-    RecordedRequest get = server.takeRequest();
-    assertThat(get.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
-    assertThat(get.getHeader("Host")).isEqualTo("android.com");
-    assertThat(hostnameVerifier.calls).isEqualTo(
-        asList("verify android.com"));
-  }
-
-  /** Tolerate bad https proxy response when using HttpResponseCache. Android bug 6754912. */
-  @Test public void connectViaHttpProxyToHttpsUsingBadProxyAndHttpResponseCache() throws Exception {
-    initResponseCache();
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    // The inclusion of a body in the response to a CONNECT is key to reproducing b/6754912.
-    MockResponse badProxyResponse = new MockResponse()
-        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
-        .setBody("bogus proxy connect response content");
-    server.enqueue(badProxyResponse);
-    server.enqueue(new MockResponse()
-        .setBody("response"));
-
-    // Configure a single IP address for the host and a single configuration, so we only need one
-    // failure to fail permanently.
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .connectionSpecs(immutableListOf(ConnectionSpec.MODERN_TLS))
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .proxy(server.toProxyAddress())
-        .build();
-
-    Response response = getResponse(new Request.Builder()
-        .url(HttpUrl.get("https://android.com/foo"))
-        .build());
-    assertContent("response", response);
-
-    RecordedRequest connect = server.takeRequest();
-    assertThat(connect.getRequestLine()).isEqualTo(
-        "CONNECT android.com:443 HTTP/1.1");
-    assertThat(connect.getHeader("Host")).isEqualTo("android.com:443");
-  }
-
-  private void initResponseCache() {
-    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-  }
-
-  /** Test which headers are sent unencrypted to the HTTP proxy. */
-  @Test public void proxyConnectIncludesProxyHeadersOnly() throws Exception {
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("encrypted response from the origin server"));
-
-    client = client.newBuilder()
-        .proxy(server.toProxyAddress())
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(hostnameVerifier)
-        .build();
-
-    Response response = getResponse(new Request.Builder()
-        .url(HttpUrl.get("https://android.com/foo"))
-        .header("Private", "Secret")
-        .header("Proxy-Authorization", "bar")
-        .header("User-Agent", "baz")
-        .build());
-    assertContent("encrypted response from the origin server", response);
-
-    RecordedRequest connect = server.takeRequest();
-    assertThat(connect.getHeader("Private")).isNull();
-    assertThat(connect.getHeader("Proxy-Authorization")).isNull();
-    assertThat(connect.getHeader("User-Agent")).isEqualTo(Version.userAgent);
-    assertThat(connect.getHeader("Host")).isEqualTo("android.com:443");
-    assertThat(connect.getHeader("Proxy-Connection")).isEqualTo("Keep-Alive");
-
-    RecordedRequest get = server.takeRequest();
-    assertThat(get.getHeader("Private")).isEqualTo("Secret");
-    assertThat(hostnameVerifier.calls).isEqualTo(
-        asList("verify android.com"));
-  }
-
-  @Test public void proxyAuthenticateOnConnect() throws Exception {
-    Authenticator.setDefault(new RecordingAuthenticator());
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.enqueue(new MockResponse()
-        .setResponseCode(407)
-        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    client = client.newBuilder()
-        .proxyAuthenticator(new JavaNetAuthenticator())
-        .proxy(server.toProxyAddress())
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    Response response = getResponse(new Request.Builder()
-        .url(HttpUrl.parse("https://android.com/foo"))
-        .build());
-    assertContent("A", response);
-
-    RecordedRequest connect1 = server.takeRequest();
-    assertThat(connect1.getRequestLine()).isEqualTo(
-        "CONNECT android.com:443 HTTP/1.1");
-    assertThat(connect1.getHeader("Proxy-Authorization")).isNull();
-
-    RecordedRequest connect2 = server.takeRequest();
-    assertThat(connect2.getRequestLine()).isEqualTo(
-        "CONNECT android.com:443 HTTP/1.1");
-    assertThat(connect2.getHeader("Proxy-Authorization")).isEqualTo(
-        ("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS));
-
-    RecordedRequest get = server.takeRequest();
-    assertThat(get.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
-    assertThat(get.getHeader("Proxy-Authorization")).isNull();
-  }
-
-  // Don't disconnect after building a tunnel with CONNECT
-  // http://code.google.com/p/android/issues/detail?id=37221
-  @Test public void proxyWithConnectionClose() throws IOException {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("this response comes via a proxy"));
-
-    client = client.newBuilder()
-        .proxy(server.toProxyAddress())
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    Response response = getResponse(new Request.Builder()
-        .url("https://android.com/foo")
-        .header("Connection", "close")
-        .build());
-
-    assertContent("this response comes via a proxy", response);
-  }
-
-  @Test public void proxyWithConnectionReuse() throws IOException {
-    SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-
-    server.useHttps(socketFactory, true);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    server.enqueue(new MockResponse()
-        .setBody("response 1"));
-    server.enqueue(new MockResponse()
-        .setBody("response 2"));
-
-    client = client.newBuilder()
-        .proxy(server.toProxyAddress())
-        .sslSocketFactory(socketFactory, handshakeCertificates.trustManager())
-        .hostnameVerifier(hostnameVerifier)
-        .build();
-
-    assertContent("response 1", getResponse(newRequest(HttpUrl.get("https://android.com/foo"))));
-    assertContent("response 2", getResponse(newRequest(HttpUrl.get("https://android.com/foo"))));
-  }
-
-  @Test public void proxySelectorHttpWithConnectionReuse() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("response 1"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(407));
-
-    client = client.newBuilder()
-        .proxySelector(new ProxySelector() {
-          @Override public List<Proxy> select(URI uri) {
-            return Collections.singletonList(server.toProxyAddress());
-          }
-
-          @Override public void connectFailed(
-              URI uri, SocketAddress socketAddress, IOException e) {
-          }
-        }).build();
-    HttpUrl url = HttpUrl.get("http://android.com/foo");
-    assertContent("response 1", getResponse(newRequest(url)));
-    assertThat(getResponse(newRequest(url)).code()).isEqualTo(407);
-  }
-
-  @Test public void disconnectedConnection() throws IOException {
-    server.enqueue(new MockResponse()
-        .throttleBody(2, 100, TimeUnit.MILLISECONDS)
-        .setBody("ABCD"));
-
-    Call call = client.newCall(newRequest("/"));
-    Response response = call.execute();
-    InputStream in = response.body().byteStream();
-    assertThat((char) in.read()).isEqualTo('A');
-    call.cancel();
-    try {
-      // Reading 'B' may succeed if it's buffered.
-      in.read();
-
-      // But 'C' shouldn't be buffered (the response is throttled) and this should fail.
-      in.read();
-      fail("Expected a connection closed exception");
-    } catch (IOException expected) {
-    }
-    in.close();
-  }
-
-  @Test public void disconnectDuringConnect_cookieJar() {
-    AtomicReference<Call> callReference = new AtomicReference<>();
-
-    class DisconnectingCookieJar implements CookieJar {
-      @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) {
-      }
-
-      @Override public List<Cookie> loadForRequest(HttpUrl url) {
-        callReference.get().cancel();
-        return Collections.emptyList();
-      }
-    }
-    client = client.newBuilder()
-        .cookieJar(new DisconnectingCookieJar())
-        .build();
-
-    Call call = client.newCall(newRequest("/"));
-    callReference.set(call);
-    try {
-      call.execute();
-      fail("Connection should not be established");
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("Canceled");
-    }
-  }
-
-  @Test public void disconnectBeforeConnect() {
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    Call call = client.newCall(newRequest("/"));
-    call.cancel();
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @SuppressWarnings("deprecation") @Test public void defaultRequestProperty() {
-    URLConnection.setDefaultRequestProperty("X-testSetDefaultRequestProperty", "A");
-    assertThat(
-        (Object) URLConnection.getDefaultRequestProperty("X-setDefaultRequestProperty")).isNull();
-  }
-
-  /**
-   * Reads {@code count} characters from the stream. If the stream is exhausted before {@code count}
-   * characters can be read, the remaining characters are returned and the stream is closed.
-   */
-  private String readAscii(InputStream in, int count) throws IOException {
-    StringBuilder result = new StringBuilder();
-    for (int i = 0; i < count; i++) {
-      int value = in.read();
-      if (value == -1) {
-        in.close();
-        break;
-      }
-      result.append((char) value);
-    }
-    return result.toString();
-  }
-
-  @Test public void markAndResetWithContentLengthHeader() throws IOException {
-    testMarkAndReset(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void markAndResetWithChunkedEncoding() throws IOException {
-    testMarkAndReset(TransferKind.CHUNKED);
-  }
-
-  @Test public void markAndResetWithNoLengthHeaders() throws IOException {
-    testMarkAndReset(TransferKind.END_OF_STREAM);
-  }
-
-  private void testMarkAndReset(TransferKind transferKind) throws IOException {
-    MockResponse response = new MockResponse();
-    transferKind.setBody(response, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", 1024);
-    server.enqueue(response);
-    server.enqueue(response);
-
-    InputStream in = getResponse(newRequest("/")).body().byteStream();
-    assertThat(in.markSupported())
-        .overridingErrorMessage("This implementation claims to support mark().")
-        .isFalse();
-    in.mark(5);
-    assertThat(readAscii(in, 5)).isEqualTo("ABCDE");
-    try {
-      in.reset();
-      fail();
-    } catch (IOException expected) {
-    }
-    assertThat(readAscii(in, Integer.MAX_VALUE)).isEqualTo(
-        "FGHIJKLMNOPQRSTUVWXYZ");
-    in.close();
-    assertContent("ABCDEFGHIJKLMNOPQRSTUVWXYZ", getResponse(newRequest("/")));
-  }
-
-  /**
-   * We've had a bug where we forget the HTTP response when we see response code 401. This causes a
-   * new HTTP request to be issued for every call into the URLConnection.
-   */
-  @Test public void unauthorizedResponseHandling() throws IOException {
-    MockResponse mockResponse = new MockResponse()
-        .addHeader("WWW-Authenticate: challenge")
-        .setResponseCode(HttpURLConnection.HTTP_UNAUTHORIZED)
-        .setBody("Unauthorized");
-    server.enqueue(mockResponse);
-    server.enqueue(mockResponse);
-    server.enqueue(mockResponse);
-
-    Response response = getResponse(newRequest("/"));
-
-    assertThat(response.code()).isEqualTo(401);
-    assertThat(response.code()).isEqualTo(401);
-    assertThat(response.code()).isEqualTo(401);
-    assertThat(server.getRequestCount()).isEqualTo(1);
-    response.body().close();
-  }
-
-  @Test public void nonHexChunkSize() {
-    server.enqueue(new MockResponse()
-        .setBody("5\r\nABCDE\r\nG\r\nFGHIJKLMNOPQRSTU\r\n0\r\n\r\n")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked"));
-
-    try (Response response = getResponse(newRequest("/"))) {
-      response.body().string();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void malformedChunkSize() {
-    server.enqueue(new MockResponse()
-        .setBody("5:x\r\nABCDE\r\n0\r\n\r\n")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked"));
-
-    try (Response response = getResponse(newRequest("/"))) {
-      readAscii(response.body().byteStream(), Integer.MAX_VALUE);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void extensionAfterChunkSize() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("5;x\r\nABCDE\r\n0\r\n\r\n")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked"));
-
-    try (Response response = getResponse(newRequest("/"))) {
-      assertContent("ABCDE", response);
-    }
-  }
-
-  @Test public void missingChunkBody() {
-    server.enqueue(new MockResponse()
-        .setBody("5")
-        .clearHeaders()
-        .addHeader("Transfer-encoding: chunked")
-        .setSocketPolicy(DISCONNECT_AT_END));
-
-    try (Response response = getResponse(newRequest("/"))) {
-      readAscii(response.body().byteStream(), Integer.MAX_VALUE);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  /**
-   * This test checks whether connections are gzipped by default. This behavior in not required by
-   * the API, so a failure of this test does not imply a bug in the implementation.
-   */
-  @Test public void gzipEncodingEnabledByDefault() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(gzip("ABCABCABC"))
-        .addHeader("Content-Encoding: gzip"));
-
-    Response response = getResponse(newRequest("/"));
-    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "ABCABCABC");
-    assertThat(response.header("Content-Encoding")).isNull();
-    assertThat(response.body().contentLength()).isEqualTo(-1L);
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getHeader("Accept-Encoding")).isEqualTo("gzip");
-  }
-
-  @Test public void clientConfiguredGzipContentEncoding() throws Exception {
-    Buffer bodyBytes = gzip("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
-    server.enqueue(new MockResponse()
-        .setBody(bodyBytes)
-        .addHeader("Content-Encoding: gzip"));
-
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .header("Accept-Encoding", "gzip")
-        .build());
-    InputStream gunzippedIn = new GZIPInputStream(response.body().byteStream());
-    assertThat(readAscii(gunzippedIn, Integer.MAX_VALUE)).isEqualTo(
-        "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
-    assertThat(response.body().contentLength()).isEqualTo(bodyBytes.size());
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getHeader("Accept-Encoding")).isEqualTo("gzip");
-  }
-
-  @Test public void gzipAndConnectionReuseWithFixedLength() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.FIXED_LENGTH, false);
-  }
-
-  @Test public void gzipAndConnectionReuseWithChunkedEncoding() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.CHUNKED, false);
-  }
-
-  @Test public void gzipAndConnectionReuseWithFixedLengthAndTls() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.FIXED_LENGTH, true);
-  }
-
-  @Test public void gzipAndConnectionReuseWithChunkedEncodingAndTls() throws Exception {
-    testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind.CHUNKED, true);
-  }
-
-  @Test public void clientConfiguredCustomContentEncoding() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("ABCDE")
-        .addHeader("Content-Encoding: custom"));
-
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .header("Accept-Encoding", "custom")
-        .build());
-    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "ABCDE");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getHeader("Accept-Encoding")).isEqualTo("custom");
-  }
-
-  /**
-   * Test a bug where gzip input streams weren't exhausting the input stream, which corrupted the
-   * request that followed or prevented connection reuse. http://code.google.com/p/android/issues/detail?id=7059
-   * http://code.google.com/p/android/issues/detail?id=38817
-   */
-  private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind transferKind,
-      boolean tls) throws Exception {
-    if (tls) {
-      SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
-      RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-      server.useHttps(socketFactory, false);
-      client = client.newBuilder()
-          .sslSocketFactory(socketFactory, handshakeCertificates.trustManager())
-          .hostnameVerifier(hostnameVerifier)
-          .build();
-    }
-
-    MockResponse responseOne = new MockResponse()
-        .addHeader("Content-Encoding: gzip");
-    transferKind.setBody(responseOne, gzip("one (gzipped)"), 5);
-    server.enqueue(responseOne);
-    MockResponse responseTwo = new MockResponse();
-    transferKind.setBody(responseTwo, "two (identity)", 5);
-    server.enqueue(responseTwo);
-
-    Response response1 = getResponse(new Request.Builder()
-        .header("Accept-Encoding", "gzip")
-        .url(server.url("/"))
-        .build());
-    InputStream gunzippedIn = new GZIPInputStream(response1.body().byteStream());
-    assertThat(readAscii(gunzippedIn, Integer.MAX_VALUE)).isEqualTo(
-        "one (gzipped)");
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-
-    Response response2 = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    assertThat(readAscii(response2.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "two (identity)");
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void transparentGzipWorksAfterExceptionRecovery() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("a")
-        .setSocketPolicy(SHUTDOWN_INPUT_AT_END));
-    server.enqueue(new MockResponse()
-        .addHeader("Content-Encoding: gzip")
-        .setBody(gzip("b")));
-
-    // Seed the pool with a bad connection.
-    assertContent("a", getResponse(newRequest("/")));
-
-    // Give the server time to disconnect.
-    Thread.sleep(500);
-
-    // This connection will need to be recovered. When it is, transparent gzip should still work!
-    assertContent("b", getResponse(newRequest("/")));
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    // Connection is not pooled.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void endOfStreamResponseIsNotPooled() throws Exception {
-    client.connectionPool().evictAll();
-    server.enqueue(new MockResponse()
-        .setBody("{}")
-        .clearHeaders()
-        .setSocketPolicy(DISCONNECT_AT_END));
-
-    Response response = getResponse(newRequest("/"));
-    assertContent("{}", response);
-    assertThat(client.connectionPool().idleConnectionCount()).isEqualTo(0);
-  }
-
-  @Test public void earlyDisconnectDoesntHarmPoolingWithChunkedEncoding() throws Exception {
-    testEarlyDisconnectDoesntHarmPooling(TransferKind.CHUNKED);
-  }
-
-  @Test public void earlyDisconnectDoesntHarmPoolingWithFixedLengthEncoding() throws Exception {
-    testEarlyDisconnectDoesntHarmPooling(TransferKind.FIXED_LENGTH);
-  }
-
-  private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) throws Exception {
-    MockResponse mockResponse1 = new MockResponse();
-    transferKind.setBody(mockResponse1, "ABCDEFGHIJK", 1024);
-    server.enqueue(mockResponse1);
-
-    MockResponse mockResponse2 = new MockResponse();
-    transferKind.setBody(mockResponse2, "LMNOPQRSTUV", 1024);
-    server.enqueue(mockResponse2);
-
-    Call call1 = client.newCall(newRequest("/"));
-    Response response1 = call1.execute();
-    InputStream in1 = response1.body().byteStream();
-    assertThat(readAscii(in1, 5)).isEqualTo("ABCDE");
-    in1.close();
-    call1.cancel();
-
-    Call call2 = client.newCall(newRequest("/"));
-    Response response2 = call2.execute();
-    InputStream in2 = response2.body().byteStream();
-    assertThat(readAscii(in2, 5)).isEqualTo("LMNOP");
-    in2.close();
-    call2.cancel();
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    // Connection is pooled!
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void streamDiscardingIsTimely() throws Exception {
-    // This response takes at least a full second to serve: 10,000 bytes served 100 bytes at a time.
-    server.enqueue(new MockResponse()
-        .setBody(new Buffer().write(new byte[10000]))
-        .throttleBody(100, 10, MILLISECONDS));
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    long startNanos = System.nanoTime();
-    Response connection1 = getResponse(newRequest("/"));
-    InputStream in = connection1.body().byteStream();
-    in.close();
-    long elapsedNanos = System.nanoTime() - startNanos;
-    long elapsedMillis = NANOSECONDS.toMillis(elapsedNanos);
-
-    // If we're working correctly, this should be greater than 100ms, but less than double that.
-    // Previously we had a bug where we would download the entire response body as long as no
-    // individual read took longer than 100ms.
-    assertThat(elapsedMillis).isLessThan(500L);
-
-    // Do another request to confirm that the discarded connection was not pooled.
-    assertContent("A", getResponse(newRequest("/")));
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    // Connection is not pooled.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void setChunkedStreamingMode() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .post(TransferKind.CHUNKED.newRequestBody("ABCDEFGHIJKLMNOPQ"))
-        .build());
-    assertThat(response.code()).isEqualTo(200);
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("ABCDEFGHIJKLMNOPQ");
-    assertThat(request.getChunkSizes()).isEqualTo(
-        asList("ABCDEFGHIJKLMNOPQ".length()));
-  }
-
-  @Test public void authenticateWithFixedLengthStreaming() throws Exception {
-    testAuthenticateWithStreamingPost(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void authenticateWithChunkedStreaming() throws Exception {
-    testAuthenticateWithStreamingPost(TransferKind.CHUNKED);
-  }
-
-  private void testAuthenticateWithStreamingPost(TransferKind streamingMode) throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate."));
-    server.enqueue(new MockResponse()
-        .setBody("Authenticated!"));
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    client = client.newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build();
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(streamingMode.newRequestBody("ABCD"))
-        .build();
-    Response response = getResponse(request);
-    assertThat(response.code()).isEqualTo(200);
-    assertContent("Authenticated!", response);
-
-    // No authorization header for the request...
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getHeader("Authorization")).isNull();
-    assertThat(recordedRequest.getBody().readUtf8()).isEqualTo("ABCD");
-  }
-
-  @Test public void postBodyRetransmittedAfterAuthorizationFail() throws Exception {
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
-  @Test public void postBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
-    platform.assumeHttp2Support();
-
-    enableProtocol(Protocol.HTTP_2);
-    postBodyRetransmittedAfterAuthorizationFail("abc");
-  }
-
-  /** Don't explode when resending an empty post. https://github.com/square/okhttp/issues/1131 */
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail() throws Exception {
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
-  @Test public void postEmptyBodyRetransmittedAfterAuthorizationFail_HTTP_2() throws Exception {
-    platform.assumeHttp2Support();
-
-    enableProtocol(Protocol.HTTP_2);
-    postBodyRetransmittedAfterAuthorizationFail("");
-  }
-
-  private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(401));
-    server.enqueue(new MockResponse());
-
-    String credential = Credentials.basic("jesse", "secret");
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential, null))
-        .build();
-
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create(body, null))
-        .build());
-    assertThat(response.code()).isEqualTo(200);
-    response.body().byteStream().close();
-
-    RecordedRequest recordedRequest1 = server.takeRequest();
-    assertThat(recordedRequest1.getMethod()).isEqualTo("POST");
-    assertThat(recordedRequest1.getBody().readUtf8()).isEqualTo(body);
-    assertThat(recordedRequest1.getHeader("Authorization")).isNull();
-
-    RecordedRequest recordedRequest2 = server.takeRequest();
-    assertThat(recordedRequest2.getMethod()).isEqualTo("POST");
-    assertThat(recordedRequest2.getBody().readUtf8()).isEqualTo(body);
-    assertThat(recordedRequest2.getHeader("Authorization")).isEqualTo(
-        credential);
-  }
-
-  @Test public void nonStandardAuthenticationScheme() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Foo");
-    assertThat(calls).isEqualTo(Collections.<String>emptyList());
-  }
-
-  @Test public void nonStandardAuthenticationSchemeWithRealm() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Foo realm=\"Bar\"");
-    assertThat(calls.size()).isEqualTo(0);
-  }
-
-  // Digest auth is currently unsupported. Test that digest requests should fail reasonably.
-  // http://code.google.com/p/android/issues/detail?id=11140
-  @Test public void digestAuthentication() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Digest "
-        + "realm=\"testrealm@host.com\", qop=\"auth,auth-int\", "
-        + "nonce=\"dcd98b7102dd2f0e8b11d0f600bfb0c093\", "
-        + "opaque=\"5ccc069c403ebaf9f0171e9517f40e41\"");
-    assertThat(calls.size()).isEqualTo(0);
-  }
-
-  @Test public void allAttributesSetInServerAuthenticationCallbacks() throws Exception {
-    List<String> calls = authCallsForHeader("WWW-Authenticate: Basic realm=\"Bar\"");
-    assertThat(calls.size()).isEqualTo(1);
-    URL url = server.url("/").url();
-    String call = calls.get(0);
-    assertThat(call).contains("host=" + url.getHost());
-    assertThat(call).contains("port=" + url.getPort());
-    assertThat(call).contains("site=" + url.getHost());
-    assertThat(call).contains("url=" + url);
-    assertThat(call).contains("type=" + Authenticator.RequestorType.SERVER);
-    assertThat(call).contains("prompt=Bar");
-    assertThat(call).contains("protocol=http");
-    assertThat(call.toLowerCase(US)).contains("scheme=basic"); // lowercase for the RI.
-  }
-
-  @Test public void allAttributesSetInProxyAuthenticationCallbacks() throws Exception {
-    List<String> calls = authCallsForHeader("Proxy-Authenticate: Basic realm=\"Bar\"");
-    assertThat(calls.size()).isEqualTo(1);
-    URL url = server.url("/").url();
-    String call = calls.get(0);
-    assertThat(call).contains("host=" + url.getHost());
-    assertThat(call).contains("port=" + url.getPort());
-    assertThat(call).contains("site=" + url.getHost());
-    assertThat(call).contains("url=http://android.com");
-    assertThat(call).contains("type=" + Authenticator.RequestorType.PROXY);
-    assertThat(call).contains("prompt=Bar");
-    assertThat(call).contains("protocol=http");
-    assertThat(call.toLowerCase(US)).contains("scheme=basic");
-  }
-
-  private List<String> authCallsForHeader(String authHeader) throws IOException {
-    boolean proxy = authHeader.startsWith("Proxy-");
-    int responseCode = proxy ? 407 : 401;
-    RecordingAuthenticator authenticator = new RecordingAuthenticator(null);
-    Authenticator.setDefault(authenticator);
-    server.enqueue(new MockResponse()
-        .setResponseCode(responseCode)
-        .addHeader(authHeader)
-        .setBody("Please authenticate."));
-
-    Response response;
-    if (proxy) {
-      client = client.newBuilder()
-          .proxy(server.toProxyAddress())
-          .proxyAuthenticator(new JavaNetAuthenticator())
-          .build();
-      response = getResponse(newRequest(HttpUrl.get("http://android.com/")));
-    } else {
-      client = client.newBuilder()
-          .authenticator(new JavaNetAuthenticator())
-          .build();
-      response = getResponse(newRequest("/"));
-    }
-    assertThat(response.code()).isEqualTo(responseCode);
-    response.body().byteStream().close();
-    return authenticator.calls;
-  }
-
-  @Test public void setValidRequestMethod() {
-    assertMethodForbidsRequestBody("GET");
-    assertMethodPermitsRequestBody("DELETE");
-    assertMethodForbidsRequestBody("HEAD");
-    assertMethodPermitsRequestBody("OPTIONS");
-    assertMethodPermitsRequestBody("POST");
-    assertMethodPermitsRequestBody("PUT");
-    assertMethodPermitsRequestBody("TRACE");
-    assertMethodPermitsRequestBody("PATCH");
-
-    assertMethodPermitsNoRequestBody("GET");
-    assertMethodPermitsNoRequestBody("DELETE");
-    assertMethodPermitsNoRequestBody("HEAD");
-    assertMethodPermitsNoRequestBody("OPTIONS");
-    assertMethodForbidsNoRequestBody("POST");
-    assertMethodForbidsNoRequestBody("PUT");
-    assertMethodPermitsNoRequestBody("TRACE");
-    assertMethodForbidsNoRequestBody("PATCH");
-  }
-
-  private void assertMethodPermitsRequestBody(String requestMethod) {
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .method(requestMethod, RequestBody.create("abc", null))
-        .build();
-    assertThat(request.method()).isEqualTo(requestMethod);
-  }
-
-  private void assertMethodForbidsRequestBody(String requestMethod) {
-    try {
-      new Request.Builder()
-          .url(server.url("/"))
-          .method(requestMethod, RequestBody.create("abc", null))
-          .build();
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  private void assertMethodPermitsNoRequestBody(String requestMethod) {
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .method(requestMethod, null)
-        .build();
-    assertThat(request.method()).isEqualTo(requestMethod);
-  }
-
-  private void assertMethodForbidsNoRequestBody(String requestMethod) {
-    try {
-      new Request.Builder()
-          .url(server.url("/"))
-          .method(requestMethod, null)
-          .build();
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setInvalidRequestMethodLowercase() throws Exception {
-    assertValidRequestMethod("get");
-  }
-
-  @Test public void setInvalidRequestMethodConnect() throws Exception {
-    assertValidRequestMethod("CONNECT");
-  }
-
-  private void assertValidRequestMethod(String requestMethod) throws Exception {
-    server.enqueue(new MockResponse());
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .method(requestMethod, null)
-        .build());
-    assertThat(response.code()).isEqualTo(200);
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getMethod()).isEqualTo(requestMethod);
-  }
-
-  @Test public void shoutcast() throws Exception {
-    server.enqueue(new MockResponse()
-        .setStatus("ICY 200 OK")
-        .addHeader("Accept-Ranges: none")
-        .addHeader("Content-Type: audio/mpeg")
-        .addHeader("icy-br:128")
-        .addHeader("ice-audio-info: bitrate=128;samplerate=44100;channels=2")
-        .addHeader("icy-br:128")
-        .addHeader("icy-description:Rock")
-        .addHeader("icy-genre:riders")
-        .addHeader("icy-name:A2RRock")
-        .addHeader("icy-pub:1")
-        .addHeader("icy-url:http://www.A2Rradio.com")
-        .addHeader("Server: Icecast 2.3.3-kh8")
-        .addHeader("Cache-Control: no-cache")
-        .addHeader("Pragma: no-cache")
-        .addHeader("Expires: Mon, 26 Jul 1997 05:00:00 GMT")
-        .addHeader("icy-metaint:16000")
-        .setBody("mp3 data"));
-    Response response = getResponse(newRequest("/"));
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.message()).isEqualTo("OK");
-    assertContent("mp3 data", response);
-  }
-
-  @Test public void secureFixedLengthStreaming() throws Exception {
-    testSecureStreamingPost(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void secureChunkedStreaming() throws Exception {
-    testSecureStreamingPost(TransferKind.CHUNKED);
-  }
-
-  /**
-   * Users have reported problems using HTTPS with streaming request bodies.
-   * http://code.google.com/p/android/issues/detail?id=12860
-   */
-  private void testSecureStreamingPost(TransferKind streamingMode) throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setBody("Success!"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .post(streamingMode.newRequestBody("ABCD"))
-        .build());
-    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "Success!");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getRequestLine()).isEqualTo("POST / HTTP/1.1");
-    if (streamingMode == TransferKind.FIXED_LENGTH) {
-      assertThat(request.getChunkSizes()).isEqualTo(
-          Collections.<Integer>emptyList());
-    } else if (streamingMode == TransferKind.CHUNKED) {
-      assertThat(request.getChunkSizes()).containsExactly(4);
-    }
-    assertThat(request.getBody().readUtf8()).isEqualTo("ABCD");
-  }
-
-  @Test public void authenticateWithPost() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse()
-        .setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    // Fail auth three times...
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    // ...then succeed the fourth time.
-    server.enqueue(new MockResponse()
-        .setBody("Successful auth!"));
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    client = client.newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build();
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create("ABCD", null))
-        .build());
-    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "Successful auth!");
-
-    // No authorization header for the first request...
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getHeader("Authorization")).isNull();
-
-    // ...but the three requests that follow include an authorization header.
-    for (int i = 0; i < 3; i++) {
-      request = server.takeRequest();
-      assertThat(request.getRequestLine()).isEqualTo("POST / HTTP/1.1");
-      assertThat(request.getHeader("Authorization")).isEqualTo(
-          ("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS));
-      assertThat(request.getBody().readUtf8()).isEqualTo("ABCD");
-    }
-  }
-
-  @Test public void authenticateWithGet() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse()
-        .setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    // Fail auth three times...
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    // ...then succeed the fourth time.
-    server.enqueue(new MockResponse()
-        .setBody("Successful auth!"));
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    client = client.newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build();
-    Response response = getResponse(newRequest("/"));
-    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "Successful auth!");
-
-    // No authorization header for the first request...
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getHeader("Authorization")).isNull();
-
-    // ...but the three requests that follow requests include an authorization header.
-    for (int i = 0; i < 3; i++) {
-      request = server.takeRequest();
-      assertThat(request.getRequestLine()).isEqualTo("GET / HTTP/1.1");
-      assertThat(request.getHeader("Authorization")).isEqualTo(
-          ("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS));
-    }
-  }
-
-  @Test public void authenticateWithCharset() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\", charset=\"UTF-8\"")
-        .setBody("Please authenticate with UTF-8."));
-    server.enqueue(new MockResponse()
-        .setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate with ISO-8859-1."));
-    server.enqueue(new MockResponse()
-        .setBody("Successful auth!"));
-
-    Authenticator.setDefault(new RecordingAuthenticator(
-        new PasswordAuthentication("username", "mtorhead".toCharArray())));
-    client = client.newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build();
-    Response response = getResponse(newRequest("/"));
-    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "Successful auth!");
-
-    // No authorization header for the first request...
-    RecordedRequest request1 = server.takeRequest();
-    assertThat(request1.getHeader("Authorization")).isNull();
-
-    // UTF-8 encoding for the first credential.
-    RecordedRequest request2 = server.takeRequest();
-    assertThat(request2.getHeader("Authorization")).isEqualTo(
-        "Basic dXNlcm5hbWU6bcO2dG9yaGVhZA==");
-
-    // ISO-8859-1 encoding for the second credential.
-    RecordedRequest request3 = server.takeRequest();
-    assertThat(request3.getHeader("Authorization")).isEqualTo(
-        "Basic dXNlcm5hbWU6bfZ0b3JoZWFk");
-  }
-
-  /** https://code.google.com/p/android/issues/detail?id=74026 */
-  @Test public void authenticateWithGetAndTransparentGzip() throws Exception {
-    MockResponse pleaseAuthenticate = new MockResponse()
-        .setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate.");
-    // Fail auth three times...
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    server.enqueue(pleaseAuthenticate);
-    // ...then succeed the fourth time.
-    MockResponse successfulResponse = new MockResponse()
-        .addHeader("Content-Encoding", "gzip")
-        .setBody(gzip("Successful auth!"));
-    server.enqueue(successfulResponse);
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    client = client.newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build();
-    Response response = getResponse(newRequest("/"));
-    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "Successful auth!");
-
-    // no authorization header for the first request...
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getHeader("Authorization")).isNull();
-
-    // ...but the three requests that follow requests include an authorization header
-    for (int i = 0; i < 3; i++) {
-      request = server.takeRequest();
-      assertThat(request.getRequestLine()).isEqualTo("GET / HTTP/1.1");
-      assertThat(request.getHeader("Authorization")).isEqualTo(
-          ("Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS));
-    }
-  }
-
-  /** https://github.com/square/okhttp/issues/342 */
-  @Test public void authenticateRealmUppercase() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(401)
-        .addHeader("wWw-aUtHeNtIcAtE: bAsIc rEaLm=\"pRoTeCtEd aReA\"")
-        .setBody("Please authenticate."));
-    server.enqueue(new MockResponse()
-        .setBody("Successful auth!"));
-
-    Authenticator.setDefault(new RecordingAuthenticator());
-    client = client.newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build();
-    Response response = getResponse(newRequest("/"));
-    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "Successful auth!");
-  }
-
-  @Test public void redirectedWithChunkedEncoding() throws Exception {
-    testRedirected(TransferKind.CHUNKED, true);
-  }
-
-  @Test public void redirectedWithContentLengthHeader() throws Exception {
-    testRedirected(TransferKind.FIXED_LENGTH, true);
-  }
-
-  @Test public void redirectedWithNoLengthHeaders() throws Exception {
-    testRedirected(TransferKind.END_OF_STREAM, false);
-  }
-
-  private void testRedirected(TransferKind transferKind, boolean reuse) throws Exception {
-    MockResponse mockResponse = new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo");
-    transferKind.setBody(mockResponse, "This page has moved!", 10);
-    server.enqueue(mockResponse);
-    server.enqueue(new MockResponse()
-        .setBody("This is the new location!"));
-
-    Response response = getResponse(newRequest("/"));
-    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "This is the new location!");
-
-    RecordedRequest first = server.takeRequest();
-    assertThat(first.getRequestLine()).isEqualTo("GET / HTTP/1.1");
-    RecordedRequest retry = server.takeRequest();
-    assertThat(retry.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
-    if (reuse) {
-      assertThat(retry.getSequenceNumber()).overridingErrorMessage(
-          "Expected connection reuse").isEqualTo(1);
-    }
-  }
-
-  @Test public void redirectedOnHttps() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse()
-        .setBody("This is the new location!"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-    Response response = getResponse(newRequest("/"));
-    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "This is the new location!");
-
-    RecordedRequest first = server.takeRequest();
-    assertThat(first.getRequestLine()).isEqualTo("GET / HTTP/1.1");
-    RecordedRequest retry = server.takeRequest();
-    assertThat(retry.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
-    assertThat(retry.getSequenceNumber()).overridingErrorMessage(
-        "Expected connection reuse").isEqualTo(1);
-  }
-
-  @Test public void notRedirectedFromHttpsToHttp() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: http://anyhost/foo")
-        .setBody("This page has moved!"));
-
-    client = client.newBuilder()
-        .followSslRedirects(false)
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-    Response response = getResponse(newRequest("/"));
-    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "This page has moved!");
-  }
-
-  @Test public void notRedirectedFromHttpToHttps() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: https://anyhost/foo")
-        .setBody("This page has moved!"));
-
-    client = client.newBuilder()
-        .followSslRedirects(false)
-        .build();
-    Response response = getResponse(newRequest("/"));
-    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "This page has moved!");
-  }
-
-  @Test public void redirectedFromHttpsToHttpFollowingProtocolRedirects() throws Exception {
-    server2.enqueue(new MockResponse()
-        .setBody("This is insecure HTTP!"));
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/").url())
-        .setBody("This page has moved!"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .followSslRedirects(true)
-        .build();
-    Response response = getResponse(newRequest("/"));
-    assertContent("This is insecure HTTP!", response);
-    assertThat(response.handshake()).isNull();
-  }
-
-  @Test public void redirectedFromHttpToHttpsFollowingProtocolRedirects() throws Exception {
-    server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server2.enqueue(new MockResponse()
-        .setBody("This is secure HTTPS!"));
-
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/").url())
-        .setBody("This page has moved!"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .followSslRedirects(true)
-        .build();
-    Response response = getResponse(newRequest("/"));
-    assertContent("This is secure HTTPS!", response);
-  }
-
-  @Test public void redirectToAnotherOriginServer() throws Exception {
-    redirectToAnotherOriginServer(false);
-  }
-
-  @Test public void redirectToAnotherOriginServerWithHttps() throws Exception {
-    redirectToAnotherOriginServer(true);
-  }
-
-  private void redirectToAnotherOriginServer(boolean https) throws Exception {
-    if (https) {
-      server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-      server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
-      server2.setProtocolNegotiationEnabled(false);
-      client = client.newBuilder()
-          .sslSocketFactory(
-              handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-          .hostnameVerifier(new RecordingHostnameVerifier())
-          .build();
-    }
-
-    server2.enqueue(new MockResponse()
-        .setBody("This is the 2nd server!"));
-    server2.enqueue(new MockResponse()
-        .setBody("This is the 2nd server, again!"));
-
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/").url().toString())
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse()
-        .setBody("This is the first server again!"));
-
-    Response response = getResponse(newRequest("/"));
-    assertContent("This is the 2nd server!", response);
-    assertThat(response.request().url()).isEqualTo(server2.url("/"));
-
-    // make sure the first server was careful to recycle the connection
-    assertContent("This is the first server again!", getResponse(newRequest(server.url("/"))));
-    assertContent("This is the 2nd server, again!", getResponse(newRequest(server2.url("/"))));
-
-    String server1Host = server.getHostName() + ":" + server.getPort();
-    String server2Host = server2.getHostName() + ":" + server2.getPort();
-    assertThat(server.takeRequest().getHeader("Host")).isEqualTo(server1Host);
-    assertThat(server2.takeRequest().getHeader("Host")).isEqualTo(server2Host);
-    assertThat(server.takeRequest().getSequenceNumber()).overridingErrorMessage(
-        "Expected connection reuse").isEqualTo(1);
-    assertThat(server2.takeRequest().getSequenceNumber()).overridingErrorMessage(
-        "Expected connection reuse").isEqualTo(1);
-  }
-
-  @Test public void redirectWithProxySelector() throws Exception {
-    final List<URI> proxySelectionRequests = new ArrayList<>();
-    client = client.newBuilder()
-        .proxySelector(new ProxySelector() {
-          @Override public List<Proxy> select(URI uri) {
-            proxySelectionRequests.add(uri);
-            MockWebServer proxyServer = (uri.getPort() == server.getPort())
-                ? server
-                : server2;
-            return asList(proxyServer.toProxyAddress());
-          }
-
-          @Override public void connectFailed(URI uri, SocketAddress address, IOException failure) {
-            throw new AssertionError();
-          }
-        })
-        .build();
-
-    server2.enqueue(new MockResponse()
-        .setBody("This is the 2nd server!"));
-
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + server2.url("/b").toString())
-        .setBody("This page has moved!"));
-
-    assertContent("This is the 2nd server!", getResponse(newRequest("/a")));
-
-    assertThat(proxySelectionRequests).isEqualTo(
-        asList(server.url("/").url().toURI(), server2.url("/").url().toURI()));
-  }
-
-  @Test public void redirectWithAuthentication() throws Exception {
-    server2.enqueue(new MockResponse()
-        .setBody("Page 2"));
-
-    server.enqueue(new MockResponse()
-        .setResponseCode(401));
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: " + server2.url("/b")));
-
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret"), null))
-        .build();
-    assertContent("Page 2", getResponse(newRequest("/a")));
-
-    RecordedRequest redirectRequest = server2.takeRequest();
-    assertThat(redirectRequest.getHeader("Authorization")).isNull();
-    assertThat(redirectRequest.getPath()).isEqualTo("/b");
-  }
-
-  @Test public void response300MultipleChoiceWithPost() throws Exception {
-    // Chrome doesn't follow the redirect, but Firefox and the RI both do
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MULT_CHOICE, TransferKind.END_OF_STREAM);
-  }
-
-  @Test public void response301MovedPermanentlyWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_PERM, TransferKind.END_OF_STREAM);
-  }
-
-  @Test public void response302MovedTemporarilyWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.END_OF_STREAM);
-  }
-
-  @Test public void response303SeeOtherWithPost() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_SEE_OTHER, TransferKind.END_OF_STREAM);
-  }
-
-  @Test public void postRedirectToGetWithChunkedRequest() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.CHUNKED);
-  }
-
-  @Test public void postRedirectToGetWithStreamedRequest() throws Exception {
-    testResponseRedirectedWithPost(HttpURLConnection.HTTP_MOVED_TEMP, TransferKind.FIXED_LENGTH);
-  }
-
-  private void testResponseRedirectedWithPost(int redirectCode, TransferKind transferKind)
-      throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(redirectCode)
-        .addHeader("Location: /page2")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse()
-        .setBody("Page 2"));
-
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/page1"))
-        .post(transferKind.newRequestBody("ABCD"))
-        .build());
-    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "Page 2");
-
-    RecordedRequest page1 = server.takeRequest();
-    assertThat(page1.getRequestLine()).isEqualTo("POST /page1 HTTP/1.1");
-    assertThat(page1.getBody().readUtf8()).isEqualTo("ABCD");
-
-    RecordedRequest page2 = server.takeRequest();
-    assertThat(page2.getRequestLine()).isEqualTo("GET /page2 HTTP/1.1");
-  }
-
-  @Test public void redirectedPostStripsRequestBodyHeaders() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /page2"));
-    server.enqueue(new MockResponse()
-        .setBody("Page 2"));
-
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/page1"))
-        .post(RequestBody.create("ABCD", MediaType.get("text/plain; charset=utf-8")))
-        .header("Transfer-Encoding", "identity")
-        .build());
-    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "Page 2");
-
-    assertThat(server.takeRequest().getRequestLine()).isEqualTo(
-        "POST /page1 HTTP/1.1");
-
-    RecordedRequest page2 = server.takeRequest();
-    assertThat(page2.getRequestLine()).isEqualTo("GET /page2 HTTP/1.1");
-    assertThat(page2.getHeader("Content-Length")).isNull();
-    assertThat(page2.getHeader("Content-Type")).isNull();
-    assertThat(page2.getHeader("Transfer-Encoding")).isNull();
-  }
-
-  @Test public void response305UseProxy() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_USE_PROXY)
-        .addHeader("Location: " + server.url("/").url())
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse()
-        .setBody("Proxy Response"));
-
-    Response response = getResponse(newRequest("/foo"));
-    // Fails on the RI, which gets "Proxy Response".
-    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "This page has moved!");
-
-    RecordedRequest page1 = server.takeRequest();
-    assertThat(page1.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
-    assertThat(server.getRequestCount()).isEqualTo(1);
-  }
-
-  @Test public void response307WithGet() throws Exception {
-    testRedirect(true, "GET");
-  }
-
-  @Test public void response307WithHead() throws Exception {
-    testRedirect(true, "HEAD");
-  }
-
-  @Test public void response307WithOptions() throws Exception {
-    testRedirect(true, "OPTIONS");
-  }
-
-  @Test public void response307WithPost() throws Exception {
-    testRedirect(true, "POST");
-  }
-
-  @Test public void response308WithGet() throws Exception {
-    testRedirect(false, "GET");
-  }
-
-  @Test public void response308WithHead() throws Exception {
-    testRedirect(false, "HEAD");
-  }
-
-  @Test public void response308WithOptions() throws Exception {
-    testRedirect(false, "OPTIONS");
-  }
-
-  @Test public void response308WithPost() throws Exception {
-    testRedirect(false, "POST");
-  }
-
-  private void testRedirect(boolean temporary, String method) throws Exception {
-    MockResponse response1 = new MockResponse()
-        .setResponseCode(temporary ? HTTP_TEMP_REDIRECT : HTTP_PERM_REDIRECT)
-        .addHeader("Location: /page2");
-    if (!method.equals("HEAD")) {
-      response1.setBody("This page has moved!");
-    }
-    server.enqueue(response1);
-    server.enqueue(new MockResponse()
-        .setBody("Page 2"));
-
-    Request.Builder requestBuilder = new Request.Builder()
-        .url(server.url("/page1"));
-    if (method.equals("POST")) {
-      requestBuilder.post(RequestBody.create("ABCD", null));
-    } else {
-      requestBuilder.method(method, null);
-    }
-
-    Response response = getResponse(requestBuilder.build());
-    String responseString = readAscii(response.body().byteStream(), Integer.MAX_VALUE);
-
-    RecordedRequest page1 = server.takeRequest();
-    assertThat(page1.getRequestLine()).isEqualTo((method + " /page1 HTTP/1.1"));
-
-    if (method.equals("GET")) {
-      assertThat(responseString).isEqualTo("Page 2");
-    } else if (method.equals("HEAD")) {
-      assertThat(responseString).isEqualTo("");
-    } else {
-      // Methods other than GET/HEAD shouldn't follow the redirect.
-      if (method.equals("POST")) {
-        assertThat(page1.getBody().readUtf8()).isEqualTo("ABCD");
-      }
-      assertThat(server.getRequestCount()).isEqualTo(1);
-      assertThat(responseString).isEqualTo("This page has moved!");
-      return;
-    }
-
-    // GET/HEAD requests should have followed the redirect with the same method.
-    assertThat(server.getRequestCount()).isEqualTo(2);
-    RecordedRequest page2 = server.takeRequest();
-    assertThat(page2.getRequestLine()).isEqualTo((method + " /page2 HTTP/1.1"));
-  }
-
-  @Test public void follow20Redirects() throws Exception {
-    for (int i = 0; i < 20; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-    server.enqueue(new MockResponse()
-        .setBody("Success!"));
-
-    Response response = getResponse(newRequest("/0"));
-    assertContent("Success!", response);
-    assertThat(response.request().url()).isEqualTo(server.url("/20"));
-  }
-
-  @Test public void doesNotFollow21Redirects() throws Exception {
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-          .addHeader("Location: /" + (i + 1))
-          .setBody("Redirecting to /" + (i + 1)));
-    }
-
-    try {
-      getResponse(newRequest("/0"));
-      fail();
-    } catch (ProtocolException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "Too many follow-up requests: 21");
-    }
-  }
-
-  @Test public void httpsWithCustomTrustManager() throws Exception {
-    RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-    RecordingTrustManager trustManager =
-        new RecordingTrustManager(handshakeCertificates.trustManager());
-    SSLContext sslContext = Platform.get().newSSLContext();
-    sslContext.init(null, new TrustManager[] {trustManager}, null);
-
-    client = client.newBuilder()
-        .hostnameVerifier(hostnameVerifier)
-        .sslSocketFactory(sslContext.getSocketFactory(), trustManager)
-        .build();
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-    server.enqueue(new MockResponse()
-        .setBody("GHI"));
-
-    assertContent("ABC", getResponse(newRequest("/")));
-    assertContent("DEF", getResponse(newRequest("/")));
-    assertContent("GHI", getResponse(newRequest("/")));
-
-    assertThat(hostnameVerifier.calls).isEqualTo(
-        asList("verify " + server.getHostName()));
-    assertThat(trustManager.calls).isEqualTo(
-        asList("checkServerTrusted [CN=localhost 1]"));
-  }
-
-  @Test public void getClientRequestTimeout() throws Exception {
-    enqueueClientRequestTimeoutResponses();
-
-    Response response = getResponse(newRequest("/"));
-
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "Body");
-  }
-
-  private void enqueueClientRequestTimeoutResponses() {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(HttpURLConnection.HTTP_CLIENT_TIMEOUT)
-        .setHeader("Connection", "Close")
-        .setBody("You took too long!"));
-    server.enqueue(new MockResponse()
-        .setBody("Body"));
-  }
-
-  @Test public void bufferedBodyWithClientRequestTimeout() throws Exception {
-    enqueueClientRequestTimeoutResponses();
-
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create("Hello", null))
-        .build());
-
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "Body");
-
-    RecordedRequest request1 = server.takeRequest();
-    assertThat(request1.getBody().readUtf8()).isEqualTo("Hello");
-
-    RecordedRequest request2 = server.takeRequest();
-    assertThat(request2.getBody().readUtf8()).isEqualTo("Hello");
-  }
-
-  @Test public void streamedBodyWithClientRequestTimeout() throws Exception {
-    enqueueClientRequestTimeoutResponses();
-
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .post(TransferKind.CHUNKED.newRequestBody("Hello"))
-        .build());
-
-    assertThat(response.code()).isEqualTo(200);
-    assertContent("Body", response);
-    response.close();
-    assertThat(server.getRequestCount()).isEqualTo(2);
-  }
-
-  @Test public void readTimeouts() throws IOException {
-    // This relies on the fact that MockWebServer doesn't close the
-    // connection after a response has been sent. This causes the client to
-    // try to read more bytes than are sent, which results in a timeout.
-    server.enqueue(new MockResponse()
-        .setBody("ABC")
-        .clearHeaders()
-        .addHeader("Content-Length: 4"));
-    server.enqueue(new MockResponse()
-        .setBody("unused")); // to keep the server alive
-
-    Response response = getResponse(newRequest("/"));
-    BufferedSource in = response.body().source();
-    in.timeout().timeout(1000, MILLISECONDS);
-    assertThat(in.readByte()).isEqualTo((byte) 'A');
-    assertThat(in.readByte()).isEqualTo((byte) 'B');
-    assertThat(in.readByte()).isEqualTo((byte) 'C');
-    try {
-      in.readByte(); // If Content-Length was accurate, this would return -1 immediately.
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-    in.close();
-  }
-
-  /** Confirm that an unacknowledged write times out. */
-  @Test public void writeTimeouts() throws IOException {
-    MockWebServer server = new MockWebServer();
-    // Sockets on some platforms can have large buffers that mean writes do not block when
-    // required. These socket factories explicitly set the buffer sizes on sockets created.
-    final int SOCKET_BUFFER_SIZE = 4 * 1024;
-    server.setServerSocketFactory(
-        new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
-          @Override
-          protected ServerSocket configureServerSocket(ServerSocket serverSocket)
-              throws IOException {
-            serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-            return serverSocket;
-          }
-        });
-    client = client.newBuilder()
-        .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
-          @Override protected Socket configureSocket(Socket socket) throws IOException {
-            socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-            socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
-            return socket;
-          }
-        })
-        .writeTimeout(500, TimeUnit.MILLISECONDS)
-        .build();
-
-    server.start();
-    server.enqueue(new MockResponse()
-        .throttleBody(1, 1, TimeUnit.SECONDS)); // Prevent the server from reading!
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(new RequestBody() {
-          @Override public @Nullable MediaType contentType() {
-            return null;
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            byte[] data = new byte[2 * 1024 * 1024]; // 2 MiB.
-            sink.write(data);
-          }
-        })
-        .build();
-    try {
-      getResponse(request);
-      fail();
-    } catch (SocketTimeoutException expected) {
-    }
-  }
-
-  @Test public void setChunkedEncodingAsRequestProperty() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .header("Transfer-encoding", "chunked")
-        .post(TransferKind.CHUNKED.newRequestBody("ABC"))
-        .build());
-    assertThat(response.code()).isEqualTo(200);
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getBody().readUtf8()).isEqualTo("ABC");
-  }
-
-  @Test public void connectionCloseInRequest() throws Exception {
-    server.enqueue(new MockResponse()); // Server doesn't honor the connection: close header!
-    server.enqueue(new MockResponse());
-
-    Response a = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .header("Connection", "close")
-        .build());
-    assertThat(a.code()).isEqualTo(200);
-
-    Response b = getResponse(newRequest("/"));
-    assertThat(b.code()).isEqualTo(200);
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).overridingErrorMessage(
-        "When connection: close is used, each request should get its own connection").isEqualTo(
-        (long) 0);
-  }
-
-  @Test public void connectionCloseInResponse() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Connection: close"));
-    server.enqueue(new MockResponse());
-
-    Response a = getResponse(newRequest("/"));
-    assertThat(a.code()).isEqualTo(200);
-
-    Response b = getResponse(newRequest("/"));
-    assertThat(b.code()).isEqualTo(200);
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).overridingErrorMessage(
-        "When connection: close is used, each request should get its own connection").isEqualTo(
-        (long) 0);
-  }
-
-  @Test public void connectionCloseWithRedirect() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .addHeader("Connection: close"));
-    server.enqueue(new MockResponse()
-        .setBody("This is the new location!"));
-
-    Response response = getResponse(newRequest("/"));
-    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "This is the new location!");
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).overridingErrorMessage(
-        "When connection: close is used, each request should get its own connection").isEqualTo(
-        (long) 0);
-  }
-
-  /**
-   * Retry redirects if the socket is closed.
-   * https://code.google.com/p/android/issues/detail?id=41576
-   */
-  @Test public void sameConnectionRedirectAndReuse() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .setSocketPolicy(SHUTDOWN_INPUT_AT_END)
-        .addHeader("Location: /foo"));
-    server.enqueue(new MockResponse()
-        .setBody("This is the new page!"));
-
-    assertContent("This is the new page!", getResponse(newRequest("/")));
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void responseCodeDisagreesWithHeaders() {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NO_CONTENT)
-        .setBody("This body is not allowed!"));
-
-    try {
-      getResponse(newRequest("/"));
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "HTTP 204 had non-zero Content-Length: 25");
-    }
-  }
-
-  @Test public void singleByteReadIsSigned() throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody(new Buffer()
-            .writeByte(-2)
-            .writeByte(-1)));
-
-    Response response = getResponse(newRequest("/"));
-    InputStream in = response.body().byteStream();
-    assertThat(in.read()).isEqualTo(254);
-    assertThat(in.read()).isEqualTo(255);
-    assertThat(in.read()).isEqualTo(-1);
-  }
-
-  @Test public void flushAfterStreamTransmittedWithChunkedEncoding() throws IOException {
-    testFlushAfterStreamTransmitted(TransferKind.CHUNKED);
-  }
-
-  @Test public void flushAfterStreamTransmittedWithFixedLength() throws IOException {
-    testFlushAfterStreamTransmitted(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void flushAfterStreamTransmittedWithNoLengthHeaders() throws IOException {
-    testFlushAfterStreamTransmitted(TransferKind.END_OF_STREAM);
-  }
-
-  /**
-   * We explicitly permit apps to close the upload stream even after it has been transmitted.  We
-   * also permit flush so that buffered streams can do a no-op flush when they are closed.
-   * http://b/3038470
-   */
-  private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws IOException {
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    AtomicReference<BufferedSink> sinkReference = new AtomicReference<>();
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .post(new ForwardingRequestBody(transferKind.newRequestBody("def")) {
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            sinkReference.set(sink);
-            super.writeTo(sink);
-          }
-        })
-        .build());
-
-    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "abc");
-
-    try {
-      sinkReference.get().flush();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      sinkReference.get().write("ghi".getBytes(UTF_8));
-      sinkReference.get().emit();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void getHeadersThrows() {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(DISCONNECT_AT_START));
-
-    try {
-      getResponse(newRequest("/"));
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void dnsFailureThrowsIOException() {
-    client = client.newBuilder()
-        .dns(new FakeDns())
-        .build();
-    try {
-      getResponse(newRequest(HttpUrl.get("http://host.unlikelytld")));
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void malformedUrlThrowsUnknownHostException() throws IOException {
-    try {
-      getResponse(newRequest(HttpUrl.get("http://./foo.html")));
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
-  @Test public void getKeepAlive() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-
-    // The request should work once and then fail.
-    Response connection1 = getResponse(newRequest("/"));
-    BufferedSource source1 = connection1.body().source();
-    source1.timeout().timeout(100, TimeUnit.MILLISECONDS);
-    assertThat(readAscii(source1.inputStream(), Integer.MAX_VALUE)).isEqualTo(
-        "ABC");
-    server.shutdown();
-    try {
-      getResponse(newRequest("/"));
-      fail();
-    } catch (ConnectException expected) {
-    }
-  }
-
-  /** http://code.google.com/p/android/issues/detail?id=14562 */
-  @Test public void readAfterLastByte() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("ABC")
-        .clearHeaders()
-        .addHeader("Connection: close")
-        .setSocketPolicy(DISCONNECT_AT_END));
-
-    Response response = getResponse(newRequest("/"));
-    InputStream in = response.body().byteStream();
-    assertThat(readAscii(in, 3)).isEqualTo("ABC");
-    assertThat(in.read()).isEqualTo(-1);
-    // throws IOException in Gingerbread.
-    assertThat(in.read()).isEqualTo(-1);
-  }
-
-  @Test public void getOutputStreamOnGetFails() {
-    try {
-      new Request.Builder()
-          .url(server.url("/"))
-          .method("GET", RequestBody.create("abc", null))
-          .build();
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void clientSendsContentLength() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create("ABC", null))
-        .build());
-    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "A");
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getHeader("Content-Length")).isEqualTo("3");
-    response.body().close();
-  }
-
-  @Test public void getContentLengthConnects() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-    Response response = getResponse(newRequest("/"));
-    assertThat(response.body().contentLength()).isEqualTo(3L);
-    response.body().close();
-  }
-
-  @Test public void getContentTypeConnects() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Content-Type: text/plain")
-        .setBody("ABC"));
-    Response response = getResponse(newRequest("/"));
-    assertThat(response.body().contentType()).isEqualTo(
-        MediaType.get("text/plain"));
-    response.body().close();
-  }
-
-  @Test public void getContentEncodingConnects() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Content-Encoding: identity")
-        .setBody("ABC"));
-    Response response = getResponse(newRequest("/"));
-    assertThat(response.header("Content-Encoding")).isEqualTo("identity");
-    response.body().close();
-  }
-
-  @Test public void urlContainsQueryButNoPath() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    HttpUrl url = server.url("?query");
-    Response response = getResponse(newRequest(url));
-    assertThat(readAscii(response.body().byteStream(), Integer.MAX_VALUE)).isEqualTo(
-        "A");
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getRequestLine()).isEqualTo("GET /?query HTTP/1.1");
-  }
-
-  @Test public void doOutputForMethodThatDoesntSupportOutput() {
-    try {
-      new Request.Builder()
-          .url(server.url("/"))
-          .method("HEAD", RequestBody.create("", null))
-          .build();
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  // http://code.google.com/p/android/issues/detail?id=20442
-  @Test public void inputStreamAvailableWithChunkedEncoding() throws Exception {
-    testInputStreamAvailable(TransferKind.CHUNKED);
-  }
-
-  @Test public void inputStreamAvailableWithContentLengthHeader() throws Exception {
-    testInputStreamAvailable(TransferKind.FIXED_LENGTH);
-  }
-
-  @Test public void inputStreamAvailableWithNoLengthHeaders() throws Exception {
-    testInputStreamAvailable(TransferKind.END_OF_STREAM);
-  }
-
-  private void testInputStreamAvailable(TransferKind transferKind) throws IOException {
-    String body = "ABCDEFGH";
-    MockResponse mockResponse = new MockResponse();
-    transferKind.setBody(mockResponse, body, 4);
-    server.enqueue(mockResponse);
-    Response response = getResponse(newRequest("/"));
-    InputStream in = response.body().byteStream();
-    for (int i = 0; i < body.length(); i++) {
-      assertThat(in.available()).isGreaterThanOrEqualTo(0);
-      assertThat(in.read()).isEqualTo(body.charAt(i));
-    }
-    assertThat(in.available()).isEqualTo(0);
-    assertThat(in.read()).isEqualTo(-1);
-  }
-
-  @Test public void postFailsWithBufferedRequestForSmallRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.END_OF_STREAM, 1024);
-  }
-
-  @Test public void postFailsWithBufferedRequestForLargeRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.END_OF_STREAM, 16384);
-  }
-
-  @Test public void postFailsWithChunkedRequestForSmallRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.CHUNKED, 1024);
-  }
-
-  @Test public void postFailsWithChunkedRequestForLargeRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.CHUNKED, 16384);
-  }
-
-  @Test public void postFailsWithFixedLengthRequestForSmallRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.FIXED_LENGTH, 1024);
-  }
-
-  @Test public void postFailsWithFixedLengthRequestForLargeRequest() throws Exception {
-    reusedConnectionFailsWithPost(TransferKind.FIXED_LENGTH, 16384);
-  }
-
-  private void reusedConnectionFailsWithPost(TransferKind transferKind, int requestSize)
-      throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .setSocketPolicy(DISCONNECT_AT_END));
-    server.enqueue(new MockResponse()
-        .setBody("B"));
-    server.enqueue(new MockResponse()
-        .setBody("C"));
-
-    assertContent("A", getResponse(newRequest("/a")));
-
-    // Give the server time to disconnect.
-    Thread.sleep(500);
-
-    // If the request body is larger than OkHttp's replay buffer, the failure may still occur.
-    char[] requestBodyChars = new char[requestSize];
-    Arrays.fill(requestBodyChars, 'x');
-    String requestBody = new String(requestBodyChars);
-
-    for (int j = 0; j < 2; j++) {
-      try {
-        Response response = getResponse(new Request.Builder()
-            .url(server.url("/b"))
-            .post(transferKind.newRequestBody(requestBody))
-            .build());
-        assertContent("B", response);
-        break;
-      } catch (IOException socketException) {
-        // If there's a socket exception, this must have a streamed request body.
-        assertThat(j).isEqualTo(0);
-        assertThat(transferKind).isIn(TransferKind.CHUNKED, TransferKind.FIXED_LENGTH);
-      }
-    }
-
-    RecordedRequest requestA = server.takeRequest();
-    assertThat(requestA.getPath()).isEqualTo("/a");
-    RecordedRequest requestB = server.takeRequest();
-    assertThat(requestB.getPath()).isEqualTo("/b");
-    assertThat(requestB.getBody().readUtf8()).isEqualTo(requestBody);
-  }
-
-  @Test public void postBodyRetransmittedOnFailureRecovery() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(DISCONNECT_AFTER_REQUEST));
-    server.enqueue(new MockResponse()
-        .setBody("def"));
-
-    // Seed the connection pool so we have something that can fail.
-    assertContent("abc", getResponse(newRequest("/")));
-
-    Response post = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create("body!", null))
-        .build());
-    assertContent("def", post);
-
-    RecordedRequest get = server.takeRequest();
-    assertThat(get.getSequenceNumber()).isEqualTo(0);
-
-    RecordedRequest post1 = server.takeRequest();
-    assertThat(post1.getBody().readUtf8()).isEqualTo("body!");
-    assertThat(post1.getSequenceNumber()).isEqualTo(1);
-
-    RecordedRequest post2 = server.takeRequest();
-    assertThat(post2.getBody().readUtf8()).isEqualTo("body!");
-    assertThat(post2.getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void fullyBufferedPostIsTooShort() {
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    RequestBody requestBody = new RequestBody() {
-      @Override public @Nullable MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return 4L;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.writeUtf8("abc");
-      }
-    };
-    try {
-      getResponse(new Request.Builder()
-          .url(server.url("/b"))
-          .post(requestBody)
-          .build());
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void fullyBufferedPostIsTooLong() {
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    RequestBody requestBody = new RequestBody() {
-      @Override public @Nullable MediaType contentType() {
-        return null;
-      }
-
-      @Override public long contentLength() {
-        return 3L;
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        sink.writeUtf8("abcd");
-      }
-    };
-    try {
-      getResponse(new Request.Builder()
-          .url(server.url("/b"))
-          .post(requestBody)
-          .build());
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test @Ignore public void testPooledConnectionsDetectHttp10() {
-    // TODO: write a test that shows pooled connections detect HTTP/1.0 (vs. HTTP/1.1)
-    fail("TODO");
-  }
-
-  @Test @Ignore public void postBodiesRetransmittedOnAuthProblems() {
-    fail("TODO");
-  }
-
-  @Test @Ignore public void cookiesAndTrailers() {
-    // Do cookie headers get processed too many times?
-    fail("TODO");
-  }
-
-  @Test public void emptyRequestHeaderValueIsAllowed() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("body"));
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .header("B", "")
-        .build());
-    assertContent("body", response);
-    assertThat(response.request().header("B")).isEqualTo("");
-  }
-
-  @Test public void emptyResponseHeaderValueIsAllowed() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("A:")
-        .setBody("body"));
-    Response response = getResponse(newRequest("/"));
-    assertContent("body", response);
-    assertThat(response.header("A")).isEqualTo("");
-  }
-
-  @Test public void emptyRequestHeaderNameIsStrict() {
-    try {
-      new Request.Builder()
-          .url(server.url("/"))
-          .header("", "A")
-          .build();
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void emptyResponseHeaderNameIsLenient() throws Exception {
-    Headers.Builder headers = new Headers.Builder();
-    Internal.addHeaderLenient(headers, ":A");
-    server.enqueue(new MockResponse()
-        .setHeaders(headers.build())
-        .setBody("body"));
-    Response response = getResponse(newRequest("/"));
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.header("")).isEqualTo("A");
-    response.body().close();
-  }
-
-  @Test public void requestHeaderValidationIsStrict() {
-    try {
-      new Request.Builder()
-          .addHeader("a\tb", "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      new Request.Builder()
-          .addHeader("Name", "c\u007fd");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      new Request.Builder()
-          .addHeader("", "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      new Request.Builder()
-          .addHeader("\ud83c\udf69", "Value");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-    try {
-      new Request.Builder()
-          .addHeader("Name", "\u2615\ufe0f");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void responseHeaderParsingIsLenient() throws Exception {
-    Headers.Builder headersBuilder = new Headers.Builder();
-    headersBuilder.add("Content-Length", "0");
-    addHeaderLenient(headersBuilder, "a\tb: c\u007fd");
-    addHeaderLenient(headersBuilder, ": ef");
-    addHeaderLenient(headersBuilder, "\ud83c\udf69: \u2615\ufe0f");
-    Headers headers = headersBuilder.build();
-    server.enqueue(new MockResponse()
-        .setHeaders(headers));
-
-    Response response = getResponse(newRequest("/"));
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.header("a\tb")).isEqualTo("c\u007fd");
-    assertThat(response.header("\ud83c\udf69")).isEqualTo("\u2615\ufe0f");
-    assertThat(response.header("")).isEqualTo("ef");
-  }
-
-  @Test @Ignore public void deflateCompression() {
-    fail("TODO");
-  }
-
-  @Test @Ignore public void postBodiesRetransmittedOnIpAddressProblems() {
-    fail("TODO");
-  }
-
-  @Test @Ignore public void pooledConnectionProblemsNotReportedToProxySelector() {
-    fail("TODO");
-  }
-
-  @Test public void customBasicAuthenticator() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate."));
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    String credential = Credentials.basic("jesse", "peanutbutter");
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(credential, null);
-    client = client.newBuilder()
-        .authenticator(authenticator)
-        .build();
-    assertContent("A", getResponse(newRequest("/private")));
-
-    assertThat(server.takeRequest().getHeader("Authorization")).isNull();
-    assertThat(server.takeRequest().getHeader("Authorization")).isEqualTo(
-        credential);
-
-    assertThat(authenticator.onlyRoute().proxy()).isEqualTo(Proxy.NO_PROXY);
-    Response response = authenticator.onlyResponse();
-    assertThat(response.request().url().url().getPath()).isEqualTo("/private");
-    assertThat(response.challenges()).isEqualTo(
-        asList(new Challenge("Basic", "protected area")));
-  }
-
-  @Test public void customTokenAuthenticator() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(401)
-        .addHeader("WWW-Authenticate: Bearer realm=\"oauthed\"")
-        .setBody("Please authenticate."));
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-
-    RecordingOkAuthenticator authenticator
-        = new RecordingOkAuthenticator("oauthed abc123", "Bearer");
-    client = client.newBuilder()
-        .authenticator(authenticator)
-        .build();
-    assertContent("A", getResponse(newRequest("/private")));
-
-    assertThat(server.takeRequest().getHeader("Authorization")).isNull();
-    assertThat(server.takeRequest().getHeader("Authorization")).isEqualTo(
-        "oauthed abc123");
-
-    Response response = authenticator.onlyResponse();
-    assertThat(response.request().url().url().getPath()).isEqualTo("/private");
-    assertThat(response.challenges()).isEqualTo(
-        asList(new Challenge("Bearer", "oauthed")));
-  }
-
-  @Test public void authenticateCallsTrackedAsRedirects() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeader("Location: /b"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(401)
-        .addHeader("WWW-Authenticate: Basic realm=\"protected area\""));
-    server.enqueue(new MockResponse()
-        .setBody("c"));
-
-    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(
-        Credentials.basic("jesse", "peanutbutter"), "Basic");
-    client = client.newBuilder()
-        .authenticator(authenticator)
-        .build();
-    assertContent("c", getResponse(newRequest("/a")));
-
-    Response challengeResponse = authenticator.responses.get(0);
-    assertThat(challengeResponse.request().url().url().getPath()).isEqualTo(
-        "/b");
-
-    Response redirectedBy = challengeResponse.priorResponse();
-    assertThat(redirectedBy.request().url().url().getPath()).isEqualTo("/a");
-  }
-
-  @Test public void attemptAuthorization20Times() throws Exception {
-    for (int i = 0; i < 20; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(401));
-    }
-    server.enqueue(new MockResponse()
-        .setBody("Success!"));
-
-    String credential = Credentials.basic("jesse", "peanutbutter");
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential, null))
-        .build();
-
-    Response response = getResponse(newRequest("/0"));
-    assertContent("Success!", response);
-  }
-
-  @Test public void doesNotAttemptAuthorization21Times() throws Exception {
-    for (int i = 0; i < 21; i++) {
-      server.enqueue(new MockResponse()
-          .setResponseCode(401));
-    }
-
-    String credential = Credentials.basic("jesse", "peanutbutter");
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential, null))
-        .build();
-
-    try {
-      getResponse(newRequest("/"));
-      fail();
-    } catch (ProtocolException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "Too many follow-up requests: 21");
-    }
-  }
-
-  @Test public void setsNegotiatedProtocolHeader_HTTP_2() throws Exception {
-    platform.assumeHttp2Support();
-
-    setsNegotiatedProtocolHeader(Protocol.HTTP_2);
-  }
-
-  private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException {
-    enableProtocol(protocol);
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-    client = client.newBuilder()
-        .protocols(asList(protocol, Protocol.HTTP_1_1))
-        .build();
-    Response response = getResponse(newRequest("/"));
-    assertThat(response.protocol()).isEqualTo(protocol);
-    assertContent("A", response);
-  }
-
-  @Test public void http10SelectedProtocol() throws IOException {
-    server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.0 200 OK"));
-    Response response = getResponse(newRequest("/"));
-    assertThat(response.protocol()).isEqualTo(Protocol.HTTP_1_0);
-  }
-
-  @Test public void http11SelectedProtocol() throws IOException {
-    server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 200 OK"));
-    Response response = getResponse(newRequest("/"));
-    assertThat(response.protocol()).isEqualTo(Protocol.HTTP_1_1);
-  }
-
-  /** For example, empty Protobuf RPC messages end up as a zero-length POST. */
-  @Test public void zeroLengthPost() throws Exception {
-    zeroLengthPayload("POST");
-  }
-
-  @Test public void zeroLengthPost_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    zeroLengthPost();
-  }
-
-  /** For example, creating an Amazon S3 bucket ends up as a zero-length POST. */
-  @Test public void zeroLengthPut() throws Exception {
-    zeroLengthPayload("PUT");
-  }
-
-  @Test public void zeroLengthPut_HTTP_2() throws Exception {
-    enableProtocol(Protocol.HTTP_2);
-    zeroLengthPut();
-  }
-
-  private void zeroLengthPayload(String method) throws Exception {
-    server.enqueue(new MockResponse());
-
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .method(method, RequestBody.create("", null))
-        .build());
-    assertContent("", response);
-    RecordedRequest zeroLengthPayload = server.takeRequest();
-    assertThat(zeroLengthPayload.getMethod()).isEqualTo(method);
-    assertThat(zeroLengthPayload.getHeader("content-length")).isEqualTo("0");
-    assertThat(zeroLengthPayload.getBodySize()).isEqualTo(0L);
-  }
-
-  @Test public void setProtocols() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("A"));
-    client = client.newBuilder()
-        .protocols(asList(Protocol.HTTP_1_1))
-        .build();
-    assertContent("A", getResponse(newRequest("/")));
-  }
-
-  @Test public void setProtocolsWithoutHttp11() {
-    try {
-      new OkHttpClient.Builder()
-          .protocols(asList(Protocol.HTTP_2));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setProtocolsWithNull() {
-    try {
-      new OkHttpClient.Builder()
-          .protocols(asList(Protocol.HTTP_1_1, null));
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void veryLargeFixedLengthRequest() throws Exception {
-    server.setBodyLimit(0);
-    server.enqueue(new MockResponse());
-
-    long contentLength = Integer.MAX_VALUE + 1L;
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .post(new RequestBody() {
-          @Override public @Nullable MediaType contentType() {
-            return null;
-          }
-
-          @Override public long contentLength() {
-            return contentLength;
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            byte[] buffer = new byte[1024 * 1024];
-            for (long bytesWritten = 0; bytesWritten < contentLength; ) {
-              int byteCount = (int) Math.min(buffer.length, contentLength - bytesWritten);
-              bytesWritten += byteCount;
-              sink.write(buffer, 0, byteCount);
-            }
-          }
-        })
-        .build());
-
-    assertContent("", response);
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getHeader("Content-Length")).isEqualTo(
-        Long.toString(contentLength));
-  }
-
-  @Test public void testNoSslFallback() throws Exception {
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false /* tunnelProxy */);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(FAIL_HANDSHAKE));
-    server.enqueue(new MockResponse()
-        .setBody("Response that would have needed fallbacks"));
-
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .build();
-    try {
-      getResponse(newRequest("/"));
-      fail();
-    } catch (SSLProtocolException expected) {
-      // RI response to the FAIL_HANDSHAKE
-    } catch (SSLHandshakeException expected) {
-      // Android's response to the FAIL_HANDSHAKE
-    } catch (SSLException expected) {
-      // JDK 1.9 response to the FAIL_HANDSHAKE
-      // javax.net.ssl.SSLException: Unexpected handshake message: client_hello
-    } catch (SocketException expected) {
-      // Conscrypt's response to the FAIL_HANDSHAKE
-    }
-  }
-
-  /**
-   * We had a bug where we attempted to gunzip responses that didn't have a body. This only came up
-   * with 304s since that response code can include headers (like "Content-Encoding") without any
-   * content to go along with it. https://github.com/square/okhttp/issues/358
-   */
-  @Test public void noTransparentGzipFor304NotModified() throws Exception {
-    server.enqueue(new MockResponse()
-        .clearHeaders()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
-        .addHeader("Content-Encoding: gzip"));
-    server.enqueue(new MockResponse()
-        .setBody("b"));
-
-    Response response1 = getResponse(newRequest("/"));
-    assertThat(response1.code()).isEqualTo(
-        (long) HttpURLConnection.HTTP_NOT_MODIFIED);
-    assertContent("", response1);
-
-    Response response2 = getResponse(newRequest("/"));
-    assertThat(response2.code()).isEqualTo(HttpURLConnection.HTTP_OK);
-    assertContent("b", response2);
-
-    RecordedRequest requestA = server.takeRequest();
-    assertThat(requestA.getSequenceNumber()).isEqualTo(0);
-
-    RecordedRequest requestB = server.takeRequest();
-    assertThat(requestB.getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void nullSSLSocketFactory_throws() {
-    try {
-      client.newBuilder().sslSocketFactory(null);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  /**
-   * We had a bug where we weren't closing Gzip streams on redirects.
-   * https://github.com/square/okhttp/issues/441
-   */
-  @Test public void gzipWithRedirectAndConnectionReuse() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .addHeader("Content-Encoding: gzip")
-        .setBody(gzip("Moved! Moved! Moved!")));
-    server.enqueue(new MockResponse()
-        .setBody("This is the new page!"));
-
-    Response response = getResponse(newRequest("/"));
-    assertContent("This is the new page!", response);
-
-    RecordedRequest requestA = server.takeRequest();
-    assertThat(requestA.getSequenceNumber()).isEqualTo(0);
-
-    RecordedRequest requestB = server.takeRequest();
-    assertThat(requestB.getSequenceNumber()).isEqualTo(1);
-  }
-
-  /**
-   * The RFC is unclear in this regard as it only specifies that this should invalidate the cache
-   * entry (if any).
-   */
-  @Test public void bodyPermittedOnDelete() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Response response = getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .delete(RequestBody.create("BODY", null))
-        .build());
-    assertThat(response.code()).isEqualTo(200);
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getMethod()).isEqualTo("DELETE");
-    assertThat(request.getBody().readUtf8()).isEqualTo("BODY");
-  }
-
-  @Test public void userAgentDefaultsToOkHttpVersion() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    assertContent("abc", getResponse(newRequest("/")));
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getHeader("User-Agent")).isEqualTo(Version.userAgent);
-  }
-
-  @Test public void urlWithSpaceInHost() {
-    try {
-      HttpUrl.get("http://and roid.com/");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void urlWithSpaceInHostViaHttpProxy() {
-    try {
-      HttpUrl.get("http://and roid.com/");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void urlHostWithNul() {
-    try {
-      HttpUrl.get("http://host\u0000/");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void urlRedirectToHostWithNul() throws Exception {
-    String redirectUrl = "http://host\u0000/";
-    server.enqueue(new MockResponse()
-        .setResponseCode(302)
-        .addHeaderLenient("Location", redirectUrl));
-
-    Response response = getResponse(newRequest("/"));
-    assertThat(response.code()).isEqualTo(302);
-    assertThat(response.header("Location")).isEqualTo(redirectUrl);
-  }
-
-  @Test public void urlWithBadAsciiHost() {
-    try {
-      HttpUrl.get("http://host\u0001/");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void setSslSocketFactoryFailsOnJdk9() {
-    platform.assumeJdk9();
-
-    try {
-      client.newBuilder()
-          .sslSocketFactory(handshakeCertificates.sslSocketFactory());
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
-  }
-
-  /** Confirm that runtime exceptions thrown inside of OkHttp propagate to the caller. */
-  @Test public void unexpectedExceptionSync() throws Exception {
-    client = client.newBuilder()
-        .dns(hostname -> {
-          throw new RuntimeException("boom!");
-        })
-        .build();
-
-    server.enqueue(new MockResponse());
-
-    try {
-      getResponse(newRequest("/"));
-      fail();
-    } catch (RuntimeException expected) {
-      assertThat(expected.getMessage()).isEqualTo("boom!");
-    }
-  }
-
-  @Test public void streamedBodyIsRetriedOnHttp2Shutdown() throws Exception {
-    platform.assumeHttp2Support();
-
-    enableProtocol(Protocol.HTTP_2);
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setBody("abc"));
-    server.enqueue(new MockResponse()
-        .setBody("def"));
-
-    // Send a separate request which will trigger a GOAWAY frame on the healthy connection.
-    Response response = getResponse(newRequest("/"));
-    assertContent("abc", response);
-
-    // Ensure the GOAWAY frame has time to be read and processed.
-    Thread.sleep(500);
-
-    assertContent("def", getResponse(new Request.Builder()
-        .url(server.url("/"))
-        .post(RequestBody.create("123", null))
-        .build()));
-
-    RecordedRequest request1 = server.takeRequest();
-    assertThat(request1.getSequenceNumber()).isEqualTo(0);
-
-    RecordedRequest request2 = server.takeRequest();
-    assertThat(request2.getBody().readUtf8()).isEqualTo("123");
-    assertThat(request2.getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void authenticateNoConnection() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Connection: close")
-        .setResponseCode(401)
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
-
-    Authenticator.setDefault(new RecordingAuthenticator(null));
-    client = client.newBuilder()
-        .authenticator(new JavaNetAuthenticator())
-        .build();
-    Response response = getResponse(newRequest("/"));
-    assertThat(response.code()).isEqualTo(401);
-  }
-
-  private Request newRequest(String s) {
-    return newRequest(server.url(s));
-  }
-
-  private Request newRequest(HttpUrl url) {
-    return new Request.Builder()
-        .url(url)
-        .build();
-  }
-
-  private Response getResponse(Request request) throws IOException {
-    return client.newCall(request).execute();
-  }
-
-  /** Returns a gzipped copy of {@code bytes}. */
-  public Buffer gzip(String data) throws IOException {
-    Buffer result = new Buffer();
-    BufferedSink gzipSink = Okio.buffer(new GzipSink(result));
-    gzipSink.writeUtf8(data);
-    gzipSink.close();
-    return result;
-  }
-
-  private void assertContent(String expected, Response response, int limit)
-      throws IOException {
-    assertThat(readAscii(response.body().byteStream(), limit)).isEqualTo(
-        expected);
-  }
-
-  private void assertContent(String expected, Response response) throws IOException {
-    assertContent(expected, response, Integer.MAX_VALUE);
-  }
-
-  private Set<String> newSet(String... elements) {
-    return new LinkedHashSet<>(asList(elements));
-  }
-
-  enum TransferKind {
-    CHUNKED {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setChunkedBody(content, chunkSize);
-      }
-
-      @Override RequestBody newRequestBody(String body) {
-        return new RequestBody() {
-          @Override public long contentLength() {
-            return -1L;
-          }
-
-          @Override public @Nullable MediaType contentType() {
-            return null;
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            sink.writeUtf8(body);
-          }
-        };
-      }
-    },
-    FIXED_LENGTH {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-      }
-
-      @Override RequestBody newRequestBody(String body) {
-        return new RequestBody() {
-          @Override public long contentLength() {
-            return Utf8.size(body);
-          }
-
-          @Override public @Nullable MediaType contentType() {
-            return null;
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            sink.writeUtf8(body);
-          }
-        };
-      }
-    },
-    END_OF_STREAM {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
-        response.setBody(content);
-        response.setSocketPolicy(DISCONNECT_AT_END);
-        response.removeHeader("Content-Length");
-      }
-
-      @Override RequestBody newRequestBody(String body) {
-        throw new AssumptionViolatedException("END_OF_STREAM not implemented for requests");
-      }
-    };
-
-    abstract void setBody(MockResponse response, Buffer content, int chunkSize) throws IOException;
-
-    abstract RequestBody newRequestBody(String body);
-
-    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
-      setBody(response, new Buffer().writeUtf8(content), chunkSize);
-    }
-  }
-
-  enum ProxyConfig {
-    NO_PROXY() {
-      @Override public Call.Factory connect(MockWebServer server, OkHttpClient client) {
-        return client.newBuilder()
-            .proxy(Proxy.NO_PROXY)
-            .build();
-      }
-    },
-
-    CREATE_ARG() {
-      @Override public Call.Factory connect(MockWebServer server, OkHttpClient client) {
-        return client.newBuilder()
-            .proxy(server.toProxyAddress())
-            .build();
-      }
-    },
-
-    PROXY_SYSTEM_PROPERTY() {
-      @Override public Call.Factory connect(MockWebServer server, OkHttpClient client) {
-        System.setProperty("proxyHost", server.getHostName());
-        System.setProperty("proxyPort", Integer.toString(server.getPort()));
-        return client;
-      }
-    },
-
-    HTTP_PROXY_SYSTEM_PROPERTY() {
-      @Override public Call.Factory connect(MockWebServer server, OkHttpClient client) {
-        System.setProperty("http.proxyHost", server.getHostName());
-        System.setProperty("http.proxyPort", Integer.toString(server.getPort()));
-        return client;
-      }
-    },
-
-    HTTPS_PROXY_SYSTEM_PROPERTY() {
-      @Override public Call.Factory connect(MockWebServer server, OkHttpClient client) {
-        System.setProperty("https.proxyHost", server.getHostName());
-        System.setProperty("https.proxyPort", Integer.toString(server.getPort()));
-        return client;
-      }
-    };
-
-    public abstract Call.Factory connect(MockWebServer server, OkHttpClient client)
-        throws IOException;
-
-    public Call connect(
-        MockWebServer server, OkHttpClient client, HttpUrl url) throws IOException {
-      Request request = new Request.Builder()
-          .url(url)
-          .build();
-      return connect(server, client).newCall(request);
-    }
-  }
-
-  private static class RecordingTrustManager implements X509TrustManager {
-    private final List<String> calls = new ArrayList<>();
-    private final X509TrustManager delegate;
-
-    RecordingTrustManager(X509TrustManager delegate) {
-      this.delegate = delegate;
-    }
-
-    @Override public X509Certificate[] getAcceptedIssuers() {
-      return delegate.getAcceptedIssuers();
-    }
-
-    @Override public void checkClientTrusted(X509Certificate[] chain, String authType) {
-      calls.add("checkClientTrusted " + certificatesToString(chain));
-    }
-
-    @Override public void checkServerTrusted(X509Certificate[] chain, String authType) {
-      calls.add("checkServerTrusted " + certificatesToString(chain));
-    }
-
-    private String certificatesToString(X509Certificate[] certificates) {
-      List<String> result = new ArrayList<>();
-      for (X509Certificate certificate : certificates) {
-        result.add(certificate.getSubjectDN() + " " + certificate.getSerialNumber());
-      }
-      return result.toString();
-    }
-  }
-
-  /**
-   * Tests that use this will fail unless boot classpath is set. Ex. {@code
-   * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
-   */
-  private void enableProtocol(Protocol protocol) {
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .protocols(asList(protocol, Protocol.HTTP_1_1))
-        .build();
-    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    server.setProtocolNegotiationEnabled(true);
-    server.setProtocols(client.protocols());
-  }
-
-  /**
-   * Used during tests that involve TLS connection fallback attempts. OkHttp includes the
-   * TLS_FALLBACK_SCSV cipher on fallback connections. See {@link FallbackTestClientSocketFactory}
-   * for details.
-   */
-  private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
-    return new FallbackTestClientSocketFactory(handshakeCertificates.sslSocketFactory());
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/UrlComponentEncodingTester.java b/okhttp/src/test/java/okhttp3/UrlComponentEncodingTester.java
deleted file mode 100644
index bc2f054fc9..0000000000
--- a/okhttp/src/test/java/okhttp3/UrlComponentEncodingTester.java
+++ /dev/null
@@ -1,452 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.net.URI;
-import java.net.URL;
-import java.util.Collections;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.ByteString;
-
-import static org.junit.Assert.fail;
-
-/** Tests how each code point is encoded and decoded in the context of each URL component. */
-class UrlComponentEncodingTester {
-  private static final int UNICODE_2 = 0x07ff; // Arbitrary code point that's 2 bytes in UTF-8.
-  private static final int UNICODE_3 = 0xffff; // Arbitrary code point that's 3 bytes in UTF-8.
-  private static final int UNICODE_4 = 0x10ffff; // Arbitrary code point that's 4 bytes in UTF-8.
-
-  /**
-   * The default encode set for the ASCII range. The specific rules vary per-component: for example,
-   * '?' may be identity-encoded in a fragment, but must be percent-encoded in a path.
-   *
-   * See https://url.spec.whatwg.org/#percent-encoded-bytes
-   */
-  private static final Map<Integer, Encoding> defaultEncodings;
-
-  static {
-    Map<Integer, Encoding> map = new LinkedHashMap<>();
-    map.put(       0x0, Encoding.PERCENT); // Null character
-    map.put(       0x1, Encoding.PERCENT); // Start of Header
-    map.put(       0x2, Encoding.PERCENT); // Start of Text
-    map.put(       0x3, Encoding.PERCENT); // End of Text
-    map.put(       0x4, Encoding.PERCENT); // End of Transmission
-    map.put(       0x5, Encoding.PERCENT); // Enquiry
-    map.put(       0x6, Encoding.PERCENT); // Acknowledgment
-    map.put(       0x7, Encoding.PERCENT); // Bell
-    map.put((int) '\b', Encoding.PERCENT); // Backspace
-    map.put((int) '\t', Encoding.SKIP);    // Horizontal Tab
-    map.put((int) '\n', Encoding.SKIP);    // Line feed
-    map.put(       0xb, Encoding.PERCENT); // Vertical Tab
-    map.put((int) '\f', Encoding.SKIP);    // Form feed
-    map.put((int) '\r', Encoding.SKIP);    // Carriage return
-    map.put(       0xe, Encoding.PERCENT); // Shift Out
-    map.put(       0xf, Encoding.PERCENT); // Shift In
-    map.put(      0x10, Encoding.PERCENT); // Data Link Escape
-    map.put(      0x11, Encoding.PERCENT); // Device Control 1 (oft. XON)
-    map.put(      0x12, Encoding.PERCENT); // Device Control 2
-    map.put(      0x13, Encoding.PERCENT); // Device Control 3 (oft. XOFF)
-    map.put(      0x14, Encoding.PERCENT); // Device Control 4
-    map.put(      0x15, Encoding.PERCENT); // Negative Acknowledgment
-    map.put(      0x16, Encoding.PERCENT); // Synchronous idle
-    map.put(      0x17, Encoding.PERCENT); // End of Transmission Block
-    map.put(      0x18, Encoding.PERCENT); // Cancel
-    map.put(      0x19, Encoding.PERCENT); // End of Medium
-    map.put(      0x1a, Encoding.PERCENT); // Substitute
-    map.put(      0x1b, Encoding.PERCENT); // Escape
-    map.put(      0x1c, Encoding.PERCENT); // File Separator
-    map.put(      0x1d, Encoding.PERCENT); // Group Separator
-    map.put(      0x1e, Encoding.PERCENT); // Record Separator
-    map.put(      0x1f, Encoding.PERCENT); // Unit Separator
-    map.put((int)  ' ', Encoding.PERCENT);
-    map.put((int)  '!', Encoding.IDENTITY);
-    map.put((int)  '"', Encoding.PERCENT);
-    map.put((int)  '#', Encoding.PERCENT);
-    map.put((int)  '$', Encoding.IDENTITY);
-    map.put((int)  '%', Encoding.IDENTITY);
-    map.put((int)  '&', Encoding.IDENTITY);
-    map.put((int) '\'', Encoding.IDENTITY);
-    map.put((int)  '(', Encoding.IDENTITY);
-    map.put((int)  ')', Encoding.IDENTITY);
-    map.put((int)  '*', Encoding.IDENTITY);
-    map.put((int)  '+', Encoding.IDENTITY);
-    map.put((int)  ',', Encoding.IDENTITY);
-    map.put((int)  '-', Encoding.IDENTITY);
-    map.put((int)  '.', Encoding.IDENTITY);
-    map.put((int)  '/', Encoding.IDENTITY);
-    map.put((int)  '0', Encoding.IDENTITY);
-    map.put((int)  '1', Encoding.IDENTITY);
-    map.put((int)  '2', Encoding.IDENTITY);
-    map.put((int)  '3', Encoding.IDENTITY);
-    map.put((int)  '4', Encoding.IDENTITY);
-    map.put((int)  '5', Encoding.IDENTITY);
-    map.put((int)  '6', Encoding.IDENTITY);
-    map.put((int)  '7', Encoding.IDENTITY);
-    map.put((int)  '8', Encoding.IDENTITY);
-    map.put((int)  '9', Encoding.IDENTITY);
-    map.put((int)  ':', Encoding.IDENTITY);
-    map.put((int)  ';', Encoding.IDENTITY);
-    map.put((int)  '<', Encoding.PERCENT);
-    map.put((int)  '=', Encoding.IDENTITY);
-    map.put((int)  '>', Encoding.PERCENT);
-    map.put((int)  '?', Encoding.PERCENT);
-    map.put((int)  '@', Encoding.IDENTITY);
-    map.put((int)  'A', Encoding.IDENTITY);
-    map.put((int)  'B', Encoding.IDENTITY);
-    map.put((int)  'C', Encoding.IDENTITY);
-    map.put((int)  'D', Encoding.IDENTITY);
-    map.put((int)  'E', Encoding.IDENTITY);
-    map.put((int)  'F', Encoding.IDENTITY);
-    map.put((int)  'G', Encoding.IDENTITY);
-    map.put((int)  'H', Encoding.IDENTITY);
-    map.put((int)  'I', Encoding.IDENTITY);
-    map.put((int)  'J', Encoding.IDENTITY);
-    map.put((int)  'K', Encoding.IDENTITY);
-    map.put((int)  'L', Encoding.IDENTITY);
-    map.put((int)  'M', Encoding.IDENTITY);
-    map.put((int)  'N', Encoding.IDENTITY);
-    map.put((int)  'O', Encoding.IDENTITY);
-    map.put((int)  'P', Encoding.IDENTITY);
-    map.put((int)  'Q', Encoding.IDENTITY);
-    map.put((int)  'R', Encoding.IDENTITY);
-    map.put((int)  'S', Encoding.IDENTITY);
-    map.put((int)  'T', Encoding.IDENTITY);
-    map.put((int)  'U', Encoding.IDENTITY);
-    map.put((int)  'V', Encoding.IDENTITY);
-    map.put((int)  'W', Encoding.IDENTITY);
-    map.put((int)  'X', Encoding.IDENTITY);
-    map.put((int)  'Y', Encoding.IDENTITY);
-    map.put((int)  'Z', Encoding.IDENTITY);
-    map.put((int)  '[', Encoding.IDENTITY);
-    map.put((int) '\\', Encoding.IDENTITY);
-    map.put((int)  ']', Encoding.IDENTITY);
-    map.put((int)  '^', Encoding.IDENTITY);
-    map.put((int)  '_', Encoding.IDENTITY);
-    map.put((int)  '`', Encoding.PERCENT);
-    map.put((int)  'a', Encoding.IDENTITY);
-    map.put((int)  'b', Encoding.IDENTITY);
-    map.put((int)  'c', Encoding.IDENTITY);
-    map.put((int)  'd', Encoding.IDENTITY);
-    map.put((int)  'e', Encoding.IDENTITY);
-    map.put((int)  'f', Encoding.IDENTITY);
-    map.put((int)  'g', Encoding.IDENTITY);
-    map.put((int)  'h', Encoding.IDENTITY);
-    map.put((int)  'i', Encoding.IDENTITY);
-    map.put((int)  'j', Encoding.IDENTITY);
-    map.put((int)  'k', Encoding.IDENTITY);
-    map.put((int)  'l', Encoding.IDENTITY);
-    map.put((int)  'm', Encoding.IDENTITY);
-    map.put((int)  'n', Encoding.IDENTITY);
-    map.put((int)  'o', Encoding.IDENTITY);
-    map.put((int)  'p', Encoding.IDENTITY);
-    map.put((int)  'q', Encoding.IDENTITY);
-    map.put((int)  'r', Encoding.IDENTITY);
-    map.put((int)  's', Encoding.IDENTITY);
-    map.put((int)  't', Encoding.IDENTITY);
-    map.put((int)  'u', Encoding.IDENTITY);
-    map.put((int)  'v', Encoding.IDENTITY);
-    map.put((int)  'w', Encoding.IDENTITY);
-    map.put((int)  'x', Encoding.IDENTITY);
-    map.put((int)  'y', Encoding.IDENTITY);
-    map.put((int)  'z', Encoding.IDENTITY);
-    map.put((int)  '{', Encoding.IDENTITY);
-    map.put((int)  '|', Encoding.IDENTITY);
-    map.put((int)  '}', Encoding.IDENTITY);
-    map.put((int)  '~', Encoding.IDENTITY);
-    map.put(      0x7f, Encoding.PERCENT); // Delete
-    map.put( UNICODE_2, Encoding.PERCENT);
-    map.put( UNICODE_3, Encoding.PERCENT);
-    map.put( UNICODE_4, Encoding.PERCENT);
-    defaultEncodings = Collections.unmodifiableMap(map);
-  }
-
-  private final Map<Integer, Encoding> encodings;
-  private final StringBuilder uriEscapedCodePoints = new StringBuilder();
-
-  public UrlComponentEncodingTester() {
-    this.encodings = new LinkedHashMap<>(defaultEncodings);
-  }
-
-  public UrlComponentEncodingTester override(Encoding encoding, int... codePoints) {
-    for (int codePoint : codePoints) {
-      encodings.put(codePoint, encoding);
-    }
-    return this;
-  }
-
-  public UrlComponentEncodingTester identityForNonAscii() {
-    encodings.put(UNICODE_2, Encoding.IDENTITY);
-    encodings.put(UNICODE_3, Encoding.IDENTITY);
-    encodings.put(UNICODE_4, Encoding.IDENTITY);
-    return this;
-  }
-
-  /**
-   * Configure a character to be skipped but only for conversion to and from {@code java.net.URI}.
-   * That class is more strict than the others.
-   */
-  public UrlComponentEncodingTester skipForUri(int... codePoints) {
-    uriEscapedCodePoints.append(new String(codePoints, 0, codePoints.length));
-    return this;
-  }
-
-  public UrlComponentEncodingTester test(Component component) {
-    for (Map.Entry<Integer, Encoding> entry : encodings.entrySet()) {
-      Encoding encoding = entry.getValue();
-      int codePoint = entry.getKey();
-      testEncodeAndDecode(codePoint, component);
-      if (encoding == Encoding.SKIP) continue;
-
-      testParseOriginal(codePoint, encoding, component);
-      testParseAlreadyEncoded(codePoint, encoding, component);
-      testToUrl(codePoint, encoding, component);
-      testFromUrl(codePoint, encoding, component);
-
-      if (codePoint != '%') {
-        boolean uriEscaped = uriEscapedCodePoints.indexOf(
-            Encoding.IDENTITY.encode(codePoint)) != -1;
-        testUri(codePoint, encoding, component, uriEscaped);
-      }
-    }
-    return this;
-  }
-
-  private void testParseAlreadyEncoded(int codePoint, Encoding encoding, Component component) {
-    String encoded = encoding.encode(codePoint);
-    String urlString = component.urlString(encoded);
-    HttpUrl url = HttpUrl.get(urlString);
-    if (!component.encodedValue(url).equals(encoded)) {
-      fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
-    }
-  }
-
-  private void testEncodeAndDecode(int codePoint, Component component) {
-    String expected = Encoding.IDENTITY.encode(codePoint);
-    HttpUrl.Builder builder = HttpUrl.get("http://host/").newBuilder();
-    component.set(builder, expected);
-    HttpUrl url = builder.build();
-    String actual = component.get(url);
-    if (!expected.equals(actual)) {
-      fail(Util.format("Roundtrip %s %#x %s", component, codePoint, url));
-    }
-  }
-
-  private void testParseOriginal(int codePoint, Encoding encoding, Component component) {
-    String encoded = encoding.encode(codePoint);
-    if (encoding != Encoding.PERCENT) return;
-    String identity = Encoding.IDENTITY.encode(codePoint);
-    String urlString = component.urlString(identity);
-    HttpUrl url = HttpUrl.get(urlString);
-
-    String s = component.encodedValue(url);
-    if (!s.equals(encoded)) {
-      fail(Util.format("Encoding %s %#02x using %s", component, codePoint, encoding));
-    }
-  }
-
-  private void testToUrl(int codePoint, Encoding encoding, Component component) {
-    String encoded = encoding.encode(codePoint);
-    HttpUrl httpUrl = HttpUrl.get(component.urlString(encoded));
-    URL javaNetUrl = httpUrl.url();
-    if (!javaNetUrl.toString().equals(javaNetUrl.toString())) {
-      fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
-    }
-  }
-
-  private void testFromUrl(int codePoint, Encoding encoding, Component component) {
-    String encoded = encoding.encode(codePoint);
-    HttpUrl httpUrl = HttpUrl.get(component.urlString(encoded));
-    HttpUrl toAndFromJavaNetUrl = HttpUrl.get(httpUrl.url());
-    if (!toAndFromJavaNetUrl.equals(httpUrl)) {
-      fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
-    }
-  }
-
-  private void testUri(
-      int codePoint, Encoding encoding, Component component, boolean uriEscaped) {
-    String string = new String(new int[] {codePoint}, 0, 1);
-    String encoded = encoding.encode(codePoint);
-    HttpUrl httpUrl = HttpUrl.get(component.urlString(encoded));
-    URI uri = httpUrl.uri();
-    HttpUrl toAndFromUri = HttpUrl.get(uri);
-    if (uriEscaped) {
-      // The URI has more escaping than the HttpURL. Check that the decoded values still match.
-      if (uri.toString().equals(httpUrl.toString())) {
-        fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
-      }
-      if (!component.get(toAndFromUri).equals(string)) {
-        fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
-      }
-    } else {
-      // Check that the URI and HttpURL have the exact same escaping.
-      if (!toAndFromUri.equals(httpUrl)) {
-        fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
-      }
-      if (!uri.toString().equals(httpUrl.toString())) {
-        fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
-      }
-    }
-  }
-
-  public enum Encoding {
-    IDENTITY {
-      @Override public String encode(int codePoint) {
-        return new String(new int[] {codePoint}, 0, 1);
-      }
-    },
-
-    PERCENT {
-      @Override public String encode(int codePoint) {
-        ByteString utf8 = ByteString.encodeUtf8(IDENTITY.encode(codePoint));
-        Buffer percentEncoded = new Buffer();
-        for (int i = 0; i < utf8.size(); i++) {
-          percentEncoded.writeUtf8(Util.format("%%%02X", utf8.getByte(i) & 0xff));
-        }
-        return percentEncoded.readUtf8();
-      }
-    },
-
-    SKIP;
-
-    public String encode(int codePoint) {
-      throw new UnsupportedOperationException();
-    }
-  }
-
-  public enum Component {
-    USER {
-      @Override public String urlString(String value) {
-        return "http://" + value + "@example.com/";
-      }
-
-      @Override public String encodedValue(HttpUrl url) {
-        return url.encodedUsername();
-      }
-
-      @Override public void set(HttpUrl.Builder builder, String value) {
-        builder.username(value);
-      }
-
-      @Override public String get(HttpUrl url) {
-        return url.username();
-      }
-    },
-    PASSWORD {
-      @Override public String urlString(String value) {
-        return "http://:" + value + "@example.com/";
-      }
-
-      @Override public String encodedValue(HttpUrl url) {
-        return url.encodedPassword();
-      }
-
-      @Override public void set(HttpUrl.Builder builder, String value) {
-        builder.password(value);
-      }
-
-      @Override public String get(HttpUrl url) {
-        return url.password();
-      }
-    },
-    PATH {
-      @Override public String urlString(String value) {
-        return "http://example.com/a" + value + "z/";
-      }
-
-      @Override public String encodedValue(HttpUrl url) {
-        String path = url.encodedPath();
-        return path.substring(2, path.length() - 2);
-      }
-
-      @Override public void set(HttpUrl.Builder builder, String value) {
-        builder.addPathSegment("a" + value + "z");
-      }
-
-      @Override public String get(HttpUrl url) {
-        String pathSegment = url.pathSegments().get(0);
-        return pathSegment.substring(1, pathSegment.length() - 1);
-      }
-    },
-    QUERY {
-      @Override public String urlString(String value) {
-        return "http://example.com/?a" + value + "z";
-      }
-
-      @Override public String encodedValue(HttpUrl url) {
-        String query = url.encodedQuery();
-        return query.substring(1, query.length() - 1);
-      }
-
-      @Override public void set(HttpUrl.Builder builder, String value) {
-        builder.query("a" + value + "z");
-      }
-
-      @Override public String get(HttpUrl url) {
-        String query = url.query();
-        return query.substring(1, query.length() - 1);
-      }
-    },
-    QUERY_VALUE {
-      @Override public String urlString(String value) {
-        return "http://example.com/?q=a" + value + "z";
-      }
-
-      @Override public String encodedValue(HttpUrl url) {
-        String query = url.encodedQuery();
-        return query.substring(3, query.length() - 1);
-      }
-
-      @Override public void set(HttpUrl.Builder builder, String value) {
-        builder.addQueryParameter("q", "a" + value + "z");
-      }
-
-      @Override public String get(HttpUrl url) {
-        String value = url.queryParameter("q");
-        return value.substring(1, value.length() - 1);
-      }
-    },
-    FRAGMENT {
-      @Override public String urlString(String value) {
-        return "http://example.com/#a" + value + "z";
-      }
-
-      @Override public String encodedValue(HttpUrl url) {
-        String fragment = url.encodedFragment();
-        return fragment.substring(1, fragment.length() - 1);
-      }
-
-      @Override public void set(HttpUrl.Builder builder, String value) {
-        builder.fragment("a" + value + "z");
-      }
-
-      @Override public String get(HttpUrl url) {
-        String fragment = url.fragment();
-        return fragment.substring(1, fragment.length() - 1);
-      }
-    };
-
-    public abstract String urlString(String value);
-
-    public abstract String encodedValue(HttpUrl url);
-
-    public abstract void set(HttpUrl.Builder builder, String value);
-
-    public abstract String get(HttpUrl url);
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/WebPlatformUrlTest.java b/okhttp/src/test/java/okhttp3/WebPlatformUrlTest.java
deleted file mode 100644
index 6e975910db..0000000000
--- a/okhttp/src/test/java/okhttp3/WebPlatformUrlTest.java
+++ /dev/null
@@ -1,128 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import okio.BufferedSource;
-import okio.Okio;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameter;
-
-import static okhttp3.internal.Util.immutableListOf;
-import static org.assertj.core.api.Assertions.assertThat;
-
-/** Runs the web platform URL tests against Java URL models. */
-@RunWith(Parameterized.class)
-public final class WebPlatformUrlTest {
-  @Parameterized.Parameters(name = "{0}")
-  public static List<Object[]> parameters() {
-    try {
-      List<Object[]> result = new ArrayList<>();
-      for (WebPlatformUrlTestData urlTestData : loadTests()) {
-        result.add(new Object[] {urlTestData});
-      }
-      return result;
-    } catch (IOException e) {
-      throw new AssertionError();
-    }
-  }
-
-  @Parameter
-  public WebPlatformUrlTestData testData;
-
-  private static final List<String> HTTP_URL_SCHEMES = immutableListOf("http", "https");
-  private static final List<String> KNOWN_FAILURES = immutableListOf(
-      "Parsing: <http://example\t.\norg> against <http://example.org/foo/bar>",
-      "Parsing: <http://f:0/c> against <http://example.org/foo/bar>",
-      "Parsing: <http://f:00000000000000/c> against <http://example.org/foo/bar>",
-      "Parsing: <http://f:\n/c> against <http://example.org/foo/bar>",
-      "Parsing: <http://f:999999/c> against <http://example.org/foo/bar>",
-      "Parsing: <http://192.0x00A80001> against <about:blank>",
-      "Parsing: <http://%30%78%63%30%2e%30%32%35%30.01> against <http://other.com/>",
-      "Parsing: <http://192.168.0.257> against <http://other.com/>",
-      "Parsing: <http://> against <http://other.com/>"
-  );
-
-  /** Test how {@link HttpUrl} does against the web platform test suite. */
-  @Test public void httpUrl() throws Exception {
-    if (!testData.scheme.isEmpty() && !HTTP_URL_SCHEMES.contains(testData.scheme)) {
-      System.err.println("Ignoring unsupported scheme " + testData.scheme);
-      return;
-    }
-    if (!testData.base.startsWith("https:")
-        && !testData.base.startsWith("http:")
-        && !testData.base.equals("about:blank")) {
-      System.err.println("Ignoring unsupported base " + testData.base);
-      return;
-    }
-
-    try {
-      testHttpUrl();
-      if (KNOWN_FAILURES.contains(testData.toString())) {
-        System.err.println("Expected failure but was success: " + testData);
-      }
-    } catch (Throwable e) {
-      if (KNOWN_FAILURES.contains(testData.toString())) {
-        System.err.println("Ignoring known failure: " + testData);
-        e.printStackTrace();
-      } else {
-        throw e;
-      }
-    }
-  }
-
-  private void testHttpUrl() {
-    HttpUrl url;
-    if (testData.base.equals("about:blank")) {
-      url = HttpUrl.parse(testData.input);
-    } else {
-      HttpUrl baseUrl = HttpUrl.get(testData.base);
-      url = baseUrl.resolve(testData.input);
-    }
-
-    if (testData.expectParseFailure()) {
-      assertThat(url).overridingErrorMessage("Expected URL to fail parsing").isNull();
-    } else {
-      assertThat(url).overridingErrorMessage(
-          "Expected URL to parse successfully, but was null").isNotNull();
-      String effectivePort = url.port() != HttpUrl.defaultPort(url.scheme())
-          ? Integer.toString(url.port())
-          : "";
-      String effectiveQuery = url.encodedQuery() != null ? "?" + url.encodedQuery() : "";
-      String effectiveFragment = url.encodedFragment() != null ? "#" + url.encodedFragment() : "";
-      String effectiveHost = url.host().contains(":")
-          ? ("[" + url.host() + "]")
-          : url.host();
-      assertThat(url.scheme()).overridingErrorMessage("scheme").isEqualTo(testData.scheme);
-      assertThat(effectiveHost).overridingErrorMessage("host").isEqualTo(testData.host);
-      assertThat(effectivePort).overridingErrorMessage("port").isEqualTo(testData.port);
-      assertThat(url.encodedPath()).overridingErrorMessage("path").isEqualTo(testData.path);
-      assertThat(effectiveQuery).overridingErrorMessage("query").isEqualTo(testData.query);
-      assertThat(effectiveFragment).overridingErrorMessage("fragment").isEqualTo(
-          testData.fragment);
-    }
-  }
-
-  private static List<WebPlatformUrlTestData> loadTests() throws IOException {
-    BufferedSource source = Okio.buffer(Okio.source(
-        WebPlatformUrlTest.class.getResourceAsStream("/web-platform-test-urltestdata.txt")));
-    return WebPlatformUrlTestData.load(source);
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/WebPlatformUrlTestData.java b/okhttp/src/test/java/okhttp3/WebPlatformUrlTestData.java
deleted file mode 100644
index 72f92f9abf..0000000000
--- a/okhttp/src/test/java/okhttp3/WebPlatformUrlTestData.java
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.BufferedSource;
-
-/**
- * A test from the <a href="https://github.com/w3c/web-platform-tests/tree/master/url">Web Platform
- * URL test suite</a>. Each test is a line of the file {@code urltestdata.txt}; the format is
- * informally specified by its JavaScript parser {@code urltestparser.js}; with which this class
- * attempts to be compatible.
- *
- * <p>Each line of the urltestdata.text file specifies a test. Lines look like this: <pre>   {@code
- *
- *   http://example\t.\norg http://example.org/foo/bar s:http h:example.org p:/
- * }</pre>
- */
-public final class WebPlatformUrlTestData {
-  String input;
-  String base;
-  String scheme = "";
-  String username = "";
-  String password = null;
-  String host = "";
-  String port = "";
-  String path = "";
-  String query = "";
-  String fragment = "";
-
-  public boolean expectParseFailure() {
-    return scheme.isEmpty();
-  }
-
-  private void set(String name, String value) {
-    switch (name) {
-      case "s":
-        scheme = value;
-        break;
-      case "u":
-        username = value;
-        break;
-      case "pass":
-        password = value;
-        break;
-      case "h":
-        host = value;
-        break;
-      case "port":
-        port = value;
-        break;
-      case "p":
-        path = value;
-        break;
-      case "q":
-        query = value;
-        break;
-      case "f":
-        fragment = value;
-        break;
-      default:
-        throw new IllegalArgumentException("unexpected attribute: " + value);
-    }
-  }
-
-  @Override public String toString() {
-    return Util.format("Parsing: <%s> against <%s>", input, base);
-  }
-
-  public static List<WebPlatformUrlTestData> load(BufferedSource source) throws IOException {
-    List<WebPlatformUrlTestData> list = new ArrayList<>();
-    for (String line; (line = source.readUtf8Line()) != null; ) {
-      if (line.isEmpty() || line.startsWith("#")) continue;
-
-      int i = 0;
-      String[] parts = line.split(" ");
-      WebPlatformUrlTestData element = new WebPlatformUrlTestData();
-      element.input = unescape(parts[i++]);
-
-      String base = i < parts.length ? parts[i++] : null;
-      element.base = (base == null || base.isEmpty())
-          ? list.get(list.size() - 1).base
-          : unescape(base);
-
-      for (; i < parts.length; i++) {
-        String piece = parts[i];
-        if (piece.startsWith("#")) continue;
-        String[] nameAndValue = piece.split(":", 2);
-        element.set(nameAndValue[0], unescape(nameAndValue[1]));
-      }
-
-      list.add(element);
-    }
-    return list;
-  }
-
-  private static String unescape(String s) throws EOFException {
-    Buffer in = new Buffer().writeUtf8(s);
-    StringBuilder result = new StringBuilder();
-    while (!in.exhausted()) {
-      int c = in.readUtf8CodePoint();
-      if (c != '\\') {
-        result.append((char) c);
-        continue;
-      }
-
-      switch (in.readUtf8CodePoint()) {
-        case '\\':
-          result.append('\\');
-          break;
-        case '#':
-          result.append('#');
-          break;
-        case 'n':
-          result.append('\n');
-          break;
-        case 'r':
-          result.append('\r');
-          break;
-        case 's':
-          result.append(' ');
-          break;
-        case 't':
-          result.append('\t');
-          break;
-        case 'f':
-          result.append('\f');
-          break;
-        case 'u':
-          result.append((char) Integer.parseInt(in.readUtf8(4), 16));
-          break;
-        default:
-          throw new IllegalArgumentException("unexpected escape character in " + s);
-      }
-    }
-
-    return result.toString();
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/WholeOperationTimeoutTest.java b/okhttp/src/test/java/okhttp3/WholeOperationTimeoutTest.java
deleted file mode 100644
index 376642db16..0000000000
--- a/okhttp/src/test/java/okhttp3/WholeOperationTimeoutTest.java
+++ /dev/null
@@ -1,325 +0,0 @@
-/*
- * Copyright (C) 2018 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3;
-
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.net.HttpURLConnection;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.testing.Flaky;
-import okio.BufferedSink;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class WholeOperationTimeoutTest {
-  /** A large response body. Smaller bodies might successfully read after the socket is closed! */
-  private static final String BIG_ENOUGH_BODY = TestUtil.repeat('a', 64 * 1024);
-
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  private final OkHttpClient client = clientTestRule.newClient();
-
-  @Test public void defaultConfigIsNoTimeout() throws Exception {
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Call call = client.newCall(request);
-    assertThat(call.timeout().timeoutNanos()).isEqualTo(0);
-  }
-
-  @Test public void configureClientDefault() throws Exception {
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    OkHttpClient timeoutClient = client.newBuilder()
-        .callTimeout(456, TimeUnit.MILLISECONDS)
-        .build();
-
-    Call call = timeoutClient.newCall(request);
-    assertThat(call.timeout().timeoutNanos()).isEqualTo(TimeUnit.MILLISECONDS.toNanos(456));
-  }
-
-  @Test public void timeoutWritingRequest() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(sleepingRequestBody(500))
-        .build();
-
-    Call call = client.newCall(request);
-    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("timeout");
-      assertThat(call.isCanceled()).isTrue();
-    }
-  }
-
-  @Test public void timeoutWritingRequestWithEnqueue() throws Exception {
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(sleepingRequestBody(500))
-        .build();
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    final AtomicReference<Throwable> exceptionRef = new AtomicReference<>();
-
-    Call call = client.newCall(request);
-    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
-    call.enqueue(new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-        exceptionRef.set(e);
-        latch.countDown();
-      }
-
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        response.close();
-        latch.countDown();
-      }
-    });
-
-    latch.await();
-    assertThat(call.isCanceled()).isTrue();
-    assertThat(exceptionRef.get()).isNotNull();
-  }
-
-  @Test public void timeoutProcessing() throws Exception {
-    server.enqueue(new MockResponse()
-        .setHeadersDelay(500, TimeUnit.MILLISECONDS));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Call call = client.newCall(request);
-    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("timeout");
-      assertThat(call.isCanceled()).isTrue();
-    }
-  }
-
-  @Test public void timeoutProcessingWithEnqueue() throws Exception {
-    server.enqueue(new MockResponse()
-        .setHeadersDelay(500, TimeUnit.MILLISECONDS));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    final AtomicReference<Throwable> exceptionRef = new AtomicReference<>();
-
-    Call call = client.newCall(request);
-    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
-    call.enqueue(new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-        exceptionRef.set(e);
-        latch.countDown();
-      }
-
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        response.close();
-        latch.countDown();
-      }
-    });
-
-    latch.await();
-    assertThat(call.isCanceled()).isTrue();
-    assertThat(exceptionRef.get()).isNotNull();
-  }
-
-  @Test public void timeoutReadingResponse() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(BIG_ENOUGH_BODY));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    Call call = client.newCall(request);
-    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
-    Response response = call.execute();
-    Thread.sleep(500);
-    try {
-      response.body().source().readUtf8();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("timeout");
-      assertThat(call.isCanceled()).isTrue();
-    }
-  }
-
-  @Test public void timeoutReadingResponseWithEnqueue() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(BIG_ENOUGH_BODY));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-
-    final CountDownLatch latch = new CountDownLatch(1);
-    final AtomicReference<Throwable> exceptionRef = new AtomicReference<>();
-
-    Call call = client.newCall(request);
-    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
-    call.enqueue(new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-        latch.countDown();
-      }
-
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        try {
-          Thread.sleep(500);
-        } catch (InterruptedException e) {
-          throw new AssertionError();
-        }
-        try {
-          response.body().source().readUtf8();
-          fail();
-        } catch (IOException e) {
-          exceptionRef.set(e);
-        } finally {
-          latch.countDown();
-        }
-      }
-    });
-
-    latch.await();
-    assertThat(call.isCanceled()).isTrue();
-    assertThat(exceptionRef.get()).isNotNull();
-  }
-
-  @Test public void singleTimeoutForAllFollowUpRequests() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .setHeader("Location", "/b")
-        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .setHeader("Location", "/c")
-        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .setHeader("Location", "/d")
-        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .setHeader("Location", "/e")
-        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .setHeader("Location", "/f")
-        .setHeadersDelay(100, TimeUnit.MILLISECONDS));
-    server.enqueue(new MockResponse());
-
-    Request request = new Request.Builder()
-        .url(server.url("/a"))
-        .build();
-
-    Call call = client.newCall(request);
-    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("timeout");
-      assertThat(call.isCanceled()).isTrue();
-    }
-  }
-
-  @Test
-  public void timeoutFollowingRedirectOnNewConnection() throws Exception {
-    MockWebServer otherServer = new MockWebServer();
-
-    server.enqueue(
-        new MockResponse()
-            .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-            .setHeader("Location", otherServer.url("/")));
-
-    otherServer.enqueue(new MockResponse().setHeadersDelay(500, TimeUnit.MILLISECONDS));
-
-    Request request = new Request.Builder().url(server.url("/")).build();
-
-    Call call = client.newCall(request);
-    call.timeout().timeout(250, TimeUnit.MILLISECONDS);
-    try {
-      call.execute();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("timeout");
-      assertThat(call.isCanceled()).isTrue();
-    }
-  }
-
-  @Flaky
-  @Test public void noTimeout() throws Exception {
-    // Flaky https://github.com/square/okhttp/issues/5304
-
-    server.enqueue(new MockResponse()
-        .setHeadersDelay(250, TimeUnit.MILLISECONDS)
-        .setBody(BIG_ENOUGH_BODY));
-
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .post(sleepingRequestBody(250))
-        .build();
-
-    Call call = client.newCall(request);
-    call.timeout().timeout(2000, TimeUnit.MILLISECONDS);
-    Response response = call.execute();
-    Thread.sleep(250);
-    response.body().source().readUtf8();
-    response.close();
-    assertThat(call.isCanceled()).isFalse();
-  }
-
-  private RequestBody sleepingRequestBody(final int sleepMillis) {
-    return new RequestBody() {
-      @Override public MediaType contentType() {
-        return MediaType.parse("text/plain");
-      }
-
-      @Override public void writeTo(BufferedSink sink) throws IOException {
-        try {
-          sink.writeUtf8("abc");
-          sink.flush();
-          Thread.sleep(sleepMillis);
-          sink.writeUtf8("def");
-        } catch (InterruptedException e) {
-          throw new InterruptedIOException();
-        }
-      }
-    };
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/DoubleInetAddressDns.java b/okhttp/src/test/java/okhttp3/internal/DoubleInetAddressDns.java
deleted file mode 100644
index ac42c15c7f..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/DoubleInetAddressDns.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal;
-
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.List;
-import okhttp3.Dns;
-
-import static java.util.Arrays.asList;
-
-/**
- * A network that always resolves two IP addresses per host. Use this when testing route selection
- * fallbacks to guarantee that a fallback address is available.
- */
-public class DoubleInetAddressDns implements Dns {
-  @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
-    List<InetAddress> addresses = Dns.SYSTEM.lookup(hostname);
-    return asList(addresses.get(0), addresses.get(0));
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/RecordingAuthenticator.java b/okhttp/src/test/java/okhttp3/internal/RecordingAuthenticator.java
deleted file mode 100644
index aeb34f742f..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/RecordingAuthenticator.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal;
-
-import java.net.Authenticator;
-import java.net.PasswordAuthentication;
-import java.util.ArrayList;
-import java.util.List;
-
-public final class RecordingAuthenticator extends Authenticator {
-  /** base64("username:password") */
-  public static final String BASE_64_CREDENTIALS = "dXNlcm5hbWU6cGFzc3dvcmQ=";
-
-  public final List<String> calls = new ArrayList<>();
-  public final PasswordAuthentication authentication;
-
-  public RecordingAuthenticator(PasswordAuthentication authentication) {
-    this.authentication = authentication;
-  }
-
-  public RecordingAuthenticator() {
-    this(new PasswordAuthentication("username", "password".toCharArray()));
-  }
-
-  @Override protected PasswordAuthentication getPasswordAuthentication() {
-    this.calls.add("host=" + getRequestingHost()
-        + " port=" + getRequestingPort()
-        + " site=" + getRequestingSite().getHostName()
-        + " url=" + getRequestingURL()
-        + " type=" + getRequestorType()
-        + " prompt=" + getRequestingPrompt()
-        + " protocol=" + getRequestingProtocol()
-        + " scheme=" + getRequestingScheme());
-    return authentication;
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java b/okhttp/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
deleted file mode 100644
index 126fce4d7e..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal;
-
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-import javax.annotation.Nullable;
-import okhttp3.Authenticator;
-import okhttp3.Challenge;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.Route;
-
-public final class RecordingOkAuthenticator implements Authenticator {
-  public final List<Response> responses = new ArrayList<>();
-  public final List<Route> routes = new ArrayList<>();
-  public @Nullable String credential;
-  public @Nullable String scheme;
-
-  public RecordingOkAuthenticator(@Nullable String credential, @Nullable String scheme) {
-    this.credential = credential;
-    this.scheme = scheme;
-  }
-
-  public Response onlyResponse() {
-    if (responses.size() != 1) throw new IllegalStateException();
-    return responses.get(0);
-  }
-
-  public Route onlyRoute() {
-    if (routes.size() != 1) throw new IllegalStateException();
-    return routes.get(0);
-  }
-
-  @Override public Request authenticate(Route route, Response response) throws IOException {
-    if (route == null) throw new NullPointerException("route == null");
-    if (response == null) throw new NullPointerException("response == null");
-
-    responses.add(response);
-    routes.add(route);
-
-    if (!schemeMatches(response) || credential == null) return null;
-
-    String header = response.code() == 407 ? "Proxy-Authorization" : "Authorization";
-    return response.request().newBuilder()
-        .addHeader(header, credential)
-        .build();
-  }
-
-  private boolean schemeMatches(Response response) {
-    if (scheme == null) return true;
-
-    for (Challenge challenge : response.challenges()) {
-      if (challenge.scheme().equalsIgnoreCase(scheme)) return true;
-    }
-
-    return false;
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/SocketRecorder.java b/okhttp/src/test/java/okhttp3/internal/SocketRecorder.java
deleted file mode 100644
index ba3b84f91e..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/SocketRecorder.java
+++ /dev/null
@@ -1,206 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.net.Socket;
-import java.util.Deque;
-import java.util.concurrent.LinkedBlockingDeque;
-import javax.net.ssl.SSLSocket;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.DelegatingSSLSocket;
-import okhttp3.DelegatingSSLSocketFactory;
-import okio.Buffer;
-import okio.ByteString;
-
-/** Records all bytes written and read from a socket and makes them available for inspection. */
-public final class SocketRecorder {
-  private final Deque<RecordedSocket> recordedSockets = new LinkedBlockingDeque<>();
-
-  /** Returns an SSLSocketFactory whose sockets will record all transmitted bytes. */
-  public SSLSocketFactory sslSocketFactory(SSLSocketFactory delegate) {
-    return new DelegatingSSLSocketFactory(delegate) {
-      @Override protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
-        RecordedSocket recordedSocket = new RecordedSocket();
-        recordedSockets.add(recordedSocket);
-        return new RecordingSSLSocket(sslSocket, recordedSocket);
-      }
-    };
-  }
-
-  public RecordedSocket takeSocket() {
-    return recordedSockets.remove();
-  }
-
-  /** A bidirectional transfer of unadulterated bytes over a socket. */
-  public static final class RecordedSocket {
-    private final Buffer bytesWritten = new Buffer();
-    private final Buffer bytesRead = new Buffer();
-
-    synchronized void byteWritten(int b) {
-      bytesWritten.writeByte(b);
-    }
-
-    synchronized void byteRead(int b) {
-      bytesRead.writeByte(b);
-    }
-
-    synchronized void bytesWritten(byte[] bytes, int offset, int length) {
-      bytesWritten.write(bytes, offset, length);
-    }
-
-    synchronized void bytesRead(byte[] bytes, int offset, int length) {
-      bytesRead.write(bytes, offset, length);
-    }
-
-    /** Returns all bytes that have been written to this socket. */
-    public synchronized ByteString bytesWritten() {
-      return bytesWritten.readByteString();
-    }
-
-    /** Returns all bytes that have been read from this socket. */
-    public synchronized ByteString bytesRead() {
-      return bytesRead.readByteString();
-    }
-  }
-
-  static final class RecordingInputStream extends InputStream {
-    private final Socket socket;
-    private final RecordedSocket recordedSocket;
-
-    RecordingInputStream(Socket socket, RecordedSocket recordedSocket) {
-      this.socket = socket;
-      this.recordedSocket = recordedSocket;
-    }
-
-    @Override public int read() throws IOException {
-      int b = socket.getInputStream().read();
-      if (b == -1) return -1;
-      recordedSocket.byteRead(b);
-      return b;
-    }
-
-    @Override public int read(byte[] b, int off, int len) throws IOException {
-      int read = socket.getInputStream().read(b, off, len);
-      if (read == -1) return -1;
-      recordedSocket.bytesRead(b, off, read);
-      return read;
-    }
-
-    @Override public void close() throws IOException {
-      socket.getInputStream().close();
-    }
-  }
-
-  static final class RecordingOutputStream extends OutputStream {
-    private final Socket socket;
-    private final RecordedSocket recordedSocket;
-
-    RecordingOutputStream(Socket socket, RecordedSocket recordedSocket) {
-      this.socket = socket;
-      this.recordedSocket = recordedSocket;
-    }
-
-    @Override public void write(int b) throws IOException {
-      socket.getOutputStream().write(b);
-      recordedSocket.byteWritten(b);
-    }
-
-    @Override public void write(byte[] b, int off, int len) throws IOException {
-      socket.getOutputStream().write(b, off, len);
-      recordedSocket.bytesWritten(b, off, len);
-    }
-
-    @Override public void close() throws IOException {
-      socket.getOutputStream().close();
-    }
-
-    @Override public void flush() throws IOException {
-      socket.getOutputStream().flush();
-    }
-  }
-
-  static final class RecordingSSLSocket extends DelegatingSSLSocket {
-    private final InputStream inputStream;
-    private final OutputStream outputStream;
-
-    RecordingSSLSocket(SSLSocket delegate, RecordedSocket recordedSocket) {
-      super(delegate);
-      inputStream = new RecordingInputStream(delegate, recordedSocket);
-      outputStream = new RecordingOutputStream(delegate, recordedSocket);
-    }
-
-    @Override public void startHandshake() throws IOException {
-      // Intercept the handshake to properly configure TLS extensions with Jetty ALPN. Jetty ALPN
-      // expects the real SSLSocket to be placed in the global map. Because we are wrapping the real
-      // SSLSocket, it confuses Jetty ALPN. This patches that up so things work as expected.
-      Class<?> alpn = null;
-      Class<?> provider = null;
-      try {
-        alpn = Class.forName("org.eclipse.jetty.alpn.ALPN");
-        provider = Class.forName("org.eclipse.jetty.alpn.ALPN$Provider");
-      } catch (ClassNotFoundException ignored) {
-      }
-
-      if (alpn == null || provider == null) {
-        // No Jetty, so nothing to worry about.
-        super.startHandshake();
-        return;
-      }
-
-      Object providerInstance = null;
-      Method putMethod = null;
-      try {
-        Method getMethod = alpn.getMethod("get", SSLSocket.class);
-        putMethod = alpn.getMethod("put", SSLSocket.class, provider);
-        providerInstance = getMethod.invoke(null, this);
-        if (providerInstance == null) {
-          // Jetty's on the classpath but TLS extensions weren't used.
-          super.startHandshake();
-          return;
-        }
-
-        // TLS extensions were used; replace with the real SSLSocket to make Jetty ALPN happy.
-        putMethod.invoke(null, delegate, providerInstance);
-        super.startHandshake();
-      } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
-        throw new AssertionError();
-      } finally {
-        // If we replaced the SSLSocket in the global map, we must put the original back for
-        // everything to work inside OkHttp.
-        if (providerInstance != null) {
-          try {
-            putMethod.invoke(null, this, providerInstance);
-          } catch (IllegalAccessException | InvocationTargetException e) {
-            throw new AssertionError();
-          }
-        }
-      }
-    }
-
-    @Override public InputStream getInputStream() throws IOException {
-      return inputStream;
-    }
-
-    @Override public OutputStream getOutputStream() throws IOException {
-      return outputStream;
-    }
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/UtilTest.kt b/okhttp/src/test/java/okhttp3/internal/UtilTest.kt
deleted file mode 100644
index 6e9d05f7ac..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/UtilTest.kt
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal
-
-import org.assertj.core.api.Assertions.assertThat
-import org.junit.Assert.fail
-import org.junit.Test
-import java.util.LinkedHashMap
-
-class UtilTest {
-  @Test fun immutableMap() {
-    val map = LinkedHashMap<String, String>()
-    map["a"] = "A"
-    val immutableCopy = map.toImmutableMap()
-    assertThat(mapOf("a" to "A")).isEqualTo(immutableCopy)
-    map.clear()
-    assertThat(mapOf("a" to "A")).isEqualTo(immutableCopy)
-    try {
-      (immutableCopy as MutableMap).clear()
-      fail()
-    } catch (_: UnsupportedOperationException) {
-    }
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java b/okhttp/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
deleted file mode 100644
index 9fe5131094..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
+++ /dev/null
@@ -1,1829 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Deque;
-import java.util.Iterator;
-import java.util.List;
-import java.util.NoSuchElementException;
-import okhttp3.internal.concurrent.TaskFaker;
-import okhttp3.internal.concurrent.TaskRunner;
-import okhttp3.internal.io.FaultyFileSystem;
-import okhttp3.internal.io.FileSystem;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.Okio;
-import okio.Source;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-import org.junit.rules.Timeout;
-
-import static java.util.Arrays.asList;
-import static okhttp3.internal.cache.DiskLruCache.JOURNAL_FILE;
-import static okhttp3.internal.cache.DiskLruCache.JOURNAL_FILE_BACKUP;
-import static okhttp3.internal.cache.DiskLruCache.MAGIC;
-import static okhttp3.internal.cache.DiskLruCache.VERSION_1;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class DiskLruCacheTest {
-  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
-  @Rule public final Timeout timeout = new Timeout(60 * 1000);
-
-  private final FaultyFileSystem fileSystem = new FaultyFileSystem(FileSystem.SYSTEM);
-  private final int appVersion = 100;
-  private File cacheDir;
-  private File journalFile;
-  private File journalBkpFile;
-  private final TaskFaker taskFaker = new TaskFaker();
-  private final TaskRunner taskRunner = taskFaker.getTaskRunner();
-
-  private DiskLruCache cache;
-  private final Deque<DiskLruCache> toClose = new ArrayDeque<>();
-
-  private void createNewCache() throws IOException {
-    createNewCacheWithSize(Integer.MAX_VALUE);
-  }
-
-  private void createNewCacheWithSize(int maxSize) throws IOException {
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, maxSize, taskRunner);
-    synchronized (cache) {
-      cache.initialize();
-    }
-    toClose.add(cache);
-  }
-
-  @Before public void setUp() throws Exception {
-    cacheDir = tempDir.getRoot();
-    journalFile = new File(cacheDir, JOURNAL_FILE);
-    journalBkpFile = new File(cacheDir, JOURNAL_FILE_BACKUP);
-    createNewCache();
-  }
-
-  @After public void tearDown() throws Exception {
-    while (!toClose.isEmpty()) {
-      toClose.pop().close();
-    }
-  }
-
-  @Test public void emptyCache() throws Exception {
-    cache.close();
-    assertJournalEquals();
-  }
-
-  @Test public void recoverFromInitializationFailure() throws IOException {
-    // Add an uncommitted entry. This will get detected on initialization, and the cache will
-    // attempt to delete the file. Do not explicitly close the cache here so the entry is left as
-    // incomplete.
-    DiskLruCache.Editor creator = cache.edit("k1");
-    BufferedSink sink = Okio.buffer(creator.newSink(0));
-    sink.writeUtf8("Hello");
-    sink.close();
-
-    // Simulate a severe filesystem failure on the first initialization.
-    fileSystem.setFaultyDelete(new File(cacheDir, "k1.0.tmp"), true);
-    fileSystem.setFaultyDelete(cacheDir, true);
-
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, taskRunner);
-    toClose.add(cache);
-
-    try {
-      cache.get("k1");
-      fail();
-    } catch (IOException expected) {
-    }
-
-    // Now let it operate normally.
-    fileSystem.setFaultyDelete(new File(cacheDir, "k1.0.tmp"), false);
-    fileSystem.setFaultyDelete(cacheDir, false);
-
-    DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertThat(snapshot).isNull();
-  }
-
-  @Test public void validateKey() throws Exception {
-    String key = null;
-    try {
-      key = "has_space ";
-      cache.edit(key);
-      fail("Expecting an IllegalArgumentException as the key was invalid.");
-    } catch (IllegalArgumentException iae) {
-      assertThat(iae.getMessage()).isEqualTo(
-          ("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\""));
-    }
-    try {
-      key = "has_CR\r";
-      cache.edit(key);
-      fail("Expecting an IllegalArgumentException as the key was invalid.");
-    } catch (IllegalArgumentException iae) {
-      assertThat(iae.getMessage()).isEqualTo(
-          ("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\""));
-    }
-    try {
-      key = "has_LF\n";
-      cache.edit(key);
-      fail("Expecting an IllegalArgumentException as the key was invalid.");
-    } catch (IllegalArgumentException iae) {
-      assertThat(iae.getMessage()).isEqualTo(
-          ("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\""));
-    }
-    try {
-      key = "has_invalid/";
-      cache.edit(key);
-      fail("Expecting an IllegalArgumentException as the key was invalid.");
-    } catch (IllegalArgumentException iae) {
-      assertThat(iae.getMessage()).isEqualTo(
-          ("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\""));
-    }
-    try {
-      key = "has_invalid\u2603";
-      cache.edit(key);
-      fail("Expecting an IllegalArgumentException as the key was invalid.");
-    } catch (IllegalArgumentException iae) {
-      assertThat(iae.getMessage()).isEqualTo(
-          ("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\""));
-    }
-    try {
-      key = "this_is_way_too_long_this_is_way_too_long_this_is_way_too_long_"
-          + "this_is_way_too_long_this_is_way_too_long_this_is_way_too_long";
-      cache.edit(key);
-      fail("Expecting an IllegalArgumentException as the key was too long.");
-    } catch (IllegalArgumentException iae) {
-      assertThat(iae.getMessage()).isEqualTo(
-          ("keys must match regex [a-z0-9_-]{1,120}: \"" + key + "\""));
-    }
-
-    // Test valid cases.
-
-    // Exactly 120.
-    key = "0123456789012345678901234567890123456789012345678901234567890123456789"
-        + "01234567890123456789012345678901234567890123456789";
-    cache.edit(key).abort();
-    // Contains all valid characters.
-    key = "abcdefghijklmnopqrstuvwxyz_0123456789";
-    cache.edit(key).abort();
-    // Contains dash.
-    key = "-20384573948576";
-    cache.edit(key).abort();
-  }
-
-  @Test public void writeAndReadEntry() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 0, "ABC");
-    setString(creator, 1, "DE");
-    assertThat(creator.newSource(0)).isNull();
-    assertThat(creator.newSource(1)).isNull();
-    creator.commit();
-
-    DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertSnapshotValue(snapshot, 0, "ABC");
-    assertSnapshotValue(snapshot, 1, "DE");
-  }
-
-  @Test public void readAndWriteEntryAcrossCacheOpenAndClose() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 0, "A");
-    setString(creator, 1, "B");
-    creator.commit();
-    cache.close();
-
-    createNewCache();
-    DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertSnapshotValue(snapshot, 0, "A");
-    assertSnapshotValue(snapshot, 1, "B");
-    snapshot.close();
-  }
-
-  @Test public void readAndWriteEntryWithoutProperClose() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 0, "A");
-    setString(creator, 1, "B");
-    creator.commit();
-
-    // Simulate a dirty close of 'cache' by opening the cache directory again.
-    createNewCache();
-    DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertSnapshotValue(snapshot, 0, "A");
-    assertSnapshotValue(snapshot, 1, "B");
-    snapshot.close();
-  }
-
-  @Test public void journalWithEditAndPublish() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    assertJournalEquals("DIRTY k1"); // DIRTY must always be flushed.
-    setString(creator, 0, "AB");
-    setString(creator, 1, "C");
-    creator.commit();
-    cache.close();
-    assertJournalEquals("DIRTY k1", "CLEAN k1 2 1");
-  }
-
-  @Test public void revertedNewFileIsRemoveInJournal() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    assertJournalEquals("DIRTY k1"); // DIRTY must always be flushed.
-    setString(creator, 0, "AB");
-    setString(creator, 1, "C");
-    creator.abort();
-    cache.close();
-    assertJournalEquals("DIRTY k1", "REMOVE k1");
-  }
-
-  @Test public void unterminatedEditIsRevertedOnClose() throws Exception {
-    cache.edit("k1");
-    cache.close();
-    assertJournalEquals("DIRTY k1", "REMOVE k1");
-  }
-
-  @Test public void journalDoesNotIncludeReadOfYetUnpublishedValue() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    assertThat(cache.get("k1")).isNull();
-    setString(creator, 0, "A");
-    setString(creator, 1, "BC");
-    creator.commit();
-    cache.close();
-    assertJournalEquals("DIRTY k1", "CLEAN k1 1 2");
-  }
-
-  @Test public void journalWithEditAndPublishAndRead() throws Exception {
-    DiskLruCache.Editor k1Creator = cache.edit("k1");
-    setString(k1Creator, 0, "AB");
-    setString(k1Creator, 1, "C");
-    k1Creator.commit();
-    DiskLruCache.Editor k2Creator = cache.edit("k2");
-    setString(k2Creator, 0, "DEF");
-    setString(k2Creator, 1, "G");
-    k2Creator.commit();
-    DiskLruCache.Snapshot k1Snapshot = cache.get("k1");
-    k1Snapshot.close();
-    cache.close();
-    assertJournalEquals("DIRTY k1", "CLEAN k1 2 1", "DIRTY k2", "CLEAN k2 3 1", "READ k1");
-  }
-
-  @Test public void cannotOperateOnEditAfterPublish() throws Exception {
-    DiskLruCache.Editor editor = cache.edit("k1");
-    setString(editor, 0, "A");
-    setString(editor, 1, "B");
-    editor.commit();
-    assertInoperable(editor);
-  }
-
-  @Test public void cannotOperateOnEditAfterRevert() throws Exception {
-    DiskLruCache.Editor editor = cache.edit("k1");
-    setString(editor, 0, "A");
-    setString(editor, 1, "B");
-    editor.abort();
-    assertInoperable(editor);
-  }
-
-  @Test public void explicitRemoveAppliedToDiskImmediately() throws Exception {
-    DiskLruCache.Editor editor = cache.edit("k1");
-    setString(editor, 0, "ABC");
-    setString(editor, 1, "B");
-    editor.commit();
-    File k1 = getCleanFile("k1", 0);
-    assertThat(readFile(k1)).isEqualTo("ABC");
-    cache.remove("k1");
-    assertThat(fileSystem.exists(k1)).isFalse();
-  }
-
-  @Test public void removePreventsActiveEditFromStoringAValue() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Editor a = cache.edit("a");
-    setString(a, 0, "a1");
-    assertThat(cache.remove("a")).isTrue();
-    setString(a, 1, "a2");
-    a.commit();
-    assertAbsent("a");
-  }
-
-  /**
-   * Each read sees a snapshot of the file at the time read was called. This means that two reads of
-   * the same key can see different data.
-   */
-  @Test public void readAndWriteOverlapsMaintainConsistency() throws Exception {
-    DiskLruCache.Editor v1Creator = cache.edit("k1");
-    setString(v1Creator, 0, "AAaa");
-    setString(v1Creator, 1, "BBbb");
-    v1Creator.commit();
-
-    DiskLruCache.Snapshot snapshot1 = cache.get("k1");
-    BufferedSource inV1 = Okio.buffer(snapshot1.getSource(0));
-    assertThat(inV1.readByte()).isEqualTo((byte) 'A');
-    assertThat(inV1.readByte()).isEqualTo((byte) 'A');
-
-    DiskLruCache.Editor v1Updater = cache.edit("k1");
-    setString(v1Updater, 0, "CCcc");
-    setString(v1Updater, 1, "DDdd");
-    v1Updater.commit();
-
-    DiskLruCache.Snapshot snapshot2 = cache.get("k1");
-    assertSnapshotValue(snapshot2, 0, "CCcc");
-    assertSnapshotValue(snapshot2, 1, "DDdd");
-    snapshot2.close();
-
-    assertThat(inV1.readByte()).isEqualTo((byte) 'a');
-    assertThat(inV1.readByte()).isEqualTo((byte) 'a');
-    assertSnapshotValue(snapshot1, 1, "BBbb");
-    snapshot1.close();
-  }
-
-  @Test public void openWithDirtyKeyDeletesAllFilesForThatKey() throws Exception {
-    cache.close();
-    File cleanFile0 = getCleanFile("k1", 0);
-    File cleanFile1 = getCleanFile("k1", 1);
-    File dirtyFile0 = getDirtyFile("k1", 0);
-    File dirtyFile1 = getDirtyFile("k1", 1);
-    writeFile(cleanFile0, "A");
-    writeFile(cleanFile1, "B");
-    writeFile(dirtyFile0, "C");
-    writeFile(dirtyFile1, "D");
-    createJournal("CLEAN k1 1 1", "DIRTY   k1");
-    createNewCache();
-    assertThat(fileSystem.exists(cleanFile0)).isFalse();
-    assertThat(fileSystem.exists(cleanFile1)).isFalse();
-    assertThat(fileSystem.exists(dirtyFile0)).isFalse();
-    assertThat(fileSystem.exists(dirtyFile1)).isFalse();
-    assertThat(cache.get("k1")).isNull();
-  }
-
-  @Test public void openWithInvalidVersionClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournalWithHeader(MAGIC, "0", "100", "2", "");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-  }
-
-  @Test public void openWithInvalidAppVersionClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournalWithHeader(MAGIC, "1", "101", "2", "");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-  }
-
-  @Test public void openWithInvalidValueCountClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournalWithHeader(MAGIC, "1", "100", "1", "");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-  }
-
-  @Test public void openWithInvalidBlankLineClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournalWithHeader(MAGIC, "1", "100", "2", "x");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-  }
-
-  @Test public void openWithInvalidJournalLineClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournal("CLEAN k1 1 1", "BOGUS");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-    assertThat(cache.get("k1")).isNull();
-  }
-
-  @Test public void openWithInvalidFileSizeClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournal("CLEAN k1 0000x001 1");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-    assertThat(cache.get("k1")).isNull();
-  }
-
-  @Test public void openWithTruncatedLineDiscardsThatLine() throws Exception {
-    cache.close();
-    writeFile(getCleanFile("k1", 0), "A");
-    writeFile(getCleanFile("k1", 1), "B");
-
-    BufferedSink sink = Okio.buffer(fileSystem.sink(journalFile));
-    sink.writeUtf8(MAGIC + "\n" + VERSION_1 + "\n100\n2\n\nCLEAN k1 1 1"); // no trailing newline
-    sink.close();
-    createNewCache();
-    assertThat(cache.get("k1")).isNull();
-
-    // The journal is not corrupt when editing after a truncated line.
-    set("k1", "C", "D");
-
-    cache.close();
-    createNewCache();
-    assertValue("k1", "C", "D");
-  }
-
-  @Test public void openWithTooManyFileSizesClearsDirectory() throws Exception {
-    cache.close();
-    generateSomeGarbageFiles();
-    createJournal("CLEAN k1 1 1 1");
-    createNewCache();
-    assertGarbageFilesAllDeleted();
-    assertThat(cache.get("k1")).isNull();
-  }
-
-  @Test public void keyWithSpaceNotPermitted() throws Exception {
-    try {
-      cache.edit("my key");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void keyWithNewlineNotPermitted() throws Exception {
-    try {
-      cache.edit("my\nkey");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void keyWithCarriageReturnNotPermitted() throws Exception {
-    try {
-      cache.edit("my\rkey");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void nullKeyThrows() throws Exception {
-    try {
-      cache.edit(null);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void createNewEntryWithTooFewValuesFails() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 1, "A");
-    try {
-      creator.commit();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-
-    assertThat(fileSystem.exists(getCleanFile("k1", 0))).isFalse();
-    assertThat(fileSystem.exists(getCleanFile("k1", 1))).isFalse();
-    assertThat(fileSystem.exists(getDirtyFile("k1", 0))).isFalse();
-    assertThat(fileSystem.exists(getDirtyFile("k1", 1))).isFalse();
-    assertThat(cache.get("k1")).isNull();
-
-    DiskLruCache.Editor creator2 = cache.edit("k1");
-    setString(creator2, 0, "B");
-    setString(creator2, 1, "C");
-    creator2.commit();
-  }
-
-  @Test public void revertWithTooFewValues() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 1, "A");
-    creator.abort();
-    assertThat(fileSystem.exists(getCleanFile("k1", 0))).isFalse();
-    assertThat(fileSystem.exists(getCleanFile("k1", 1))).isFalse();
-    assertThat(fileSystem.exists(getDirtyFile("k1", 0))).isFalse();
-    assertThat(fileSystem.exists(getDirtyFile("k1", 1))).isFalse();
-    assertThat(cache.get("k1")).isNull();
-  }
-
-  @Test public void updateExistingEntryWithTooFewValuesReusesPreviousValues() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 0, "A");
-    setString(creator, 1, "B");
-    creator.commit();
-
-    DiskLruCache.Editor updater = cache.edit("k1");
-    setString(updater, 0, "C");
-    updater.commit();
-
-    DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertSnapshotValue(snapshot, 0, "C");
-    assertSnapshotValue(snapshot, 1, "B");
-    snapshot.close();
-  }
-
-  @Test public void growMaxSize() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-    set("a", "a", "aaa"); // size 4
-    set("b", "bb", "bbbb"); // size 6
-    cache.setMaxSize(20);
-    set("c", "c", "c"); // size 12
-    assertThat(cache.size()).isEqualTo(12);
-  }
-
-  @Test public void shrinkMaxSizeEvicts() throws Exception {
-    cache.close();
-    createNewCacheWithSize(20);
-    set("a", "a", "aaa"); // size 4
-    set("b", "bb", "bbbb"); // size 6
-    set("c", "c", "c"); // size 12
-    cache.setMaxSize(10);
-    assertThat(taskFaker.isIdle()).isFalse();
-  }
-
-  @Test public void evictOnInsert() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-
-    set("a", "a", "aaa"); // size 4
-    set("b", "bb", "bbbb"); // size 6
-    assertThat(cache.size()).isEqualTo(10);
-
-    // Cause the size to grow to 12 should evict 'A'.
-    set("c", "c", "c");
-    cache.flush();
-    assertThat(cache.size()).isEqualTo(8);
-    assertAbsent("a");
-    assertValue("b", "bb", "bbbb");
-    assertValue("c", "c", "c");
-
-    // Causing the size to grow to 10 should evict nothing.
-    set("d", "d", "d");
-    cache.flush();
-    assertThat(cache.size()).isEqualTo(10);
-    assertAbsent("a");
-    assertValue("b", "bb", "bbbb");
-    assertValue("c", "c", "c");
-    assertValue("d", "d", "d");
-
-    // Causing the size to grow to 18 should evict 'B' and 'C'.
-    set("e", "eeee", "eeee");
-    cache.flush();
-    assertThat(cache.size()).isEqualTo(10);
-    assertAbsent("a");
-    assertAbsent("b");
-    assertAbsent("c");
-    assertValue("d", "d", "d");
-    assertValue("e", "eeee", "eeee");
-  }
-
-  @Test public void evictOnUpdate() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-
-    set("a", "a", "aa"); // size 3
-    set("b", "b", "bb"); // size 3
-    set("c", "c", "cc"); // size 3
-    assertThat(cache.size()).isEqualTo(9);
-
-    // Causing the size to grow to 11 should evict 'A'.
-    set("b", "b", "bbbb");
-    cache.flush();
-    assertThat(cache.size()).isEqualTo(8);
-    assertAbsent("a");
-    assertValue("b", "b", "bbbb");
-    assertValue("c", "c", "cc");
-  }
-
-  @Test public void evictionHonorsLruFromCurrentSession() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-    set("a", "a", "a");
-    set("b", "b", "b");
-    set("c", "c", "c");
-    set("d", "d", "d");
-    set("e", "e", "e");
-    cache.get("b").close(); // 'B' is now least recently used.
-
-    // Causing the size to grow to 12 should evict 'A'.
-    set("f", "f", "f");
-    // Causing the size to grow to 12 should evict 'C'.
-    set("g", "g", "g");
-    cache.flush();
-    assertThat(cache.size()).isEqualTo(10);
-    assertAbsent("a");
-    assertValue("b", "b", "b");
-    assertAbsent("c");
-    assertValue("d", "d", "d");
-    assertValue("e", "e", "e");
-    assertValue("f", "f", "f");
-  }
-
-  @Test public void evictionHonorsLruFromPreviousSession() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-    set("c", "c", "c");
-    set("d", "d", "d");
-    set("e", "e", "e");
-    set("f", "f", "f");
-    cache.get("b").close(); // 'B' is now least recently used.
-    assertThat(cache.size()).isEqualTo(12);
-    cache.close();
-    createNewCacheWithSize(10);
-
-    set("g", "g", "g");
-    cache.flush();
-    assertThat(cache.size()).isEqualTo(10);
-    assertAbsent("a");
-    assertValue("b", "b", "b");
-    assertAbsent("c");
-    assertValue("d", "d", "d");
-    assertValue("e", "e", "e");
-    assertValue("f", "f", "f");
-    assertValue("g", "g", "g");
-  }
-
-  @Test public void cacheSingleEntryOfSizeGreaterThanMaxSize() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-    set("a", "aaaaa", "aaaaaa"); // size=11
-    cache.flush();
-    assertAbsent("a");
-  }
-
-  @Test public void cacheSingleValueOfSizeGreaterThanMaxSize() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-    set("a", "aaaaaaaaaaa", "a"); // size=12
-    cache.flush();
-    assertAbsent("a");
-  }
-
-  @Test public void constructorDoesNotAllowZeroCacheSize() throws Exception {
-    try {
-      new DiskLruCache(fileSystem, cacheDir, appVersion, 2, 0, taskRunner);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void constructorDoesNotAllowZeroValuesPerEntry() throws Exception {
-    try {
-      new DiskLruCache(fileSystem, cacheDir, appVersion, 0, 10, taskRunner);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-  }
-
-  @Test public void removeAbsentElement() throws Exception {
-    cache.remove("a");
-  }
-
-  @Test public void readingTheSameStreamMultipleTimes() throws Exception {
-    set("a", "a", "b");
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    assertThat(snapshot.getSource(0)).isSameAs(snapshot.getSource(0));
-    snapshot.close();
-  }
-
-  @Test public void rebuildJournalOnRepeatedReads() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-    while (taskFaker.isIdle()) {
-      assertValue("a", "a", "a");
-      assertValue("b", "b", "b");
-    }
-  }
-
-  @Test public void rebuildJournalOnRepeatedEdits() throws Exception {
-    while (taskFaker.isIdle()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-    taskFaker.runNextTask();
-
-    // Sanity check that a rebuilt journal behaves normally.
-    assertValue("a", "a", "a");
-    assertValue("b", "b", "b");
-  }
-
-  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/28">Issue #28</a> */
-  @Test public void rebuildJournalOnRepeatedReadsWithOpenAndClose() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-    while (taskFaker.isIdle()) {
-      assertValue("a", "a", "a");
-      assertValue("b", "b", "b");
-      cache.close();
-      createNewCache();
-    }
-  }
-
-  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/28">Issue #28</a> */
-  @Test public void rebuildJournalOnRepeatedEditsWithOpenAndClose() throws Exception {
-    while (taskFaker.isIdle()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-      cache.close();
-      createNewCache();
-    }
-  }
-
-  @Test public void rebuildJournalFailurePreventsEditors() throws Exception {
-    while (taskFaker.isIdle()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    taskFaker.runNextTask();
-
-    // Don't allow edits under any circumstances.
-    assertThat(cache.edit("a")).isNull();
-    assertThat(cache.edit("c")).isNull();
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    assertThat(snapshot.edit()).isNull();
-    snapshot.close();
-  }
-
-  @Test public void rebuildJournalFailureIsRetried() throws Exception {
-    while (taskFaker.isIdle()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    taskFaker.runNextTask();
-
-    // The rebuild is retried on cache hits and on cache edits.
-    DiskLruCache.Snapshot snapshot = cache.get("b");
-    snapshot.close();
-    assertThat(cache.edit("d")).isNull();
-    assertThat(taskFaker.isIdle()).isFalse();
-
-    // On cache misses, no retry job is queued.
-    assertThat(cache.get("c")).isNull();
-    assertThat(taskFaker.isIdle()).isFalse();
-
-    // Let the rebuild complete successfully.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
-    taskFaker.runNextTask();
-    assertJournalEquals("CLEAN a 1 1", "CLEAN b 1 1");
-  }
-
-  @Test public void rebuildJournalFailureWithInFlightEditors() throws Exception {
-    while (taskFaker.isIdle()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-    DiskLruCache.Editor commitEditor = cache.edit("c");
-    DiskLruCache.Editor abortEditor = cache.edit("d");
-    cache.edit("e"); // Grab an editor, but don't do anything with it.
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    taskFaker.runNextTask();
-
-    // In-flight editors can commit and have their values retained.
-    setString(commitEditor, 0, "c");
-    setString(commitEditor, 1, "c");
-    commitEditor.commit();
-    assertValue("c", "c", "c");
-
-    abortEditor.abort();
-
-    // Let the rebuild complete successfully.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
-    taskFaker.runNextTask();
-    assertJournalEquals("CLEAN a 1 1", "CLEAN b 1 1", "DIRTY e", "CLEAN c 1 1");
-  }
-
-  @Test public void rebuildJournalFailureWithEditorsInFlightThenClose() throws Exception {
-    while (taskFaker.isIdle()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-    DiskLruCache.Editor commitEditor = cache.edit("c");
-    DiskLruCache.Editor abortEditor = cache.edit("d");
-    cache.edit("e"); // Grab an editor, but don't do anything with it.
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    taskFaker.runNextTask();
-
-    setString(commitEditor, 0, "c");
-    setString(commitEditor, 1, "c");
-    commitEditor.commit();
-    assertValue("c", "c", "c");
-
-    abortEditor.abort();
-
-    cache.close();
-    createNewCache();
-
-    // Although 'c' successfully committed above, the journal wasn't available to issue a CLEAN op.
-    // Because the last state of 'c' was DIRTY before the journal failed, it should be removed
-    // entirely on a subsequent open.
-    assertThat(cache.size()).isEqualTo(4);
-    assertAbsent("c");
-    assertAbsent("d");
-    assertAbsent("e");
-  }
-
-  @Test public void rebuildJournalFailureAllowsRemovals() throws Exception {
-    while (taskFaker.isIdle()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    taskFaker.runNextTask();
-
-    assertThat(cache.remove("a")).isTrue();
-    assertAbsent("a");
-
-    // Let the rebuild complete successfully.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), false);
-    taskFaker.runNextTask();
-
-    assertJournalEquals("CLEAN b 1 1");
-  }
-
-  @Test public void rebuildJournalFailureWithRemovalThenClose() throws Exception {
-    while (taskFaker.isIdle()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    taskFaker.runNextTask();
-
-    assertThat(cache.remove("a")).isTrue();
-    assertAbsent("a");
-
-    cache.close();
-    createNewCache();
-
-    // The journal will have no record that 'a' was removed. It will have an entry for 'a', but when
-    // it tries to read the cache files, it will find they were deleted. Once it encounters an entry
-    // with missing cache files, it should remove it from the cache entirely.
-    assertThat(cache.size()).isEqualTo(4);
-    assertThat(cache.get("a")).isNull();
-    assertThat(cache.size()).isEqualTo(2);
-  }
-
-  @Test public void rebuildJournalFailureAllowsEvictAll() throws Exception {
-    while (taskFaker.isIdle()) {
-      set("a", "a", "a");
-      set("b", "b", "b");
-    }
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    taskFaker.runNextTask();
-
-    cache.evictAll();
-
-    assertThat(cache.size()).isEqualTo(0);
-    assertAbsent("a");
-    assertAbsent("b");
-
-    cache.close();
-    createNewCache();
-
-    // The journal has no record that 'a' and 'b' were removed. It will have an entry for both, but
-    // when it tries to read the cache files for either entry, it will discover the cache files are
-    // missing and remove the entries from the cache.
-    assertThat(cache.size()).isEqualTo(4);
-    assertThat(cache.get("a")).isNull();
-    assertThat(cache.get("b")).isNull();
-    assertThat(cache.size()).isEqualTo(0);
-  }
-
-  @Test public void rebuildJournalFailureWithCacheTrim() throws Exception {
-    while (taskFaker.isIdle()) {
-      set("a", "aa", "aa");
-      set("b", "bb", "bb");
-    }
-
-    // Cause the rebuild action to fail.
-    fileSystem.setFaultyRename(new File(cacheDir, DiskLruCache.JOURNAL_FILE_BACKUP), true);
-    taskFaker.runNextTask();
-
-    // Trigger a job to trim the cache.
-    cache.setMaxSize(4);
-    taskFaker.runNextTask();
-
-    assertAbsent("a");
-    assertValue("b", "bb", "bb");
-  }
-
-  @Test public void restoreBackupFile() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 0, "ABC");
-    setString(creator, 1, "DE");
-    creator.commit();
-    cache.close();
-
-    fileSystem.rename(journalFile, journalBkpFile);
-    assertThat(fileSystem.exists(journalFile)).isFalse();
-
-    createNewCache();
-
-    DiskLruCache.Snapshot snapshot = cache.get("k1");
-    assertSnapshotValue(snapshot, 0, "ABC");
-    assertSnapshotValue(snapshot, 1, "DE");
-
-    assertThat(fileSystem.exists(journalBkpFile)).isFalse();
-    assertThat(fileSystem.exists(journalFile)).isTrue();
-  }
-
-  @Test public void journalFileIsPreferredOverBackupFile() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 0, "ABC");
-    setString(creator, 1, "DE");
-    creator.commit();
-    cache.flush();
-
-    copyFile(journalFile, journalBkpFile);
-
-    creator = cache.edit("k2");
-    setString(creator, 0, "F");
-    setString(creator, 1, "GH");
-    creator.commit();
-    cache.close();
-
-    assertThat(fileSystem.exists(journalFile)).isTrue();
-    assertThat(fileSystem.exists(journalBkpFile)).isTrue();
-
-    createNewCache();
-
-    DiskLruCache.Snapshot snapshotA = cache.get("k1");
-    assertSnapshotValue(snapshotA, 0, "ABC");
-    assertSnapshotValue(snapshotA, 1, "DE");
-
-    DiskLruCache.Snapshot snapshotB = cache.get("k2");
-    assertSnapshotValue(snapshotB, 0, "F");
-    assertSnapshotValue(snapshotB, 1, "GH");
-
-    assertThat(fileSystem.exists(journalBkpFile)).isFalse();
-    assertThat(fileSystem.exists(journalFile)).isTrue();
-  }
-
-  @Test public void openCreatesDirectoryIfNecessary() throws Exception {
-    cache.close();
-    File dir = tempDir.newFolder("testOpenCreatesDirectoryIfNecessary");
-    cache = new DiskLruCache(fileSystem, dir, appVersion, 2, Integer.MAX_VALUE, taskRunner);
-    set("a", "a", "a");
-    assertThat(fileSystem.exists(new File(dir, "a.0"))).isTrue();
-    assertThat(fileSystem.exists(new File(dir, "a.1"))).isTrue();
-    assertThat(fileSystem.exists(new File(dir, "journal"))).isTrue();
-  }
-
-  @Test public void fileDeletedExternally() throws Exception {
-    set("a", "a", "a");
-    fileSystem.delete(getCleanFile("a", 1));
-    assertThat(cache.get("a")).isNull();
-    assertThat(cache.size()).isEqualTo(0);
-  }
-
-  @Test public void editSameVersion() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    DiskLruCache.Editor editor = snapshot.edit();
-    setString(editor, 1, "a2");
-    editor.commit();
-    assertValue("a", "a", "a2");
-  }
-
-  @Test public void editSnapshotAfterChangeAborted() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    DiskLruCache.Editor toAbort = snapshot.edit();
-    setString(toAbort, 0, "b");
-    toAbort.abort();
-    DiskLruCache.Editor editor = snapshot.edit();
-    setString(editor, 1, "a2");
-    editor.commit();
-    assertValue("a", "a", "a2");
-  }
-
-  @Test public void editSnapshotAfterChangeCommitted() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    DiskLruCache.Editor toAbort = snapshot.edit();
-    setString(toAbort, 0, "b");
-    toAbort.commit();
-    assertThat(snapshot.edit()).isNull();
-  }
-
-  @Test public void editSinceEvicted() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-    set("a", "aa", "aaa"); // size 5
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    set("b", "bb", "bbb"); // size 5
-    set("c", "cc", "ccc"); // size 5; will evict 'A'
-    cache.flush();
-    assertThat(snapshot.edit()).isNull();
-  }
-
-  @Test public void editSinceEvictedAndRecreated() throws Exception {
-    cache.close();
-    createNewCacheWithSize(10);
-    set("a", "aa", "aaa"); // size 5
-    DiskLruCache.Snapshot snapshot = cache.get("a");
-    set("b", "bb", "bbb"); // size 5
-    set("c", "cc", "ccc"); // size 5; will evict 'A'
-    set("a", "a", "aaaa"); // size 5; will evict 'B'
-    cache.flush();
-    assertThat(snapshot.edit()).isNull();
-  }
-
-  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
-  @Test public void aggressiveClearingHandlesWrite() throws Exception {
-    fileSystem.deleteContents(tempDir.getRoot());
-    set("a", "a", "a");
-    assertValue("a", "a", "a");
-  }
-
-  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
-  @Test public void aggressiveClearingHandlesEdit() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Editor a = cache.get("a").edit();
-    fileSystem.deleteContents(tempDir.getRoot());
-    setString(a, 1, "a2");
-    a.commit();
-  }
-
-  @Test public void removeHandlesMissingFile() throws Exception {
-    set("a", "a", "a");
-    getCleanFile("a", 0).delete();
-    cache.remove("a");
-  }
-
-  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
-  @Test public void aggressiveClearingHandlesPartialEdit() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-    DiskLruCache.Editor a = cache.get("a").edit();
-    setString(a, 0, "a1");
-    fileSystem.deleteContents(tempDir.getRoot());
-    setString(a, 1, "a2");
-    a.commit();
-    assertThat(cache.get("a")).isNull();
-  }
-
-  /** @see <a href="https://github.com/JakeWharton/DiskLruCache/issues/2">Issue #2</a> */
-  @Test public void aggressiveClearingHandlesRead() throws Exception {
-    fileSystem.deleteContents(tempDir.getRoot());
-    assertThat(cache.get("a")).isNull();
-  }
-
-  /**
-   * We had a long-lived bug where {@link DiskLruCache#trimToSize} could infinite loop if entries
-   * being edited required deletion for the operation to complete.
-   */
-  @Test public void trimToSizeWithActiveEdit() throws Exception {
-    set("a", "a1234", "a1234");
-    DiskLruCache.Editor a = cache.edit("a");
-    setString(a, 0, "a123");
-
-    cache.setMaxSize(8); // Smaller than the sum of active edits!
-    cache.flush(); // Force trimToSize().
-    assertThat(cache.size()).isEqualTo(0);
-    assertThat(cache.get("a")).isNull();
-
-    // After the edit is completed, its entry is still gone.
-    setString(a, 1, "a1");
-    a.commit();
-    assertAbsent("a");
-    assertThat(cache.size()).isEqualTo(0);
-  }
-
-  @Test public void evictAll() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-    cache.evictAll();
-    assertThat(cache.size()).isEqualTo(0);
-    assertAbsent("a");
-    assertAbsent("b");
-  }
-
-  @Test public void evictAllWithPartialCreate() throws Exception {
-    DiskLruCache.Editor a = cache.edit("a");
-    setString(a, 0, "a1");
-    setString(a, 1, "a2");
-    cache.evictAll();
-    assertThat(cache.size()).isEqualTo(0);
-    a.commit();
-    assertAbsent("a");
-  }
-
-  @Test public void evictAllWithPartialEditDoesNotStoreAValue() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Editor a = cache.edit("a");
-    setString(a, 0, "a1");
-    setString(a, 1, "a2");
-    cache.evictAll();
-    assertThat(cache.size()).isEqualTo(0);
-    a.commit();
-    assertAbsent("a");
-  }
-
-  @Test public void evictAllDoesntInterruptPartialRead() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Snapshot a = cache.get("a");
-    assertSnapshotValue(a, 0, "a");
-    cache.evictAll();
-    assertThat(cache.size()).isEqualTo(0);
-    assertAbsent("a");
-    assertSnapshotValue(a, 1, "a");
-    a.close();
-  }
-
-  @Test public void editSnapshotAfterEvictAllReturnsNullDueToStaleValue() throws Exception {
-    set("a", "a", "a");
-    DiskLruCache.Snapshot a = cache.get("a");
-    cache.evictAll();
-    assertThat(cache.size()).isEqualTo(0);
-    assertAbsent("a");
-    assertThat(a.edit()).isNull();
-    a.close();
-  }
-
-  @Test public void iterator() throws Exception {
-    set("a", "a1", "a2");
-    set("b", "b1", "b2");
-    set("c", "c1", "c2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-
-    assertThat(iterator.hasNext()).isTrue();
-    DiskLruCache.Snapshot a = iterator.next();
-    assertThat(a.key()).isEqualTo("a");
-    assertSnapshotValue(a, 0, "a1");
-    assertSnapshotValue(a, 1, "a2");
-    a.close();
-
-    assertThat(iterator.hasNext()).isTrue();
-    DiskLruCache.Snapshot b = iterator.next();
-    assertThat(b.key()).isEqualTo("b");
-    assertSnapshotValue(b, 0, "b1");
-    assertSnapshotValue(b, 1, "b2");
-    b.close();
-
-    assertThat(iterator.hasNext()).isTrue();
-    DiskLruCache.Snapshot c = iterator.next();
-    assertThat(c.key()).isEqualTo("c");
-    assertSnapshotValue(c, 0, "c1");
-    assertSnapshotValue(c, 1, "c2");
-    c.close();
-
-    assertThat(iterator.hasNext()).isFalse();
-    try {
-      iterator.next();
-      fail();
-    } catch (NoSuchElementException expected) {
-    }
-  }
-
-  @Test public void iteratorElementsAddedDuringIterationAreOmitted() throws Exception {
-    set("a", "a1", "a2");
-    set("b", "b1", "b2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-
-    DiskLruCache.Snapshot a = iterator.next();
-    assertThat(a.key()).isEqualTo("a");
-    a.close();
-
-    set("c", "c1", "c2");
-
-    DiskLruCache.Snapshot b = iterator.next();
-    assertThat(b.key()).isEqualTo("b");
-    b.close();
-
-    assertThat(iterator.hasNext()).isFalse();
-  }
-
-  @Test public void iteratorElementsUpdatedDuringIterationAreUpdated() throws Exception {
-    set("a", "a1", "a2");
-    set("b", "b1", "b2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-
-    DiskLruCache.Snapshot a = iterator.next();
-    assertThat(a.key()).isEqualTo("a");
-    a.close();
-
-    set("b", "b3", "b4");
-
-    DiskLruCache.Snapshot b = iterator.next();
-    assertThat(b.key()).isEqualTo("b");
-    assertSnapshotValue(b, 0, "b3");
-    assertSnapshotValue(b, 1, "b4");
-    b.close();
-  }
-
-  @Test public void iteratorElementsRemovedDuringIterationAreOmitted() throws Exception {
-    set("a", "a1", "a2");
-    set("b", "b1", "b2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-
-    cache.remove("b");
-
-    DiskLruCache.Snapshot a = iterator.next();
-    assertThat(a.key()).isEqualTo("a");
-    a.close();
-
-    assertThat(iterator.hasNext()).isFalse();
-  }
-
-  @Test public void iteratorRemove() throws Exception {
-    set("a", "a1", "a2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-
-    DiskLruCache.Snapshot a = iterator.next();
-    a.close();
-    iterator.remove();
-
-    assertThat(cache.get("a")).isNull();
-  }
-
-  @Test public void iteratorRemoveBeforeNext() throws Exception {
-    set("a", "a1", "a2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-    try {
-      iterator.remove();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void iteratorRemoveOncePerCallToNext() throws Exception {
-    set("a", "a1", "a2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-
-    DiskLruCache.Snapshot a = iterator.next();
-    iterator.remove();
-    a.close();
-
-    try {
-      iterator.remove();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void cacheClosedTruncatesIterator() throws Exception {
-    set("a", "a1", "a2");
-    Iterator<DiskLruCache.Snapshot> iterator = cache.snapshots();
-    cache.close();
-    assertThat(iterator.hasNext()).isFalse();
-  }
-
-  @Test public void isClosed_uninitializedCache() throws Exception {
-    // Create an uninitialized cache.
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, taskRunner);
-    toClose.add(cache);
-
-    assertThat(cache.isClosed()).isFalse();
-    cache.close();
-    assertThat(cache.isClosed()).isTrue();
-  }
-
-  @Test public void journalWriteFailsDuringEdit() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-
-    // We can't begin the edit if writing 'DIRTY' fails.
-    fileSystem.setFaultyWrite(journalFile, true);
-    assertThat(cache.edit("c")).isNull();
-
-    // Once the journal has a failure, subsequent writes aren't permitted.
-    fileSystem.setFaultyWrite(journalFile, false);
-    assertThat(cache.edit("d")).isNull();
-
-    // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
-    cache.close();
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, taskRunner);
-    assertValue("a", "a", "a");
-    assertValue("b", "b", "b");
-    assertAbsent("c");
-    assertAbsent("d");
-  }
-
-  /**
-   * We had a bug where the cache was left in an inconsistent state after a journal write failed.
-   * https://github.com/square/okhttp/issues/1211
-   */
-  @Test public void journalWriteFailsDuringEditorCommit() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-
-    // Create an entry that fails to write to the journal during commit.
-    DiskLruCache.Editor editor = cache.edit("c");
-    setString(editor, 0, "c");
-    setString(editor, 1, "c");
-    fileSystem.setFaultyWrite(journalFile, true);
-    editor.commit();
-
-    // Once the journal has a failure, subsequent writes aren't permitted.
-    fileSystem.setFaultyWrite(journalFile, false);
-    assertThat(cache.edit("d")).isNull();
-
-    // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
-    cache.close();
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, taskRunner);
-    assertValue("a", "a", "a");
-    assertValue("b", "b", "b");
-    assertAbsent("c");
-    assertAbsent("d");
-  }
-
-  @Test public void journalWriteFailsDuringEditorAbort() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-
-    // Create an entry that fails to write to the journal during abort.
-    DiskLruCache.Editor editor = cache.edit("c");
-    setString(editor, 0, "c");
-    setString(editor, 1, "c");
-    fileSystem.setFaultyWrite(journalFile, true);
-    editor.abort();
-
-    // Once the journal has a failure, subsequent writes aren't permitted.
-    fileSystem.setFaultyWrite(journalFile, false);
-    assertThat(cache.edit("d")).isNull();
-
-    // Confirm that the fault didn't corrupt entries stored before the fault was introduced.
-    cache.close();
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, taskRunner);
-    assertValue("a", "a", "a");
-    assertValue("b", "b", "b");
-    assertAbsent("c");
-    assertAbsent("d");
-  }
-
-  @Test public void journalWriteFailsDuringRemove() throws Exception {
-    set("a", "a", "a");
-    set("b", "b", "b");
-
-    // Remove, but the journal write will fail.
-    fileSystem.setFaultyWrite(journalFile, true);
-    assertThat(cache.remove("a")).isTrue();
-
-    // Confirm that the entry was still removed.
-    fileSystem.setFaultyWrite(journalFile, false);
-    cache.close();
-    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, taskRunner);
-    assertAbsent("a");
-    assertValue("b", "b", "b");
-  }
-
-  @Test public void cleanupTrimFailurePreventsNewEditors() throws Exception {
-    cache.setMaxSize(8);
-    taskFaker.runNextTask();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    taskFaker.runNextTask();
-
-    // Confirm that edits are prevented after a cache trim failure.
-    assertThat(cache.edit("a")).isNull();
-    assertThat(cache.edit("b")).isNull();
-    assertThat(cache.edit("c")).isNull();
-
-    // Allow the test to clean up.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-  }
-
-  @Test public void cleanupTrimFailureRetriedOnEditors() throws Exception {
-    cache.setMaxSize(8);
-    taskFaker.runNextTask();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    taskFaker.runNextTask();
-
-    // An edit should now add a job to clean up if the most recent trim failed.
-    assertThat(cache.edit("b")).isNull();
-    taskFaker.runNextTask();
-
-    // Confirm a successful cache trim now allows edits.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-    assertThat(cache.edit("c")).isNull();
-    taskFaker.runNextTask();
-    set("c", "cc", "cc");
-    assertValue("c", "cc", "cc");
-  }
-
-  @Test public void cleanupTrimFailureWithInFlightEditor() throws Exception {
-    cache.setMaxSize(8);
-    taskFaker.runNextTask();
-    set("a", "aa", "aaa");
-    set("b", "bb", "bb");
-    DiskLruCache.Editor inFlightEditor = cache.edit("c");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    taskFaker.runNextTask();
-
-    // The in-flight editor can still write after a trim failure.
-    setString(inFlightEditor, 0, "cc");
-    setString(inFlightEditor, 1, "cc");
-    inFlightEditor.commit();
-
-    // Confirm the committed values are present after a successful cache trim.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-    taskFaker.runNextTask();
-    assertValue("c", "cc", "cc");
-  }
-
-  @Test public void cleanupTrimFailureAllowsSnapshotReads() throws Exception {
-    cache.setMaxSize(8);
-    taskFaker.runNextTask();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    taskFaker.runNextTask();
-
-    // Confirm we still allow snapshot reads after a trim failure.
-    assertValue("a", "aa", "aa");
-    assertValue("b", "bb", "bbb");
-
-    // Allow the test to clean up.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-  }
-
-  @Test public void cleanupTrimFailurePreventsSnapshotWrites() throws Exception {
-    cache.setMaxSize(8);
-    taskFaker.runNextTask();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    taskFaker.runNextTask();
-
-    // Confirm snapshot writes are prevented after a trim failure.
-    DiskLruCache.Snapshot snapshot1 = cache.get("a");
-    assertThat(snapshot1.edit()).isNull();
-    snapshot1.close();
-    DiskLruCache.Snapshot snapshot2 = cache.get("b");
-    assertThat(snapshot2.edit()).isNull();
-    snapshot2.close();
-
-    // Allow the test to clean up.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-  }
-
-  @Test public void evictAllAfterCleanupTrimFailure() throws Exception {
-    cache.setMaxSize(8);
-    taskFaker.runNextTask();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    taskFaker.runNextTask();
-
-    // Confirm we prevent edits after a trim failure.
-    assertThat(cache.edit("c")).isNull();
-
-    // A successful eviction should allow new writes.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-    cache.evictAll();
-    set("c", "cc", "cc");
-    assertValue("c", "cc", "cc");
-  }
-
-  @Test public void manualRemovalAfterCleanupTrimFailure() throws Exception {
-    cache.setMaxSize(8);
-    taskFaker.runNextTask();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    taskFaker.runNextTask();
-
-    // Confirm we prevent edits after a trim failure.
-    assertThat(cache.edit("c")).isNull();
-
-    // A successful removal which trims the cache should allow new writes.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-    cache.remove("a");
-    set("c", "cc", "cc");
-    assertValue("c", "cc", "cc");
-  }
-
-  @Test public void flushingAfterCleanupTrimFailure() throws Exception {
-    cache.setMaxSize(8);
-    taskFaker.runNextTask();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim job to fail.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), true);
-    taskFaker.runNextTask();
-
-    // Confirm we prevent edits after a trim failure.
-    assertThat(cache.edit("c")).isNull();
-
-    // A successful flush trims the cache and should allow new writes.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.0"), false);
-    cache.flush();
-    set("c", "cc", "cc");
-    assertValue("c", "cc", "cc");
-  }
-
-  @Test public void cleanupTrimFailureWithPartialSnapshot() throws Exception {
-    cache.setMaxSize(8);
-    taskFaker.runNextTask();
-    set("a", "aa", "aa");
-    set("b", "bb", "bbb");
-
-    // Cause the cache trim to fail on the second value leaving a partial snapshot.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.1"), true);
-    taskFaker.runNextTask();
-
-    // Confirm the partial snapshot is not returned.
-    assertThat(cache.get("a")).isNull();
-
-    // Confirm we prevent edits after a trim failure.
-    assertThat(cache.edit("a")).isNull();
-
-    // Confirm the partial snapshot is not returned after a successful trim.
-    fileSystem.setFaultyDelete(new File(cacheDir, "a.1"), false);
-    taskFaker.runNextTask();
-    assertThat(cache.get("a")).isNull();
-  }
-
-  @Test public void noSizeCorruptionAfterCreatorDetached() throws Exception {
-    // Create an editor for k1. Detach it by clearing the cache.
-    DiskLruCache.Editor editor = cache.edit("k1");
-    setString(editor, 0, "a");
-    setString(editor, 1, "a");
-    cache.evictAll();
-
-    // Create a new value in its place.
-    set("k1", "bb", "bb");
-    assertThat(cache.size()).isEqualTo(4);
-
-    // Committing the detached editor should not change the cache's size.
-    editor.commit();
-    assertThat(cache.size()).isEqualTo(4);
-    assertValue("k1", "bb", "bb");
-  }
-
-  @Test public void noSizeCorruptionAfterEditorDetached() throws Exception {
-    set("k1", "a", "a");
-
-    // Create an editor for k1. Detach it by clearing the cache.
-    DiskLruCache.Editor editor = cache.edit("k1");
-    setString(editor, 0, "bb");
-    setString(editor, 1, "bb");
-    cache.evictAll();
-
-    // Create a new value in its place.
-    set("k1", "ccc", "ccc");
-    assertThat(cache.size()).isEqualTo(6);
-
-    // Committing the detached editor should not change the cache's size.
-    editor.commit();
-    assertThat(cache.size()).isEqualTo(6);
-    assertValue("k1", "ccc", "ccc");
-  }
-
-  @Test public void noNewSourceAfterEditorDetached() throws Exception {
-    set("k1", "a", "a");
-
-    DiskLruCache.Editor editor = cache.edit("k1");
-    cache.evictAll();
-
-    assertThat(editor.newSource(0)).isNull();
-  }
-
-  @Test public void editsDiscardedAfterEditorDetached() throws Exception {
-    set("k1", "a", "a");
-
-    // Create an editor, then detach it.
-    DiskLruCache.Editor editor = cache.edit("k1");
-    BufferedSink sink = Okio.buffer(editor.newSink(0));
-    cache.evictAll();
-
-    // Create another value in its place.
-    set("k1", "ccc", "ccc");
-
-    // Complete the original edit. It goes into a black hole.
-    sink.writeUtf8("bb");
-    sink.close();
-
-    assertValue("k1", "ccc", "ccc");
-  }
-
-  @Test public void abortAfterDetach() throws Exception {
-    set("k1", "a", "a");
-
-    DiskLruCache.Editor editor = cache.edit("k1");
-    cache.evictAll();
-
-    editor.abort();
-    assertThat(cache.size()).isEqualTo(0);
-    assertAbsent("k1");
-  }
-
-  @Test public void dontRemoveUnfinishedEntryWhenCreatingSnapshot() throws Exception {
-    DiskLruCache.Editor creator = cache.edit("k1");
-    setString(creator, 0, "ABC");
-    setString(creator, 1, "DE");
-
-    assertThat(creator.newSource(0)).isNull();
-    assertThat(creator.newSource(1)).isNull();
-
-    Iterator<DiskLruCache.Snapshot> snapshotWhileEditing = cache.snapshots();
-    assertThat(snapshotWhileEditing.hasNext()).isFalse(); // entry still is being created/edited
-    creator.commit();
-
-    Iterator<DiskLruCache.Snapshot> snapshotAfterCommit = cache.snapshots();
-
-    assertThat(snapshotAfterCommit.hasNext())
-        .withFailMessage("Entry has been removed during creation.")
-        .isTrue();
-  }
-
-  private void assertJournalEquals(String... expectedBodyLines) throws Exception {
-    List<String> expectedLines = new ArrayList<>();
-    expectedLines.add(MAGIC);
-    expectedLines.add(VERSION_1);
-    expectedLines.add("100");
-    expectedLines.add("2");
-    expectedLines.add("");
-    expectedLines.addAll(asList(expectedBodyLines));
-    assertThat(readJournalLines()).isEqualTo(expectedLines);
-  }
-
-  private void createJournal(String... bodyLines) throws Exception {
-    createJournalWithHeader(MAGIC, VERSION_1, "100", "2", "", bodyLines);
-  }
-
-  private void createJournalWithHeader(String magic, String version, String appVersion,
-      String valueCount, String blank, String... bodyLines) throws Exception {
-    BufferedSink sink = Okio.buffer(fileSystem.sink(journalFile));
-    sink.writeUtf8(magic + "\n");
-    sink.writeUtf8(version + "\n");
-    sink.writeUtf8(appVersion + "\n");
-    sink.writeUtf8(valueCount + "\n");
-    sink.writeUtf8(blank + "\n");
-    for (String line : bodyLines) {
-      sink.writeUtf8(line);
-      sink.writeUtf8("\n");
-    }
-    sink.close();
-  }
-
-  private List<String> readJournalLines() throws Exception {
-    List<String> result = new ArrayList<>();
-    BufferedSource source = Okio.buffer(fileSystem.source(journalFile));
-    for (String line; (line = source.readUtf8Line()) != null; ) {
-      result.add(line);
-    }
-    source.close();
-    return result;
-  }
-
-  private File getCleanFile(String key, int index) {
-    return new File(cacheDir, key + "." + index);
-  }
-
-  private File getDirtyFile(String key, int index) {
-    return new File(cacheDir, key + "." + index + ".tmp");
-  }
-
-  private String readFile(File file) throws Exception {
-    BufferedSource source = Okio.buffer(fileSystem.source(file));
-    String result = source.readUtf8();
-    source.close();
-    return result;
-  }
-
-  public void writeFile(File file, String content) throws Exception {
-    BufferedSink sink = Okio.buffer(fileSystem.sink(file));
-    sink.writeUtf8(content);
-    sink.close();
-  }
-
-  private static void assertInoperable(DiskLruCache.Editor editor) throws Exception {
-    try {
-      setString(editor, 0, "A");
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      editor.newSource(0);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      editor.newSink(0);
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      editor.commit();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-    try {
-      editor.abort();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  private void generateSomeGarbageFiles() throws Exception {
-    File dir1 = new File(cacheDir, "dir1");
-    File dir2 = new File(dir1, "dir2");
-    writeFile(getCleanFile("g1", 0), "A");
-    writeFile(getCleanFile("g1", 1), "B");
-    writeFile(getCleanFile("g2", 0), "C");
-    writeFile(getCleanFile("g2", 1), "D");
-    writeFile(getCleanFile("g2", 1), "D");
-    writeFile(new File(cacheDir, "otherFile0"), "E");
-    writeFile(new File(dir2, "otherFile1"), "F");
-  }
-
-  private void assertGarbageFilesAllDeleted() {
-    assertThat(fileSystem.exists(getCleanFile("g1", 0))).isFalse();
-    assertThat(fileSystem.exists(getCleanFile("g1", 1))).isFalse();
-    assertThat(fileSystem.exists(getCleanFile("g2", 0))).isFalse();
-    assertThat(fileSystem.exists(getCleanFile("g2", 1))).isFalse();
-    assertThat(fileSystem.exists(new File(cacheDir, "otherFile0"))).isFalse();
-    assertThat(fileSystem.exists(new File(cacheDir, "dir1"))).isFalse();
-  }
-
-  private void set(String key, String value0, String value1) throws Exception {
-    DiskLruCache.Editor editor = cache.edit(key);
-    setString(editor, 0, value0);
-    setString(editor, 1, value1);
-    editor.commit();
-  }
-
-  public static void setString(DiskLruCache.Editor editor, int index, String value)
-      throws IOException {
-    BufferedSink writer = Okio.buffer(editor.newSink(index));
-    writer.writeUtf8(value);
-    writer.close();
-  }
-
-  private void assertAbsent(String key) throws Exception {
-    DiskLruCache.Snapshot snapshot = cache.get(key);
-    if (snapshot != null) {
-      snapshot.close();
-      fail();
-    }
-    assertThat(fileSystem.exists(getCleanFile(key, 0))).isFalse();
-    assertThat(fileSystem.exists(getCleanFile(key, 1))).isFalse();
-    assertThat(fileSystem.exists(getDirtyFile(key, 0))).isFalse();
-    assertThat(fileSystem.exists(getDirtyFile(key, 1))).isFalse();
-  }
-
-  private void assertValue(String key, String value0, String value1) throws Exception {
-    DiskLruCache.Snapshot snapshot = cache.get(key);
-    assertSnapshotValue(snapshot, 0, value0);
-    assertSnapshotValue(snapshot, 1, value1);
-    assertThat(fileSystem.exists(getCleanFile(key, 0))).isTrue();
-    assertThat(fileSystem.exists(getCleanFile(key, 1))).isTrue();
-    snapshot.close();
-  }
-
-  private void assertSnapshotValue(DiskLruCache.Snapshot snapshot, int index, String value)
-      throws IOException {
-    assertThat(sourceAsString(snapshot.getSource(index))).isEqualTo(value);
-    assertThat(snapshot.getLength(index)).isEqualTo(value.length());
-  }
-
-  private String sourceAsString(Source source) throws IOException {
-    return source != null ? Okio.buffer(source).readUtf8() : null;
-  }
-
-  private void copyFile(File from, File to) throws IOException {
-    Source source = fileSystem.source(from);
-    BufferedSink sink = Okio.buffer(fileSystem.sink(to));
-    sink.writeAll(source);
-    source.close();
-    sink.close();
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java b/okhttp/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java
deleted file mode 100644
index cca27974fc..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/cache2/FileOperatorTest.java
+++ /dev/null
@@ -1,200 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache2;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.RandomAccessFile;
-import java.util.Random;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class FileOperatorTest {
-  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
-
-  private File file;
-  private RandomAccessFile randomAccessFile;
-
-  @Before public void setUp() throws Exception {
-    file = tempDir.newFile();
-    randomAccessFile = new RandomAccessFile(file, "rw");
-  }
-
-  @After public void tearDown() throws Exception {
-    randomAccessFile.close();
-  }
-
-  @Test public void read() throws Exception {
-    write(ByteString.encodeUtf8("Hello, World"));
-
-    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
-
-    Buffer buffer = new Buffer();
-    operator.read(0, buffer, 5);
-    assertThat(buffer.readUtf8()).isEqualTo("Hello");
-
-    operator.read(4, buffer, 5);
-    assertThat(buffer.readUtf8()).isEqualTo("o, Wo");
-  }
-
-  @Test public void write() throws Exception {
-    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
-
-    Buffer buffer1 = new Buffer().writeUtf8("Hello, World");
-    operator.write(0, buffer1, 5);
-    assertThat(buffer1.readUtf8()).isEqualTo(", World");
-
-    Buffer buffer2 = new Buffer().writeUtf8("icopter!");
-    operator.write(3, buffer2, 7);
-    assertThat(buffer2.readUtf8()).isEqualTo("!");
-
-    assertThat(snapshot()).isEqualTo(ByteString.encodeUtf8("Helicopter"));
-  }
-
-  @Test public void readAndWrite() throws Exception {
-    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
-
-    write(ByteString.encodeUtf8("woman god creates dinosaurs destroys. "));
-    Buffer buffer = new Buffer();
-    operator.read(6, buffer, 21);
-    operator.read(36, buffer, 1);
-    operator.read(5, buffer, 5);
-    operator.read(28, buffer, 8);
-    operator.read(17, buffer, 10);
-    operator.read(36, buffer, 2);
-    operator.read(2, buffer, 4);
-    operator.write(0, buffer, buffer.size());
-    operator.read(0, buffer, 12);
-    operator.read(47, buffer, 3);
-    operator.read(45, buffer, 2);
-    operator.read(47, buffer, 3);
-    operator.read(26, buffer, 10);
-    operator.read(23, buffer, 3);
-    operator.write(47, buffer, buffer.size());
-    operator.read(62, buffer, 6);
-    operator.read(4, buffer, 19);
-    operator.write(80, buffer, buffer.size());
-
-    assertThat(ByteString.encodeUtf8(""
-        + "god creates dinosaurs. "
-        + "god destroys dinosaurs. "
-        + "god creates man. "
-        + "man destroys god. "
-        + "man creates dinosaurs. ")).isEqualTo(snapshot());
-  }
-
-  @Test public void multipleOperatorsShareOneFile() throws Exception {
-    FileOperator operatorA = new FileOperator(randomAccessFile.getChannel());
-    FileOperator operatorB = new FileOperator(randomAccessFile.getChannel());
-
-    Buffer bufferA = new Buffer();
-    Buffer bufferB = new Buffer();
-
-    bufferA.writeUtf8("Dodgson!\n");
-    operatorA.write(0, bufferA, 9);
-
-    bufferB.writeUtf8("You shouldn't use my name.\n");
-    operatorB.write(9, bufferB, 27);
-
-    bufferA.writeUtf8("Dodgson, we've got Dodgson here!\n");
-    operatorA.write(36, bufferA, 33);
-
-    operatorB.read(0, bufferB, 9);
-    assertThat(bufferB.readUtf8()).isEqualTo("Dodgson!\n");
-
-    operatorA.read(9, bufferA, 27);
-    assertThat(bufferA.readUtf8()).isEqualTo("You shouldn't use my name.\n");
-
-    operatorB.read(36, bufferB, 33);
-    assertThat(bufferB.readUtf8()).isEqualTo("Dodgson, we've got Dodgson here!\n");
-  }
-
-  @Test public void largeRead() throws Exception {
-    ByteString data = randomByteString(1000000);
-    write(data);
-
-    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
-
-    Buffer buffer = new Buffer();
-    operator.read(0, buffer, data.size());
-    assertThat(buffer.readByteString()).isEqualTo(data);
-  }
-
-  @Test public void largeWrite() throws Exception {
-    ByteString data = randomByteString(1000000);
-
-    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
-
-    Buffer buffer = new Buffer().write(data);
-    operator.write(0, buffer, data.size());
-
-    assertThat(snapshot()).isEqualTo(data);
-  }
-
-  @Test public void readBounds() throws Exception {
-    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
-    Buffer buffer = new Buffer();
-    try {
-      operator.read(0, buffer, -1L);
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-  }
-
-  @Test public void writeBounds() throws Exception {
-    FileOperator operator = new FileOperator(randomAccessFile.getChannel());
-    Buffer buffer = new Buffer().writeUtf8("abc");
-    try {
-      operator.write(0, buffer, -1L);
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-    try {
-      operator.write(0, buffer, 4L);
-      fail();
-    } catch (IndexOutOfBoundsException expected) {
-    }
-  }
-
-  private ByteString randomByteString(int byteCount) {
-    byte[] bytes = new byte[byteCount];
-    new Random(0).nextBytes(bytes);
-    return ByteString.of(bytes);
-  }
-
-  private ByteString snapshot() throws IOException {
-    randomAccessFile.getChannel().force(false);
-    BufferedSource source = Okio.buffer(Okio.source(file));
-    return source.readByteString();
-  }
-
-  private void write(ByteString data) throws IOException {
-    BufferedSink sink = Okio.buffer(Okio.sink(file));
-    sink.write(data);
-    sink.close();
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/cache2/RelayTest.java b/okhttp/src/test/java/okhttp3/internal/cache2/RelayTest.java
deleted file mode 100644
index c853cddeac..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/cache2/RelayTest.java
+++ /dev/null
@@ -1,250 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.cache2;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.concurrent.Callable;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.Future;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Okio;
-import okio.Pipe;
-import okio.Source;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TemporaryFolder;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class RelayTest {
-  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
-
-  private ExecutorService executor = Executors.newCachedThreadPool();
-  private ByteString metadata = ByteString.encodeUtf8("great metadata!");
-  private File file;
-
-  @Before public void setUp() throws Exception {
-    file = tempDir.newFile();
-  }
-
-  @After public void tearDown() throws Exception {
-    executor.shutdown();
-  }
-
-  @Test public void singleSource() throws Exception {
-    Buffer upstream = new Buffer();
-    upstream.writeUtf8("abcdefghijklm");
-
-    Relay relay = Relay.Companion.edit(file, upstream, metadata, 1024);
-    Source source = relay.newSource();
-    Buffer sourceBuffer = new Buffer();
-
-    assertThat(source.read(sourceBuffer, 5)).isEqualTo(5);
-    assertThat(sourceBuffer.readUtf8()).isEqualTo("abcde");
-
-    assertThat(source.read(sourceBuffer, 1024)).isEqualTo(8);
-    assertThat(sourceBuffer.readUtf8()).isEqualTo("fghijklm");
-
-    assertThat(source.read(sourceBuffer, 1024)).isEqualTo(-1);
-    assertThat(sourceBuffer.size()).isEqualTo(0);
-
-    source.close();
-    assertThat(relay.isClosed()).isTrue();
-    assertFile(Relay.PREFIX_CLEAN, 13L, metadata.size(), "abcdefghijklm", metadata);
-  }
-
-  @Test public void multipleSources() throws Exception {
-    Buffer upstream = new Buffer();
-    upstream.writeUtf8("abcdefghijklm");
-
-    Relay relay = Relay.Companion.edit(file, upstream, metadata, 1024);
-    BufferedSource source1 = Okio.buffer(relay.newSource());
-    BufferedSource source2 = Okio.buffer(relay.newSource());
-
-    assertThat(source1.readUtf8()).isEqualTo("abcdefghijklm");
-    assertThat(source2.readUtf8()).isEqualTo("abcdefghijklm");
-    source1.close();
-    source2.close();
-    assertThat(relay.isClosed()).isTrue();
-
-    assertFile(Relay.PREFIX_CLEAN, 13L, metadata.size(), "abcdefghijklm", metadata);
-  }
-
-  @Test public void readFromBuffer() throws Exception {
-    Buffer upstream = new Buffer();
-    upstream.writeUtf8("abcdefghij");
-
-    Relay relay = Relay.Companion.edit(file, upstream, metadata, 5);
-    BufferedSource source1 = Okio.buffer(relay.newSource());
-    BufferedSource source2 = Okio.buffer(relay.newSource());
-
-    assertThat(source1.readUtf8(5)).isEqualTo("abcde");
-    assertThat(source2.readUtf8(5)).isEqualTo("abcde");
-    assertThat(source2.readUtf8(5)).isEqualTo("fghij");
-    assertThat(source1.readUtf8(5)).isEqualTo("fghij");
-    assertThat(source1.exhausted()).isTrue();
-    assertThat(source2.exhausted()).isTrue();
-    source1.close();
-    source2.close();
-    assertThat(relay.isClosed()).isTrue();
-
-    assertFile(Relay.PREFIX_CLEAN, 10L, metadata.size(), "abcdefghij", metadata);
-  }
-
-  @Test public void readFromFile() throws Exception {
-    Buffer upstream = new Buffer();
-    upstream.writeUtf8("abcdefghijklmnopqrst");
-
-    Relay relay = Relay.Companion.edit(file, upstream, metadata, 5);
-    BufferedSource source1 = Okio.buffer(relay.newSource());
-    BufferedSource source2 = Okio.buffer(relay.newSource());
-
-    assertThat(source1.readUtf8(10)).isEqualTo("abcdefghij");
-    assertThat(source2.readUtf8(10)).isEqualTo("abcdefghij");
-    assertThat(source2.readUtf8(10)).isEqualTo("klmnopqrst");
-    assertThat(source1.readUtf8(10)).isEqualTo("klmnopqrst");
-    assertThat(source1.exhausted()).isTrue();
-    assertThat(source2.exhausted()).isTrue();
-    source1.close();
-    source2.close();
-    assertThat(relay.isClosed()).isTrue();
-
-    assertFile(Relay.PREFIX_CLEAN, 20L, metadata.size(), "abcdefghijklmnopqrst", metadata);
-  }
-
-  @Test public void readAfterEdit() throws Exception {
-    Buffer upstream = new Buffer();
-    upstream.writeUtf8("abcdefghij");
-
-    Relay relay1 = Relay.Companion.edit(file, upstream, metadata, 5);
-    BufferedSource source1 = Okio.buffer(relay1.newSource());
-    assertThat(source1.readUtf8(10)).isEqualTo("abcdefghij");
-    assertThat(source1.exhausted()).isTrue();
-    source1.close();
-    assertThat(relay1.isClosed()).isTrue();
-
-    // Since relay1 is closed, new sources cannot be created.
-    assertThat(relay1.newSource()).isNull();
-
-    Relay relay2 = Relay.Companion.read(file);
-    assertThat(relay2.metadata()).isEqualTo(metadata);
-    BufferedSource source2 = Okio.buffer(relay2.newSource());
-    assertThat(source2.readUtf8(10)).isEqualTo("abcdefghij");
-    assertThat(source2.exhausted()).isTrue();
-    source2.close();
-    assertThat(relay2.isClosed()).isTrue();
-
-    // Since relay2 is closed, new sources cannot be created.
-    assertThat(relay2.newSource()).isNull();
-
-    assertFile(Relay.PREFIX_CLEAN, 10L, metadata.size(), "abcdefghij", metadata);
-  }
-
-  @Test public void closeBeforeExhaustLeavesDirtyFile() throws Exception {
-    Buffer upstream = new Buffer();
-    upstream.writeUtf8("abcdefghij");
-
-    Relay relay1 = Relay.Companion.edit(file, upstream, metadata, 5);
-    BufferedSource source1 = Okio.buffer(relay1.newSource());
-    assertThat(source1.readUtf8(10)).isEqualTo("abcdefghij");
-    source1.close(); // Not exhausted!
-    assertThat(relay1.isClosed()).isTrue();
-
-    try {
-      Relay.Companion.read(file);
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("unreadable cache file");
-    }
-
-    assertFile(Relay.PREFIX_DIRTY, -1L, -1, null, null);
-  }
-
-  @Test public void redundantCallsToCloseAreIgnored() throws Exception {
-    Buffer upstream = new Buffer();
-    upstream.writeUtf8("abcde");
-
-    Relay relay = Relay.Companion.edit(file, upstream, metadata, 1024);
-    Source source1 = relay.newSource();
-    Source source2 = relay.newSource();
-
-    source1.close();
-    source1.close(); // Unnecessary. Shouldn't decrement the reference count.
-    assertThat(relay.isClosed()).isFalse();
-
-    source2.close();
-    assertThat(relay.isClosed()).isTrue();
-    assertFile(Relay.PREFIX_DIRTY, -1L, -1, null, null);
-  }
-
-  @Test public void racingReaders() throws Exception {
-    Pipe pipe = new Pipe(1024);
-    BufferedSink sink = Okio.buffer(pipe.sink());
-
-    Relay relay = Relay.Companion.edit(file, pipe.source(), metadata, 5);
-
-    Future<ByteString> future1 = executor.submit(sourceReader(relay.newSource()));
-    Future<ByteString> future2 = executor.submit(sourceReader(relay.newSource()));
-
-    Thread.sleep(500);
-    sink.writeUtf8("abcdefghij");
-
-    Thread.sleep(500);
-    sink.writeUtf8("klmnopqrst");
-    sink.close();
-
-    assertThat(future1.get()).isEqualTo(ByteString.encodeUtf8("abcdefghijklmnopqrst"));
-    assertThat(future2.get()).isEqualTo(ByteString.encodeUtf8("abcdefghijklmnopqrst"));
-
-    assertThat(relay.isClosed()).isTrue();
-
-    assertFile(Relay.PREFIX_CLEAN, 20L, metadata.size(), "abcdefghijklmnopqrst", metadata);
-  }
-
-  /** Returns a callable that reads all of source, closes it, and returns the bytes. */
-  private Callable<ByteString> sourceReader(final Source source) {
-    return () -> {
-      Buffer buffer = new Buffer();
-      while (source.read(buffer, 16384) != -1) {
-      }
-      source.close();
-      return buffer.readByteString();
-    };
-  }
-
-  private void assertFile(ByteString prefix, long upstreamSize, int metadataSize, String upstream,
-      ByteString metadata) throws IOException {
-    BufferedSource source = Okio.buffer(Okio.source(file));
-    assertThat(source.readByteString(prefix.size())).isEqualTo(prefix);
-    assertThat(source.readLong()).isEqualTo(upstreamSize);
-    assertThat(source.readLong()).isEqualTo(metadataSize);
-    if (upstream != null) {
-      assertThat(source.readUtf8(upstreamSize)).isEqualTo(upstream);
-    }
-    if (metadata != null) {
-      assertThat(source.readByteString(metadataSize)).isEqualTo(metadata);
-    }
-    source.close();
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/concurrent/TaskFaker.kt b/okhttp/src/test/java/okhttp3/internal/concurrent/TaskFaker.kt
deleted file mode 100644
index 2e3a960ba5..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/concurrent/TaskFaker.kt
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.concurrent
-
-import okhttp3.internal.notify
-import okhttp3.internal.wait
-import org.assertj.core.api.Assertions.assertThat
-import java.util.concurrent.Executors
-
-/**
- * Runs a [TaskRunner] in a controlled environment so that everything is sequential and
- * deterministic. All tasks are executed on-demand on the test thread by calls to [runTasks] and
- * [advanceUntil].
- */
-class TaskFaker {
-  /** Runnables scheduled for execution. These will execute tasks and perform scheduling. */
-  private val futureRunnables = mutableListOf<Runnable>()
-
-  /** Runnables currently executing. */
-  private val currentRunnables = mutableListOf<Runnable>()
-
-  /**
-   * Executor service for the runnables above. This executor service should never have more than two
-   * active threads: one for a currently-executing task and one for a currently-sleeping task.
-   */
-  private val executorService = Executors.newCachedThreadPool()
-
-  /** True if this task faker has ever had multiple tasks scheduled to run concurrently. */
-  var isParallel = false
-
-  /** Guarded by [taskRunner]. */
-  var nanoTime = 0L
-    private set
-
-  /** The thread currently waiting for time to advance. */
-  private var waitingThread: Thread? = null
-
-  /** Guarded by taskRunner. Time at which we should yield execution to a waiting runnable. */
-  private var waitingUntilTime = Long.MAX_VALUE
-
-  /** Total number of runnables executed. */
-  private var executedRunnableCount = 0
-
-  /** Stall once we've executed this many runnables. */
-  private var executedTaskLimit = Int.MAX_VALUE
-
-  /** A task runner that posts tasks to this fake. Tasks won't be executed until requested. */
-  val taskRunner: TaskRunner = TaskRunner(object : TaskRunner.Backend {
-    override fun beforeTask(taskRunner: TaskRunner) {
-      check(Thread.holdsLock(taskRunner))
-      while (executedRunnableCount >= executedTaskLimit) {
-        coordinatorWait(taskRunner, Long.MAX_VALUE)
-      }
-    }
-
-    override fun execute(runnable: Runnable) {
-      futureRunnables.add(runnable)
-    }
-
-    override fun nanoTime() = nanoTime
-
-    override fun coordinatorNotify(taskRunner: TaskRunner) {
-      check(Thread.holdsLock(taskRunner))
-      waitingUntilTime = nanoTime
-    }
-
-    override fun coordinatorWait(taskRunner: TaskRunner, nanos: Long) {
-      check(Thread.holdsLock(taskRunner))
-      check(waitingUntilTime == Long.MAX_VALUE)
-      check(waitingThread == null)
-
-      waitingThread = Thread.currentThread()
-      waitingUntilTime = if (nanos < Long.MAX_VALUE) nanoTime + nanos else Long.MAX_VALUE
-      try {
-        if (nanoTime < waitingUntilTime) {
-          // Stall because there's no work to do.
-          taskRunner.notify()
-          taskRunner.wait()
-        }
-      } finally {
-        waitingThread = null
-        waitingUntilTime = Long.MAX_VALUE
-      }
-    }
-  })
-
-  /** Runs all tasks that are ready without advancing the simulated clock. */
-  fun runTasks() {
-    advanceUntil(nanoTime)
-  }
-
-  /** Advance the simulated clock and run anything ready at the new time. */
-  fun advanceUntil(newTime: Long) {
-    check(!Thread.holdsLock(taskRunner))
-
-    synchronized(taskRunner) {
-      nanoTime = newTime
-
-      while (true) {
-        runRunnables(taskRunner)
-
-        if (waitingUntilTime <= nanoTime) {
-          // Let the coordinator do its business at the new time.
-          taskRunner.notify()
-          taskRunner.wait()
-        } else {
-          return
-        }
-      }
-    }
-  }
-
-  /** Returns true if anything was executed. */
-  private fun runRunnables(taskRunner: TaskRunner) {
-    check(Thread.holdsLock(taskRunner))
-
-    while (futureRunnables.isNotEmpty()) {
-      val runnable = futureRunnables.removeAt(0)
-      currentRunnables.add(runnable)
-      if (currentRunnables.size > 1) isParallel = true
-      executorService.execute(Runnable {
-        try {
-          runnable.run()
-        } finally {
-          currentRunnables.remove(runnable)
-          synchronized(taskRunner) {
-            taskRunner.notify()
-          }
-        }
-      })
-      taskRunner.wait() // Wait for the coordinator to stall.
-    }
-  }
-
-  fun assertNoMoreTasks() {
-    assertThat(futureRunnables).isEmpty()
-    assertThat(waitingUntilTime)
-        .withFailMessage("tasks are scheduled to run at $waitingUntilTime")
-        .isEqualTo(Long.MAX_VALUE)
-  }
-
-  fun interruptCoordinatorThread() {
-    check(!Thread.holdsLock(taskRunner))
-
-    synchronized(taskRunner) {
-      check(waitingThread != null) { "no thread currently waiting" }
-      waitingThread!!.interrupt()
-      taskRunner.wait() // Wait for the coordinator to stall.
-    }
-  }
-
-  /** Advances and runs up to one task. */
-  fun runNextTask() {
-    executedTaskLimit = executedRunnableCount + 1
-    try {
-      advanceUntil(nanoTime)
-    } finally {
-      executedTaskLimit = Int.MAX_VALUE
-    }
-  }
-
-  /** Returns true if no tasks have been scheduled. This runs the coordinator for confirmation. */
-  fun isIdle() = taskRunner.activeQueues().isEmpty()
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerRealBackendTest.kt b/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerRealBackendTest.kt
deleted file mode 100644
index a762daf73d..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerRealBackendTest.kt
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.concurrent
-
-import okhttp3.internal.threadFactory
-import org.assertj.core.api.Assertions.assertThat
-import org.assertj.core.data.Offset
-import org.junit.Test
-import java.util.concurrent.LinkedBlockingDeque
-import java.util.concurrent.TimeUnit
-
-/**
- * Integration test to confirm that [TaskRunner] works with a real backend. Business logic is all
- * exercised by [TaskRunnerTest].
- *
- * This test is doing real sleeping with tolerances of 250 ms. Hopefully that's enough for even the
- * busiest of CI servers.
- */
-class TaskRunnerRealBackendTest {
-  private val backend = TaskRunner.RealBackend(threadFactory("TaskRunnerRealBackendTest", true))
-  private val taskRunner = TaskRunner(backend)
-  private val queue = taskRunner.newQueue()
-  private val log = LinkedBlockingDeque<String>()
-
-  @Test fun test() {
-    val t1 = System.nanoTime() / 1e6
-
-    val delays = mutableListOf(TimeUnit.MILLISECONDS.toNanos(1000), -1L)
-    queue.schedule("task", TimeUnit.MILLISECONDS.toNanos(750)) {
-      log.put("runOnce delays.size=${delays.size}")
-      return@schedule delays.removeAt(0)
-    }
-
-    assertThat(log.take()).isEqualTo("runOnce delays.size=2")
-    val t2 = System.nanoTime() / 1e6 - t1
-    assertThat(t2).isCloseTo(750.0, Offset.offset(250.0))
-
-    assertThat(log.take()).isEqualTo("runOnce delays.size=1")
-    val t3 = System.nanoTime() / 1e6 - t1
-    assertThat(t3).isCloseTo(1750.0, Offset.offset(250.0))
-
-    backend.shutdown()
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerTest.kt b/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerTest.kt
deleted file mode 100644
index f6066b4cac..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/concurrent/TaskRunnerTest.kt
+++ /dev/null
@@ -1,465 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.concurrent
-
-import org.assertj.core.api.Assertions.assertThat
-import org.junit.Assert.fail
-import org.junit.Test
-import java.util.concurrent.RejectedExecutionException
-
-class TaskRunnerTest {
-  private val taskFaker = TaskFaker()
-  private val taskRunner = taskFaker.taskRunner
-  private val log = mutableListOf<String>()
-  private val redQueue = taskRunner.newQueue()
-  private val blueQueue = taskRunner.newQueue()
-  private val greenQueue = taskRunner.newQueue()
-
-  @Test fun executeDelayed() {
-    redQueue.execute("task", 100L) {
-      log += "run@${taskFaker.nanoTime}"
-    }
-
-    taskFaker.advanceUntil(0L)
-    assertThat(log).containsExactly()
-
-    taskFaker.advanceUntil(99L)
-    assertThat(log).containsExactly()
-
-    taskFaker.advanceUntil(100L)
-    assertThat(log).containsExactly("run@100")
-
-    taskFaker.assertNoMoreTasks()
-  }
-
-  @Test fun executeRepeated() {
-    val delays = mutableListOf(50L, 150L, -1L)
-    redQueue.schedule("task", 100L) {
-      log += "run@${taskFaker.nanoTime}"
-      return@schedule delays.removeAt(0)
-    }
-
-    taskFaker.advanceUntil(0L)
-    assertThat(log).containsExactly()
-
-    taskFaker.advanceUntil(100L)
-    assertThat(log).containsExactly("run@100")
-
-    taskFaker.advanceUntil(150L)
-    assertThat(log).containsExactly("run@100", "run@150")
-
-    taskFaker.advanceUntil(299L)
-    assertThat(log).containsExactly("run@100", "run@150")
-
-    taskFaker.advanceUntil(300L)
-    assertThat(log).containsExactly("run@100", "run@150", "run@300")
-
-    taskFaker.assertNoMoreTasks()
-  }
-
-  /** Repeat with a delay of 200 but schedule with a delay of 50. The schedule wins. */
-  @Test fun executeScheduledEarlierReplacesRepeatedLater() {
-    val task = object : Task("task") {
-      val schedules = mutableListOf(50L)
-      val delays = mutableListOf(200L, -1L)
-      override fun runOnce(): Long {
-        log += "run@${taskFaker.nanoTime}"
-        if (schedules.isNotEmpty()) {
-          redQueue.schedule(this, schedules.removeAt(0))
-        }
-        return delays.removeAt(0)
-      }
-    }
-    redQueue.schedule(task, 100L)
-
-    taskFaker.advanceUntil(0L)
-    assertThat(log).isEmpty()
-
-    taskFaker.advanceUntil(100L)
-    assertThat(log).containsExactly("run@100")
-
-    taskFaker.advanceUntil(150L)
-    assertThat(log).containsExactly("run@100", "run@150")
-
-    taskFaker.assertNoMoreTasks()
-  }
-
-  /** Schedule with a delay of 200 but repeat with a delay of 50. The repeat wins. */
-  @Test fun executeRepeatedEarlierReplacesScheduledLater() {
-    val task = object : Task("task") {
-      val schedules = mutableListOf(200L)
-      val delays = mutableListOf(50L, -1L)
-      override fun runOnce(): Long {
-        log += "run@${taskFaker.nanoTime}"
-        if (schedules.isNotEmpty()) {
-          redQueue.schedule(this, schedules.removeAt(0))
-        }
-        return delays.removeAt(0)
-      }
-    }
-    redQueue.schedule(task, 100L)
-
-    taskFaker.advanceUntil(0L)
-    assertThat(log).isEmpty()
-
-    taskFaker.advanceUntil(100L)
-    assertThat(log).containsExactly("run@100")
-
-    taskFaker.advanceUntil(150L)
-    assertThat(log).containsExactly("run@100", "run@150")
-
-    taskFaker.assertNoMoreTasks()
-  }
-
-  @Test fun cancelReturnsTruePreventsNextExecution() {
-    redQueue.execute("task", 100L) {
-      log += "run@${taskFaker.nanoTime}"
-    }
-
-    taskFaker.advanceUntil(0L)
-    assertThat(log).isEmpty()
-
-    redQueue.cancelAll()
-
-    taskFaker.advanceUntil(99L)
-    assertThat(log).isEmpty()
-
-    taskFaker.assertNoMoreTasks()
-  }
-
-  @Test fun cancelReturnsFalseDoesNotCancel() {
-    redQueue.schedule(object : Task("task", cancelable = false) {
-      override fun runOnce(): Long {
-        log += "run@${taskFaker.nanoTime}"
-        return -1L
-      }
-    }, 100L)
-
-    taskFaker.advanceUntil(0L)
-    assertThat(log).isEmpty()
-
-    redQueue.cancelAll()
-
-    taskFaker.advanceUntil(99L)
-    assertThat(log).isEmpty()
-
-    taskFaker.advanceUntil(100L)
-    assertThat(log).containsExactly("run@100")
-
-    taskFaker.assertNoMoreTasks()
-  }
-
-  @Test fun cancelWhileExecutingPreventsRepeat() {
-    redQueue.schedule("task", 100L) {
-      log += "run@${taskFaker.nanoTime}"
-      redQueue.cancelAll()
-      return@schedule 100L
-    }
-
-    taskFaker.advanceUntil(0L)
-    assertThat(log).isEmpty()
-
-    taskFaker.advanceUntil(100L)
-    assertThat(log).containsExactly("run@100")
-
-    taskFaker.assertNoMoreTasks()
-  }
-
-  @Test fun cancelWhileExecutingDoesNothingIfTaskDoesNotRepeat() {
-    redQueue.execute("task", 100L) {
-      log += "run@${taskFaker.nanoTime}"
-      redQueue.cancelAll()
-    }
-
-    taskFaker.advanceUntil(0L)
-    assertThat(log).isEmpty()
-
-    taskFaker.advanceUntil(100L)
-    assertThat(log).containsExactly("run@100")
-
-    taskFaker.assertNoMoreTasks()
-  }
-
-  @Test fun cancelWhileExecutingDoesNotStopUncancelableTask() {
-    redQueue.schedule(object : Task("task", cancelable = false) {
-      val delays = mutableListOf(50L, -1L)
-      override fun runOnce(): Long {
-        log += "run@${taskFaker.nanoTime}"
-        redQueue.cancelAll()
-        return delays.removeAt(0)
-      }
-    }, 100L)
-
-    taskFaker.advanceUntil(0L)
-    assertThat(log).isEmpty()
-
-    taskFaker.advanceUntil(100L)
-    assertThat(log).containsExactly("run@100")
-
-    taskFaker.advanceUntil(150L)
-    assertThat(log).containsExactly("run@100", "run@150")
-
-    taskFaker.assertNoMoreTasks()
-  }
-
-  @Test fun interruptingCoordinatorAttemptsToCancelsAndSucceeds() {
-    redQueue.execute("task", 100L) {
-      log += "run@${taskFaker.nanoTime}"
-    }
-
-    taskFaker.advanceUntil(0L)
-    assertThat(log).isEmpty()
-
-    taskFaker.interruptCoordinatorThread()
-
-    taskFaker.advanceUntil(0L)
-    assertThat(log).isEmpty()
-
-    taskFaker.assertNoMoreTasks()
-  }
-
-  @Test fun interruptingCoordinatorAttemptsToCancelsAndFails() {
-    redQueue.schedule(object : Task("task", cancelable = false) {
-      override fun runOnce(): Long {
-        log += "run@${taskFaker.nanoTime}"
-        return -1L
-      }
-    }, 100L)
-
-    taskFaker.advanceUntil(0L)
-    assertThat(log).isEmpty()
-
-    taskFaker.interruptCoordinatorThread()
-
-    taskFaker.advanceUntil(0L)
-    assertThat(log).isEmpty()
-
-    taskFaker.advanceUntil(100L)
-    assertThat(log).containsExactly("run@100")
-
-    taskFaker.assertNoMoreTasks()
-  }
-
-  /** Inspect how many runnables have been enqueued. If none then we're truly sequential. */
-  @Test fun singleQueueIsSerial() {
-    redQueue.execute("task one", 100L) {
-      log += "one:run@${taskFaker.nanoTime} parallel=${taskFaker.isParallel}"
-    }
-
-    redQueue.execute("task two", 100L) {
-      log += "two:run@${taskFaker.nanoTime} parallel=${taskFaker.isParallel}"
-    }
-
-    redQueue.execute("task three", 100L) {
-      log += "three:run@${taskFaker.nanoTime} parallel=${taskFaker.isParallel}"
-    }
-
-    taskFaker.advanceUntil(0L)
-    assertThat(log).isEmpty()
-
-    taskFaker.advanceUntil(100L)
-    assertThat(log).containsExactly(
-        "one:run@100 parallel=false",
-        "two:run@100 parallel=false",
-        "three:run@100 parallel=false"
-    )
-
-    taskFaker.assertNoMoreTasks()
-  }
-
-  /** Inspect how many runnables have been enqueued. If non-zero then we're truly parallel. */
-  @Test fun differentQueuesAreParallel() {
-    redQueue.execute("task one", 100L) {
-      log += "one:run@${taskFaker.nanoTime} parallel=${taskFaker.isParallel}"
-    }
-
-    blueQueue.execute("task two", 100L) {
-      log += "two:run@${taskFaker.nanoTime} parallel=${taskFaker.isParallel}"
-    }
-
-    greenQueue.execute("task three", 100L) {
-      log += "three:run@${taskFaker.nanoTime} parallel=${taskFaker.isParallel}"
-    }
-
-    taskFaker.advanceUntil(0L)
-    assertThat(log).isEmpty()
-
-    taskFaker.advanceUntil(100L)
-    assertThat(log).containsExactly(
-        "one:run@100 parallel=true",
-        "two:run@100 parallel=true",
-        "three:run@100 parallel=true"
-    )
-
-    taskFaker.assertNoMoreTasks()
-  }
-
-  /** Test the introspection method [TaskQueue.scheduledTasks]. */
-  @Test fun scheduledTasks() {
-    redQueue.execute("task one", 100L) {
-      // Do nothing.
-    }
-
-    redQueue.execute("task two", 200L) {
-      // Do nothing.
-    }
-
-    assertThat(redQueue.scheduledTasks.toString()).isEqualTo("[task one, task two]")
-  }
-
-  /**
-   * We don't track the active task in scheduled tasks. This behavior might be a mistake, but it's
-   * cumbersome to implement properly because the active task might be a cancel.
-   */
-  @Test fun scheduledTasksDoesNotIncludeRunningTask() {
-    val task = object : Task("task one") {
-      val schedules = mutableListOf(200L)
-      override fun runOnce(): Long {
-        if (schedules.isNotEmpty()) {
-          redQueue.schedule(this, schedules.removeAt(0)) // Add it at the end also.
-        }
-        log += "scheduledTasks=${redQueue.scheduledTasks}"
-        return -1L
-      }
-    }
-    redQueue.schedule(task, 100L)
-
-    redQueue.execute("task two", 200L) {
-      log += "scheduledTasks=${redQueue.scheduledTasks}"
-    }
-
-    taskFaker.advanceUntil(100L)
-    assertThat(log).containsExactly(
-        "scheduledTasks=[task two, task one]"
-    )
-
-    taskFaker.advanceUntil(200L)
-    assertThat(log).containsExactly(
-        "scheduledTasks=[task two, task one]",
-        "scheduledTasks=[task one]"
-    )
-
-    taskFaker.advanceUntil(300L)
-    assertThat(log).containsExactly(
-        "scheduledTasks=[task two, task one]",
-        "scheduledTasks=[task one]",
-        "scheduledTasks=[]"
-    )
-
-    taskFaker.assertNoMoreTasks()
-  }
-
-  /**
-   * The runner doesn't hold references to its queues! Otherwise we'd need a mechanism to clean them
-   * up when they're no longer needed and that's annoying. Instead the task runner only tracks which
-   * queues have work scheduled.
-   */
-  @Test fun activeQueuesContainsOnlyQueuesWithScheduledTasks() {
-    redQueue.execute("task one", 100L) {
-      // Do nothing.
-    }
-
-    blueQueue.execute("task two", 200L) {
-      // Do nothing.
-    }
-
-    taskFaker.advanceUntil(0L)
-    assertThat(taskRunner.activeQueues()).containsExactly(redQueue, blueQueue)
-
-    taskFaker.advanceUntil(100L)
-    assertThat(taskRunner.activeQueues()).containsExactly(blueQueue)
-
-    taskFaker.advanceUntil(200L)
-    assertThat(taskRunner.activeQueues()).isEmpty()
-
-    taskFaker.assertNoMoreTasks()
-  }
-
-  @Test fun taskNameIsUsedForThreadNameWhenRunning() {
-    redQueue.execute("lucky task") {
-      log += "run threadName:${Thread.currentThread().name}"
-    }
-
-    taskFaker.advanceUntil(0L)
-    assertThat(log).containsExactly("run threadName:lucky task")
-
-    taskFaker.assertNoMoreTasks()
-  }
-
-  @Test fun shutdownSuccessfullyCancelsScheduledTasks() {
-    redQueue.execute("task", 100L) {
-      log += "run@${taskFaker.nanoTime}"
-    }
-
-    taskFaker.advanceUntil(0L)
-    assertThat(log).isEmpty()
-
-    redQueue.shutdown()
-
-    taskFaker.advanceUntil(99L)
-    assertThat(log).isEmpty()
-
-    taskFaker.assertNoMoreTasks()
-  }
-
-  @Test fun shutdownFailsToCancelsScheduledTasks() {
-    redQueue.schedule(object : Task("task", false) {
-      override fun runOnce(): Long {
-        log += "run@${taskFaker.nanoTime}"
-        return 50L
-      }
-    }, 100L)
-
-    taskFaker.advanceUntil(0L)
-    assertThat(log).isEmpty()
-
-    redQueue.shutdown()
-
-    taskFaker.advanceUntil(99L)
-    assertThat(log).isEmpty()
-
-    taskFaker.advanceUntil(100L)
-    assertThat(log).containsExactly("run@100")
-
-    taskFaker.assertNoMoreTasks()
-  }
-
-  @Test fun scheduleDiscardsTaskWhenShutdown() {
-    redQueue.shutdown()
-
-    redQueue.execute("task", 100L) {
-      // Do nothing.
-    }
-
-    taskFaker.assertNoMoreTasks()
-  }
-
-  @Test fun scheduleThrowsWhenShutdown() {
-    redQueue.shutdown()
-
-    try {
-      redQueue.schedule(object : Task("task", cancelable = false) {
-        override fun runOnce(): Long {
-          return -1L
-        }
-      }, 100L)
-      fail()
-    } catch (_: RejectedExecutionException) {
-    }
-
-    taskFaker.assertNoMoreTasks()
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java b/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java
deleted file mode 100644
index 06e92889c5..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/connection/ConnectionPoolTest.java
+++ /dev/null
@@ -1,247 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.Socket;
-import java.util.Collections;
-import java.util.concurrent.TimeUnit;
-import javax.net.SocketFactory;
-import okhttp3.Address;
-import okhttp3.Call;
-import okhttp3.ConnectionPool;
-import okhttp3.Dns;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Route;
-import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.concurrent.TaskFaker;
-import okhttp3.internal.concurrent.TaskRunner;
-import org.junit.Test;
-
-import static okhttp3.TestUtil.awaitGarbageCollection;
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class ConnectionPoolTest {
-  /** The fake task runner prevents the cleanup runnable from being started. */
-  private final TaskRunner taskRunner = new TaskFaker().getTaskRunner();
-  private final Address addressA = newAddress("a");
-  private final Route routeA1 = newRoute(addressA);
-  private final Address addressB = newAddress("b");
-  private final Route routeB1 = newRoute(addressB);
-  private final Address addressC = newAddress("c");
-  private final Route routeC1 = newRoute(addressC);
-
-  @Test public void connectionsEvictedWhenIdleLongEnough() throws Exception {
-    RealConnectionPool pool = new RealConnectionPool(
-        taskRunner, Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
-
-    RealConnection c1 = newConnection(pool, routeA1, 50L);
-
-    // Running at time 50, the pool returns that nothing can be evicted until time 150.
-    assertThat(pool.cleanup(50L)).isEqualTo(100L);
-    assertThat(pool.connectionCount()).isEqualTo(1);
-    assertThat(c1.socket().isClosed()).isFalse();
-
-    // Running at time 60, the pool returns that nothing can be evicted until time 150.
-    assertThat(pool.cleanup(60L)).isEqualTo(90L);
-    assertThat(pool.connectionCount()).isEqualTo(1);
-    assertThat(c1.socket().isClosed()).isFalse();
-
-    // Running at time 149, the pool returns that nothing can be evicted until time 150.
-    assertThat(pool.cleanup(149L)).isEqualTo(1L);
-    assertThat(pool.connectionCount()).isEqualTo(1);
-    assertThat(c1.socket().isClosed()).isFalse();
-
-    // Running at time 150, the pool evicts.
-    assertThat(pool.cleanup(150L)).isEqualTo(0);
-    assertThat(pool.connectionCount()).isEqualTo(0);
-    assertThat(c1.socket().isClosed()).isTrue();
-
-    // Running again, the pool reports that no further runs are necessary.
-    assertThat(pool.cleanup(150L)).isEqualTo(-1);
-    assertThat(pool.connectionCount()).isEqualTo(0);
-    assertThat(c1.socket().isClosed()).isTrue();
-  }
-
-  @Test public void inUseConnectionsNotEvicted() throws Exception {
-    RealConnectionPool pool = new RealConnectionPool(
-        taskRunner, Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
-    ConnectionPool poolApi = new ConnectionPool(pool);
-
-    RealConnection c1 = newConnection(pool, routeA1, 50L);
-    synchronized (pool) {
-      OkHttpClient client = new OkHttpClient.Builder()
-          .connectionPool(poolApi)
-          .build();
-      Call call = client.newCall(newRequest(addressA));
-      Transmitter transmitter = new Transmitter(client, call);
-      transmitter.prepareToConnect(call.request());
-      transmitter.acquireConnectionNoEvents(c1);
-    }
-
-    // Running at time 50, the pool returns that nothing can be evicted until time 150.
-    assertThat(pool.cleanup(50L)).isEqualTo(100L);
-    assertThat(pool.connectionCount()).isEqualTo(1);
-    assertThat(c1.socket().isClosed()).isFalse();
-
-    // Running at time 60, the pool returns that nothing can be evicted until time 160.
-    assertThat(pool.cleanup(60L)).isEqualTo(100L);
-    assertThat(pool.connectionCount()).isEqualTo(1);
-    assertThat(c1.socket().isClosed()).isFalse();
-
-    // Running at time 160, the pool returns that nothing can be evicted until time 260.
-    assertThat(pool.cleanup(160L)).isEqualTo(100L);
-    assertThat(pool.connectionCount()).isEqualTo(1);
-    assertThat(c1.socket().isClosed()).isFalse();
-  }
-
-  @Test public void cleanupPrioritizesEarliestEviction() throws Exception {
-    RealConnectionPool pool = new RealConnectionPool(
-        taskRunner, Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
-
-    RealConnection c1 = newConnection(pool, routeA1, 75L);
-    RealConnection c2 = newConnection(pool, routeB1, 50L);
-
-    // Running at time 75, the pool returns that nothing can be evicted until time 150.
-    assertThat(pool.cleanup(75L)).isEqualTo(75L);
-    assertThat(pool.connectionCount()).isEqualTo(2);
-
-    // Running at time 149, the pool returns that nothing can be evicted until time 150.
-    assertThat(pool.cleanup(149L)).isEqualTo(1L);
-    assertThat(pool.connectionCount()).isEqualTo(2);
-
-    // Running at time 150, the pool evicts c2.
-    assertThat(pool.cleanup(150L)).isEqualTo(0L);
-    assertThat(pool.connectionCount()).isEqualTo(1);
-    assertThat(c1.socket().isClosed()).isFalse();
-    assertThat(c2.socket().isClosed()).isTrue();
-
-    // Running at time 150, the pool returns that nothing can be evicted until time 175.
-    assertThat(pool.cleanup(150L)).isEqualTo(25L);
-    assertThat(pool.connectionCount()).isEqualTo(1);
-
-    // Running at time 175, the pool evicts c1.
-    assertThat(pool.cleanup(175L)).isEqualTo(0L);
-    assertThat(pool.connectionCount()).isEqualTo(0);
-    assertThat(c1.socket().isClosed()).isTrue();
-    assertThat(c2.socket().isClosed()).isTrue();
-  }
-
-  @Test public void oldestConnectionsEvictedIfIdleLimitExceeded() throws Exception {
-    RealConnectionPool pool = new RealConnectionPool(
-        taskRunner, 2, 100L, TimeUnit.NANOSECONDS);
-
-    RealConnection c1 = newConnection(pool, routeA1, 50L);
-    RealConnection c2 = newConnection(pool, routeB1, 75L);
-
-    // With 2 connections, there's no need to evict until the connections time out.
-    assertThat(pool.cleanup(100L)).isEqualTo(50L);
-    assertThat(pool.connectionCount()).isEqualTo(2);
-    assertThat(c1.socket().isClosed()).isFalse();
-    assertThat(c2.socket().isClosed()).isFalse();
-
-    // Add a third connection
-    RealConnection c3 = newConnection(pool, routeC1, 75L);
-
-    // The third connection bounces the first.
-    assertThat(pool.cleanup(100L)).isEqualTo(0L);
-    assertThat(pool.connectionCount()).isEqualTo(2);
-    assertThat(c1.socket().isClosed()).isTrue();
-    assertThat(c2.socket().isClosed()).isFalse();
-    assertThat(c3.socket().isClosed()).isFalse();
-  }
-
-  @Test public void leakedAllocation() throws Exception {
-    RealConnectionPool pool = new RealConnectionPool(
-        taskRunner, Integer.MAX_VALUE, 100L, TimeUnit.NANOSECONDS);
-    ConnectionPool poolApi = new ConnectionPool(pool);
-
-    RealConnection c1 = newConnection(pool, routeA1, 0L);
-    allocateAndLeakAllocation(poolApi, c1);
-
-    awaitGarbageCollection();
-    assertThat(pool.cleanup(100L)).isEqualTo(0L);
-    assertThat(c1.getTransmitters()).isEmpty();
-
-    // Can't allocate once a leak has been detected.
-    assertThat(c1.getNoNewExchanges()).isTrue();
-  }
-
-  @Test public void interruptStopsThread() throws Exception {
-    TaskRunner realTaskRunner = TaskRunner.INSTANCE;
-    RealConnectionPool pool = new RealConnectionPool(
-        realTaskRunner, 2, 100L, TimeUnit.NANOSECONDS);
-    RealConnection c1 = newConnection(pool, routeA1, Long.MAX_VALUE);
-
-    assertThat(realTaskRunner.activeQueues()).isNotEmpty();
-
-    Thread.sleep(100);
-
-    Thread[] threads = new Thread[Thread.activeCount() * 2];
-    Thread.enumerate(threads);
-    for (Thread t: threads) {
-      if (t != null && t.getName().equals("OkHttp TaskRunner")) {
-        t.interrupt();
-      }
-    }
-
-    Thread.sleep(100);
-
-    assertThat(realTaskRunner.activeQueues()).isEmpty();
-  }
-
-  /** Use a helper method so there's no hidden reference remaining on the stack. */
-  private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection connection) {
-    synchronized (RealConnectionPool.Companion.get(pool)) {
-      OkHttpClient client = new OkHttpClient.Builder()
-          .connectionPool(pool)
-          .build();
-      Call call = client.newCall(newRequest(connection.route().address()));
-      Transmitter transmitter = new Transmitter(client, call);
-      transmitter.prepareToConnect(call.request());
-      transmitter.acquireConnectionNoEvents(connection);
-    }
-  }
-
-  private RealConnection newConnection(RealConnectionPool pool, Route route, long idleAtNanos) {
-    RealConnection result = RealConnection.Companion.newTestConnection(
-        pool, route, new Socket(), idleAtNanos);
-    synchronized (pool) {
-      pool.put(result);
-    }
-    return result;
-  }
-
-  private Address newAddress(String name) {
-    return new Address(name, 1, Dns.SYSTEM, SocketFactory.getDefault(), null, null, null,
-        new RecordingOkAuthenticator("password", null), null, Collections.emptyList(),
-        Collections.emptyList(), ProxySelector.getDefault());
-  }
-
-  private Route newRoute(Address address) {
-    return new Route(address, Proxy.NO_PROXY,
-        InetSocketAddress.createUnresolved(address.url().host(), address.url().port()));
-  }
-
-  private Request newRequest(Address address) {
-    return new Request.Builder()
-        .url(address.url())
-        .build();
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java b/okhttp/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
deleted file mode 100644
index 6fa893e07d..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.io.IOException;
-import java.security.cert.CertificateException;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLSocket;
-import okhttp3.ConnectionSpec;
-import okhttp3.TlsVersion;
-import okhttp3.tls.HandshakeCertificates;
-import org.junit.Test;
-
-import static java.util.Arrays.asList;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class ConnectionSpecSelectorTest {
-  public static final SSLHandshakeException RETRYABLE_EXCEPTION = new SSLHandshakeException(
-      "Simulated handshake exception");
-
-  private HandshakeCertificates handshakeCertificates = localhost();
-
-  @Test
-  public void nonRetryableIOException() throws Exception {
-    ConnectionSpecSelector connectionSpecSelector =
-        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
-    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
-    connectionSpecSelector.configureSecureSocket(socket);
-
-    boolean retry = connectionSpecSelector.connectionFailed(
-        new IOException("Non-handshake exception"));
-    assertThat(retry).isFalse();
-    socket.close();
-  }
-
-  @Test
-  public void nonRetryableSSLHandshakeException() throws Exception {
-    ConnectionSpecSelector connectionSpecSelector =
-        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
-    SSLSocket socket = createSocketWithEnabledProtocols(TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
-    connectionSpecSelector.configureSecureSocket(socket);
-
-    SSLHandshakeException trustIssueException =
-        new SSLHandshakeException("Certificate handshake exception");
-    trustIssueException.initCause(new CertificateException());
-    boolean retry = connectionSpecSelector.connectionFailed(trustIssueException);
-    assertThat(retry).isFalse();
-    socket.close();
-  }
-
-  @Test
-  public void retryableSSLHandshakeException() throws Exception {
-    ConnectionSpecSelector connectionSpecSelector =
-        createConnectionSpecSelector(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS);
-    SSLSocket socket = createSocketWithEnabledProtocols(
-        TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
-    connectionSpecSelector.configureSecureSocket(socket);
-
-    boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
-    assertThat(retry).isTrue();
-    socket.close();
-  }
-
-  @Test
-  public void someFallbacksSupported() throws Exception {
-    ConnectionSpec sslV3 = new ConnectionSpec.Builder(ConnectionSpec.MODERN_TLS)
-        .tlsVersions(TlsVersion.SSL_3_0)
-        .build();
-
-    ConnectionSpecSelector connectionSpecSelector = createConnectionSpecSelector(
-        ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, sslV3);
-
-    TlsVersion[] enabledSocketTlsVersions = {
-        TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0
-    };
-    SSLSocket socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
-
-    // MODERN_TLS is used here.
-    connectionSpecSelector.configureSecureSocket(socket);
-    assertEnabledProtocols(socket, TlsVersion.TLS_1_2);
-
-    boolean retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
-    assertThat(retry).isTrue();
-    socket.close();
-
-    // COMPATIBLE_TLS is used here.
-    socket = createSocketWithEnabledProtocols(enabledSocketTlsVersions);
-    connectionSpecSelector.configureSecureSocket(socket);
-    assertEnabledProtocols(socket, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0);
-
-    retry = connectionSpecSelector.connectionFailed(RETRYABLE_EXCEPTION);
-    assertThat(retry).isFalse();
-    socket.close();
-
-    // sslV3 is not used because SSLv3 is not enabled on the socket.
-  }
-
-  private static ConnectionSpecSelector createConnectionSpecSelector(
-      ConnectionSpec... connectionSpecs) {
-    return new ConnectionSpecSelector(asList(connectionSpecs));
-  }
-
-  private SSLSocket createSocketWithEnabledProtocols(TlsVersion... tlsVersions) throws IOException {
-    SSLSocket socket = (SSLSocket) handshakeCertificates.sslSocketFactory().createSocket();
-    socket.setEnabledProtocols(javaNames(tlsVersions));
-    return socket;
-  }
-
-  private static void assertEnabledProtocols(SSLSocket socket, TlsVersion... required) {
-    assertThat(socket.getEnabledProtocols()).containsExactlyInAnyOrder(javaNames(required));
-  }
-
-  private static String[] javaNames(TlsVersion... tlsVersions) {
-    String[] protocols = new String[tlsVersions.length];
-    for (int i = 0; i < tlsVersions.length; i++) {
-      protocols[i] = tlsVersions[i].javaName();
-    }
-    return protocols;
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java b/okhttp/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
deleted file mode 100644
index bce264a618..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2015 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.io.IOException;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class RouteExceptionTest {
-
-  @Test public void getConnectionIOException_single() {
-    IOException firstException = new IOException();
-    RouteException re = new RouteException(firstException);
-    assertThat(re.getFirstConnectException()).isSameAs(firstException);
-    assertThat(re.getLastConnectException()).isSameAs(firstException);
-  }
-
-  @Test public void getConnectionIOException_multiple() {
-    IOException firstException = new IOException();
-    IOException secondException = new IOException();
-    IOException thirdException = new IOException();
-    RouteException re = new RouteException(firstException);
-    re.addConnectException(secondException);
-    re.addConnectException(thirdException);
-
-    IOException connectionIOException = re.getFirstConnectException();
-    assertThat(connectionIOException).isSameAs(firstException);
-    Throwable[] suppressedExceptions = connectionIOException.getSuppressed();
-    assertThat(suppressedExceptions.length).isEqualTo(2);
-    assertThat(suppressedExceptions[0]).isSameAs(secondException);
-    assertThat(suppressedExceptions[1]).isSameAs(thirdException);
-
-    assertThat(re.getLastConnectException()).isSameAs(thirdException);
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java b/okhttp/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
deleted file mode 100644
index a901295c4b..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
+++ /dev/null
@@ -1,467 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.connection;
-
-import java.io.IOException;
-import java.net.InetAddress;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.SocketAddress;
-import java.net.URI;
-import java.net.UnknownHostException;
-import java.util.Arrays;
-import java.util.List;
-import java.util.NoSuchElementException;
-import javax.net.SocketFactory;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLSocketFactory;
-import okhttp3.Address;
-import okhttp3.Authenticator;
-import okhttp3.Call;
-import okhttp3.ConnectionSpec;
-import okhttp3.EventListener;
-import okhttp3.FakeDns;
-import okhttp3.OkHttpClientTestRule;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Route;
-import okhttp3.internal.http.RecordingProxySelector;
-import okhttp3.tls.HandshakeCertificates;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static java.net.Proxy.NO_PROXY;
-import static okhttp3.internal.Util.immutableListOf;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class RouteSelectorTest {
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  public final List<ConnectionSpec> connectionSpecs = immutableListOf(
-      ConnectionSpec.MODERN_TLS,
-      ConnectionSpec.COMPATIBLE_TLS,
-      ConnectionSpec.CLEARTEXT);
-
-  private static final int proxyAPort = 1001;
-  private static final String proxyAHost = "proxya";
-  private static final Proxy proxyA =
-      new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(proxyAHost, proxyAPort));
-  private static final int proxyBPort = 1002;
-  private static final String proxyBHost = "proxyb";
-  private static final Proxy proxyB =
-      new Proxy(Proxy.Type.HTTP, InetSocketAddress.createUnresolved(proxyBHost, proxyBPort));
-  private String uriHost = "hosta";
-  private int uriPort = 1003;
-
-  private Call call;
-  private SocketFactory socketFactory;
-  private final HandshakeCertificates handshakeCertificates = localhost();
-  private final SSLSocketFactory sslSocketFactory = handshakeCertificates.sslSocketFactory();
-  private HostnameVerifier hostnameVerifier;
-
-  private final Authenticator authenticator = Authenticator.NONE;
-  private final List<Protocol> protocols = Arrays.asList(Protocol.HTTP_1_1);
-  private final FakeDns dns = new FakeDns();
-  private final RecordingProxySelector proxySelector = new RecordingProxySelector();
-  private RouteDatabase routeDatabase = new RouteDatabase();
-
-  @Before public void setUp() throws Exception {
-    call = clientTestRule.newClient().newCall(new Request.Builder()
-        .url("https://" + uriHost + ":" + uriPort + "/")
-        .build());
-    socketFactory = SocketFactory.getDefault();
-    hostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();
-  }
-
-  @Test public void singleRoute() throws Exception {
-    Address address = httpAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
-        EventListener.NONE);
-
-    assertThat(routeSelector.hasNext()).isTrue();
-    dns.set(uriHost, dns.allocate(1));
-    RouteSelector.Selection selection = routeSelector.next();
-    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
-    dns.assertRequests(uriHost);
-    assertThat(selection.hasNext()).isFalse();
-    try {
-      selection.next();
-      fail();
-    } catch (NoSuchElementException expected) {
-    }
-
-    assertThat(routeSelector.hasNext()).isFalse();
-    try {
-      routeSelector.next();
-      fail();
-    } catch (NoSuchElementException expected) {
-    }
-  }
-
-  @Test public void singleRouteReturnsFailedRoute() throws Exception {
-    Address address = httpAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
-        EventListener.NONE);
-
-    assertThat(routeSelector.hasNext()).isTrue();
-    dns.set(uriHost, dns.allocate(1));
-    RouteSelector.Selection selection = routeSelector.next();
-    Route route = selection.next();
-    routeDatabase.failed(route);
-    routeSelector = new RouteSelector(address, routeDatabase, call, EventListener.NONE);
-    selection = routeSelector.next();
-    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
-    assertThat(selection.hasNext()).isFalse();
-
-    try {
-      selection.next();
-      fail();
-    } catch (NoSuchElementException expected) {
-    }
-
-    assertThat(routeSelector.hasNext()).isFalse();
-    try {
-      routeSelector.next();
-      fail();
-    } catch (NoSuchElementException expected) {
-    }
-  }
-
-  @Test public void explicitProxyTriesThatProxysAddressesOnly() throws Exception {
-    Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
-        authenticator, proxyA, protocols, connectionSpecs, proxySelector);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
-        EventListener.NONE);
-
-    assertThat(routeSelector.hasNext()).isTrue();
-    dns.set(proxyAHost, dns.allocate(2));
-    RouteSelector.Selection selection = routeSelector.next();
-    assertRoute(selection.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
-    assertRoute(selection.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
-
-    assertThat(selection.hasNext()).isFalse();
-    assertThat(routeSelector.hasNext()).isFalse();
-    dns.assertRequests(proxyAHost);
-    proxySelector.assertRequests(); // No proxy selector requests!
-  }
-
-  @Test public void explicitDirectProxy() throws Exception {
-    Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
-        authenticator, NO_PROXY, protocols, connectionSpecs, proxySelector);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
-        EventListener.NONE);
-
-    assertThat(routeSelector.hasNext()).isTrue();
-    dns.set(uriHost, dns.allocate(2));
-    RouteSelector.Selection selection = routeSelector.next();
-    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
-    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
-
-    assertThat(selection.hasNext()).isFalse();
-    assertThat(routeSelector.hasNext()).isFalse();
-    dns.assertRequests(uriHost);
-    proxySelector.assertRequests(); // No proxy selector requests!
-  }
-
-  @Test public void proxySelectorReturnsNull() throws Exception {
-    ProxySelector nullProxySelector = new ProxySelector() {
-      @Override public List<Proxy> select(URI uri) {
-        assertThat(uri.getHost()).isEqualTo(uriHost);
-        return null;
-      }
-
-      @Override public void connectFailed(
-          URI uri, SocketAddress socketAddress, IOException e) {
-        throw new AssertionError();
-      }
-    };
-
-    Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
-        authenticator, null, protocols, connectionSpecs, nullProxySelector);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
-        EventListener.NONE);
-    assertThat(routeSelector.hasNext()).isTrue();
-    dns.set(uriHost, dns.allocate(1));
-    RouteSelector.Selection selection = routeSelector.next();
-    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
-    dns.assertRequests(uriHost);
-
-    assertThat(selection.hasNext()).isFalse();
-    assertThat(routeSelector.hasNext()).isFalse();
-  }
-
-  @Test public void proxySelectorReturnsNoProxies() throws Exception {
-    Address address = httpAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
-        EventListener.NONE);
-
-    assertThat(routeSelector.hasNext()).isTrue();
-    dns.set(uriHost, dns.allocate(2));
-    RouteSelector.Selection selection = routeSelector.next();
-    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
-    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
-
-    assertThat(selection.hasNext()).isFalse();
-    assertThat(routeSelector.hasNext()).isFalse();
-    dns.assertRequests(uriHost);
-    proxySelector.assertRequests(address.url().uri());
-  }
-
-  @Test public void proxySelectorReturnsMultipleProxies() throws Exception {
-    Address address = httpAddress();
-
-    proxySelector.proxies.add(proxyA);
-    proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
-        EventListener.NONE);
-    proxySelector.assertRequests(address.url().uri());
-
-    // First try the IP addresses of the first proxy, in sequence.
-    assertThat(routeSelector.hasNext()).isTrue();
-    dns.set(proxyAHost, dns.allocate(2));
-    RouteSelector.Selection selection1 = routeSelector.next();
-    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
-    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
-    dns.assertRequests(proxyAHost);
-    assertThat(selection1.hasNext()).isFalse();
-
-    // Next try the IP address of the second proxy.
-    assertThat(routeSelector.hasNext()).isTrue();
-    dns.set(proxyBHost, dns.allocate(1));
-    RouteSelector.Selection selection2 = routeSelector.next();
-    assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
-    dns.assertRequests(proxyBHost);
-    assertThat(selection2.hasNext()).isFalse();
-
-    // No more proxies to try.
-    assertThat(routeSelector.hasNext()).isFalse();
-  }
-
-  @Test public void proxySelectorDirectConnectionsAreSkipped() throws Exception {
-    Address address = httpAddress();
-
-    proxySelector.proxies.add(NO_PROXY);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
-        EventListener.NONE);
-    proxySelector.assertRequests(address.url().uri());
-
-    // Only the origin server will be attempted.
-    assertThat(routeSelector.hasNext()).isTrue();
-    dns.set(uriHost, dns.allocate(1));
-    RouteSelector.Selection selection = routeSelector.next();
-    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
-    dns.assertRequests(uriHost);
-
-    assertThat(selection.hasNext()).isFalse();
-    assertThat(routeSelector.hasNext()).isFalse();
-  }
-
-  @Test public void proxyDnsFailureContinuesToNextProxy() throws Exception {
-    Address address = httpAddress();
-
-    proxySelector.proxies.add(proxyA);
-    proxySelector.proxies.add(proxyB);
-    proxySelector.proxies.add(proxyA);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
-        EventListener.NONE);
-    proxySelector.assertRequests(address.url().uri());
-
-    assertThat(routeSelector.hasNext()).isTrue();
-    dns.set(proxyAHost, dns.allocate(1));
-    RouteSelector.Selection selection1 = routeSelector.next();
-    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
-    dns.assertRequests(proxyAHost);
-    assertThat(selection1.hasNext()).isFalse();
-
-    assertThat(routeSelector.hasNext()).isTrue();
-    dns.clear(proxyBHost);
-    try {
-      routeSelector.next();
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-    dns.assertRequests(proxyBHost);
-
-    assertThat(routeSelector.hasNext()).isTrue();
-    dns.set(proxyAHost, dns.allocate(1));
-    RouteSelector.Selection selection2 = routeSelector.next();
-    assertRoute(selection2.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
-    dns.assertRequests(proxyAHost);
-
-    assertThat(selection2.hasNext()).isFalse();
-    assertThat(routeSelector.hasNext()).isFalse();
-  }
-
-  @Test public void multipleProxiesMultipleInetAddressesMultipleConfigurations() throws Exception {
-    Address address = httpsAddress();
-    proxySelector.proxies.add(proxyA);
-    proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
-        EventListener.NONE);
-
-    // Proxy A
-    dns.set(proxyAHost, dns.allocate(2));
-    RouteSelector.Selection selection1 = routeSelector.next();
-    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
-    dns.assertRequests(proxyAHost);
-    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
-    assertThat(selection1.hasNext()).isFalse();
-
-    // Proxy B
-    dns.set(proxyBHost, dns.allocate(2));
-    RouteSelector.Selection selection2 = routeSelector.next();
-    assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
-    dns.assertRequests(proxyBHost);
-    assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 1), proxyBPort);
-    assertThat(selection2.hasNext()).isFalse();
-
-    // No more proxies to attempt.
-    assertThat(routeSelector.hasNext()).isFalse();
-  }
-
-  @Test public void failedRouteWithSingleProxy() throws Exception {
-    Address address = httpsAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
-        EventListener.NONE);
-
-    final int numberOfAddresses = 2;
-    dns.set(uriHost, dns.allocate(numberOfAddresses));
-
-    // Extract the regular sequence of routes from selector.
-    RouteSelector.Selection selection1 = routeSelector.next();
-    List<Route> regularRoutes = selection1.getRoutes();
-
-    // Check that we do indeed have more than one route.
-    assertThat(regularRoutes.size()).isEqualTo(numberOfAddresses);
-    // Add first regular route as failed.
-    routeDatabase.failed(regularRoutes.get(0));
-    // Reset selector
-    routeSelector = new RouteSelector(address, routeDatabase, call, EventListener.NONE);
-
-    // The first selection prioritizes the non-failed routes.
-    RouteSelector.Selection selection2 = routeSelector.next();
-    assertThat(selection2.next()).isEqualTo(regularRoutes.get(1));
-    assertThat(selection2.hasNext()).isFalse();
-
-    // The second selection will contain all failed routes.
-    RouteSelector.Selection selection3 = routeSelector.next();
-    assertThat(selection3.next()).isEqualTo(regularRoutes.get(0));
-    assertThat(selection3.hasNext()).isFalse();
-
-    assertThat(routeSelector.hasNext()).isFalse();
-  }
-
-  @Test public void failedRouteWithMultipleProxies() throws IOException {
-    Address address = httpsAddress();
-    proxySelector.proxies.add(proxyA);
-    proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
-        EventListener.NONE);
-
-    dns.set(proxyAHost, dns.allocate(1));
-    dns.set(proxyBHost, dns.allocate(1));
-
-    // Mark the ProxyA route as failed.
-    RouteSelector.Selection selection = routeSelector.next();
-    dns.assertRequests(proxyAHost);
-    Route route = selection.next();
-    assertRoute(route, address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
-    routeDatabase.failed(route);
-
-    routeSelector = new RouteSelector(address, routeDatabase, call, EventListener.NONE);
-
-    // Confirm we enumerate both proxies, giving preference to the route from ProxyB.
-    RouteSelector.Selection selection2 = routeSelector.next();
-    dns.assertRequests(proxyAHost, proxyBHost);
-    assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
-    assertThat(selection2.hasNext()).isFalse();
-
-    // Confirm the last selection contains the postponed route from ProxyA.
-    RouteSelector.Selection selection3 = routeSelector.next();
-    dns.assertRequests();
-    assertRoute(selection3.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
-    assertThat(selection3.hasNext()).isFalse();
-
-    assertThat(routeSelector.hasNext()).isFalse();
-  }
-
-  @Test public void queryForAllSelectedRoutes() throws IOException {
-    Address address = httpAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, call,
-        EventListener.NONE);
-
-    dns.set(uriHost, dns.allocate(2));
-    RouteSelector.Selection selection = routeSelector.next();
-    dns.assertRequests(uriHost);
-
-    List<Route> routes = selection.getRoutes();
-    assertRoute(routes.get(0), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
-    assertRoute(routes.get(1), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
-
-    assertThat(selection.next()).isSameAs(routes.get(0));
-    assertThat(selection.next()).isSameAs(routes.get(1));
-    assertThat(selection.hasNext()).isFalse();
-    assertThat(routeSelector.hasNext()).isFalse();
-  }
-
-  @Test public void getHostString() throws Exception {
-    // Name proxy specification.
-    InetSocketAddress socketAddress = InetSocketAddress.createUnresolved("host", 1234);
-    assertThat(RouteSelector.Companion.getSocketHost(socketAddress)).isEqualTo("host");
-    socketAddress = InetSocketAddress.createUnresolved("127.0.0.1", 1234);
-    assertThat(RouteSelector.Companion.getSocketHost(socketAddress)).isEqualTo("127.0.0.1");
-
-    // InetAddress proxy specification.
-    socketAddress = new InetSocketAddress(InetAddress.getByName("localhost"), 1234);
-    assertThat(RouteSelector.Companion.getSocketHost(socketAddress)).isEqualTo("127.0.0.1");
-    socketAddress = new InetSocketAddress(
-        InetAddress.getByAddress(new byte[] {127, 0, 0, 1}), 1234);
-    assertThat(RouteSelector.Companion.getSocketHost(socketAddress)).isEqualTo("127.0.0.1");
-    socketAddress = new InetSocketAddress(
-        InetAddress.getByAddress("foobar", new byte[] {127, 0, 0, 1}), 1234);
-    assertThat(RouteSelector.Companion.getSocketHost(socketAddress)).isEqualTo("127.0.0.1");
-  }
-
-  @Test public void routeToString() throws Exception {
-    Route route = new Route(httpAddress(), Proxy.NO_PROXY,
-        InetSocketAddress.createUnresolved("host", 1234));
-    assertThat(route.toString()).isEqualTo("Route{host:1234}");
-  }
-
-  private void assertRoute(Route route, Address address, Proxy proxy, InetAddress socketAddress,
-      int socketPort) {
-    assertThat(route.address()).isEqualTo(address);
-    assertThat(route.proxy()).isEqualTo(proxy);
-    assertThat(route.socketAddress().getAddress()).isEqualTo(socketAddress);
-    assertThat(route.socketAddress().getPort()).isEqualTo(socketPort);
-  }
-
-  /** Returns an address that's without an SSL socket factory or hostname verifier. */
-  private Address httpAddress() {
-    return new Address(uriHost, uriPort, dns, socketFactory, null, null, null, authenticator, null,
-        protocols, connectionSpecs, proxySelector);
-  }
-
-  private Address httpsAddress() {
-    return new Address(uriHost, uriPort, dns, socketFactory, sslSocketFactory,
-        hostnameVerifier, null, authenticator, null, protocols, connectionSpecs, proxySelector);
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/http/CancelTest.java b/okhttp/src/test/java/okhttp3/internal/http/CancelTest.java
deleted file mode 100644
index 05abf5e904..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/http/CancelTest.java
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import javax.net.ServerSocketFactory;
-import javax.net.SocketFactory;
-import okhttp3.Call;
-import okhttp3.DelegatingServerSocketFactory;
-import okhttp3.DelegatingSocketFactory;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.OkHttpClientTestRule;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okio.Buffer;
-import okio.BufferedSink;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static org.junit.Assert.fail;
-
-public final class CancelTest {
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  // The size of the socket buffers in bytes.
-  private static final int SOCKET_BUFFER_SIZE = 256 * 1024;
-
-  private MockWebServer server;
-  private OkHttpClient client;
-
-  @Before public void setUp() throws Exception {
-    // Sockets on some platforms can have large buffers that mean writes do not block when
-    // required. These socket factories explicitly set the buffer sizes on sockets created.
-    server = new MockWebServer();
-    server.setServerSocketFactory(
-        new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
-          @Override protected ServerSocket configureServerSocket(
-              ServerSocket serverSocket) throws IOException {
-            serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-            return serverSocket;
-          }
-        });
-    client = clientTestRule.newClientBuilder()
-        .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
-          @Override protected Socket configureSocket(Socket socket) throws IOException {
-            socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
-            socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-            return socket;
-          }
-        })
-        .build();
-  }
-
-  @Test public void cancelWritingRequestBody() throws Exception {
-    server.enqueue(new MockResponse());
-    server.start();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(new RequestBody() {
-          @Override public @Nullable MediaType contentType() {
-            return null;
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            for (int i = 0; i < 10; i++) {
-              sink.writeByte(0);
-              sink.flush();
-              sleep(100);
-            }
-            fail("Expected connection to be closed");
-          }
-        })
-        .build());
-
-    cancelLater(call, 500);
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void cancelReadingResponseBody() throws Exception {
-    int responseBodySize = 8 * 1024 * 1024; // 8 MiB.
-
-    server.enqueue(new MockResponse()
-        .setBody(new Buffer().write(new byte[responseBodySize]))
-        .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
-    server.start();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    Response response = call.execute();
-    cancelLater(call, 500);
-    InputStream responseBody = response.body().byteStream();
-    byte[] buffer = new byte[1024];
-    try {
-      while (responseBody.read(buffer) != -1) {
-      }
-      fail("Expected connection to be closed");
-    } catch (IOException expected) {
-    }
-
-    responseBody.close();
-  }
-
-  private void sleep(int delayMillis) {
-    try {
-      Thread.sleep(delayMillis);
-    } catch (InterruptedException e) {
-      Thread.currentThread().interrupt();
-    }
-  }
-
-  private void cancelLater(Call call, int delayMillis) {
-    Thread interruptingCow = new Thread(() -> {
-      sleep(delayMillis);
-      call.cancel();
-    });
-    interruptingCow.start();
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java b/okhttp/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java
deleted file mode 100644
index 6a55aba932..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/http/ExternalHttp2Example.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2009 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.internal.http;
-
-import okhttp3.Call;
-import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-
-import static okhttp3.internal.Util.immutableListOf;
-
-public final class ExternalHttp2Example {
-  public static void main(String[] args) throws Exception {
-    OkHttpClient client = new OkHttpClient.Builder()
-        .protocols(immutableListOf(Protocol.HTTP_2, Protocol.HTTP_1_1))
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url("https://www.google.ca/")
-        .build());
-
-    Response response = call.execute();
-    try {
-      System.out.println(response.code());
-      System.out.println("PROTOCOL " + response.protocol());
-
-      String line;
-      while ((line = response.body().source().readUtf8Line()) != null) {
-        System.out.println(line);
-      }
-    } finally {
-      response.body().close();
-    }
-
-    client.connectionPool().evictAll();
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/http/HttpDateTest.kt b/okhttp/src/test/java/okhttp3/internal/http/HttpDateTest.kt
deleted file mode 100644
index a1c5dbd541..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/http/HttpDateTest.kt
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http
-
-import org.assertj.core.api.Assertions.assertThat
-import org.junit.After
-import org.junit.Before
-import org.junit.Test
-import java.util.Date
-import java.util.TimeZone
-
-class HttpDateTest {
-
-  private lateinit var originalDefault: TimeZone
-
-  @Before
-  @Throws(Exception::class)
-  fun setUp() {
-    originalDefault = TimeZone.getDefault()
-    // The default timezone should affect none of these tests: HTTP specified GMT, so we set it to
-    // something else.
-    TimeZone.setDefault(TimeZone.getTimeZone("America/Los_Angeles"))
-  }
-
-  @After
-  @Throws(Exception::class)
-  fun tearDown() {
-    TimeZone.setDefault(originalDefault)
-  }
-
-  @Test @Throws(Exception::class)
-  fun parseStandardFormats() {
-    // RFC 822, updated by RFC 1123 with GMT.
-    assertThat("Thu, 01 Jan 1970 00:00:00 GMT".toHttpDateOrNull()!!.time).isEqualTo(0L)
-    assertThat("Fri, 06 Jun 2014 12:30:30 GMT".toHttpDateOrNull()!!.time).isEqualTo(1402057830000L)
-
-    // RFC 850, obsoleted by RFC 1036 with GMT.
-    assertThat("Thursday, 01-Jan-70 00:00:00 GMT".toHttpDateOrNull()!!.time).isEqualTo(0L)
-    assertThat("Friday, 06-Jun-14 12:30:30 GMT".toHttpDateOrNull()!!.time).isEqualTo(1402057830000L)
-
-    // ANSI C's asctime(): should use GMT, not platform default.
-    assertThat("Thu Jan 1 00:00:00 1970".toHttpDateOrNull()!!.time).isEqualTo(0L)
-    assertThat("Fri Jun 6 12:30:30 2014".toHttpDateOrNull()!!.time).isEqualTo(1402057830000L)
-  }
-
-  @Test @Throws(Exception::class)
-  fun format() {
-    assertThat(Date(0L).toHttpDateString()).isEqualTo("Thu, 01 Jan 1970 00:00:00 GMT")
-    assertThat(Date(1402057830000L).toHttpDateString()).isEqualTo("Fri, 06 Jun 2014 12:30:30 GMT")
-  }
-
-  @Test @Throws(Exception::class)
-  fun parseNonStandardStrings() {
-    // RFC 822, updated by RFC 1123 with any TZ
-    assertThat("Thu, 01 Jan 1970 00:00:00 GMT-01:00".toHttpDateOrNull()!!.time).isEqualTo(3600000L)
-    assertThat("Thu, 01 Jan 1970 00:00:00 PST".toHttpDateOrNull()!!.time).isEqualTo(28800000L)
-    // Ignore trailing junk
-    assertThat("Thu, 01 Jan 1970 00:00:00 GMT JUNK".toHttpDateOrNull()!!.time).isEqualTo(0L)
-    // Missing timezones treated as bad.
-    assertThat("Thu, 01 Jan 1970 00:00:00".toHttpDateOrNull()).isNull()
-    // Missing seconds treated as bad.
-    assertThat("Thu, 01 Jan 1970 00:00 GMT".toHttpDateOrNull()).isNull()
-    // Extra spaces treated as bad.
-    assertThat("Thu,  01 Jan 1970 00:00 GMT".toHttpDateOrNull()).isNull()
-    // Missing leading zero treated as bad.
-    assertThat("Thu, 1 Jan 1970 00:00 GMT".toHttpDateOrNull()).isNull()
-
-    // RFC 850, obsoleted by RFC 1036 with any TZ.
-    assertThat("Thursday, 01-Jan-1970 00:00:00 GMT-01:00".toHttpDateOrNull()!!.time)
-        .isEqualTo(3600000L)
-    assertThat("Thursday, 01-Jan-1970 00:00:00 PST".toHttpDateOrNull()!!.time)
-        .isEqualTo(28800000L)
-    // Ignore trailing junk
-    assertThat("Thursday, 01-Jan-1970 00:00:00 PST JUNK".toHttpDateOrNull()!!.time)
-        .isEqualTo(28800000L)
-
-    // ANSI C's asctime() format
-    // This format ignores the timezone entirely even if it is present and uses GMT.
-    assertThat("Fri Jun 6 12:30:30 2014 PST".toHttpDateOrNull()!!.time).isEqualTo(1402057830000L)
-    // Ignore trailing junk.
-    assertThat("Fri Jun 6 12:30:30 2014 JUNK".toHttpDateOrNull()!!.time).isEqualTo(1402057830000L)
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/http/RecordingProxySelector.java b/okhttp/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
deleted file mode 100644
index 3f1698d503..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import java.net.InetSocketAddress;
-import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.SocketAddress;
-import java.net.URI;
-import java.util.ArrayList;
-import java.util.List;
-import okhttp3.internal.Util;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class RecordingProxySelector extends ProxySelector {
-  public final List<Proxy> proxies = new ArrayList<>();
-  public final List<URI> requestedUris = new ArrayList<>();
-  public final List<String> failures = new ArrayList<>();
-
-  @Override public List<Proxy> select(URI uri) {
-    requestedUris.add(uri);
-    return proxies;
-  }
-
-  public void assertRequests(URI... expectedUris) {
-    assertThat(requestedUris).containsExactly(expectedUris);
-    requestedUris.clear();
-  }
-
-  @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
-    InetSocketAddress socketAddress = (InetSocketAddress) sa;
-    failures.add(Util.format("%s %s:%d %s",
-        uri, socketAddress, socketAddress.getPort(), ioe.getMessage()));
-  }
-
-  @Override public String toString() {
-    return "RecordingProxySelector";
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/http/StatusLineTest.java b/okhttp/src/test/java/okhttp3/internal/http/StatusLineTest.java
deleted file mode 100644
index b8b49828f8..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/http/StatusLineTest.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import java.net.ProtocolException;
-import okhttp3.Protocol;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class StatusLineTest {
-  @Test public void parse() throws IOException {
-    String message = "Temporary Redirect";
-    int version = 1;
-    int code = 200;
-    StatusLine statusLine = StatusLine.Companion.parse(
-        "HTTP/1." + version + " " + code + " " + message);
-    assertThat(statusLine.message).isEqualTo(message);
-    assertThat(statusLine.protocol).isEqualTo(Protocol.HTTP_1_1);
-    assertThat(statusLine.code).isEqualTo(code);
-  }
-
-  @Test public void emptyMessage() throws IOException {
-    int version = 1;
-    int code = 503;
-    StatusLine statusLine = StatusLine.Companion.parse("HTTP/1." + version + " " + code + " ");
-    assertThat(statusLine.message).isEqualTo("");
-    assertThat(statusLine.protocol).isEqualTo(Protocol.HTTP_1_1);
-    assertThat(statusLine.code).isEqualTo(code);
-  }
-
-  /**
-   * This is not defined in the protocol but some servers won't add the leading empty space when the
-   * message is empty. http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1
-   */
-  @Test public void emptyMessageAndNoLeadingSpace() throws IOException {
-    int version = 1;
-    int code = 503;
-    StatusLine statusLine = StatusLine.Companion.parse("HTTP/1." + version + " " + code);
-    assertThat(statusLine.message).isEqualTo("");
-    assertThat(statusLine.protocol).isEqualTo(Protocol.HTTP_1_1);
-    assertThat(statusLine.code).isEqualTo(code);
-  }
-
-  // https://github.com/square/okhttp/issues/386
-  @Test public void shoutcast() throws IOException {
-    StatusLine statusLine = StatusLine.Companion.parse("ICY 200 OK");
-    assertThat(statusLine.message).isEqualTo("OK");
-    assertThat(statusLine.protocol).isEqualTo(Protocol.HTTP_1_0);
-    assertThat(statusLine.code).isEqualTo(200);
-  }
-
-  @Test public void missingProtocol() throws IOException {
-    assertInvalid("");
-    assertInvalid(" ");
-    assertInvalid("200 OK");
-    assertInvalid(" 200 OK");
-  }
-
-  @Test public void protocolVersions() throws IOException {
-    assertInvalid("HTTP/2.0 200 OK");
-    assertInvalid("HTTP/2.1 200 OK");
-    assertInvalid("HTTP/-.1 200 OK");
-    assertInvalid("HTTP/1.- 200 OK");
-    assertInvalid("HTTP/0.1 200 OK");
-    assertInvalid("HTTP/101 200 OK");
-    assertInvalid("HTTP/1.1_200 OK");
-  }
-
-  @Test public void nonThreeDigitCode() throws IOException {
-    assertInvalid("HTTP/1.1  OK");
-    assertInvalid("HTTP/1.1 2 OK");
-    assertInvalid("HTTP/1.1 20 OK");
-    assertInvalid("HTTP/1.1 2000 OK");
-    assertInvalid("HTTP/1.1 two OK");
-    assertInvalid("HTTP/1.1 2");
-    assertInvalid("HTTP/1.1 2000");
-    assertInvalid("HTTP/1.1 two");
-  }
-
-  @Test public void truncated() throws IOException {
-    assertInvalid("");
-    assertInvalid("H");
-    assertInvalid("HTTP/1");
-    assertInvalid("HTTP/1.");
-    assertInvalid("HTTP/1.1");
-    assertInvalid("HTTP/1.1 ");
-    assertInvalid("HTTP/1.1 2");
-    assertInvalid("HTTP/1.1 20");
-  }
-
-  @Test public void wrongMessageDelimiter() throws IOException {
-    assertInvalid("HTTP/1.1 200_");
-  }
-
-  private void assertInvalid(String statusLine) throws IOException {
-    try {
-      StatusLine.Companion.parse(statusLine);
-      fail();
-    } catch (ProtocolException expected) {
-    }
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java b/okhttp/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
deleted file mode 100644
index dab57bb7e0..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import javax.net.ServerSocketFactory;
-import javax.net.SocketFactory;
-import okhttp3.Call;
-import okhttp3.DelegatingServerSocketFactory;
-import okhttp3.DelegatingSocketFactory;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.OkHttpClientTestRule;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okio.Buffer;
-import okio.BufferedSink;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static org.junit.Assert.fail;
-
-public final class ThreadInterruptTest {
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  // The size of the socket buffers in bytes.
-  private static final int SOCKET_BUFFER_SIZE = 256 * 1024;
-
-  private MockWebServer server;
-  private OkHttpClient client;
-
-  @Before public void setUp() throws Exception {
-    // Sockets on some platforms can have large buffers that mean writes do not block when
-    // required. These socket factories explicitly set the buffer sizes on sockets created.
-    server = new MockWebServer();
-    server.setServerSocketFactory(
-        new DelegatingServerSocketFactory(ServerSocketFactory.getDefault()) {
-          @Override
-          protected ServerSocket configureServerSocket(ServerSocket serverSocket)
-              throws IOException {
-            serverSocket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-            return serverSocket;
-          }
-        });
-    client = clientTestRule.newClientBuilder()
-        .socketFactory(new DelegatingSocketFactory(SocketFactory.getDefault()) {
-          @Override
-          protected Socket configureSocket(Socket socket) throws IOException {
-            socket.setSendBufferSize(SOCKET_BUFFER_SIZE);
-            socket.setReceiveBufferSize(SOCKET_BUFFER_SIZE);
-            return socket;
-          }
-        })
-        .build();
-  }
-
-  @After public void tearDown() throws Exception {
-    Thread.interrupted(); // Clear interrupted state.
-  }
-
-  @Test public void interruptWritingRequestBody() throws Exception {
-    server.enqueue(new MockResponse());
-    server.start();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(new RequestBody() {
-          @Override public @Nullable MediaType contentType() {
-            return null;
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            for (int i = 0; i < 10; i++) {
-              sink.writeByte(0);
-              sink.flush();
-              sleep(100);
-            }
-            fail("Expected connection to be closed");
-          }
-        })
-        .build());
-
-    interruptLater(500);
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void interruptReadingResponseBody() throws Exception {
-    int responseBodySize = 8 * 1024 * 1024; // 8 MiB.
-
-    server.enqueue(new MockResponse()
-        .setBody(new Buffer().write(new byte[responseBodySize]))
-        .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
-    server.start();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    Response response = call.execute();
-    interruptLater(500);
-    InputStream responseBody = response.body().byteStream();
-    byte[] buffer = new byte[1024];
-    try {
-      while (responseBody.read(buffer) != -1) {
-      }
-      fail("Expected connection to be interrupted");
-    } catch (IOException expected) {
-    }
-
-    responseBody.close();
-  }
-
-  private void sleep(int delayMillis) {
-    try {
-      Thread.sleep(delayMillis);
-    } catch (InterruptedException e) {
-      Thread.currentThread().interrupt();
-    }
-  }
-
-  private void interruptLater(int delayMillis) {
-    Thread toInterrupt = Thread.currentThread();
-    Thread interruptingCow = new Thread(() -> {
-      sleep(delayMillis);
-      toInterrupt.interrupt();
-    });
-    interruptingCow.start();
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/http2/BaseTestHandler.java b/okhttp/src/test/java/okhttp3/internal/http2/BaseTestHandler.java
deleted file mode 100644
index b0b552b937..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/http2/BaseTestHandler.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.IOException;
-import java.util.List;
-import okio.BufferedSource;
-import okio.ByteString;
-
-import static org.junit.Assert.fail;
-
-class BaseTestHandler implements Http2Reader.Handler {
-  @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
-      throws IOException {
-    fail();
-  }
-
-  @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
-      List<Header> headerBlock) {
-    fail();
-  }
-
-  @Override public void rstStream(int streamId, ErrorCode errorCode) {
-    fail();
-  }
-
-  @Override public void settings(boolean clearPrevious, Settings settings) {
-    fail();
-  }
-
-  @Override public void ackSettings() {
-    fail();
-  }
-
-  @Override public void ping(boolean ack, int payload1, int payload2) {
-    fail();
-  }
-
-  @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
-    fail();
-  }
-
-  @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
-    fail();
-  }
-
-  @Override public void priority(int streamId, int streamDependency, int weight,
-      boolean exclusive) {
-    fail();
-  }
-
-  @Override
-  public void pushPromise(int streamId, int associatedStreamId, List<Header> headerBlock) {
-    fail();
-  }
-
-  @Override public void alternateService(int streamId, String origin, ByteString protocol,
-      String host, int port, long maxAge) {
-    fail();
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/http2/FrameLogTest.java b/okhttp/src/test/java/okhttp3/internal/http2/FrameLogTest.java
deleted file mode 100644
index 71c26860d9..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/http2/FrameLogTest.java
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.util.ArrayList;
-import java.util.List;
-import org.junit.Test;
-
-import static okhttp3.internal.http2.Http2.FLAG_ACK;
-import static okhttp3.internal.http2.Http2.FLAG_END_HEADERS;
-import static okhttp3.internal.http2.Http2.FLAG_END_STREAM;
-import static okhttp3.internal.http2.Http2.FLAG_NONE;
-import static okhttp3.internal.http2.Http2.TYPE_CONTINUATION;
-import static okhttp3.internal.http2.Http2.TYPE_DATA;
-import static okhttp3.internal.http2.Http2.TYPE_GOAWAY;
-import static okhttp3.internal.http2.Http2.TYPE_HEADERS;
-import static okhttp3.internal.http2.Http2.TYPE_PING;
-import static okhttp3.internal.http2.Http2.TYPE_PUSH_PROMISE;
-import static okhttp3.internal.http2.Http2.TYPE_SETTINGS;
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class FrameLogTest {
-  /** Real stream traffic applied to the log format. */
-  @Test public void exampleStream() {
-    assertThat(frameLog(false, 0, 5, TYPE_SETTINGS, FLAG_NONE)).isEqualTo(
-        ">> 0x00000000     5 SETTINGS      ");
-    assertThat(frameLog(false, 3, 100, TYPE_HEADERS, FLAG_END_HEADERS)).isEqualTo(
-        ">> 0x00000003   100 HEADERS       END_HEADERS");
-    assertThat(frameLog(false, 3, 0, TYPE_DATA, FLAG_END_STREAM)).isEqualTo(
-        ">> 0x00000003     0 DATA          END_STREAM");
-    assertThat(frameLog(true, 0, 15, TYPE_SETTINGS, FLAG_NONE)).isEqualTo(
-        "<< 0x00000000    15 SETTINGS      ");
-    assertThat(frameLog(false, 0, 0, TYPE_SETTINGS, FLAG_ACK)).isEqualTo(
-        ">> 0x00000000     0 SETTINGS      ACK");
-    assertThat(frameLog(true, 0, 0, TYPE_SETTINGS, FLAG_ACK)).isEqualTo(
-        "<< 0x00000000     0 SETTINGS      ACK");
-    assertThat(frameLog(true, 3, 22, TYPE_HEADERS, FLAG_END_HEADERS)).isEqualTo(
-        "<< 0x00000003    22 HEADERS       END_HEADERS");
-    assertThat(frameLog(true, 3, 226, TYPE_DATA, FLAG_END_STREAM)).isEqualTo(
-        "<< 0x00000003   226 DATA          END_STREAM");
-    assertThat(frameLog(false, 0, 8, TYPE_GOAWAY, FLAG_NONE)).isEqualTo(
-        ">> 0x00000000     8 GOAWAY        ");
-  }
-
-  @Test public void flagOverlapOn0x1() {
-    assertThat(frameLog(true, 0, 0, TYPE_SETTINGS, (byte) 0x1)).isEqualTo(
-        "<< 0x00000000     0 SETTINGS      ACK");
-    assertThat(frameLog(true, 0, 8, TYPE_PING, (byte) 0x1)).isEqualTo(
-        "<< 0x00000000     8 PING          ACK");
-    assertThat(frameLog(true, 3, 0, TYPE_HEADERS, (byte) 0x1)).isEqualTo(
-        "<< 0x00000003     0 HEADERS       END_STREAM");
-    assertThat(frameLog(true, 3, 0, TYPE_DATA, (byte) 0x1)).isEqualTo(
-        "<< 0x00000003     0 DATA          END_STREAM");
-  }
-
-  @Test public void flagOverlapOn0x4() {
-    assertThat(frameLog(true, 3, 10000, TYPE_HEADERS, (byte) 0x4)).isEqualTo(
-        "<< 0x00000003 10000 HEADERS       END_HEADERS");
-    assertThat(frameLog(true, 3, 10000, TYPE_CONTINUATION, (byte) 0x4)).isEqualTo(
-        "<< 0x00000003 10000 CONTINUATION  END_HEADERS");
-    assertThat(frameLog(true, 4, 10000, TYPE_PUSH_PROMISE, (byte) 0x4)).isEqualTo(
-        "<< 0x00000004 10000 PUSH_PROMISE  END_PUSH_PROMISE");
-  }
-
-  @Test public void flagOverlapOn0x20() {
-    assertThat(frameLog(true, 3, 10000, TYPE_HEADERS, (byte) 0x20)).isEqualTo(
-        "<< 0x00000003 10000 HEADERS       PRIORITY");
-    assertThat(frameLog(true, 3, 10000, TYPE_DATA, (byte) 0x20)).isEqualTo(
-        "<< 0x00000003 10000 DATA          COMPRESSED");
-  }
-
-  /**
-   * Ensures that valid flag combinations appear visually correct, and invalid show in hex.  This
-   * also demonstrates how sparse the lookup table is.
-   */
-  @Test public void allFormattedFlagsWithValidBits() {
-    List<String> formattedFlags = new ArrayList<>(0x40); // Highest valid flag is 0x20.
-    for (byte i = 0; i < 0x40; i++) formattedFlags.add(Http2.INSTANCE.formatFlags(TYPE_HEADERS, i));
-
-    assertThat(formattedFlags).containsExactly(
-        "",
-        "END_STREAM",
-        "00000010",
-        "00000011",
-        "END_HEADERS",
-        "END_STREAM|END_HEADERS",
-        "00000110",
-        "00000111",
-        "PADDED",
-        "END_STREAM|PADDED",
-        "00001010",
-        "00001011",
-        "00001100",
-        "END_STREAM|END_HEADERS|PADDED",
-        "00001110",
-        "00001111",
-        "00010000",
-        "00010001",
-        "00010010",
-        "00010011",
-        "00010100",
-        "00010101",
-        "00010110",
-        "00010111",
-        "00011000",
-        "00011001",
-        "00011010",
-        "00011011",
-        "00011100",
-        "00011101",
-        "00011110",
-        "00011111",
-        "PRIORITY",
-        "END_STREAM|PRIORITY",
-        "00100010",
-        "00100011",
-        "END_HEADERS|PRIORITY",
-        "END_STREAM|END_HEADERS|PRIORITY",
-        "00100110",
-        "00100111",
-        "00101000",
-        "END_STREAM|PRIORITY|PADDED",
-        "00101010",
-        "00101011",
-        "00101100",
-        "END_STREAM|END_HEADERS|PRIORITY|PADDED",
-        "00101110",
-        "00101111",
-        "00110000",
-        "00110001",
-        "00110010",
-        "00110011",
-        "00110100",
-        "00110101",
-        "00110110",
-        "00110111",
-        "00111000",
-        "00111001",
-        "00111010",
-        "00111011",
-        "00111100",
-        "00111101",
-        "00111110",
-        "00111111"
-    );
-  }
-
-  private String frameLog(boolean inbound, int streamId, int length, int type, int flags) {
-    return Http2.INSTANCE.frameLog(inbound, streamId, length, type, flags);
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/http2/HpackTest.java b/okhttp/src/test/java/okhttp3/internal/http2/HpackTest.java
deleted file mode 100644
index 9fd7faa6f7..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/http2/HpackTest.java
+++ /dev/null
@@ -1,1107 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.List;
-import okio.Buffer;
-import okio.ByteString;
-import org.junit.Before;
-import org.junit.Test;
-
-import static java.util.Arrays.asList;
-import static okhttp3.TestUtil.headerEntries;
-import static okio.ByteString.decodeHex;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class HpackTest {
-  private final Buffer bytesIn = new Buffer();
-  private Hpack.Reader hpackReader;
-  private Buffer bytesOut = new Buffer();
-  private Hpack.Writer hpackWriter;
-
-  @Before public void reset() {
-    hpackReader = newReader(bytesIn);
-    hpackWriter = new Hpack.Writer(4096, false, bytesOut);
-  }
-
-  /**
-   * Variable-length quantity special cases strings which are longer than 127 bytes.  Values such as
-   * cookies can be 4KiB, and should be possible to send.
-   *
-   * <p> http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#section-5.2
-   */
-  @Test public void largeHeaderValue() throws IOException {
-    char[] value = new char[4096];
-    Arrays.fill(value, '!');
-    List<Header> headerBlock = headerEntries("cookie", new String(value));
-
-    hpackWriter.writeHeaders(headerBlock);
-    bytesIn.writeAll(bytesOut);
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(0);
-
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
-  }
-
-  /**
-   * HPACK has a max header table size, which can be smaller than the max header message. Ensure the
-   * larger header content is not lost.
-   */
-  @Test public void tooLargeToHPackIsStillEmitted() throws IOException {
-    bytesIn.writeByte(0x21); // Dynamic table size update (size = 1).
-    bytesIn.writeByte(0x00); // Literal indexed
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-key");
-
-    bytesIn.writeByte(0x0d); // Literal value (len = 13)
-    bytesIn.writeUtf8("custom-header");
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(0);
-
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(
-        headerEntries("custom-key", "custom-header"));
-  }
-
-  /** Oldest entries are evicted to support newer ones. */
-  @Test public void writerEviction() throws IOException {
-    List<Header> headerBlock =
-        headerEntries(
-            "custom-foo", "custom-header",
-            "custom-bar", "custom-header",
-            "custom-baz", "custom-header");
-
-    bytesIn.writeByte(0x40); // Literal indexed
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-foo");
-
-    bytesIn.writeByte(0x0d); // Literal value (len = 13)
-    bytesIn.writeUtf8("custom-header");
-
-    bytesIn.writeByte(0x40); // Literal indexed
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-bar");
-
-    bytesIn.writeByte(0x0d); // Literal value (len = 13)
-    bytesIn.writeUtf8("custom-header");
-
-    bytesIn.writeByte(0x40); // Literal indexed
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-baz");
-
-    bytesIn.writeByte(0x0d); // Literal value (len = 13)
-    bytesIn.writeUtf8("custom-header");
-
-    // Set to only support 110 bytes (enough for 2 headers).
-    // Use a new Writer because we don't support change the dynamic table
-    // size after Writer constructed.
-    Hpack.Writer writer = new Hpack.Writer(110, false, bytesOut);
-    writer.writeHeaders(headerBlock);
-
-    assertThat(bytesOut).isEqualTo(bytesIn);
-    assertThat(writer.headerCount).isEqualTo(2);
-
-    int tableLength = writer.dynamicTable.length;
-    Header entry = writer.dynamicTable[tableLength - 1];
-    checkEntry(entry, "custom-bar", "custom-header", 55);
-
-    entry = writer.dynamicTable[tableLength - 2];
-    checkEntry(entry, "custom-baz", "custom-header", 55);
-  }
-
-  @Test public void readerEviction() throws IOException {
-    List<Header> headerBlock =
-        headerEntries(
-            "custom-foo", "custom-header",
-            "custom-bar", "custom-header",
-            "custom-baz", "custom-header");
-
-    // Set to only support 110 bytes (enough for 2 headers).
-    bytesIn.writeByte(0x3F); // Dynamic table size update (size = 110).
-    bytesIn.writeByte(0x4F);
-
-    bytesIn.writeByte(0x40); // Literal indexed
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-foo");
-
-    bytesIn.writeByte(0x0d); // Literal value (len = 13)
-    bytesIn.writeUtf8("custom-header");
-
-    bytesIn.writeByte(0x40); // Literal indexed
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-bar");
-
-    bytesIn.writeByte(0x0d); // Literal value (len = 13)
-    bytesIn.writeUtf8("custom-header");
-
-    bytesIn.writeByte(0x40); // Literal indexed
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-baz");
-
-    bytesIn.writeByte(0x0d); // Literal value (len = 13)
-    bytesIn.writeUtf8("custom-header");
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(2);
-
-    Header entry1 = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
-    checkEntry(entry1, "custom-bar", "custom-header", 55);
-
-    Header entry2 = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
-    checkEntry(entry2, "custom-baz", "custom-header", 55);
-
-    // Once a header field is decoded and added to the reconstructed header
-    // list, it cannot be removed from it. Hence, foo is here.
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
-
-    // Simulate receiving a small dynamic table size update, that implies eviction.
-    bytesIn.writeByte(0x3F); // Dynamic table size update (size = 55).
-    bytesIn.writeByte(0x18);
-    hpackReader.readHeaders();
-    assertThat(hpackReader.headerCount).isEqualTo(1);
-  }
-
-  /** Header table backing array is initially 8 long, let's ensure it grows. */
-  @Test public void dynamicallyGrowsBeyond64Entries() throws IOException {
-    // Lots of headers need more room!
-    hpackReader = new Hpack.Reader(bytesIn, 16384, 4096);
-    bytesIn.writeByte(0x3F); // Dynamic table size update (size = 16384).
-    bytesIn.writeByte(0xE1);
-    bytesIn.writeByte(0x7F);
-
-    for (int i = 0; i < 256; i++) {
-      bytesIn.writeByte(0x40); // Literal indexed
-      bytesIn.writeByte(0x0a); // Literal name (len = 10)
-      bytesIn.writeUtf8("custom-foo");
-
-      bytesIn.writeByte(0x0d); // Literal value (len = 13)
-      bytesIn.writeUtf8("custom-header");
-    }
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(256);
-  }
-
-  @Test public void huffmanDecodingSupported() throws IOException {
-    bytesIn.writeByte(0x44); // == Literal indexed ==
-                             // Indexed name (idx = 4) -> :path
-    bytesIn.writeByte(0x8c); // Literal value Huffman encoded 12 bytes
-                             // decodes to www.example.com which is length 15
-    bytesIn.write(decodeHex("f1e3c2e5f23a6ba0ab90f4ff"));
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(1);
-    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(52);
-
-    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
-    checkEntry(entry, ":path", "www.example.com", 52);
-  }
-
-  /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.2.1
-   */
-  @Test public void readLiteralHeaderFieldWithIndexing() throws IOException {
-    bytesIn.writeByte(0x40); // Literal indexed
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-key");
-
-    bytesIn.writeByte(0x0d); // Literal value (len = 13)
-    bytesIn.writeUtf8("custom-header");
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(1);
-    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(55);
-
-    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
-    checkEntry(entry, "custom-key", "custom-header", 55);
-
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(
-        headerEntries("custom-key", "custom-header"));
-  }
-
-  /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.2.2
-   */
-  @Test public void literalHeaderFieldWithoutIndexingIndexedName() throws IOException {
-    List<Header> headerBlock = headerEntries(":path", "/sample/path");
-
-    bytesIn.writeByte(0x04); // == Literal not indexed ==
-                             // Indexed name (idx = 4) -> :path
-    bytesIn.writeByte(0x0c); // Literal value (len = 12)
-    bytesIn.writeUtf8("/sample/path");
-
-    hpackWriter.writeHeaders(headerBlock);
-    assertThat(bytesOut).isEqualTo(bytesIn);
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(0);
-
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
-  }
-
-  @Test public void literalHeaderFieldWithoutIndexingNewName() throws IOException {
-    List<Header> headerBlock = headerEntries("custom-key", "custom-header");
-
-    bytesIn.writeByte(0x00); // Not indexed
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-key");
-
-    bytesIn.writeByte(0x0d); // Literal value (len = 13)
-    bytesIn.writeUtf8("custom-header");
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(0);
-
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
-  }
-
-  @Test public void literalHeaderFieldNeverIndexedIndexedName() throws IOException {
-    bytesIn.writeByte(0x14); // == Literal never indexed ==
-                             // Indexed name (idx = 4) -> :path
-    bytesIn.writeByte(0x0c); // Literal value (len = 12)
-    bytesIn.writeUtf8("/sample/path");
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(0);
-
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(
-        headerEntries(":path", "/sample/path"));
-  }
-
-  @Test public void literalHeaderFieldNeverIndexedNewName() throws IOException {
-    List<Header> headerBlock = headerEntries("custom-key", "custom-header");
-
-    bytesIn.writeByte(0x10); // Never indexed
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-key");
-
-    bytesIn.writeByte(0x0d); // Literal value (len = 13)
-    bytesIn.writeUtf8("custom-header");
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(0);
-
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
-  }
-
-  @Test public void literalHeaderFieldWithIncrementalIndexingIndexedName() throws IOException {
-    List<Header> headerBlock = headerEntries(":path", "/sample/path");
-
-    bytesIn.writeByte(0x44); // Indexed name (idx = 4) -> :path
-    bytesIn.writeByte(0x0c); // Literal value (len = 12)
-    bytesIn.writeUtf8("/sample/path");
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(1);
-
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
-  }
-
-  @Test public void literalHeaderFieldWithIncrementalIndexingNewName() throws IOException {
-    List<Header> headerBlock = headerEntries("custom-key", "custom-header");
-
-    bytesIn.writeByte(0x40); // Never indexed
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-key");
-
-    bytesIn.writeByte(0x0d); // Literal value (len = 13)
-    bytesIn.writeUtf8("custom-header");
-
-    hpackWriter.writeHeaders(headerBlock);
-    assertThat(bytesOut).isEqualTo(bytesIn);
-
-    assertThat(hpackWriter.headerCount).isEqualTo(1);
-
-    Header entry = hpackWriter.dynamicTable[hpackWriter.dynamicTable.length - 1];
-    checkEntry(entry, "custom-key", "custom-header", 55);
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(1);
-
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
-  }
-
-  @Test public void theSameHeaderAfterOneIncrementalIndexed() throws IOException {
-    List<Header> headerBlock =
-        headerEntries(
-            "custom-key", "custom-header",
-            "custom-key", "custom-header");
-
-    bytesIn.writeByte(0x40); // Never indexed
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-key");
-
-    bytesIn.writeByte(0x0d); // Literal value (len = 13)
-    bytesIn.writeUtf8("custom-header");
-
-    bytesIn.writeByte(0xbe); // Indexed name and value (idx = 63)
-
-    hpackWriter.writeHeaders(headerBlock);
-    assertThat(bytesOut).isEqualTo(bytesIn);
-
-    assertThat(hpackWriter.headerCount).isEqualTo(1);
-
-    Header entry = hpackWriter.dynamicTable[hpackWriter.dynamicTable.length - 1];
-    checkEntry(entry, "custom-key", "custom-header", 55);
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(1);
-
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerBlock);
-  }
-
-  @Test public void staticHeaderIsNotCopiedIntoTheIndexedTable() throws IOException {
-    bytesIn.writeByte(0x82); // == Indexed - Add ==
-                             // idx = 2 -> :method: GET
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.headerCount).isEqualTo(0);
-    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(0);
-
-    assertThat(hpackReader.dynamicTable[readerHeaderTableLength() - 1]).isNull();
-
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(
-        headerEntries(":method", "GET"));
-  }
-
-  // Example taken from twitter/hpack DecoderTest.testUnusedIndex
-  @Test public void readIndexedHeaderFieldIndex0() throws IOException {
-    bytesIn.writeByte(0x80); // == Indexed - Add idx = 0
-
-    try {
-      hpackReader.readHeaders();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("index == 0");
-    }
-  }
-
-  // Example taken from twitter/hpack DecoderTest.testIllegalIndex
-  @Test public void readIndexedHeaderFieldTooLargeIndex() throws IOException {
-    bytesIn.writeShort(0xff00); // == Indexed - Add idx = 127
-
-    try {
-      hpackReader.readHeaders();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("Header index too large 127");
-    }
-  }
-
-  // Example taken from twitter/hpack DecoderTest.testInsidiousIndex
-  @Test public void readIndexedHeaderFieldInsidiousIndex() throws IOException {
-    bytesIn.writeByte(0xff); // == Indexed - Add ==
-    bytesIn.write(decodeHex("8080808008")); // idx = -2147483521
-
-    try {
-      hpackReader.readHeaders();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("Header index too large -2147483521");
-    }
-  }
-
-  // Example taken from twitter/hpack DecoderTest.testHeaderTableSizeUpdate
-  @Test public void minMaxHeaderTableSize() throws IOException {
-    bytesIn.writeByte(0x20);
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.maxDynamicTableByteCount()).isEqualTo(0);
-
-    bytesIn.writeByte(0x3f); // encode size 4096
-    bytesIn.writeByte(0xe1);
-    bytesIn.writeByte(0x1f);
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.maxDynamicTableByteCount()).isEqualTo(4096);
-  }
-
-  // Example taken from twitter/hpack DecoderTest.testIllegalHeaderTableSizeUpdate
-  @Test public void cannotSetTableSizeLargerThanSettingsValue() throws IOException {
-    bytesIn.writeByte(0x3f); // encode size 4097
-    bytesIn.writeByte(0xe2);
-    bytesIn.writeByte(0x1f);
-
-    try {
-      hpackReader.readHeaders();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("Invalid dynamic table size update 4097");
-    }
-  }
-
-  // Example taken from twitter/hpack DecoderTest.testInsidiousMaxHeaderSize
-  @Test public void readHeaderTableStateChangeInsidiousMaxHeaderByteCount() throws IOException {
-    bytesIn.writeByte(0x3f);
-    bytesIn.write(decodeHex("e1ffffff07")); // count = -2147483648
-
-    try {
-      hpackReader.readHeaders();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("Invalid dynamic table size update -2147483648");
-    }
-  }
-
-  /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.2.4
-   */
-  @Test public void readIndexedHeaderFieldFromStaticTableWithoutBuffering() throws IOException {
-    bytesIn.writeByte(0x20); // Dynamic table size update (size = 0).
-    bytesIn.writeByte(0x82); // == Indexed - Add ==
-                             // idx = 2 -> :method: GET
-
-    hpackReader.readHeaders();
-
-    // Not buffered in header table.
-    assertThat(hpackReader.headerCount).isEqualTo(0);
-
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(
-        headerEntries(":method", "GET"));
-  }
-
-  @Test public void readLiteralHeaderWithIncrementalIndexingStaticName() throws IOException {
-    bytesIn.writeByte(0x7d); // == Literal indexed ==
-    // Indexed name (idx = 60) -> "www-authenticate"
-    bytesIn.writeByte(0x05); // Literal value (len = 5)
-    bytesIn.writeUtf8("Basic");
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.getAndResetHeaderList())
-        .containsExactly(new Header("www-authenticate", "Basic"));
-  }
-
-  @Test public void readLiteralHeaderWithIncrementalIndexingDynamicName() throws IOException {
-    bytesIn.writeByte(0x40);
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-foo");
-    bytesIn.writeByte(0x05); // Literal value (len = 5)
-    bytesIn.writeUtf8("Basic");
-
-    bytesIn.writeByte(0x7e);
-    bytesIn.writeByte(0x06); // Literal value (len = 6)
-    bytesIn.writeUtf8("Basic2");
-
-    hpackReader.readHeaders();
-
-    assertThat(hpackReader.getAndResetHeaderList()).containsExactly(
-        new Header("custom-foo", "Basic"), new Header("custom-foo", "Basic2"));
-  }
-
-  /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.2
-   */
-  @Test public void readRequestExamplesWithoutHuffman() throws IOException {
-    firstRequestWithoutHuffman();
-    hpackReader.readHeaders();
-    checkReadFirstRequestWithoutHuffman();
-
-    secondRequestWithoutHuffman();
-    hpackReader.readHeaders();
-    checkReadSecondRequestWithoutHuffman();
-
-    thirdRequestWithoutHuffman();
-    hpackReader.readHeaders();
-    checkReadThirdRequestWithoutHuffman();
-  }
-
-  @Test public void readFailingRequestExample() throws IOException {
-    bytesIn.writeByte(0x82); // == Indexed - Add ==
-    // idx = 2 -> :method: GET
-    bytesIn.writeByte(0x86); // == Indexed - Add ==
-    // idx = 7 -> :scheme: http
-    bytesIn.writeByte(0x84); // == Indexed - Add ==
-
-    bytesIn.writeByte(0x7f); // == Bad index! ==
-
-    // Indexed name (idx = 4) -> :authority
-    bytesIn.writeByte(0x0f); // Literal value (len = 15)
-    bytesIn.writeUtf8("www.example.com");
-
-    try {
-      hpackReader.readHeaders();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("Header index too large 78");
-    }
-  }
-
-  private void firstRequestWithoutHuffman() {
-    bytesIn.writeByte(0x82); // == Indexed - Add ==
-                             // idx = 2 -> :method: GET
-    bytesIn.writeByte(0x86); // == Indexed - Add ==
-                             // idx = 7 -> :scheme: http
-    bytesIn.writeByte(0x84); // == Indexed - Add ==
-                             // idx = 6 -> :path: /
-    bytesIn.writeByte(0x41); // == Literal indexed ==
-                             // Indexed name (idx = 4) -> :authority
-    bytesIn.writeByte(0x0f); // Literal value (len = 15)
-    bytesIn.writeUtf8("www.example.com");
-  }
-
-  private void checkReadFirstRequestWithoutHuffman() {
-    assertThat(hpackReader.headerCount).isEqualTo(1);
-
-    // [  1] (s =  57) :authority: www.example.com
-    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
-    checkEntry(entry, ":authority", "www.example.com", 57);
-
-    // Table size: 57
-    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(57);
-
-    // Decoded header list:
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerEntries(
-        ":method", "GET",
-        ":scheme", "http",
-        ":path", "/",
-        ":authority", "www.example.com"));
-  }
-
-  private void secondRequestWithoutHuffman() {
-    bytesIn.writeByte(0x82); // == Indexed - Add ==
-                             // idx = 2 -> :method: GET
-    bytesIn.writeByte(0x86); // == Indexed - Add ==
-                             // idx = 7 -> :scheme: http
-    bytesIn.writeByte(0x84); // == Indexed - Add ==
-                             // idx = 6 -> :path: /
-    bytesIn.writeByte(0xbe); // == Indexed - Add ==
-                             // Indexed name (idx = 62) -> :authority: www.example.com
-    bytesIn.writeByte(0x58); // == Literal indexed ==
-                             // Indexed name (idx = 24) -> cache-control
-    bytesIn.writeByte(0x08); // Literal value (len = 8)
-    bytesIn.writeUtf8("no-cache");
-  }
-
-  private void checkReadSecondRequestWithoutHuffman() {
-    assertThat(hpackReader.headerCount).isEqualTo(2);
-
-    // [  1] (s =  53) cache-control: no-cache
-    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
-    checkEntry(entry, "cache-control", "no-cache", 53);
-
-    // [  2] (s =  57) :authority: www.example.com
-    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
-    checkEntry(entry, ":authority", "www.example.com", 57);
-
-    // Table size: 110
-    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(110);
-
-    // Decoded header list:
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerEntries(
-        ":method", "GET",
-        ":scheme", "http",
-        ":path", "/",
-        ":authority", "www.example.com",
-        "cache-control", "no-cache"));
-  }
-
-  private void thirdRequestWithoutHuffman() {
-    bytesIn.writeByte(0x82); // == Indexed - Add ==
-                             // idx = 2 -> :method: GET
-    bytesIn.writeByte(0x87); // == Indexed - Add ==
-                             // idx = 7 -> :scheme: http
-    bytesIn.writeByte(0x85); // == Indexed - Add ==
-                             // idx = 5 -> :path: /index.html
-    bytesIn.writeByte(0xbf); // == Indexed - Add ==
-                             // Indexed name (idx = 63) -> :authority: www.example.com
-    bytesIn.writeByte(0x40); // Literal indexed
-    bytesIn.writeByte(0x0a); // Literal name (len = 10)
-    bytesIn.writeUtf8("custom-key");
-    bytesIn.writeByte(0x0c); // Literal value (len = 12)
-    bytesIn.writeUtf8("custom-value");
-  }
-
-  private void checkReadThirdRequestWithoutHuffman() {
-    assertThat(hpackReader.headerCount).isEqualTo(3);
-
-    // [  1] (s =  54) custom-key: custom-value
-    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 3];
-    checkEntry(entry, "custom-key", "custom-value", 54);
-
-    // [  2] (s =  53) cache-control: no-cache
-    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
-    checkEntry(entry, "cache-control", "no-cache", 53);
-
-    // [  3] (s =  57) :authority: www.example.com
-    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
-    checkEntry(entry, ":authority", "www.example.com", 57);
-
-    // Table size: 164
-    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(164);
-
-    // Decoded header list:
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerEntries(
-        ":method", "GET",
-        ":scheme", "https",
-        ":path", "/index.html",
-        ":authority", "www.example.com",
-        "custom-key", "custom-value"));
-  }
-
-  /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.4
-   */
-  @Test public void readRequestExamplesWithHuffman() throws IOException {
-    firstRequestWithHuffman();
-    hpackReader.readHeaders();
-    checkReadFirstRequestWithHuffman();
-
-    secondRequestWithHuffman();
-    hpackReader.readHeaders();
-    checkReadSecondRequestWithHuffman();
-
-    thirdRequestWithHuffman();
-    hpackReader.readHeaders();
-    checkReadThirdRequestWithHuffman();
-  }
-
-  private void firstRequestWithHuffman() {
-    bytesIn.writeByte(0x82); // == Indexed - Add ==
-                             // idx = 2 -> :method: GET
-    bytesIn.writeByte(0x86); // == Indexed - Add ==
-                             // idx = 6 -> :scheme: http
-    bytesIn.writeByte(0x84); // == Indexed - Add ==
-                             // idx = 4 -> :path: /
-    bytesIn.writeByte(0x41); // == Literal indexed ==
-                             // Indexed name (idx = 1) -> :authority
-    bytesIn.writeByte(0x8c); // Literal value Huffman encoded 12 bytes
-                             // decodes to www.example.com which is length 15
-    bytesIn.write(decodeHex("f1e3c2e5f23a6ba0ab90f4ff"));
-  }
-
-  private void checkReadFirstRequestWithHuffman() {
-    assertThat(hpackReader.headerCount).isEqualTo(1);
-
-    // [  1] (s =  57) :authority: www.example.com
-    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
-    checkEntry(entry, ":authority", "www.example.com", 57);
-
-    // Table size: 57
-    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(57);
-
-    // Decoded header list:
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerEntries(
-        ":method", "GET",
-        ":scheme", "http",
-        ":path", "/",
-        ":authority", "www.example.com"));
-  }
-
-  private void secondRequestWithHuffman() {
-    bytesIn.writeByte(0x82); // == Indexed - Add ==
-                             // idx = 2 -> :method: GET
-    bytesIn.writeByte(0x86); // == Indexed - Add ==
-                             // idx = 6 -> :scheme: http
-    bytesIn.writeByte(0x84); // == Indexed - Add ==
-                             // idx = 4 -> :path: /
-    bytesIn.writeByte(0xbe); // == Indexed - Add ==
-                             // idx = 62 -> :authority: www.example.com
-    bytesIn.writeByte(0x58); // == Literal indexed ==
-                             // Indexed name (idx = 24) -> cache-control
-    bytesIn.writeByte(0x86); // Literal value Huffman encoded 6 bytes
-                             // decodes to no-cache which is length 8
-    bytesIn.write(decodeHex("a8eb10649cbf"));
-  }
-
-  private void checkReadSecondRequestWithHuffman() {
-    assertThat(hpackReader.headerCount).isEqualTo(2);
-
-    // [  1] (s =  53) cache-control: no-cache
-    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
-    checkEntry(entry, "cache-control", "no-cache", 53);
-
-    // [  2] (s =  57) :authority: www.example.com
-    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
-    checkEntry(entry, ":authority", "www.example.com", 57);
-
-    // Table size: 110
-    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(110);
-
-    // Decoded header list:
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerEntries(
-        ":method", "GET",
-        ":scheme", "http",
-        ":path", "/",
-        ":authority", "www.example.com",
-        "cache-control", "no-cache"));
-  }
-
-  private void thirdRequestWithHuffman() {
-    bytesIn.writeByte(0x82); // == Indexed - Add ==
-                             // idx = 2 -> :method: GET
-    bytesIn.writeByte(0x87); // == Indexed - Add ==
-                             // idx = 7 -> :scheme: https
-    bytesIn.writeByte(0x85); // == Indexed - Add ==
-                             // idx = 5 -> :path: /index.html
-    bytesIn.writeByte(0xbf); // == Indexed - Add ==
-                             // idx = 63 -> :authority: www.example.com
-    bytesIn.writeByte(0x40); // Literal indexed
-    bytesIn.writeByte(0x88); // Literal name Huffman encoded 8 bytes
-                             // decodes to custom-key which is length 10
-    bytesIn.write(decodeHex("25a849e95ba97d7f"));
-    bytesIn.writeByte(0x89); // Literal value Huffman encoded 9 bytes
-                             // decodes to custom-value which is length 12
-    bytesIn.write(decodeHex("25a849e95bb8e8b4bf"));
-  }
-
-  private void checkReadThirdRequestWithHuffman() {
-    assertThat(hpackReader.headerCount).isEqualTo(3);
-
-    // [  1] (s =  54) custom-key: custom-value
-    Header entry = hpackReader.dynamicTable[readerHeaderTableLength() - 3];
-    checkEntry(entry, "custom-key", "custom-value", 54);
-
-    // [  2] (s =  53) cache-control: no-cache
-    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 2];
-    checkEntry(entry, "cache-control", "no-cache", 53);
-
-    // [  3] (s =  57) :authority: www.example.com
-    entry = hpackReader.dynamicTable[readerHeaderTableLength() - 1];
-    checkEntry(entry, ":authority", "www.example.com", 57);
-
-    // Table size: 164
-    assertThat(hpackReader.dynamicTableByteCount).isEqualTo(164);
-
-    // Decoded header list:
-    assertThat(hpackReader.getAndResetHeaderList()).isEqualTo(headerEntries(
-        ":method", "GET",
-        ":scheme", "https",
-        ":path", "/index.html",
-        ":authority", "www.example.com",
-        "custom-key", "custom-value"));
-  }
-
-  @Test public void readSingleByteInt() throws IOException {
-    assertThat(newReader(byteStream()).readInt(10, 31)).isEqualTo(10);
-    assertThat(newReader(byteStream()).readInt(0xe0 | 10, 31)).isEqualTo(10);
-  }
-
-  @Test public void readMultibyteInt() throws IOException {
-    assertThat(newReader(byteStream(154, 10)).readInt(31, 31)).isEqualTo(1337);
-  }
-
-  @Test public void writeSingleByteInt() throws IOException {
-    hpackWriter.writeInt(10, 31, 0);
-    assertBytes(10);
-    hpackWriter.writeInt(10, 31, 0xe0);
-    assertBytes(0xe0 | 10);
-  }
-
-  @Test public void writeMultibyteInt() throws IOException {
-    hpackWriter.writeInt(1337, 31, 0);
-    assertBytes(31, 154, 10);
-    hpackWriter.writeInt(1337, 31, 0xe0);
-    assertBytes(0xe0 | 31, 154, 10);
-  }
-
-  @Test public void max31BitValue() throws IOException {
-    hpackWriter.writeInt(0x7fffffff, 31, 0);
-    assertBytes(31, 224, 255, 255, 255, 7);
-    assertThat(newReader(byteStream(224, 255, 255, 255, 7)).readInt(31, 31)).isEqualTo(
-        (long) 0x7fffffff);
-  }
-
-  @Test public void prefixMask() throws IOException {
-    hpackWriter.writeInt(31, 31, 0);
-    assertBytes(31, 0);
-    assertThat(newReader(byteStream(0)).readInt(31, 31)).isEqualTo(31);
-  }
-
-  @Test public void prefixMaskMinusOne() throws IOException {
-    hpackWriter.writeInt(30, 31, 0);
-    assertBytes(30);
-    assertThat(newReader(byteStream(0)).readInt(31, 31)).isEqualTo(31);
-  }
-
-  @Test public void zero() throws IOException {
-    hpackWriter.writeInt(0, 31, 0);
-    assertBytes(0);
-    assertThat(newReader(byteStream()).readInt(0, 31)).isEqualTo(0);
-  }
-
-  @Test public void lowercaseHeaderNameBeforeEmit() throws IOException {
-    hpackWriter.writeHeaders(asList(new Header("FoO", "BaR")));
-    assertBytes(0x40, 3, 'f', 'o', 'o', 3, 'B', 'a', 'R');
-  }
-
-  @Test public void mixedCaseHeaderNameIsMalformed() throws IOException {
-    try {
-      newReader(byteStream(0, 3, 'F', 'o', 'o', 3, 'B', 'a', 'R')).readHeaders();
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "PROTOCOL_ERROR response malformed: mixed case name: Foo");
-    }
-  }
-
-  @Test public void emptyHeaderName() throws IOException {
-    hpackWriter.writeByteString(ByteString.encodeUtf8(""));
-    assertBytes(0);
-    assertThat(newReader(byteStream(0)).readByteString()).isEqualTo(ByteString.EMPTY);
-  }
-
-  @Test public void emitsDynamicTableSizeUpdate() throws IOException {
-    hpackWriter.resizeHeaderTable(2048);
-    hpackWriter.writeHeaders(asList(new Header("foo", "bar")));
-    assertBytes(
-        0x3F, 0xE1, 0xF, // Dynamic table size update (size = 2048).
-        0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
-
-    hpackWriter.resizeHeaderTable(8192);
-    hpackWriter.writeHeaders(asList(new Header("bar", "foo")));
-    assertBytes(
-        0x3F, 0xE1, 0x3F, // Dynamic table size update (size = 8192).
-        0x40, 3, 'b', 'a', 'r', 3, 'f', 'o', 'o');
-
-    // No more dynamic table updates should be emitted.
-    hpackWriter.writeHeaders(asList(new Header("far", "boo")));
-    assertBytes(0x40, 3, 'f', 'a', 'r', 3, 'b', 'o', 'o');
-  }
-
-  @Test public void noDynamicTableSizeUpdateWhenSizeIsEqual() throws IOException {
-    int currentSize = hpackWriter.headerTableSizeSetting;
-    hpackWriter.resizeHeaderTable(currentSize);
-    hpackWriter.writeHeaders(asList(new Header("foo", "bar")));
-
-    assertBytes(0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
-  }
-
-  @Test public void growDynamicTableSize() throws IOException {
-    hpackWriter.resizeHeaderTable(8192);
-    hpackWriter.resizeHeaderTable(16384);
-    hpackWriter.writeHeaders(asList(new Header("foo", "bar")));
-
-    assertBytes(
-        0x3F, 0xE1, 0x7F, // Dynamic table size update (size = 16384).
-        0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
-  }
-
-  @Test public void shrinkDynamicTableSize() throws IOException {
-    hpackWriter.resizeHeaderTable(2048);
-    hpackWriter.resizeHeaderTable(0);
-    hpackWriter.writeHeaders(asList(new Header("foo", "bar")));
-
-    assertBytes(
-        0x20, // Dynamic size update (size = 0).
-        0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
-  }
-
-  @Test public void manyDynamicTableSizeChanges() throws IOException {
-    hpackWriter.resizeHeaderTable(16384);
-    hpackWriter.resizeHeaderTable(8096);
-    hpackWriter.resizeHeaderTable(0);
-    hpackWriter.resizeHeaderTable(4096);
-    hpackWriter.resizeHeaderTable(2048);
-    hpackWriter.writeHeaders(asList(new Header("foo", "bar")));
-
-    assertBytes(
-        0x20, // Dynamic size update (size = 0).
-        0x3F, 0xE1, 0xF, // Dynamic size update (size = 2048).
-        0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
-  }
-
-  @Test public void dynamicTableEvictionWhenSizeLowered() throws IOException {
-    List<Header> headerBlock =
-        headerEntries(
-            "custom-key1", "custom-header",
-            "custom-key2", "custom-header");
-    hpackWriter.writeHeaders(headerBlock);
-    assertThat(hpackWriter.headerCount).isEqualTo(2);
-
-    hpackWriter.resizeHeaderTable(56);
-    assertThat(hpackWriter.headerCount).isEqualTo(1);
-
-    hpackWriter.resizeHeaderTable(0);
-    assertThat(hpackWriter.headerCount).isEqualTo(0);
-  }
-
-  @Test public void noEvictionOnDynamicTableSizeIncrease() throws IOException {
-    List<Header> headerBlock =
-        headerEntries(
-            "custom-key1", "custom-header",
-            "custom-key2", "custom-header");
-    hpackWriter.writeHeaders(headerBlock);
-    assertThat(hpackWriter.headerCount).isEqualTo(2);
-
-    hpackWriter.resizeHeaderTable(8192);
-    assertThat(hpackWriter.headerCount).isEqualTo(2);
-  }
-
-  @Test public void dynamicTableSizeHasAnUpperBound() {
-    hpackWriter.resizeHeaderTable(1048576);
-    assertThat(hpackWriter.maxDynamicTableByteCount).isEqualTo(16384);
-  }
-
-  @Test public void huffmanEncode() throws IOException {
-    hpackWriter = new Hpack.Writer(4096, true, bytesOut);
-    hpackWriter.writeHeaders(headerEntries("foo", "bar"));
-
-    ByteString expected = new Buffer()
-        .writeByte(0x40) // Literal header, new name.
-        .writeByte(0x82) // String literal is Huffman encoded (len = 2).
-        .writeByte(0x94) // 'foo' Huffman encoded.
-        .writeByte(0xE7)
-        .writeByte(3) // String literal not Huffman encoded (len = 3).
-        .writeByte('b')
-        .writeByte('a')
-        .writeByte('r')
-        .readByteString();
-
-    ByteString actual = bytesOut.readByteString();
-    assertThat(actual).isEqualTo(expected);
-  }
-
-  @Test public void staticTableIndexedHeaders() throws IOException {
-    hpackWriter.writeHeaders(headerEntries(":method", "GET"));
-    assertBytes(0x82);
-    assertThat(hpackWriter.headerCount).isEqualTo(0);
-
-    hpackWriter.writeHeaders(headerEntries(":method", "POST"));
-    assertBytes(0x83);
-    assertThat(hpackWriter.headerCount).isEqualTo(0);
-
-    hpackWriter.writeHeaders(headerEntries(":path", "/"));
-    assertBytes(0x84);
-    assertThat(hpackWriter.headerCount).isEqualTo(0);
-
-    hpackWriter.writeHeaders(headerEntries(":path", "/index.html"));
-    assertBytes(0x85);
-    assertThat(hpackWriter.headerCount).isEqualTo(0);
-
-    hpackWriter.writeHeaders(headerEntries(":scheme", "http"));
-    assertBytes(0x86);
-    assertThat(hpackWriter.headerCount).isEqualTo(0);
-
-    hpackWriter.writeHeaders(headerEntries(":scheme", "https"));
-    assertBytes(0x87);
-    assertThat(hpackWriter.headerCount).isEqualTo(0);
-  }
-
-  @Test public void dynamicTableIndexedHeader() throws IOException {
-    hpackWriter.writeHeaders(headerEntries("custom-key", "custom-header"));
-    assertBytes(0x40,
-        10, 'c', 'u', 's', 't', 'o', 'm', '-', 'k', 'e', 'y',
-        13, 'c', 'u', 's', 't', 'o', 'm', '-', 'h', 'e', 'a', 'd', 'e', 'r');
-    assertThat(hpackWriter.headerCount).isEqualTo(1);
-
-    hpackWriter.writeHeaders(headerEntries("custom-key", "custom-header"));
-    assertBytes(0xbe);
-    assertThat(hpackWriter.headerCount).isEqualTo(1);
-  }
-
-  @Test public void doNotIndexPseudoHeaders() throws IOException {
-    hpackWriter.writeHeaders(headerEntries(":method", "PUT"));
-    assertBytes(0x02, 3, 'P', 'U', 'T');
-    assertThat(hpackWriter.headerCount).isEqualTo(0);
-
-    hpackWriter.writeHeaders(headerEntries(":path", "/okhttp"));
-    assertBytes(0x04, 7, '/', 'o', 'k', 'h', 't', 't', 'p');
-    assertThat(hpackWriter.headerCount).isEqualTo(0);
-  }
-
-  @Test public void incrementalIndexingWithAuthorityPseudoHeader() throws IOException {
-    hpackWriter.writeHeaders(headerEntries(":authority", "foo.com"));
-    assertBytes(0x41, 7, 'f', 'o', 'o', '.', 'c', 'o', 'm');
-    assertThat(hpackWriter.headerCount).isEqualTo(1);
-
-    hpackWriter.writeHeaders(headerEntries(":authority", "foo.com"));
-    assertBytes(0xbe);
-    assertThat(hpackWriter.headerCount).isEqualTo(1);
-
-    // If the :authority header somehow changes, it should be re-added to the dynamic table.
-    hpackWriter.writeHeaders(headerEntries(":authority", "bar.com"));
-    assertBytes(0x41, 7, 'b', 'a', 'r', '.', 'c', 'o', 'm');
-    assertThat(hpackWriter.headerCount).isEqualTo(2);
-
-    hpackWriter.writeHeaders(headerEntries(":authority", "bar.com"));
-    assertBytes(0xbe);
-    assertThat(hpackWriter.headerCount).isEqualTo(2);
-  }
-
-  @Test public void incrementalIndexingWithStaticTableIndexedName() throws IOException {
-    hpackWriter.writeHeaders(headerEntries("accept-encoding", "gzip"));
-    assertBytes(0x50, 4, 'g', 'z', 'i', 'p');
-    assertThat(hpackWriter.headerCount).isEqualTo(1);
-
-    hpackWriter.writeHeaders(headerEntries("accept-encoding", "gzip"));
-    assertBytes(0xbe);
-    assertThat(hpackWriter.headerCount).isEqualTo(1);
-  }
-
-  @Test public void incrementalIndexingWithDynamcTableIndexedName() throws IOException {
-    hpackWriter.writeHeaders(headerEntries("foo", "bar"));
-    assertBytes(0x40, 3, 'f', 'o', 'o', 3, 'b', 'a', 'r');
-    assertThat(hpackWriter.headerCount).isEqualTo(1);
-
-    hpackWriter.writeHeaders(headerEntries("foo", "bar1"));
-    assertBytes(0x7e, 4, 'b', 'a', 'r', '1');
-    assertThat(hpackWriter.headerCount).isEqualTo(2);
-
-    hpackWriter.writeHeaders(headerEntries("foo", "bar1"));
-    assertBytes(0xbe);
-    assertThat(hpackWriter.headerCount).isEqualTo(2);
-  }
-
-  private Hpack.Reader newReader(Buffer source) {
-    return new Hpack.Reader(source, 4096);
-  }
-
-  private Buffer byteStream(int... bytes) {
-    return new Buffer().write(intArrayToByteArray(bytes));
-  }
-
-  private void checkEntry(Header entry, String name, String value, int size) {
-    assertThat(entry.name.utf8()).isEqualTo(name);
-    assertThat(entry.value.utf8()).isEqualTo(value);
-    assertThat(entry.hpackSize).isEqualTo(size);
-  }
-
-  private void assertBytes(int... bytes) throws IOException {
-    ByteString expected = intArrayToByteArray(bytes);
-    ByteString actual = bytesOut.readByteString();
-    assertThat(actual).isEqualTo(expected);
-  }
-
-  private ByteString intArrayToByteArray(int[] bytes) {
-    byte[] data = new byte[bytes.length];
-    for (int i = 0; i < bytes.length; i++) {
-      data[i] = (byte) bytes[i];
-    }
-    return ByteString.of(data);
-  }
-
-  private int readerHeaderTableLength() {
-    return hpackReader.dynamicTable.length;
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java b/okhttp/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
deleted file mode 100644
index 06daebc53f..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
+++ /dev/null
@@ -1,1935 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.net.Socket;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import okhttp3.Headers;
-import okhttp3.internal.Util;
-import okhttp3.internal.concurrent.TaskRunner;
-import okhttp3.internal.http2.MockHttp2Peer.InFrame;
-import okio.AsyncTimeout;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.Okio;
-import okio.Sink;
-import okio.Source;
-import okio.Utf8;
-import org.junit.After;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TestRule;
-import org.junit.rules.Timeout;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static java.util.Arrays.asList;
-import static okhttp3.TestUtil.headerEntries;
-import static okhttp3.TestUtil.repeat;
-import static okhttp3.internal.Util.EMPTY_BYTE_ARRAY;
-import static okhttp3.internal.Util.EMPTY_HEADERS;
-import static okhttp3.internal.http2.Http2Connection.Listener.REFUSE_INCOMING_STREAMS;
-import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-import static okhttp3.internal.http2.Settings.ENABLE_PUSH;
-import static okhttp3.internal.http2.Settings.HEADER_TABLE_SIZE;
-import static okhttp3.internal.http2.Settings.INITIAL_WINDOW_SIZE;
-import static okhttp3.internal.http2.Settings.MAX_CONCURRENT_STREAMS;
-import static okhttp3.internal.http2.Settings.MAX_FRAME_SIZE;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.data.Offset.offset;
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.fail;
-
-public final class Http2ConnectionTest {
-  private final MockHttp2Peer peer = new MockHttp2Peer();
-
-  @Rule public final TestRule timeout = new Timeout(5_000, TimeUnit.MILLISECONDS);
-
-  @After public void tearDown() throws Exception {
-    peer.close();
-  }
-
-  @Test public void serverPingsClientHttp2() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.sendFrame().ping(false, 2, 3);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    connect(peer);
-
-    // verify the peer received what was expected
-    InFrame ping = peer.takeFrame();
-    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
-    assertThat(ping.streamId).isEqualTo(0);
-    assertThat(ping.payload1).isEqualTo(2);
-    assertThat(ping.payload2).isEqualTo(3);
-    assertThat(ping.ack).isTrue();
-  }
-
-  @Test public void peerHttp2ServerLowersInitialWindowSize() throws Exception {
-    Settings initial = new Settings();
-    initial.set(INITIAL_WINDOW_SIZE, 1684);
-    Settings shouldntImpactConnection = new Settings();
-    shouldntImpactConnection.set(INITIAL_WINDOW_SIZE, 3368);
-
-    peer.sendFrame().settings(initial);
-    peer.acceptFrame(); // ACK
-    peer.sendFrame().settings(shouldntImpactConnection);
-    peer.acceptFrame(); // ACK 2
-    peer.acceptFrame(); // HEADERS
-    peer.play();
-
-    Http2Connection connection = connect(peer);
-
-    // Verify the peer received the second ACK.
-    InFrame ackFrame = peer.takeFrame();
-    assertThat(ackFrame.type).isEqualTo(Http2.TYPE_SETTINGS);
-    assertThat(ackFrame.streamId).isEqualTo(0);
-    assertThat(ackFrame.ack).isTrue();
-
-    // This stream was created *after* the connection settings were adjusted.
-    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
-
-    assertThat(connection.getPeerSettings().getInitialWindowSize()).isEqualTo(3368L);
-    // New Stream is has the most recent initial window size.
-    assertThat(stream.getWriteBytesTotal()).isEqualTo(0L);
-    assertThat(stream.getWriteBytesMaximum()).isEqualTo(3368L);
-  }
-
-  @Test public void peerHttp2ServerZerosCompressionTable() throws Exception {
-    boolean client = false; // Peer is server, so we are client.
-    Settings settings = new Settings();
-    settings.set(HEADER_TABLE_SIZE, 0);
-
-    Http2Connection connection = connectWithSettings(client, settings);
-
-    // Verify the peer's settings were read and applied.
-    assertThat(connection.getPeerSettings().getHeaderTableSize()).isEqualTo(0);
-    Http2Writer writer = connection.getWriter();
-    assertThat(writer.getHpackWriter().dynamicTableByteCount).isEqualTo(0);
-    assertThat(writer.getHpackWriter().headerTableSizeSetting).isEqualTo(0);
-  }
-
-  @Test public void peerHttp2ClientDisablesPush() throws Exception {
-    boolean client = false; // Peer is client, so we are server.
-    Settings settings = new Settings();
-    settings.set(ENABLE_PUSH, 0); // The peer client disables push.
-
-    Http2Connection connection = connectWithSettings(client, settings);
-
-    // verify the peer's settings were read and applied.
-    assertThat(connection.getPeerSettings().getEnablePush(true)).isFalse();
-  }
-
-  @Test public void peerIncreasesMaxFrameSize() throws Exception {
-    int newMaxFrameSize = 0x4001;
-    Settings settings = new Settings();
-    settings.set(MAX_FRAME_SIZE, newMaxFrameSize);
-
-    Http2Connection connection = connectWithSettings(true, settings);
-
-    // verify the peer's settings were read and applied.
-    assertThat(connection.getPeerSettings().getMaxFrameSize(-1)).isEqualTo(newMaxFrameSize);
-    assertThat(connection.getWriter().maxDataLength()).isEqualTo(newMaxFrameSize);
-  }
-
-  /**
-   * Webservers may set the initial window size to zero, which is a special case because it means
-   * that we have to flush headers immediately before any request body can be sent.
-   * https://github.com/square/okhttp/issues/2543
-   */
-  @Test public void peerSetsZeroFlowControl() throws Exception {
-    peer.setClient(true);
-
-    // Write the mocking script.
-    peer.sendFrame().settings(new Settings().set(INITIAL_WINDOW_SIZE, 0));
-    peer.acceptFrame(); // ACK
-    peer.sendFrame().windowUpdate(0, 10); // Increase the connection window size.
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // HEADERS STREAM 3
-    peer.sendFrame().windowUpdate(3, 5);
-    peer.acceptFrame(); // DATA STREAM 3 "abcde"
-    peer.sendFrame().windowUpdate(3, 5);
-    peer.acceptFrame(); // DATA STREAM 3 "fghi"
-    peer.play();
-
-    // Play it back.
-    Http2Connection connection = connect(peer);
-    connection.writePingAndAwaitPong(); // Ensure the SETTINGS have been received.
-    Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
-    BufferedSink sink = Okio.buffer(stream.getSink());
-    sink.writeUtf8("abcdefghi");
-    sink.flush();
-
-    // Verify the peer received what was expected.
-    peer.takeFrame(); // PING
-    InFrame headers = peer.takeFrame();
-    assertThat(headers.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame data1 = peer.takeFrame();
-    assertThat(data1.type).isEqualTo(Http2.TYPE_DATA);
-    assertThat(data1.streamId).isEqualTo(3);
-    assertArrayEquals("abcde".getBytes(UTF_8), data1.data);
-    InFrame data2 = peer.takeFrame();
-    assertThat(data2.type).isEqualTo(Http2.TYPE_DATA);
-    assertThat(data2.streamId).isEqualTo(3);
-    assertArrayEquals("fghi".getBytes(UTF_8), data2.data);
-  }
-
-  /**
-   * Confirm that we account for discarded data frames. It's possible that data frames are in-flight
-   * just prior to us canceling a stream.
-   */
-  @Test public void discardedDataFramesAreCounted() throws Exception {
-    // Write the mocking script.
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM 3
-    peer.sendFrame().headers(false, 3, headerEntries("a", "apple"));
-    peer.sendFrame().data(false, 3, data(1024), 1024);
-    peer.acceptFrame(); // RST_STREAM
-    peer.sendFrame().data(true, 3, data(1024), 1024);
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    Http2Connection connection = connect(peer);
-    Http2Stream stream1 = connection.newStream(headerEntries("b", "bark"), false);
-    Source source = stream1.getSource();
-    Buffer buffer = new Buffer();
-    while (buffer.size() != 1024) source.read(buffer, 1024);
-    stream1.close(ErrorCode.CANCEL, null);
-
-    InFrame frame1 = peer.takeFrame();
-    assertThat(frame1.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame frame2 = peer.takeFrame();
-    assertThat(frame2.type).isEqualTo(Http2.TYPE_RST_STREAM);
-    InFrame frame3 = peer.takeFrame();
-    assertThat(frame3.type).isEqualTo(Http2.TYPE_RST_STREAM);
-
-    assertThat(connection.getReadBytesAcknowledged()).isEqualTo(0L);
-    assertThat(connection.getReadBytesTotal()).isEqualTo(2048L);
-  }
-
-  @Test public void receiveGoAwayHttp2() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM 3
-    peer.acceptFrame(); // SYN_STREAM 5
-    peer.sendFrame().goAway(3, ErrorCode.PROTOCOL_ERROR, EMPTY_BYTE_ARRAY);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // DATA STREAM 3
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream1 = connection.newStream(headerEntries("a", "android"), true);
-    Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
-    connection.writePingAndAwaitPong(); // Ensure the GO_AWAY that resets stream2 has been received.
-    BufferedSink sink1 = Okio.buffer(stream1.getSink());
-    BufferedSink sink2 = Okio.buffer(stream2.getSink());
-    sink1.writeUtf8("abc");
-    try {
-      sink2.writeUtf8("abc");
-      sink2.flush();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("stream was reset: REFUSED_STREAM");
-    }
-    sink1.writeUtf8("def");
-    sink1.close();
-    try {
-      connection.newStream(headerEntries("c", "cola"), true);
-      fail();
-    } catch (ConnectionShutdownException expected) {
-    }
-    assertThat(stream1.isOpen()).isTrue();
-    assertThat(stream2.isOpen()).isFalse();
-    assertThat(connection.openStreamCount()).isEqualTo(1);
-
-    // verify the peer received what was expected
-    InFrame synStream1 = peer.takeFrame();
-    assertThat(synStream1.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame synStream2 = peer.takeFrame();
-    assertThat(synStream2.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame ping = peer.takeFrame();
-    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
-    InFrame data1 = peer.takeFrame();
-    assertThat(data1.type).isEqualTo(Http2.TYPE_DATA);
-    assertThat(data1.streamId).isEqualTo(3);
-    assertArrayEquals("abcdef".getBytes(UTF_8), data1.data);
-  }
-
-  @Test public void readSendsWindowUpdateHttp2() throws Exception {
-    int windowSize = 100;
-    int windowUpdateThreshold = 50;
-
-    // Write the mocking script.
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    for (int i = 0; i < 3; i++) {
-      // Send frames of summing to size 50, which is windowUpdateThreshold.
-      peer.sendFrame().data(false, 3, data(24), 24);
-      peer.sendFrame().data(false, 3, data(25), 25);
-      peer.sendFrame().data(false, 3, data(1), 1);
-      peer.acceptFrame(); // connection WINDOW UPDATE
-      peer.acceptFrame(); // stream WINDOW UPDATE
-    }
-    peer.sendFrame().data(true, 3, data(0), 0);
-    peer.play();
-
-    // Play it back.
-    Http2Connection connection = connect(peer);
-    connection.getOkHttpSettings().set(INITIAL_WINDOW_SIZE, windowSize);
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertThat(stream.getReadBytesAcknowledged()).isEqualTo(0L);
-    assertThat(stream.getReadBytesTotal()).isEqualTo(0L);
-    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
-    Source in = stream.getSource();
-    Buffer buffer = new Buffer();
-    buffer.writeAll(in);
-    assertThat(in.read(buffer, 1)).isEqualTo(-1);
-    assertThat(buffer.size()).isEqualTo(150);
-
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    for (int i = 0; i < 3; i++) {
-      List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
-      for (int j = 0; j < 2; j++) {
-        InFrame windowUpdate = peer.takeFrame();
-        assertThat(windowUpdate.type).isEqualTo(Http2.TYPE_WINDOW_UPDATE);
-        windowUpdateStreamIds.add(windowUpdate.streamId);
-        assertThat(windowUpdate.windowSizeIncrement).isEqualTo(windowUpdateThreshold);
-      }
-      // connection
-      assertThat(windowUpdateStreamIds).contains(0);
-      // stream
-      assertThat(windowUpdateStreamIds).contains(3);
-    }
-  }
-
-  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdateHttp2() throws Exception {
-    // Write the mocking script.
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 3, data(0), 0);
-    peer.play();
-
-    // Play it back.
-    Http2Connection connection = connect(peer);
-    Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
-    assertThat(client.getSource().read(new Buffer(), 1)).isEqualTo(-1);
-
-    // Verify the peer received what was expected.
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(peer.frameCount()).isEqualTo(5);
-  }
-
-  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdateHttp2() throws Exception {
-    // Write the mocking script.
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // DATA
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.play();
-
-    // Play it back.
-    Http2Connection connection = connect(peer);
-    Http2Stream client = connection.newStream(headerEntries("b", "banana"), true);
-    BufferedSink out = Okio.buffer(client.getSink());
-    out.write(EMPTY_BYTE_ARRAY);
-    out.flush();
-    out.close();
-
-    // Verify the peer received what was expected.
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_DATA);
-    assertThat(peer.frameCount()).isEqualTo(5);
-  }
-
-  @Test public void maxFrameSizeHonored() throws Exception {
-    byte[] buff = new byte[peer.maxOutboundDataLength() + 1];
-    Arrays.fill(buff, (byte) '*');
-
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.acceptFrame(); // DATA
-    peer.acceptFrame(); // DATA
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    out.write(buff);
-    out.flush();
-    out.close();
-
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame data = peer.takeFrame();
-    assertThat(data.data.length).isEqualTo(peer.maxOutboundDataLength());
-    data = peer.takeFrame();
-    assertThat(data.data.length).isEqualTo(1);
-  }
-
-  @Test public void pushPromiseStream() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    final List<Header> expectedRequestHeaders = asList(
-        new Header(Header.TARGET_METHOD, "GET"),
-        new Header(Header.TARGET_SCHEME, "https"),
-        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
-        new Header(Header.TARGET_PATH, "/cached")
-    );
-    peer.sendFrame().pushPromise(3, 2, expectedRequestHeaders);
-    final List<Header> expectedResponseHeaders = asList(
-        new Header(Header.RESPONSE_STATUS, "200")
-    );
-    peer.sendFrame().headers(true, 2, expectedResponseHeaders);
-    peer.sendFrame().data(true, 3, data(0), 0);
-    peer.play();
-
-    RecordingPushObserver observer = new RecordingPushObserver();
-
-    // play it back
-    Http2Connection connection = connect(peer, observer, REFUSE_INCOMING_STREAMS);
-    Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
-    assertThat(client.getSource().read(new Buffer(), 1)).isEqualTo(-1);
-
-    // verify the peer received what was expected
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
-
-    assertThat(observer.takeEvent()).isEqualTo(expectedRequestHeaders);
-    assertThat(observer.takeEvent()).isEqualTo(expectedResponseHeaders);
-  }
-
-  @Test public void doublePushPromise() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.sendFrame().pushPromise(3, 2, headerEntries("a", "android"));
-    peer.acceptFrame(); // SYN_REPLY
-    peer.sendFrame().pushPromise(3, 2, headerEntries("b", "banana"));
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    connection.newStream(headerEntries("b", "banana"), false);
-
-    // verify the peer received what was expected
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(peer.takeFrame().errorCode).isEqualTo(ErrorCode.PROTOCOL_ERROR);
-  }
-
-  @Test public void pushPromiseStreamsAutomaticallyCancel() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.sendFrame().pushPromise(3, 2, asList(
-        new Header(Header.TARGET_METHOD, "GET"),
-        new Header(Header.TARGET_SCHEME, "https"),
-        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
-        new Header(Header.TARGET_PATH, "/cached")
-    ));
-    peer.sendFrame().headers(true, 2, asList(
-        new Header(Header.RESPONSE_STATUS, "200")
-    ));
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    connect(peer, PushObserver.CANCEL, REFUSE_INCOMING_STREAMS);
-
-    // verify the peer received what was expected
-    InFrame rstStream = peer.takeFrame();
-    assertThat(rstStream.type).isEqualTo(Http2.TYPE_RST_STREAM);
-    assertThat(rstStream.streamId).isEqualTo(2);
-    assertThat(rstStream.errorCode).isEqualTo(ErrorCode.CANCEL);
-  }
-
-  /**
-   * When writing a set of headers fails due to an {@code IOException}, make sure the writer is left
-   * in a consistent state so the next writer also gets an {@code IOException} also instead of
-   * something worse (like an {@link IllegalStateException}.
-   *
-   * <p>See https://github.com/square/okhttp/issues/1651
-   */
-  @Test public void socketExceptionWhileWritingHeaders() throws Exception {
-    peer.acceptFrame(); // SYN_STREAM.
-    peer.play();
-
-    String longString = repeat('a', Http2.INITIAL_MAX_FRAME_SIZE + 1);
-    Socket socket = peer.openSocket();
-    Http2Connection connection = new Http2Connection.Builder(true, TaskRunner.INSTANCE)
-        .socket(socket)
-        .pushObserver(IGNORE)
-        .build();
-    connection.start(false);
-    socket.shutdownOutput();
-    try {
-      connection.newStream(headerEntries("a", longString), false);
-      fail();
-    } catch (IOException expected) {
-    }
-    try {
-      connection.newStream(headerEntries("b", longString), false);
-      fail();
-    } catch (IOException expected) {
-    }
-  }
-
-  @Test public void clientCreatesStreamAndServerReplies() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // DATA
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("robot"), 5);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0); // PING
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    out.writeUtf8("c3po");
-    out.close();
-    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
-    assertStreamData("robot", stream.getSource());
-    connection.writePingAndAwaitPong();
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(synStream.outFinished).isFalse();
-    assertThat(synStream.streamId).isEqualTo(3);
-    assertThat(synStream.associatedStreamId).isEqualTo(-1);
-    assertThat(synStream.headerBlock).isEqualTo(headerEntries("b", "banana"));
-    InFrame requestData = peer.takeFrame();
-    assertArrayEquals("c3po".getBytes(UTF_8), requestData.data);
-  }
-
-  @Test public void serverFinishesStreamWithHeaders() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // PING
-    peer.sendFrame().headers(true, 3, headerEntries("headers", "bam"));
-    peer.sendFrame().ping(true, 1, 0); // PONG
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("a", "artichaut"), false);
-    connection.writePingAndAwaitPong();
-    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("headers", "bam"));
-    assertThat(stream.trailers()).isEqualTo(EMPTY_HEADERS);
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(synStream.outFinished).isFalse();
-    assertThat(synStream.streamId).isEqualTo(3);
-    assertThat(synStream.associatedStreamId).isEqualTo(-1);
-    assertThat(synStream.headerBlock).isEqualTo(headerEntries("a", "artichaut"));
-  }
-
-  @Test public void serverWritesTrailersAndClientReadsTrailers() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("headers", "bam"));
-    peer.acceptFrame(); // PING
-    peer.sendFrame().headers(true, 3, headerEntries("trailers", "boom"));
-    peer.sendFrame().ping(true, 1, 0); // PONG
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("a", "artichaut"), false);
-    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("headers", "bam"));
-    connection.writePingAndAwaitPong();
-    assertThat(stream.trailers()).isEqualTo(Headers.of("trailers", "boom"));
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(synStream.outFinished).isFalse();
-    assertThat(synStream.streamId).isEqualTo(3);
-    assertThat(synStream.associatedStreamId).isEqualTo(-1);
-    assertThat(synStream.headerBlock).isEqualTo(headerEntries("a", "artichaut"));
-  }
-
-  @Test public void serverWritesTrailersWithData() throws Exception {
-    // We buffer some outbound data and headers and confirm that the END_STREAM flag comes with the
-    // headers (and not with the data).
-
-    // write the mocking script for the client
-    peer.setClient(true);
-
-    // Write the mocking script.
-    peer.sendFrame().settings(new Settings());
-    peer.sendFrame().headers(true, 3, headerEntries("client", "abc"));
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // HEADERS STREAM 3
-    peer.acceptFrame(); // DATA STREAM 3 "abcde"
-    peer.acceptFrame(); // HEADERS STREAM 3
-    peer.play();
-
-    // Play it back.
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
-    stream.enqueueTrailers(Headers.of("foo", "bar"));
-    BufferedSink sink = Okio.buffer(stream.getSink());
-    sink.writeUtf8("abcdefghi");
-    sink.close();
-
-    // Verify the peer received what was expected.
-    InFrame headers1 = peer.takeFrame();
-    assertThat(headers1.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame data1 = peer.takeFrame();
-    assertThat(data1.type).isEqualTo(Http2.TYPE_DATA);
-    assertThat(data1.streamId).isEqualTo(3);
-    assertArrayEquals("abcdefghi".getBytes(UTF_8), data1.data);
-    assertThat(data1.inFinished).isFalse();
-    InFrame headers2 = peer.takeFrame();
-    assertThat(headers2.type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(headers2.inFinished).isTrue();
-  }
-
-  @Test public void clientCannotReadTrailersWithoutExhaustingStream() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().data(false, 3, new Buffer().writeUtf8("robot"), 5);
-    peer.sendFrame().headers(true, 3, headerEntries("trailers", "boom"));
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0); // PONG
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("a", "artichaut"), true);
-    connection.writePingAndAwaitPong();
-    try {
-      stream.trailers();
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void clientCannotReadTrailersIfTheStreamFailed() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().rstStream(3, ErrorCode.PROTOCOL_ERROR);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0); // PONG
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("a", "artichaut"), true);
-    connection.writePingAndAwaitPong();
-    try {
-      stream.trailers();
-      fail();
-    } catch (StreamResetException expected) {
-    }
-  }
-
-  @Test public void serverCannotEnqueueTrailersAfterFinishingTheStream() throws Exception {
-    peer.setClient(true);
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // Play it back.
-    Http2Connection connection = connect(peer);
-    connection.writePingAndAwaitPong();
-    Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
-    // finish the stream
-    stream.writeHeaders(headerEntries("b", "berserk"), true, false);
-    try {
-      stream.enqueueTrailers(Headers.of("trailers", "boom"));
-      fail();
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test public void noTrailersFrameYieldsEmptyTrailers() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("headers", "bam"));
-    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("robot"), 5);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0); // PONG
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("a", "artichaut"), false);
-    BufferedSource source = Okio.buffer(stream.getSource());
-    connection.writePingAndAwaitPong();
-    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("headers", "bam"));
-    assertThat(source.readUtf8(5)).isEqualTo("robot");
-    assertThat(stream.trailers()).isEqualTo(EMPTY_HEADERS);
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(synStream.outFinished).isFalse();
-    assertThat(synStream.streamId).isEqualTo(3);
-    assertThat(synStream.associatedStreamId).isEqualTo(-1);
-    assertThat(synStream.headerBlock).isEqualTo(headerEntries("a", "artichaut"));
-  }
-
-  @Test public void serverReadsHeadersDataHeaders() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // DATA
-    peer.acceptFrame(); // HEADERS
-    peer.sendFrame().headers(true, 3, headerEntries("a", "android"));
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0); // PING
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    out.writeUtf8("c3po");
-    out.close();
-    stream.writeHeaders(headerEntries("e", "elephant"), false, false);
-    connection.writePingAndAwaitPong();
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(synStream.outFinished).isFalse();
-    assertThat(synStream.streamId).isEqualTo(3);
-    assertThat(synStream.associatedStreamId).isEqualTo(-1);
-    assertThat(synStream.headerBlock).isEqualTo(headerEntries("b", "banana"));
-    InFrame requestData = peer.takeFrame();
-    assertArrayEquals("c3po".getBytes(UTF_8), requestData.data);
-
-    InFrame nextFrame = peer.takeFrame();
-    assertThat(nextFrame.headerBlock).isEqualTo(headerEntries("e", "elephant"));
-  }
-
-  @Test public void clientCreatesStreamAndServerRepliesWithFin() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // PING
-    peer.sendFrame().headers(true, 3, headerEntries("a", "android"));
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    connection.newStream(headerEntries("b", "banana"), false);
-    assertThat(connection.openStreamCount()).isEqualTo(1);
-    connection.writePingAndAwaitPong(); // Ensure that the SYN_REPLY has been received.
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame ping = peer.takeFrame();
-    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
-  }
-
-  @Test public void serverPingsClient() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    connect(peer);
-
-    // verify the peer received what was expected
-    InFrame ping = peer.takeFrame();
-    assertThat(ping.streamId).isEqualTo(0);
-    assertThat(ping.payload1).isEqualTo(2);
-    assertThat(ping.payload2).isEqualTo(0);
-    assertThat(ping.ack).isTrue();
-  }
-
-  @Test public void clientPingsServer() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 5);
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    long pingAtNanos = System.nanoTime();
-    connection.writePingAndAwaitPong();
-    long elapsedNanos = System.nanoTime() - pingAtNanos;
-    assertThat(elapsedNanos).isGreaterThan(0L);
-    assertThat(elapsedNanos).isLessThan(TimeUnit.SECONDS.toNanos(1));
-
-    // verify the peer received what was expected
-    InFrame pingFrame = peer.takeFrame();
-    assertThat(pingFrame.type).isEqualTo(Http2.TYPE_PING);
-    assertThat(pingFrame.streamId).isEqualTo(0);
-    // OkOk
-    assertThat(pingFrame.payload1).isEqualTo(0x4f4b6f6b);
-    // donut
-    assertThat(pingFrame.payload2).isEqualTo(0xf09f8da9);
-    assertThat(pingFrame.ack).isFalse();
-  }
-
-  @Test public void unexpectedPingIsNotReturned() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 3, 0); // This ping will not be returned.
-    peer.sendFrame().ping(false, 4, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    connect(peer);
-
-    // verify the peer received what was expected
-    InFrame ping2 = peer.takeFrame();
-    assertThat(ping2.payload1).isEqualTo(2);
-    InFrame ping4 = peer.takeFrame();
-    assertThat(ping4.payload1).isEqualTo(4);
-  }
-
-  @Test public void serverSendsSettingsToClient() throws Exception {
-    // write the mocking script
-    final Settings settings = new Settings();
-    settings.set(MAX_CONCURRENT_STREAMS, 10);
-    peer.sendFrame().settings(settings);
-    peer.acceptFrame(); // ACK
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    final CountDownLatch maxConcurrentStreamsUpdated = new CountDownLatch(1);
-    final AtomicInteger maxConcurrentStreams = new AtomicInteger();
-    Http2Connection.Listener listener = new Http2Connection.Listener() {
-      @Override public void onStream(Http2Stream stream) throws IOException {
-        throw new AssertionError();
-      }
-
-      @Override public void onSettings(Http2Connection connection, Settings settings) {
-        maxConcurrentStreams.set(settings.getMaxConcurrentStreams());
-        maxConcurrentStreamsUpdated.countDown();
-      }
-    };
-    Http2Connection connection = connect(peer, IGNORE, listener);
-
-    synchronized (connection) {
-      assertThat(connection.getPeerSettings().getMaxConcurrentStreams()).isEqualTo(10);
-    }
-    maxConcurrentStreamsUpdated.await();
-    assertThat(maxConcurrentStreams.get()).isEqualTo(10);
-  }
-
-  @Test public void multipleSettingsFramesAreMerged() throws Exception {
-    // write the mocking script
-    Settings settings1 = new Settings();
-    settings1.set(HEADER_TABLE_SIZE, 10000);
-    settings1.set(INITIAL_WINDOW_SIZE, 20000);
-    settings1.set(MAX_FRAME_SIZE, 30000);
-    peer.sendFrame().settings(settings1);
-    peer.acceptFrame(); // ACK SETTINGS
-    Settings settings2 = new Settings();
-    settings2.set(INITIAL_WINDOW_SIZE, 40000);
-    settings2.set(MAX_FRAME_SIZE, 50000);
-    settings2.set(MAX_CONCURRENT_STREAMS, 60000);
-    peer.sendFrame().settings(settings2);
-    peer.acceptFrame(); // ACK SETTINGS
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_SETTINGS);
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_PING);
-    synchronized (connection) {
-      assertThat(connection.getPeerSettings().getHeaderTableSize()).isEqualTo(10000);
-      assertThat(connection.getPeerSettings().getInitialWindowSize()).isEqualTo(40000);
-      assertThat(connection.getPeerSettings().getMaxFrameSize(-1)).isEqualTo(50000);
-      assertThat(connection.getPeerSettings().getMaxConcurrentStreams()).isEqualTo(60000);
-    }
-  }
-
-  @Test public void clearSettingsBeforeMerge() throws Exception {
-    // write the mocking script
-    Settings settings1 = new Settings();
-    settings1.set(HEADER_TABLE_SIZE, 10000);
-    settings1.set(INITIAL_WINDOW_SIZE, 20000);
-    settings1.set(MAX_FRAME_SIZE, 30000);
-    peer.sendFrame().settings(settings1);
-    peer.acceptFrame(); // ACK
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame();
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-
-    // fake a settings frame with clear flag set.
-    Settings settings2 = new Settings();
-    settings2.set(MAX_CONCURRENT_STREAMS, 60000);
-    connection.getReaderRunnable().applyAndAckSettings(true, settings2);
-
-    synchronized (connection) {
-      assertThat(connection.getPeerSettings().getHeaderTableSize()).isEqualTo(-1);
-      assertThat(connection.getPeerSettings().getInitialWindowSize()).isEqualTo(
-          (long) DEFAULT_INITIAL_WINDOW_SIZE);
-      assertThat(connection.getPeerSettings().getMaxFrameSize(-1)).isEqualTo(-1);
-      assertThat(connection.getPeerSettings().getMaxConcurrentStreams()).isEqualTo(60000);
-    }
-  }
-
-  @Test public void bogusDataFrameDoesNotDisruptConnection() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.sendFrame().data(true, 41, new Buffer().writeUtf8("bogus"), 5);
-    peer.acceptFrame(); // RST_STREAM
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    connect(peer);
-
-    // verify the peer received what was expected
-    InFrame rstStream = peer.takeFrame();
-    assertThat(rstStream.type).isEqualTo(Http2.TYPE_RST_STREAM);
-    assertThat(rstStream.streamId).isEqualTo(41);
-    assertThat(rstStream.errorCode).isEqualTo(ErrorCode.PROTOCOL_ERROR);
-    InFrame ping = peer.takeFrame();
-    assertThat(ping.payload1).isEqualTo(2);
-  }
-
-  @Test public void bogusReplySilentlyIgnored() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.sendFrame().headers(false, 41, headerEntries("a", "android"));
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    connect(peer);
-
-    // verify the peer received what was expected
-    InFrame ping = peer.takeFrame();
-    assertThat(ping.payload1).isEqualTo(2);
-  }
-
-  @Test public void serverClosesClientOutputStream() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().rstStream(3, ErrorCode.CANCEL);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    connection.writePingAndAwaitPong(); // Ensure that the RST_CANCEL has been received.
-    try {
-      out.writeUtf8("square");
-      out.flush();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("stream was reset: CANCEL");
-    }
-    try {
-      out.close();
-      fail();
-    } catch (IOException expected) {
-      // Close throws because buffered data wasn't flushed.
-    }
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(synStream.inFinished).isFalse();
-    assertThat(synStream.outFinished).isFalse();
-    InFrame ping = peer.takeFrame();
-    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
-  }
-
-  /**
-   * Test that the client sends a RST_STREAM if doing so won't disrupt the output stream.
-   */
-  @Test public void clientClosesClientInputStream() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
-    Source in = stream.getSource();
-    BufferedSink out = Okio.buffer(stream.getSink());
-    in.close();
-    try {
-      in.read(new Buffer(), 1);
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("stream closed");
-    }
-    try {
-      out.writeUtf8("a");
-      out.flush();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("stream finished");
-    }
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(synStream.inFinished).isTrue();
-    assertThat(synStream.outFinished).isFalse();
-    InFrame rstStream = peer.takeFrame();
-    assertThat(rstStream.type).isEqualTo(Http2.TYPE_RST_STREAM);
-    assertThat(rstStream.errorCode).isEqualTo(ErrorCode.CANCEL);
-  }
-
-  /**
-   * Test that the client doesn't send a RST_STREAM if doing so will disrupt the output stream.
-   */
-  @Test public void clientClosesClientInputStreamIfOutputStreamIsClosed() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // DATA
-    peer.acceptFrame(); // DATA with FLAG_FIN
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
-    Source source = stream.getSource();
-    BufferedSink out = Okio.buffer(stream.getSink());
-    source.close();
-    try {
-      source.read(new Buffer(), 1);
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("stream closed");
-    }
-    out.writeUtf8("square");
-    out.flush();
-    out.close();
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(synStream.inFinished).isFalse();
-    assertThat(synStream.outFinished).isFalse();
-    InFrame data = peer.takeFrame();
-    assertThat(data.type).isEqualTo(Http2.TYPE_DATA);
-    assertArrayEquals("square".getBytes(UTF_8), data.data);
-    InFrame fin = peer.takeFrame();
-    assertThat(fin.type).isEqualTo(Http2.TYPE_DATA);
-    assertThat(fin.inFinished).isTrue();
-    assertThat(fin.outFinished).isFalse();
-    InFrame rstStream = peer.takeFrame();
-    assertThat(rstStream.type).isEqualTo(Http2.TYPE_RST_STREAM);
-    assertThat(rstStream.errorCode).isEqualTo(ErrorCode.CANCEL);
-  }
-
-  @Test public void serverClosesClientInputStream() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("b", "banana"));
-    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("square"), 6);
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
-    Source source = stream.getSource();
-    assertStreamData("square", source);
-    connection.writePingAndAwaitPong(); // Ensure that inFinished has been received.
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(synStream.inFinished).isTrue();
-    assertThat(synStream.outFinished).isFalse();
-  }
-
-  @Test public void remoteDoubleSynReply() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.acceptFrame(); // PING
-    peer.sendFrame().headers(false, 3, headerEntries("b", "banana"));
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("c", "cola"), false);
-    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
-    connection.writePingAndAwaitPong(); // Ensure that the 2nd SYN REPLY has been received.
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame ping = peer.takeFrame();
-    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
-  }
-
-  @Test public void remoteSendsDataAfterInFinished() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("robot"), 5);
-    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("c3po"), 4);
-    peer.acceptFrame(); // RST_STREAM
-    peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
-    assertStreamData("robot", stream.getSource());
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame rstStream = peer.takeFrame();
-    assertThat(rstStream.type).isEqualTo(Http2.TYPE_RST_STREAM);
-    assertThat(rstStream.streamId).isEqualTo(3);
-    InFrame ping = peer.takeFrame();
-    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
-    assertThat(ping.payload1).isEqualTo(2);
-  }
-
-  @Test public void clientDoesNotLimitFlowControl() throws Exception {
-    int dataLength = 16384;
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("b", "banana"));
-    peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
-    peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
-    peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
-    peer.sendFrame().data(false, 3, new Buffer().write(new byte[dataLength]), dataLength);
-    peer.sendFrame().data(false, 3, new Buffer().write(new byte[1]), 1);
-    peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
-    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("b", "banana"));
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame ping = peer.takeFrame();
-    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
-    assertThat(ping.payload1).isEqualTo(2);
-  }
-
-  @Test public void remoteSendsRefusedStreamBeforeReplyHeaders() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().rstStream(3, ErrorCode.REFUSED_STREAM);
-    peer.sendFrame().ping(false, 2, 0);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
-    try {
-      stream.takeHeaders();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("stream was reset: REFUSED_STREAM");
-    }
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame ping = peer.takeFrame();
-    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
-    assertThat(ping.payload1).isEqualTo(2);
-  }
-
-  @Test public void receiveGoAway() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM 1
-    peer.acceptFrame(); // SYN_STREAM 3
-    peer.acceptFrame(); // PING.
-    peer.sendFrame().goAway(3, ErrorCode.PROTOCOL_ERROR, Util.EMPTY_BYTE_ARRAY);
-    peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // DATA STREAM 1
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream1 = connection.newStream(headerEntries("a", "android"), true);
-    Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
-    connection.writePingAndAwaitPong(); // Ensure the GO_AWAY that resets stream2 has been received.
-    BufferedSink sink1 = Okio.buffer(stream1.getSink());
-    BufferedSink sink2 = Okio.buffer(stream2.getSink());
-    sink1.writeUtf8("abc");
-    try {
-      sink2.writeUtf8("abc");
-      sink2.flush();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("stream was reset: REFUSED_STREAM");
-    }
-    sink1.writeUtf8("def");
-    sink1.close();
-    try {
-      connection.newStream(headerEntries("c", "cola"), false);
-      fail();
-    } catch (ConnectionShutdownException expected) {
-    }
-    assertThat(stream1.isOpen()).isTrue();
-    assertThat(stream2.isOpen()).isFalse();
-    assertThat(connection.openStreamCount()).isEqualTo(1);
-
-    // verify the peer received what was expected
-    InFrame synStream1 = peer.takeFrame();
-    assertThat(synStream1.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame synStream2 = peer.takeFrame();
-    assertThat(synStream2.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame ping = peer.takeFrame();
-    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
-    InFrame data1 = peer.takeFrame();
-    assertThat(data1.type).isEqualTo(Http2.TYPE_DATA);
-    assertThat(data1.streamId).isEqualTo(3);
-    assertArrayEquals("abcdef".getBytes(UTF_8), data1.data);
-  }
-
-  @Test public void sendGoAway() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM 1
-    peer.acceptFrame(); // GOAWAY
-    peer.acceptFrame(); // PING
-    peer.sendFrame().headers(false, 2, headerEntries("b", "b")); // Should be ignored!
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    connection.newStream(headerEntries("a", "android"), false);
-    synchronized (connection) {
-      if (connection.isShutdown()) {
-        throw new ConnectionShutdownException();
-      }
-    }
-    connection.writePing(false, 0x01, 0x02);
-    connection.shutdown(ErrorCode.PROTOCOL_ERROR);
-    assertThat(connection.openStreamCount()).isEqualTo(1);
-    connection.awaitPong(); // Prevent the peer from exiting prematurely.
-
-    // verify the peer received what was expected
-    InFrame synStream1 = peer.takeFrame();
-    assertThat(synStream1.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame pingFrame = peer.takeFrame();
-    assertThat(pingFrame.type).isEqualTo(Http2.TYPE_PING);
-    InFrame goaway = peer.takeFrame();
-    assertThat(goaway.type).isEqualTo(Http2.TYPE_GOAWAY);
-    assertThat(goaway.streamId).isEqualTo(0);
-    assertThat(goaway.errorCode).isEqualTo(ErrorCode.PROTOCOL_ERROR);
-  }
-
-  @Test public void close() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // GOAWAY
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
-    assertThat(connection.openStreamCount()).isEqualTo(1);
-    connection.close();
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-    try {
-      connection.newStream(headerEntries("b", "banana"), false);
-      fail();
-    } catch (ConnectionShutdownException expected) {
-    }
-    BufferedSink sink = Okio.buffer(stream.getSink());
-    try {
-      sink.writeByte(0);
-      sink.flush();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("stream finished");
-    }
-    try {
-      stream.getSource().read(new Buffer(), 1);
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("stream was reset: CANCEL");
-    }
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame goaway = peer.takeFrame();
-    assertThat(goaway.type).isEqualTo(Http2.TYPE_GOAWAY);
-    InFrame rstStream = peer.takeFrame();
-    assertThat(rstStream.type).isEqualTo(Http2.TYPE_RST_STREAM);
-    assertThat(rstStream.streamId).isEqualTo(3);
-  }
-
-  @Test public void getResponseHeadersTimesOut() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
-    long startNanos = System.nanoTime();
-    try {
-      stream.takeHeaders();
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
-    long elapsedNanos = System.nanoTime() - startNanos;
-    awaitWatchdogIdle();
-    /* 200ms delta */
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedNanos)).isCloseTo(500d, offset(200d));
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_RST_STREAM);
-  }
-
-  @Test public void readTimesOut() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
-    Source source = stream.getSource();
-    long startNanos = System.nanoTime();
-    try {
-      source.read(new Buffer(), 1);
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
-    long elapsedNanos = System.nanoTime() - startNanos;
-    awaitWatchdogIdle();
-    /* 200ms delta */
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedNanos)).isCloseTo(500d, offset(200d));
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_RST_STREAM);
-  }
-
-  @Test public void writeTimesOutAwaitingStreamWindow() throws Exception {
-    // Set the peer's receive window to 5 bytes!
-    Settings peerSettings = new Settings().set(INITIAL_WINDOW_SIZE, 5);
-
-    // write the mocking script
-    peer.sendFrame().settings(peerSettings);
-    peer.acceptFrame(); // ACK SETTINGS
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.acceptFrame(); // DATA
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    connection.writePingAndAwaitPong(); // Make sure settings have been received.
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
-    Sink sink = stream.getSink();
-    sink.write(new Buffer().writeUtf8("abcde"), 5);
-    stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
-    long startNanos = System.nanoTime();
-    sink.write(new Buffer().writeUtf8("f"), 1);
-    try {
-      sink.flush(); // This will time out waiting on the write window.
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
-    long elapsedNanos = System.nanoTime() - startNanos;
-    awaitWatchdogIdle();
-    /* 200ms delta */
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedNanos)).isCloseTo(500d, offset(200d));
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_PING);
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_DATA);
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_RST_STREAM);
-  }
-
-  @Test public void writeTimesOutAwaitingConnectionWindow() throws Exception {
-    // Set the peer's receive window to 5 bytes. Give the stream 5 bytes back, so only the
-    // connection-level window is applicable.
-    Settings peerSettings = new Settings().set(INITIAL_WINDOW_SIZE, 5);
-
-    // write the mocking script
-    peer.sendFrame().settings(peerSettings);
-    peer.acceptFrame(); // ACK SETTINGS
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 3, 0);
-    peer.acceptFrame(); // DATA
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    connection.writePingAndAwaitPong(); // Make sure settings have been acked.
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
-    connection.writePingAndAwaitPong(); // Make sure the window update has been received.
-    Sink sink = stream.getSink();
-    stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
-    sink.write(new Buffer().writeUtf8("abcdef"), 6);
-    long startNanos = System.nanoTime();
-    try {
-      sink.flush(); // This will time out waiting on the write window.
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
-    long elapsedNanos = System.nanoTime() - startNanos;
-    awaitWatchdogIdle();
-    /* 200ms delta */
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedNanos)).isCloseTo(500d, offset(200d));
-    assertThat(connection.openStreamCount()).isEqualTo(0);
-
-    // verify the peer received what was expected
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_PING);
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_PING);
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_DATA);
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_RST_STREAM);
-  }
-
-  @Test public void outgoingWritesAreBatched() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.acceptFrame(); // DATA
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
-
-    // two outgoing writes
-    Sink sink = stream.getSink();
-    sink.write(new Buffer().writeUtf8("abcde"), 5);
-    sink.write(new Buffer().writeUtf8("fghij"), 5);
-    sink.close();
-
-    // verify the peer received one incoming frame
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame data = peer.takeFrame();
-    assertThat(data.type).isEqualTo(Http2.TYPE_DATA);
-    assertArrayEquals("abcdefghij".getBytes(UTF_8), data.data);
-    assertThat(data.inFinished).isTrue();
-  }
-
-  @Test public void headers() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // PING
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.sendFrame().headers(false, 3, headerEntries("c", "c3po"));
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
-    connection.writePingAndAwaitPong(); // Ensure that the HEADERS has been received.
-    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
-    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("c", "c3po"));
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame ping = peer.takeFrame();
-    assertThat(ping.type).isEqualTo(Http2.TYPE_PING);
-  }
-
-  @Test public void readMultipleSetsOfResponseHeaders() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.acceptFrame(); // PING
-    peer.sendFrame().headers(true, 3, headerEntries("c", "cola"));
-    peer.sendFrame().ping(true, 1, 0); // PONG
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
-    stream.getConnection().flush();
-    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
-    connection.writePingAndAwaitPong();
-    assertThat(stream.trailers()).isEqualTo(Headers.of("c", "cola"));
-
-    // verify the peer received what was expected
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_PING);
-  }
-
-  @Test public void readSendsWindowUpdate() throws Exception {
-    int windowSize = 100;
-    int windowUpdateThreshold = 50;
-
-    // Write the mocking script.
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    for (int i = 0; i < 3; i++) {
-      // Send frames of summing to size 50, which is windowUpdateThreshold.
-      peer.sendFrame().data(false, 3, data(24), 24);
-      peer.sendFrame().data(false, 3, data(25), 25);
-      peer.sendFrame().data(false, 3, data(1), 1);
-      peer.acceptFrame(); // connection WINDOW UPDATE
-      peer.acceptFrame(); // stream WINDOW UPDATE
-    }
-    peer.sendFrame().data(true, 3, data(0), 0);
-    peer.play();
-
-    // Play it back.
-    Http2Connection connection = connect(peer);
-    connection.getOkHttpSettings().set(INITIAL_WINDOW_SIZE, windowSize);
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertThat(stream.getReadBytesAcknowledged()).isEqualTo(0L);
-    assertThat(stream.getReadBytesTotal()).isEqualTo(0L);
-    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
-    Source in = stream.getSource();
-    Buffer buffer = new Buffer();
-    buffer.writeAll(in);
-    assertThat(in.read(buffer, 1)).isEqualTo(-1);
-    assertThat(buffer.size()).isEqualTo(150);
-
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    for (int i = 0; i < 3; i++) {
-      List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
-      for (int j = 0; j < 2; j++) {
-        InFrame windowUpdate = peer.takeFrame();
-        assertThat(windowUpdate.type).isEqualTo(Http2.TYPE_WINDOW_UPDATE);
-        windowUpdateStreamIds.add(windowUpdate.streamId);
-        assertThat(windowUpdate.windowSizeIncrement).isEqualTo(windowUpdateThreshold);
-      }
-      // connection
-      assertThat(windowUpdateStreamIds).contains(0);
-      // stream
-      assertThat(windowUpdateStreamIds).contains(3);
-    }
-  }
-
-  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdate() throws Exception {
-    // Write the mocking script.
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 3, data(0), 0);
-    peer.play();
-
-    // Play it back.
-    Http2Connection connection = connect(peer);
-    Http2Stream client = connection.newStream(headerEntries("b", "banana"), false);
-    assertThat(client.getSource().read(new Buffer(), 1)).isEqualTo(-1);
-
-    // Verify the peer received what was expected.
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(peer.frameCount()).isEqualTo(5);
-  }
-
-  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdate() throws Exception {
-    // Write the mocking script.
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.acceptFrame(); // DATA
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.play();
-
-    // Play it back.
-    Http2Connection connection = connect(peer);
-    Http2Stream client = connection.newStream(headerEntries("b", "banana"), true);
-    BufferedSink out = Okio.buffer(client.getSink());
-    out.write(Util.EMPTY_BYTE_ARRAY);
-    out.flush();
-    out.close();
-
-    // Verify the peer received what was expected.
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_HEADERS);
-    assertThat(peer.takeFrame().type).isEqualTo(Http2.TYPE_DATA);
-    assertThat(peer.frameCount()).isEqualTo(5);
-  }
-
-  @Test public void testTruncatedDataFrame() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.sendFrame().data(false, 3, data(1024), 1024);
-    peer.truncateLastFrame(8 + 100);
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    assertThat(stream.takeHeaders()).isEqualTo(Headers.of("a", "android"));
-    Source in = stream.getSource();
-    try {
-      Okio.buffer(in).readByteString(101);
-      fail();
-    } catch (EOFException expected) {
-    }
-  }
-
-  @Test public void blockedStreamDoesntStarveNewStream() throws Exception {
-    int framesThatFillWindow = roundUp(DEFAULT_INITIAL_WINDOW_SIZE, peer.maxOutboundDataLength());
-
-    // Write the mocking script. This accepts more data frames than necessary!
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // SETTINGS ACK
-    peer.acceptFrame(); // SYN_STREAM on stream 1
-    for (int i = 0; i < framesThatFillWindow; i++) {
-      peer.acceptFrame(); // DATA on stream 1
-    }
-    peer.acceptFrame(); // SYN_STREAM on stream 2
-    peer.acceptFrame(); // DATA on stream 2
-    peer.play();
-
-    // Play it back.
-    Http2Connection connection = connect(peer);
-    Http2Stream stream1 = connection.newStream(headerEntries("a", "apple"), true);
-    BufferedSink out1 = Okio.buffer(stream1.getSink());
-    out1.write(new byte[DEFAULT_INITIAL_WINDOW_SIZE]);
-    out1.flush();
-
-    // Check that we've filled the window for both the stream and also the connection.
-    assertThat(connection.getWriteBytesTotal()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
-    assertThat(connection.getWriteBytesMaximum()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
-    assertThat(stream1.getWriteBytesTotal()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
-    assertThat(stream1.getWriteBytesMaximum()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
-
-    // receiving a window update on the connection will unblock new streams.
-    connection.getReaderRunnable().windowUpdate(0, 3);
-
-    assertThat(connection.getWriteBytesTotal()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
-    assertThat(connection.getWriteBytesMaximum()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE + 3);
-    assertThat(stream1.getWriteBytesTotal()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
-    assertThat(stream1.getWriteBytesMaximum()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
-
-    // Another stream should be able to send data even though 1 is blocked.
-    Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
-    BufferedSink out2 = Okio.buffer(stream2.getSink());
-    out2.writeUtf8("foo");
-    out2.flush();
-
-    assertThat(connection.getWriteBytesTotal()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE + 3);
-    assertThat(connection.getWriteBytesMaximum()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE + 3);
-    assertThat(stream1.getWriteBytesTotal()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
-    assertThat(stream1.getWriteBytesMaximum()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
-    assertThat(stream2.getWriteBytesTotal()).isEqualTo(3L);
-    assertThat(stream2.getWriteBytesMaximum()).isEqualTo(DEFAULT_INITIAL_WINDOW_SIZE);
-  }
-
-  @Test public void remoteOmitsInitialSettings() throws Exception {
-    // Write the mocking script. Note no SETTINGS frame is sent or acknowledged.
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().headers(false, 3, headerEntries("a", "android"));
-    peer.acceptFrame(); // GOAWAY
-    peer.play();
-
-    Http2Connection connection = new Http2Connection.Builder(true, TaskRunner.INSTANCE)
-        .socket(peer.openSocket())
-        .build();
-    connection.start(false);
-
-    Http2Stream stream = connection.newStream(headerEntries("b", "banana"), false);
-    try {
-      stream.takeHeaders();
-      fail();
-    } catch (IOException expected) {
-      assertThat(expected.getMessage()).isEqualTo("Expected a SETTINGS frame but was 1");
-    }
-
-    // verify the peer received what was expected
-    InFrame synStream = peer.takeFrame();
-    assertThat(synStream.type).isEqualTo(Http2.TYPE_HEADERS);
-    InFrame goaway = peer.takeFrame();
-    assertThat(goaway.type).isEqualTo(Http2.TYPE_GOAWAY);
-    assertThat(goaway.errorCode).isEqualTo(ErrorCode.PROTOCOL_ERROR);
-  }
-
-  private Buffer data(int byteCount) {
-    return new Buffer().write(new byte[byteCount]);
-  }
-
-  private void assertStreamData(String expected, Source source) throws IOException {
-    String actual = Okio.buffer(source).readUtf8();
-    assertThat(actual).isEqualTo(expected);
-  }
-
-  /** Reads {@code prefix} from {@code source}. */
-  private void assertStreamPrefix(String prefix, BufferedSource source) throws IOException {
-    assertThat(source.readUtf8(Utf8.size(prefix))).isEqualTo(prefix);
-  }
-
-  /**
-   * Returns true when all work currently in progress by the watchdog have completed. This method
-   * creates more work for the watchdog and waits for that work to be executed. When it is, we know
-   * work that preceded this call is complete.
-   */
-  private void awaitWatchdogIdle() throws Exception {
-    final CountDownLatch latch = new CountDownLatch(1);
-    AsyncTimeout watchdogJob = new AsyncTimeout() {
-      @Override protected void timedOut() {
-        latch.countDown();
-      }
-    };
-    watchdogJob.deadlineNanoTime(System.nanoTime()); // Due immediately!
-    watchdogJob.enter();
-    latch.await();
-  }
-
-  static int roundUp(int num, int divisor) {
-    return (num + divisor - 1) / divisor;
-  }
-
-  private Http2Connection connectWithSettings(boolean client, Settings settings) throws Exception {
-    peer.setClient(client);
-    peer.sendFrame().settings(settings);
-    peer.acceptFrame(); // ACK
-    peer.play();
-    return connect(peer);
-  }
-
-  private Http2Connection connect(MockHttp2Peer peer) throws Exception {
-    return connect(peer, IGNORE, Http2Connection.Listener.REFUSE_INCOMING_STREAMS);
-  }
-
-  /** Builds a new connection to {@code peer} with settings acked. */
-  private Http2Connection connect(MockHttp2Peer peer, PushObserver pushObserver,
-      Http2Connection.Listener listener) throws Exception {
-    Http2Connection connection = new Http2Connection.Builder(true, TaskRunner.INSTANCE)
-        .socket(peer.openSocket())
-        .pushObserver(pushObserver)
-        .listener(listener)
-        .build();
-    connection.start(false);
-
-    // verify the peer received the ACK
-    InFrame ackFrame = peer.takeFrame();
-    assertThat(ackFrame.type).isEqualTo(Http2.TYPE_SETTINGS);
-    assertThat(ackFrame.streamId).isEqualTo(0);
-    assertThat(ackFrame.ack).isTrue();
-
-    return connection;
-  }
-
-  static final PushObserver IGNORE = new PushObserver() {
-
-    @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
-      return false;
-    }
-
-    @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
-      return false;
-    }
-
-    @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
-        boolean last) throws IOException {
-      source.skip(byteCount);
-      return false;
-    }
-
-    @Override public void onReset(int streamId, ErrorCode errorCode) {
-    }
-  };
-
-  private static class RecordingPushObserver implements PushObserver {
-    final List<Object> events = new ArrayList<>();
-
-    public synchronized Object takeEvent() throws Exception {
-      while (events.isEmpty()) {
-        wait();
-      }
-      return events.remove(0);
-    }
-
-    @Override public synchronized boolean onRequest(int streamId, List<Header> requestHeaders) {
-      assertThat(streamId).isEqualTo(2);
-      events.add(requestHeaders);
-      notifyAll();
-      return false;
-    }
-
-    @Override public synchronized boolean onHeaders(
-        int streamId, List<Header> responseHeaders, boolean last) {
-      assertThat(streamId).isEqualTo(2);
-      assertThat(last).isTrue();
-      events.add(responseHeaders);
-      notifyAll();
-      return false;
-    }
-
-    @Override public synchronized boolean onData(
-        int streamId, BufferedSource source, int byteCount, boolean last) {
-      events.add(new AssertionError("onData"));
-      notifyAll();
-      return false;
-    }
-
-    @Override public synchronized void onReset(int streamId, ErrorCode errorCode) {
-      events.add(new AssertionError("onReset"));
-      notifyAll();
-    }
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/http2/Http2Test.java b/okhttp/src/test/java/okhttp3/internal/http2/Http2Test.java
deleted file mode 100644
index 45f0a71a75..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/http2/Http2Test.java
+++ /dev/null
@@ -1,778 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.List;
-import java.util.concurrent.atomic.AtomicInteger;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.GzipSink;
-import okio.Okio;
-import org.junit.Test;
-
-import static java.util.Arrays.asList;
-import static okhttp3.TestUtil.headerEntries;
-import static okhttp3.internal.http2.Http2.FLAG_COMPRESSED;
-import static okhttp3.internal.http2.Http2.FLAG_END_HEADERS;
-import static okhttp3.internal.http2.Http2.FLAG_END_STREAM;
-import static okhttp3.internal.http2.Http2.FLAG_NONE;
-import static okhttp3.internal.http2.Http2.FLAG_PADDED;
-import static okhttp3.internal.http2.Http2.FLAG_PRIORITY;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class Http2Test {
-  final Buffer frame = new Buffer();
-  final Http2Reader reader = new Http2Reader(frame, false);
-  final int expectedStreamId = 15;
-
-  @Test public void unknownFrameTypeSkipped() throws IOException {
-    writeMedium(frame, 4); // has a 4-byte field
-    frame.writeByte(99); // type 99
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(expectedStreamId);
-    frame.writeInt(111111111); // custom data
-
-    reader.nextFrame(false, new BaseTestHandler()); // Should not callback.
-  }
-
-  @Test public void onlyOneLiteralHeadersFrame() throws IOException {
-    final List<Header> sentHeaders = headerEntries("name", "value");
-
-    Buffer headerBytes = literalHeaders(sentHeaders);
-    writeMedium(frame, (int) headerBytes.size());
-    frame.writeByte(Http2.TYPE_HEADERS);
-    frame.writeByte(FLAG_END_HEADERS | FLAG_END_STREAM);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeAll(headerBytes);
-
-    // Check writer sends the same bytes.
-    assertThat(sendHeaderFrames(true, sentHeaders)).isEqualTo(frame);
-
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override public void headers(boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> headerBlock) {
-        assertThat(inFinished).isTrue();
-        assertThat(streamId).isEqualTo(expectedStreamId);
-        assertThat(associatedStreamId).isEqualTo(-1);
-        assertThat(headerBlock).isEqualTo(sentHeaders);
-      }
-    });
-  }
-
-  @Test public void headersWithPriority() throws IOException {
-    final List<Header> sentHeaders = headerEntries("name", "value");
-
-    Buffer headerBytes = literalHeaders(sentHeaders);
-    writeMedium(frame, (int) (headerBytes.size() + 5));
-    frame.writeByte(Http2.TYPE_HEADERS);
-    frame.writeByte(FLAG_END_HEADERS | FLAG_PRIORITY);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeInt(0); // Independent stream.
-    frame.writeByte(255); // Heaviest weight, zero-indexed.
-    frame.writeAll(headerBytes);
-
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override public void priority(int streamId, int streamDependency, int weight,
-          boolean exclusive) {
-        assertThat(streamDependency).isEqualTo(0);
-        assertThat(weight).isEqualTo(256);
-        assertThat(exclusive).isFalse();
-      }
-
-      @Override public void headers(boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> nameValueBlock) {
-        assertThat(inFinished).isFalse();
-        assertThat(streamId).isEqualTo(expectedStreamId);
-        assertThat(associatedStreamId).isEqualTo(-1);
-        assertThat(nameValueBlock).isEqualTo(sentHeaders);
-      }
-    });
-  }
-
-  /** Headers are compressed, then framed. */
-  @Test public void headersFrameThenContinuation() throws IOException {
-    final List<Header> sentHeaders = largeHeaders();
-
-    Buffer headerBlock = literalHeaders(sentHeaders);
-
-    // Write the first headers frame.
-    writeMedium(frame, Http2.INITIAL_MAX_FRAME_SIZE);
-    frame.writeByte(Http2.TYPE_HEADERS);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.write(headerBlock, Http2.INITIAL_MAX_FRAME_SIZE);
-
-    // Write the continuation frame, specifying no more frames are expected.
-    writeMedium(frame, (int) headerBlock.size());
-    frame.writeByte(Http2.TYPE_CONTINUATION);
-    frame.writeByte(FLAG_END_HEADERS);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeAll(headerBlock);
-
-    // Check writer sends the same bytes.
-    assertThat(sendHeaderFrames(false, sentHeaders)).isEqualTo(frame);
-
-    // Reading the above frames should result in a concatenated headerBlock.
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override public void headers(boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> headerBlock) {
-        assertThat(inFinished).isFalse();
-        assertThat(streamId).isEqualTo(expectedStreamId);
-        assertThat(associatedStreamId).isEqualTo(-1);
-        assertThat(headerBlock).isEqualTo(sentHeaders);
-      }
-    });
-  }
-
-  @Test public void pushPromise() throws IOException {
-    final int expectedPromisedStreamId = 11;
-
-    final List<Header> pushPromise = asList(
-        new Header(Header.TARGET_METHOD, "GET"),
-        new Header(Header.TARGET_SCHEME, "https"),
-        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
-        new Header(Header.TARGET_PATH, "/")
-    );
-
-    // Write the push promise frame, specifying the associated stream ID.
-    Buffer headerBytes = literalHeaders(pushPromise);
-    writeMedium(frame, (int) (headerBytes.size() + 4));
-    frame.writeByte(Http2.TYPE_PUSH_PROMISE);
-    frame.writeByte(Http2.FLAG_END_PUSH_PROMISE);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
-    frame.writeAll(headerBytes);
-
-    assertThat(sendPushPromiseFrames(expectedPromisedStreamId, pushPromise)).isEqualTo(
-        frame);
-
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override
-      public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
-        assertThat(streamId).isEqualTo(expectedStreamId);
-        assertThat(promisedStreamId).isEqualTo(expectedPromisedStreamId);
-        assertThat(headerBlock).isEqualTo(pushPromise);
-      }
-    });
-  }
-
-  /** Headers are compressed, then framed. */
-  @Test public void pushPromiseThenContinuation() throws IOException {
-    final int expectedPromisedStreamId = 11;
-    final List<Header> pushPromise = largeHeaders();
-
-    // Decoding the first header will cross frame boundaries.
-    Buffer headerBlock = literalHeaders(pushPromise);
-
-    // Write the first headers frame.
-    writeMedium(frame, Http2.INITIAL_MAX_FRAME_SIZE);
-    frame.writeByte(Http2.TYPE_PUSH_PROMISE);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
-    frame.write(headerBlock, Http2.INITIAL_MAX_FRAME_SIZE - 4);
-
-    // Write the continuation frame, specifying no more frames are expected.
-    writeMedium(frame, (int) headerBlock.size());
-    frame.writeByte(Http2.TYPE_CONTINUATION);
-    frame.writeByte(FLAG_END_HEADERS);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeAll(headerBlock);
-
-    assertThat(sendPushPromiseFrames(expectedPromisedStreamId, pushPromise)).isEqualTo(
-        frame);
-
-    // Reading the above frames should result in a concatenated headerBlock.
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override
-      public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
-        assertThat(streamId).isEqualTo(expectedStreamId);
-        assertThat(promisedStreamId).isEqualTo(expectedPromisedStreamId);
-        assertThat(headerBlock).isEqualTo(pushPromise);
-      }
-    });
-  }
-
-  @Test public void readRstStreamFrame() throws IOException {
-    writeMedium(frame, 4);
-    frame.writeByte(Http2.TYPE_RST_STREAM);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeInt(ErrorCode.PROTOCOL_ERROR.getHttpCode());
-
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override public void rstStream(int streamId, ErrorCode errorCode) {
-        assertThat(streamId).isEqualTo(expectedStreamId);
-        assertThat(errorCode).isEqualTo(ErrorCode.PROTOCOL_ERROR);
-      }
-    });
-  }
-
-  @Test public void readSettingsFrame() throws IOException {
-    final int reducedTableSizeBytes = 16;
-
-    writeMedium(frame, 12); // 2 settings * 6 bytes (2 for the code and 4 for the value).
-    frame.writeByte(Http2.TYPE_SETTINGS);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(0); // Settings are always on the connection stream 0.
-    frame.writeShort(1); // SETTINGS_HEADER_TABLE_SIZE
-    frame.writeInt(reducedTableSizeBytes);
-    frame.writeShort(2); // SETTINGS_ENABLE_PUSH
-    frame.writeInt(0);
-
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override public void settings(boolean clearPrevious, Settings settings) {
-        // No clearPrevious in HTTP/2.
-        assertThat(clearPrevious).isFalse();
-        assertThat(settings.getHeaderTableSize()).isEqualTo(reducedTableSizeBytes);
-        assertThat(settings.getEnablePush(true)).isFalse();
-      }
-    });
-  }
-
-  @Test public void readSettingsFrameInvalidPushValue() throws IOException {
-    writeMedium(frame, 6); // 2 for the code and 4 for the value
-    frame.writeByte(Http2.TYPE_SETTINGS);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(0); // Settings are always on the connection stream 0.
-    frame.writeShort(2);
-    frame.writeInt(2);
-
-    try {
-      reader.nextFrame(false, new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1");
-    }
-  }
-
-  @Test public void readSettingsFrameUnknownSettingId() throws IOException {
-    writeMedium(frame, 6); // 2 for the code and 4 for the value
-    frame.writeByte(Http2.TYPE_SETTINGS);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(0); // Settings are always on the connection stream 0.
-    frame.writeShort(7); // old number for SETTINGS_INITIAL_WINDOW_SIZE
-    frame.writeInt(1);
-
-    final AtomicInteger settingValue = new AtomicInteger();
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override public void settings(boolean clearPrevious, Settings settings) {
-        settingValue.set(settings.get(7));
-      }
-    });
-    assertThat(1).isEqualTo(settingValue.intValue());
-  }
-
-  @Test public void readSettingsFrameExperimentalId() throws IOException {
-    writeMedium(frame, 6); // 2 for the code and 4 for the value
-    frame.writeByte(Http2.TYPE_SETTINGS);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(0); // Settings are always on the connection stream 0.
-    frame.write(ByteString.decodeHex("f000")); // Id reserved for experimental use.
-    frame.writeInt(1);
-
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override public void settings(boolean clearPrevious, Settings settings) {
-        // no-op
-      }
-    });
-  }
-
-  @Test public void readSettingsFrameNegativeWindowSize() throws IOException {
-    writeMedium(frame, 6); // 2 for the code and 4 for the value
-    frame.writeByte(Http2.TYPE_SETTINGS);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(0); // Settings are always on the connection stream 0.
-    frame.writeShort(4); // SETTINGS_INITIAL_WINDOW_SIZE
-    frame.writeInt(Integer.MIN_VALUE);
-
-    try {
-      reader.nextFrame(false, new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1");
-    }
-  }
-
-  @Test public void readSettingsFrameNegativeFrameLength() throws IOException {
-    writeMedium(frame, 6); // 2 for the code and 4 for the value
-    frame.writeByte(Http2.TYPE_SETTINGS);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(0); // Settings are always on the connection stream 0.
-    frame.writeShort(5); // SETTINGS_MAX_FRAME_SIZE
-    frame.writeInt(Integer.MIN_VALUE);
-
-    try {
-      reader.nextFrame(false, new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: -2147483648");
-    }
-  }
-
-  @Test public void readSettingsFrameTooShortFrameLength() throws IOException {
-    writeMedium(frame, 6); // 2 for the code and 4 for the value
-    frame.writeByte(Http2.TYPE_SETTINGS);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(0); // Settings are always on the connection stream 0.
-    frame.writeShort(5); // SETTINGS_MAX_FRAME_SIZE
-    frame.writeInt((int) Math.pow(2, 14) - 1);
-
-    try {
-      reader.nextFrame(false, new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: 16383");
-    }
-  }
-
-  @Test public void readSettingsFrameTooLongFrameLength() throws IOException {
-    writeMedium(frame, 6); // 2 for the code and 4 for the value
-    frame.writeByte(Http2.TYPE_SETTINGS);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(0); // Settings are always on the connection stream 0.
-    frame.writeShort(5); // SETTINGS_MAX_FRAME_SIZE
-    frame.writeInt((int) Math.pow(2, 24));
-
-    try {
-      reader.nextFrame(false, new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "PROTOCOL_ERROR SETTINGS_MAX_FRAME_SIZE: 16777216");
-    }
-  }
-
-  @Test public void pingRoundTrip() throws IOException {
-    final int expectedPayload1 = 7;
-    final int expectedPayload2 = 8;
-
-    writeMedium(frame, 8); // length
-    frame.writeByte(Http2.TYPE_PING);
-    frame.writeByte(Http2.FLAG_ACK);
-    frame.writeInt(0); // connection-level
-    frame.writeInt(expectedPayload1);
-    frame.writeInt(expectedPayload2);
-
-    // Check writer sends the same bytes.
-    assertThat(sendPingFrame(true, expectedPayload1, expectedPayload2)).isEqualTo(frame);
-
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override public void ping(boolean ack, int payload1, int payload2) {
-        assertThat(ack).isTrue();
-        assertThat(payload1).isEqualTo(expectedPayload1);
-        assertThat(payload2).isEqualTo(expectedPayload2);
-      }
-    });
-  }
-
-  @Test public void maxLengthDataFrame() throws IOException {
-    final byte[] expectedData = new byte[Http2.INITIAL_MAX_FRAME_SIZE];
-    Arrays.fill(expectedData, (byte) 2);
-
-    writeMedium(frame, expectedData.length);
-    frame.writeByte(Http2.TYPE_DATA);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.write(expectedData);
-
-    // Check writer sends the same bytes.
-    assertThat(sendDataFrame(new Buffer().write(expectedData))).isEqualTo(frame);
-
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override public void data(boolean inFinished, int streamId, BufferedSource source,
-          int length) throws IOException {
-        assertThat(inFinished).isFalse();
-        assertThat(streamId).isEqualTo(expectedStreamId);
-        assertThat(length).isEqualTo(Http2.INITIAL_MAX_FRAME_SIZE);
-        ByteString data = source.readByteString(length);
-        for (byte b : data.toByteArray()) {
-          assertThat(b).isEqualTo((byte) 2);
-        }
-      }
-    });
-  }
-
-  @Test public void dataFrameNotAssociateWithStream() throws IOException {
-    byte[] payload = new byte[] {0x01, 0x02};
-
-    writeMedium(frame, payload.length);
-    frame.writeByte(Http2.TYPE_DATA);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(0);
-    frame.write(payload);
-
-    try {
-      reader.nextFrame(false, new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("PROTOCOL_ERROR: TYPE_DATA streamId == 0");
-    }
-  }
-
-  /** We do not send SETTINGS_COMPRESS_DATA = 1, nor want to. Let's make sure we error. */
-  @Test public void compressedDataFrameWhenSettingDisabled() throws IOException {
-    byte[] expectedData = new byte[Http2.INITIAL_MAX_FRAME_SIZE];
-    Arrays.fill(expectedData, (byte) 2);
-    Buffer zipped = gzip(expectedData);
-    int zippedSize = (int) zipped.size();
-
-    writeMedium(frame, zippedSize);
-    frame.writeByte(Http2.TYPE_DATA);
-    frame.writeByte(FLAG_COMPRESSED);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    zipped.readAll(frame);
-
-    try {
-      reader.nextFrame(false, new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA");
-    }
-  }
-
-  @Test public void readPaddedDataFrame() throws IOException {
-    int dataLength = 1123;
-    byte[] expectedData = new byte[dataLength];
-    Arrays.fill(expectedData, (byte) 2);
-
-    int paddingLength = 254;
-    byte[] padding = new byte[paddingLength];
-    Arrays.fill(padding, (byte) 0);
-
-    writeMedium(frame, dataLength + paddingLength + 1);
-    frame.writeByte(Http2.TYPE_DATA);
-    frame.writeByte(FLAG_PADDED);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeByte(paddingLength);
-    frame.write(expectedData);
-    frame.write(padding);
-
-    reader.nextFrame(false, assertData());
-    // Padding was skipped.
-    assertThat(frame.exhausted()).isTrue();
-  }
-
-  @Test public void readPaddedDataFrameZeroPadding() throws IOException {
-    int dataLength = 1123;
-    byte[] expectedData = new byte[dataLength];
-    Arrays.fill(expectedData, (byte) 2);
-
-    writeMedium(frame, dataLength + 1);
-    frame.writeByte(Http2.TYPE_DATA);
-    frame.writeByte(FLAG_PADDED);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeByte(0);
-    frame.write(expectedData);
-
-    reader.nextFrame(false, assertData());
-  }
-
-  @Test public void readPaddedHeadersFrame() throws IOException {
-    int paddingLength = 254;
-    byte[] padding = new byte[paddingLength];
-    Arrays.fill(padding, (byte) 0);
-
-    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
-    writeMedium(frame, (int) headerBlock.size() + paddingLength + 1);
-    frame.writeByte(Http2.TYPE_HEADERS);
-    frame.writeByte(FLAG_END_HEADERS | FLAG_PADDED);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeByte(paddingLength);
-    frame.writeAll(headerBlock);
-    frame.write(padding);
-
-    reader.nextFrame(false, assertHeaderBlock());
-    // Padding was skipped.
-    assertThat(frame.exhausted()).isTrue();
-  }
-
-  @Test public void readPaddedHeadersFrameZeroPadding() throws IOException {
-    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
-    writeMedium(frame, (int) headerBlock.size() + 1);
-    frame.writeByte(Http2.TYPE_HEADERS);
-    frame.writeByte(FLAG_END_HEADERS | FLAG_PADDED);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeByte(0);
-    frame.writeAll(headerBlock);
-
-    reader.nextFrame(false, assertHeaderBlock());
-  }
-
-  /** Headers are compressed, then framed. */
-  @Test public void readPaddedHeadersFrameThenContinuation() throws IOException {
-    int paddingLength = 254;
-    byte[] padding = new byte[paddingLength];
-    Arrays.fill(padding, (byte) 0);
-
-    // Decoding the first header will cross frame boundaries.
-    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
-
-    // Write the first headers frame.
-    writeMedium(frame, (int) (headerBlock.size() / 2) + paddingLength + 1);
-    frame.writeByte(Http2.TYPE_HEADERS);
-    frame.writeByte(FLAG_PADDED);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeByte(paddingLength);
-    frame.write(headerBlock, headerBlock.size() / 2);
-    frame.write(padding);
-
-    // Write the continuation frame, specifying no more frames are expected.
-    writeMedium(frame, (int) headerBlock.size());
-    frame.writeByte(Http2.TYPE_CONTINUATION);
-    frame.writeByte(FLAG_END_HEADERS);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeAll(headerBlock);
-
-    reader.nextFrame(false, assertHeaderBlock());
-    assertThat(frame.exhausted()).isTrue();
-  }
-
-  @Test public void tooLargeDataFrame() throws IOException {
-    try {
-      sendDataFrame(new Buffer().write(new byte[0x1000000]));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("FRAME_SIZE_ERROR length > 16384: 16777216");
-    }
-  }
-
-  @Test public void windowUpdateRoundTrip() throws IOException {
-    final long expectedWindowSizeIncrement = 0x7fffffff;
-
-    writeMedium(frame, 4); // length
-    frame.writeByte(Http2.TYPE_WINDOW_UPDATE);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(expectedStreamId);
-    frame.writeInt((int) expectedWindowSizeIncrement);
-
-    // Check writer sends the same bytes.
-    assertThat(windowUpdate(expectedWindowSizeIncrement)).isEqualTo(frame);
-
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
-        assertThat(streamId).isEqualTo(expectedStreamId);
-        assertThat(windowSizeIncrement).isEqualTo(expectedWindowSizeIncrement);
-      }
-    });
-  }
-
-  @Test public void badWindowSizeIncrement() throws IOException {
-    try {
-      windowUpdate(0);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 0");
-    }
-    try {
-      windowUpdate(0x80000000L);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 2147483648");
-    }
-  }
-
-  @Test public void goAwayWithoutDebugDataRoundTrip() throws IOException {
-    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
-
-    writeMedium(frame, 8); // Without debug data there's only 2 32-bit fields.
-    frame.writeByte(Http2.TYPE_GOAWAY);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(0); // connection-scope
-    frame.writeInt(expectedStreamId); // last good stream.
-    frame.writeInt(expectedError.getHttpCode());
-
-    // Check writer sends the same bytes.
-    assertThat(sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY)).isEqualTo(
-        frame);
-
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override public void goAway(
-          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
-        assertThat(lastGoodStreamId).isEqualTo(expectedStreamId);
-        assertThat(errorCode).isEqualTo(expectedError);
-        assertThat(debugData.size()).isEqualTo(0);
-      }
-    });
-  }
-
-  @Test public void goAwayWithDebugDataRoundTrip() throws IOException {
-    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
-    final ByteString expectedData = ByteString.encodeUtf8("abcdefgh");
-
-    // Compose the expected GOAWAY frame without debug data.
-    writeMedium(frame, 8 + expectedData.size());
-    frame.writeByte(Http2.TYPE_GOAWAY);
-    frame.writeByte(Http2.FLAG_NONE);
-    frame.writeInt(0); // connection-scope
-    frame.writeInt(0); // never read any stream!
-    frame.writeInt(expectedError.getHttpCode());
-    frame.write(expectedData.toByteArray());
-
-    // Check writer sends the same bytes.
-    assertThat(sendGoAway(0, expectedError, expectedData.toByteArray())).isEqualTo(frame);
-
-    reader.nextFrame(false, new BaseTestHandler() {
-      @Override public void goAway(
-          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
-        assertThat(lastGoodStreamId).isEqualTo(0);
-        assertThat(errorCode).isEqualTo(expectedError);
-        assertThat(debugData).isEqualTo(expectedData);
-      }
-    });
-  }
-
-  @Test public void frameSizeError() throws IOException {
-    Http2Writer writer = new Http2Writer(new Buffer(), true);
-
-    try {
-      writer.frameHeader(0, 16777216, Http2.TYPE_DATA, FLAG_NONE);
-      fail();
-    } catch (IllegalArgumentException e) {
-      // TODO: real max is based on settings between 16384 and 16777215
-      assertThat(e.getMessage()).isEqualTo("FRAME_SIZE_ERROR length > 16384: 16777216");
-    }
-  }
-
-  @Test public void ackSettingsAppliesMaxFrameSize() throws IOException {
-    int newMaxFrameSize = 16777215;
-
-    Http2Writer writer = new Http2Writer(new Buffer(), true);
-
-    writer.applyAndAckSettings(new Settings().set(Settings.MAX_FRAME_SIZE, newMaxFrameSize));
-
-    assertThat(writer.maxDataLength()).isEqualTo(newMaxFrameSize);
-    writer.frameHeader(0, newMaxFrameSize, Http2.TYPE_DATA, FLAG_NONE);
-  }
-
-  @Test public void streamIdHasReservedBit() throws IOException {
-    Http2Writer writer = new Http2Writer(new Buffer(), true);
-
-    try {
-      int streamId = 3;
-      streamId |= 1L << 31; // set reserved bit
-      writer.frameHeader(streamId, Http2.INITIAL_MAX_FRAME_SIZE, Http2.TYPE_DATA, FLAG_NONE);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("reserved bit set: -2147483645");
-    }
-  }
-
-  private Buffer literalHeaders(List<Header> sentHeaders) throws IOException {
-    Buffer out = new Buffer();
-    new Hpack.Writer(out).writeHeaders(sentHeaders);
-    return out;
-  }
-
-  private Buffer sendHeaderFrames(boolean outFinished, List<Header> headers) throws IOException {
-    Buffer out = new Buffer();
-    new Http2Writer(out, true).headers(outFinished, expectedStreamId, headers);
-    return out;
-  }
-
-  private Buffer sendPushPromiseFrames(int streamId, List<Header> headers) throws IOException {
-    Buffer out = new Buffer();
-    new Http2Writer(out, true).pushPromise(expectedStreamId, streamId, headers);
-    return out;
-  }
-
-  private Buffer sendPingFrame(boolean ack, int payload1, int payload2) throws IOException {
-    Buffer out = new Buffer();
-    new Http2Writer(out, true).ping(ack, payload1, payload2);
-    return out;
-  }
-
-  private Buffer sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
-      throws IOException {
-    Buffer out = new Buffer();
-    new Http2Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
-    return out;
-  }
-
-  private Buffer sendDataFrame(Buffer data) throws IOException {
-    Buffer out = new Buffer();
-    new Http2Writer(out, true).dataFrame(expectedStreamId, FLAG_NONE, data,
-        (int) data.size());
-    return out;
-  }
-
-  private Buffer windowUpdate(long windowSizeIncrement) throws IOException {
-    Buffer out = new Buffer();
-    new Http2Writer(out, true).windowUpdate(expectedStreamId, windowSizeIncrement);
-    return out;
-  }
-
-  private Http2Reader.Handler assertHeaderBlock() {
-    return new BaseTestHandler() {
-      @Override public void headers(boolean inFinished, int streamId,
-          int associatedStreamId, List<Header> headerBlock) {
-        assertThat(inFinished).isFalse();
-        assertThat(streamId).isEqualTo(expectedStreamId);
-        assertThat(associatedStreamId).isEqualTo(-1);
-        assertThat(headerBlock).isEqualTo(headerEntries("foo", "barrr", "baz", "qux"));
-      }
-    };
-  }
-
-  private Http2Reader.Handler assertData() {
-    return new BaseTestHandler() {
-      @Override public void data(boolean inFinished, int streamId, BufferedSource source,
-          int length) throws IOException {
-        assertThat(inFinished).isFalse();
-        assertThat(streamId).isEqualTo(expectedStreamId);
-        assertThat(length).isEqualTo(1123);
-        ByteString data = source.readByteString(length);
-        for (byte b : data.toByteArray()) {
-          assertThat(b).isEqualTo((byte) 2);
-        }
-      }
-    };
-  }
-
-  private static Buffer gzip(byte[] data) throws IOException {
-    Buffer buffer = new Buffer();
-    Okio.buffer(new GzipSink(buffer)).write(data).close();
-    return buffer;
-  }
-
-  /** Create a sufficiently large header set to overflow INITIAL_MAX_FRAME_SIZE bytes. */
-  private static List<Header> largeHeaders() {
-    String[] nameValues = new String[32];
-    char[] chars = new char[512];
-    for (int i = 0; i < nameValues.length; ) {
-      Arrays.fill(chars, (char) i);
-      nameValues[i++] = nameValues[i++] = String.valueOf(chars);
-    }
-    return headerEntries(nameValues);
-  }
-
-  private static void writeMedium(BufferedSink sink, int i) throws IOException {
-    sink.writeByte((i >>> 16) & 0xff);
-    sink.writeByte((i >>> 8) & 0xff);
-    sink.writeByte(i & 0xff);
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java b/okhttp/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
deleted file mode 100644
index 43e665019d..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
+++ /dev/null
@@ -1,1654 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.Authenticator;
-import java.net.HttpURLConnection;
-import java.net.SocketTimeoutException;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.List;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.SynchronousQueue;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import javax.annotation.Nullable;
-import okhttp3.Cache;
-import okhttp3.Call;
-import okhttp3.Callback;
-import okhttp3.Connection;
-import okhttp3.Cookie;
-import okhttp3.Credentials;
-import okhttp3.EventListener;
-import okhttp3.Headers;
-import okhttp3.Interceptor;
-import okhttp3.MediaType;
-import okhttp3.OkHttpClient;
-import okhttp3.OkHttpClientTestRule;
-import okhttp3.Protocol;
-import okhttp3.RecordingCookieJar;
-import okhttp3.RecordingHostnameVerifier;
-import okhttp3.Request;
-import okhttp3.RequestBody;
-import okhttp3.Response;
-import okhttp3.TestLogHandler;
-import okhttp3.TestUtil;
-import okhttp3.internal.DoubleInetAddressDns;
-import okhttp3.internal.RecordingOkAuthenticator;
-import okhttp3.internal.Util;
-import okhttp3.internal.connection.RealConnection;
-import okhttp3.mockwebserver.Dispatcher;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.PushPromise;
-import okhttp3.mockwebserver.QueueDispatcher;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.testing.Flaky;
-import okhttp3.testing.PlatformRule;
-import okhttp3.tls.HandshakeCertificates;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.GzipSink;
-import okio.Okio;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.RuleChain;
-import org.junit.rules.TemporaryFolder;
-import org.junit.rules.TestRule;
-import org.junit.rules.Timeout;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static java.util.Arrays.asList;
-import static java.util.concurrent.TimeUnit.MILLISECONDS;
-import static java.util.concurrent.TimeUnit.SECONDS;
-import static okhttp3.internal.Util.discard;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.data.Offset.offset;
-import static org.junit.Assert.assertArrayEquals;
-import static org.junit.Assert.fail;
-import static org.junit.Assume.assumeTrue;
-
-/** Test how HTTP/2 interacts with HTTP features. */
-@RunWith(Parameterized.class)
-@Flaky
-public final class HttpOverHttp2Test {
-  // Flaky https://github.com/square/okhttp/issues/4632
-  // Flaky https://github.com/square/okhttp/issues/4633
-
-  private static final Logger http2Logger = Logger.getLogger(Http2.class.getName());
-  private static final HandshakeCertificates handshakeCertificates = localhost();
-
-  @Parameters(name = "{0}")
-  public static Collection<Protocol> data() {
-    return asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_2);
-  }
-
-  private PlatformRule platform = new PlatformRule();
-  @Rule public final TestRule chain =
-      RuleChain.outerRule(platform).around(new Timeout(5, SECONDS));
-  @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
-  @Rule public final MockWebServer server = new MockWebServer();
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  private OkHttpClient client;
-  private Cache cache;
-  private TestLogHandler http2Handler = new TestLogHandler();
-  private Level previousLevel;
-  private String scheme;
-  private Protocol protocol;
-
-  public HttpOverHttp2Test(Protocol protocol) {
-    this.protocol = protocol;
-  }
-
-  @Before public void setUp() {
-    platform.assumeNotOpenJSSE();
-
-    if (protocol == Protocol.HTTP_2) {
-      platform.assumeHttp2Support();
-      server.useHttps(handshakeCertificates.sslSocketFactory(), false);
-      client = clientTestRule.newClientBuilder()
-          .protocols(asList(Protocol.HTTP_2, Protocol.HTTP_1_1))
-          .sslSocketFactory(
-              handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-          .hostnameVerifier(new RecordingHostnameVerifier())
-          .build();
-      scheme = "https";
-    } else {
-      server.setProtocols(asList(Protocol.H2_PRIOR_KNOWLEDGE));
-      client = clientTestRule.newClientBuilder()
-          .protocols(asList(Protocol.H2_PRIOR_KNOWLEDGE))
-          .build();
-      scheme = "http";
-    }
-
-    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
-    http2Logger.addHandler(http2Handler);
-    previousLevel = http2Logger.getLevel();
-    http2Logger.setLevel(Level.FINE);
-  }
-
-  @After public void tearDown() {
-    Authenticator.setDefault(null);
-    http2Logger.removeHandler(http2Handler);
-    http2Logger.setLevel(previousLevel);
-  }
-
-  @Test public void get() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("ABCDE")
-        .setStatus("HTTP/1.1 200 Sweet"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/foo"))
-        .build());
-    Response response = call.execute();
-
-    assertThat(response.body().string()).isEqualTo("ABCDE");
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.message()).isEqualTo("");
-    assertThat(response.protocol()).isEqualTo(protocol);
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
-    assertThat(request.getHeader(":scheme")).isEqualTo(scheme);
-    assertThat(request.getHeader(":authority")).isEqualTo(
-        (server.getHostName() + ":" + server.getPort()));
-  }
-
-  @Test public void emptyResponse() throws IOException {
-    server.enqueue(new MockResponse());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/foo"))
-        .build());
-    Response response = call.execute();
-
-    assertThat(response.body().byteStream().read()).isEqualTo(-1);
-    response.body().close();
-  }
-
-  @Test public void noDefaultContentLengthOnStreamingPost() throws Exception {
-    byte[] postBytes = "FGHIJ".getBytes(UTF_8);
-
-    server.enqueue(new MockResponse().setBody("ABCDE"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/foo"))
-        .post(new RequestBody() {
-          @Override public MediaType contentType() {
-            return MediaType.get("text/plain; charset=utf-8");
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            sink.write(postBytes);
-          }
-        })
-        .build());
-
-    Response response = call.execute();
-    assertThat(response.body().string()).isEqualTo("ABCDE");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getRequestLine()).isEqualTo("POST /foo HTTP/1.1");
-    assertArrayEquals(postBytes, request.getBody().readByteArray());
-    assertThat(request.getHeader("Content-Length")).isNull();
-  }
-
-  @Test public void userSuppliedContentLengthHeader() throws Exception {
-    byte[] postBytes = "FGHIJ".getBytes(UTF_8);
-
-    server.enqueue(new MockResponse().setBody("ABCDE"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/foo"))
-        .post(new RequestBody() {
-          @Override public MediaType contentType() {
-            return MediaType.get("text/plain; charset=utf-8");
-          }
-
-          @Override public long contentLength() {
-            return postBytes.length;
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            sink.write(postBytes);
-          }
-        })
-        .build());
-
-    Response response = call.execute();
-    assertThat(response.body().string()).isEqualTo("ABCDE");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getRequestLine()).isEqualTo("POST /foo HTTP/1.1");
-    assertArrayEquals(postBytes, request.getBody().readByteArray());
-    assertThat(Integer.parseInt(request.getHeader("Content-Length"))).isEqualTo(
-        (long) postBytes.length);
-  }
-
-  @Test public void closeAfterFlush() throws Exception {
-    byte[] postBytes = "FGHIJ".getBytes(UTF_8);
-
-    server.enqueue(new MockResponse().setBody("ABCDE"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/foo"))
-        .post(new RequestBody() {
-          @Override public MediaType contentType() {
-            return MediaType.get("text/plain; charset=utf-8");
-          }
-
-          @Override public long contentLength() {
-            return postBytes.length;
-          }
-
-          @Override public void writeTo(BufferedSink sink) throws IOException {
-            sink.write(postBytes);  // push bytes into the stream's buffer
-            sink.flush(); // Http2Connection.writeData subject to write window
-            sink.close(); // Http2Connection.writeData empty frame
-          }
-        })
-        .build());
-
-    Response response = call.execute();
-    assertThat(response.body().string()).isEqualTo("ABCDE");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getRequestLine()).isEqualTo("POST /foo HTTP/1.1");
-    assertArrayEquals(postBytes, request.getBody().readByteArray());
-    assertThat(Integer.parseInt(request.getHeader("Content-Length"))).isEqualTo(
-        (long) postBytes.length);
-  }
-
-  @Test public void connectionReuse() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABCDEF"));
-    server.enqueue(new MockResponse().setBody("GHIJKL"));
-
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/r1"))
-        .build());
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/r1"))
-        .build());
-    Response response1 = call1.execute();
-    Response response2 = call2.execute();
-
-    assertThat(response1.body().source().readUtf8(3)).isEqualTo("ABC");
-    assertThat(response2.body().source().readUtf8(3)).isEqualTo("GHI");
-    assertThat(response1.body().source().readUtf8(3)).isEqualTo("DEF");
-    assertThat(response2.body().source().readUtf8(3)).isEqualTo("JKL");
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-
-    response1.close();
-    response2.close();
-  }
-
-  @Test public void connectionWindowUpdateAfterCanceling() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(new Buffer().write(new byte[Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE + 1])));
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-
-    waitForDataFrames(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
-
-    // Cancel the call and discard what we've buffered for the response body. This should free up
-    // the connection flow-control window so new requests can proceed.
-    call1.cancel();
-    assertThat(discard(response1.body().source(), 1, TimeUnit.SECONDS))
-        .overridingErrorMessage("Call should not have completed successfully.")
-        .isFalse();
-
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    assertThat(response2.body().string()).isEqualTo("abc");
-  }
-
-  /** Wait for the client to receive {@code dataLength} DATA frames. */
-  private void waitForDataFrames(int dataLength) throws Exception {
-    int expectedFrameCount = dataLength / 16384;
-    int dataFrameCount = 0;
-    while (dataFrameCount < expectedFrameCount) {
-      String log = http2Handler.take();
-      if (log.equals("FINE: << 0x00000003 16384 DATA          ")) {
-        dataFrameCount++;
-      }
-    }
-  }
-
-  @Test public void connectionWindowUpdateOnClose() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(new Buffer().write(new byte[Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE + 1])));
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-
-    waitForDataFrames(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
-
-    // Cancel the call and close the response body. This should discard the buffered data and update
-    // the connection flow-control window.
-    call1.cancel();
-    response1.close();
-
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    assertThat(response2.body().string()).isEqualTo("abc");
-  }
-
-  @Test public void concurrentRequestWithEmptyFlowControlWindow() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody(new Buffer().write(new byte[Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE])));
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-
-    waitForDataFrames(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
-
-    assertThat(response1.body().contentLength()).isEqualTo(
-        (long) Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
-    int read = response1.body().source().read(new byte[8192]);
-    assertThat(read).isEqualTo(8192);
-
-    // Make a second call that should transmit the response headers. The response body won't be
-    // transmitted until the flow-control window is updated from the first request.
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    assertThat(response2.code()).isEqualTo(200);
-
-    // Close the response body. This should discard the buffered data and update the connection
-    // flow-control window.
-    response1.close();
-
-    assertThat(response2.body().string()).isEqualTo("abc");
-  }
-
-  /** https://github.com/square/okhttp/issues/373 */
-  @Test @Ignore public void synchronousRequest() throws Exception {
-    server.enqueue(new MockResponse().setBody("A"));
-    server.enqueue(new MockResponse().setBody("A"));
-
-    ExecutorService executor = Executors.newCachedThreadPool();
-    CountDownLatch countDownLatch = new CountDownLatch(2);
-    executor.execute(new AsyncRequest("/r1", countDownLatch));
-    executor.execute(new AsyncRequest("/r2", countDownLatch));
-    countDownLatch.await();
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void gzippedResponseBody() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeader("Content-Encoding: gzip")
-        .setBody(gzip("ABCABCABC")));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/r1"))
-        .build());
-
-    Response response = call.execute();
-    assertThat(response.body().string()).isEqualTo("ABCABCABC");
-  }
-
-  @Test public void authenticate() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_UNAUTHORIZED)
-        .addHeader("www-authenticate: Basic realm=\"protected area\"")
-        .setBody("Please authenticate."));
-    server.enqueue(new MockResponse()
-        .setBody("Successful auth!"));
-
-    String credential = Credentials.basic("username", "password");
-    client = client.newBuilder()
-        .authenticator(new RecordingOkAuthenticator(credential, "Basic"))
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertThat(response.body().string()).isEqualTo("Successful auth!");
-
-    RecordedRequest denied = server.takeRequest();
-    assertThat(denied.getHeader("Authorization")).isNull();
-    RecordedRequest accepted = server.takeRequest();
-    assertThat(accepted.getRequestLine()).isEqualTo("GET / HTTP/1.1");
-    assertThat(accepted.getHeader("Authorization")).isEqualTo(credential);
-  }
-
-  @Test public void redirect() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: /foo")
-        .setBody("This page has moved!"));
-    server.enqueue(new MockResponse().setBody("This is the new location!"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    Response response = call.execute();
-    assertThat(response.body().string()).isEqualTo("This is the new location!");
-
-    RecordedRequest request1 = server.takeRequest();
-    assertThat(request1.getPath()).isEqualTo("/");
-    RecordedRequest request2 = server.takeRequest();
-    assertThat(request2.getPath()).isEqualTo("/foo");
-  }
-
-  @Test public void readAfterLastByte() throws Exception {
-    server.enqueue(new MockResponse().setBody("ABC"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-
-    InputStream in = response.body().byteStream();
-    assertThat(in.read()).isEqualTo('A');
-    assertThat(in.read()).isEqualTo('B');
-    assertThat(in.read()).isEqualTo('C');
-    assertThat(in.read()).isEqualTo(-1);
-    assertThat(in.read()).isEqualTo(-1);
-
-    in.close();
-  }
-
-  @Test public void readResponseHeaderTimeout() throws Exception {
-    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
-    server.enqueue(new MockResponse().setBody("A"));
-
-    client = client.newBuilder()
-        .readTimeout(1000, MILLISECONDS)
-        .build();
-
-    // Make a call expecting a timeout reading the response headers.
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    try {
-      call1.execute();
-      fail("Should have timed out!");
-    } catch (SocketTimeoutException expected) {
-      assertThat(expected.getMessage()).isEqualTo("timeout");
-    }
-
-    // Confirm that a subsequent request on the same connection is not impacted.
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    assertThat(response2.body().string()).isEqualTo("A");
-
-    // Confirm that the connection was reused.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  /**
-   * Test to ensure we don't  throw a read timeout on responses that are progressing.  For this
-   * case, we take a 4KiB body and throttle it to 1KiB/second.  We set the read timeout to two
-   * seconds.  If our implementation is acting correctly, it will not throw, as it is progressing.
-   */
-  @Test public void readTimeoutMoreGranularThanBodySize() throws Exception {
-    char[] body = new char[4096]; // 4KiB to read.
-    Arrays.fill(body, 'y');
-    server.enqueue(new MockResponse().setBody(new String(body))
-        .throttleBody(1024, 1, SECONDS)); // Slow connection 1KiB/second.
-
-    client = client.newBuilder()
-        .readTimeout(2, SECONDS)
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    Response response = call.execute();
-    assertThat(response.body().string()).isEqualTo(new String(body));
-  }
-
-  /**
-   * Test to ensure we throw a read timeout on responses that are progressing too slowly.  For this
-   * case, we take a 2KiB body and throttle it to 1KiB/second.  We set the read timeout to half a
-   * second.  If our implementation is acting correctly, it will throw, as a byte doesn't arrive in
-   * time.
-   */
-  @Test public void readTimeoutOnSlowConnection() throws Exception {
-    String body = TestUtil.repeat('y', 2048);
-    server.enqueue(new MockResponse()
-        .setBody(body)
-        .throttleBody(1024, 1, SECONDS)); // Slow connection 1KiB/second.
-    server.enqueue(new MockResponse()
-        .setBody(body));
-
-    client = client.newBuilder()
-        .readTimeout(500, MILLISECONDS) // Half a second to read something.
-        .build();
-
-    // Make a call expecting a timeout reading the response body.
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-    try {
-      response1.body().string();
-      fail("Should have timed out!");
-    } catch (SocketTimeoutException expected) {
-      assertThat(expected.getMessage()).isEqualTo("timeout");
-    }
-
-    // Confirm that a subsequent request on the same connection is not impacted.
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    assertThat(response2.body().string()).isEqualTo(body);
-
-    // Confirm that the connection was reused.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void connectionTimeout() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("A")
-        .setBodyDelay(1, SECONDS));
-
-    OkHttpClient client1 = client.newBuilder()
-        .readTimeout(2000, MILLISECONDS)
-        .build();
-    Call call1 = client1
-        .newCall(new Request.Builder()
-            .url(server.url("/"))
-            .build());
-
-    OkHttpClient client2 = client.newBuilder()
-        .readTimeout(200, MILLISECONDS)
-        .build();
-    Call call2 = client2
-        .newCall(new Request.Builder()
-            .url(server.url("/"))
-            .build());
-
-    Response response1 = call1.execute();
-    assertThat(response1.body().string()).isEqualTo("A");
-
-    try {
-      call2.execute();
-      fail();
-    } catch (IOException expected) {
-    }
-
-    // Confirm that the connection was reused.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void responsesAreCached() throws IOException {
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    server.enqueue(new MockResponse()
-        .addHeader("cache-control: max-age=60")
-        .setBody("A"));
-
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-
-    assertThat(response1.body().string()).isEqualTo("A");
-    assertThat(cache.requestCount()).isEqualTo(1);
-    assertThat(cache.networkCount()).isEqualTo(1);
-    assertThat(cache.hitCount()).isEqualTo(0);
-
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    assertThat(response2.body().string()).isEqualTo("A");
-
-    Call call3 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response3 = call3.execute();
-    assertThat(response3.body().string()).isEqualTo("A");
-
-    assertThat(cache.requestCount()).isEqualTo(3);
-    assertThat(cache.networkCount()).isEqualTo(1);
-    assertThat(cache.hitCount()).isEqualTo(2);
-  }
-
-  @Test public void conditionalCache() throws IOException {
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    server.enqueue(new MockResponse()
-        .addHeader("ETag: v1")
-        .setBody("A"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
-
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-    assertThat(response1.body().string()).isEqualTo("A");
-
-    assertThat(cache.requestCount()).isEqualTo(1);
-    assertThat(cache.networkCount()).isEqualTo(1);
-    assertThat(cache.hitCount()).isEqualTo(0);
-
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    assertThat(response2.body().string()).isEqualTo("A");
-
-    assertThat(cache.requestCount()).isEqualTo(2);
-    assertThat(cache.networkCount()).isEqualTo(2);
-    assertThat(cache.hitCount()).isEqualTo(1);
-  }
-
-  @Test public void responseCachedWithoutConsumingFullBody() throws IOException {
-    client = client.newBuilder()
-        .cache(cache)
-        .build();
-
-    server.enqueue(new MockResponse()
-        .addHeader("cache-control: max-age=60")
-        .setBody("ABCD"));
-    server.enqueue(new MockResponse()
-        .addHeader("cache-control: max-age=60")
-        .setBody("EFGH"));
-
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-    assertThat(response1.body().source().readUtf8(2)).isEqualTo("AB");
-    response1.body().close();
-
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    assertThat(response2.body().source().readUtf8()).isEqualTo("ABCD");
-    response2.body().close();
-  }
-
-  @Test public void sendRequestCookies() throws Exception {
-    RecordingCookieJar cookieJar = new RecordingCookieJar();
-    Cookie requestCookie = new Cookie.Builder()
-        .name("a")
-        .value("b")
-        .domain(server.getHostName())
-        .build();
-    cookieJar.enqueueRequestCookies(requestCookie);
-    client = client.newBuilder()
-        .cookieJar(cookieJar)
-        .build();
-
-    server.enqueue(new MockResponse());
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertThat(response.body().string()).isEqualTo("");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getHeader("Cookie")).isEqualTo("a=b");
-  }
-
-  @Test public void receiveResponseCookies() throws Exception {
-    RecordingCookieJar cookieJar = new RecordingCookieJar();
-    client = client.newBuilder()
-        .cookieJar(cookieJar)
-        .build();
-
-    server.enqueue(new MockResponse()
-        .addHeader("set-cookie: a=b"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertThat(response.body().string()).isEqualTo("");
-
-    cookieJar.assertResponseCookies("a=b; path=/");
-  }
-
-  @Test public void cancelWithStreamNotCompleted() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-    server.enqueue(new MockResponse()
-        .setBody("def"));
-
-    // Disconnect before the stream is created. A connection is still established!
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call1.execute();
-    call1.cancel();
-
-    // That connection is pooled, and it works.
-    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    assertThat(response2.body().string()).isEqualTo("def");
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-
-    // Clean up the connection.
-    response.close();
-  }
-
-  @Test public void recoverFromOneRefusedStreamReusesConnection() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
-        .setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.getHttpCode()));
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertThat(response.body().string()).isEqualTo("abc");
-
-    // New connection.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    // Reused connection.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void recoverFromOneInternalErrorRequiresNewConnection() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
-        .setHttp2ErrorCode(ErrorCode.INTERNAL_ERROR.getHttpCode()));
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    client = client.newBuilder()
-        .dns(new DoubleInetAddressDns())
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertThat(response.body().string()).isEqualTo("abc");
-
-    // New connection.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    // New connection.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void recoverFromMultipleRefusedStreamsRequiresNewConnection() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
-        .setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.getHttpCode()));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
-        .setHttp2ErrorCode(ErrorCode.REFUSED_STREAM.getHttpCode()));
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    client = client.newBuilder()
-        .dns(new DoubleInetAddressDns())
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertThat(response.body().string()).isEqualTo("abc");
-
-    // New connection.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    // Reused connection.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-    // New connection.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void recoverFromCancelReusesConnection() throws Exception {
-    List<CountDownLatch> responseDequeuedLatches = Arrays.asList(
-        new CountDownLatch(1),
-        // No synchronization is needed for the last request, which is not canceled.
-        new CountDownLatch(0));
-    List<CountDownLatch> requestCanceledLatches = Arrays.asList(
-        new CountDownLatch(1),
-        new CountDownLatch(0));
-
-    QueueDispatcher dispatcher =
-        new RespondAfterCancelDispatcher(responseDequeuedLatches, requestCanceledLatches);
-    dispatcher.enqueueResponse(new MockResponse()
-        .setBodyDelay(10, TimeUnit.SECONDS)
-        .setBody("abc"));
-    dispatcher.enqueueResponse(new MockResponse()
-        .setBody("def"));
-    server.setDispatcher(dispatcher);
-
-    client = client.newBuilder()
-        .dns(new DoubleInetAddressDns())
-        .build();
-
-    callAndCancel(0, responseDequeuedLatches.get(0), requestCanceledLatches.get(0));
-
-    // Make a second request to ensure the connection is reused.
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertThat(response.body().string()).isEqualTo("def");
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  @Test public void recoverFromMultipleCancelReusesConnection() throws Exception {
-    List<CountDownLatch> responseDequeuedLatches = Arrays.asList(
-        new CountDownLatch(1),
-        new CountDownLatch(1),
-        // No synchronization is needed for the last request, which is not canceled.
-        new CountDownLatch(0));
-    List<CountDownLatch> requestCanceledLatches = Arrays.asList(
-        new CountDownLatch(1),
-        new CountDownLatch(1),
-        new CountDownLatch(0));
-
-    QueueDispatcher dispatcher =
-        new RespondAfterCancelDispatcher(responseDequeuedLatches, requestCanceledLatches);
-    dispatcher.enqueueResponse(new MockResponse()
-        .setBodyDelay(10, TimeUnit.SECONDS)
-        .setBody("abc"));
-    dispatcher.enqueueResponse(new MockResponse()
-        .setBodyDelay(10, TimeUnit.SECONDS)
-        .setBody("def"));
-    dispatcher.enqueueResponse(new MockResponse()
-        .setBody("ghi"));
-    server.setDispatcher(dispatcher);
-
-    client = client.newBuilder()
-        .dns(new DoubleInetAddressDns())
-        .build();
-
-    callAndCancel(0, responseDequeuedLatches.get(0), requestCanceledLatches.get(0));
-    callAndCancel(1, responseDequeuedLatches.get(1), requestCanceledLatches.get(1));
-
-    // Make a third request to ensure the connection is reused.
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertThat(response.body().string()).isEqualTo("ghi");
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
-  }
-
-  private static class RespondAfterCancelDispatcher extends QueueDispatcher {
-    final private List<CountDownLatch> responseDequeuedLatches;
-    final private List<CountDownLatch> requestCanceledLatches;
-    private int responseIndex = 0;
-
-    RespondAfterCancelDispatcher(
-        List<CountDownLatch> responseDequeuedLatches,
-        List<CountDownLatch> requestCanceledLatches) {
-      this.responseDequeuedLatches = responseDequeuedLatches;
-      this.requestCanceledLatches = requestCanceledLatches;
-    }
-
-    @Override
-    synchronized public MockResponse dispatch(RecordedRequest request)
-        throws InterruptedException {
-      // This guarantees a deterministic sequence when handling the canceled request:
-      // 1. Server reads request and dequeues first response
-      // 2. Client cancels request
-      // 3. Server tries to send response on the canceled stream
-      // Otherwise, there is no guarantee for the sequence. For example, the server may use the
-      // first mocked response to respond to the second request.
-      MockResponse response = super.dispatch(request);
-      responseDequeuedLatches.get(responseIndex).countDown();
-      requestCanceledLatches.get(responseIndex).await();
-      responseIndex++;
-      return response;
-    }
-  }
-
-  /** Make a call and canceling it as soon as it's accepted by the server. */
-  private void callAndCancel(int expectedSequenceNumber, CountDownLatch responseDequeuedLatch,
-      CountDownLatch requestCanceledLatch) throws Exception {
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    CountDownLatch latch = new CountDownLatch(1);
-    call.enqueue(new Callback() {
-      @Override public void onFailure(Call call1, IOException e) {
-        latch.countDown();
-      }
-
-      @Override public void onResponse(Call call1, Response response) {
-        fail();
-      }
-    });
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(
-        (long) expectedSequenceNumber);
-    responseDequeuedLatch.await();
-    call.cancel();
-    requestCanceledLatch.countDown();
-    latch.await();
-  }
-
-  @Test public void noRecoveryFromRefusedStreamWithRetryDisabled() throws Exception {
-    noRecoveryFromErrorWithRetryDisabled(ErrorCode.REFUSED_STREAM);
-  }
-
-  @Test public void noRecoveryFromInternalErrorWithRetryDisabled() throws Exception {
-    noRecoveryFromErrorWithRetryDisabled(ErrorCode.INTERNAL_ERROR);
-  }
-
-  private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
-        .setHttp2ErrorCode(errorCode.getHttpCode()));
-    server.enqueue(new MockResponse()
-        .setBody("abc"));
-
-    client = client.newBuilder()
-        .retryOnConnectionFailure(false)
-        .build();
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    try {
-      call.execute();
-      fail();
-    } catch (StreamResetException expected) {
-      assertThat(expected.errorCode).isEqualTo(errorCode);
-    }
-  }
-
-  @Test public void recoverFromConnectionNoNewStreamsOnFollowUp() throws Exception {
-    server.enqueue(new MockResponse()
-        .setResponseCode(401));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
-        .setHttp2ErrorCode(ErrorCode.INTERNAL_ERROR.getHttpCode()));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-    server.enqueue(new MockResponse()
-        .setResponseCode(301)
-        .addHeader("Location", "/foo"));
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-
-    CountDownLatch latch = new CountDownLatch(1);
-    BlockingQueue<String> responses = new SynchronousQueue<>();
-    okhttp3.Authenticator authenticator = (route, response) -> {
-      responses.offer(response.body().string());
-      try {
-        latch.await();
-      } catch (InterruptedException e) {
-        throw new AssertionError();
-      }
-      return response.request();
-    };
-
-    OkHttpClient blockingAuthClient = client.newBuilder()
-        .authenticator(authenticator)
-        .build();
-
-    Callback callback = new Callback() {
-      @Override public void onFailure(Call call, IOException e) {
-        fail();
-      }
-
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        responses.offer(response.body().string());
-      }
-    };
-
-    // Make the first request waiting until we get our auth challenge.
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    blockingAuthClient.newCall(request).enqueue(callback);
-    String response1 = responses.take();
-    assertThat(response1).isEqualTo("");
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-
-    // Now make the second request which will restrict the first HTTP/2 connection from creating new
-    // streams.
-    client.newCall(request).enqueue(callback);
-    String response2 = responses.take();
-    assertThat(response2).isEqualTo("DEF");
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-
-    // Let the first request proceed. It should discard the the held HTTP/2 connection and get a new
-    // one.
-    latch.countDown();
-    String response3 = responses.take();
-    assertThat(response3).isEqualTo("ABC");
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
-  }
-
-  @Test public void nonAsciiResponseHeader() throws Exception {
-    server.enqueue(new MockResponse()
-        .addHeaderLenient("Alpha", "")
-        .addHeaderLenient("", "Beta"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    response.close();
-
-    assertThat(response.header("Alpha")).isEqualTo("");
-    assertThat(response.header("")).isEqualTo("Beta");
-  }
-
-  @Test public void serverSendsPushPromise_GET() throws Exception {
-    PushPromise pushPromise = new PushPromise("GET", "/foo/bar", Headers.of("foo", "bar"),
-        new MockResponse().setBody("bar").setStatus("HTTP/1.1 200 Sweet"));
-    server.enqueue(new MockResponse()
-        .setBody("ABCDE")
-        .setStatus("HTTP/1.1 200 Sweet")
-        .withPush(pushPromise));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/foo"))
-        .build());
-    Response response = call.execute();
-
-    assertThat(response.body().string()).isEqualTo("ABCDE");
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.message()).isEqualTo("");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
-    assertThat(request.getHeader(":scheme")).isEqualTo(scheme);
-    assertThat(request.getHeader(":authority")).isEqualTo(
-        (server.getHostName() + ":" + server.getPort()));
-
-    RecordedRequest pushedRequest = server.takeRequest();
-    assertThat(pushedRequest.getRequestLine()).isEqualTo(
-        "GET /foo/bar HTTP/1.1");
-    assertThat(pushedRequest.getHeader("foo")).isEqualTo("bar");
-  }
-
-  @Test public void serverSendsPushPromise_HEAD() throws Exception {
-    PushPromise pushPromise = new PushPromise("HEAD", "/foo/bar", Headers.of("foo", "bar"),
-        new MockResponse().setStatus("HTTP/1.1 204 Sweet"));
-    server.enqueue(new MockResponse()
-        .setBody("ABCDE")
-        .setStatus("HTTP/1.1 200 Sweet")
-        .withPush(pushPromise));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/foo"))
-        .build());
-    Response response = call.execute();
-    assertThat(response.body().string()).isEqualTo("ABCDE");
-    assertThat(response.code()).isEqualTo(200);
-    assertThat(response.message()).isEqualTo("");
-
-    RecordedRequest request = server.takeRequest();
-    assertThat(request.getRequestLine()).isEqualTo("GET /foo HTTP/1.1");
-    assertThat(request.getHeader(":scheme")).isEqualTo(scheme);
-    assertThat(request.getHeader(":authority")).isEqualTo(
-        (server.getHostName() + ":" + server.getPort()));
-
-    RecordedRequest pushedRequest = server.takeRequest();
-    assertThat(pushedRequest.getRequestLine()).isEqualTo(
-        "HEAD /foo/bar HTTP/1.1");
-    assertThat(pushedRequest.getHeader("foo")).isEqualTo("bar");
-  }
-
-  @Test public void noDataFramesSentWithNullRequestBody() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .method("DELETE", null)
-        .build());
-    Response response = call.execute();
-    assertThat(response.body().string()).isEqualTo("ABC");
-
-    assertThat(response.protocol()).isEqualTo(protocol);
-
-    List<String> logs = http2Handler.takeAll();
-
-    assertThat(firstFrame(logs, "HEADERS"))
-        .overridingErrorMessage("header logged")
-        .contains("HEADERS       END_STREAM|END_HEADERS");
-  }
-
-  @Test public void emptyDataFrameSentWithEmptyBody() throws Exception {
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .method("DELETE", Util.EMPTY_REQUEST)
-        .build());
-    Response response = call.execute();
-    assertThat(response.body().string()).isEqualTo("ABC");
-
-    assertThat(response.protocol()).isEqualTo(protocol);
-
-    List<String> logs = http2Handler.takeAll();
-
-    assertThat(firstFrame(logs, "HEADERS"))
-        .overridingErrorMessage("header logged")
-        .contains("HEADERS       END_HEADERS");
-    // While MockWebServer waits to read the client's HEADERS frame before sending the response, it
-    // doesn't wait to read the client's DATA frame and may send a DATA frame before the client
-    // does. So we can't assume the client's empty DATA will be logged first.
-    assertThat(countFrames(logs, "FINE: >> 0x00000003     0 DATA          END_STREAM"))
-        .isEqualTo((long) 2);
-    assertThat(countFrames(logs, "FINE: >> 0x00000003     3 DATA          "))
-        .isEqualTo((long) 1);
-  }
-
-  @Test public void pingsTransmitted() throws Exception {
-    // Ping every 500 ms, starting at 500 ms.
-    client = client.newBuilder()
-        .pingInterval(500, TimeUnit.MILLISECONDS)
-        .build();
-
-    // Delay the response to give 1 ping enough time to be sent and replied to.
-    server.enqueue(new MockResponse()
-        .setBodyDelay(750, TimeUnit.MILLISECONDS)
-        .setBody("ABC"));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertThat(response.body().string()).isEqualTo("ABC");
-
-    assertThat(response.protocol()).isEqualTo(protocol);
-
-    // Confirm a single ping was sent and received, and its reply was sent and received.
-    List<String> logs = http2Handler.takeAll();
-    assertThat(countFrames(logs, "FINE: >> 0x00000000     8 PING          ")).isEqualTo(
-        (long) 1);
-    assertThat(countFrames(logs, "FINE: << 0x00000000     8 PING          ")).isEqualTo(
-        (long) 1);
-    assertThat(countFrames(logs, "FINE: >> 0x00000000     8 PING          ACK")).isEqualTo(
-        (long) 1);
-    assertThat(countFrames(logs, "FINE: << 0x00000000     8 PING          ACK")).isEqualTo(
-        (long) 1);
-  }
-
-  @Flaky
-  @Test public void missingPongsFailsConnection() throws Exception {
-    if (protocol == Protocol.HTTP_2) {
-      // https://github.com/square/okhttp/issues/5221
-      platform.expectFailureFromJdkVersion(12);
-    }
-
-    // Ping every 500 ms, starting at 500 ms.
-    client = client.newBuilder()
-        .readTimeout(10, TimeUnit.SECONDS) // Confirm we fail before the read timeout.
-        .pingInterval(500, TimeUnit.MILLISECONDS)
-        .build();
-
-    // Set up the server to ignore the socket. It won't respond to pings!
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.STALL_SOCKET_AT_START));
-
-    // Make a call. It'll fail as soon as our pings detect a problem.
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    long executeAtNanos = System.nanoTime();
-    try {
-      call.execute();
-      fail();
-    } catch (StreamResetException expected) {
-      assertThat(expected.getMessage()).isEqualTo(
-          "stream was reset: PROTOCOL_ERROR");
-    }
-
-    long elapsedUntilFailure = System.nanoTime() - executeAtNanos;
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure)).isCloseTo(
-        (double) 1000, offset(250d));
-
-    // Confirm a single ping was sent but not acknowledged.
-    List<String> logs = http2Handler.takeAll();
-    assertThat(countFrames(logs, "FINE: >> 0x00000000     8 PING          ")).isEqualTo(
-        (long) 1);
-    assertThat(countFrames(logs, "FINE: << 0x00000000     8 PING          ACK")).isEqualTo(
-        (long) 0);
-  }
-
-  private String firstFrame(List<String> logs, String type) {
-    for (String log : logs) {
-      if (log.contains(type)) {
-        return log;
-      }
-    }
-    return null;
-  }
-
-  private int countFrames(List<String> logs, String message) {
-    int result = 0;
-    for (String log : logs) {
-      if (log.equals(message)) {
-        result++;
-      }
-    }
-    return result;
-  }
-
-  /**
-   * Push a setting that permits up to 2 concurrent streams, then make 3 concurrent requests and
-   * confirm that the third concurrent request prepared a new connection.
-   */
-  @Test public void settingsLimitsMaxConcurrentStreams() throws Exception {
-    Settings settings = new Settings();
-    settings.set(Settings.MAX_CONCURRENT_STREAMS, 2);
-
-    // Read & write a full request to confirm settings are accepted.
-    server.enqueue(new MockResponse().withSettings(settings));
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertThat(response.body().string()).isEqualTo("");
-
-    server.enqueue(new MockResponse()
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-    server.enqueue(new MockResponse()
-        .setBody("GHI"));
-
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-
-    Call call3 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response3 = call3.execute();
-
-    assertThat(response1.body().string()).isEqualTo("ABC");
-    assertThat(response2.body().string()).isEqualTo("DEF");
-    assertThat(response3.body().string()).isEqualTo("GHI");
-    // Settings connection.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    // Reuse settings connection.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(1);
-    // Reuse settings connection.
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(2);
-    // New connection!
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Test public void connectionNotReusedAfterShutdown() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-    assertThat(response1.body().string()).isEqualTo("ABC");
-
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    assertThat(response2.body().string()).isEqualTo("DEF");
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  /**
-   * This simulates a race condition where we receive a healthy HTTP/2 connection and just prior to
-   * writing our request, we get a GOAWAY frame from the server.
-   */
-  @Test public void connectionShutdownAfterHealthCheck() throws Exception {
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setBody("DEF"));
-
-    OkHttpClient client2 = client.newBuilder()
-        .addNetworkInterceptor(new Interceptor() {
-          boolean executedCall;
-
-          @Override public Response intercept(Chain chain) throws IOException {
-            if (!executedCall) {
-              // At this point, we have a healthy HTTP/2 connection. This call will trigger the
-              // server to send a GOAWAY frame, leaving the connection in a shutdown state.
-              executedCall = true;
-              Call call = client.newCall(new Request.Builder()
-                  .url(server.url("/"))
-                  .build());
-              Response response = call.execute();
-              assertThat(response.body().string()).isEqualTo("ABC");
-              // Wait until the GOAWAY has been processed.
-              RealConnection connection = (RealConnection) chain.connection();
-              while (connection.isHealthy(false)) ;
-            }
-            return chain.proceed(chain.request());
-          }
-        })
-        .build();
-
-    Call call = client2.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response = call.execute();
-    assertThat(response.body().string()).isEqualTo("DEF");
-
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(server.takeRequest().getSequenceNumber()).isEqualTo(0);
-  }
-
-  @Flaky
-  @Test public void responseHeadersAfterGoaway() throws Exception {
-    // Flaky https://github.com/square/okhttp/issues/4836
-    server.enqueue(new MockResponse()
-        .setHeadersDelay(1, SECONDS)
-        .setBody("ABC"));
-    server.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setBody("DEF"));
-
-    BlockingQueue<String> bodies = new LinkedBlockingQueue<>();
-    Callback callback = new Callback() {
-      @Override public void onResponse(Call call, Response response) throws IOException {
-        bodies.add(response.body().string());
-      }
-
-      @Override public void onFailure(Call call, IOException e) {
-        System.out.println(e);
-      }
-    };
-    client.newCall(new Request.Builder().url(server.url("/")).build()).enqueue(callback);
-    client.newCall(new Request.Builder().url(server.url("/")).build()).enqueue(callback);
-
-    assertThat(bodies.poll(2, SECONDS)).isEqualTo("DEF");
-    assertThat(bodies.poll(2, SECONDS)).isEqualTo("ABC");
-    assertThat(server.getRequestCount()).isEqualTo(2);
-  }
-
-  /**
-   * We don't know if the connection will support HTTP/2 until after we've connected. When multiple
-   * connections are requested concurrently OkHttp will pessimistically connect multiple times, then
-   * close any unnecessary connections. This test confirms that behavior works as intended.
-   *
-   * <p>This test uses proxy tunnels to get a hook while a connection is being established.
-   */
-  @Test public void concurrentHttp2ConnectionsDeduplicated() throws Exception {
-    assumeTrue(protocol == Protocol.HTTP_2);
-
-    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
-
-    QueueDispatcher queueDispatcher = new QueueDispatcher();
-    queueDispatcher.enqueueResponse(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    queueDispatcher.enqueueResponse(new MockResponse()
-        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
-        .clearHeaders());
-    queueDispatcher.enqueueResponse(new MockResponse()
-        .setBody("call2 response"));
-    queueDispatcher.enqueueResponse(new MockResponse()
-        .setBody("call1 response"));
-
-    // We use a re-entrant dispatcher to initiate one HTTPS connection while the other is in flight.
-    server.setDispatcher(new Dispatcher() {
-      int requestCount;
-
-      @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
-        MockResponse result = queueDispatcher.dispatch(request);
-
-        requestCount++;
-        if (requestCount == 1) {
-          // Before handling call1's CONNECT we do all of call2. This part re-entrant!
-          try {
-            Call call2 = client.newCall(new Request.Builder()
-                .url("https://android.com/call2")
-                .build());
-            Response response2 = call2.execute();
-            assertThat(response2.body().string()).isEqualTo("call2 response");
-          } catch (IOException e) {
-            throw new RuntimeException(e);
-          }
-        }
-
-        return result;
-      }
-
-      @Override public MockResponse peek() {
-        return queueDispatcher.peek();
-      }
-
-      @Override public void shutdown() {
-        queueDispatcher.shutdown();
-      }
-    });
-
-    client = client.newBuilder()
-        .proxy(server.toProxyAddress())
-        .build();
-
-    Call call1 = client.newCall(new Request.Builder()
-        .url("https://android.com/call1")
-        .build());
-    Response response2 = call1.execute();
-    assertThat(response2.body().string()).isEqualTo("call1 response");
-
-    RecordedRequest call1Connect = server.takeRequest();
-    assertThat(call1Connect.getMethod()).isEqualTo("CONNECT");
-    assertThat(call1Connect.getSequenceNumber()).isEqualTo(0);
-
-    RecordedRequest call2Connect = server.takeRequest();
-    assertThat(call2Connect.getMethod()).isEqualTo("CONNECT");
-    assertThat(call2Connect.getSequenceNumber()).isEqualTo(0);
-
-    RecordedRequest call2Get = server.takeRequest();
-    assertThat(call2Get.getMethod()).isEqualTo("GET");
-    assertThat(call2Get.getPath()).isEqualTo("/call2");
-    assertThat(call2Get.getSequenceNumber()).isEqualTo(0);
-
-    RecordedRequest call1Get = server.takeRequest();
-    assertThat(call1Get.getMethod()).isEqualTo("GET");
-    assertThat(call1Get.getPath()).isEqualTo("/call1");
-    assertThat(call1Get.getSequenceNumber()).isEqualTo(1);
-
-    assertThat(client.connectionPool().connectionCount()).isEqualTo(1);
-  }
-
-  /** https://github.com/square/okhttp/issues/3103 */
-  @Test public void domainFronting() throws Exception {
-    client = client.newBuilder()
-        .addNetworkInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
-            Request request = chain.request().newBuilder()
-                .header("Host", "privateobject.com")
-                .build();
-            return chain.proceed(request);
-          }
-        })
-        .build();
-
-    server.enqueue(new MockResponse());
-
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-
-    Response response = call.execute();
-    assertThat(response.body().string()).isEqualTo("");
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getHeader(":authority")).isEqualTo(
-        "privateobject.com");
-  }
-
-  private Buffer gzip(String bytes) throws IOException {
-    Buffer bytesOut = new Buffer();
-    BufferedSink sink = Okio.buffer(new GzipSink(bytesOut));
-    sink.writeUtf8(bytes);
-    sink.close();
-    return bytesOut;
-  }
-
-  class AsyncRequest implements Runnable {
-    String path;
-    CountDownLatch countDownLatch;
-
-    AsyncRequest(String path, CountDownLatch countDownLatch) {
-      this.path = path;
-      this.countDownLatch = countDownLatch;
-    }
-
-    @Override public void run() {
-      try {
-        Call call = client.newCall(new Request.Builder()
-            .url(server.url(path))
-            .build());
-        Response response = call.execute();
-        assertThat(response.body().string()).isEqualTo("A");
-        countDownLatch.countDown();
-      } catch (Exception e) {
-        throw new RuntimeException(e);
-      }
-    }
-  }
-
-  /** https://github.com/square/okhttp/issues/4875 */
-  @Test
-  public void shutdownAfterLateCoalescing() throws Exception {
-    CountDownLatch latch = new CountDownLatch(2);
-
-    Callback callback = new Callback() {
-      @Override public void onResponse(Call call, Response response) {
-        fail();
-      }
-
-      @Override public void onFailure(Call call, IOException e) {
-        latch.countDown();
-      }
-    };
-
-    client = client.newBuilder().eventListener(new EventListener() {
-      int callCount;
-
-      @Override public void connectionAcquired(Call call, Connection connection) {
-        try {
-          if (callCount++ == 1) {
-            server.shutdown();
-          }
-        } catch (IOException e) {
-          fail();
-        }
-      }
-    }).build();
-
-    client.newCall(new Request.Builder().url(server.url("")).build()).enqueue(callback);
-    client.newCall(new Request.Builder().url(server.url("")).build()).enqueue(callback);
-
-    latch.await();
-  }
-
-  @Test public void cancelWhileWritingRequestBodySendsCancelToServer() throws Exception {
-    server.enqueue(new MockResponse());
-
-    AtomicReference<Call> callReference = new AtomicReference<>();
-    Call call = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .post(new RequestBody() {
-          @Override public @Nullable MediaType contentType() {
-            return MediaType.get("text/plain; charset=utf-8");
-          }
-
-          @Override public void writeTo(BufferedSink sink) {
-            callReference.get().cancel();
-          }
-        })
-        .build());
-    callReference.set(call);
-
-    try {
-      call.execute();
-      fail();
-    } catch (IOException expected) {
-      assertThat(call.isCanceled()).isTrue();
-    }
-
-    RecordedRequest recordedRequest = server.takeRequest();
-    assertThat(recordedRequest.getFailure()).hasMessage("stream was reset: CANCEL");
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/http2/HuffmanTest.java b/okhttp/src/test/java/okhttp3/internal/http2/HuffmanTest.java
deleted file mode 100644
index 6e027caa56..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/http2/HuffmanTest.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright 2013 Twitter, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.io.IOException;
-import java.util.Random;
-import okio.Buffer;
-import okio.ByteString;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.assertEquals;
-
-/** Original version of this class was lifted from {@code com.twitter.hpack.HuffmanTest}. */
-public final class HuffmanTest {
-  @Test public void roundTripForRequestAndResponse() throws IOException {
-    String s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
-    for (int i = 0; i < s.length(); i++) {
-      assertRoundTrip(ByteString.encodeUtf8(s.substring(0, i)));
-    }
-
-    Random random = new Random(123456789L);
-    byte[] buf = new byte[4096];
-    random.nextBytes(buf);
-    assertRoundTrip(ByteString.of(buf));
-  }
-
-  private void assertRoundTrip(ByteString data) throws IOException {
-    Buffer encodeBuffer = new Buffer();
-    Huffman.INSTANCE.encode(data, encodeBuffer);
-    assertThat(Huffman.INSTANCE.encodedLength(data)).isEqualTo(encodeBuffer.size());
-
-    Buffer decodeBuffer = new Buffer();
-    Huffman.INSTANCE.decode(encodeBuffer, encodeBuffer.size(), decodeBuffer);
-    assertEquals(data, decodeBuffer.readByteString());
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java b/okhttp/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
deleted file mode 100644
index a773bf1948..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
+++ /dev/null
@@ -1,313 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package okhttp3.internal.http2;
-
-import java.io.Closeable;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.InetSocketAddress;
-import java.net.ServerSocket;
-import java.net.Socket;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.logging.Logger;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Okio;
-
-import static okhttp3.internal.Util.closeQuietly;
-
-/** Replays prerecorded outgoing frames and records incoming frames. */
-public final class MockHttp2Peer implements Closeable {
-  private static final Logger logger = Logger.getLogger(MockHttp2Peer.class.getName());
-
-  private int frameCount = 0;
-  private boolean client = false;
-  private final Buffer bytesOut = new Buffer();
-  private Http2Writer writer = new Http2Writer(bytesOut, client);
-  private final List<OutFrame> outFrames = new ArrayList<>();
-  private final BlockingQueue<InFrame> inFrames = new LinkedBlockingQueue<>();
-  private int port;
-  private final ExecutorService executor = Executors.newSingleThreadExecutor(
-      Util.threadFactory("MockHttp2Peer", false));
-  private ServerSocket serverSocket;
-  private Socket socket;
-
-  public void setClient(boolean client) {
-    if (this.client == client) {
-      return;
-    }
-    this.client = client;
-    this.writer = new Http2Writer(bytesOut, client);
-  }
-
-  public void acceptFrame() {
-    frameCount++;
-  }
-
-  /** Maximum length of an outbound data frame. */
-  public int maxOutboundDataLength() {
-    return writer.maxDataLength();
-  }
-
-  /** Count of frames sent or received. */
-  public int frameCount() {
-    return frameCount;
-  }
-
-  public Http2Writer sendFrame() {
-    outFrames.add(new OutFrame(frameCount++, bytesOut.size(), false));
-    return writer;
-  }
-
-  /**
-   * Shortens the last frame from its original length to {@code length}. This will cause the peer to
-   * close the socket as soon as this frame has been written; otherwise the peer stays open until
-   * explicitly closed.
-   */
-  public Http2Writer truncateLastFrame(int length) {
-    OutFrame lastFrame = outFrames.remove(outFrames.size() - 1);
-    if (length >= bytesOut.size() - lastFrame.start) throw new IllegalArgumentException();
-
-    // Move everything from bytesOut into a new buffer.
-    Buffer fullBuffer = new Buffer();
-    bytesOut.read(fullBuffer, bytesOut.size());
-
-    // Copy back all but what we're truncating.
-    fullBuffer.read(bytesOut, lastFrame.start + length);
-
-    outFrames.add(new OutFrame(lastFrame.sequence, lastFrame.start, true));
-    return writer;
-  }
-
-  public InFrame takeFrame() throws Exception {
-    return inFrames.take();
-  }
-
-  public void play() throws IOException {
-    if (serverSocket != null) throw new IllegalStateException();
-    serverSocket = new ServerSocket();
-    serverSocket.setReuseAddress(false);
-    serverSocket.bind(new InetSocketAddress("localhost", 0), 1);
-    port = serverSocket.getLocalPort();
-    executor.execute(() -> {
-      try {
-        readAndWriteFrames();
-      } catch (IOException e) {
-        closeQuietly(MockHttp2Peer.this);
-        logger.info(MockHttp2Peer.this + " done: " + e.getMessage());
-      }
-    });
-  }
-
-  private void readAndWriteFrames() throws IOException {
-    if (socket != null) throw new IllegalStateException();
-    socket = serverSocket.accept();
-
-    // Bail out now if this instance was closed while waiting for the socket to accept.
-    synchronized (this) {
-      if (executor.isShutdown()) {
-        socket.close();
-        return;
-      }
-    }
-
-    OutputStream out = socket.getOutputStream();
-    InputStream in = socket.getInputStream();
-    Http2Reader reader = new Http2Reader(Okio.buffer(Okio.source(in)), client);
-
-    Iterator<OutFrame> outFramesIterator = outFrames.iterator();
-    byte[] outBytes = bytesOut.readByteArray();
-    OutFrame nextOutFrame = null;
-
-    for (int i = 0; i < frameCount; i++) {
-      if (nextOutFrame == null && outFramesIterator.hasNext()) {
-        nextOutFrame = outFramesIterator.next();
-      }
-
-      if (nextOutFrame != null && nextOutFrame.sequence == i) {
-        long start = nextOutFrame.start;
-        boolean truncated;
-        long end;
-        if (outFramesIterator.hasNext()) {
-          nextOutFrame = outFramesIterator.next();
-          end = nextOutFrame.start;
-          truncated = false;
-        } else {
-          end = outBytes.length;
-          truncated = nextOutFrame.truncated;
-        }
-
-        // Write a frame.
-        int length = (int) (end - start);
-        out.write(outBytes, (int) start, length);
-
-        // If the last frame was truncated, immediately close the connection.
-        if (truncated) {
-          socket.close();
-        }
-      } else {
-        // read a frame
-        InFrame inFrame = new InFrame(i, reader);
-        reader.nextFrame(false, inFrame);
-        inFrames.add(inFrame);
-      }
-    }
-  }
-
-  public Socket openSocket() throws IOException {
-    return new Socket("localhost", port);
-  }
-
-  @Override public synchronized void close() throws IOException {
-    executor.shutdown();
-    if (socket != null) {
-      closeQuietly(socket);
-    }
-    if (serverSocket != null) {
-      closeQuietly(serverSocket);
-    }
-  }
-
-  @Override public String toString() {
-    return "MockHttp2Peer[" + port + "]";
-  }
-
-  private static class OutFrame {
-    private final int sequence;
-    private final long start;
-    private final boolean truncated;
-
-    private OutFrame(int sequence, long start, boolean truncated) {
-      this.sequence = sequence;
-      this.start = start;
-      this.truncated = truncated;
-    }
-  }
-
-  public static class InFrame implements Http2Reader.Handler {
-    public final int sequence;
-    public final Http2Reader reader;
-    public int type = -1;
-    public boolean clearPrevious;
-    public boolean outFinished;
-    public boolean inFinished;
-    public int streamId;
-    public int associatedStreamId;
-    public ErrorCode errorCode;
-    public long windowSizeIncrement;
-    public List<Header> headerBlock;
-    public byte[] data;
-    public Settings settings;
-    public boolean ack;
-    public int payload1;
-    public int payload2;
-
-    public InFrame(int sequence, Http2Reader reader) {
-      this.sequence = sequence;
-      this.reader = reader;
-    }
-
-    @Override public void settings(boolean clearPrevious, Settings settings) {
-      if (this.type != -1) throw new IllegalStateException();
-      this.type = Http2.TYPE_SETTINGS;
-      this.clearPrevious = clearPrevious;
-      this.settings = settings;
-    }
-
-    @Override public void ackSettings() {
-      if (this.type != -1) throw new IllegalStateException();
-      this.type = Http2.TYPE_SETTINGS;
-      this.ack = true;
-    }
-
-    @Override public void headers(boolean inFinished, int streamId,
-        int associatedStreamId, List<Header> headerBlock) {
-      if (this.type != -1) throw new IllegalStateException();
-      this.type = Http2.TYPE_HEADERS;
-      this.inFinished = inFinished;
-      this.streamId = streamId;
-      this.associatedStreamId = associatedStreamId;
-      this.headerBlock = headerBlock;
-    }
-
-    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
-        throws IOException {
-      if (this.type != -1) throw new IllegalStateException();
-      this.type = Http2.TYPE_DATA;
-      this.inFinished = inFinished;
-      this.streamId = streamId;
-      this.data = source.readByteString(length).toByteArray();
-    }
-
-    @Override public void rstStream(int streamId, ErrorCode errorCode) {
-      if (this.type != -1) throw new IllegalStateException();
-      this.type = Http2.TYPE_RST_STREAM;
-      this.streamId = streamId;
-      this.errorCode = errorCode;
-    }
-
-    @Override public void ping(boolean ack, int payload1, int payload2) {
-      if (this.type != -1) throw new IllegalStateException();
-      this.type = Http2.TYPE_PING;
-      this.ack = ack;
-      this.payload1 = payload1;
-      this.payload2 = payload2;
-    }
-
-    @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
-      if (this.type != -1) throw new IllegalStateException();
-      this.type = Http2.TYPE_GOAWAY;
-      this.streamId = lastGoodStreamId;
-      this.errorCode = errorCode;
-      this.data = debugData.toByteArray();
-    }
-
-    @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
-      if (this.type != -1) throw new IllegalStateException();
-      this.type = Http2.TYPE_WINDOW_UPDATE;
-      this.streamId = streamId;
-      this.windowSizeIncrement = windowSizeIncrement;
-    }
-
-    @Override public void priority(int streamId, int streamDependency, int weight,
-        boolean exclusive) {
-      throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public void pushPromise(int streamId, int associatedStreamId, List<Header> headerBlock) {
-      this.type = Http2.TYPE_PUSH_PROMISE;
-      this.streamId = streamId;
-      this.associatedStreamId = associatedStreamId;
-      this.headerBlock = headerBlock;
-    }
-
-    @Override public void alternateService(int streamId, String origin, ByteString protocol,
-        String host, int port, long maxAge) {
-      throw new UnsupportedOperationException();
-    }
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/http2/SettingsTest.java b/okhttp/src/test/java/okhttp3/internal/http2/SettingsTest.java
deleted file mode 100644
index 55cbfc3c10..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/http2/SettingsTest.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import org.junit.Test;
-
-import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
-import static okhttp3.internal.http2.Settings.MAX_CONCURRENT_STREAMS;
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class SettingsTest {
-  @Test public void unsetField() {
-    Settings settings = new Settings();
-    assertThat(settings.isSet(MAX_CONCURRENT_STREAMS)).isFalse();
-    assertThat(settings.getMaxConcurrentStreams()).isEqualTo(Integer.MAX_VALUE);
-  }
-
-  @Test public void setFields() {
-    Settings settings = new Settings();
-
-    settings.set(Settings.HEADER_TABLE_SIZE, 8096);
-    assertThat(settings.getHeaderTableSize()).isEqualTo(8096);
-
-    assertThat(settings.getEnablePush(true)).isTrue();
-    settings.set(Settings.ENABLE_PUSH, 1);
-    assertThat(settings.getEnablePush(false)).isTrue();
-    settings.clear();
-
-    assertThat(settings.getMaxConcurrentStreams()).isEqualTo(Integer.MAX_VALUE);
-    settings.set(MAX_CONCURRENT_STREAMS, 75);
-    assertThat(settings.getMaxConcurrentStreams()).isEqualTo(75);
-
-    settings.clear();
-    assertThat(settings.getMaxFrameSize(16384)).isEqualTo(16384);
-    settings.set(Settings.MAX_FRAME_SIZE, 16777215);
-    assertThat(settings.getMaxFrameSize(16384)).isEqualTo(16777215);
-
-    assertThat(settings.getMaxHeaderListSize(-1)).isEqualTo(-1);
-    settings.set(Settings.MAX_HEADER_LIST_SIZE, 16777215);
-    assertThat(settings.getMaxHeaderListSize(-1)).isEqualTo(16777215);
-
-    assertThat(settings.getInitialWindowSize()).isEqualTo(
-        DEFAULT_INITIAL_WINDOW_SIZE);
-    settings.set(Settings.INITIAL_WINDOW_SIZE, 108);
-    assertThat(settings.getInitialWindowSize()).isEqualTo(108);
-  }
-
-  @Test public void merge() {
-    Settings a = new Settings();
-    a.set(Settings.HEADER_TABLE_SIZE, 10000);
-    a.set(Settings.MAX_HEADER_LIST_SIZE, 20000);
-    a.set(Settings.INITIAL_WINDOW_SIZE, 30000);
-
-    Settings b = new Settings();
-    b.set(Settings.MAX_HEADER_LIST_SIZE, 40000);
-    b.set(Settings.INITIAL_WINDOW_SIZE, 50000);
-    b.set(Settings.MAX_CONCURRENT_STREAMS, 60000);
-
-    a.merge(b);
-    assertThat(a.getHeaderTableSize()).isEqualTo(10000);
-    assertThat(a.getMaxHeaderListSize(-1)).isEqualTo(40000);
-    assertThat(a.getInitialWindowSize()).isEqualTo(50000);
-    assertThat(a.getMaxConcurrentStreams()).isEqualTo(60000);
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/io/FaultyFileSystem.java b/okhttp/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
deleted file mode 100644
index bc0263d830..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.io;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.util.LinkedHashSet;
-import java.util.Set;
-import okio.Buffer;
-import okio.ForwardingSink;
-import okio.Sink;
-import okio.Source;
-
-public final class FaultyFileSystem implements FileSystem {
-  private final FileSystem delegate;
-  private final Set<File> writeFaults = new LinkedHashSet<>();
-  private final Set<File> deleteFaults = new LinkedHashSet<>();
-  private final Set<File> renameFaults = new LinkedHashSet<>();
-
-  public FaultyFileSystem(FileSystem delegate) {
-    this.delegate = delegate;
-  }
-
-  public void setFaultyWrite(File file, boolean faulty) {
-    if (faulty) {
-      writeFaults.add(file);
-    } else {
-      writeFaults.remove(file);
-    }
-  }
-
-  public void setFaultyDelete(File file, boolean faulty) {
-    if (faulty) {
-      deleteFaults.add(file);
-    } else {
-      deleteFaults.remove(file);
-    }
-  }
-
-  public void setFaultyRename(File file, boolean faulty) {
-    if (faulty) {
-      renameFaults.add(file);
-    } else {
-      renameFaults.remove(file);
-    }
-  }
-
-  @Override public Source source(File file) throws FileNotFoundException {
-    return delegate.source(file);
-  }
-
-  @Override public Sink sink(File file) throws FileNotFoundException {
-    return new FaultySink(delegate.sink(file), file);
-  }
-
-  @Override public Sink appendingSink(File file) throws FileNotFoundException {
-    return new FaultySink(delegate.appendingSink(file), file);
-  }
-
-  @Override public void delete(File file) throws IOException {
-    if (deleteFaults.contains(file)) throw new IOException("boom!");
-    delegate.delete(file);
-  }
-
-  @Override public boolean exists(File file) {
-    return delegate.exists(file);
-  }
-
-  @Override public long size(File file) {
-    return delegate.size(file);
-  }
-
-  @Override public void rename(File from, File to) throws IOException {
-    if (renameFaults.contains(from) || renameFaults.contains(to)) throw new IOException("boom!");
-    delegate.rename(from, to);
-  }
-
-  @Override public void deleteContents(File directory) throws IOException {
-    if (deleteFaults.contains(directory)) throw new IOException("boom!");
-    delegate.deleteContents(directory);
-  }
-
-  private class FaultySink extends ForwardingSink {
-    private final File file;
-
-    public FaultySink(Sink delegate, File file) {
-      super(delegate);
-      this.file = file;
-    }
-
-    @Override public void write(Buffer source, long byteCount) throws IOException {
-      if (writeFaults.contains(file)) throw new IOException("boom!");
-      super.write(source, byteCount);
-    }
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatformTest.java b/okhttp/src/test/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatformTest.java
deleted file mode 100644
index e738f07814..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/platform/Jdk8WithJettyBootPlatformTest.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.platform;
-
-import okhttp3.testing.PlatformRule;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static org.assertj.core.api.Java6Assertions.assertThat;
-import static org.junit.Assume.assumeFalse;
-import static org.junit.Assume.assumeTrue;
-
-public class Jdk8WithJettyBootPlatformTest {
-  @Rule public final PlatformRule platform = new PlatformRule();
-
-  @Test
-  public void testBuildsWithJettyBoot() {
-    assumeTrue(System.getProperty("java.specification.version").equals("1.8"));
-    platform.assumeJettyBootEnabled();
-
-    assertThat(Jdk8WithJettyBootPlatform.Companion.buildIfSupported()).isNotNull();
-  }
-
-  @Test
-  public void testNotBuildWithOther() {
-    assumeFalse(System.getProperty("java.specification.version").equals("1.8"));
-
-    assertThat(Jdk8WithJettyBootPlatform.Companion.buildIfSupported()).isNull();
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java b/okhttp/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
deleted file mode 100644
index 6c1fa33a50..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/platform/Jdk9PlatformTest.java
+++ /dev/null
@@ -1,36 +0,0 @@
-///*
-// * Copyright (C) 2016 Square, Inc.
-// *
-// * Licensed under the Apache License, Version 2.0 (the "License");
-// * you may not use this file except in compliance with the License.
-// * You may obtain a copy of the License at
-// *
-// *      http://www.apache.org/licenses/LICENSE-2.0
-// *
-// * Unless required by applicable law or agreed to in writing, software
-// * distributed under the License is distributed on an "AS IS" BASIS,
-// * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// * See the License for the specific language governing permissions and
-// * limitations under the License.
-// */
-//package okhttp3.internal.platform;
-//
-//import okhttp3.testing.PlatformRule;
-//import org.junit.Rule;
-//import org.junit.Test;
-//
-//import static org.assertj.core.api.Assertions.assertThat;
-//
-//public class Jdk9PlatformTest {
-//  @Rule public final PlatformRule platform = new PlatformRule("jdk9");
-//
-//  @Test
-//  public void buildsWhenJdk9() {
-//    assertThat(Jdk9Platform.Companion.buildIfSupported()).isNotNull();
-//  }
-//
-//  @Test
-//  public void testToStringIsClassname() throws NoSuchMethodException {
-//    assertThat(new Jdk9Platform().toString()).isEqualTo("Jdk9Platform");
-//  }
-//}
diff --git a/okhttp/src/test/java/okhttp3/internal/platform/PlatformTest.java b/okhttp/src/test/java/okhttp3/internal/platform/PlatformTest.java
deleted file mode 100644
index f2dc6ef4c9..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/platform/PlatformTest.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.platform;
-
-import okhttp3.testing.PlatformRule;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public class PlatformTest {
-  @Rule
-  public PlatformRule platform = new PlatformRule();
-
-  @Test public void alwaysBuilds() {
-    new Platform();
-  }
-
-  /** Guard against the default value changing by accident. */
-  @Test public void defaultPrefix() {
-    assertThat(new Platform().getPrefix()).isEqualTo("OkHttp");
-  }
-
-  public static String getJvmSpecVersion() {
-    return System.getProperty("java.specification.version", "unknown");
-  }
-
-  @Test
-  public void testToStringIsClassname() {
-    assertThat(new Platform().toString()).isEqualTo("Platform");
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/platform/android/AndroidSocketAdapterTest.kt b/okhttp/src/test/java/okhttp3/internal/platform/android/AndroidSocketAdapterTest.kt
deleted file mode 100644
index 534d413f6a..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/platform/android/AndroidSocketAdapterTest.kt
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Copyright (C) 2019 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.platform.android
-
-import okhttp3.DelegatingSSLSocket
-import okhttp3.DelegatingSSLSocketFactory
-import okhttp3.Protocol.HTTP_1_1
-import okhttp3.Protocol.HTTP_2
-import okhttp3.testing.PlatformRule
-import org.conscrypt.Conscrypt
-import org.junit.Assert.assertFalse
-import org.junit.Assert.assertNotNull
-import org.junit.Assert.assertNull
-import org.junit.Assert.assertTrue
-import org.junit.Assume.assumeFalse
-import org.junit.Assume.assumeTrue
-import org.junit.Rule
-import org.junit.Test
-import org.junit.runner.RunWith
-import org.junit.runners.Parameterized
-import java.security.Provider
-import javax.net.ssl.SSLContext
-import javax.net.ssl.SSLSocket
-
-@RunWith(Parameterized::class)
-class AndroidSocketAdapterTest(private val adapter: SocketAdapter) {
-  @Suppress("RedundantVisibilityModifier")
-  @JvmField
-  @Rule
-  public val platform = PlatformRule.conscrypt()
-
-  val context by lazy {
-    val provider: Provider = Conscrypt.newProviderBuilder().provideTrustManager(true).build()
-
-    SSLContext.getInstance("TLS", provider).apply {
-      init(null, null, null)
-    }
-  }
-
-  @Test
-  fun testMatchesSupportedSocket() {
-    val socketFactory = context.socketFactory
-
-    val sslSocket = socketFactory.createSocket() as SSLSocket
-    assertTrue(adapter.matchesSocket(sslSocket))
-
-    adapter.configureTlsExtensions(sslSocket, listOf(HTTP_2, HTTP_1_1))
-    // not connected
-    assertNull(adapter.getSelectedProtocol(sslSocket))
-  }
-
-  @Test
-  fun testMatchesSupportedAndroidSocketFactory() {
-    assumeTrue(adapter is StandardAndroidSocketAdapter)
-
-    assertTrue(adapter.matchesSocketFactory(context.socketFactory))
-    assertNotNull(adapter.trustManager(context.socketFactory))
-  }
-
-  @Test
-  fun testDoesntMatchSupportedCustomSocketFactory() {
-    assumeFalse(adapter is StandardAndroidSocketAdapter)
-
-    assertFalse(adapter.matchesSocketFactory(context.socketFactory))
-    assertNull(adapter.trustManager(context.socketFactory))
-  }
-
-  @Test
-  fun testCustomSocket() {
-    val socketFactory = DelegatingSSLSocketFactory(context.socketFactory)
-
-    assertFalse(adapter.matchesSocketFactory(socketFactory))
-
-    val sslSocket =
-        object : DelegatingSSLSocket(context.socketFactory.createSocket() as SSLSocket) {}
-    assertFalse(adapter.matchesSocket(sslSocket))
-
-    adapter.configureTlsExtensions(sslSocket, listOf(HTTP_2, HTTP_1_1))
-    // not connected
-    assertNull(adapter.getSelectedProtocol(sslSocket))
-  }
-
-  companion object {
-    @JvmStatic
-    @Parameterized.Parameters(name = "{0}")
-    fun data(): Collection<SocketAdapter> {
-      return listOfNotNull(
-          ConscryptSocketAdapter.buildIfSupported(),
-          DeferredSocketAdapter("org.conscrypt"),
-          AndroidSocketAdapter.buildIfSupported("org.conscrypt"),
-          StandardAndroidSocketAdapter.buildIfSupported("org.conscrypt")
-      )
-    }
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java b/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
deleted file mode 100644
index 46a107e46f..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
+++ /dev/null
@@ -1,287 +0,0 @@
-/*
- * Copyright (C) 2017 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.publicsuffix;
-
-import java.io.IOException;
-import java.io.InputStream;
-import okio.Buffer;
-import okio.BufferedSource;
-import okio.GzipSource;
-import okio.Okio;
-import org.junit.Test;
-
-import static okhttp3.internal.HostnamesKt.toCanonicalHost;
-import static okhttp3.internal.publicsuffix.PublicSuffixDatabase.PUBLIC_SUFFIX_RESOURCE;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class PublicSuffixDatabaseTest {
-  private final PublicSuffixDatabase publicSuffixDatabase = new PublicSuffixDatabase();
-
-  @Test public void longestMatchWins() {
-    Buffer buffer = new Buffer()
-        .writeUtf8("com\n")
-        .writeUtf8("my.square.com\n")
-        .writeUtf8("square.com\n");
-    publicSuffixDatabase.setListBytes(buffer.readByteArray(), new byte[]{});
-
-    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("example.com")).isEqualTo(
-        "example.com");
-    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("foo.example.com")).isEqualTo(
-        "example.com");
-    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("foo.bar.square.com")).isEqualTo(
-        "bar.square.com");
-    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.com")).isEqualTo(
-        "foo.my.square.com");
-  }
-
-  @Test public void wildcardMatch() {
-    Buffer buffer = new Buffer()
-        .writeUtf8("*.square.com\n")
-        .writeUtf8("com\n")
-        .writeUtf8("example.com\n");
-    publicSuffixDatabase.setListBytes(buffer.readByteArray(), new byte[]{});
-
-    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("my.square.com")).isNull();
-    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.com")).isEqualTo(
-        "foo.my.square.com");
-    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("bar.foo.my.square.com")).isEqualTo(
-        "foo.my.square.com");
-  }
-
-  @Test public void boundarySearches() {
-    Buffer buffer = new Buffer()
-        .writeUtf8("bbb\n")
-        .writeUtf8("ddd\n")
-        .writeUtf8("fff\n");
-    publicSuffixDatabase.setListBytes(buffer.readByteArray(), new byte[]{});
-
-    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("aaa")).isNull();
-    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("ggg")).isNull();
-    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("ccc")).isNull();
-    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("eee")).isNull();
-  }
-
-  @Test public void exceptionRule() {
-    Buffer exception = new Buffer()
-        .writeUtf8("my.square.jp\n");
-    Buffer buffer = new Buffer()
-        .writeUtf8("*.jp\n")
-        .writeUtf8("*.square.jp\n")
-        .writeUtf8("example.com\n")
-        .writeUtf8("square.com\n");
-    publicSuffixDatabase.setListBytes(buffer.readByteArray(), exception.readByteArray());
-
-    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("my.square.jp")).isEqualTo(
-        "my.square.jp");
-    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.jp")).isEqualTo(
-        "my.square.jp");
-    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("my1.square.jp")).isNull();
-  }
-
-  @Test public void noEffectiveTldPlusOne() {
-    Buffer exception = new Buffer()
-        .writeUtf8("my.square.jp\n");
-    Buffer buffer = new Buffer()
-        .writeUtf8("*.jp\n")
-        .writeUtf8("*.square.jp\n")
-        .writeUtf8("example.com\n")
-        .writeUtf8("square.com\n");
-    publicSuffixDatabase.setListBytes(buffer.readByteArray(), exception.readByteArray());
-
-    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("example.com")).isNull();
-    assertThat(publicSuffixDatabase.getEffectiveTldPlusOne("foo.square.jp")).isNull();
-  }
-
-  @Test public void allPublicSuffixes() throws IOException {
-    InputStream resource = PublicSuffixDatabaseTest.class
-        .getResourceAsStream(PUBLIC_SUFFIX_RESOURCE);
-    BufferedSource source = Okio.buffer(new GzipSource(Okio.source(resource)));
-    int length = source.readInt();
-    Buffer buffer = new Buffer();
-    buffer.write(source, length);
-    resource.close();
-
-    while (!buffer.exhausted()) {
-      String publicSuffix = buffer.readUtf8LineStrict();
-      if (publicSuffix.contains("*")) {
-        // A wildcard rule, let's replace the wildcard with a value.
-        publicSuffix = publicSuffix.replaceAll("\\*", "square");
-      }
-      assertThat(publicSuffixDatabase.getEffectiveTldPlusOne(publicSuffix)).isNull();
-
-      String test = "foobar." + publicSuffix;
-      assertThat(publicSuffixDatabase.getEffectiveTldPlusOne(test)).isEqualTo(test);
-    }
-  }
-
-  @Test public void publicSuffixExceptions() throws IOException {
-    InputStream resource = PublicSuffixDatabaseTest.class
-        .getResourceAsStream(PUBLIC_SUFFIX_RESOURCE);
-    BufferedSource source = Okio.buffer(new GzipSource(Okio.source(resource)));
-    int length = source.readInt();
-    source.skip(length);
-
-    length = source.readInt();
-    Buffer buffer = new Buffer();
-    buffer.write(source, length);
-    resource.close();
-
-    while (!buffer.exhausted()) {
-      String exception = buffer.readUtf8LineStrict();
-      assertThat(publicSuffixDatabase.getEffectiveTldPlusOne(exception)).isEqualTo(
-          exception);
-
-      String test = "foobar." + exception;
-      assertThat(publicSuffixDatabase.getEffectiveTldPlusOne(test)).isEqualTo(exception);
-    }
-  }
-
-  @Test public void threadIsInterruptedOnFirstRead() {
-    Thread.currentThread().interrupt();
-    try {
-      String result = publicSuffixDatabase.getEffectiveTldPlusOne("squareup.com");
-      assertThat(result).isEqualTo("squareup.com");
-    } finally {
-      assertThat(Thread.interrupted()).isTrue();
-    }
-  }
-
-  /**
-   * These tests are provided by <a href="https://publicsuffix.org/list/">publicsuffix.org</a>.
-   */
-  @Test public void publicSuffixDotOrgTestCases() {
-    // Any copyright is dedicated to the Public Domain.
-    // https://creativecommons.org/publicdomain/zero/1.0/
-
-    // null input.
-    checkPublicSuffix(null, null);
-    // Mixed case.
-    checkPublicSuffix("COM", null);
-    checkPublicSuffix("example.COM", "example.com");
-    checkPublicSuffix("WwW.example.COM", "example.com");
-    // Leading dot.
-    checkPublicSuffix(".com", null);
-    checkPublicSuffix(".example", null);
-    checkPublicSuffix(".example.com", null);
-    checkPublicSuffix(".example.example", null);
-    // Unlisted TLD.
-    checkPublicSuffix("example", null);
-    checkPublicSuffix("example.example", "example.example");
-    checkPublicSuffix("b.example.example", "example.example");
-    checkPublicSuffix("a.b.example.example", "example.example");
-    // Listed, but non-Internet, TLD.
-    //checkPublicSuffix("local", null);
-    //checkPublicSuffix("example.local", null);
-    //checkPublicSuffix("b.example.local", null);
-    //checkPublicSuffix("a.b.example.local", null);
-    // TLD with only 1 rule.
-    checkPublicSuffix("biz", null);
-    checkPublicSuffix("domain.biz", "domain.biz");
-    checkPublicSuffix("b.domain.biz", "domain.biz");
-    checkPublicSuffix("a.b.domain.biz", "domain.biz");
-    // TLD with some 2-level rules.
-    checkPublicSuffix("com", null);
-    checkPublicSuffix("example.com", "example.com");
-    checkPublicSuffix("b.example.com", "example.com");
-    checkPublicSuffix("a.b.example.com", "example.com");
-    checkPublicSuffix("uk.com", null);
-    checkPublicSuffix("example.uk.com", "example.uk.com");
-    checkPublicSuffix("b.example.uk.com", "example.uk.com");
-    checkPublicSuffix("a.b.example.uk.com", "example.uk.com");
-    checkPublicSuffix("test.ac", "test.ac");
-    // TLD with only 1 (wildcard) rule.
-    checkPublicSuffix("mm", null);
-    checkPublicSuffix("c.mm", null);
-    checkPublicSuffix("b.c.mm", "b.c.mm");
-    checkPublicSuffix("a.b.c.mm", "b.c.mm");
-    // More complex TLD.
-    checkPublicSuffix("jp", null);
-    checkPublicSuffix("test.jp", "test.jp");
-    checkPublicSuffix("www.test.jp", "test.jp");
-    checkPublicSuffix("ac.jp", null);
-    checkPublicSuffix("test.ac.jp", "test.ac.jp");
-    checkPublicSuffix("www.test.ac.jp", "test.ac.jp");
-    checkPublicSuffix("kyoto.jp", null);
-    checkPublicSuffix("test.kyoto.jp", "test.kyoto.jp");
-    checkPublicSuffix("ide.kyoto.jp", null);
-    checkPublicSuffix("b.ide.kyoto.jp", "b.ide.kyoto.jp");
-    checkPublicSuffix("a.b.ide.kyoto.jp", "b.ide.kyoto.jp");
-    checkPublicSuffix("c.kobe.jp", null);
-    checkPublicSuffix("b.c.kobe.jp", "b.c.kobe.jp");
-    checkPublicSuffix("a.b.c.kobe.jp", "b.c.kobe.jp");
-    checkPublicSuffix("city.kobe.jp", "city.kobe.jp");
-    checkPublicSuffix("www.city.kobe.jp", "city.kobe.jp");
-    // TLD with a wildcard rule and exceptions.
-    checkPublicSuffix("ck", null);
-    checkPublicSuffix("test.ck", null);
-    checkPublicSuffix("b.test.ck", "b.test.ck");
-    checkPublicSuffix("a.b.test.ck", "b.test.ck");
-    checkPublicSuffix("www.ck", "www.ck");
-    checkPublicSuffix("www.www.ck", "www.ck");
-    // US K12.
-    checkPublicSuffix("us", null);
-    checkPublicSuffix("test.us", "test.us");
-    checkPublicSuffix("www.test.us", "test.us");
-    checkPublicSuffix("ak.us", null);
-    checkPublicSuffix("test.ak.us", "test.ak.us");
-    checkPublicSuffix("www.test.ak.us", "test.ak.us");
-    checkPublicSuffix("k12.ak.us", null);
-    checkPublicSuffix("test.k12.ak.us", "test.k12.ak.us");
-    checkPublicSuffix("www.test.k12.ak.us", "test.k12.ak.us");
-    // IDN labels.
-    checkPublicSuffix(".com.cn", ".com.cn");
-    checkPublicSuffix("..cn", "..cn");
-    checkPublicSuffix("www...cn", "..cn");
-    checkPublicSuffix("shishi..cn", "shishi..cn");
-    checkPublicSuffix(".cn", null);
-    checkPublicSuffix(".", ".");
-    checkPublicSuffix("www..", ".");
-    checkPublicSuffix("shishi.", "shishi.");
-    checkPublicSuffix("", null);
-    // Same as above, but punycoded.
-    checkPublicSuffix("xn--85x722f.com.cn", "xn--85x722f.com.cn");
-    checkPublicSuffix("xn--85x722f.xn--55qx5d.cn", "xn--85x722f.xn--55qx5d.cn");
-    checkPublicSuffix("www.xn--85x722f.xn--55qx5d.cn", "xn--85x722f.xn--55qx5d.cn");
-    checkPublicSuffix("shishi.xn--55qx5d.cn", "shishi.xn--55qx5d.cn");
-    checkPublicSuffix("xn--55qx5d.cn", null);
-    checkPublicSuffix("xn--85x722f.xn--fiqs8s", "xn--85x722f.xn--fiqs8s");
-    checkPublicSuffix("www.xn--85x722f.xn--fiqs8s", "xn--85x722f.xn--fiqs8s");
-    checkPublicSuffix("shishi.xn--fiqs8s", "shishi.xn--fiqs8s");
-    checkPublicSuffix("xn--fiqs8s", null);
-  }
-
-  private void checkPublicSuffix(String domain, String registrablePart) {
-    if (domain == null) {
-      try {
-        publicSuffixDatabase.getEffectiveTldPlusOne(null);
-        fail();
-      } catch (IllegalArgumentException expected) {
-      }
-      return;
-    }
-
-    String canonicalDomain = toCanonicalHost(domain);
-    if (canonicalDomain == null) return;
-
-    String result = publicSuffixDatabase.getEffectiveTldPlusOne(canonicalDomain);
-    if (registrablePart == null) {
-      assertThat(result).isNull();
-    } else {
-      assertThat(result).isEqualTo(toCanonicalHost(registrablePart));
-    }
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixListGenerator.java b/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixListGenerator.java
deleted file mode 100644
index f79f8d074a..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixListGenerator.java
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
- * Copyright (C) 2017 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.publicsuffix;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.SortedSet;
-import java.util.TreeSet;
-import okhttp3.OkHttpClient;
-import okhttp3.Request;
-import okhttp3.Response;
-import okio.BufferedSink;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.GzipSink;
-import okio.Okio;
-import okio.Sink;
-
-/**
- * Downloads the public suffix list from https://publicsuffix.org/list/public_suffix_list.dat and
- * transforms the file into an efficient format used by OkHttp.
- *
- * <p>The intent is to use this class to update the list periodically by manually running the main
- * method. This should be run from the top-level okhttp directory.
- *
- * <p>The resulting file is used by {@link PublicSuffixDatabase}.
- */
-public final class PublicSuffixListGenerator {
-  private static final String OKHTTP_RESOURCE_DIR = "okhttp" + File.separator + "src"
-      + File.separator + "main" + File.separator + "resources" + File.separator
-      + "okhttp3" + File.separator + "internal" + File.separator + "publicsuffix";
-
-  private static final ByteString EXCEPTION_RULE_MARKER = ByteString.encodeUtf8("!");
-  private static final String WILDCARD_CHAR = "*";
-
-  public static void main(String... args) throws IOException {
-    OkHttpClient client = new OkHttpClient.Builder().build();
-    Request request = new Request.Builder()
-        .url("https://publicsuffix.org/list/public_suffix_list.dat")
-        .build();
-    SortedSet<ByteString> sortedRules = new TreeSet<>();
-    SortedSet<ByteString> sortedExceptionRules = new TreeSet<>();
-    try (Response response = client.newCall(request).execute()) {
-      BufferedSource source = response.body().source();
-      int totalRuleBytes = 0;
-      int totalExceptionRuleBytes = 0;
-      while (!source.exhausted()) {
-        String line = source.readUtf8LineStrict();
-        if (line.trim().isEmpty() || line.startsWith("//")) continue;
-
-        if (line.contains(WILDCARD_CHAR)) {
-          assertWildcardRule(line);
-        }
-
-        ByteString rule = ByteString.encodeUtf8(line);
-        if (rule.startsWith(EXCEPTION_RULE_MARKER)) {
-          rule = rule.substring(1);
-          // We use '\n' for end of value.
-          totalExceptionRuleBytes += rule.size() + 1;
-          sortedExceptionRules.add(rule);
-        } else {
-          totalRuleBytes += rule.size() + 1; // We use '\n' for end of value.
-          sortedRules.add(rule);
-        }
-      }
-
-      File resources = new File(OKHTTP_RESOURCE_DIR);
-      if (!resources.mkdirs() && !resources.exists()) {
-        throw new RuntimeException("Unable to create resource directory!");
-      }
-
-      Sink fileSink = Okio.sink(new File(resources,
-          PublicSuffixDatabase.PUBLIC_SUFFIX_RESOURCE));
-      try (BufferedSink sink = Okio.buffer(new GzipSink(fileSink))) {
-        sink.writeInt(totalRuleBytes);
-        for (ByteString domain : sortedRules) {
-          sink.write(domain).writeByte('\n');
-        }
-
-        sink.writeInt(totalExceptionRuleBytes);
-        for (ByteString domain : sortedExceptionRules) {
-          sink.write(domain).writeByte('\n');
-        }
-      }
-    }
-  }
-
-  /**
-   * These assertions ensure the {@link PublicSuffixDatabase} remains correct. The specification is
-   * very flexible regarding wildcard rules, but this flexibility is not something currently used
-   * in practice. To simplify the implementation, we've avoided implementing the flexible rules in
-   * favor of supporting what's actually used in practice. That means if these assertions ever fail,
-   * the implementation will need to be revisited to support a more flexible rule.
-   */
-  private static void assertWildcardRule(String rule) {
-    if (rule.indexOf(WILDCARD_CHAR) != 0) {
-      throw new RuntimeException("Wildcard Assertion Failure: " + rule + "\nA wildcard rule was "
-          + "added with a wildcard that is not in leftmost position! We'll need to change the "
-          + PublicSuffixDatabase.class.getName() + " to handle this.");
-    }
-    if (rule.indexOf(WILDCARD_CHAR, 1) != -1) {
-      throw new RuntimeException("Wildcard Assertion Failure: " + rule + "\nA wildcard rule was "
-          + "added with multiple wildcards! We'll need to change "
-          + PublicSuffixDatabase.class.getName() + " to handle this.");
-    }
-    if (rule.length() == 1) {
-      throw new RuntimeException("Wildcard Assertion Failure: " + rule + "\nA wildcard rule was "
-          + "added that wildcards the first level! We'll need to change the "
-          + PublicSuffixDatabase.class.getName() + " to handle this.");
-    }
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java b/okhttp/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
deleted file mode 100644
index b9223ff838..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
+++ /dev/null
@@ -1,356 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.tls;
-
-import java.security.GeneralSecurityException;
-import java.security.SecureRandom;
-import java.security.cert.X509Certificate;
-import java.util.Collections;
-import javax.net.ssl.KeyManager;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.X509KeyManager;
-import javax.net.ssl.X509TrustManager;
-import okhttp3.Call;
-import okhttp3.CertificatePinner;
-import okhttp3.OkHttpClient;
-import okhttp3.OkHttpClientTestRule;
-import okhttp3.RecordingHostnameVerifier;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.platform.Platform;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.testing.PlatformRule;
-import okhttp3.tls.HandshakeCertificates;
-import okhttp3.tls.HeldCertificate;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static okhttp3.tls.internal.TlsUtil.newKeyManager;
-import static okhttp3.tls.internal.TlsUtil.newTrustManager;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class CertificatePinnerChainValidationTest {
-  @Rule public final PlatformRule platform = new PlatformRule();
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  /** The pinner should pull the root certificate from the trust manager. */
-  @Test public void pinRootNotPresentInChain() throws Exception {
-    // Fails on 11.0.1 https://github.com/square/okhttp/issues/4703
-
-    HeldCertificate rootCa = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .certificateAuthority(1)
-        .commonName("root")
-        .build();
-    HeldCertificate intermediateCa = new HeldCertificate.Builder()
-        .signedBy(rootCa)
-        .certificateAuthority(0)
-        .serialNumber(2L)
-        .commonName("intermediate_ca")
-        .build();
-    HeldCertificate certificate = new HeldCertificate.Builder()
-        .signedBy(intermediateCa)
-        .serialNumber(3L)
-        .commonName(server.getHostName())
-        .build();
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(server.getHostName(), CertificatePinner.pin(rootCa.certificate()))
-        .build();
-    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
-        .addTrustedCertificate(rootCa.certificate())
-        .build();
-    OkHttpClient client = clientTestRule.newClientBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .certificatePinner(certificatePinner)
-        .build();
-
-    HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
-        .heldCertificate(certificate, intermediateCa.certificate())
-        .build();
-    server.useHttps(serverHandshakeCertificates.sslSocketFactory(), false);
-
-    // The request should complete successfully.
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-    assertThat(response1.body().string()).isEqualTo("abc");
-
-    // Confirm that a second request also succeeds. This should detect caching problems.
-    server.enqueue(new MockResponse()
-        .setBody("def")
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    assertThat(response2.body().string()).isEqualTo("def");
-  }
-
-  /** The pinner should accept an intermediate from the server's chain. */
-  @Test public void pinIntermediatePresentInChain() throws Exception {
-    // Fails on 11.0.1 https://github.com/square/okhttp/issues/4703
-
-    HeldCertificate rootCa = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .certificateAuthority(1)
-        .commonName("root")
-        .build();
-    HeldCertificate intermediateCa = new HeldCertificate.Builder()
-        .signedBy(rootCa)
-        .certificateAuthority(0)
-        .serialNumber(2L)
-        .commonName("intermediate_ca")
-        .build();
-    HeldCertificate certificate = new HeldCertificate.Builder()
-        .signedBy(intermediateCa)
-        .serialNumber(3L)
-        .commonName(server.getHostName())
-        .build();
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(server.getHostName(), CertificatePinner.pin(intermediateCa.certificate()))
-        .build();
-    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
-        .addTrustedCertificate(rootCa.certificate())
-        .build();
-    OkHttpClient client = clientTestRule.newClientBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .certificatePinner(certificatePinner)
-        .build();
-
-    HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
-        .heldCertificate(certificate, intermediateCa.certificate())
-        .build();
-    server.useHttps(serverHandshakeCertificates.sslSocketFactory(), false);
-
-    // The request should complete successfully.
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
-    Call call1 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response1 = call1.execute();
-    assertThat(response1.body().string()).isEqualTo("abc");
-    response1.close();
-
-    // Force a fresh connection for the next request.
-    client.connectionPool().evictAll();
-
-    // Confirm that a second request also succeeds. This should detect caching problems.
-    server.enqueue(new MockResponse()
-        .setBody("def")
-        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
-    Call call2 = client.newCall(new Request.Builder()
-        .url(server.url("/"))
-        .build());
-    Response response2 = call2.execute();
-    assertThat(response2.body().string()).isEqualTo("def");
-    response2.close();
-  }
-
-  @Test public void unrelatedPinnedLeafCertificateInChain() throws Exception {
-    // https://github.com/square/okhttp/issues/4729
-    platform.expectFailureOnConscryptPlatform();
-
-    // Start with a trusted root CA certificate.
-    HeldCertificate rootCa = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .certificateAuthority(1)
-        .commonName("root")
-        .build();
-
-    // Add a good intermediate CA, and have that issue a good certificate to localhost. Prepare an
-    // SSL context for an HTTP client under attack. It includes the trusted CA and a pinned
-    // certificate.
-    HeldCertificate goodIntermediateCa = new HeldCertificate.Builder()
-        .signedBy(rootCa)
-        .certificateAuthority(0)
-        .serialNumber(2L)
-        .commonName("good_intermediate_ca")
-        .build();
-    HeldCertificate goodCertificate = new HeldCertificate.Builder()
-        .signedBy(goodIntermediateCa)
-        .serialNumber(3L)
-        .commonName(server.getHostName())
-        .build();
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(server.getHostName(), CertificatePinner.pin(goodCertificate.certificate()))
-        .build();
-    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
-        .addTrustedCertificate(rootCa.certificate())
-        .build();
-    OkHttpClient client = clientTestRule.newClientBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .certificatePinner(certificatePinner)
-        .build();
-
-    // Add a bad intermediate CA and have that issue a rogue certificate for localhost. Prepare
-    // an SSL context for an attacking webserver. It includes both these rogue certificates plus the
-    // trusted good certificate above. The attack is that by including the good certificate in the
-    // chain, we may trick the certificate pinner into accepting the rouge certificate.
-    HeldCertificate compromisedIntermediateCa = new HeldCertificate.Builder()
-        .signedBy(rootCa)
-        .certificateAuthority(0)
-        .serialNumber(4L)
-        .commonName("bad_intermediate_ca")
-        .build();
-    HeldCertificate rogueCertificate = new HeldCertificate.Builder()
-        .serialNumber(5L)
-        .signedBy(compromisedIntermediateCa)
-        .commonName(server.getHostName())
-        .build();
-
-    SSLSocketFactory socketFactory = newServerSocketFactory(rogueCertificate,
-        compromisedIntermediateCa.certificate(), goodCertificate.certificate());
-
-    server.useHttps(socketFactory, false);
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .addHeader("Content-Type: text/plain"));
-
-    // Make a request from client to server. It should succeed certificate checks (unfortunately the
-    // rogue CA is trusted) but it should fail certificate pinning.
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Call call = client.newCall(request);
-    try {
-      call.execute();
-      fail();
-    } catch (SSLPeerUnverifiedException expected) {
-      // Certificate pinning fails!
-      String message = expected.getMessage();
-      assertThat(message).startsWith("Certificate pinning failure!");
-    }
-  }
-
-  @Test public void unrelatedPinnedIntermediateCertificateInChain() throws Exception {
-    // https://github.com/square/okhttp/issues/4729
-    platform.expectFailureOnConscryptPlatform();
-
-    // Start with two root CA certificates, one is good and the other is compromised.
-    HeldCertificate rootCa = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .certificateAuthority(1)
-        .commonName("root")
-        .build();
-    HeldCertificate compromisedRootCa = new HeldCertificate.Builder()
-        .serialNumber(2L)
-        .certificateAuthority(1)
-        .commonName("compromised_root")
-        .build();
-
-    // Add a good intermediate CA, and have that issue a good certificate to localhost. Prepare an
-    // SSL context for an HTTP client under attack. It includes the trusted CA and a pinned
-    // certificate.
-    HeldCertificate goodIntermediateCa = new HeldCertificate.Builder()
-        .signedBy(rootCa)
-        .certificateAuthority(0)
-        .serialNumber(3L)
-        .commonName("intermediate_ca")
-        .build();
-    CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(server.getHostName(), CertificatePinner.pin(goodIntermediateCa.certificate()))
-        .build();
-    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
-        .addTrustedCertificate(rootCa.certificate())
-        .addTrustedCertificate(compromisedRootCa.certificate())
-        .build();
-    OkHttpClient client = clientTestRule.newClientBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .certificatePinner(certificatePinner)
-        .build();
-
-    // The attacker compromises the root CA, issues an intermediate with the same common name
-    // "intermediate_ca" as the good CA. This signs a rogue certificate for localhost. The server
-    // serves the good CAs certificate in the chain, which means the certificate pinner sees a
-    // different set of certificates than the SSL verifier.
-    HeldCertificate compromisedIntermediateCa = new HeldCertificate.Builder()
-        .signedBy(compromisedRootCa)
-        .certificateAuthority(0)
-        .serialNumber(4L)
-        .commonName("intermediate_ca")
-        .build();
-    HeldCertificate rogueCertificate = new HeldCertificate.Builder()
-        .serialNumber(5L)
-        .signedBy(compromisedIntermediateCa)
-        .commonName(server.getHostName())
-        .build();
-
-    SSLSocketFactory socketFactory = newServerSocketFactory(rogueCertificate,
-        goodIntermediateCa.certificate(), compromisedIntermediateCa.certificate());
-    server.useHttps(socketFactory, false);
-    server.enqueue(new MockResponse()
-        .setBody("abc")
-        .addHeader("Content-Type: text/plain"));
-
-    // Make a request from client to server. It should succeed certificate checks (unfortunately the
-    // rogue CA is trusted) but it should fail certificate pinning.
-    Request request = new Request.Builder()
-        .url(server.url("/"))
-        .build();
-    Call call = client.newCall(request);
-    try {
-      call.execute();
-      fail();
-    } catch (SSLHandshakeException expected) {
-      // On Android, the handshake fails before the certificate pinner runs.
-      String message = expected.getMessage();
-      assertThat(message).contains("Could not validate certificate");
-    } catch (SSLPeerUnverifiedException expected) {
-      // On OpenJDK, the handshake succeeds but the certificate pinner fails.
-      String message = expected.getMessage();
-      assertThat(message).startsWith("Certificate pinning failure!");
-    }
-  }
-
-  private SSLSocketFactory newServerSocketFactory(HeldCertificate heldCertificate,
-      X509Certificate... intermediates) throws GeneralSecurityException {
-    // Test setup fails on JDK9
-    // java.security.KeyStoreException: Certificate chain is not valid
-    // at sun.security.pkcs12.PKCS12KeyStore.setKeyEntry
-    // http://openjdk.java.net/jeps/229
-    // http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/2c1c21d11e58/src/share/classes/sun/security/pkcs12/PKCS12KeyStore.java#l596
-    String keystoreType = platform.isJdk9() ? "JKS" : null;
-    X509KeyManager x509KeyManager = newKeyManager(keystoreType, heldCertificate, intermediates);
-    X509TrustManager trustManager = newTrustManager(keystoreType, Collections.emptyList());
-    SSLContext sslContext = Platform.get().newSSLContext();
-    sslContext.init(new KeyManager[] {x509KeyManager}, new TrustManager[] {trustManager},
-        new SecureRandom());
-    return sslContext.getSocketFactory();
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/tls/ClientAuthTest.java b/okhttp/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
deleted file mode 100644
index 33d367f997..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
+++ /dev/null
@@ -1,298 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.tls;
-
-import java.net.SocketException;
-import java.security.GeneralSecurityException;
-import java.security.SecureRandom;
-import java.security.cert.X509Certificate;
-import javax.net.ssl.KeyManager;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLException;
-import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.X509KeyManager;
-import javax.net.ssl.X509TrustManager;
-import javax.security.auth.x500.X500Principal;
-import okhttp3.Call;
-import okhttp3.OkHttpClient;
-import okhttp3.OkHttpClientTestRule;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.http2.ConnectionShutdownException;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.testing.PlatformRule;
-import okhttp3.testing.PlatformVersion;
-import okhttp3.tls.HandshakeCertificates;
-import okhttp3.tls.HeldCertificate;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static java.util.Arrays.asList;
-import static okhttp3.testing.PlatformRule.getPlatformSystemProperty;
-import static okhttp3.tls.internal.TlsUtil.newKeyManager;
-import static okhttp3.tls.internal.TlsUtil.newTrustManager;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class ClientAuthTest {
-  @Rule public final PlatformRule platform = new PlatformRule();
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-  @Rule public final MockWebServer server = new MockWebServer();
-
-  private HeldCertificate serverRootCa;
-  private HeldCertificate serverIntermediateCa;
-  private HeldCertificate serverCert;
-  private HeldCertificate clientRootCa;
-  private HeldCertificate clientIntermediateCa;
-  private HeldCertificate clientCert;
-
-  @Before
-  public void setUp() {
-    platform.assumeNotOpenJSSE();
-
-    serverRootCa = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .certificateAuthority(1)
-        .commonName("root")
-        .addSubjectAlternativeName("root_ca.com")
-        .build();
-    serverIntermediateCa = new HeldCertificate.Builder()
-        .signedBy(serverRootCa)
-        .certificateAuthority(0)
-        .serialNumber(2L)
-        .commonName("intermediate_ca")
-        .addSubjectAlternativeName("intermediate_ca.com")
-        .build();
-
-    serverCert = new HeldCertificate.Builder()
-        .signedBy(serverIntermediateCa)
-        .serialNumber(3L)
-        .commonName("Local Host")
-        .addSubjectAlternativeName(server.getHostName())
-        .build();
-
-    clientRootCa = new HeldCertificate.Builder()
-        .serialNumber(1L)
-        .certificateAuthority(1)
-        .commonName("root")
-        .addSubjectAlternativeName("root_ca.com")
-        .build();
-    clientIntermediateCa = new HeldCertificate.Builder()
-        .signedBy(serverRootCa)
-        .certificateAuthority(0)
-        .serialNumber(2L)
-        .commonName("intermediate_ca")
-        .addSubjectAlternativeName("intermediate_ca.com")
-        .build();
-
-    clientCert = new HeldCertificate.Builder()
-        .signedBy(clientIntermediateCa)
-        .serialNumber(4L)
-        .commonName("Jethro Willis")
-        .addSubjectAlternativeName("jethrowillis.com")
-        .build();
-  }
-
-  @Test public void clientAuthForWants() throws Exception {
-    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
-
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
-
-    server.useHttps(socketFactory, false);
-    server.requestClientAuth();
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    Response response = call.execute();
-    assertThat(response.handshake().peerPrincipal()).isEqualTo(
-        new X500Principal("CN=Local Host"));
-    assertThat(response.handshake().localPrincipal()).isEqualTo(
-        new X500Principal("CN=Jethro Willis"));
-    assertThat(response.body().string()).isEqualTo("abc");
-  }
-
-  @Test public void clientAuthForNeeds() throws Exception {
-    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
-
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
-
-    server.useHttps(socketFactory, false);
-    server.requireClientAuth();
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    Response response = call.execute();
-    assertThat(response.handshake().peerPrincipal()).isEqualTo(
-        new X500Principal("CN=Local Host"));
-    assertThat(response.handshake().localPrincipal()).isEqualTo(
-        new X500Principal("CN=Jethro Willis"));
-    assertThat(response.body().string()).isEqualTo("abc");
-  }
-
-  @Test public void clientAuthSkippedForNone() throws Exception {
-    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
-
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
-
-    server.useHttps(socketFactory, false);
-    server.noClientAuth();
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    Response response = call.execute();
-    assertThat(response.handshake().peerPrincipal()).isEqualTo(
-        new X500Principal("CN=Local Host"));
-    assertThat(response.handshake().localPrincipal()).isNull();
-    assertThat(response.body().string()).isEqualTo("abc");
-  }
-
-  @Test public void missingClientAuthSkippedForWantsOnly() throws Exception {
-    OkHttpClient client = buildClient(null, clientIntermediateCa.certificate());
-
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
-
-    server.useHttps(socketFactory, false);
-    server.requestClientAuth();
-    server.enqueue(new MockResponse().setBody("abc"));
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-    Response response = call.execute();
-    assertThat(response.handshake().peerPrincipal()).isEqualTo(
-        new X500Principal("CN=Local Host"));
-    assertThat(response.handshake().localPrincipal()).isNull();
-    assertThat(response.body().string()).isEqualTo("abc");
-  }
-
-  @Test public void missingClientAuthFailsForNeeds() throws Exception {
-    // Fails with 11.0.1 https://github.com/square/okhttp/issues/4598
-    // StreamReset stream was reset: PROT...
-
-    OkHttpClient client = buildClient(null, clientIntermediateCa.certificate());
-
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
-
-    server.useHttps(socketFactory, false);
-    server.requireClientAuth();
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-
-    try {
-      call.execute();
-      fail();
-    } catch (SSLHandshakeException expected) {
-    } catch (SSLException expected) {
-      assertThat(PlatformVersion.INSTANCE.getMajorVersion()).isGreaterThanOrEqualTo(11);
-    } catch (SocketException expected) {
-      assertThat(getPlatformSystemProperty()).isIn(PlatformRule.JDK9_PROPERTY,
-          PlatformRule.CONSCRYPT_PROPERTY);
-    }
-  }
-
-  @Test public void commonNameIsNotTrusted() throws Exception {
-    serverCert = new HeldCertificate.Builder()
-        .signedBy(serverIntermediateCa)
-        .serialNumber(3L)
-        .commonName(server.getHostName())
-        .addSubjectAlternativeName("different-host.com")
-        .build();
-
-    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
-
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
-
-    server.useHttps(socketFactory, false);
-    server.requireClientAuth();
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-
-    try {
-      call.execute();
-      fail();
-    } catch (SSLPeerUnverifiedException expected) {
-    }
-  }
-
-  @Test public void invalidClientAuthFails() throws Throwable {
-    // Fails with https://github.com/square/okhttp/issues/4598
-    // StreamReset stream was reset: PROT...
-
-    HeldCertificate clientCert2 = new HeldCertificate.Builder()
-        .serialNumber(4L)
-        .commonName("Jethro Willis")
-        .build();
-
-    OkHttpClient client = buildClient(clientCert2);
-
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
-
-    server.useHttps(socketFactory, false);
-    server.requireClientAuth();
-
-    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
-
-    try {
-      call.execute();
-      fail();
-    } catch (SSLHandshakeException expected) {
-    } catch (SSLException expected) {
-      // javax.net.ssl.SSLException: readRecord
-      assertThat(PlatformVersion.INSTANCE.getMajorVersion()).isGreaterThanOrEqualTo(11);
-    } catch (SocketException expected) {
-      assertThat(getPlatformSystemProperty()).isIn(PlatformRule.JDK9_PROPERTY,
-          PlatformRule.CONSCRYPT_PROPERTY);
-    } catch (ConnectionShutdownException expected) {
-      // It didn't fail until it reached the application layer.
-    }
-  }
-
-  private OkHttpClient buildClient(
-      HeldCertificate heldCertificate, X509Certificate... intermediates) {
-    HandshakeCertificates.Builder builder = new HandshakeCertificates.Builder()
-        .addTrustedCertificate(serverRootCa.certificate());
-
-    if (heldCertificate != null) {
-      builder.heldCertificate(heldCertificate, intermediates);
-    }
-
-    HandshakeCertificates handshakeCertificates = builder.build();
-    return clientTestRule.newClientBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .build();
-  }
-
-  private SSLSocketFactory buildServerSslSocketFactory() {
-    // The test uses JDK default SSL Context instead of the Platform provided one
-    // as Conscrypt seems to have some differences, we only want to test client side here.
-    try {
-      X509KeyManager keyManager = newKeyManager(
-          null, serverCert, serverIntermediateCa.certificate());
-      X509TrustManager trustManager = newTrustManager(
-          null, asList(serverRootCa.certificate(), clientRootCa.certificate()));
-      SSLContext sslContext = SSLContext.getInstance("TLS");
-      sslContext.init(new KeyManager[] {keyManager}, new TrustManager[] {trustManager},
-          new SecureRandom());
-      return sslContext.getSocketFactory();
-    } catch (GeneralSecurityException e) {
-      throw new AssertionError(e);
-    }
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java b/okhttp/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
deleted file mode 100644
index 75764ee116..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
+++ /dev/null
@@ -1,553 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements. See the NOTICE file distributed with this
- * work for additional information regarding copyright ownership. The ASF
- * licenses this file to You under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package okhttp3.internal.tls;
-
-import java.io.ByteArrayInputStream;
-import java.security.cert.CertificateFactory;
-import java.security.cert.X509Certificate;
-import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.SSLSession;
-import javax.security.auth.x500.X500Principal;
-import okhttp3.FakeSSLSession;
-import okhttp3.internal.Util;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.assertj.core.api.Assertions.assertThat;
-
-/**
- * Tests for our hostname verifier. Most of these tests are from AOSP, which itself includes tests
- * from the Apache HTTP Client test suite.
- */
-public final class HostnameVerifierTest {
-  private HostnameVerifier verifier = OkHostnameVerifier.INSTANCE;
-
-  @Test public void verify() throws Exception {
-    FakeSSLSession session = new FakeSSLSession();
-    assertThat(verifier.verify("localhost", session)).isFalse();
-  }
-
-  @Test public void verifyCn() throws Exception {
-    // CN=foo.com
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIERjCCAy6gAwIBAgIJAIz+EYMBU6aQMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE1MzE0MVoXDTI4MTEwNTE1MzE0MVowgaQx\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIEwhNYXJ5bGFuZDEUMBIGA1UEBxMLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoTDmh0dHBjb21wb25lbnRzMRowGAYDVQQLExF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczEQMA4GA1UEAxMHZm9vLmNvbTElMCMGCSqGSIb3DQEJARYWanVs\n"
-        + "aXVzZGF2aWVzQGdtYWlsLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\n"
-        + "ggEBAMhjr5aCPoyp0R1iroWAfnEyBMGYWoCidH96yGPFjYLowez5aYKY1IOKTY2B\n"
-        + "lYho4O84X244QrZTRl8kQbYtxnGh4gSCD+Z8gjZ/gMvLUlhqOb+WXPAUHMB39GRy\n"
-        + "zerA/ZtrlUqf+lKo0uWcocxeRc771KN8cPH3nHZ0rV0Hx4ZAZy6U4xxObe4rtSVY\n"
-        + "07hNKXAb2odnVqgzcYiDkLV8ilvEmoNWMWrp8UBqkTcpEhYhCYp3cTkgJwMSuqv8\n"
-        + "BqnGd87xQU3FVZI4tbtkB+KzjD9zz8QCDJAfDjZHR03KNQ5mxOgXwxwKw6lGMaiV\n"
-        + "JTxpTKqym93whYk93l3ocEe55c0CAwEAAaN7MHkwCQYDVR0TBAIwADAsBglghkgB\n"
-        + "hvhCAQ0EHxYdT3BlblNTTCBHZW5lcmF0ZWQgQ2VydGlmaWNhdGUwHQYDVR0OBBYE\n"
-        + "FJ8Ud78/OrbKOIJCSBYs2tDLXofYMB8GA1UdIwQYMBaAFHua2o+QmU5S0qzbswNS\n"
-        + "yoemDT4NMA0GCSqGSIb3DQEBBQUAA4IBAQC3jRmEya6sQCkmieULcvx8zz1euCk9\n"
-        + "fSez7BEtki8+dmfMXe3K7sH0lI8f4jJR0rbSCjpmCQLYmzC3NxBKeJOW0RcjNBpO\n"
-        + "c2JlGO9auXv2GDP4IYiXElLJ6VSqc8WvDikv0JmCCWm0Zga+bZbR/EWN5DeEtFdF\n"
-        + "815CLpJZNcYwiYwGy/CVQ7w2TnXlG+mraZOz+owr+cL6J/ZesbdEWfjoS1+cUEhE\n"
-        + "HwlNrAu8jlZ2UqSgskSWlhYdMTAP9CPHiUv9N7FcT58Itv/I4fKREINQYjDpvQcx\n"
-        + "SaTYb9dr5sB4WLNglk7zxDtM80H518VvihTcP7FHL+Gn6g4j5fkI98+S\n"
-        + "-----END CERTIFICATE-----\n");
-    assertThat(verifier.verify("foo.com", session)).isFalse();
-    assertThat(verifier.verify("a.foo.com", session)).isFalse();
-    assertThat(verifier.verify("bar.com", session)).isFalse();
-  }
-
-  @Test public void verifyNonAsciiCn() throws Exception {
-    // CN=&#x82b1;&#x5b50;.co.jp
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIESzCCAzOgAwIBAgIJAIz+EYMBU6aTMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE1NDIxNVoXDTI4MTEwNTE1NDIxNVowgakx\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIDAhNYXJ5bGFuZDEUMBIGA1UEBwwLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoMDmh0dHBjb21wb25lbnRzMRowGAYDVQQLDBF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczEVMBMGA1UEAwwM6Iqx5a2QLmNvLmpwMSUwIwYJKoZIhvcNAQkB\n"
-        + "FhZqdWxpdXNkYXZpZXNAZ21haWwuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A\n"
-        + "MIIBCgKCAQEAyGOvloI+jKnRHWKuhYB+cTIEwZhagKJ0f3rIY8WNgujB7PlpgpjU\n"
-        + "g4pNjYGViGjg7zhfbjhCtlNGXyRBti3GcaHiBIIP5nyCNn+Ay8tSWGo5v5Zc8BQc\n"
-        + "wHf0ZHLN6sD9m2uVSp/6UqjS5ZyhzF5FzvvUo3xw8fecdnStXQfHhkBnLpTjHE5t\n"
-        + "7iu1JVjTuE0pcBvah2dWqDNxiIOQtXyKW8Sag1YxaunxQGqRNykSFiEJindxOSAn\n"
-        + "AxK6q/wGqcZ3zvFBTcVVkji1u2QH4rOMP3PPxAIMkB8ONkdHTco1DmbE6BfDHArD\n"
-        + "qUYxqJUlPGlMqrKb3fCFiT3eXehwR7nlzQIDAQABo3sweTAJBgNVHRMEAjAAMCwG\n"
-        + "CWCGSAGG+EIBDQQfFh1PcGVuU1NMIEdlbmVyYXRlZCBDZXJ0aWZpY2F0ZTAdBgNV\n"
-        + "HQ4EFgQUnxR3vz86tso4gkJIFiza0Mteh9gwHwYDVR0jBBgwFoAUe5raj5CZTlLS\n"
-        + "rNuzA1LKh6YNPg0wDQYJKoZIhvcNAQEFBQADggEBALJ27i3okV/KvlDp6KMID3gd\n"
-        + "ITl68PyItzzx+SquF8gahMh016NX73z/oVZoVUNdftla8wPUB1GwIkAnGkhQ9LHK\n"
-        + "spBdbRiCj0gMmLCsX8SrjFvr7cYb2cK6J/fJe92l1tg/7Y4o7V/s4JBe/cy9U9w8\n"
-        + "a0ctuDmEBCgC784JMDtT67klRfr/2LlqWhlOEq7pUFxRLbhpquaAHSOjmIcWnVpw\n"
-        + "9BsO7qe46hidgn39hKh1WjKK2VcL/3YRsC4wUi0PBtFW6ScMCuMhgIRXSPU55Rae\n"
-        + "UIlOdPjjr1SUNWGId1rD7W16Scpwnknn310FNxFMHVI0GTGFkNdkilNCFJcIoRA=\n"
-        + "-----END CERTIFICATE-----\n");
-    assertThat(verifier.verify("\u82b1\u5b50.co.jp", session)).isFalse();
-    assertThat(verifier.verify("a.\u82b1\u5b50.co.jp", session)).isFalse();
-  }
-
-  @Test public void verifySubjectAlt() throws Exception {
-    // CN=foo.com, subjectAlt=bar.com
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIEXDCCA0SgAwIBAgIJAIz+EYMBU6aRMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE1MzYyOVoXDTI4MTEwNTE1MzYyOVowgaQx\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIEwhNYXJ5bGFuZDEUMBIGA1UEBxMLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoTDmh0dHBjb21wb25lbnRzMRowGAYDVQQLExF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczEQMA4GA1UEAxMHZm9vLmNvbTElMCMGCSqGSIb3DQEJARYWanVs\n"
-        + "aXVzZGF2aWVzQGdtYWlsLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\n"
-        + "ggEBAMhjr5aCPoyp0R1iroWAfnEyBMGYWoCidH96yGPFjYLowez5aYKY1IOKTY2B\n"
-        + "lYho4O84X244QrZTRl8kQbYtxnGh4gSCD+Z8gjZ/gMvLUlhqOb+WXPAUHMB39GRy\n"
-        + "zerA/ZtrlUqf+lKo0uWcocxeRc771KN8cPH3nHZ0rV0Hx4ZAZy6U4xxObe4rtSVY\n"
-        + "07hNKXAb2odnVqgzcYiDkLV8ilvEmoNWMWrp8UBqkTcpEhYhCYp3cTkgJwMSuqv8\n"
-        + "BqnGd87xQU3FVZI4tbtkB+KzjD9zz8QCDJAfDjZHR03KNQ5mxOgXwxwKw6lGMaiV\n"
-        + "JTxpTKqym93whYk93l3ocEe55c0CAwEAAaOBkDCBjTAJBgNVHRMEAjAAMCwGCWCG\n"
-        + "SAGG+EIBDQQfFh1PcGVuU1NMIEdlbmVyYXRlZCBDZXJ0aWZpY2F0ZTAdBgNVHQ4E\n"
-        + "FgQUnxR3vz86tso4gkJIFiza0Mteh9gwHwYDVR0jBBgwFoAUe5raj5CZTlLSrNuz\n"
-        + "A1LKh6YNPg0wEgYDVR0RBAswCYIHYmFyLmNvbTANBgkqhkiG9w0BAQUFAAOCAQEA\n"
-        + "dQyprNZBmVnvuVWjV42sey/PTfkYShJwy1j0/jcFZR/ypZUovpiHGDO1DgL3Y3IP\n"
-        + "zVQ26uhUsSw6G0gGRiaBDe/0LUclXZoJzXX1qpS55OadxW73brziS0sxRgGrZE/d\n"
-        + "3g5kkio6IED47OP6wYnlmZ7EKP9cqjWwlnvHnnUcZ2SscoLNYs9rN9ccp8tuq2by\n"
-        + "88OyhKwGjJfhOudqfTNZcDzRHx4Fzm7UsVaycVw4uDmhEHJrAsmMPpj/+XRK9/42\n"
-        + "2xq+8bc6HojdtbCyug/fvBZvZqQXSmU8m8IVcMmWMz0ZQO8ee3QkBHMZfCy7P/kr\n"
-        + "VbWx/uETImUu+NZg22ewEw==\n"
-        + "-----END CERTIFICATE-----\n");
-    assertThat(verifier.verify("foo.com", session)).isFalse();
-    assertThat(verifier.verify("a.foo.com", session)).isFalse();
-    assertThat(verifier.verify("bar.com", session)).isTrue();
-    assertThat(verifier.verify("a.bar.com", session)).isFalse();
-  }
-
-  /**
-   * Ignored due to incompatibilities between Android and Java on how non-ASCII subject alt names
-   * are parsed. Android fails to parse these, which means we fall back to the CN. The RI does parse
-   * them, so the CN is unused.
-   */
-  @Test @Ignore public void verifyNonAsciiSubjectAlt() throws Exception {
-    // CN=foo.com, subjectAlt=bar.com, subjectAlt=&#x82b1;&#x5b50;.co.jp
-    // (hanako.co.jp in kanji)
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIEajCCA1KgAwIBAgIJAIz+EYMBU6aSMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE1MzgxM1oXDTI4MTEwNTE1MzgxM1owgaQx\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIEwhNYXJ5bGFuZDEUMBIGA1UEBxMLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoTDmh0dHBjb21wb25lbnRzMRowGAYDVQQLExF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczEQMA4GA1UEAxMHZm9vLmNvbTElMCMGCSqGSIb3DQEJARYWanVs\n"
-        + "aXVzZGF2aWVzQGdtYWlsLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\n"
-        + "ggEBAMhjr5aCPoyp0R1iroWAfnEyBMGYWoCidH96yGPFjYLowez5aYKY1IOKTY2B\n"
-        + "lYho4O84X244QrZTRl8kQbYtxnGh4gSCD+Z8gjZ/gMvLUlhqOb+WXPAUHMB39GRy\n"
-        + "zerA/ZtrlUqf+lKo0uWcocxeRc771KN8cPH3nHZ0rV0Hx4ZAZy6U4xxObe4rtSVY\n"
-        + "07hNKXAb2odnVqgzcYiDkLV8ilvEmoNWMWrp8UBqkTcpEhYhCYp3cTkgJwMSuqv8\n"
-        + "BqnGd87xQU3FVZI4tbtkB+KzjD9zz8QCDJAfDjZHR03KNQ5mxOgXwxwKw6lGMaiV\n"
-        + "JTxpTKqym93whYk93l3ocEe55c0CAwEAAaOBnjCBmzAJBgNVHRMEAjAAMCwGCWCG\n"
-        + "SAGG+EIBDQQfFh1PcGVuU1NMIEdlbmVyYXRlZCBDZXJ0aWZpY2F0ZTAdBgNVHQ4E\n"
-        + "FgQUnxR3vz86tso4gkJIFiza0Mteh9gwHwYDVR0jBBgwFoAUe5raj5CZTlLSrNuz\n"
-        + "A1LKh6YNPg0wIAYDVR0RBBkwF4IHYmFyLmNvbYIM6Iqx5a2QLmNvLmpwMA0GCSqG\n"
-        + "SIb3DQEBBQUAA4IBAQBeZs7ZIYyKtdnVxVvdLgwySEPOE4pBSXii7XYv0Q9QUvG/\n"
-        + "++gFGQh89HhABzA1mVUjH5dJTQqSLFvRfqTHqLpxSxSWqMHnvRM4cPBkIRp/XlMK\n"
-        + "PlXadYtJLPTgpbgvulA1ickC9EwlNYWnowZ4uxnfsMghW4HskBqaV+PnQ8Zvy3L0\n"
-        + "12c7Cg4mKKS5pb1HdRuiD2opZ+Hc77gRQLvtWNS8jQvd/iTbh6fuvTKfAOFoXw22\n"
-        + "sWIKHYrmhCIRshUNohGXv50m2o+1w9oWmQ6Dkq7lCjfXfUB4wIbggJjpyEtbNqBt\n"
-        + "j4MC2x5rfsLKKqToKmNE7pFEgqwe8//Aar1b+Qj+\n"
-        + "-----END CERTIFICATE-----\n");
-    assertThat(verifier.verify("foo.com", session)).isTrue();
-    assertThat(verifier.verify("a.foo.com", session)).isFalse();
-    // these checks test alternative subjects. The test data contains an
-    // alternative subject starting with a japanese kanji character. This is
-    // not supported by Android because the underlying implementation from
-    // harmony follows the definition from rfc 1034 page 10 for alternative
-    // subject names. This causes the code to drop all alternative subjects.
-    // assertTrue(verifier.verify("bar.com", session));
-    // assertFalse(verifier.verify("a.bar.com", session));
-    // assertFalse(verifier.verify("a.\u82b1\u5b50.co.jp", session));
-  }
-
-  @Test public void verifySubjectAltOnly() throws Exception {
-    // subjectAlt=foo.com
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIESjCCAzKgAwIBAgIJAIz+EYMBU6aYMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE2MjYxMFoXDTI4MTEwNTE2MjYxMFowgZIx\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIDAhNYXJ5bGFuZDEUMBIGA1UEBwwLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoMDmh0dHBjb21wb25lbnRzMRowGAYDVQQLDBF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczElMCMGCSqGSIb3DQEJARYWanVsaXVzZGF2aWVzQGdtYWlsLmNv\n"
-        + "bTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMhjr5aCPoyp0R1iroWA\n"
-        + "fnEyBMGYWoCidH96yGPFjYLowez5aYKY1IOKTY2BlYho4O84X244QrZTRl8kQbYt\n"
-        + "xnGh4gSCD+Z8gjZ/gMvLUlhqOb+WXPAUHMB39GRyzerA/ZtrlUqf+lKo0uWcocxe\n"
-        + "Rc771KN8cPH3nHZ0rV0Hx4ZAZy6U4xxObe4rtSVY07hNKXAb2odnVqgzcYiDkLV8\n"
-        + "ilvEmoNWMWrp8UBqkTcpEhYhCYp3cTkgJwMSuqv8BqnGd87xQU3FVZI4tbtkB+Kz\n"
-        + "jD9zz8QCDJAfDjZHR03KNQ5mxOgXwxwKw6lGMaiVJTxpTKqym93whYk93l3ocEe5\n"
-        + "5c0CAwEAAaOBkDCBjTAJBgNVHRMEAjAAMCwGCWCGSAGG+EIBDQQfFh1PcGVuU1NM\n"
-        + "IEdlbmVyYXRlZCBDZXJ0aWZpY2F0ZTAdBgNVHQ4EFgQUnxR3vz86tso4gkJIFiza\n"
-        + "0Mteh9gwHwYDVR0jBBgwFoAUe5raj5CZTlLSrNuzA1LKh6YNPg0wEgYDVR0RBAsw\n"
-        + "CYIHZm9vLmNvbTANBgkqhkiG9w0BAQUFAAOCAQEAjl78oMjzFdsMy6F1sGg/IkO8\n"
-        + "tF5yUgPgFYrs41yzAca7IQu6G9qtFDJz/7ehh/9HoG+oqCCIHPuIOmS7Sd0wnkyJ\n"
-        + "Y7Y04jVXIb3a6f6AgBkEFP1nOT0z6kjT7vkA5LJ2y3MiDcXuRNMSta5PYVnrX8aZ\n"
-        + "yiqVUNi40peuZ2R8mAUSBvWgD7z2qWhF8YgDb7wWaFjg53I36vWKn90ZEti3wNCw\n"
-        + "qAVqixM+J0qJmQStgAc53i2aTMvAQu3A3snvH/PHTBo+5UL72n9S1kZyNCsVf1Qo\n"
-        + "n8jKTiRriEM+fMFlcgQP284EBFzYHyCXFb9O/hMjK2+6mY9euMB1U1aFFzM/Bg==\n"
-        + "-----END CERTIFICATE-----\n");
-    assertThat(verifier.verify("foo.com", session)).isTrue();
-    assertThat(verifier.verify("a.foo.com", session)).isFalse();
-    assertThat(verifier.verify("foo.com", session)).isTrue();
-    assertThat(verifier.verify("a.foo.com", session)).isFalse();
-  }
-
-  @Test public void verifyMultipleCn() throws Exception {
-    // CN=foo.com, CN=bar.com, CN=&#x82b1;&#x5b50;.co.jp
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIEbzCCA1egAwIBAgIJAIz+EYMBU6aXMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE2MTk0NVoXDTI4MTEwNTE2MTk0NVowgc0x\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIDAhNYXJ5bGFuZDEUMBIGA1UEBwwLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoMDmh0dHBjb21wb25lbnRzMRowGAYDVQQLDBF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczEQMA4GA1UEAwwHZm9vLmNvbTEQMA4GA1UEAwwHYmFyLmNvbTEV\n"
-        + "MBMGA1UEAwwM6Iqx5a2QLmNvLmpwMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyGOv\n"
-        + "loI+jKnRHWKuhYB+cTIEwZhagKJ0f3rIY8WNgujB7PlpgpjUg4pNjYGViGjg7zhf\n"
-        + "bjhCtlNGXyRBti3GcaHiBIIP5nyCNn+Ay8tSWGo5v5Zc8BQcwHf0ZHLN6sD9m2uV\n"
-        + "Sp/6UqjS5ZyhzF5FzvvUo3xw8fecdnStXQfHhkBnLpTjHE5t7iu1JVjTuE0pcBva\n"
-        + "h2dWqDNxiIOQtXyKW8Sag1YxaunxQGqRNykSFiEJindxOSAnAxK6q/wGqcZ3zvFB\n"
-        + "TcVVkji1u2QH4rOMP3PPxAIMkB8ONkdHTco1DmbE6BfDHArDqUYxqJUlPGlMqrKb\n"
-        + "3fCFiT3eXehwR7nlzQIDAQABo3sweTAJBgNVHRMEAjAAMCwGCWCGSAGG+EIBDQQf\n"
-        + "Fh1PcGVuU1NMIEdlbmVyYXRlZCBDZXJ0aWZpY2F0ZTAdBgNVHQ4EFgQUnxR3vz86\n"
-        + "tso4gkJIFiza0Mteh9gwHwYDVR0jBBgwFoAUe5raj5CZTlLSrNuzA1LKh6YNPg0w\n"
-        + "DQYJKoZIhvcNAQEFBQADggEBAGuZb8ai1NO2j4v3y9TLZvd5s0vh5/TE7n7RX+8U\n"
-        + "y37OL5k7x9nt0mM1TyAKxlCcY+9h6frue8MemZIILSIvMrtzccqNz0V1WKgA+Orf\n"
-        + "uUrabmn+CxHF5gpy6g1Qs2IjVYWA5f7FROn/J+Ad8gJYc1azOWCLQqSyfpNRLSvY\n"
-        + "EriQFEV63XvkJ8JrG62b+2OT2lqT4OO07gSPetppdlSa8NBSKP6Aro9RIX1ZjUZQ\n"
-        + "SpQFCfo02NO0uNRDPUdJx2huycdNb+AXHaO7eXevDLJ+QnqImIzxWiY6zLOdzjjI\n"
-        + "VBMkLHmnP7SjGSQ3XA4ByrQOxfOUTyLyE7NuemhHppuQPxE=\n"
-        + "-----END CERTIFICATE-----\n");
-    assertThat(verifier.verify("foo.com", session)).isFalse();
-    assertThat(verifier.verify("a.foo.com", session)).isFalse();
-    assertThat(verifier.verify("bar.com", session)).isFalse();
-    assertThat(verifier.verify("a.bar.com", session)).isFalse();
-    assertThat(verifier.verify("\u82b1\u5b50.co.jp", session)).isFalse();
-    assertThat(verifier.verify("a.\u82b1\u5b50.co.jp", session)).isFalse();
-  }
-
-  @Test public void verifyWilcardCn() throws Exception {
-    // CN=*.foo.com
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIESDCCAzCgAwIBAgIJAIz+EYMBU6aUMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE2MTU1NVoXDTI4MTEwNTE2MTU1NVowgaYx\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIEwhNYXJ5bGFuZDEUMBIGA1UEBxMLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoTDmh0dHBjb21wb25lbnRzMRowGAYDVQQLExF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczESMBAGA1UEAxQJKi5mb28uY29tMSUwIwYJKoZIhvcNAQkBFhZq\n"
-        + "dWxpdXNkYXZpZXNAZ21haWwuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\n"
-        + "CgKCAQEAyGOvloI+jKnRHWKuhYB+cTIEwZhagKJ0f3rIY8WNgujB7PlpgpjUg4pN\n"
-        + "jYGViGjg7zhfbjhCtlNGXyRBti3GcaHiBIIP5nyCNn+Ay8tSWGo5v5Zc8BQcwHf0\n"
-        + "ZHLN6sD9m2uVSp/6UqjS5ZyhzF5FzvvUo3xw8fecdnStXQfHhkBnLpTjHE5t7iu1\n"
-        + "JVjTuE0pcBvah2dWqDNxiIOQtXyKW8Sag1YxaunxQGqRNykSFiEJindxOSAnAxK6\n"
-        + "q/wGqcZ3zvFBTcVVkji1u2QH4rOMP3PPxAIMkB8ONkdHTco1DmbE6BfDHArDqUYx\n"
-        + "qJUlPGlMqrKb3fCFiT3eXehwR7nlzQIDAQABo3sweTAJBgNVHRMEAjAAMCwGCWCG\n"
-        + "SAGG+EIBDQQfFh1PcGVuU1NMIEdlbmVyYXRlZCBDZXJ0aWZpY2F0ZTAdBgNVHQ4E\n"
-        + "FgQUnxR3vz86tso4gkJIFiza0Mteh9gwHwYDVR0jBBgwFoAUe5raj5CZTlLSrNuz\n"
-        + "A1LKh6YNPg0wDQYJKoZIhvcNAQEFBQADggEBAH0ipG6J561UKUfgkeW7GvYwW98B\n"
-        + "N1ZooWX+JEEZK7+Pf/96d3Ij0rw9ACfN4bpfnCq0VUNZVSYB+GthQ2zYuz7tf/UY\n"
-        + "A6nxVgR/IjG69BmsBl92uFO7JTNtHztuiPqBn59pt+vNx4yPvno7zmxsfI7jv0ww\n"
-        + "yfs+0FNm7FwdsC1k47GBSOaGw38kuIVWqXSAbL4EX9GkryGGOKGNh0qvAENCdRSB\n"
-        + "G9Z6tyMbmfRY+dLSh3a9JwoEcBUso6EWYBakLbq4nG/nvYdYvG9ehrnLVwZFL82e\n"
-        + "l3Q/RK95bnA6cuRClGusLad0e6bjkBzx/VQ3VarDEpAkTLUGVAa0CLXtnyc=\n"
-        + "-----END CERTIFICATE-----\n");
-    assertThat(verifier.verify("foo.com", session)).isFalse();
-    assertThat(verifier.verify("www.foo.com", session)).isFalse();
-    assertThat(verifier.verify("\u82b1\u5b50.foo.com", session)).isFalse();
-    assertThat(verifier.verify("a.b.foo.com", session)).isFalse();
-  }
-
-  @Test public void verifyWilcardCnOnTld() throws Exception {
-    // It's the CA's responsibility to not issue broad-matching certificates!
-    // CN=*.co.jp
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIERjCCAy6gAwIBAgIJAIz+EYMBU6aVMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE2MTYzMFoXDTI4MTEwNTE2MTYzMFowgaQx\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIEwhNYXJ5bGFuZDEUMBIGA1UEBxMLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoTDmh0dHBjb21wb25lbnRzMRowGAYDVQQLExF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczEQMA4GA1UEAxQHKi5jby5qcDElMCMGCSqGSIb3DQEJARYWanVs\n"
-        + "aXVzZGF2aWVzQGdtYWlsLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC\n"
-        + "ggEBAMhjr5aCPoyp0R1iroWAfnEyBMGYWoCidH96yGPFjYLowez5aYKY1IOKTY2B\n"
-        + "lYho4O84X244QrZTRl8kQbYtxnGh4gSCD+Z8gjZ/gMvLUlhqOb+WXPAUHMB39GRy\n"
-        + "zerA/ZtrlUqf+lKo0uWcocxeRc771KN8cPH3nHZ0rV0Hx4ZAZy6U4xxObe4rtSVY\n"
-        + "07hNKXAb2odnVqgzcYiDkLV8ilvEmoNWMWrp8UBqkTcpEhYhCYp3cTkgJwMSuqv8\n"
-        + "BqnGd87xQU3FVZI4tbtkB+KzjD9zz8QCDJAfDjZHR03KNQ5mxOgXwxwKw6lGMaiV\n"
-        + "JTxpTKqym93whYk93l3ocEe55c0CAwEAAaN7MHkwCQYDVR0TBAIwADAsBglghkgB\n"
-        + "hvhCAQ0EHxYdT3BlblNTTCBHZW5lcmF0ZWQgQ2VydGlmaWNhdGUwHQYDVR0OBBYE\n"
-        + "FJ8Ud78/OrbKOIJCSBYs2tDLXofYMB8GA1UdIwQYMBaAFHua2o+QmU5S0qzbswNS\n"
-        + "yoemDT4NMA0GCSqGSIb3DQEBBQUAA4IBAQA0sWglVlMx2zNGvUqFC73XtREwii53\n"
-        + "CfMM6mtf2+f3k/d8KXhLNySrg8RRlN11zgmpPaLtbdTLrmG4UdAHHYr8O4y2BBmE\n"
-        + "1cxNfGxxechgF8HX10QV4dkyzp6Z1cfwvCeMrT5G/V1pejago0ayXx+GPLbWlNeZ\n"
-        + "S+Kl0m3p+QplXujtwG5fYcIpaGpiYraBLx3Tadih39QN65CnAh/zRDhLCUzKyt9l\n"
-        + "UGPLEUDzRHMPHLnSqT1n5UU5UDRytbjJPXzF+l/+WZIsanefWLsxnkgAuZe/oMMF\n"
-        + "EJMryEzOjg4Tfuc5qM0EXoPcQ/JlheaxZ40p2IyHqbsWV4MRYuFH4bkM\n"
-        + "-----END CERTIFICATE-----\n");
-    assertThat(verifier.verify("foo.co.jp", session)).isFalse();
-    assertThat(verifier.verify("\u82b1\u5b50.co.jp", session)).isFalse();
-  }
-
-  /**
-   * Ignored due to incompatibilities between Android and Java on how non-ASCII subject alt names
-   * are parsed. Android fails to parse these, which means we fall back to the CN. The RI does parse
-   * them, so the CN is unused.
-   */
-  @Test @Ignore public void testWilcardNonAsciiSubjectAlt() throws Exception {
-    // CN=*.foo.com, subjectAlt=*.bar.com, subjectAlt=*.&#x82b1;&#x5b50;.co.jp
-    // (*.hanako.co.jp in kanji)
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIEcDCCA1igAwIBAgIJAIz+EYMBU6aWMA0GCSqGSIb3DQEBBQUAMIGiMQswCQYD\n"
-        + "VQQGEwJDQTELMAkGA1UECBMCQkMxEjAQBgNVBAcTCVZhbmNvdXZlcjEWMBQGA1UE\n"
-        + "ChMNd3d3LmN1Y2JjLmNvbTEUMBIGA1UECxQLY29tbW9uc19zc2wxHTAbBgNVBAMU\n"
-        + "FGRlbW9faW50ZXJtZWRpYXRlX2NhMSUwIwYJKoZIhvcNAQkBFhZqdWxpdXNkYXZp\n"
-        + "ZXNAZ21haWwuY29tMB4XDTA2MTIxMTE2MTczMVoXDTI4MTEwNTE2MTczMVowgaYx\n"
-        + "CzAJBgNVBAYTAlVTMREwDwYDVQQIEwhNYXJ5bGFuZDEUMBIGA1UEBxMLRm9yZXN0\n"
-        + "IEhpbGwxFzAVBgNVBAoTDmh0dHBjb21wb25lbnRzMRowGAYDVQQLExF0ZXN0IGNl\n"
-        + "cnRpZmljYXRlczESMBAGA1UEAxQJKi5mb28uY29tMSUwIwYJKoZIhvcNAQkBFhZq\n"
-        + "dWxpdXNkYXZpZXNAZ21haWwuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\n"
-        + "CgKCAQEAyGOvloI+jKnRHWKuhYB+cTIEwZhagKJ0f3rIY8WNgujB7PlpgpjUg4pN\n"
-        + "jYGViGjg7zhfbjhCtlNGXyRBti3GcaHiBIIP5nyCNn+Ay8tSWGo5v5Zc8BQcwHf0\n"
-        + "ZHLN6sD9m2uVSp/6UqjS5ZyhzF5FzvvUo3xw8fecdnStXQfHhkBnLpTjHE5t7iu1\n"
-        + "JVjTuE0pcBvah2dWqDNxiIOQtXyKW8Sag1YxaunxQGqRNykSFiEJindxOSAnAxK6\n"
-        + "q/wGqcZ3zvFBTcVVkji1u2QH4rOMP3PPxAIMkB8ONkdHTco1DmbE6BfDHArDqUYx\n"
-        + "qJUlPGlMqrKb3fCFiT3eXehwR7nlzQIDAQABo4GiMIGfMAkGA1UdEwQCMAAwLAYJ\n"
-        + "YIZIAYb4QgENBB8WHU9wZW5TU0wgR2VuZXJhdGVkIENlcnRpZmljYXRlMB0GA1Ud\n"
-        + "DgQWBBSfFHe/Pzq2yjiCQkgWLNrQy16H2DAfBgNVHSMEGDAWgBR7mtqPkJlOUtKs\n"
-        + "27MDUsqHpg0+DTAkBgNVHREEHTAbggkqLmJhci5jb22CDiou6Iqx5a2QLmNvLmpw\n"
-        + "MA0GCSqGSIb3DQEBBQUAA4IBAQBobWC+D5/lx6YhX64CwZ26XLjxaE0S415ajbBq\n"
-        + "DK7lz+Rg7zOE3GsTAMi+ldUYnhyz0wDiXB8UwKXl0SDToB2Z4GOgqQjAqoMmrP0u\n"
-        + "WB6Y6dpkfd1qDRUzI120zPYgSdsXjHW9q2H77iV238hqIU7qCvEz+lfqqWEY504z\n"
-        + "hYNlknbUnR525ItosEVwXFBJTkZ3Yw8gg02c19yi8TAh5Li3Ad8XQmmSJMWBV4XK\n"
-        + "qFr0AIZKBlg6NZZFf/0dP9zcKhzSriW27bY0XfzA6GSiRDXrDjgXq6baRT6YwgIg\n"
-        + "pgJsDbJtZfHnV1nd3M6zOtQPm1TIQpNmMMMd/DPrGcUQerD3\n"
-        + "-----END CERTIFICATE-----\n");
-    // try the foo.com variations
-    assertThat(verifier.verify("foo.com", session)).isTrue();
-    assertThat(verifier.verify("www.foo.com", session)).isTrue();
-    assertThat(verifier.verify("\u82b1\u5b50.foo.com", session)).isTrue();
-    assertThat(verifier.verify("a.b.foo.com", session)).isFalse();
-    // these checks test alternative subjects. The test data contains an
-    // alternative subject starting with a japanese kanji character. This is
-    // not supported by Android because the underlying implementation from
-    // harmony follows the definition from rfc 1034 page 10 for alternative
-    // subject names. This causes the code to drop all alternative subjects.
-    // assertFalse(verifier.verify("bar.com", session));
-    // assertTrue(verifier.verify("www.bar.com", session));
-    // assertTrue(verifier.verify("\u82b1\u5b50.bar.com", session));
-    // assertTrue(verifier.verify("a.b.bar.com", session));
-  }
-
-  @Test public void subjectAltUsesLocalDomainAndIp() throws Exception {
-    // cat cert.cnf
-    // [req]
-    // distinguished_name=distinguished_name
-    // req_extensions=req_extensions
-    // x509_extensions=x509_extensions
-    // [distinguished_name]
-    // [req_extensions]
-    // [x509_extensions]
-    // subjectAltName=DNS:localhost.localdomain,DNS:localhost,IP:127.0.0.1
-    //
-    // $ openssl req -x509 -nodes -days 36500 -subj '/CN=localhost' -config ./cert.cnf \
-    //     -newkey rsa:512 -out cert.pem
-    X509Certificate certificate = certificate(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIBWDCCAQKgAwIBAgIJANS1EtICX2AZMA0GCSqGSIb3DQEBBQUAMBQxEjAQBgNV\n"
-        + "BAMTCWxvY2FsaG9zdDAgFw0xMjAxMDIxOTA4NThaGA8yMTExMTIwOTE5MDg1OFow\n"
-        + "FDESMBAGA1UEAxMJbG9jYWxob3N0MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAPpt\n"
-        + "atK8r4/hf4hSIs0os/BSlQLbRBaK9AfBReM4QdAklcQqe6CHsStKfI8pp0zs7Ptg\n"
-        + "PmMdpbttL0O7mUboBC8CAwEAAaM1MDMwMQYDVR0RBCowKIIVbG9jYWxob3N0Lmxv\n"
-        + "Y2FsZG9tYWlugglsb2NhbGhvc3SHBH8AAAEwDQYJKoZIhvcNAQEFBQADQQD0ntfL\n"
-        + "DCzOCv9Ma6Lv5o5jcYWVxvBSTsnt22hsJpWD1K7iY9lbkLwl0ivn73pG2evsAn9G\n"
-        + "X8YKH52fnHsCrhSD\n"
-        + "-----END CERTIFICATE-----");
-    assertThat(certificate.getSubjectX500Principal()).isEqualTo(
-        new X500Principal("CN=localhost"));
-
-    FakeSSLSession session = new FakeSSLSession(certificate);
-    assertThat(verifier.verify("localhost", session)).isTrue();
-    assertThat(verifier.verify("localhost.localdomain", session)).isTrue();
-    assertThat(verifier.verify("local.host", session)).isFalse();
-
-    assertThat(verifier.verify("127.0.0.1", session)).isTrue();
-    assertThat(verifier.verify("127.0.0.2", session)).isFalse();
-  }
-
-  @Test public void wildcardsCannotMatchIpAddresses() throws Exception {
-    // openssl req -x509 -nodes -days 36500 -subj '/CN=*.0.0.1' -newkey rsa:512 -out cert.pem
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIBkjCCATygAwIBAgIJAMdemqOwd/BEMA0GCSqGSIb3DQEBBQUAMBIxEDAOBgNV\n"
-        + "BAMUByouMC4wLjEwIBcNMTAxMjIwMTY0NDI1WhgPMjExMDExMjYxNjQ0MjVaMBIx\n"
-        + "EDAOBgNVBAMUByouMC4wLjEwXDANBgkqhkiG9w0BAQEFAANLADBIAkEAqY8c9Qrt\n"
-        + "YPWCvb7lclI+aDHM6fgbJcHsS9Zg8nUOh5dWrS7AgeA25wyaokFl4plBbbHQe2j+\n"
-        + "cCjsRiJIcQo9HwIDAQABo3MwcTAdBgNVHQ4EFgQUJ436TZPJvwCBKklZZqIvt1Yt\n"
-        + "JjEwQgYDVR0jBDswOYAUJ436TZPJvwCBKklZZqIvt1YtJjGhFqQUMBIxEDAOBgNV\n"
-        + "BAMUByouMC4wLjGCCQDHXpqjsHfwRDAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEB\n"
-        + "BQUAA0EAk9i88xdjWoewqvE+iMC9tD2obMchgFDaHH0ogxxiRaIKeEly3g0uGxIt\n"
-        + "fl2WRY8hb4x+zRrwsFaLEpdEvqcjOQ==\n"
-        + "-----END CERTIFICATE-----");
-    assertThat(verifier.verify("127.0.0.1", session)).isFalse();
-  }
-
-  /**
-   * Earlier implementations of Android's hostname verifier required that wildcard names wouldn't
-   * match "*.com" or similar. This was a nonstandard check that we've since dropped. It is the CA's
-   * responsibility to not hand out certificates that match so broadly.
-   */
-  @Test public void wildcardsDoesNotNeedTwoDots() throws Exception {
-    // openssl req -x509 -nodes -days 36500 -subj '/CN=*.com' -newkey rsa:512 -out cert.pem
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIBjDCCATagAwIBAgIJAOVulXCSu6HuMA0GCSqGSIb3DQEBBQUAMBAxDjAMBgNV\n"
-        + "BAMUBSouY29tMCAXDTEwMTIyMDE2NDkzOFoYDzIxMTAxMTI2MTY0OTM4WjAQMQ4w\n"
-        + "DAYDVQQDFAUqLmNvbTBcMA0GCSqGSIb3DQEBAQUAA0sAMEgCQQDJd8xqni+h7Iaz\n"
-        + "ypItivs9kPuiJUqVz+SuJ1C05SFc3PmlRCvwSIfhyD67fHcbMdl+A/LrIjhhKZJe\n"
-        + "1joO0+pFAgMBAAGjcTBvMB0GA1UdDgQWBBS4Iuzf5w8JdCp+EtBfdFNudf6+YzBA\n"
-        + "BgNVHSMEOTA3gBS4Iuzf5w8JdCp+EtBfdFNudf6+Y6EUpBIwEDEOMAwGA1UEAxQF\n"
-        + "Ki5jb22CCQDlbpVwkruh7jAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBBQUAA0EA\n"
-        + "U6LFxmZr31lFyis2/T68PpjAppc0DpNQuA2m/Y7oTHBDi55Fw6HVHCw3lucuWZ5d\n"
-        + "qUYo4ES548JdpQtcLrW2sA==\n"
-        + "-----END CERTIFICATE-----");
-    assertThat(verifier.verify("google.com", session)).isFalse();
-  }
-
-  @Test public void subjectAltName() throws Exception {
-    // $ cat ./cert.cnf
-    // [req]
-    // distinguished_name=distinguished_name
-    // req_extensions=req_extensions
-    // x509_extensions=x509_extensions
-    // [distinguished_name]
-    // [req_extensions]
-    // [x509_extensions]
-    // subjectAltName=DNS:bar.com,DNS:baz.com
-    //
-    // $ openssl req -x509 -nodes -days 36500 -subj '/CN=foo.com' -config ./cert.cnf \
-    //     -newkey rsa:512 -out cert.pem
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIBPTCB6KADAgECAgkA7zoHaaqNGHQwDQYJKoZIhvcNAQEFBQAwEjEQMA4GA1UE\n"
-        + "AxMHZm9vLmNvbTAgFw0xMDEyMjAxODM5MzZaGA8yMTEwMTEyNjE4MzkzNlowEjEQ\n"
-        + "MA4GA1UEAxMHZm9vLmNvbTBcMA0GCSqGSIb3DQEBAQUAA0sAMEgCQQC+gmoSxF+8\n"
-        + "hbV+rgRQqHIJd50216OWQJbU3BvdlPbca779NYO4+UZWTFdBM8BdQqs3H4B5Agvp\n"
-        + "y7HeSff1F7XRAgMBAAGjHzAdMBsGA1UdEQQUMBKCB2Jhci5jb22CB2Jhei5jb20w\n"
-        + "DQYJKoZIhvcNAQEFBQADQQBXpZZPOY2Dy1lGG81JTr8L4or9jpKacD7n51eS8iqI\n"
-        + "oTznPNuXHU5bFN0AAGX2ij47f/EahqTpo5RdS95P4sVm\n"
-        + "-----END CERTIFICATE-----");
-    assertThat(verifier.verify("foo.com", session)).isFalse();
-    assertThat(verifier.verify("bar.com", session)).isTrue();
-    assertThat(verifier.verify("baz.com", session)).isTrue();
-    assertThat(verifier.verify("a.foo.com", session)).isFalse();
-    assertThat(verifier.verify("quux.com", session)).isFalse();
-  }
-
-  @Test public void subjectAltNameWithWildcard() throws Exception {
-    // $ cat ./cert.cnf
-    // [req]
-    // distinguished_name=distinguished_name
-    // req_extensions=req_extensions
-    // x509_extensions=x509_extensions
-    // [distinguished_name]
-    // [req_extensions]
-    // [x509_extensions]
-    // subjectAltName=DNS:bar.com,DNS:*.baz.com
-    //
-    // $ openssl req -x509 -nodes -days 36500 -subj '/CN=foo.com' -config ./cert.cnf \
-    //     -newkey rsa:512 -out cert.pem
-    SSLSession session = session(""
-        + "-----BEGIN CERTIFICATE-----\n"
-        + "MIIBPzCB6qADAgECAgkAnv/7Jv5r7pMwDQYJKoZIhvcNAQEFBQAwEjEQMA4GA1UE\n"
-        + "AxMHZm9vLmNvbTAgFw0xMDEyMjAxODQ2MDFaGA8yMTEwMTEyNjE4NDYwMVowEjEQ\n"
-        + "MA4GA1UEAxMHZm9vLmNvbTBcMA0GCSqGSIb3DQEBAQUAA0sAMEgCQQDAz2YXnyog\n"
-        + "YdYLSFr/OEgSumtwqtZKJTB4wqTW/eKbBCEzxnyUMxWZIqUGu353PzwfOuWp2re3\n"
-        + "nvVV+QDYQlh9AgMBAAGjITAfMB0GA1UdEQQWMBSCB2Jhci5jb22CCSouYmF6LmNv\n"
-        + "bTANBgkqhkiG9w0BAQUFAANBAB8yrSl8zqy07i0SNYx2B/FnvQY734pxioaqFWfO\n"
-        + "Bqo1ZZl/9aPHEWIwBrxYNVB0SGu/kkbt/vxqOjzzrkXukmI=\n"
-        + "-----END CERTIFICATE-----");
-    assertThat(verifier.verify("foo.com", session)).isFalse();
-    assertThat(verifier.verify("bar.com", session)).isTrue();
-    assertThat(verifier.verify("a.baz.com", session)).isTrue();
-    assertThat(verifier.verify("baz.com", session)).isFalse();
-    assertThat(verifier.verify("a.foo.com", session)).isFalse();
-    assertThat(verifier.verify("a.bar.com", session)).isFalse();
-    assertThat(verifier.verify("quux.com", session)).isFalse();
-  }
-
-  @Test public void verifyAsIpAddress() {
-    // IPv4
-    assertThat(Util.canParseAsIpAddress("127.0.0.1")).isTrue();
-    assertThat(Util.canParseAsIpAddress("1.2.3.4")).isTrue();
-
-    // IPv6
-    assertThat(Util.canParseAsIpAddress("::1")).isTrue();
-    assertThat(Util.canParseAsIpAddress("2001:db8::1")).isTrue();
-    assertThat(Util.canParseAsIpAddress("::192.168.0.1")).isTrue();
-    assertThat(Util.canParseAsIpAddress("::ffff:192.168.0.1")).isTrue();
-    assertThat(Util.canParseAsIpAddress("FEDC:BA98:7654:3210:FEDC:BA98:7654:3210")).isTrue();
-    assertThat(Util.canParseAsIpAddress("1080:0:0:0:8:800:200C:417A")).isTrue();
-    assertThat(Util.canParseAsIpAddress("1080::8:800:200C:417A")).isTrue();
-    assertThat(Util.canParseAsIpAddress("FF01::101")).isTrue();
-    assertThat(Util.canParseAsIpAddress("0:0:0:0:0:0:13.1.68.3")).isTrue();
-    assertThat(Util.canParseAsIpAddress("0:0:0:0:0:FFFF:129.144.52.38")).isTrue();
-    assertThat(Util.canParseAsIpAddress("::13.1.68.3")).isTrue();
-    assertThat(Util.canParseAsIpAddress("::FFFF:129.144.52.38")).isTrue();
-
-    // Hostnames
-    assertThat(Util.canParseAsIpAddress("go")).isFalse();
-    assertThat(Util.canParseAsIpAddress("localhost")).isFalse();
-    assertThat(Util.canParseAsIpAddress("squareup.com")).isFalse();
-    assertThat(Util.canParseAsIpAddress("www.nintendo.co.jp")).isFalse();
-  }
-
-  private X509Certificate certificate(String certificate) throws Exception {
-    return (X509Certificate) CertificateFactory.getInstance("X.509").generateCertificate(
-        new ByteArrayInputStream(certificate.getBytes(UTF_8)));
-  }
-
-  private SSLSession session(String certificate) throws Exception {
-    return new FakeSSLSession(certificate(certificate));
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java b/okhttp/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
deleted file mode 100644
index bbabd9ddae..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
+++ /dev/null
@@ -1,398 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.net.SocketTimeoutException;
-import java.util.Random;
-import java.util.concurrent.TimeUnit;
-import okhttp3.Protocol;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.internal.concurrent.TaskRunner;
-import okio.ByteString;
-import okio.Okio;
-import okio.Pipe;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.data.Offset.offset;
-import static org.junit.Assert.fail;
-
-public final class RealWebSocketTest {
-  // NOTE: Fields are named 'client' and 'server' for cognitive simplicity. This differentiation has
-  // zero effect on the behavior of the WebSocket API which is why tests are only written once
-  // from the perspective of a single peer.
-
-  private final Random random = new Random(0);
-  private final Pipe client2Server = new Pipe(1024L);
-  private final Pipe server2client = new Pipe(1024L);
-
-  private TestStreams client = new TestStreams(true, server2client, client2Server);
-  private TestStreams server = new TestStreams(false, client2Server, server2client);
-
-  @Before public void setUp() throws IOException {
-    client.initWebSocket(random, 0);
-    server.initWebSocket(random, 0);
-  }
-
-  @After public void tearDown() throws Exception {
-    client.listener.assertExhausted();
-    server.listener.assertExhausted();
-    server.getSource().close();
-    client.getSource().close();
-    server.webSocket.tearDown();
-    client.webSocket.tearDown();
-  }
-
-  @Test public void close() throws IOException {
-    client.webSocket.close(1000, "Hello!");
-    // This will trigger a close response.
-    assertThat(server.processNextFrame()).isFalse();
-    server.listener.assertClosing(1000, "Hello!");
-    server.webSocket.close(1000, "Goodbye!");
-    assertThat(client.processNextFrame()).isFalse();
-    client.listener.assertClosing(1000, "Goodbye!");
-    server.listener.assertClosed(1000, "Hello!");
-    client.listener.assertClosed(1000, "Goodbye!");
-  }
-
-  @Test public void clientCloseThenMethodsReturnFalse() throws IOException {
-    client.webSocket.close(1000, "Hello!");
-
-    assertThat(client.webSocket.close(1000, "Hello!")).isFalse();
-    assertThat(client.webSocket.send("Hello!")).isFalse();
-  }
-
-  @Test public void clientCloseWith0Fails() throws IOException {
-    try {
-      client.webSocket.close(0, null);
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat("Code must be in range [1000,5000): 0").isEqualTo(expected.getMessage());
-    }
-  }
-
-  @Test public void afterSocketClosedPingFailsWebSocket() throws IOException {
-    client2Server.source().close();
-    client.webSocket.pong(ByteString.encodeUtf8("Ping!"));
-    client.listener.assertFailure(IOException.class, "source is closed");
-
-    assertThat(client.webSocket.send("Hello!")).isFalse();
-  }
-
-  @Test public void socketClosedDuringMessageKillsWebSocket() throws IOException {
-    client2Server.source().close();
-
-    assertThat(client.webSocket.send("Hello!")).isTrue();
-    client.listener.assertFailure(IOException.class, "source is closed");
-
-    // A failed write prevents further use of the WebSocket instance.
-    assertThat(client.webSocket.send("Hello!")).isFalse();
-    assertThat(client.webSocket.pong(ByteString.encodeUtf8("Ping!"))).isFalse();
-  }
-
-  @Test public void serverCloseThenWritingPingSucceeds() throws IOException {
-    server.webSocket.close(1000, "Hello!");
-    client.processNextFrame();
-    client.listener.assertClosing(1000, "Hello!");
-
-    assertThat(client.webSocket.pong(ByteString.encodeUtf8("Pong?"))).isTrue();
-  }
-
-  @Test public void clientCanWriteMessagesAfterServerClose() throws IOException {
-    server.webSocket.close(1000, "Hello!");
-    client.processNextFrame();
-    client.listener.assertClosing(1000, "Hello!");
-
-    assertThat(client.webSocket.send("Hi!")).isTrue();
-    server.processNextFrame();
-    server.listener.assertTextMessage("Hi!");
-  }
-
-  @Test public void serverCloseThenClientClose() throws IOException {
-    server.webSocket.close(1000, "Hello!");
-    client.processNextFrame();
-    client.listener.assertClosing(1000, "Hello!");
-    assertThat(client.webSocket.close(1000, "Bye!")).isTrue();
-  }
-
-  @Test public void emptyCloseInitiatesShutdown() throws IOException {
-    server.getSink().write(ByteString.decodeHex("8800")).emit(); // Close without code.
-    client.processNextFrame();
-    client.listener.assertClosing(1005, "");
-
-    assertThat(client.webSocket.close(1000, "Bye!")).isTrue();
-    server.processNextFrame();
-    server.listener.assertClosing(1000, "Bye!");
-
-    client.listener.assertClosed(1005, "");
-  }
-
-  @Test public void clientCloseClosesConnection() throws IOException {
-    client.webSocket.close(1000, "Hello!");
-    assertThat(client.closed).isFalse();
-    server.processNextFrame(); // Read client closing, send server close.
-    server.listener.assertClosing(1000, "Hello!");
-
-    server.webSocket.close(1000, "Goodbye!");
-    client.processNextFrame(); // Read server closing, close connection.
-    assertThat(client.closed).isTrue();
-    client.listener.assertClosing(1000, "Goodbye!");
-
-    // Server and client both finished closing, connection is closed.
-    server.listener.assertClosed(1000, "Hello!");
-    client.listener.assertClosed(1000, "Goodbye!");
-  }
-
-  @Test public void serverCloseClosesConnection() throws IOException {
-    server.webSocket.close(1000, "Hello!");
-
-    client.processNextFrame(); // Read server close, send client close, close connection.
-    assertThat(client.closed).isFalse();
-    client.listener.assertClosing(1000, "Hello!");
-
-    client.webSocket.close(1000, "Hello!");
-    server.processNextFrame();
-    server.listener.assertClosing(1000, "Hello!");
-
-    client.listener.assertClosed(1000, "Hello!");
-    server.listener.assertClosed(1000, "Hello!");
-  }
-
-  @Test public void clientAndServerCloseClosesConnection() throws Exception {
-    // Send close from both sides at the same time.
-    server.webSocket.close(1000, "Hello!");
-    client.processNextFrame(); // Read close, close connection close.
-
-    assertThat(client.closed).isFalse();
-    client.webSocket.close(1000, "Hi!");
-    server.processNextFrame();
-
-    client.listener.assertClosing(1000, "Hello!");
-    server.listener.assertClosing(1000, "Hi!");
-    client.listener.assertClosed(1000, "Hello!");
-    server.listener.assertClosed(1000, "Hi!");
-    client.webSocket.awaitTermination(5, TimeUnit.SECONDS);
-    assertThat(client.closed).isTrue();
-
-    server.listener.assertExhausted(); // Client should not have sent second close.
-    client.listener.assertExhausted(); // Server should not have sent second close.
-  }
-
-  @Test public void serverCloseBreaksReadMessageLoop() throws IOException {
-    server.webSocket.send("Hello!");
-    server.webSocket.close(1000, "Bye!");
-    assertThat(client.processNextFrame()).isTrue();
-    client.listener.assertTextMessage("Hello!");
-    assertThat(client.processNextFrame()).isFalse();
-    client.listener.assertClosing(1000, "Bye!");
-  }
-
-  @Test public void protocolErrorBeforeCloseSendsFailure() throws IOException {
-    server.getSink().write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
-
-    client.processNextFrame(); // Detects error, send close, close connection.
-    assertThat(client.closed).isTrue();
-    client.listener.assertFailure(ProtocolException.class, "Control frames must be final.");
-
-    server.processNextFrame();
-    server.listener.assertFailure(EOFException.class);
-  }
-
-  @Test public void protocolErrorInCloseResponseClosesConnection() throws IOException {
-    client.webSocket.close(1000, "Hello");
-    server.processNextFrame();
-    // Not closed until close reply is received.
-    assertThat(client.closed).isFalse();
-
-    // Manually write an invalid masked close frame.
-    server.getSink().write(ByteString.decodeHex("888760b420bb635c68de0cd84f")).emit();
-
-    client.processNextFrame();// Detects error, disconnects immediately since close already sent.
-    assertThat(client.closed).isTrue();
-    client.listener.assertFailure(
-        ProtocolException.class, "Server-sent frames must not be masked.");
-
-    server.listener.assertClosing(1000, "Hello");
-    server.listener.assertExhausted(); // Client should not have sent second close.
-  }
-
-  @Test public void protocolErrorAfterCloseDoesNotSendClose() throws IOException {
-    client.webSocket.close(1000, "Hello!");
-    server.processNextFrame();
-
-    // Not closed until close reply is received.
-    assertThat(client.closed).isFalse();
-    server.getSink().write(ByteString.decodeHex("0a00")).emit(); // Invalid non-final ping frame.
-
-    client.processNextFrame(); // Detects error, disconnects immediately since close already sent.
-    assertThat(client.closed).isTrue();
-    client.listener.assertFailure(ProtocolException.class, "Control frames must be final.");
-
-    server.listener.assertClosing(1000, "Hello!");
-
-    server.listener.assertExhausted(); // Client should not have sent second close.
-  }
-
-  @Test public void networkErrorReportedAsFailure() throws IOException {
-    server.getSink().close();
-    client.processNextFrame();
-    client.listener.assertFailure(EOFException.class);
-  }
-
-  @Test public void closeThrowingFailsConnection() throws IOException {
-    client2Server.source().close();
-    client.webSocket.close(1000, null);
-    client.listener.assertFailure(IOException.class, "source is closed");
-  }
-
-  @Ignore // TODO(jwilson): come up with a way to test unchecked exceptions on the writer thread.
-  @Test public void closeMessageAndConnectionCloseThrowingDoesNotMaskOriginal() throws IOException {
-    client.getSink().close();
-    client.closeThrows = true;
-
-    client.webSocket.close(1000, "Bye!");
-    client.listener.assertFailure(IOException.class, "failure");
-    assertThat(client.closed).isTrue();
-  }
-
-  @Ignore // TODO(jwilson): come up with a way to test unchecked exceptions on the writer thread.
-  @Test public void peerConnectionCloseThrowingPropagates() throws IOException {
-    client.closeThrows = true;
-
-    server.webSocket.close(1000, "Bye from Server!");
-    client.processNextFrame();
-    client.listener.assertClosing(1000, "Bye from Server!");
-
-    client.webSocket.close(1000, "Bye from Client!");
-    server.processNextFrame();
-    server.listener.assertClosing(1000, "Bye from Client!");
-  }
-
-  @Test public void pingOnInterval() throws IOException {
-    long startNanos = System.nanoTime();
-    client.initWebSocket(random, 500);
-
-    server.processNextFrame(); // Ping.
-    client.processNextFrame(); // Pong.
-    long elapsedUntilPing1 = System.nanoTime() - startNanos;
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing1)).isCloseTo((double) 500, offset(
-        250d));
-
-    server.processNextFrame(); // Ping.
-    client.processNextFrame(); // Pong.
-    long elapsedUntilPing2 = System.nanoTime() - startNanos;
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing2)).isCloseTo((double) 1000, offset(
-        250d));
-
-    server.processNextFrame(); // Ping.
-    client.processNextFrame(); // Pong.
-    long elapsedUntilPing3 = System.nanoTime() - startNanos;
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing3)).isCloseTo((double) 1500, offset(
-        250d));
-  }
-
-  @Test public void unacknowledgedPingFailsConnection() throws IOException {
-    long startNanos = System.nanoTime();
-    client.initWebSocket(random, 500);
-
-    // Don't process the ping and pong frames!
-    client.listener.assertFailure(SocketTimeoutException.class,
-        "sent ping but didn't receive pong within 500ms (after 0 successful ping/pongs)");
-    long elapsedUntilFailure = System.nanoTime() - startNanos;
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure)).isCloseTo((double) 1000, offset(
-        250d));
-  }
-
-  @Test public void unexpectedPongsDoNotInterfereWithFailureDetection() throws IOException {
-    long startNanos = System.nanoTime();
-    client.initWebSocket(random, 500);
-
-    // At 0ms the server sends 3 unexpected pongs. The client accepts 'em and ignores em.
-    server.webSocket.pong(ByteString.encodeUtf8("pong 1"));
-    client.processNextFrame();
-    server.webSocket.pong(ByteString.encodeUtf8("pong 2"));
-    client.processNextFrame();
-    server.webSocket.pong(ByteString.encodeUtf8("pong 3"));
-    client.processNextFrame();
-
-    // After 500ms the client automatically pings and the server pongs back.
-    server.processNextFrame(); // Ping.
-    client.processNextFrame(); // Pong.
-    long elapsedUntilPing = System.nanoTime() - startNanos;
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing)).isCloseTo((double) 500, offset(
-        250d));
-
-    // After 1000ms the client will attempt a ping 2, but we don't process it. That'll cause the
-    // client to fail at 1500ms when it's time to send ping 3 because pong 2 hasn't been received.
-    client.listener.assertFailure(SocketTimeoutException.class,
-        "sent ping but didn't receive pong within 500ms (after 1 successful ping/pongs)");
-    long elapsedUntilFailure = System.nanoTime() - startNanos;
-    assertThat((double) TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure)).isCloseTo((double) 1500, offset(
-        250d));
-  }
-
-  /** One peer's streams, listener, and web socket in the test. */
-  private static class TestStreams extends RealWebSocket.Streams {
-    private final String name;
-    private final WebSocketRecorder listener;
-    private RealWebSocket webSocket;
-    boolean closeThrows;
-    boolean closed;
-
-    public TestStreams(boolean client, Pipe source, Pipe sink) {
-      super(client, Okio.buffer(source.source()), Okio.buffer(sink.sink()));
-      this.name = client ? "client" : "server";
-      this.listener = new WebSocketRecorder(name);
-    }
-
-    public void initWebSocket(Random random, int pingIntervalMillis) throws IOException {
-      String url = "http://example.com/websocket";
-      Response response = new Response.Builder()
-          .code(101)
-          .message("OK")
-          .request(new Request.Builder().url(url).build())
-          .protocol(Protocol.HTTP_1_1)
-          .build();
-      webSocket = new RealWebSocket(
-          TaskRunner.INSTANCE, response.request(), listener, random, pingIntervalMillis);
-      webSocket.initReaderAndWriter(name, this);
-    }
-
-    public boolean processNextFrame() throws IOException {
-      return webSocket.processNextFrame();
-    }
-
-    @Override public void close() throws IOException {
-      getSource().close();
-      getSink().close();
-      if (closed) {
-        throw new AssertionError("Already closed");
-      }
-      closed = true;
-
-      if (closeThrows) {
-        throw new RuntimeException("Oops!");
-      }
-    }
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
deleted file mode 100644
index 52ae73969f..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
+++ /dev/null
@@ -1,817 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.io.InterruptedIOException;
-import java.net.HttpURLConnection;
-import java.net.ProtocolException;
-import java.net.SocketTimeoutException;
-import java.util.Random;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.logging.Logger;
-import okhttp3.OkHttpClient;
-import okhttp3.OkHttpClientTestRule;
-import okhttp3.Protocol;
-import okhttp3.RecordingEventListener;
-import okhttp3.RecordingHostnameVerifier;
-import okhttp3.Request;
-import okhttp3.Response;
-import okhttp3.TestLogHandler;
-import okhttp3.WebSocket;
-import okhttp3.WebSocketListener;
-import okhttp3.internal.concurrent.TaskRunner;
-import okhttp3.mockwebserver.Dispatcher;
-import okhttp3.mockwebserver.MockResponse;
-import okhttp3.mockwebserver.MockWebServer;
-import okhttp3.mockwebserver.RecordedRequest;
-import okhttp3.mockwebserver.SocketPolicy;
-import okhttp3.testing.Flaky;
-import okhttp3.testing.PlatformRule;
-import okhttp3.tls.HandshakeCertificates;
-import okio.Buffer;
-import okio.ByteString;
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Ignore;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static java.util.Arrays.asList;
-import static okhttp3.TestUtil.repeat;
-import static okhttp3.tls.internal.TlsUtil.localhost;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.data.Offset.offset;
-import static org.junit.Assert.fail;
-
-@Flaky
-public final class WebSocketHttpTest {
-  // Flaky https://github.com/square/okhttp/issues/4515
-  // Flaky https://github.com/square/okhttp/issues/4953
-
-  @Rule public final MockWebServer webServer = new MockWebServer();
-  @Rule public final OkHttpClientTestRule clientTestRule = new OkHttpClientTestRule();
-  @Rule public final PlatformRule platform = new PlatformRule();
-
-  private final HandshakeCertificates handshakeCertificates = localhost();
-  private final WebSocketRecorder clientListener = new WebSocketRecorder("client");
-  private final WebSocketRecorder serverListener = new WebSocketRecorder("server");
-  private final Random random = new Random(0);
-  private OkHttpClient client = clientTestRule.newClientBuilder()
-      .writeTimeout(500, TimeUnit.MILLISECONDS)
-      .readTimeout(500, TimeUnit.MILLISECONDS)
-      .addInterceptor(chain -> {
-        Response response = chain.proceed(chain.request());
-        // Ensure application interceptors never see a null body.
-        assertThat(response.body()).isNotNull();
-        return response;
-      })
-      .build();
-
-  @Before public void setUp() {
-    platform.assumeNotOpenJSSE();
-  }
-
-  @After public void tearDown() {
-    clientListener.assertExhausted();
-  }
-
-  @Test public void textMessage() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    WebSocket webSocket = newWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    webSocket.send("Hello, WebSockets!");
-    serverListener.assertTextMessage("Hello, WebSockets!");
-
-    closeWebSockets(webSocket, server);
-  }
-
-  @Test public void binaryMessage() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    WebSocket webSocket = newWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    webSocket.send(ByteString.encodeUtf8("Hello!"));
-    serverListener.assertBinaryMessage(ByteString.of(new byte[] {'H', 'e', 'l', 'l', 'o', '!'}));
-
-    closeWebSockets(webSocket, server);
-  }
-
-  @Test public void nullStringThrows() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    WebSocket webSocket = newWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-    try {
-      webSocket.send((String) null);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-
-    closeWebSockets(webSocket, server);
-  }
-
-  @Test public void nullByteStringThrows() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    WebSocket webSocket = newWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-    try {
-      webSocket.send((ByteString) null);
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
-
-    closeWebSockets(webSocket, server);
-  }
-
-  @Test public void serverMessage() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    WebSocket webSocket = newWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    server.send("Hello, WebSockets!");
-    clientListener.assertTextMessage("Hello, WebSockets!");
-
-    closeWebSockets(webSocket, server);
-  }
-
-  @Test public void throwingOnOpenFailsImmediately() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    final RuntimeException e = new RuntimeException();
-    clientListener.setNextEventDelegate(new WebSocketListener() {
-      @Override public void onOpen(WebSocket webSocket, Response response) {
-        throw e;
-      }
-    });
-    newWebSocket();
-
-    serverListener.assertOpen();
-    serverListener.assertFailure(EOFException.class);
-    serverListener.assertExhausted();
-    clientListener.assertFailure(e);
-  }
-
-  @Ignore("AsyncCall currently lets runtime exceptions propagate.")
-  @Test public void throwingOnFailLogs() throws Exception {
-    TestLogHandler logs = new TestLogHandler();
-    Logger logger = Logger.getLogger(OkHttpClient.class.getName());
-    logger.addHandler(logs);
-
-    webServer.enqueue(new MockResponse().setResponseCode(200).setBody("Body"));
-
-    final RuntimeException e = new RuntimeException();
-    clientListener.setNextEventDelegate(new WebSocketListener() {
-      @Override public void onFailure(WebSocket webSocket, Throwable t, Response response) {
-        throw e;
-      }
-    });
-
-    newWebSocket();
-
-    assertThat(logs.take()).isEqualTo("");
-    logger.removeHandler(logs);
-  }
-
-  @Test public void throwingOnMessageClosesImmediatelyAndFails() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    newWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    final RuntimeException e = new RuntimeException();
-    clientListener.setNextEventDelegate(new WebSocketListener() {
-      @Override public void onMessage(WebSocket webSocket, String text) {
-        throw e;
-      }
-    });
-
-    server.send("Hello, WebSockets!");
-    clientListener.assertFailure(e);
-    serverListener.assertFailure(EOFException.class);
-    serverListener.assertExhausted();
-  }
-
-  @Test public void throwingOnClosingClosesImmediatelyAndFails() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    newWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    final RuntimeException e = new RuntimeException();
-    clientListener.setNextEventDelegate(new WebSocketListener() {
-      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
-        throw e;
-      }
-    });
-
-    server.close(1000, "bye");
-    clientListener.assertFailure(e);
-    serverListener.assertFailure();
-    serverListener.assertExhausted();
-  }
-
-  @Test public void unplannedCloseHandledByCloseWithoutFailure() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    newWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-    clientListener.setNextEventDelegate(new WebSocketListener() {
-      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
-        webSocket.close(1000, null);
-      }
-    });
-
-    server.close(1001, "bye");
-    clientListener.assertClosed(1001, "bye");
-    clientListener.assertExhausted();
-    serverListener.assertClosing(1000, "");
-    serverListener.assertClosed(1000, "");
-    serverListener.assertExhausted();
-  }
-
-  @Test public void unplannedCloseHandledWithoutFailure() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    newWebSocket();
-
-    WebSocket webSocket = clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    closeWebSockets(webSocket, server);
-  }
-
-  @Test public void non101RetainsBody() throws IOException {
-    webServer.enqueue(new MockResponse().setResponseCode(200).setBody("Body"));
-    newWebSocket();
-
-    clientListener.assertFailure(200, "Body", ProtocolException.class,
-        "Expected HTTP 101 response but was '200 OK'");
-  }
-
-  @Test public void notFound() throws IOException {
-    webServer.enqueue(new MockResponse().setStatus("HTTP/1.1 404 Not Found"));
-    newWebSocket();
-
-    clientListener.assertFailure(404, null, ProtocolException.class,
-        "Expected HTTP 101 response but was '404 Not Found'");
-  }
-
-  @Test public void clientTimeoutClosesBody() {
-    webServer.enqueue(new MockResponse().setResponseCode(408));
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    WebSocket webSocket = newWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    webSocket.send("abc");
-    serverListener.assertTextMessage("abc");
-
-    server.send("def");
-    clientListener.assertTextMessage("def");
-
-    closeWebSockets(webSocket, server);
-  }
-
-  @Test public void missingConnectionHeader() throws IOException {
-    webServer.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Upgrade", "websocket")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    newWebSocket();
-
-    clientListener.assertFailure(101, null, ProtocolException.class,
-        "Expected 'Connection' header value 'Upgrade' but was 'null'");
-  }
-
-  @Test public void wrongConnectionHeader() throws IOException {
-    webServer.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Upgrade", "websocket")
-        .setHeader("Connection", "Downgrade")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    newWebSocket();
-
-    clientListener.assertFailure(101, null, ProtocolException.class,
-        "Expected 'Connection' header value 'Upgrade' but was 'Downgrade'");
-  }
-
-  @Test public void missingUpgradeHeader() throws IOException {
-    webServer.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    newWebSocket();
-
-    clientListener.assertFailure(101, null, ProtocolException.class,
-        "Expected 'Upgrade' header value 'websocket' but was 'null'");
-  }
-
-  @Test public void wrongUpgradeHeader() throws IOException {
-    webServer.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Upgrade", "Pepsi")
-        .setHeader("Sec-WebSocket-Accept", "ujmZX4KXZqjwy6vi1aQFH5p4Ygk="));
-    newWebSocket();
-
-    clientListener.assertFailure(101, null, ProtocolException.class,
-        "Expected 'Upgrade' header value 'websocket' but was 'Pepsi'");
-  }
-
-  @Test public void missingMagicHeader() throws IOException {
-    webServer.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Upgrade", "websocket"));
-    newWebSocket();
-
-    clientListener.assertFailure(101, null, ProtocolException.class,
-        "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'null'");
-  }
-
-  @Test public void wrongMagicHeader() throws IOException {
-    webServer.enqueue(new MockResponse()
-        .setResponseCode(101)
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Upgrade", "websocket")
-        .setHeader("Sec-WebSocket-Accept", "magic"));
-    newWebSocket();
-
-    clientListener.assertFailure(101, null, ProtocolException.class,
-        "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'magic'");
-  }
-
-  @Test public void webSocketAndApplicationInterceptors() {
-    final AtomicInteger interceptedCount = new AtomicInteger();
-
-    client = client.newBuilder()
-        .addInterceptor(chain -> {
-          assertThat(chain.request().body()).isNull();
-          Response response = chain.proceed(chain.request());
-          assertThat(response.header("Connection")).isEqualTo("Upgrade");
-          assertThat(response.body().source().exhausted()).isTrue();
-          interceptedCount.incrementAndGet();
-          return response;
-        })
-        .build();
-
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    WebSocket webSocket = newWebSocket();
-    clientListener.assertOpen();
-    assertThat(interceptedCount.get()).isEqualTo(1);
-
-    closeWebSockets(webSocket, serverListener.assertOpen());
-  }
-
-  @Test public void webSocketAndNetworkInterceptors() {
-    client = client.newBuilder()
-        .addNetworkInterceptor(chain -> {
-          throw new AssertionError(); // Network interceptors don't execute.
-        })
-        .build();
-
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    WebSocket webSocket = newWebSocket();
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    closeWebSockets(webSocket, server);
-  }
-
-  @Test public void overflowOutgoingQueue() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    WebSocket webSocket = newWebSocket();
-    clientListener.assertOpen();
-
-    // Send messages until the client's outgoing buffer overflows!
-    ByteString message = ByteString.of(new byte[1024 * 1024]);
-    long messageCount = 0;
-    while (true) {
-      boolean success = webSocket.send(message);
-      if (!success) break;
-
-      messageCount++;
-      long queueSize = webSocket.queueSize();
-      assertThat(queueSize).isBetween(0L, messageCount * message.size());
-      // Expect to fail before enqueueing 32 MiB.
-      assertThat(messageCount).isLessThan(32L);
-    }
-
-    // Confirm all sent messages were received, followed by a client-initiated close.
-    WebSocket server = serverListener.assertOpen();
-    for (int i = 0; i < messageCount; i++) {
-      serverListener.assertBinaryMessage(message);
-    }
-    serverListener.assertClosing(1001, "");
-
-    // When the server acknowledges the close the connection shuts down gracefully.
-    server.close(1000, null);
-    clientListener.assertClosing(1000, "");
-    clientListener.assertClosed(1000, "");
-    serverListener.assertClosed(1001, "");
-  }
-
-  @Test public void closeReasonMaximumLength() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    String clientReason = repeat('C', 123);
-    String serverReason = repeat('S', 123);
-
-    WebSocket webSocket = newWebSocket();
-    WebSocket server = serverListener.assertOpen();
-
-    clientListener.assertOpen();
-    webSocket.close(1000, clientReason);
-    serverListener.assertClosing(1000, clientReason);
-
-    server.close(1000, serverReason);
-    clientListener.assertClosing(1000, serverReason);
-    clientListener.assertClosed(1000, serverReason);
-
-    serverListener.assertClosed(1000, clientReason);
-  }
-
-  @Test public void closeReasonTooLong() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    WebSocket webSocket = newWebSocket();
-    WebSocket server = serverListener.assertOpen();
-
-    clientListener.assertOpen();
-    String reason = repeat('X', 124);
-    try {
-      webSocket.close(1000, reason);
-      fail();
-    } catch (IllegalArgumentException expected) {
-      assertThat(expected.getMessage()).isEqualTo(("reason.size() > 123: " + reason));
-    }
-
-    webSocket.close(1000, null);
-    serverListener.assertClosing(1000, "");
-
-    server.close(1000, null);
-    clientListener.assertClosing(1000, "");
-    clientListener.assertClosed(1000, "");
-
-    serverListener.assertClosed(1000, "");
-  }
-
-  @Test public void wsScheme() {
-    websocketScheme("ws");
-  }
-
-  @Test public void wsUppercaseScheme() {
-    websocketScheme("WS");
-  }
-
-  @Test public void wssScheme() {
-    webServer.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    websocketScheme("wss");
-  }
-
-  @Test public void httpsScheme() {
-    webServer.useHttps(handshakeCertificates.sslSocketFactory(), false);
-    client = client.newBuilder()
-        .sslSocketFactory(
-            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
-        .hostnameVerifier(new RecordingHostnameVerifier())
-        .build();
-
-    websocketScheme("https");
-  }
-
-  @Test public void readTimeoutAppliesToHttpRequest() {
-    webServer.enqueue(new MockResponse()
-        .setSocketPolicy(SocketPolicy.NO_RESPONSE));
-
-    WebSocket webSocket = newWebSocket();
-
-    clientListener.assertFailure(SocketTimeoutException.class, "timeout", "Read timed out");
-    assertThat(webSocket.close(1000, null)).isFalse();
-  }
-
-  /**
-   * There's no read timeout when reading the first byte of a new frame. But as soon as we start
-   * reading a frame we enable the read timeout. In this test we have the server returning the first
-   * byte of a frame but no more frames.
-   */
-  @Test public void readTimeoutAppliesWithinFrames() {
-    webServer.setDispatcher(new Dispatcher() {
-      @Override public MockResponse dispatch(RecordedRequest request) {
-        return upgradeResponse(request)
-            .setBody(new Buffer().write(ByteString.decodeHex("81"))) // Truncated frame.
-            .removeHeader("Content-Length")
-            .setSocketPolicy(SocketPolicy.KEEP_OPEN);
-      }
-    });
-
-    WebSocket webSocket = newWebSocket();
-    clientListener.assertOpen();
-
-    clientListener.assertFailure(SocketTimeoutException.class, "timeout", "Read timed out");
-    assertThat(webSocket.close(1000, null)).isFalse();
-  }
-
-  @Test public void readTimeoutDoesNotApplyAcrossFrames() throws Exception {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    WebSocket webSocket = newWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    // Sleep longer than the HTTP client's read timeout.
-    Thread.sleep(client.readTimeoutMillis() + 500);
-
-    server.send("abc");
-    clientListener.assertTextMessage("abc");
-
-    closeWebSockets(webSocket, server);
-  }
-
-  @Test public void clientPingsServerOnInterval() throws Exception {
-    client = client.newBuilder()
-        .pingInterval(500, TimeUnit.MILLISECONDS)
-        .build();
-
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    RealWebSocket webSocket = newWebSocket();
-
-    clientListener.assertOpen();
-    RealWebSocket server = (RealWebSocket) serverListener.assertOpen();
-
-    long startNanos = System.nanoTime();
-    while (webSocket.receivedPongCount() < 3) {
-      Thread.sleep(50);
-    }
-
-    long elapsedUntilPong3 = System.nanoTime() - startNanos;
-    assertThat(TimeUnit.NANOSECONDS.toMillis(elapsedUntilPong3))
-        .isCloseTo(1500L, offset(250L));
-
-    // The client pinged the server 3 times, and it has ponged back 3 times.
-    assertThat(webSocket.sentPingCount()).isEqualTo(3);
-    assertThat(server.receivedPingCount()).isEqualTo(3);
-    assertThat(webSocket.receivedPongCount()).isEqualTo(3);
-
-    // The server has never pinged the client.
-    assertThat(server.receivedPongCount()).isEqualTo(0);
-    assertThat(webSocket.receivedPingCount()).isEqualTo(0);
-
-    closeWebSockets(webSocket, server);
-  }
-
-  @Test public void clientDoesNotPingServerByDefault() throws Exception {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    RealWebSocket webSocket = newWebSocket();
-
-    clientListener.assertOpen();
-    RealWebSocket server = (RealWebSocket) serverListener.assertOpen();
-
-    Thread.sleep(1000);
-
-    // No pings and no pongs.
-    assertThat(webSocket.sentPingCount()).isEqualTo(0);
-    assertThat(webSocket.receivedPingCount()).isEqualTo(0);
-    assertThat(webSocket.receivedPongCount()).isEqualTo(0);
-    assertThat(server.sentPingCount()).isEqualTo(0);
-    assertThat(server.receivedPingCount()).isEqualTo(0);
-    assertThat(server.receivedPongCount()).isEqualTo(0);
-
-    closeWebSockets(webSocket, server);
-  }
-
-  /**
-   * Configure the websocket to send pings every 500 ms. Artificially prevent the server from
-   * responding to pings. The client should give up when attempting to send its 2nd ping, at about
-   * 1000 ms.
-   */
-  @Test public void unacknowledgedPingFailsConnection() {
-    client = client.newBuilder()
-        .pingInterval(500, TimeUnit.MILLISECONDS)
-        .build();
-
-    // Stall in onOpen to prevent pongs from being sent.
-    final CountDownLatch latch = new CountDownLatch(1);
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(new WebSocketListener() {
-      @Override public void onOpen(WebSocket webSocket, Response response) {
-        try {
-          latch.await(); // The server can't respond to pings!
-        } catch (InterruptedException e) {
-          throw new AssertionError(e);
-        }
-      }
-    }));
-
-    long openAtNanos = System.nanoTime();
-    newWebSocket();
-    clientListener.assertOpen();
-    clientListener.assertFailure(SocketTimeoutException.class,
-        "sent ping but didn't receive pong within 500ms (after 0 successful ping/pongs)");
-    latch.countDown();
-
-    long elapsedUntilFailure = System.nanoTime() - openAtNanos;
-    assertThat(TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure))
-        .isCloseTo(1000L, offset(250L));
-  }
-
-  /** https://github.com/square/okhttp/issues/2788 */
-  @Test public void clientCancelsIfCloseIsNotAcknowledged() {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    RealWebSocket webSocket = newWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    // Initiate a close on the client, which will schedule a hard cancel in 500 ms.
-    long closeAtNanos = System.nanoTime();
-    webSocket.close(1000, "goodbye", 500L);
-    serverListener.assertClosing(1000, "goodbye");
-
-    // Confirm that the hard cancel occurred after 500 ms.
-    clientListener.assertFailure();
-    long elapsedUntilFailure = System.nanoTime() - closeAtNanos;
-    assertThat(TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure))
-        .isCloseTo(500L, offset(250L));
-
-    // Close the server and confirm it saw what we expected.
-    server.close(1000, null);
-    serverListener.assertClosed(1000, "goodbye");
-  }
-
-  @Test public void webSocketsDontTriggerEventListener() {
-    RecordingEventListener listener = new RecordingEventListener();
-
-    client = client.newBuilder()
-        .eventListener(listener)
-        .build();
-
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-    WebSocket webSocket = newWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    webSocket.send("Web Sockets and Events?!");
-    serverListener.assertTextMessage("Web Sockets and Events?!");
-
-    webSocket.close(1000, "");
-    serverListener.assertClosing(1000, "");
-
-    server.close(1000, "");
-    clientListener.assertClosing(1000, "");
-    clientListener.assertClosed(1000, "");
-    serverListener.assertClosed(1000, "");
-
-    assertThat(listener.recordedEventTypes()).isEmpty();
-  }
-
-  @Test public void callTimeoutAppliesToSetup() throws Exception {
-    webServer.enqueue(new MockResponse()
-        .setHeadersDelay(500, TimeUnit.MILLISECONDS));
-
-    client = client.newBuilder()
-        .readTimeout(0, TimeUnit.MILLISECONDS)
-        .writeTimeout(0, TimeUnit.MILLISECONDS)
-        .callTimeout(100, TimeUnit.MILLISECONDS)
-        .build();
-
-    newWebSocket();
-    clientListener.assertFailure(InterruptedIOException.class, "timeout");
-  }
-
-  @Test public void callTimeoutDoesNotApplyOnceConnected() throws Exception {
-    client = client.newBuilder()
-        .callTimeout(100, TimeUnit.MILLISECONDS)
-        .build();
-
-    webServer.enqueue(new MockResponse()
-        .withWebSocketUpgrade(serverListener));
-    WebSocket webSocket = newWebSocket();
-
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    Thread.sleep(500);
-
-    server.send("Hello, WebSockets!");
-    clientListener.assertTextMessage("Hello, WebSockets!");
-
-    closeWebSockets(webSocket, server);
-  }
-
-  /**
-   * We had a bug where web socket connections were leaked if the HTTP connection upgrade was not
-   * successful. This test confirms that connections are released back to the connection pool!
-   * https://github.com/square/okhttp/issues/4258
-   */
-  @Test public void webSocketConnectionIsReleased() throws Exception {
-    // This test assumes HTTP/1.1 pooling semantics.
-    client = client.newBuilder()
-        .protocols(asList(Protocol.HTTP_1_1))
-        .build();
-
-    webServer.enqueue(new MockResponse()
-        .setResponseCode(HttpURLConnection.HTTP_NOT_FOUND)
-        .setBody("not found!"));
-    webServer.enqueue(new MockResponse());
-
-    newWebSocket();
-    clientListener.assertFailure();
-
-    Request regularRequest = new Request.Builder()
-        .url(webServer.url("/"))
-        .build();
-    Response response = client.newCall(regularRequest).execute();
-    response.close();
-
-    assertThat(webServer.takeRequest().getSequenceNumber()).isEqualTo(0);
-    assertThat(webServer.takeRequest().getSequenceNumber()).isEqualTo(1);
-  }
-
-  private MockResponse upgradeResponse(RecordedRequest request) {
-    String key = request.getHeader("Sec-WebSocket-Key");
-    return new MockResponse()
-        .setStatus("HTTP/1.1 101 Switching Protocols")
-        .setHeader("Connection", "Upgrade")
-        .setHeader("Upgrade", "websocket")
-        .setHeader("Sec-WebSocket-Accept", WebSocketProtocol.INSTANCE.acceptHeader(key));
-  }
-
-  private void websocketScheme(String scheme) {
-    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
-
-    Request request = new Request.Builder()
-        .url(scheme + "://" + webServer.getHostName() + ":" + webServer.getPort() + "/")
-        .build();
-
-    RealWebSocket webSocket = newWebSocket(request);
-    clientListener.assertOpen();
-    WebSocket server = serverListener.assertOpen();
-
-    webSocket.send("abc");
-    serverListener.assertTextMessage("abc");
-
-    closeWebSockets(webSocket, server);
-  }
-
-  private RealWebSocket newWebSocket() {
-    return newWebSocket(new Request.Builder().get().url(webServer.url("/")).build());
-  }
-
-  private RealWebSocket newWebSocket(Request request) {
-    RealWebSocket webSocket = new RealWebSocket(
-        TaskRunner.INSTANCE, request, clientListener, random, client.pingIntervalMillis());
-    webSocket.connect(client);
-    return webSocket;
-  }
-
-  private void closeWebSockets(WebSocket webSocket, WebSocket server) {
-    server.close(1001, "");
-    clientListener.assertClosing(1001, "");
-    webSocket.close(1000, "");
-    serverListener.assertClosing(1000, "");
-    clientListener.assertClosed(1001, "");
-    serverListener.assertClosed(1000, "");
-    clientListener.assertExhausted();
-    serverListener.assertExhausted();
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
deleted file mode 100644
index 02995e30df..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
+++ /dev/null
@@ -1,323 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.net.ProtocolException;
-import java.util.Random;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.ByteString;
-import org.junit.After;
-import org.junit.Test;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class WebSocketReaderTest {
-  private final Buffer data = new Buffer();
-  private final WebSocketRecorder callback = new WebSocketRecorder("client");
-  private final Random random = new Random(0);
-
-  // Mutually exclusive. Use the one corresponding to the peer whose behavior you wish to test.
-  final WebSocketReader serverReader = new WebSocketReader(false, data, callback.asFrameCallback());
-  final WebSocketReader clientReader = new WebSocketReader(true, data, callback.asFrameCallback());
-
-  @After public void tearDown() {
-    callback.assertExhausted();
-  }
-
-  @Test public void controlFramesMustBeFinal() throws IOException {
-    data.write(ByteString.decodeHex("0a00")); // Empty pong.
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (ProtocolException e) {
-      assertThat(e.getMessage()).isEqualTo("Control frames must be final.");
-    }
-  }
-
-  @Test public void reservedFlagsAreUnsupported() throws IOException {
-    data.write(ByteString.decodeHex("ca00")); // Empty pong, flag 1 set.
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (ProtocolException e) {
-      assertThat(e.getMessage()).isEqualTo("Reserved flags are unsupported.");
-    }
-    data.clear();
-    data.write(ByteString.decodeHex("aa00")); // Empty pong, flag 2 set.
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (ProtocolException e) {
-      assertThat(e.getMessage()).isEqualTo("Reserved flags are unsupported.");
-    }
-    data.clear();
-    data.write(ByteString.decodeHex("9a00")); // Empty pong, flag 3 set.
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (ProtocolException e) {
-      assertThat(e.getMessage()).isEqualTo("Reserved flags are unsupported.");
-    }
-  }
-
-  @Test public void clientSentFramesMustBeMasked() throws IOException {
-    data.write(ByteString.decodeHex("8100"));
-    try {
-      serverReader.processNextFrame();
-      fail();
-    } catch (ProtocolException e) {
-      assertThat(e.getMessage()).isEqualTo("Client-sent frames must be masked.");
-    }
-  }
-
-  @Test public void serverSentFramesMustNotBeMasked() throws IOException {
-    data.write(ByteString.decodeHex("8180"));
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (ProtocolException e) {
-      assertThat(e.getMessage()).isEqualTo("Server-sent frames must not be masked.");
-    }
-  }
-
-  @Test public void controlFramePayloadMax() throws IOException {
-    data.write(ByteString.decodeHex("8a7e007e"));
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (ProtocolException e) {
-      assertThat(e.getMessage()).isEqualTo("Control frame must be less than 125B.");
-    }
-  }
-
-  @Test public void clientSimpleHello() throws IOException {
-    data.write(ByteString.decodeHex("810548656c6c6f")); // Hello
-    clientReader.processNextFrame();
-    callback.assertTextMessage("Hello");
-  }
-
-  @Test public void serverSimpleHello() throws IOException {
-    data.write(ByteString.decodeHex("818537fa213d7f9f4d5158")); // Hello
-    serverReader.processNextFrame();
-    callback.assertTextMessage("Hello");
-  }
-
-  @Test public void clientFramePayloadShort() throws IOException {
-    data.write(ByteString.decodeHex("817E000548656c6c6f")); // Hello
-    clientReader.processNextFrame();
-    callback.assertTextMessage("Hello");
-  }
-
-  @Test public void clientFramePayloadLong() throws IOException {
-    data.write(ByteString.decodeHex("817f000000000000000548656c6c6f")); // Hello
-    clientReader.processNextFrame();
-    callback.assertTextMessage("Hello");
-  }
-
-  @Test public void clientFramePayloadTooLongThrows() throws IOException {
-    data.write(ByteString.decodeHex("817f8000000000000000"));
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (ProtocolException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "Frame length 0x8000000000000000 > 0x7FFFFFFFFFFFFFFF");
-    }
-  }
-
-  @Test public void serverHelloTwoChunks() throws IOException {
-    data.write(ByteString.decodeHex("818537fa213d7f9f4d")); // Hel
-    data.write(ByteString.decodeHex("5158")); // lo
-
-    serverReader.processNextFrame();
-
-    callback.assertTextMessage("Hello");
-  }
-
-  @Test public void clientTwoFrameHello() throws IOException {
-    data.write(ByteString.decodeHex("010348656c")); // Hel
-    data.write(ByteString.decodeHex("80026c6f")); // lo
-    clientReader.processNextFrame();
-    callback.assertTextMessage("Hello");
-  }
-
-  @Test public void clientTwoFrameHelloWithPongs() throws IOException {
-    data.write(ByteString.decodeHex("010348656c")); // Hel
-    data.write(ByteString.decodeHex("8a00")); // Pong
-    data.write(ByteString.decodeHex("8a00")); // Pong
-    data.write(ByteString.decodeHex("8a00")); // Pong
-    data.write(ByteString.decodeHex("8a00")); // Pong
-    data.write(ByteString.decodeHex("80026c6f")); // lo
-    clientReader.processNextFrame();
-    callback.assertPong(ByteString.EMPTY);
-    callback.assertPong(ByteString.EMPTY);
-    callback.assertPong(ByteString.EMPTY);
-    callback.assertPong(ByteString.EMPTY);
-    callback.assertTextMessage("Hello");
-  }
-
-  @Test public void clientIncompleteMessageBodyThrows() throws IOException {
-    data.write(ByteString.decodeHex("810548656c")); // Length = 5, "Hel"
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (EOFException ignored) {
-    }
-  }
-
-  @Test public void clientIncompleteControlFrameBodyThrows() throws IOException {
-    data.write(ByteString.decodeHex("8a0548656c")); // Length = 5, "Hel"
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (EOFException ignored) {
-    }
-  }
-
-  @Test public void serverIncompleteMessageBodyThrows() throws IOException {
-    data.write(ByteString.decodeHex("818537fa213d7f9f4d")); // Length = 5, "Hel"
-    try {
-      serverReader.processNextFrame();
-      fail();
-    } catch (EOFException ignored) {
-    }
-  }
-
-  @Test public void serverIncompleteControlFrameBodyThrows() throws IOException {
-    data.write(ByteString.decodeHex("8a8537fa213d7f9f4d")); // Length = 5, "Hel"
-    try {
-      serverReader.processNextFrame();
-      fail();
-    } catch (EOFException ignored) {
-    }
-  }
-
-  @Test public void clientSimpleBinary() throws IOException {
-    byte[] bytes = binaryData(256);
-    data.write(ByteString.decodeHex("827E0100")).write(bytes);
-    clientReader.processNextFrame();
-    callback.assertBinaryMessage(ByteString.of(bytes));
-  }
-
-  @Test public void clientTwoFrameBinary() throws IOException {
-    byte[] bytes = binaryData(200);
-    data.write(ByteString.decodeHex("0264")).write(bytes, 0, 100);
-    data.write(ByteString.decodeHex("8064")).write(bytes, 100, 100);
-    clientReader.processNextFrame();
-    callback.assertBinaryMessage(ByteString.of(bytes));
-  }
-
-  @Test public void twoFrameNotContinuation() throws IOException {
-    byte[] bytes = binaryData(200);
-    data.write(ByteString.decodeHex("0264")).write(bytes, 0, 100);
-    data.write(ByteString.decodeHex("8264")).write(bytes, 100, 100);
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (ProtocolException e) {
-      assertThat(e.getMessage()).isEqualTo("Expected continuation opcode. Got: 2");
-    }
-  }
-
-  @Test public void emptyPingCallsCallback() throws IOException {
-    data.write(ByteString.decodeHex("8900")); // Empty ping
-    clientReader.processNextFrame();
-    callback.assertPing(ByteString.EMPTY);
-  }
-
-  @Test public void pingCallsCallback() throws IOException {
-    data.write(ByteString.decodeHex("890548656c6c6f")); // Ping with "Hello"
-    clientReader.processNextFrame();
-    callback.assertPing(ByteString.encodeUtf8("Hello"));
-  }
-
-  @Test public void emptyCloseCallsCallback() throws IOException {
-    data.write(ByteString.decodeHex("8800")); // Empty close
-    clientReader.processNextFrame();
-    callback.assertClosing(1005, "");
-  }
-
-  @Test public void closeLengthOfOneThrows() throws IOException {
-    data.write(ByteString.decodeHex("880100")); // Close with invalid 1-byte payload
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (ProtocolException e) {
-      assertThat(e.getMessage()).isEqualTo("Malformed close payload length of 1.");
-    }
-  }
-
-  @Test public void closeCallsCallback() throws IOException {
-    data.write(ByteString.decodeHex("880703e848656c6c6f")); // Close with code and reason
-    clientReader.processNextFrame();
-    callback.assertClosing(1000, "Hello");
-  }
-
-  @Test public void closeIncompleteCallsCallback() throws IOException {
-    data.write(ByteString.decodeHex("880703e948656c6c6f")); // Close with code and reason
-    data.close();
-    clientReader.processNextFrame();
-    callback.assertClosing(1001, "Hello");
-  }
-
-  @Test public void closeOutOfRangeThrows() throws IOException {
-    data.write(ByteString.decodeHex("88020001")); // Close with code 1
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (ProtocolException e) {
-      assertThat(e.getMessage()).isEqualTo("Code must be in range [1000,5000): 1");
-    }
-    data.write(ByteString.decodeHex("88021388")); // Close with code 5000
-    try {
-      clientReader.processNextFrame();
-      fail();
-    } catch (ProtocolException e) {
-      assertThat(e.getMessage()).isEqualTo("Code must be in range [1000,5000): 5000");
-    }
-  }
-
-  @Test public void closeReservedSetThrows() throws IOException {
-    data.write(ByteString.decodeHex("880203ec")); // Close with code 1004
-    data.write(ByteString.decodeHex("880203ed")); // Close with code 1005
-    data.write(ByteString.decodeHex("880203ee")); // Close with code 1006
-    for (int i = 1015; i <= 2999; i++) {
-      data.write(ByteString.decodeHex(
-          "8802" + Util.format("%04X", i))); // Close with code 'i'
-    }
-
-    int count = 0;
-    for (; !data.exhausted(); count++) {
-      try {
-        clientReader.processNextFrame();
-        fail();
-      } catch (ProtocolException e) {
-        assertThat(e.getMessage()).matches("Code \\d+ is reserved and may not be used.");
-      }
-    }
-    assertThat(count).isEqualTo(1988);
-  }
-
-  private byte[] binaryData(int length) {
-    byte[] junk = new byte[length];
-    random.nextBytes(junk);
-    return junk;
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
deleted file mode 100644
index 17a43c5fa7..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
+++ /dev/null
@@ -1,402 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import java.io.IOException;
-import java.util.Objects;
-import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.LinkedBlockingQueue;
-import java.util.concurrent.TimeUnit;
-import javax.annotation.Nullable;
-import okhttp3.Response;
-import okhttp3.WebSocket;
-import okhttp3.WebSocketListener;
-import okhttp3.internal.platform.Platform;
-import okio.ByteString;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-public final class WebSocketRecorder extends WebSocketListener {
-  private final String name;
-  private final BlockingQueue<Object> events = new LinkedBlockingQueue<>();
-  private WebSocketListener delegate;
-
-  public WebSocketRecorder(String name) {
-    this.name = name;
-  }
-
-  /** Sets a delegate for handling the next callback to this listener. Cleared after invoked. */
-  public void setNextEventDelegate(WebSocketListener delegate) {
-    this.delegate = delegate;
-  }
-
-  @Override public void onOpen(WebSocket webSocket, Response response) {
-    Platform.get().log("[WS " + name + "] onOpen", Platform.INFO, null);
-
-    WebSocketListener delegate = this.delegate;
-    if (delegate != null) {
-      this.delegate = null;
-      delegate.onOpen(webSocket, response);
-    } else {
-      events.add(new Open(webSocket, response));
-    }
-  }
-
-  @Override public void onMessage(WebSocket webSocket, ByteString bytes) {
-    Platform.get().log("[WS " + name + "] onMessage", Platform.INFO, null);
-
-    WebSocketListener delegate = this.delegate;
-    if (delegate != null) {
-      this.delegate = null;
-      delegate.onMessage(webSocket, bytes);
-    } else {
-      Message event = new Message(bytes);
-      events.add(event);
-    }
-  }
-
-  @Override public void onMessage(WebSocket webSocket, String text) {
-    Platform.get().log("[WS " + name + "] onMessage", Platform.INFO, null);
-
-    WebSocketListener delegate = this.delegate;
-    if (delegate != null) {
-      this.delegate = null;
-      delegate.onMessage(webSocket, text);
-    } else {
-      Message event = new Message(text);
-      events.add(event);
-    }
-  }
-
-  @Override public void onClosing(WebSocket webSocket, int code, String reason) {
-    Platform.get().log("[WS " + name + "] onClosing " + code, Platform.INFO, null);
-
-    WebSocketListener delegate = this.delegate;
-    if (delegate != null) {
-      this.delegate = null;
-      delegate.onClosing(webSocket, code, reason);
-    } else {
-      events.add(new Closing(code, reason));
-    }
-  }
-
-  @Override public void onClosed(WebSocket webSocket, int code, String reason) {
-    Platform.get().log("[WS " + name + "] onClosed " + code, Platform.INFO, null);
-
-    WebSocketListener delegate = this.delegate;
-    if (delegate != null) {
-      this.delegate = null;
-      delegate.onClosed(webSocket, code, reason);
-    } else {
-      events.add(new Closed(code, reason));
-    }
-  }
-
-  @Override public void onFailure(WebSocket webSocket, Throwable t, @Nullable Response response)  {
-    Platform.get().log("[WS " + name + "] onFailure", Platform.INFO, t);
-
-    WebSocketListener delegate = this.delegate;
-    if (delegate != null) {
-      this.delegate = null;
-      delegate.onFailure(webSocket, t, response);
-    } else {
-      events.add(new Failure(t, response));
-    }
-  }
-
-  private Object nextEvent() {
-    try {
-      Object event = events.poll(10, TimeUnit.SECONDS);
-      if (event == null) {
-        throw new AssertionError("Timed out waiting for event.");
-      }
-      return event;
-    } catch (InterruptedException e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  public void assertTextMessage(String payload) {
-    Object actual = nextEvent();
-    assertThat(actual).isEqualTo(new Message(payload));
-  }
-
-  public void assertBinaryMessage(ByteString payload) {
-    Object actual = nextEvent();
-    assertThat(actual).isEqualTo(new Message(payload));
-  }
-
-  public void assertPing(ByteString payload) {
-    Object actual = nextEvent();
-    assertThat(actual).isEqualTo(new Ping(payload));
-  }
-
-  public void assertPong(ByteString payload) {
-    Object actual = nextEvent();
-    assertThat(actual).isEqualTo(new Pong(payload));
-  }
-
-  public void assertClosing(int code, String reason) {
-    Object actual = nextEvent();
-    assertThat(actual).isEqualTo(new Closing(code, reason));
-  }
-
-  public void assertClosed(int code, String reason) {
-    Object actual = nextEvent();
-    assertThat(actual).isEqualTo(new Closed(code, reason));
-  }
-
-  public void assertExhausted() {
-    assertThat(events).isEmpty();
-  }
-
-  public WebSocket assertOpen() {
-    Object event = nextEvent();
-    if (!(event instanceof Open)) {
-      throw new AssertionError("Expected Open but was " + event);
-    }
-    return ((Open) event).webSocket;
-  }
-
-  public void assertFailure(Throwable t) {
-    Object event = nextEvent();
-    if (!(event instanceof Failure)) {
-      throw new AssertionError("Expected Failure but was " + event);
-    }
-    Failure failure = (Failure) event;
-    assertThat(failure.response).isNull();
-    assertThat(failure.t).isSameAs(t);
-  }
-
-  public void assertFailure(Class<? extends IOException> cls, String... messages) {
-    Object event = nextEvent();
-    if (!(event instanceof Failure)) {
-      throw new AssertionError("Expected Failure but was " + event);
-    }
-    Failure failure = (Failure) event;
-    assertThat(failure.response).isNull();
-    assertThat(failure.t.getClass()).isEqualTo(cls);
-    if (messages.length > 0) {
-      assertThat(messages).contains(failure.t.getMessage());
-    }
-  }
-
-  public void assertFailure() {
-    Object event = nextEvent();
-    if (!(event instanceof Failure)) {
-      throw new AssertionError("Expected Failure but was " + event);
-    }
-  }
-
-  public void assertFailure(int code, String body, Class<? extends IOException> cls, String message)
-      throws IOException {
-    Object event = nextEvent();
-    if (!(event instanceof Failure)) {
-      throw new AssertionError("Expected Failure but was " + event);
-    }
-    Failure failure = (Failure) event;
-    assertThat(failure.response.code()).isEqualTo(code);
-    if (body != null) {
-      assertThat(failure.responseBody).isEqualTo(body);
-    }
-    assertThat(failure.t.getClass()).isEqualTo(cls);
-    assertThat(failure.t.getMessage()).isEqualTo(message);
-  }
-
-  /** Expose this recorder as a frame callback and shim in "ping" events. */
-  public WebSocketReader.FrameCallback asFrameCallback() {
-    return new WebSocketReader.FrameCallback() {
-      @Override public void onReadMessage(String text) throws IOException {
-        onMessage(null, text);
-      }
-
-      @Override public void onReadMessage(ByteString bytes) throws IOException {
-        onMessage(null, bytes);
-      }
-
-      @Override public void onReadPing(ByteString payload) {
-        events.add(new Ping(payload));
-      }
-
-      @Override public void onReadPong(ByteString payload) {
-        events.add(new Pong(payload));
-      }
-
-      @Override public void onReadClose(int code, String reason) {
-        onClosing(null, code, reason);
-      }
-    };
-  }
-
-  static final class Open {
-    final WebSocket webSocket;
-    final Response response;
-
-    Open(WebSocket webSocket, Response response) {
-      this.webSocket = webSocket;
-      this.response = response;
-    }
-
-    @Override public String toString() {
-      return "Open[" + response + "]";
-    }
-  }
-
-  static final class Failure {
-    final Throwable t;
-    final Response response;
-    final String responseBody;
-
-    Failure(Throwable t, Response response) {
-      this.t = t;
-      this.response = response;
-      String responseBody = null;
-      if (response != null) {
-        try {
-          responseBody = response.body().string();
-        } catch (IOException ignored) {
-        }
-      }
-      this.responseBody = responseBody;
-    }
-
-    @Override public String toString() {
-      if (response == null) {
-        return "Failure[" + t + "]";
-      }
-      return "Failure[" + response + "]";
-    }
-  }
-
-  static final class Message {
-    public final ByteString bytes;
-    public final String string;
-
-    public Message(ByteString bytes) {
-      this.bytes = bytes;
-      this.string = null;
-    }
-
-    public Message(String string) {
-      this.bytes = null;
-      this.string = string;
-    }
-
-    @Override public String toString() {
-      return "Message[" + (bytes != null ? bytes : string) + "]";
-    }
-
-    @Override public int hashCode() {
-      return (bytes != null ? bytes : string).hashCode();
-    }
-
-    @Override public boolean equals(Object other) {
-      return other instanceof Message
-          && Objects.equals(((Message) other).bytes, bytes)
-          && Objects.equals(((Message) other).string, string);
-    }
-  }
-
-  static final class Ping {
-    public final ByteString payload;
-
-    public Ping(ByteString payload) {
-      this.payload = payload;
-    }
-
-    @Override public String toString() {
-      return "Ping[" + payload + "]";
-    }
-
-    @Override public int hashCode() {
-      return payload.hashCode();
-    }
-
-    @Override public boolean equals(Object other) {
-      return other instanceof Ping
-          && ((Ping) other).payload.equals(payload);
-    }
-  }
-
-  static final class Pong {
-    public final ByteString payload;
-
-    public Pong(ByteString payload) {
-      this.payload = payload;
-    }
-
-    @Override public String toString() {
-      return "Pong[" + payload + "]";
-    }
-
-    @Override public int hashCode() {
-      return payload.hashCode();
-    }
-
-    @Override public boolean equals(Object other) {
-      return other instanceof Pong
-          && ((Pong) other).payload.equals(payload);
-    }
-  }
-
-  static final class Closing {
-    public final int code;
-    public final String reason;
-
-    Closing(int code, String reason) {
-      this.code = code;
-      this.reason = reason;
-    }
-
-    @Override public String toString() {
-      return "Closing[" + code + " " + reason + "]";
-    }
-
-    @Override public int hashCode() {
-      return code * 37 + reason.hashCode();
-    }
-
-    @Override public boolean equals(Object other) {
-      return other instanceof Closing
-          && ((Closing) other).code == code
-          && ((Closing) other).reason.equals(reason);
-    }
-  }
-
-  static final class Closed {
-    public final int code;
-    public final String reason;
-
-    Closed(int code, String reason) {
-      this.code = code;
-      this.reason = reason;
-    }
-
-    @Override public String toString() {
-      return "Closed[" + code + " " + reason + "]";
-    }
-
-    @Override public int hashCode() {
-      return code * 37 + reason.hashCode();
-    }
-
-    @Override public boolean equals(Object other) {
-      return other instanceof Closed
-          && ((Closed) other).code == code
-          && ((Closed) other).reason.equals(reason);
-    }
-  }
-}
diff --git a/okhttp/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java b/okhttp/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
deleted file mode 100644
index 0d3cbe9171..0000000000
--- a/okhttp/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
+++ /dev/null
@@ -1,411 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.ws;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.util.Random;
-import okhttp3.RequestBody;
-import okhttp3.internal.Util;
-import okio.Buffer;
-import okio.BufferedSink;
-import okio.ByteString;
-import okio.Okio;
-import okio.Sink;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.rules.TestRule;
-import org.junit.runners.model.Statement;
-
-import static okhttp3.TestUtil.repeat;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_BINARY;
-import static okhttp3.internal.ws.WebSocketProtocol.OPCODE_TEXT;
-import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_BYTE_MAX;
-import static okhttp3.internal.ws.WebSocketProtocol.PAYLOAD_SHORT_MAX;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-public final class WebSocketWriterTest {
-  private final Buffer data = new Buffer();
-  private final Random random = new Random(0);
-
-  /**
-   * Check all data as verified inside of the test. We do this in a rule instead of @After so that
-   * exceptions thrown from the test do not cause this check to fail.
-   */
-  @Rule public final TestRule noDataLeftBehind = (base, description) -> new Statement() {
-    @Override public void evaluate() throws Throwable {
-      base.evaluate();
-      assertThat(data.readByteString().hex()).overridingErrorMessage("Data not empty").isEqualTo(
-          "");
-    }
-  };
-
-  // Mutually exclusive. Use the one corresponding to the peer whose behavior you wish to test.
-  private final WebSocketWriter serverWriter = new WebSocketWriter(false, data, random);
-  private final WebSocketWriter clientWriter = new WebSocketWriter(true, data, random);
-
-  @Test public void serverTextMessage() throws IOException {
-    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, -1));
-
-    sink.writeUtf8("Hel").flush();
-    assertData("010348656c");
-
-    sink.writeUtf8("lo").flush();
-    assertData("00026c6f");
-
-    sink.close();
-    assertData("8000");
-  }
-
-  @Test public void serverSmallBufferedPayloadWrittenAsOneFrame() throws IOException {
-    int length = 5;
-    byte[] bytes = binaryData(length);
-
-    RequestBody body = RequestBody.create(bytes, null);
-    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, length));
-    body.writeTo(sink);
-    sink.close();
-
-    assertData("8105");
-    assertData(bytes);
-    assertThat(data.exhausted()).isTrue();
-  }
-
-  @Test public void serverLargeBufferedPayloadWrittenAsOneFrame() throws IOException {
-    int length = 12345;
-    byte[] bytes = binaryData(length);
-
-    RequestBody body = RequestBody.create(bytes, null);
-    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, length));
-    body.writeTo(sink);
-    sink.close();
-
-    assertData("817e");
-    assertData(Util.format("%04x", length));
-    assertData(bytes);
-    assertThat(data.exhausted()).isTrue();
-  }
-
-  @Test public void serverLargeNonBufferedPayloadWrittenAsMultipleFrames() throws IOException {
-    int length = 100_000;
-    Buffer bytes = new Buffer().write(binaryData(length));
-
-    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, length));
-    Buffer body = bytes.clone();
-    sink.write(body.readByteString(20_000));
-    sink.write(body.readByteString(20_000));
-    sink.write(body.readByteString(20_000));
-    sink.write(body.readByteString(20_000));
-    sink.write(body.readByteString(20_000));
-    sink.close();
-
-    assertData("017e4000");
-    assertData(bytes.readByteArray(16_384));
-    assertData("007e4000");
-    assertData(bytes.readByteArray(16_384));
-    assertData("007e6000");
-    assertData(bytes.readByteArray(24_576));
-    assertData("007e4000");
-    assertData(bytes.readByteArray(16_384));
-    assertData("007e6000");
-    assertData(bytes.readByteArray(24_576));
-    assertData("807e06a0");
-    assertData(bytes.readByteArray(1_696));
-    assertThat(data.exhausted()).isTrue();
-  }
-
-  @Test public void closeFlushes() throws IOException {
-    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_TEXT, -1));
-
-    sink.writeUtf8("Hel").flush();
-    assertData("010348656c");
-
-    sink.writeUtf8("lo").close();
-    assertData("80026c6f");
-  }
-
-  @Test public void noWritesAfterClose() throws IOException {
-    Sink sink = serverWriter.newMessageSink(OPCODE_TEXT, -1);
-
-    sink.close();
-    assertData("8100");
-
-    Buffer payload = new Buffer().writeUtf8("Hello");
-    try {
-      // Write to the unbuffered sink as BufferedSink keeps its own closed state.
-      sink.write(payload, payload.size());
-      fail();
-    } catch (IOException e) {
-      assertThat(e.getMessage()).isEqualTo("closed");
-    }
-  }
-
-  @Test public void clientTextMessage() throws IOException {
-    BufferedSink sink = Okio.buffer(clientWriter.newMessageSink(OPCODE_TEXT, -1));
-
-    sink.writeUtf8("Hel").flush();
-    assertData("018360b420bb28d14c");
-
-    sink.writeUtf8("lo").flush();
-    assertData("00823851d9d4543e");
-
-    sink.close();
-    assertData("80807acb933d");
-  }
-
-  @Test public void serverBinaryMessage() throws IOException {
-    ByteString data = ByteString.decodeHex(""
-        + "60b420bb3851d9d47acb933dbe70399bf6c92da33af01d4fb7"
-        + "70e98c0325f41d3ebaf8986da712c82bcd4d554bf0b54023c2");
-
-    BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_BINARY, -1));
-
-    sink.write(data).flush();
-    assertData("0232");
-    assertData(data);
-
-    sink.write(data).flush();
-    assertData("0032");
-    assertData(data);
-
-    sink.close();
-    assertData("8000");
-  }
-
-  @Test public void serverMessageLengthShort() throws IOException {
-    Sink sink = serverWriter.newMessageSink(OPCODE_BINARY, -1);
-
-    // Create a payload which will overflow the normal payload byte size.
-    Buffer payload = new Buffer();
-    while (payload.completeSegmentByteCount() <= PAYLOAD_BYTE_MAX) {
-      payload.writeByte('0');
-    }
-    long byteCount = payload.completeSegmentByteCount();
-
-    // Write directly to the unbuffered sink. This ensures it will become single frame.
-    sink.write(payload.clone(), byteCount);
-    assertData("027e"); // 'e' == 4-byte follow-up length.
-    assertData(Util.format("%04X", payload.completeSegmentByteCount()));
-    assertData(payload.readByteArray());
-
-    sink.close();
-    assertData("8000");
-  }
-
-  @Test public void serverMessageLengthLong() throws IOException {
-    Sink sink = serverWriter.newMessageSink(OPCODE_BINARY, -1);
-
-    // Create a payload which will overflow the normal and short payload byte size.
-    Buffer payload = new Buffer();
-    while (payload.completeSegmentByteCount() <= PAYLOAD_SHORT_MAX) {
-      payload.writeByte('0');
-    }
-    long byteCount = payload.completeSegmentByteCount();
-
-    // Write directly to the unbuffered sink. This ensures it will become single frame.
-    sink.write(payload.clone(), byteCount);
-    assertData("027f"); // 'f' == 16-byte follow-up length.
-    assertData(Util.format("%016X", byteCount));
-    assertData(payload.readByteArray(byteCount));
-
-    sink.close();
-    assertData("8000");
-  }
-
-  @Test public void clientBinary() throws IOException {
-    ByteString data = ByteString.decodeHex(""
-        + "60b420bb3851d9d47acb933dbe70399bf6c92da33af01d4fb7"
-        + "70e98c0325f41d3ebaf8986da712c82bcd4d554bf0b54023c2");
-
-    BufferedSink sink = Okio.buffer(clientWriter.newMessageSink(OPCODE_BINARY, -1));
-
-    sink.write(data).flush();
-    assertData("02b2");
-    assertData("60b420bb");
-    assertData(""
-        + "0000000058e5f96f1a7fb386dec41920967d0d185a443df4d7"
-        + "c4c9376391d4a65e0ed8230d1332734b796dee2b4495fb4376");
-
-    sink.write(data).close();
-    assertData("80b2");
-    assertData("3851d9d4");
-    assertData(""
-        + "58e5f96f00000000429a4ae98621e04fce98f47702a1c49b8f"
-        + "2130583b742dc906eb214c55f6cb1c139c948173a16c941b93");
-  }
-
-  @Test public void serverEmptyClose() throws IOException {
-    serverWriter.writeClose(0, null);
-    assertData("8800");
-  }
-
-  @Test public void serverCloseWithCode() throws IOException {
-    serverWriter.writeClose(1001, null);
-    assertData("880203e9");
-  }
-
-  @Test public void serverCloseWithCodeAndReason() throws IOException {
-    serverWriter.writeClose(1001, ByteString.encodeUtf8("Hello"));
-    assertData("880703e948656c6c6f");
-  }
-
-  @Test public void clientEmptyClose() throws IOException {
-    clientWriter.writeClose(0, null);
-    assertData("888060b420bb");
-  }
-
-  @Test public void clientCloseWithCode() throws IOException {
-    clientWriter.writeClose(1001, null);
-    assertData("888260b420bb635d");
-  }
-
-  @Test public void clientCloseWithCodeAndReason() throws IOException {
-    clientWriter.writeClose(1001, ByteString.encodeUtf8("Hello"));
-    assertData("888760b420bb635d68de0cd84f");
-  }
-
-  @Test public void closeWithOnlyReasonThrows() throws IOException {
-    clientWriter.writeClose(0, ByteString.encodeUtf8("Hello"));
-    assertData("888760b420bb60b468de0cd84f");
-  }
-
-  @Test public void closeCodeOutOfRangeThrows() throws IOException {
-    try {
-      clientWriter.writeClose(98724976, ByteString.encodeUtf8("Hello"));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("Code must be in range [1000,5000): 98724976");
-    }
-  }
-
-  @Test public void closeReservedThrows() throws IOException {
-    try {
-      clientWriter.writeClose(1005, ByteString.encodeUtf8("Hello"));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo("Code 1005 is reserved and may not be used.");
-    }
-  }
-
-  @Test public void serverEmptyPing() throws IOException {
-    serverWriter.writePing(ByteString.EMPTY);
-    assertData("8900");
-  }
-
-  @Test public void clientEmptyPing() throws IOException {
-    clientWriter.writePing(ByteString.EMPTY);
-    assertData("898060b420bb");
-  }
-
-  @Test public void serverPingWithPayload() throws IOException {
-    serverWriter.writePing(ByteString.encodeUtf8("Hello"));
-    assertData("890548656c6c6f");
-  }
-
-  @Test public void clientPingWithPayload() throws IOException {
-    clientWriter.writePing(ByteString.encodeUtf8("Hello"));
-    assertData("898560b420bb28d14cd70f");
-  }
-
-  @Test public void serverEmptyPong() throws IOException {
-    serverWriter.writePong(ByteString.EMPTY);
-    assertData("8a00");
-  }
-
-  @Test public void clientEmptyPong() throws IOException {
-    clientWriter.writePong(ByteString.EMPTY);
-    assertData("8a8060b420bb");
-  }
-
-  @Test public void serverPongWithPayload() throws IOException {
-    serverWriter.writePong(ByteString.encodeUtf8("Hello"));
-    assertData("8a0548656c6c6f");
-  }
-
-  @Test public void clientPongWithPayload() throws IOException {
-    clientWriter.writePong(ByteString.encodeUtf8("Hello"));
-    assertData("8a8560b420bb28d14cd70f");
-  }
-
-  @Test public void pingTooLongThrows() throws IOException {
-    try {
-      serverWriter.writePing(ByteString.of(binaryData(1000)));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "Payload size must be less than or equal to 125");
-    }
-  }
-
-  @Test public void pongTooLongThrows() throws IOException {
-    try {
-      serverWriter.writePong(ByteString.of(binaryData(1000)));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "Payload size must be less than or equal to 125");
-    }
-  }
-
-  @Test public void closeTooLongThrows() throws IOException {
-    try {
-      ByteString longReason = ByteString.encodeUtf8(repeat('X', 124));
-      serverWriter.writeClose(1000, longReason);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "Payload size must be less than or equal to 125");
-    }
-  }
-
-  @Test public void twoMessageSinksThrows() {
-    clientWriter.newMessageSink(OPCODE_TEXT, -1);
-    try {
-      clientWriter.newMessageSink(OPCODE_TEXT, -1);
-      fail();
-    } catch (IllegalStateException e) {
-      assertThat(e.getMessage()).isEqualTo(
-          "Another message writer is active. Did you call close()?");
-    }
-  }
-
-  private void assertData(String hex) throws EOFException {
-    assertData(ByteString.decodeHex(hex));
-  }
-
-  private void assertData(ByteString expected) throws EOFException {
-    ByteString actual = data.readByteString(expected.size());
-    assertThat(actual).isEqualTo(expected);
-  }
-
-  private void assertData(byte[] data) throws IOException {
-    int byteCount = 16;
-    for (int i = 0; i < data.length; i += byteCount) {
-      int count = Math.min(byteCount, data.length - i);
-      Buffer expectedChunk = new Buffer();
-      expectedChunk.write(data, i, count);
-      assertThat(this.data.readByteString(count)).overridingErrorMessage("At " + i).isEqualTo(
-          expectedChunk.readByteString());
-    }
-  }
-
-  private static byte[] binaryData(int length) {
-    byte[] junk = new byte[length];
-    new Random(0).nextBytes(junk);
-    return junk;
-  }
-}
diff --git a/okhttp/src/test/resources/web-platform-test-urltestdata.txt b/okhttp/src/test/resources/web-platform-test-urltestdata.txt
deleted file mode 100644
index 87c4f67135..0000000000
--- a/okhttp/src/test/resources/web-platform-test-urltestdata.txt
+++ /dev/null
@@ -1,342 +0,0 @@
-# FORMAT NOT DOCUMENTED YET (parser is urltestparser.js)
-
-# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/script-tests/segments.js
-http://example\t.\norg http://example.org/foo/bar s:http h:example.org p:/
-http://user:pass@foo:21/bar;par?b#c  s:http u:user pass:pass h:foo port:21 p:/bar;par q:?b f:#c
-http:foo.com  s:http h:example.org p:/foo/foo.com
-\t\s\s\s:foo.com\s\s\s\n  s:http h:example.org p:/foo/:foo.com
-\sfoo.com\s\s  s:http h:example.org p:/foo/foo.com
-a:\t\sfoo.com  s:a p:\sfoo.com
-http://f:21/\sb\s?\sd\s#\se\s  s:http h:f port:21 p:/%20b%20 q:?%20d%20 f:#\se
-http://f:/c  s:http h:f p:/c
-http://f:0/c  s:http h:f port:0 p:/c
-http://f:00000000000000/c  s:http h:f port:0 p:/c
-http://f:00000000000000000000080/c  s:http h:f p:/c
-http://f:b/c
-http://f:\s/c
-http://f:\n/c  s:http h:f p:/c
-http://f:fifty-two/c
-http://f:999999/c  s:http h:f port:999999 p:/c
-http://f:\s21\s/\sb\s?\sd\s#\se\s
-  s:http h:example.org p:/foo/bar
-\s\s\t  s:http h:example.org p:/foo/bar
-:foo.com/  s:http h:example.org p:/foo/:foo.com/
-:foo.com\\  s:http h:example.org p:/foo/:foo.com/
-:  s:http h:example.org p:/foo/:
-:a  s:http h:example.org p:/foo/:a
-:/  s:http h:example.org p:/foo/:/
-:\\  s:http h:example.org p:/foo/:/
-:#  s:http h:example.org p:/foo/: f:#
-\#  s:http h:example.org p:/foo/bar f:#
-\#/  s:http h:example.org p:/foo/bar f:#/
-\#\\  s:http h:example.org p:/foo/bar f:#\\
-\#;?  s:http h:example.org p:/foo/bar f:#;?
-?  s:http h:example.org p:/foo/bar q:?
-/  s:http h:example.org p:/
-:23  s:http h:example.org p:/foo/:23
-/:23  s:http h:example.org p:/:23
-::  s:http h:example.org p:/foo/::
-::23  s:http h:example.org p:/foo/::23
-foo://  s:foo p://
-http://a:b@c:29/d  s:http u:a pass:b h:c port:29 p:/d
-http::@c:29  s:http h:example.org p:/foo/:@c:29
-http://&a:foo(b]c@d:2/  s:http u:&a pass:foo(b]c h:d port:2 p:/
-http://::@c@d:2  s:http pass::%40c h:d port:2 p:/
-http://foo.com:b@d/  s:http u:foo.com pass:b h:d p:/
-http://foo.com/\\@  s:http h:foo.com p://@
-http:\\\\foo.com\\  s:http h:foo.com p:/
-http:\\\\a\\b:c\\d@foo.com\\  s:http h:a p:/b:c/d@foo.com/
-foo:/  s:foo p:/
-foo:/bar.com/  s:foo p:/bar.com/
-foo://///////  s:foo p://///////
-foo://///////bar.com/  s:foo p://///////bar.com/
-foo:////://///  s:foo p:////://///
-c:/foo  s:c p:/foo
-//foo/bar  s:http h:foo p:/bar
-http://foo/path;a??e#f#g  s:http h:foo p:/path;a q:??e f:#f#g
-http://foo/abcd?efgh?ijkl  s:http h:foo p:/abcd q:?efgh?ijkl
-http://foo/abcd#foo?bar  s:http h:foo p:/abcd f:#foo?bar
-[61:24:74]:98  s:http h:example.org p:/foo/[61:24:74]:98
-http:[61:27]/:foo  s:http h:example.org p:/foo/[61:27]/:foo
-http://[1::2]:3:4
-http://2001::1
-http://2001::1]
-http://2001::1]:80
-http://[2001::1]  s:http h:[2001::1] p:/
-http://[2001::1]:80  s:http h:[2001::1] p:/
-http:/example.com/  s:http h:example.org p:/example.com/
-ftp:/example.com/  s:ftp h:example.com p:/
-https:/example.com/  s:https h:example.com p:/
-madeupscheme:/example.com/  s:madeupscheme p:/example.com/
-file:/example.com/  s:file p:/example.com/
-ftps:/example.com/  s:ftps p:/example.com/
-gopher:/example.com/  s:gopher h:example.com p:/
-ws:/example.com/  s:ws h:example.com p:/
-wss:/example.com/  s:wss h:example.com p:/
-data:/example.com/  s:data p:/example.com/
-javascript:/example.com/  s:javascript p:/example.com/
-mailto:/example.com/  s:mailto p:/example.com/
-http:example.com/  s:http h:example.org p:/foo/example.com/
-ftp:example.com/  s:ftp h:example.com p:/
-https:example.com/  s:https h:example.com p:/
-madeupscheme:example.com/  s:madeupscheme p:example.com/
-ftps:example.com/  s:ftps p:example.com/
-gopher:example.com/  s:gopher h:example.com p:/
-ws:example.com/  s:ws h:example.com p:/
-wss:example.com/  s:wss h:example.com p:/
-data:example.com/  s:data p:example.com/
-javascript:example.com/  s:javascript p:example.com/
-mailto:example.com/  s:mailto p:example.com/
-/a/b/c  s:http h:example.org p:/a/b/c
-/a/\s/c  s:http h:example.org p:/a/%20/c
-/a%2fc  s:http h:example.org p:/a%2fc
-/a/%2f/c  s:http h:example.org p:/a/%2f/c
-\#\u03B2  s:http h:example.org p:/foo/bar f:#\u03B2
-data:text/html,test#test  s:data p:text/html,test f:#test
-
-# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/file.html
-
-# Basic canonicalization, uppercase should be converted to lowercase
-file:c:\\foo\\bar.html file:///tmp/mock/path s:file p:/c:/foo/bar.html
-
-# Spaces should fail
-\s\sFile:c|////foo\\bar.html  s:file p:/c:////foo/bar.html
-
-# This should fail
-C|/foo/bar  s:file p:/C:/foo/bar
-
-# This should fail
-/C|\\foo\\bar  s:file p:/C:/foo/bar
-//C|/foo/bar  s:file p:/C:/foo/bar
-//server/file  s:file h:server p:/file
-\\\\server\\file  s:file h:server p:/file
-/\\server/file  s:file h:server p:/file
-file:///foo/bar.txt  s:file p:/foo/bar.txt
-file:///home/me  s:file p:/home/me
-//  s:file p:/
-///  s:file p:/
-///test  s:file p:/test
-file://test  s:file h:test p:/
-file://localhost  s:file h:localhost p:/
-file://localhost/  s:file h:localhost p:/
-file://localhost/test  s:file h:localhost p:/test
-test  s:file p:/tmp/mock/test
-file:test  s:file p:/tmp/mock/test
-
-# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/script-tests/path.js
-http://example.com/././foo about:blank s:http h:example.com p:/foo
-http://example.com/./.foo  s:http h:example.com p:/.foo
-http://example.com/foo/.  s:http h:example.com p:/foo/
-http://example.com/foo/./  s:http h:example.com p:/foo/
-http://example.com/foo/bar/..  s:http h:example.com p:/foo/
-http://example.com/foo/bar/../  s:http h:example.com p:/foo/
-http://example.com/foo/..bar  s:http h:example.com p:/foo/..bar
-http://example.com/foo/bar/../ton  s:http h:example.com p:/foo/ton
-http://example.com/foo/bar/../ton/../../a  s:http h:example.com p:/a
-http://example.com/foo/../../..  s:http h:example.com p:/
-http://example.com/foo/../../../ton  s:http h:example.com p:/ton
-http://example.com/foo/%2e  s:http h:example.com p:/foo/
-http://example.com/foo/%2e%2  s:http h:example.com p:/foo/%2e%2
-http://example.com/foo/%2e./%2e%2e/.%2e/%2e.bar  s:http h:example.com p:/%2e.bar
-http://example.com////../..  s:http h:example.com p://
-http://example.com/foo/bar//../..  s:http h:example.com p:/foo/
-http://example.com/foo/bar//..  s:http h:example.com p:/foo/bar/
-http://example.com/foo  s:http h:example.com p:/foo
-http://example.com/%20foo  s:http h:example.com p:/%20foo
-http://example.com/foo%  s:http h:example.com p:/foo%
-http://example.com/foo%2  s:http h:example.com p:/foo%2
-http://example.com/foo%2zbar  s:http h:example.com p:/foo%2zbar
-http://example.com/foo%2\u00C2\u00A9zbar  s:http h:example.com p:/foo%2%C3%82%C2%A9zbar
-http://example.com/foo%41%7a  s:http h:example.com p:/foo%41%7a
-http://example.com/foo\t\u0091%91  s:http h:example.com p:/foo%C2%91%91
-http://example.com/foo%00%51  s:http h:example.com p:/foo%00%51
-http://example.com/(%28:%3A%29)  s:http h:example.com p:/(%28:%3A%29)
-http://example.com/%3A%3a%3C%3c  s:http h:example.com p:/%3A%3a%3C%3c
-http://example.com/foo\tbar  s:http h:example.com p:/foobar
-http://example.com\\\\foo\\\\bar  s:http h:example.com p://foo//bar
-http://example.com/%7Ffp3%3Eju%3Dduvgw%3Dd  s:http h:example.com p:/%7Ffp3%3Eju%3Dduvgw%3Dd
-http://example.com/@asdf%40  s:http h:example.com p:/@asdf%40
-http://example.com/\u4F60\u597D\u4F60\u597D  s:http h:example.com p:/%E4%BD%A0%E5%A5%BD%E4%BD%A0%E5%A5%BD
-http://example.com/\u2025/foo  s:http h:example.com p:/%E2%80%A5/foo
-http://example.com/\uFEFF/foo  s:http h:example.com p:/%EF%BB%BF/foo
-http://example.com/\u202E/foo/\u202D/bar  s:http h:example.com p:/%E2%80%AE/foo/%E2%80%AD/bar
-
-# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/script-tests/relative.js
-http://www.google.com/foo?bar=baz# about:blank s:http h:www.google.com p:/foo q:?bar=baz f:#
-http://www.google.com/foo?bar=baz#\s\u00BB  s:http h:www.google.com p:/foo q:?bar=baz f:#\s\u00BB
-data:test#\s\u00BB  s:data p:test f:#\s\u00BB
-http://[www.google.com]/
-http://www.google.com  s:http h:www.google.com p:/
-http://192.0x00A80001  s:http h:192.168.0.1 p:/
-http://www/foo%2Ehtml  s:http h:www p:/foo%2Ehtml
-http://www/foo/%2E/html  s:http h:www p:/foo/html
-http://user:pass@/
-http://%25DOMAIN:foobar@foodomain.com/  s:http u:%25DOMAIN pass:foobar h:foodomain.com p:/
-http:\\\\www.google.com\\foo  s:http h:www.google.com p:/foo
-http://foo:80/  s:http h:foo p:/
-http://foo:81/  s:http h:foo port:81 p:/
-httpa://foo:80/  s:httpa p://foo:80/
-http://foo:-80/
-https://foo:443/  s:https h:foo p:/
-https://foo:80/  s:https h:foo port:80 p:/
-ftp://foo:21/  s:ftp h:foo p:/
-ftp://foo:80/  s:ftp h:foo port:80 p:/
-gopher://foo:70/  s:gopher h:foo p:/
-gopher://foo:443/  s:gopher h:foo port:443 p:/
-ws://foo:80/  s:ws h:foo p:/
-ws://foo:81/  s:ws h:foo port:81 p:/
-ws://foo:443/  s:ws h:foo port:443 p:/
-ws://foo:815/  s:ws h:foo port:815 p:/
-wss://foo:80/  s:wss h:foo port:80 p:/
-wss://foo:81/  s:wss h:foo port:81 p:/
-wss://foo:443/  s:wss h:foo p:/
-wss://foo:815/  s:wss h:foo port:815 p:/
-http:/example.com/  s:http h:example.com p:/
-ftp:/example.com/  s:ftp h:example.com p:/
-https:/example.com/  s:https h:example.com p:/
-madeupscheme:/example.com/  s:madeupscheme p:/example.com/
-file:/example.com/  s:file p:/example.com/
-ftps:/example.com/  s:ftps p:/example.com/
-gopher:/example.com/  s:gopher h:example.com p:/
-ws:/example.com/  s:ws h:example.com p:/
-wss:/example.com/  s:wss h:example.com p:/
-data:/example.com/  s:data p:/example.com/
-javascript:/example.com/  s:javascript p:/example.com/
-mailto:/example.com/  s:mailto p:/example.com/
-http:example.com/  s:http h:example.com p:/
-ftp:example.com/  s:ftp h:example.com p:/
-https:example.com/  s:https h:example.com p:/
-madeupscheme:example.com/  s:madeupscheme p:example.com/
-ftps:example.com/  s:ftps p:example.com/
-gopher:example.com/  s:gopher h:example.com p:/
-ws:example.com/  s:ws h:example.com p:/
-wss:example.com/  s:wss h:example.com p:/
-data:example.com/  s:data p:example.com/
-javascript:example.com/  s:javascript p:example.com/
-mailto:example.com/  s:mailto p:example.com/
-
-# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/segments-userinfo-vs-host.html
-http:@www.example.com about:blank s:http h:www.example.com p:/
-http:/@www.example.com  s:http h:www.example.com p:/
-http://@www.example.com  s:http h:www.example.com p:/
-http:a:b@www.example.com  s:http u:a pass:b h:www.example.com p:/
-http:/a:b@www.example.com  s:http u:a pass:b h:www.example.com p:/
-http://a:b@www.example.com  s:http u:a pass:b h:www.example.com p:/
-http://@pple.com  s:http h:pple.com p:/
-http::b@www.example.com  s:http pass:b h:www.example.com p:/
-http:/:b@www.example.com  s:http pass:b h:www.example.com p:/
-http://:b@www.example.com  s:http pass:b h:www.example.com p:/
-http:/:@/www.example.com
-http://user@/www.example.com
-http:@/www.example.com
-http:/@/www.example.com
-http://@/www.example.com
-https:@/www.example.com
-http:a:b@/www.example.com
-http:/a:b@/www.example.com
-http://a:b@/www.example.com
-http::@/www.example.com
-http:a:@www.example.com  s:http u:a pass: h:www.example.com p:/
-http:/a:@www.example.com  s:http u:a pass: h:www.example.com p:/
-http://a:@www.example.com  s:http u:a pass: h:www.example.com p:/
-http://www.@pple.com  s:http u:www. h:pple.com p:/
-http:@:www.example.com
-http:/@:www.example.com
-http://@:www.example.com
-http://:@www.example.com  s:http pass: h:www.example.com p:/
-
-#Others
-/ http://www.example.com/test s:http h:www.example.com p:/
-/test.txt  s:http h:www.example.com p:/test.txt
-.  s:http h:www.example.com p:/
-..  s:http h:www.example.com p:/
-test.txt  s:http h:www.example.com p:/test.txt
-./test.txt  s:http h:www.example.com p:/test.txt
-../test.txt  s:http h:www.example.com p:/test.txt
-../aaa/test.txt  s:http h:www.example.com p:/aaa/test.txt
-../../test.txt  s:http h:www.example.com p:/test.txt
-\u4E2D/test.txt  s:http h:www.example.com p:/%E4%B8%AD/test.txt
-http://www.example2.com  s:http h:www.example2.com p:/
-//www.example2.com  s:http h:www.example2.com p:/
-
-# Based on http://trac.webkit.org/browser/trunk/LayoutTests/fast/url/host.html
-
-# Basic canonicalization, uppercase should be converted to lowercase
-http://ExAmPlE.CoM http://other.com/ s:http p:/ h:example.com
-
-# Spaces should fail
-http://example\sexample.com
-
-# This should fail
-http://Goo%20\sgoo%7C|.com
-
-# U+3000 is mapped to U+0020 (space) which is disallowed
-http://GOO\u00a0\u3000goo.com
-
-# Other types of space (no-break, zero-width, zero-width-no-break) are
-# name-prepped away to nothing.
-# U+200B, U+2060, and U+FEFF, are ignored
-http://GOO\u200b\u2060\ufeffgoo.com  s:http p:/ h:googoo.com
-
-# Ideographic full stop (full-width period for Chinese, etc.) should be
-# treated as a dot.
-# U+3002 is mapped to U+002E (dot)
-http://www.foo\u3002bar.com  s:http p:/ h:www.foo.bar.com
-
-# Invalid unicode characters should fail...
-# U+FDD0 is disallowed; %ef%b7%90 is U+FDD0
-http://\ufdd0zyx.com
-
-# ...This is the same as previous but escaped.
-http://%ef%b7%90zyx.com
-
-# Test name prepping, fullwidth input should be converted to ASCII and NOT
-# IDN-ized. This is "Go" in fullwidth UTF-8/UTF-16.
-http://\uff27\uff4f.com  s:http p:/ h:go.com
-
-# URL spec forbids the following.
-# https://www.w3.org/Bugs/Public/show_bug.cgi?id=24257
-http://\uff05\uff14\uff11.com
-http://%ef%bc%85%ef%bc%94%ef%bc%91.com
-
-# ...%00 in fullwidth should fail (also as escaped UTF-8 input)
-http://\uff05\uff10\uff10.com
-http://%ef%bc%85%ef%bc%90%ef%bc%90.com
-
-# Basic IDN support, UTF-8 and UTF-16 input should be converted to IDN
-http://\u4f60\u597d\u4f60\u597d  s:http p:/ h:xn--6qqa088eba
-
-# Invalid escaped characters should fail and the percents should be
-# escaped. https://www.w3.org/Bugs/Public/show_bug.cgi?id=24191
-http://%zz%66%a.com
-
-# If we get an invalid character that has been escaped.
-http://%25
-http://hello%00
-
-# Escaped numbers should be treated like IP addresses if they are.
-# No special handling for IPv4 or IPv4-like URLs
-http://%30%78%63%30%2e%30%32%35%30.01  s:http p:/ h:192.168.0.1
-http://%30%78%63%30%2e%30%32%35%30.01%2e  s:http p:/ h:0xc0.0250.01.
-http://192.168.0.257
-
-# Invalid escaping should trigger the regular host error handling.
-http://%3g%78%63%30%2e%30%32%35%30%2E.01
-
-# Something that isn't exactly an IP should get treated as a host and
-# spaces escaped.
-http://192.168.0.1\shello
-
-# Fullwidth and escaped UTF-8 fullwidth should still be treated as IP.
-# These are "0Xc0.0250.01" in fullwidth.
-http://\uff10\uff38\uff43\uff10\uff0e\uff10\uff12\uff15\uff10\uff0e\uff10\uff11  s:http p:/ h:192.168.0.1
-
-# Broken IPv6
-http://[google.com]
-
-# Misc Unicode
-http://foo:\uD83D\uDCA9@example.com/bar  s:http h:example.com p:/bar u:foo pass:%F0%9F%92%A9
-
-# resolving a relative reference against an unknown scheme results in an error
-x test:test
-
diff --git a/settings.gradle b/settings.gradle
index 8fb2322a27..64e212e878 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,11 +1,11 @@
 rootProject.name = 'okhttp-parent'
 
 
-include ':okcurl'
+//include ':okcurl'
 include ':okhttp'
-include ':okhttp-brotli'
-include ':okhttp-dnsoverhttps'
-include ':okhttp-logging-interceptor'
-include ':okhttp-sse'
-include ':okhttp-tls'
-include ':okhttp-urlconnection'
+//include ':okhttp-brotli'
+//include ':okhttp-dnsoverhttps'
+//include ':okhttp-logging-interceptor'
+//include ':okhttp-sse'
+//include ':okhttp-tls'
+//include ':okhttp-urlconnection'
