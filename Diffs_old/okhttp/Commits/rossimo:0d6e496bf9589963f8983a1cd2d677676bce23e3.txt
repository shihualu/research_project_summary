diff --git a/.gitmodules b/.gitmodules
new file mode 100644
index 0000000000..d29f0b1218
--- /dev/null
+++ b/.gitmodules
@@ -0,0 +1,3 @@
+[submodule "okhttp-hpacktests/src/test/resources/hpack-test-case"]
+	path = okhttp-hpacktests/src/test/resources/hpack-test-case
+	url = git://github.com/http2jp/hpack-test-case.git
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 360a36ad49..e64155601c 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,163 @@
 Change Log
 ==========
 
+## Version 2.0.0
+
+This release commits to a stable 2.0 API. Read the 2.0.0-RC1 changes for advice
+on upgrading from 1.x to 2.x.
+
+_2014-06-21_
+
+ *  **API Change**: Use `IOException` in `Callback.onFailure()`. This is
+    a source-incompatible change, and is different from OkHttp 2.0.0-RC2 which
+    used `Throwable`.
+ *  Fix: Fixed a caching bug where we weren't storing rewritten request headers
+    like `Accept-Encoding`.
+ *  Fix: Fixed bugs in handling the SPDY window size. This was stalling certain
+    large downloads
+ *  Update the language level to Java 7. (OkHttp requires Android 2.3+ or Java 7+.)
+
+## Version 2.0.0-RC2
+
+_2014-06-11_
+
+This update fixes problems in 2.0.0-RC1. Read the 2.0.0-RC1 changes for
+advice on upgrading from 1.x to 2.x.
+
+ *  Fix: Don't leak connections! There was a regression in 2.0.0-RC1 where
+    connections were neither closed nor pooled.
+ *  Fix: Revert builder-style return types from OkHttpClient's timeout methods
+    for binary compatibility with OkHttp 1.x.
+ *  Fix: Don't skip client stream 1 on SPDY/3.1. This fixes SPDY connectivity to
+    `https://google.com`, which doesn't follow the SPDY/3.1 spec!
+ *  Fix: Always configure NPN headers. This fixes connectivity to
+    `https://facebook.com` when SPDY and HTTP/2 are both disabled. Otherwise an
+    unexpected NPN response is received and OkHttp crashes.
+ *  Fix: Write continuation frames when HPACK data is larger than 16383 bytes.
+ *  Fix: Don't drop uncaught exceptions thrown in async calls.
+ *  Fix: Throw an exception eagerly when a request body is not legal. Previously
+    we ignored the problem at request-building time, only to crash later with a
+    `NullPointerException`.
+ *  Fix: Include a backwards-compatible `OkHttp-Response-Source` header with
+    `OkUrlFactory `responses.
+ *  Fix: Don't include a default User-Agent header in requests made with the Call
+    API. Requests made with OkUrlFactory will continue to have a default user
+    agent.
+ *  New: Guava-like API to create headers:
+
+    ```
+    Headers headers = Headers.of(name1, value1, name2, value2, ...).
+    ```
+
+ *  New: Make the content-type header optional for request bodies.
+ *  New: `Response.isSuccessful()` is a convenient API to check response codes.
+ *  New: The response body can now be read outside of the callback. Response
+    bodies must always be closed, otherwise they will leak connections!
+ *  New: APIs to create multipart request bodies (`MultipartBuilder`) and form
+    encoding bodies (`FormEncodingBuilder`).
+
+## Version 2.0.0-RC1
+
+_2014-05-23_
+
+OkHttp 2 is designed around a new API that is true to HTTP, with classes for
+requests, responses, headers, and calls. It uses modern Java patterns like
+immutability and chained builders. The API now offers asynchronous callbacks
+in addition to synchronous blocking calls.
+
+#### API Changes
+
+ *  **New Request and Response types,** each with their own builder. There's also
+    a `RequestBody` class to write the request body to the network and a
+    `ResponseBody` to read the response body from the network. The standalone
+    `Headers` class offers full access to the HTTP headers.
+
+ *  **Okio dependency added.** OkHttp now depends on
+    [Okio](https://github.com/square/okio), an I/O library that makes it easier
+    to access, store and process data. Using this library internally makes OkHttp
+    faster while consuming less memory. You can write a `RequestBody` as an Okio
+    `BufferedSink` and a `ResponseBody` as an Okio `BufferedSource`. Standard
+    `InputStream` and `OutputStream` access is also available.
+
+ *  **New Call and Callback types** execute requests and receive their
+    responses. Both types of calls can be canceled via the `Call` or the
+    `OkHttpClient`.
+
+ *  **URLConnection support has moved to the okhttp-urlconnection module.**
+    If you're upgrading from 1.x, this change will impact you. You will need to
+    add the `okhttp-urlconnection` module to your project and use the
+    `OkUrlFactory` to create new instances of `HttpURLConnection`:
+
+    ```
+    // OkHttp 1.x:
+    HttpURLConnection connection = client.open(url);
+
+    // OkHttp 2.x:
+    HttpURLConnection connection = new OkUrlFactory(client).open(url);
+    ```
+
+ *  **Custom caches are no longer supported.** In OkHttp 1.x it was possible to
+    define your own response cache with the `java.net.ResponseCache` and OkHttp's
+    `OkResponseCache` interfaces. Both of these APIs have been dropped. In
+    OkHttp 2 the built-in disk cache is the only supported response cache.
+
+ *  **HttpResponseCache has been renamed to Cache.** Install it with
+    `OkHttpClient.setCache(...)` instead of `OkHttpClient.setResponseCache(...)`.
+
+ *  **OkAuthenticator has been replaced with Authenticator.** This new
+    authenticator has access to the full incoming response and can respond with
+    whichever followup request is appropriate. The `Challenge` class is now a
+    top-level class and `Credential` is replaced with a utility class called
+    `Credentials`.
+
+ *  **OkHttpClient.getFollowProtocolRedirects() renamed to
+    getFollowSslRedirects()**. We reserve the word _protocol_ for the HTTP
+    version being used (HTTP/1.1, HTTP/2). The old name of this method was
+    misleading; it was always used to configure redirects between `https://` and
+    `http://` schemes.
+
+ *  **RouteDatabase is no longer public API.** OkHttp continues to track which
+    routes have failed but this is no exposed in the API.
+
+ *  **ResponseSource is gone.** This enum exposed whether a response came from
+    the cache, network, or both. OkHttp 2 offers more detail with raw access to
+    the cache and network responses in the new `Response` class.
+
+ *  **TunnelRequest is gone.** It specified how to connect to an HTTP proxy.
+    OkHttp 2 uses the new `Request` class for this.
+
+ *  **Dispatcher** is a new class to manages the queue of asynchronous calls. It
+    implements limits on total in-flight calls and in-flight calls per host.
+
+#### Implementation changes
+
+ * Support Android `TrafficStats` socket tagging.
+ * Drop authentication headers on redirect.
+ * Added support for compressed data frames.
+ * Process push promise callbacks in order.
+ * Update to http/2 draft 12.
+ * Update to HPACK draft 07.
+ * Add ALPN support. Maven will use ALPN on OpenJDK 8.
+ * Update NPN dependency to target `jdk7u60-b13` and `Oracle jdk7u55-b13`.
+ * Ensure SPDY variants support zero-length DELETE and POST.
+ * Prevent leaking a cache item's InputStreams when metadata read fails.
+ * Use a string to identify TLS versions in routes.
+ * Add frame logger for HTTP/2.
+ * Replacing `httpMinorVersion` with `Protocol`. Expose HTTP/1.0 as a potential protocol.
+ * Use `Protocol` to describe framing.
+ * Implement write timeouts for HTTP/1.1 streams.
+ * Avoid use of SPDY stream ID 1, as that's typically used for UPGRADE.
+ * Support OAuth in `Authenticator`.
+ * Permit a dangling semicolon in media type parsing.
+
+## Version 1.6.0
+
+_2014-05-23_
+
+ * Offer bridges to make it easier to migrate from OkHttp 1.x to OkHttp 2.0.
+   This adds `OkUrlFactory`, `Cache`, and `@Deprecated` annotations for APIs
+   dropped in 2.0.
+
 ## Version 1.5.4
 
 _2014-04-14_
diff --git a/README.md b/README.md
index 67eecc9456..1f80f44afb 100644
--- a/README.md
+++ b/README.md
@@ -1,16 +1,12 @@
 OkHttp
 ======
 
-An HTTP & SPDY client for Android and Java applications.
-
-For more information please see [the website][1].
-
-
+An HTTP & SPDY client for Android and Java applications. For more information see [the website][1] and [the wiki][2].
 
 Download
 --------
 
-Download [the latest JAR][2] or grab via Maven:
+Download [the latest JAR][3] or grab via Maven:
 
 ```xml
 <dependency>
@@ -21,45 +17,6 @@ Download [the latest JAR][2] or grab via Maven:
 ```
 
 
-Building
---------
-
-OkHttp requires Java 7 to build and run tests. Runtime compatibility with Java 6 is enforced as
-part of the build to ensure compliance with Android and older versions of the JVM.
-
-
-
-Testing
--------
-
-### On the Desktop
-
-Run OkHttp tests on the desktop with Maven. Running HTTP/2 and SPDY tests on the desktop uses
-[Jetty-NPN][3] when running OpenJDK 7 or [Jetty-ALPN][4] when OpenJDK 8.
-
-```
-mvn clean test
-```
-
-### On a Device
-
-OkHttp's test suite creates an in-process HTTPS server. Prior to Android 2.3, SSL server sockets
-were broken, and so HTTPS tests will time out when run on such devices.
-
-Test on a USB-attached Android using [Vogar][5]. Unfortunately `dx` requires that you build with
-Java 6, otherwise the test class will be silently omitted from the `.dex` file.
-
-```
-mvn clean
-mvn package -DskipTests
-vogar \
-    --classpath ~/.m2/repository/org/bouncycastle/bcprov-jdk15on/1.48/bcprov-jdk15on-1.48.jar \
-    --classpath mockwebserver/target/mockwebserver-2.0.0-SNAPSHOT.jar \
-    --classpath okhttp-protocols/target/okhttp-protocols-2.0.0-SNAPSHOT.jar \
-    --classpath okhttp/target/okhttp-2.0.0-SNAPSHOT.jar \
-    okhttp/src/test
-```
-
 MockWebServer
 -------------
 
@@ -69,7 +26,7 @@ MockWebServer coupling with OkHttp is essential for proper testing of SPDY and H
 
 ### Download
 
-Download [the latest JAR][6] or grab via Maven:
+Download [the latest JAR][4] or grab via Maven:
 
 ```xml
 <dependency>
@@ -97,11 +54,7 @@ License
     limitations under the License.
 
 
-
-
  [1]: http://square.github.io/okhttp
- [2]: http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.okhttp&a=okhttp&v=LATEST
- [3]: https://github.com/jetty-project/jetty-npn
- [4]: https://github.com/jetty-project/jetty-alpn
- [5]: https://code.google.com/p/vogar/
- [6]: http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.okhttp&a=mockwebserver&v=LATEST
+ [2]: https://github.com/square/okhttp/wiki
+ [3]: http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.okhttp&a=okhttp&v=LATEST
+ [4]: http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.okhttp&a=mockwebserver&v=LATEST
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
index 82ac3e8738..0a48fbd00b 100644
--- a/benchmarks/pom.xml
+++ b/benchmarks/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.0.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>benchmarks</artifactId>
@@ -29,6 +29,11 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp-urlconnection</artifactId>
+      <version>${project.version}</version>
+    </dependency>
     <dependency>
       <groupId>com.squareup.okhttp</groupId>
       <artifactId>mockwebserver</artifactId>
@@ -83,7 +88,7 @@
             <argument>-Xmx512m</argument>
             <commandlineArgs>-Xbootclasspath/p:${bootclasspath}</commandlineArgs>
             <argument>-classpath</argument>
-            <classpath/>
+            <classpath />
             <argument>com.squareup.okhttp.benchmarks.Benchmark</argument>
           </arguments>
         </configuration>
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
index 6c8db61974..7efa32e418 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
@@ -87,7 +87,7 @@
   List<Protocol> protocols = Arrays.asList(Protocol.HTTP_1_1);
 
   public static void main(String[] args) {
-    List<String> allArgs = new ArrayList<String>();
+    List<String> allArgs = new ArrayList<>();
     allArgs.add("--instrument");
     allArgs.add("arbitrary");
     allArgs.addAll(Arrays.asList(args));
@@ -141,7 +141,7 @@ public double run() throws Exception {
   }
 
   @Override public String toString() {
-    List<Object> modifiers = new ArrayList<Object>();
+    List<Object> modifiers = new ArrayList<>();
     if (tls) modifiers.add("tls");
     if (gzip) modifiers.add("gzip");
     if (chunked) modifiers.add("chunked");
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
index 9044d0a33c..5d8cec5291 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
@@ -53,8 +53,8 @@
   private static final boolean VERBOSE = false;
 
   // Guarded by this. Real apps need more capable connection management.
-  private final Deque<HttpChannel> freeChannels = new ArrayDeque<HttpChannel>();
-  private final Deque<URL> backlog = new ArrayDeque<URL>();
+  private final Deque<HttpChannel> freeChannels = new ArrayDeque<>();
+  private final Deque<URL> backlog = new ArrayDeque<>();
 
   private int totalChannels = 0;
   private int concurrencyLevel;
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java
index 03b9e3c6f1..3885ed7f53 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java
@@ -16,6 +16,7 @@
 package com.squareup.okhttp.benchmarks;
 
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import java.io.IOException;
 import java.net.HttpURLConnection;
@@ -63,7 +64,7 @@ public OkHttpRequest(URL url) {
     public void run() {
       long start = System.nanoTime();
       try {
-        HttpURLConnection urlConnection = client.open(url);
+        HttpURLConnection urlConnection = new OkUrlFactory(client).open(url);
         long total = readAllAndClose(urlConnection.getInputStream());
         long finish = System.nanoTime();
 
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
index 31d57ef395..ab7849017c 100644
--- a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
@@ -15,11 +15,12 @@
  */
 package com.squareup.okhttp.benchmarks;
 
+import com.squareup.okhttp.Callback;
 import com.squareup.okhttp.Dispatcher;
-import com.squareup.okhttp.Failure;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import java.io.IOException;
 import java.net.URL;
@@ -38,7 +39,7 @@
   private final AtomicInteger requestsInFlight = new AtomicInteger();
 
   private OkHttpClient client;
-  private Response.Callback callback;
+  private Callback callback;
   private int concurrencyLevel;
   private int targetBacklog;
 
@@ -63,13 +64,13 @@
       client.setHostnameVerifier(hostnameVerifier);
     }
 
-    callback = new Response.Callback() {
-      @Override public void onFailure(Failure failure) {
-        System.out.println("Failed: " + failure.exception());
+    callback = new Callback() {
+      @Override public void onFailure(Request request, IOException e) {
+        System.out.println("Failed: " + e);
       }
 
       @Override public void onResponse(Response response) throws IOException {
-        Response.Body body = response.body();
+        ResponseBody body = response.body();
         long total = SynchronousHttpClient.readAllAndClose(body.byteStream());
         long finish = System.nanoTime();
         if (VERBOSE) {
diff --git a/concurrency.md b/concurrency.md
deleted file mode 100644
index 0858133a31..0000000000
--- a/concurrency.md
+++ /dev/null
@@ -1,63 +0,0 @@
-# Concurrency in OkHttp
-
-The HttpURLConnection API is a blocking API. You make a blocking write to send a request, and a blocking read to receive the response.
-
-#### Blocking APIs
-
-Blocking APIs are convenient because you get top-to-bottom procedural code without indirection. Network calls work like regular method calls: ask for data and it is returned. If the request fails, you get a stacktrace right were the call was made.
-
-Blocking APIs may be inefficient because you hold a thread idle while waiting on the network. Threads are expensive because they have both a memory overhead and a context-switching overhead.
-
-#### Framed protocols
-
-Framed protocols like spdy/3 and http/2 don't lend themselves to blocking APIs. Each application-layer thread wants to do blocking I/O for a specific stream, but the streams are multiplexed on the socket. You can't just talk to the socket, you need to cooperate with the other application-layer threads that you're sharing it with.
-
-Framing rules make it impractical to implement spdy/3 or http/2 correctly on a single blocking thread. The flow-control features introduce feedback between reads and writes, requiring writes to acknowledge reads and reads to throttle writes.
-
-In OkHttp we expose a blocking API over a framed protocol. This document explains the code and policy that makes that work.
-
-## Threads
-
-#### Application's calling thread
-
-The application-layer must block on writing I/O. We can't return from a write until we've pushed its bytes onto the socket. Otherwise, if the write fails we are unable to deliver its IOException to the application. We would have told the application layer that the write succeeded, but it didn't!
-
-The application-layer can also do blocking reads. If the application asks to read and there's nothing available, we need to hold that thread until either the bytes arrive, the stream is closed, or a timeout elapses. If we get bytes but there's nobody asking for them, we buffer them. We don't consider bytes as delivered for flow control until they're consumed by the application.
-
-Consider an application streaming a video over http/2. Perhaps the user pauses the video and the application stops reading bytes from this stream. The buffer will fill up, and flow control prevents the server from sending more data on this stream. When the user unpauses her video the buffer drains, the read is acknowledged, and the server proceeds to stream data.
-
-#### Shared reader thread
-
-We can't rely on application threads to read data from the socket. Application threads are transient: sometimes they're reading and writing and sometimes they're off doing application-layer things. But the socket is permanent, and it needs constant attention: we dispatch all incoming frames so the connection is good-to-go when the application layer needs it.
-
-So we have a dedicated thread for every socket that just reads frames and dispatches them.
-
-The reader thread must never run application-layer code. Otherwise one slow stream can hold up the entire connection.
-
-Similarly, the reader thread must never block on writing because this can deadlock the connection. Consider a client and server that both violate this rule. If you get unlucky, they could fill up their TCP buffers (so that writes block) and then use their reader threads to write a frame. Nobody is reading on either end, and the buffers are never drained.
-
-#### Do-stuff-later pool
-
-Sometimes there's an action required like calling the application layer or responding to a ping, and the thread discovering the action is not the thread that should do the work. We enqueue a runnable on this executor and it gets handled by one of the executor's threads.
-
-## Locks
-
-We have 3 different things that we synchronize on.
-
-#### SpdyConnection
-
-This lock guards internal state of each connection. This lock is never held for blocking operations. That means that we acquire the lock, read or write a few fields and release the lock. No I/O and no application-layer callbacks.
-
-#### SpdyStream
-
-This lock guards the internal state of each stream. As above, it is never held for blocking operations. When we need to hold an application thread to block a read, we use wait/notify on this lock. This works because the lock is released while `wait()` is waiting.
-
-#### FrameWriter
-
-Socket writes are guarded by the FrameWriter. Only one stream can write at a time so that messages are not interleaved. Writes are either made by application-layer threads or the do-stuff-later pool.
-
-### Holding multiple locks
-
-You're allowed to take the SpdyConnection lock while holding the FrameWriter lock. But not vice-versa. Because taking the FrameWriter lock can block.
-
-This is necessary for bookkeeping when creating new streams. Correct framing requires that stream IDs are sequential on the socket, so we need to bundle assigning the ID with sending the `SYN_STREAM` frame.
diff --git a/deploy_website.sh b/deploy_website.sh
index bac2744198..24d0c72b46 100755
--- a/deploy_website.sh
+++ b/deploy_website.sh
@@ -26,10 +26,20 @@ rm -rf *
 # Copy website files from real repo
 cp -R ../website/* .
 
-# Download the latest javadoc
-curl -L "http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=$GROUP_ID&a=$ARTIFACT_ID&v=LATEST&c=javadoc" > javadoc.zip
-mkdir javadoc
-unzip javadoc.zip -d javadoc
+# Download the latest javadoc to directories like 'javadoc' or 'javadoc-urlconnection'.
+for DOCUMENTED_ARTIFACT in okhttp okhttp-urlconnection okhttp-apache
+do
+  curl -L "http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=$GROUP_ID&a=$DOCUMENTED_ARTIFACT&v=LATEST&c=javadoc" > javadoc.zip
+  JAVADOC_DIR="javadoc${DOCUMENTED_ARTIFACT//okhttp/}"
+  mkdir $JAVADOC_DIR
+  unzip javadoc.zip -d $JAVADOC_DIR
+  rm javadoc.zip
+done
+
+# Download the 1.6.0 javadoc to '1.x/javadoc'.
+curl -L "http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=$GROUP_ID&a=$ARTIFACT_ID&v=1.6.0&c=javadoc" > javadoc.zip
+mkdir -p 1.x/javadoc
+unzip javadoc.zip -d 1.x/javadoc
 rm javadoc.zip
 
 # Stage all files in git and create a commit
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index 63ea9e6e54..1feb9d934b 100644
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.0.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>mockwebserver</artifactId>
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
index c3d76a25bd..350c6f65ac 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
@@ -27,7 +27,7 @@
   private static final String CHUNKED_BODY_HEADER = "Transfer-encoding: chunked";
 
   private String status = "HTTP/1.1 200 OK";
-  private List<String> headers = new ArrayList<String>();
+  private List<String> headers = new ArrayList<>();
 
   /** The response body content, or null if {@code bodyStream} is set. */
   private Buffer body;
@@ -42,7 +42,7 @@
 
   private int bodyDelayTimeMs = 0;
 
-  private List<PushPromise> promises = new ArrayList<PushPromise>();
+  private List<PushPromise> promises = new ArrayList<>();
 
   /** Creates a new mock response with an empty body. */
   public MockResponse() {
@@ -52,8 +52,8 @@ public MockResponse() {
   @Override public MockResponse clone() {
     try {
       MockResponse result = (MockResponse) super.clone();
-      result.headers = new ArrayList<String>(headers);
-      result.promises = new ArrayList<PushPromise>(promises);
+      result.headers = new ArrayList<>(headers);
+      result.promises = new ArrayList<>(promises);
       return result;
     } catch (CloneNotSupportedException e) {
       throw new AssertionError();
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index 988a8ff4c7..a80d7d6dee 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -55,6 +55,7 @@
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.logging.Level;
 import java.util.logging.Logger;
@@ -65,6 +66,7 @@
 import javax.net.ssl.X509TrustManager;
 import okio.Buffer;
 import okio.BufferedSink;
+import okio.BufferedSource;
 import okio.ByteString;
 import okio.Okio;
 
@@ -93,13 +95,11 @@
 
   private static final Logger logger = Logger.getLogger(MockWebServer.class.getName());
 
-  private final BlockingQueue<RecordedRequest> requestQueue =
-      new LinkedBlockingQueue<RecordedRequest>();
+  private final BlockingQueue<RecordedRequest> requestQueue = new LinkedBlockingQueue<>();
 
   /** All map values are Boolean.TRUE. (Collections.newSetFromMap isn't available in Froyo) */
-  private final Map<Socket, Boolean> openClientSockets = new ConcurrentHashMap<Socket, Boolean>();
-  private final Map<SpdyConnection, Boolean> openSpdyConnections
-      = new ConcurrentHashMap<SpdyConnection, Boolean>();
+  private final Map<Socket, Boolean> openClientSockets = new ConcurrentHashMap<>();
+  private final Map<SpdyConnection, Boolean> openSpdyConnections = new ConcurrentHashMap<>();
   private final AtomicInteger requestCount = new AtomicInteger();
   private int bodyLimit = Integer.MAX_VALUE;
   private ServerSocket serverSocket;
@@ -224,12 +224,30 @@ public void useHttps(SSLSocketFactory sslSocketFactory, boolean tunnelProxy) {
 
   /**
    * Awaits the next HTTP request, removes it, and returns it. Callers should
-   * use this to verify the request was sent as intended.
+   * use this to verify the request was sent as intended. This method will block until the
+   * request is available, possibly forever.
+   *
+   * @return the head of the request queue
    */
   public RecordedRequest takeRequest() throws InterruptedException {
     return requestQueue.take();
   }
 
+  /**
+   * Awaits the next HTTP request (waiting up to the
+   * specified wait time if necessary), removes it, and returns it. Callers should
+   * use this to verify the request was sent as intended within the given time.
+   *
+   * @param timeout how long to wait before giving up, in units of
+  *        {@code unit}
+   * @param unit a {@code TimeUnit} determining how to interpret the
+   *        {@code timeout} parameter
+   * @return the head of the request queue
+   */
+  public RecordedRequest takeRequest(int timeout, TimeUnit unit) throws InterruptedException {
+    return requestQueue.poll(timeout, unit);
+  }
+
   /**
    * Returns the number of HTTP requests received thus far by this server. This
    * may exceed the number of HTTP connections when connection reuse is in
@@ -473,7 +491,7 @@ private RecordedRequest readRequest(Socket socket, InputStream in, OutputStream
       return null; // no request because the stream is exhausted
     }
 
-    List<String> headers = new ArrayList<String>();
+    List<String> headers = new ArrayList<>();
     long contentLength = -1;
     boolean chunked = false;
     boolean expectContinue = false;
@@ -503,10 +521,10 @@ private RecordedRequest readRequest(Socket socket, InputStream in, OutputStream
 
     boolean hasBody = false;
     TruncatingOutputStream requestBody = new TruncatingOutputStream();
-    List<Integer> chunkSizes = new ArrayList<Integer>();
+    List<Integer> chunkSizes = new ArrayList<>();
     MockResponse throttlePolicy = dispatcher.peek();
     if (contentLength != -1) {
-      hasBody = true;
+      hasBody = contentLength > 0;
       throttledTransfer(throttlePolicy, in, requestBody, contentLength);
     } else if (chunked) {
       hasBody = true;
@@ -670,7 +688,7 @@ private SpdySocketHandler(Socket socket, Protocol protocol) {
 
     private RecordedRequest readRequest(SpdyStream stream) throws IOException {
       List<Header> spdyHeaders = stream.getRequestHeaders();
-      List<String> httpHeaders = new ArrayList<String>();
+      List<String> httpHeaders = new ArrayList<>();
       String method = "<:method omitted>";
       String path = "<:path omitted>";
       String version = protocol == Protocol.SPDY_3 ? "<:version omitted>" : "HTTP/1.1";
@@ -688,25 +706,21 @@ private RecordedRequest readRequest(SpdyStream stream) throws IOException {
         }
       }
 
-      InputStream bodyIn = Okio.buffer(stream.getSource()).inputStream();
-      ByteArrayOutputStream bodyOut = new ByteArrayOutputStream();
-      byte[] buffer = new byte[8192];
-      int count;
-      while ((count = bodyIn.read(buffer)) != -1) {
-        bodyOut.write(buffer, 0, count);
-      }
+      BufferedSource bodyIn = Okio.buffer(stream.getSource());
+      byte[] bodyOut = bodyIn.readByteArray();
       bodyIn.close();
+
       String requestLine = method + ' ' + path + ' ' + version;
       List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for SPDY.
-      return new RecordedRequest(requestLine, httpHeaders, chunkSizes, bodyOut.size(),
-          bodyOut.toByteArray(), sequenceNumber.getAndIncrement(), socket);
+      return new RecordedRequest(requestLine, httpHeaders, chunkSizes, bodyOut.length,
+          bodyOut, sequenceNumber.getAndIncrement(), socket);
     }
 
     private void writeResponse(SpdyStream stream, MockResponse response) throws IOException {
       if (response.getSocketPolicy() == SocketPolicy.NO_RESPONSE) {
         return;
       }
-      List<Header> spdyHeaders = new ArrayList<Header>();
+      List<Header> spdyHeaders = new ArrayList<>();
       String[] statusParts = response.getStatus().split(" ", 2);
       if (statusParts.length != 2) {
         throw new AssertionError("Unexpected status: " + response.getStatus());
@@ -763,7 +777,7 @@ private void writeResponse(SpdyStream stream, MockResponse response) throws IOEx
 
     private void pushPromises(SpdyStream stream, List<PushPromise> promises) throws IOException {
       for (PushPromise pushPromise : promises) {
-        List<Header> pushedHeaders = new ArrayList<Header>();
+        List<Header> pushedHeaders = new ArrayList<>();
         pushedHeaders.add(new Header(stream.getConnection().getProtocol() == Protocol.SPDY_3
             ? Header.TARGET_HOST
             : Header.TARGET_AUTHORITY, getUrl(pushPromise.getPath()).getHost()));
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/QueueDispatcher.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/QueueDispatcher.java
index 7c1ddd1f5e..c9c206c17c 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/QueueDispatcher.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/QueueDispatcher.java
@@ -24,8 +24,7 @@
  * by calling {@link #enqueueResponse(MockResponse)}.
  */
 public class QueueDispatcher extends Dispatcher {
-  protected final BlockingQueue<MockResponse> responseQueue
-      = new LinkedBlockingQueue<MockResponse>();
+  protected final BlockingQueue<MockResponse> responseQueue = new LinkedBlockingQueue<>();
   private MockResponse failFastResponse;
 
   @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java
index 58b5d107c9..2e49a26eff 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/RecordedRequest.java
@@ -91,7 +91,7 @@ public String getHeader(String name) {
 
   /** Returns the headers named {@code name}. */
   public List<String> getHeaders(String name) {
-    List<String> result = new ArrayList<String>();
+    List<String> result = new ArrayList<>();
     name += ":";
     for (int i = 0, size = headers.size(); i < size; i++) {
       String header = headers.get(i);
diff --git a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java
index 7b7e1125cc..efd34742c5 100644
--- a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java
+++ b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/CustomDispatcherTest.java
@@ -22,78 +22,78 @@
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
-import junit.framework.TestCase;
+import org.junit.After;
+import org.junit.Test;
 
-public class CustomDispatcherTest extends TestCase {
+import static org.junit.Assert.assertEquals;
 
-    private MockWebServer mockWebServer = new MockWebServer();
+public class CustomDispatcherTest {
+  private MockWebServer mockWebServer = new MockWebServer();
 
-    @Override
-    public void tearDown() throws Exception {
-        mockWebServer.shutdown();
-    }
+  @After public void tearDown() throws Exception {
+    mockWebServer.shutdown();
+  }
 
-    public void testSimpleDispatch() throws Exception {
-        mockWebServer.play();
-        final List<RecordedRequest> requestsMade = new ArrayList<RecordedRequest>();
-        final Dispatcher dispatcher = new Dispatcher() {
-            @Override
-            public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
-                requestsMade.add(request);
-                return new MockResponse();
-            }
-        };
-        assertEquals(0, requestsMade.size());
-        mockWebServer.setDispatcher(dispatcher);
-        final URL url = mockWebServer.getUrl("/");
-        final HttpURLConnection conn = (HttpURLConnection) url.openConnection();
-        conn.getResponseCode(); // Force the connection to hit the "server".
-        // Make sure our dispatcher got the request.
-        assertEquals(1, requestsMade.size());
-    }
+  @Test public void simpleDispatch() throws Exception {
+    mockWebServer.play();
+    final List<RecordedRequest> requestsMade = new ArrayList<>();
+    final Dispatcher dispatcher = new Dispatcher() {
+      @Override
+      public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+        requestsMade.add(request);
+        return new MockResponse();
+      }
+    };
+    assertEquals(0, requestsMade.size());
+    mockWebServer.setDispatcher(dispatcher);
+    final URL url = mockWebServer.getUrl("/");
+    final HttpURLConnection conn = (HttpURLConnection) url.openConnection();
+    conn.getResponseCode(); // Force the connection to hit the "server".
+    // Make sure our dispatcher got the request.
+    assertEquals(1, requestsMade.size());
+  }
 
-    public void testOutOfOrderResponses() throws Exception {
-        AtomicInteger firstResponseCode = new AtomicInteger();
-        AtomicInteger secondResponseCode = new AtomicInteger();
-        mockWebServer.play();
-        final String secondRequest = "/bar";
-        final String firstRequest = "/foo";
-        final CountDownLatch latch = new CountDownLatch(1);
-        final Dispatcher dispatcher = new Dispatcher() {
-            @Override
-            public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
-                if (request.getPath().equals(firstRequest)) {
-                    latch.await();
-                }
-                return new MockResponse();
-            }
-        };
-        mockWebServer.setDispatcher(dispatcher);
-        final Thread startsFirst = buildRequestThread(firstRequest, firstResponseCode);
-        startsFirst.start();
-        final Thread endsFirst = buildRequestThread(secondRequest, secondResponseCode);
-        endsFirst.start();
-        endsFirst.join();
-        assertEquals(0, firstResponseCode.get()); // First response is still waiting.
-        assertEquals(200, secondResponseCode.get()); // Second response is done.
-        latch.countDown();
-        startsFirst.join();
-        assertEquals(200, firstResponseCode.get()); // And now it's done!
-        assertEquals(200, secondResponseCode.get()); // (Still done).
-    }
-
-    private Thread buildRequestThread(final String path, final AtomicInteger responseCode) {
-        return new Thread(new Runnable() {
-            @Override public void run() {
-                final URL url = mockWebServer.getUrl(path);
-                final HttpURLConnection conn;
-                try {
-                    conn = (HttpURLConnection) url.openConnection();
-                    responseCode.set(conn.getResponseCode()); // Force the connection to hit the "server".
-                } catch (IOException e) {
-                }
-            }
-        });
-    }
+  @Test public void outOfOrderResponses() throws Exception {
+    AtomicInteger firstResponseCode = new AtomicInteger();
+    AtomicInteger secondResponseCode = new AtomicInteger();
+    mockWebServer.play();
+    final String secondRequest = "/bar";
+    final String firstRequest = "/foo";
+    final CountDownLatch latch = new CountDownLatch(1);
+    final Dispatcher dispatcher = new Dispatcher() {
+      @Override
+      public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+        if (request.getPath().equals(firstRequest)) {
+          latch.await();
+        }
+        return new MockResponse();
+      }
+    };
+    mockWebServer.setDispatcher(dispatcher);
+    final Thread startsFirst = buildRequestThread(firstRequest, firstResponseCode);
+    startsFirst.start();
+    final Thread endsFirst = buildRequestThread(secondRequest, secondResponseCode);
+    endsFirst.start();
+    endsFirst.join();
+    assertEquals(0, firstResponseCode.get()); // First response is still waiting.
+    assertEquals(200, secondResponseCode.get()); // Second response is done.
+    latch.countDown();
+    startsFirst.join();
+    assertEquals(200, firstResponseCode.get()); // And now it's done!
+    assertEquals(200, secondResponseCode.get()); // (Still done).
+  }
 
+  private Thread buildRequestThread(final String path, final AtomicInteger responseCode) {
+    return new Thread(new Runnable() {
+      @Override public void run() {
+        final URL url = mockWebServer.getUrl(path);
+        final HttpURLConnection conn;
+        try {
+          conn = (HttpURLConnection) url.openConnection();
+          responseCode.set(conn.getResponseCode()); // Force the connection to hit the "server".
+        } catch (IOException e) {
+        }
+      }
+    });
+  }
 }
diff --git a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRuleTest.java b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRuleTest.java
index ebf69f43ae..43ceebc6bb 100644
--- a/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRuleTest.java
+++ b/mockwebserver/src/test/java/com/squareup/okhttp/mockwebserver/rule/MockWebServerRuleTest.java
@@ -22,7 +22,6 @@
 import java.io.InputStreamReader;
 import java.net.ConnectException;
 import java.net.HttpURLConnection;
-import java.net.ServerSocket;
 import java.net.URL;
 import org.junit.After;
 import org.junit.Test;
diff --git a/okcurl/pom.xml b/okcurl/pom.xml
index af0ba2e212..a442c7a97b 100644
--- a/okcurl/pom.xml
+++ b/okcurl/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.0.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>okcurl</artifactId>
diff --git a/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java b/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
index 5e52e204d2..b3ceb7f0c6 100644
--- a/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
+++ b/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
@@ -22,9 +22,11 @@
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.http.StatusLine;
-import com.squareup.okhttp.internal.spdy.Http20Draft10;
+import com.squareup.okhttp.internal.spdy.Http20Draft13;
+
 import io.airlift.command.Arguments;
 import io.airlift.command.Command;
 import io.airlift.command.HelpOption;
@@ -187,7 +189,7 @@ private String getRequestMethod() {
     return "GET";
   }
 
-  private Request.Body getRequestBody() {
+  private RequestBody getRequestBody() {
     if (data == null) {
       return null;
     }
@@ -205,7 +207,7 @@ private String getRequestMethod() {
       }
     }
 
-    return Request.Body.create(MediaType.parse(mimeType), bodyData);
+    return RequestBody.create(MediaType.parse(mimeType), bodyData);
   }
 
   Request createRequest() {
@@ -264,7 +266,7 @@ private static HostnameVerifier createInsecureHostnameVerifier() {
   }
 
   private static void enableHttp2FrameLogging() {
-    Logger logger = Logger.getLogger(Http20Draft10.class.getName());
+    Logger logger = Logger.getLogger(Http20Draft13.class.getName());
     logger.setLevel(Level.FINE);
     ConsoleHandler handler = new ConsoleHandler();
     handler.setLevel(Level.FINE);
diff --git a/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java b/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java
index 48655787a2..ed6394d09e 100644
--- a/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java
+++ b/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java
@@ -16,6 +16,7 @@
 package com.squareup.okhttp.curl;
 
 import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
 import okio.Buffer;
 import org.junit.Test;
@@ -41,7 +42,7 @@
 
   @Test public void dataPost() {
     Request request = fromArgs("-d", "foo", "http://example.com").createRequest();
-    Request.Body body = request.body();
+    RequestBody body = request.body();
     assertEquals("POST", request.method());
     assertEquals("http://example.com", request.urlString());
     assertEquals("application/x-form-urlencoded; charset=utf-8", body.contentType().toString());
@@ -50,7 +51,7 @@
 
   @Test public void dataPut() {
     Request request = fromArgs("-d", "foo", "-X", "PUT", "http://example.com").createRequest();
-    Request.Body body = request.body();
+    RequestBody body = request.body();
     assertEquals("PUT", request.method());
     assertEquals("http://example.com", request.urlString());
     assertEquals("application/x-form-urlencoded; charset=utf-8", body.contentType().toString());
@@ -60,7 +61,7 @@
   @Test public void contentTypeHeader() {
     Request request = fromArgs("-d", "foo", "-H", "Content-Type: application/json",
         "http://example.com").createRequest();
-    Request.Body body = request.body();
+    RequestBody body = request.body();
     assertEquals("POST", request.method());
     assertEquals("http://example.com", request.urlString());
     assertEquals("application/json; charset=utf-8", body.contentType().toString());
@@ -83,7 +84,7 @@
     assertNull(request.body());
   }
 
-  private static String bodyAsString(Request.Body body) {
+  private static String bodyAsString(RequestBody body) {
     try {
       Buffer buffer = new Buffer();
       body.writeTo(buffer);
diff --git a/okhttp-apache/pom.xml b/okhttp-apache/pom.xml
index 14eb349b8d..a5b8d5a447 100644
--- a/okhttp-apache/pom.xml
+++ b/okhttp-apache/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.0.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-apache</artifactId>
@@ -18,12 +18,6 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
     <dependency>
       <groupId>org.apache.httpcomponents</groupId>
       <artifactId>httpclient</artifactId>
@@ -35,5 +29,27 @@
       <artifactId>junit</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <configuration>
+          <links>
+            <link>http://square.github.io/okhttp/javadoc/</link>
+            <link>http://hc.apache.org/httpcomponents-client-4.3.x/httpclient/apidocs/</link>
+            <link>https://hc.apache.org/httpcomponents-core-4.3.x/httpcore/apidocs/</link>
+          </links>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/okhttp-apache/src/main/java/com/squareup/okhttp/apache/HttpEntityBody.java b/okhttp-apache/src/main/java/com/squareup/okhttp/apache/HttpEntityBody.java
index a44f7fb3a7..fd7884cd80 100644
--- a/okhttp-apache/src/main/java/com/squareup/okhttp/apache/HttpEntityBody.java
+++ b/okhttp-apache/src/main/java/com/squareup/okhttp/apache/HttpEntityBody.java
@@ -1,26 +1,30 @@
 package com.squareup.okhttp.apache;
 
 import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
 import java.io.IOException;
 import okio.BufferedSink;
-import org.apache.http.Header;
 import org.apache.http.HttpEntity;
 
-/** Adapts an {@link HttpEntity} to OkHttp's {@link Request.Body}. */
-final class HttpEntityBody extends Request.Body {
-  private static final String DEFAULT_MEDIA_TYPE = "application/octet-stream";
+/** Adapts an {@link HttpEntity} to OkHttp's {@link RequestBody}. */
+final class HttpEntityBody extends RequestBody {
+  private static final MediaType DEFAULT_MEDIA_TYPE = MediaType.parse("application/octet-stream");
 
   private final HttpEntity entity;
   private final MediaType mediaType;
 
-  HttpEntityBody(HttpEntity entity) {
+  HttpEntityBody(HttpEntity entity, String contentTypeHeader) {
     this.entity = entity;
 
-    // Apache is forgiving and lets you skip specifying a content type with an entity. OkHttp is
-    // not forgiving so we fall back to a generic type if it's missing.
-    Header contentType = entity.getContentType();
-    mediaType = MediaType.parse(contentType != null ? contentType.getValue() : DEFAULT_MEDIA_TYPE);
+    if (contentTypeHeader != null) {
+      mediaType = MediaType.parse(contentTypeHeader);
+    } else if (entity.getContentType() != null) {
+      mediaType = MediaType.parse(entity.getContentType().getValue());
+    } else {
+      // Apache is forgiving and lets you skip specifying a content type with an entity. OkHttp is
+      // not forgiving so we fall back to a generic type if it's missing.
+      mediaType = DEFAULT_MEDIA_TYPE;
+    }
   }
 
   @Override public long contentLength() {
diff --git a/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java b/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java
index 3d2ae390ae..3cdfadb2d1 100644
--- a/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java
+++ b/okhttp-apache/src/main/java/com/squareup/okhttp/apache/OkApacheClient.java
@@ -4,7 +4,9 @@
 import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
@@ -44,16 +46,22 @@ private static Request transformRequest(HttpRequest request) {
     String method = requestLine.getMethod();
     builder.url(requestLine.getUri());
 
+    String contentType = null;
     for (Header header : request.getAllHeaders()) {
-      builder.header(header.getName(), header.getValue());
+      String name = header.getName();
+      if ("Content-Type".equals(name)) {
+        contentType = header.getValue();
+      } else {
+        builder.header(name, header.getValue());
+      }
     }
 
-    Request.Body body = null;
+    RequestBody body = null;
     if (request instanceof HttpEntityEnclosingRequest) {
       HttpEntity entity = ((HttpEntityEnclosingRequest) request).getEntity();
       if (entity != null) {
         // Wrap the entity in a custom Body which takes care of the content, length, and type.
-        body = new HttpEntityBody(entity);
+        body = new HttpEntityBody(entity, contentType);
 
         Header encoding = entity.getContentEncoding();
         if (encoding != null) {
@@ -71,7 +79,7 @@ private static HttpResponse transformResponse(Response response) {
     String message = response.message();
     BasicHttpResponse httpResponse = new BasicHttpResponse(HTTP_1_1, code, message);
 
-    Response.Body body = response.body();
+    ResponseBody body = response.body();
     InputStreamEntity entity = new InputStreamEntity(body.byteStream(), body.contentLength());
     httpResponse.setEntity(entity);
 
diff --git a/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java b/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java
index 5ebc35bf26..0f1d092b8b 100644
--- a/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java
+++ b/okhttp-apache/src/test/java/com/squareup/okhttp/apache/OkApacheClientTest.java
@@ -18,6 +18,7 @@
 import org.apache.http.client.methods.HttpPost;
 import org.apache.http.entity.ByteArrayEntity;
 import org.apache.http.entity.InputStreamEntity;
+import org.apache.http.entity.StringEntity;
 import org.apache.http.util.EntityUtils;
 import org.junit.After;
 import org.junit.Before;
@@ -114,6 +115,19 @@
     assertEquals(request.getHeader("Content-Length"), "13");
   }
 
+  @Test public void postOverrideContentType() throws Exception {
+    server.enqueue(new MockResponse());
+
+    HttpPost httpPost = new HttpPost();
+    httpPost.setURI(server.getUrl("/").toURI());
+    httpPost.addHeader("Content-Type", "application/xml");
+    httpPost.setEntity(new StringEntity("<yo/>"));
+    client.execute(httpPost);
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals(request.getHeader("Content-Type"), "application/xml");
+  }
+
   @Test public void contentType() throws Exception {
     server.enqueue(new MockResponse().setBody("<html><body><h1>Hello, World!</h1></body></html>")
         .setHeader("Content-Type", "text/html"));
diff --git a/okhttp-hpacktests/README.md b/okhttp-hpacktests/README.md
new file mode 100644
index 0000000000..f6b9049961
--- /dev/null
+++ b/okhttp-hpacktests/README.md
@@ -0,0 +1,22 @@
+OkHttp HPACK tests
+==================
+
+These tests use the [hpack-test-case][1] project to validate OkHttp's HPACK
+implementation.  The HPACK test cases are in a separate git submodule, so to
+initialize them, you must run:
+
+    git submodule init
+    git submodule update
+
+When new interop tests are available, you should update
+HpackDecodeInteropGoodTest#GOOD_INTEROP_TESTS with the directory name.
+
+TODO
+----
+
+ * Add maven goal to avoid manual call to git submodule init.
+ * Make hpack-test-case update itself from git, and run new tests.
+ * Add maven goal to generate stories and a pull request to hpack-test-case
+   to have others validate our output.
+
+[1]: https://github.com/http2jp/hpack-test-case 
diff --git a/okhttp-hpacktests/pom.xml b/okhttp-hpacktests/pom.xml
new file mode 100644
index 0000000000..0e8849076c
--- /dev/null
+++ b/okhttp-hpacktests/pom.xml
@@ -0,0 +1,57 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp</groupId>
+    <artifactId>parent</artifactId>
+    <version>2.0.1-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-hpacktests</artifactId>
+  <name>OkHttp HPACK Tests</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okio</groupId>
+      <artifactId>okio</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <!--  Gson: Java to Json conversion -->
+    <dependency>
+      <groupId>com.google.code.gson</groupId>
+      <artifactId>gson</artifactId>
+      <version>2.2.4</version>
+      <scope>compile</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <!-- Do not deploy this as an artifact to Maven central. -->
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-deploy-plugin</artifactId>
+        <configuration>
+          <skip>true</skip>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeInteropBadTest.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeInteropBadTest.java
new file mode 100644
index 0000000000..8d611ac91b
--- /dev/null
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeInteropBadTest.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.spdy.hpackjson.Story;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.Collection;
+
+/**
+ * Known bad tests for HPACK interop.
+ */
+// TODO: fix these tests (see if the input/test is legit, fix the implementation.)
+@Ignore
+@RunWith(Parameterized.class)
+public class HpackDecodeInteropBadTest extends HpackDecodeTestBase {
+
+  private static final String[] BAD_INTEROP_TESTS = { "go-hpack", "haskell-http2-diff-huffman",
+      "haskell-http2-linear-huffman", "haskell-http2-naive-huffman",
+      "haskell-http2-static-huffman", "node-http2-protocol", "twitter-hpack" };
+
+  public HpackDecodeInteropBadTest(Story story) {
+    super(story);
+  }
+
+  @Parameterized.Parameters(name="{0}")
+  public static Collection<Story[]> createStories() throws Exception {
+    return createStories(BAD_INTEROP_TESTS);
+  }
+
+  @Test
+  public void testGoodDecoderInterop() throws Exception {
+    testDecoder();
+  }
+}
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeInteropGoodTest.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeInteropGoodTest.java
new file mode 100644
index 0000000000..bf29e9e5c0
--- /dev/null
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeInteropGoodTest.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.spdy.hpackjson.Story;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.Collection;
+
+/**
+ * Known good tests for HPACK interop.
+ */
+@RunWith(Parameterized.class)
+public class HpackDecodeInteropGoodTest extends HpackDecodeTestBase {
+
+
+  private static final String[] GOOD_INTEROP_TESTS = { "haskell-http2-diff",
+      "haskell-http2-linear", "haskell-http2-naive", "haskell-http2-static",
+      "hyper-hpack", "nghttp2", "nghttp2-16384-4096",
+      "nghttp2-change-table-size", "node-http2-hpack" };
+
+  public HpackDecodeInteropGoodTest(Story story) {
+    super(story);
+  }
+
+  @Parameterized.Parameters(name="{0}")
+  public static Collection<Story[]> createStories() throws Exception {
+    return createStories(GOOD_INTEROP_TESTS);
+  }
+
+  @Test
+  public void testGoodDecoderInterop() throws Exception {
+    testDecoder();
+  }
+}
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeTestBase.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeTestBase.java
new file mode 100644
index 0000000000..f1d68a3f38
--- /dev/null
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDecodeTestBase.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+import com.squareup.okhttp.internal.spdy.hpackjson.Case;
+import com.squareup.okhttp.internal.spdy.hpackjson.HpackJsonUtil;
+import com.squareup.okhttp.internal.spdy.hpackjson.Story;
+import okio.Buffer;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.LinkedHashSet;
+import java.util.List;
+
+/**
+ * Tests Hpack implementation using https://github.com/http2jp/hpack-test-case/
+ */
+public class HpackDecodeTestBase {
+
+  /**
+   * Reads all stories in the folders provided, asserts if no story found.
+   */
+  protected static Collection<Story[]> createStories(String[] interopTests)
+      throws Exception {
+    List<Story[]> result = new ArrayList<>();
+    for (String interopTestName : interopTests) {
+      List<Story> stories = HpackJsonUtil.readStories(interopTestName);
+      if (stories.isEmpty()) {
+        fail("No stories for: " + interopTestName);
+      }
+      for (Story story : stories) {
+        result.add(new Story[] { story });
+      }
+    }
+    return result;
+  }
+
+  private final Buffer bytesIn = new Buffer();
+  private final HpackDraft08.Reader hpackReader = new HpackDraft08.Reader(4096, bytesIn);
+
+  private final Story story;
+
+  public HpackDecodeTestBase(Story story) {
+    this.story = story;
+  }
+
+  /**
+   * Expects wire to be set for all cases, and compares the decoder's output to
+   * expected headers.
+   */
+  protected void testDecoder() throws Exception {
+    testDecoder(story);
+  }
+
+  protected void testDecoder(Story story) throws Exception {
+    for (Case caze : story.getCases()) {
+      bytesIn.write(caze.getWire());
+      hpackReader.readHeaders();
+      hpackReader.emitReferenceSet();
+      assertSetEquals(String.format("seqno=%d", caze.getSeqno()), caze.getHeaders(),
+          hpackReader.getAndReset());
+    }
+  }
+  /**
+   * Checks if {@code expected} and {@code observed} are equal when viewed as a
+   * set and headers are deduped.
+   *
+   * TODO: See if duped headers should be preserved on decode and verify.
+   */
+  private static void assertSetEquals(
+      String message, List<Header> expected, List<Header> observed) {
+    assertEquals(message, new LinkedHashSet<>(expected), new LinkedHashSet<>(observed));
+  }
+
+  protected Story getStory() {
+    return story;
+  }
+}
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackRoundTripTest.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackRoundTripTest.java
new file mode 100644
index 0000000000..c55bb8b278
--- /dev/null
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/HpackRoundTripTest.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.spdy.hpackjson.Case;
+import com.squareup.okhttp.internal.spdy.hpackjson.Story;
+import okio.Buffer;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.Collection;
+
+/**
+ * Tests for round-tripping headers through hpack..
+ */
+// TODO: update hpack-test-case with the output of our encoder.
+// This test will hide complementary bugs in the encoder and decoder,
+// We should test that the encoder is producing responses that are
+// d]
+@RunWith(Parameterized.class)
+public class HpackRoundTripTest extends HpackDecodeTestBase {
+
+  private static final String[] RAW_DATA = { "raw-data" };
+
+  @Parameterized.Parameters(name="{0}")
+  public static Collection<Story[]> getStories() throws Exception {
+    return createStories(RAW_DATA);
+  }
+
+  private Buffer bytesOut = new Buffer();
+  private HpackDraft08.Writer hpackWriter = new HpackDraft08.Writer(bytesOut);
+
+  public HpackRoundTripTest(Story story) {
+    super(story);
+  }
+
+  @Test
+  public void testRoundTrip() throws Exception {
+    Story story = getStory().clone();
+    // Mutate cases in base class.
+    for (Case caze : story.getCases()) {
+      hpackWriter.writeHeaders(caze.getHeaders());
+      caze.setWire(bytesOut.readByteString());
+    }
+
+    testDecoder(story);
+  }
+
+}
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Case.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Case.java
new file mode 100644
index 0000000000..d5d272872c
--- /dev/null
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Case.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy.hpackjson;
+
+import com.squareup.okhttp.internal.spdy.Header;
+import okio.ByteString;
+
+import java.util.ArrayList;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Representation of an individual case (set of headers and wire format).
+ * There are many cases for a single story.  This class is used reflectively
+ * with Gson to parse stories.
+ */
+public class Case implements Cloneable {
+
+  private int seqno;
+  private String wire;
+  private List<Map<String, String>> headers;
+
+  public List<Header> getHeaders() {
+    List<Header> result = new ArrayList<>();
+    for (Map<String, String> inputHeader : headers) {
+      Map.Entry<String, String> entry = inputHeader.entrySet().iterator().next();
+      result.add(new Header(entry.getKey(), entry.getValue()));
+    }
+    return result;
+  }
+
+  public ByteString getWire() {
+    return ByteString.decodeHex(wire);
+  }
+
+  public int getSeqno() {
+    return seqno;
+  }
+
+  public void setWire(ByteString wire) {
+    this.wire = wire.hex();
+  }
+
+  @Override
+  protected Case clone() throws CloneNotSupportedException {
+    Case result = new Case();
+    result.seqno = seqno;
+    result.wire = wire;
+    result.headers = new ArrayList<>();
+    for (Map<String, String> header : headers) {
+      result.headers.add(new LinkedHashMap<String, String>(header));
+    }
+    return result;
+  }
+}
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/HpackJsonUtil.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/HpackJsonUtil.java
new file mode 100644
index 0000000000..d0695446d5
--- /dev/null
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/HpackJsonUtil.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy.hpackjson;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Utilities for reading HPACK tests.
+ */
+public final class HpackJsonUtil {
+
+  private static final String STORY_RESOURCE_FORMAT =
+      "/hpack-test-case/%s/story_%02d.json";
+
+  private static final Gson GSON = new GsonBuilder().create();
+
+  private static Story readStory(InputStream jsonResource) throws Exception {
+    return GSON.fromJson(new InputStreamReader(jsonResource, "UTF-8"), Story.class);
+  }
+
+  /**
+   * Reads stories named "story_xx.json" from the folder provided.
+   */
+  public static List<Story> readStories(String testFolderName) throws Exception {
+    List<Story> result = new ArrayList<>();
+    int i = 0;
+    while (true) { // break after last test.
+      String storyResourceName = String.format(STORY_RESOURCE_FORMAT, testFolderName, i);
+      InputStream storyInputStream = HpackJsonUtil.class.getResourceAsStream(storyResourceName);
+      if (storyInputStream == null) {
+        break;
+      }
+      try {
+        Story story = readStory(storyInputStream);
+        story.setFileName(storyResourceName);
+        result.add(story);
+        i++;
+      } finally {
+        storyInputStream.close();
+      }
+    }
+    return result;
+  }
+
+  private HpackJsonUtil() { } // Utilities only.
+}
\ No newline at end of file
diff --git a/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Story.java b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Story.java
new file mode 100644
index 0000000000..e7898cb826
--- /dev/null
+++ b/okhttp-hpacktests/src/test/java/com/squareup/okhttp/internal/spdy/hpackjson/Story.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy.hpackjson;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Representation of one story, a set of request headers to encode or decode.
+ * This class is used reflectively with Gson to parse stories from files.
+ */
+public class Story implements Cloneable {
+
+  private transient String fileName;
+  private List<Case> cases;
+  private int draft;
+  private String description;
+
+  /**
+   * The filename is only used in the toString representation.
+   */
+  void setFileName(String fileName) {
+    this.fileName = fileName;
+  }
+
+  public List<Case> getCases() {
+    return cases;
+  }
+
+  @Override
+  public Story clone() throws CloneNotSupportedException {
+    Story story = new Story();
+    story.fileName = this.fileName;
+    story.cases = new ArrayList<>();
+    for (Case caze : cases) {
+      story.cases.add(caze.clone());
+    }
+    story.draft = draft;
+    story.description = description;
+    return story;
+  }
+
+  @Override
+  public String toString() {
+    // Used as the test name.
+    return fileName;
+  }
+}
diff --git a/okhttp-hpacktests/src/test/resources/hpack-test-case b/okhttp-hpacktests/src/test/resources/hpack-test-case
new file mode 160000
index 0000000000..bc5da28a11
--- /dev/null
+++ b/okhttp-hpacktests/src/test/resources/hpack-test-case
@@ -0,0 +1 @@
+Subproject commit bc5da28a11638c460c39b763f44fe230472c1b24
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
index 6ce9c20f8e..7c3a601655 100644
--- a/okhttp-tests/pom.xml
+++ b/okhttp-tests/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.0.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-tests</artifactId>
@@ -22,6 +22,11 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp-urlconnection</artifactId>
+      <version>${project.version}</version>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -35,4 +40,17 @@
       <scope>test</scope>
     </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <!-- Do not deploy this as an artifact to Maven central. -->
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-deploy-plugin</artifactId>
+        <configuration>
+          <skip>true</skip>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/AbstractResponseCache.java b/okhttp-tests/src/test/java/com/squareup/okhttp/AbstractResponseCache.java
index ffd98f9b15..2a59d22a02 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/AbstractResponseCache.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/AbstractResponseCache.java
@@ -26,7 +26,7 @@
 import java.util.List;
 import java.util.Map;
 
-public abstract class AbstractResponseCache extends ResponseCache {
+public class AbstractResponseCache extends ResponseCache {
   @Override public CacheResponse get(URI uri, String requestMethod,
       Map<String, List<String>> requestHeaders) throws IOException {
     return null;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java
index 246675a810..b78a68e92d 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CacheTest.java
@@ -18,7 +18,6 @@
 
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.http.OkHeaders;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
@@ -97,7 +96,7 @@
   @Rule public MockWebServerRule serverRule = new MockWebServerRule();
   @Rule public MockWebServerRule server2Rule = new MockWebServerRule();
 
-  private final OkHttpClient client = new OkHttpClient();
+  private final OkUrlFactory client = new OkUrlFactory(new OkHttpClient());
   private MockWebServer server;
   private MockWebServer server2;
   private Cache cache;
@@ -108,7 +107,7 @@
     server.setProtocolNegotiationEnabled(false);
     server2 = server2Rule.get();
     cache = new Cache(cacheRule.getRoot(), Integer.MAX_VALUE);
-    client.setCache(cache);
+    client.client().setCache(cache);
     CookieHandler.setDefault(cookieManager);
   }
 
@@ -118,7 +117,7 @@
   }
 
   @Test public void responseCacheAccessWithOkHttpMember() throws IOException {
-    assertSame(cache, client.getCache());
+    assertSame(cache, client.client().getCache());
     assertNull(client.getResponseCache());
   }
 
@@ -402,8 +401,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
 
     HttpsURLConnection connection1 = (HttpsURLConnection) client.open(server.getUrl("/"));
     assertEquals("ABC", readAscii(connection1));
@@ -439,8 +438,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
         .addHeader("Location: " + server2.getUrl("/")));
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
 
     HttpURLConnection connection1 = client.open(server.getUrl("/"));
     assertEquals("ABC", readAscii(connection1));
@@ -456,8 +455,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   @Test public void responseCacheRequestHeaders() throws IOException, URISyntaxException {
     server.enqueue(new MockResponse().setBody("ABC"));
 
-    final AtomicReference<Map<String, List<String>>> requestHeadersRef
-        = new AtomicReference<Map<String, List<String>>>();
+    final AtomicReference<Map<String, List<String>>> requestHeadersRef = new AtomicReference<>();
     client.setResponseCache(new AbstractResponseCache() {
       @Override public CacheResponse get(URI uri,
           String requestMethod, Map<String, List<String>> requestHeaders) throws IOException {
@@ -922,6 +920,19 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     assertEquals("DEFDEFDEF", readAscii(client.open(server.getUrl("/"))));
   }
 
+  /** https://github.com/square/okhttp/issues/947 */
+  @Test public void gzipAndVaryOnAcceptEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(gzip("ABCABCABC"))
+        .addHeader("Content-Encoding: gzip")
+        .addHeader("Vary: Accept-Encoding")
+        .addHeader("Cache-Control: max-age=60"));
+    server.enqueue(new MockResponse().setBody("FAIL"));
+
+    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(client.open(server.getUrl("/"))));
+  }
+
   @Test public void conditionalCacheHitIsNotDoublePooled() throws Exception {
     server.enqueue(new MockResponse().addHeader("ETag: v1").setBody("A"));
     server.enqueue(new MockResponse()
@@ -930,11 +941,11 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
 
     ConnectionPool pool = ConnectionPool.getDefault();
     pool.evictAll();
-    client.setConnectionPool(pool);
+    client.client().setConnectionPool(pool);
 
     assertEquals("A", readAscii(client.open(server.getUrl("/"))));
     assertEquals("A", readAscii(client.open(server.getUrl("/"))));
-    assertEquals(1, client.getConnectionPool().getConnectionCount());
+    assertEquals(1, client.client().getConnectionPool().getConnectionCount());
   }
 
   @Test public void expiresDateBeforeModifiedDate() throws Exception {
@@ -1603,7 +1614,7 @@ public void assertAuthorizationRequestFullyCached(MockResponse response) throws
   }
 
   public void assertCookies(URL url, String... expectedCookies) throws Exception {
-    List<String> actualCookies = new ArrayList<String>();
+    List<String> actualCookies = new ArrayList<>();
     for (HttpCookie cookie : cookieManager.getCookieStore().get(url.toURI())) {
       actualCookies.add(cookie.toString());
     }
@@ -1654,9 +1665,6 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     URLConnection connection = client.open(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertEquals("A", readAscii(connection));
-
-    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.CACHE + " 200", source);
   }
 
   @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
@@ -1670,9 +1678,6 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     assertEquals("A", readAscii(client.open(server.getUrl("/"))));
     HttpURLConnection connection = client.open(server.getUrl("/"));
     assertEquals("B", readAscii(connection));
-
-    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.CONDITIONAL_CACHE + " 200", source);
   }
 
   @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
@@ -1684,9 +1689,6 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     assertEquals("A", readAscii(client.open(server.getUrl("/"))));
     HttpURLConnection connection = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection));
-
-    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.CONDITIONAL_CACHE + " 304", source);
   }
 
   @Test public void responseSourceHeaderFetched() throws IOException {
@@ -1694,9 +1696,6 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
 
     URLConnection connection = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection));
-
-    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.NETWORK + " 200", source);
   }
 
   @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
@@ -1761,7 +1760,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     writeFile(cache.getDirectory(), urlKey + ".1", entryBody);
     writeFile(cache.getDirectory(), "journal", journalBody);
     cache = new Cache(cache.getDirectory(), Integer.MAX_VALUE);
-    client.setCache(cache);
+    client.client().setCache(cache);
 
     HttpURLConnection connection = client.open(url);
     assertEquals(entryBody, readAscii(connection));
@@ -1859,7 +1858,7 @@ private void assertFullyCached(MockResponse response) throws Exception {
    */
   private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
     response.setSocketPolicy(DISCONNECT_AT_END);
-    List<String> headers = new ArrayList<String>(response.getHeaders());
+    List<String> headers = new ArrayList<>(response.getHeaders());
     Buffer truncatedBody = new Buffer();
     truncatedBody.write(response.getBody(), numBytesToKeep);
     response.setBody(truncatedBody);
@@ -1908,8 +1907,6 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
     }
     assertEquals(504, connection.getResponseCode());
     assertEquals(-1, connection.getErrorStream().read());
-    assertEquals(ResponseSource.NONE + " 504",
-        connection.getHeaderField(OkHeaders.RESPONSE_SOURCE));
   }
 
   enum TransferKind {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
index af8de54fad..e53e315c04 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/CallTest.java
@@ -16,6 +16,7 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.RecordingHostnameVerifier;
+import com.squareup.okhttp.internal.RecordingOkAuthenticator;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.mockwebserver.Dispatcher;
 import com.squareup.okhttp.mockwebserver.MockResponse;
@@ -28,33 +29,46 @@
 import java.net.CookieManager;
 import java.net.HttpCookie;
 import java.net.HttpURLConnection;
+import java.net.URL;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.List;
 import java.util.UUID;
+import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
+import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicReference;
 import javax.net.ssl.SSLContext;
+import okio.Buffer;
+import okio.BufferedSink;
 import okio.BufferedSource;
+import okio.GzipSink;
+import okio.Okio;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Test;
 
+import static java.lang.Thread.UncaughtExceptionHandler;
 import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class CallTest {
   private MockWebServer server = new MockWebServer();
+  private MockWebServer server2 = new MockWebServer();
   private OkHttpClient client = new OkHttpClient();
   private RecordingCallback callback = new RecordingCallback();
+  private UncaughtExceptionHandler defaultUncaughtExceptionHandler;
 
   private static final SSLContext sslContext = SslContextBuilder.localhost();
   private Cache cache;
@@ -63,11 +77,14 @@
     String tmp = System.getProperty("java.io.tmpdir");
     File cacheDir = new File(tmp, "HttpCache-" + UUID.randomUUID());
     cache = new Cache(cacheDir, Integer.MAX_VALUE);
+    defaultUncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
   }
 
   @After public void tearDown() throws Exception {
     server.shutdown();
+    server2.shutdown();
     cache.delete();
+    Thread.setDefaultUncaughtExceptionHandler(defaultUncaughtExceptionHandler);
   }
 
   @Test public void get() throws Exception {
@@ -81,6 +98,7 @@
 
     executeSynchronously(request)
         .assertCode(200)
+        .assertSuccessful()
         .assertHeader("Content-Type", "text/plain")
         .assertBody("abc");
 
@@ -91,6 +109,47 @@
     assertNull(recordedRequest.getHeader("Content-Length"));
   }
 
+  @Test public void lazilyEvaluateRequestUrl() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.play();
+
+    Request request1 = new Request.Builder()
+        .url("foo://bar?baz")
+        .build();
+    Request request2 = request1.newBuilder()
+        .url(server.getUrl("/"))
+        .build();
+    executeSynchronously(request2)
+        .assertCode(200)
+        .assertSuccessful()
+        .assertBody("abc");
+  }
+
+  @Ignore // TODO(jwilson): fix.
+  @Test public void invalidScheme() throws Exception {
+    try {
+      Request request = new Request.Builder()
+          .url("ftp://hostname/path")
+          .build();
+      executeSynchronously(request);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void getReturns500() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(500));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(500)
+        .assertNotSuccessful();
+  }
+
   @Test public void get_SPDY_3() throws Exception {
     enableProtocol(Protocol.SPDY_3);
     get();
@@ -101,6 +160,17 @@
     get();
   }
 
+  @Test public void getWithRequestBody() throws Exception {
+    server.enqueue(new MockResponse());
+    server.play();
+
+    try {
+      new Request.Builder().method("GET", RequestBody.create(MediaType.parse("text/plain"), "abc"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
   @Test public void head() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Type: text/plain"));
     server.play();
@@ -138,7 +208,7 @@
 
     Request request = new Request.Builder()
         .url(server.getUrl("/"))
-        .post(Request.Body.create(MediaType.parse("text/plain"), "def"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "def"))
         .build();
 
     executeSynchronously(request)
@@ -228,7 +298,7 @@
 
     Request request = new Request.Builder()
         .url(server.getUrl("/"))
-        .put(Request.Body.create(MediaType.parse("text/plain"), "def"))
+        .put(RequestBody.create(MediaType.parse("text/plain"), "def"))
         .build();
 
     executeSynchronously(request)
@@ -258,7 +328,7 @@
 
     Request request = new Request.Builder()
         .url(server.getUrl("/"))
-        .patch(Request.Body.create(MediaType.parse("text/plain"), "def"))
+        .patch(RequestBody.create(MediaType.parse("text/plain"), "def"))
         .build();
 
     executeSynchronously(request)
@@ -282,6 +352,23 @@
     patch();
   }
 
+  @Test public void unspecifiedRequestBodyContentTypeDoesNotGetDefault() throws Exception {
+    server.enqueue(new MockResponse());
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .method("POST", RequestBody.create(null, "abc"))
+        .build();
+
+    executeSynchronously(request).assertCode(200);
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(null, recordedRequest.getHeader("Content-Type"));
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("abc", recordedRequest.getUtf8Body());
+  }
+
   @Test public void illegalToExecuteTwice() throws Exception {
     server.enqueue(new MockResponse()
         .setBody("abc")
@@ -364,6 +451,41 @@
     assertTrue(server.takeRequest().getHeaders().contains("User-Agent: AsyncApiTest"));
   }
 
+  @Test public void onResponseThrowsIsHandledByUncaughtExceptionHandler() throws Exception {
+    server.enqueue(new MockResponse());
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+
+    final AtomicReference<Throwable> uncaughtExceptionRef = new AtomicReference<>();
+    final CountDownLatch latch = new CountDownLatch(1);
+
+    Thread.setDefaultUncaughtExceptionHandler(new UncaughtExceptionHandler() {
+      @Override public void uncaughtException(Thread thread, Throwable throwable) {
+        uncaughtExceptionRef.set(throwable);
+        latch.countDown();
+      }
+    });
+
+    client.newCall(request).enqueue(new Callback() {
+      @Override public void onFailure(Request request, IOException e) {
+        fail();
+      }
+
+      @Override public void onResponse(Response response) throws IOException {
+        throw new IOException("a");
+      }
+    });
+
+    latch.await();
+    Throwable uncaughtException = uncaughtExceptionRef.get();
+    assertEquals(RuntimeException.class, uncaughtException.getClass());
+    assertEquals(IOException.class, uncaughtException.getCause().getClass());
+    assertEquals("a", uncaughtException.getCause().getMessage());
+  }
+
   @Test public void connectionPooling() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
     server.enqueue(new MockResponse().setBody("def"));
@@ -410,8 +532,8 @@
     server.play();
 
     Request request = new Request.Builder().url(server.getUrl("/a")).build();
-    client.newCall(request).enqueue(new Response.Callback() {
-      @Override public void onFailure(Failure failure) {
+    client.newCall(request).enqueue(new Callback() {
+      @Override public void onFailure(Request request, IOException e) {
         throw new AssertionError();
       }
 
@@ -544,7 +666,7 @@
 
     Request request = new Request.Builder()
         .url(server.getUrl("/"))
-        .post(Request.Body.create(MediaType.parse("text/plain"), "def"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "def"))
         .build();
     client.newCall(request).enqueue(callback);
 
@@ -571,7 +693,7 @@
 
     Request request2 = new Request.Builder()
         .url(server.getUrl("/"))
-        .post(Request.Body.create(MediaType.parse("text/plain"), "body!"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "body!"))
         .build();
     Response response2 = client.newCall(request2).execute();
     assertEquals("def", response2.body().string());
@@ -588,22 +710,118 @@
     assertEquals(0, post2.getSequenceNumber());
   }
 
+  @Test public void cacheHit() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Vary: Accept-Charset")
+        .setBody("A"));
+    server.play();
+
+    client.setCache(cache);
+
+    // Store a response in the cache.
+    URL url = server.getUrl("/");
+    Request cacheStoreRequest = new Request.Builder()
+        .url(url)
+        .addHeader("Accept-Language", "fr-CA")
+        .addHeader("Accept-Charset", "UTF-8")
+        .build();
+    executeSynchronously(cacheStoreRequest)
+        .assertCode(200)
+        .assertBody("A");
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    // Hit that stored response.
+    Request cacheHitRequest = new Request.Builder()
+        .url(url)
+        .addHeader("Accept-Language", "en-US") // Different, but Vary says it doesn't matter.
+        .addHeader("Accept-Charset", "UTF-8")
+        .build();
+    RecordedResponse cacheHit = executeSynchronously(cacheHitRequest);
+
+    // Check the merged response. The request is the application's original request.
+    cacheHit.assertCode(200)
+        .assertBody("A")
+        .assertHeader("ETag", "v1")
+        .assertRequestUrl(cacheStoreRequest.url())
+        .assertRequestHeader("Accept-Language", "en-US")
+        .assertRequestHeader("Accept-Charset", "UTF-8");
+
+    // Check the cached response. Its request contains only the saved Vary headers.
+    cacheHit.cacheResponse()
+        .assertCode(200)
+        .assertHeader("ETag", "v1")
+        .assertRequestMethod("GET")
+        .assertRequestUrl(cacheStoreRequest.url())
+        .assertRequestHeader("Accept-Language")
+        .assertRequestHeader("Accept-Charset", "UTF-8");
+
+    cacheHit.assertNoNetworkResponse();
+  }
+
   @Test public void conditionalCacheHit() throws Exception {
-    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .addHeader("Vary: Accept-Charset")
+        .addHeader("Donut: a")
+        .setBody("A"));
     server.enqueue(new MockResponse()
         .clearHeaders()
+        .addHeader("Donut: b")
         .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
     server.play();
 
     client.setCache(cache);
 
-    executeSynchronously(new Request.Builder().url(server.getUrl("/")).build())
-        .assertCode(200).assertBody("A");
+    // Store a response in the cache.
+    URL url = server.getUrl("/");
+    Request cacheStoreRequest = new Request.Builder()
+        .url(url)
+        .addHeader("Accept-Language", "fr-CA")
+        .addHeader("Accept-Charset", "UTF-8")
+        .build();
+    executeSynchronously(cacheStoreRequest)
+        .assertCode(200)
+        .assertHeader("Donut", "a")
+        .assertBody("A");
     assertNull(server.takeRequest().getHeader("If-None-Match"));
 
-    executeSynchronously(new Request.Builder().url(server.getUrl("/")).build())
-        .assertCode(200).assertBody("A");
+    // Hit that stored response.
+    Request cacheHitRequest = new Request.Builder()
+        .url(url)
+        .addHeader("Accept-Language", "en-US") // Different, but Vary says it doesn't matter.
+        .addHeader("Accept-Charset", "UTF-8")
+        .build();
+    RecordedResponse cacheHit = executeSynchronously(cacheHitRequest);
     assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+
+    // Check the merged response. The request is the application's original request.
+    cacheHit.assertCode(200)
+        .assertBody("A")
+        .assertHeader("Donut", "b")
+        .assertRequestUrl(cacheStoreRequest.url())
+        .assertRequestHeader("Accept-Language", "en-US")
+        .assertRequestHeader("Accept-Charset", "UTF-8")
+        .assertRequestHeader("If-None-Match"); // No If-None-Match on the user's request.
+
+    // Check the cached response. Its request contains only the saved Vary headers.
+    cacheHit.cacheResponse()
+        .assertCode(200)
+        .assertHeader("Donut", "a")
+        .assertHeader("ETag", "v1")
+        .assertRequestUrl(cacheStoreRequest.url())
+        .assertRequestHeader("Accept-Language") // No Vary on Accept-Language.
+        .assertRequestHeader("Accept-Charset", "UTF-8") // Because of Vary on Accept-Charset.
+        .assertRequestHeader("If-None-Match"); // This wasn't present in the original request.
+
+    // Check the network response. It has the caller's request, plus some caching headers.
+    cacheHit.networkResponse()
+        .assertCode(304)
+        .assertHeader("Donut", "b")
+        .assertRequestHeader("Accept-Language", "en-US")
+        .assertRequestHeader("Accept-Charset", "UTF-8")
+        .assertRequestHeader("If-None-Match", "v1"); // If-None-Match in the validation request.
   }
 
   @Test public void conditionalCacheHit_Async() throws Exception {
@@ -631,19 +849,55 @@
   }
 
   @Test public void conditionalCacheMiss() throws Exception {
-    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
-    server.enqueue(new MockResponse().setBody("B"));
+    server.enqueue(new MockResponse()
+        .addHeader("ETag: v1")
+        .addHeader("Vary: Accept-Charset")
+        .addHeader("Donut: a")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Donut: b")
+        .setBody("B"));
     server.play();
 
     client.setCache(cache);
 
-    executeSynchronously(new Request.Builder().url(server.getUrl("/")).build())
-        .assertCode(200).assertBody("A");
+    Request cacheStoreRequest = new Request.Builder()
+        .url(server.getUrl("/"))
+        .addHeader("Accept-Language", "fr-CA")
+        .addHeader("Accept-Charset", "UTF-8")
+        .build();
+    executeSynchronously(cacheStoreRequest)
+        .assertCode(200)
+        .assertBody("A");
     assertNull(server.takeRequest().getHeader("If-None-Match"));
 
-    executeSynchronously(new Request.Builder().url(server.getUrl("/")).build())
-        .assertCode(200).assertBody("B");
+    Request cacheMissRequest = new Request.Builder()
+        .url(server.getUrl("/"))
+        .addHeader("Accept-Language", "en-US") // Different, but Vary says it doesn't matter.
+        .addHeader("Accept-Charset", "UTF-8")
+        .build();
+    RecordedResponse cacheHit = executeSynchronously(cacheMissRequest);
     assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+
+    // Check the user response. It has the application's original request.
+    cacheHit.assertCode(200)
+        .assertBody("B")
+        .assertHeader("Donut", "b")
+        .assertRequestUrl(cacheStoreRequest.url());
+
+    // Check the cache response. Even though it's a miss, we used the cache.
+    cacheHit.cacheResponse()
+        .assertCode(200)
+        .assertHeader("Donut", "a")
+        .assertHeader("ETag", "v1")
+        .assertRequestUrl(cacheStoreRequest.url());
+
+    // Check the network response. It has the network request, plus caching headers.
+    cacheHit.networkResponse()
+        .assertCode(200)
+        .assertHeader("Donut", "b")
+        .assertRequestHeader("If-None-Match", "v1")  // If-None-Match in the validation request.
+        .assertRequestUrl(cacheStoreRequest.url());
   }
 
   @Test public void conditionalCacheMiss_Async() throws Exception {
@@ -668,6 +922,21 @@
     assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
   }
 
+  @Test public void onlyIfCachedReturns504WhenNotCached() throws Exception {
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("Cache-Control", "only-if-cached")
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(504)
+        .assertBody("")
+        .assertNoNetworkResponse()
+        .assertNoCacheResponse();
+  }
+
   @Test public void redirect() throws Exception {
     server.enqueue(new MockResponse()
         .setResponseCode(301)
@@ -685,10 +954,10 @@
     executeSynchronously(new Request.Builder().url(server.getUrl("/a")).build())
         .assertCode(200)
         .assertBody("C")
-        .redirectedBy()
+        .priorResponse()
         .assertCode(302)
         .assertHeader("Test", "Redirect from /b to /c")
-        .redirectedBy()
+        .priorResponse()
         .assertCode(301)
         .assertHeader("Test", "Redirect from /a to /b");
 
@@ -707,7 +976,7 @@
 
     Response response = client.newCall(new Request.Builder()
         .url(server.getUrl("/page1"))
-        .post(Request.Body.create(MediaType.parse("text/plain"), "Request Body"))
+        .post(RequestBody.create(MediaType.parse("text/plain"), "Request Body"))
         .build()).execute();
     assertEquals("Page 2", response.body().string());
 
@@ -720,13 +989,12 @@
   }
 
   @Test public void redirectsDoNotIncludeTooManyCookies() throws Exception {
-    MockWebServer redirectTarget = new MockWebServer();
-    redirectTarget.enqueue(new MockResponse().setBody("Page 2"));
-    redirectTarget.play();
+    server2.enqueue(new MockResponse().setBody("Page 2"));
+    server2.play();
 
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
-        .addHeader("Location: " + redirectTarget.getUrl("/")));
+        .addHeader("Location: " + server2.getUrl("/")));
     server.play();
 
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
@@ -748,10 +1016,30 @@
         + "c=\"cookie\";$Path=\"/\";$Domain=\"" + server.getCookieDomain()
         + "\";$Port=\"" + portList + "\"");
 
-    RecordedRequest request2 = redirectTarget.takeRequest();
+    RecordedRequest request2 = server2.takeRequest();
     assertContainsNoneMatching(request2.getHeaders(), "Cookie.*");
   }
 
+  @Test public void redirectsDoNotIncludeTooManyAuthHeaders() throws Exception {
+    server2.enqueue(new MockResponse().setBody("Page 2"));
+    server2.play();
+
+    server.enqueue(new MockResponse().setResponseCode(401));
+    server.enqueue(new MockResponse().setResponseCode(302)
+        .addHeader("Location: " + server2.getUrl("/b")));
+    server.play();
+
+    client.setAuthenticator(new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")));
+
+    Request request = new Request.Builder().url(server.getUrl("/a")).build();
+    Response response = client.newCall(request).execute();
+    assertEquals("Page 2", response.body().string());
+
+    RecordedRequest redirectRequest = server2.takeRequest();
+    assertContainsNoneMatching(redirectRequest.getHeaders(), "Authorization.*");
+    assertEquals("/b", redirectRequest.getPath());
+  }
+
   @Test public void redirect_Async() throws Exception {
     server.enqueue(new MockResponse()
         .setResponseCode(301)
@@ -772,10 +1060,10 @@
     callback.await(server.getUrl("/c"))
         .assertCode(200)
         .assertBody("C")
-        .redirectedBy()
+        .priorResponse()
         .assertCode(302)
         .assertHeader("Test", "Redirect from /b to /c")
-        .redirectedBy()
+        .priorResponse()
         .assertCode(301)
         .assertHeader("Test", "Redirect from /a to /b");
 
@@ -924,16 +1212,17 @@
   }
 
   @Test public void canceledBeforeResponseReadSignalsOnFailure() throws Exception {
+    server.play();
+    Request requestA = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
+    final Call call = client.newCall(requestA);
     server.setDispatcher(new Dispatcher() {
       @Override public MockResponse dispatch(RecordedRequest request) {
-        client.cancel("request A");
+        call.cancel();
         return new MockResponse().setBody("A");
       }
     });
-    server.play();
 
-    Request requestA = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
-    client.newCall(requestA).enqueue(callback);
+    call.enqueue(callback);
     assertEquals("/a", server.takeRequest().getPath());
 
     callback.await(requestA.url()).assertFailure("Canceled");
@@ -958,15 +1247,15 @@
     server.play();
 
     final CountDownLatch latch = new CountDownLatch(1);
-    final AtomicReference<String> bodyRef = new AtomicReference<String>();
-    final AtomicReference<Failure> failureRef = new AtomicReference<Failure>();
+    final AtomicReference<String> bodyRef = new AtomicReference<>();
+    final AtomicBoolean failureRef = new AtomicBoolean();
 
     Request request = new Request.Builder().url(server.getUrl("/a")).tag("request A").build();
     final Call call = client.newCall(request);
-    call.enqueue(new Response.Callback() {
-      @Override public void onFailure(Failure failure) {
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Request request, IOException e) {
+        failureRef.set(true);
         latch.countDown();
-        failureRef.set(failure); // This should never occur as we don't signal twice.
       }
 
       @Override public void onResponse(Response response) throws IOException {
@@ -984,7 +1273,7 @@
 
     latch.await();
     assertEquals("A", bodyRef.get());
-    assertNull(failureRef.get());
+    assertFalse(failureRef.get());
   }
 
   @Test public void canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce_HTTP_2()
@@ -999,6 +1288,102 @@
     canceledAfterResponseIsDeliveredBreaksStreamButSignalsOnce();
   }
 
+  @Test public void gzip() throws Exception {
+    Buffer gzippedBody = gzip("abcabcabc");
+    String bodySize = Long.toString(gzippedBody.size());
+
+    server.enqueue(new MockResponse()
+        .setBody(gzippedBody)
+        .addHeader("Content-Encoding: gzip"));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+
+    // Confirm that the user request doesn't have Accept-Encoding, and the user
+    // response doesn't have a Content-Encoding or Content-Length.
+    RecordedResponse userResponse = executeSynchronously(request);
+    userResponse.assertCode(200)
+        .assertRequestHeader("Accept-Encoding")
+        .assertHeader("Content-Encoding")
+        .assertHeader("Content-Length")
+        .assertBody("abcabcabc");
+
+    // But the network request doesn't lie. OkHttp used gzip for this call.
+    userResponse.networkResponse()
+        .assertHeader("Content-Encoding", "gzip")
+        .assertHeader("Content-Length", bodySize)
+        .assertRequestHeader("Accept-Encoding", "gzip");
+  }
+
+  @Test public void asyncResponseCanBeConsumedLater() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("User-Agent", "SyncApiTest")
+        .build();
+
+    final BlockingQueue<Response> responseRef = new SynchronousQueue<>();
+    client.newCall(request).enqueue(new Callback() {
+      @Override public void onFailure(Request request, IOException e) {
+        throw new AssertionError();
+      }
+
+      @Override public void onResponse(Response response) throws IOException {
+        try {
+          responseRef.put(response);
+        } catch (InterruptedException e) {
+          throw new AssertionError();
+        }
+      }
+    });
+
+    Response response = responseRef.take();
+    assertEquals(200, response.code());
+    assertEquals("abc", response.body().string());
+
+    // Make another request just to confirm that that connection can be reused...
+    executeSynchronously(new Request.Builder().url(server.getUrl("/")).build()).assertBody("def");
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
+
+    // ... even before we close the response body!
+    response.body().close();
+  }
+
+  @Test public void userAgentIsOmittedByDefault() throws Exception {
+    server.enqueue(new MockResponse());
+    server.play();
+
+    executeSynchronously(new Request.Builder().url(server.getUrl("/")).build());
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertNull(recordedRequest.getHeader("User-Agent"));
+  }
+
+  @Test
+  public void setFollowRedirectsFalse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /b")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+    server.play();
+
+    client.setFollowRedirects(false);
+    RecordedResponse recordedResponse = executeSynchronously(
+        new Request.Builder().url(server.getUrl("/a")).build());
+
+    recordedResponse
+        .assertBody("A")
+        .assertCode(302);
+  }
+
   private RecordedResponse executeSynchronously(Request request) throws IOException {
     Response response = client.newCall(request).execute();
     return new RecordedResponse(request, response, response.body().string(), null);
@@ -1016,6 +1401,14 @@ private void enableProtocol(Protocol protocol) {
     server.setProtocols(client.getProtocols());
   }
 
+  private Buffer gzip(String data) throws IOException {
+    Buffer result = new Buffer();
+    BufferedSink sink = Okio.buffer(new GzipSink(result));
+    sink.writeUtf8(data);
+    sink.close();
+    return result;
+  }
+
   private void assertContains(Collection<String> collection, String element) {
     for (String c : collection) {
       if (c != null && c.equalsIgnoreCase(element)) return;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
index f24e9d8c60..147a7d41cb 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
@@ -18,7 +18,7 @@
 import com.squareup.okhttp.internal.RecordingHostnameVerifier;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
-import com.squareup.okhttp.internal.huc.AuthenticatorAdapter;
+import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import java.io.IOException;
 import java.net.InetAddress;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
index 59e35e2263..68713b9ef2 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
@@ -132,14 +132,14 @@
   }
 
   class RecordingExecutor extends AbstractExecutorService {
-    private List<AsyncCall> calls = new ArrayList<AsyncCall>();
+    private List<AsyncCall> calls = new ArrayList<>();
 
     @Override public void execute(Runnable command) {
       calls.add((AsyncCall) command);
     }
 
     public void assertJobs(String... expectedUrls) {
-      List<String> actualUrls = new ArrayList<String>();
+      List<String> actualUrls = new ArrayList<>();
       for (AsyncCall call : calls) {
         actualUrls.add(call.request().urlString());
       }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/FormEncodingBuilderTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/FormEncodingBuilderTest.java
new file mode 100644
index 0000000000..a9533bf783
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/FormEncodingBuilderTest.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import okio.Buffer;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public final class FormEncodingBuilderTest {
+  @Test public void urlEncoding() throws Exception {
+    RequestBody formEncoding = new FormEncodingBuilder()
+        .add("a&b", "c=d")
+        .add("space, the", "final frontier")
+        .build();
+
+    assertEquals("application/x-www-form-urlencoded", formEncoding.contentType().toString());
+
+    String expected = "a%26b=c%3Dd&space%2C+the=final+frontier";
+    assertEquals(expected.length(), formEncoding.contentLength());
+
+    Buffer out = new Buffer();
+    formEncoding.writeTo(out);
+    assertEquals(expected, out.readUtf8());
+  }
+
+  @Test public void encodedPair() throws Exception {
+    RequestBody formEncoding = new FormEncodingBuilder()
+        .add("sim", "ple")
+        .build();
+
+    String expected = "sim=ple";
+    assertEquals(expected.length(), formEncoding.contentLength());
+
+    Buffer buffer = new Buffer();
+    formEncoding.writeTo(buffer);
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void encodeMultiplePairs() throws Exception {
+    RequestBody formEncoding = new FormEncodingBuilder()
+        .add("sim", "ple")
+        .add("hey", "there")
+        .add("help", "me")
+        .build();
+
+    String expected = "sim=ple&hey=there&help=me";
+    assertEquals(expected.length(), formEncoding.contentLength());
+
+    Buffer buffer = new Buffer();
+    formEncoding.writeTo(buffer);
+    assertEquals(expected, buffer.readUtf8());
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/MediaTypeTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/MediaTypeTest.java
index 45dd06a64f..25805957a5 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/MediaTypeTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/MediaTypeTest.java
@@ -107,6 +107,11 @@
     assertEquals("UTF-8", mediaType.charset().name());
   }
 
+  @Test public void testDuplicatedCharsets() {
+    MediaType mediaType = MediaType.parse("text/plain; charset=utf-8; charset=UTF-8");
+    assertEquals("UTF-8", mediaType.charset().name());
+  }
+
   @Test public void testMultipleCharsets() {
     try {
       MediaType.parse("text/plain; charset=utf-8; charset=utf-16");
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/MultipartBuilderTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/MultipartBuilderTest.java
new file mode 100644
index 0000000000..4159679c76
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/MultipartBuilderTest.java
@@ -0,0 +1,245 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import java.io.IOException;
+import okio.Buffer;
+import okio.BufferedSink;
+import org.junit.Test;
+
+import static com.squareup.okhttp.internal.Util.UTF_8;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class MultipartBuilderTest {
+  @Test(expected = IllegalStateException.class)
+  public void onePartRequired() throws Exception {
+    new MultipartBuilder().build();
+  }
+
+  @Test public void singlePart() throws Exception {
+    String expected = ""
+        + "--123\r\n"
+        + "Content-Length: 13\r\n"
+        + "\r\n"
+        + "Hello, World!\r\n"
+        + "--123--\r\n";
+
+    RequestBody requestBody = new MultipartBuilder("123")
+        .addPart(RequestBody.create(null, "Hello, World!"))
+        .build();
+
+    assertEquals("multipart/mixed; boundary=123", requestBody.contentType().toString());
+
+    Buffer buffer = new Buffer();
+    requestBody.writeTo(buffer);
+    assertEquals(53, requestBody.contentLength());
+    assertEquals(buffer.size(), requestBody.contentLength());
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void threeParts() throws Exception {
+    String expected = ""
+        + "--123\r\n"
+        + "Content-Length: 5\r\n"
+        + "\r\n"
+        + "Quick\r\n"
+        + "--123\r\n"
+        + "Content-Length: 5\r\n"
+        + "\r\n"
+        + "Brown\r\n"
+        + "--123\r\n"
+        + "Content-Length: 3\r\n"
+        + "\r\n"
+        + "Fox\r\n"
+        + "--123--\r\n";
+
+    RequestBody requestBody = new MultipartBuilder("123")
+        .addPart(RequestBody.create(null, "Quick"))
+        .addPart(RequestBody.create(null, "Brown"))
+        .addPart(RequestBody.create(null, "Fox"))
+        .build();
+
+    assertEquals("multipart/mixed; boundary=123", requestBody.contentType().toString());
+
+    Buffer buffer = new Buffer();
+    requestBody.writeTo(buffer);
+    assertEquals(112, requestBody.contentLength());
+    assertEquals(buffer.size(), requestBody.contentLength());
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void fieldAndTwoFiles() throws Exception {
+    String expected = ""
+        + "--AaB03x\r\n"
+        + "Content-Disposition: form-data; name=\"submit-name\"\r\n"
+        + "Content-Length: 5\r\n"
+        + "\r\n"
+        + "Larry\r\n"
+        + "--AaB03x\r\n"
+        + "Content-Disposition: form-data; name=\"files\"\r\n"
+        + "Content-Type: multipart/mixed; boundary=BbC04y\r\n"
+        + "Content-Length: 337\r\n"
+        + "\r\n"
+        + "--BbC04y\r\n"
+        + "Content-Disposition: file; filename=\"file1.txt\"\r\n"
+        + "Content-Type: text/plain; charset=utf-8\r\n"
+        + "Content-Length: 29\r\n"
+        + "\r\n"
+        + "... contents of file1.txt ...\r\n"
+        + "--BbC04y\r\n"
+        + "Content-Disposition: file; filename=\"file2.gif\"\r\n"
+        + "Content-Transfer-Encoding: binary\r\n"
+        + "Content-Type: image/gif\r\n"
+        + "Content-Length: 29\r\n"
+        + "\r\n"
+        + "... contents of file2.gif ...\r\n"
+        + "--BbC04y--\r\n"
+        + "\r\n"
+        + "--AaB03x--\r\n";
+
+    RequestBody requestBody = new MultipartBuilder("AaB03x")
+        .type(MultipartBuilder.FORM)
+        .addFormDataPart("submit-name", "Larry")
+        .addFormDataPart("files", null,
+            new MultipartBuilder("BbC04y")
+                .addPart(
+                    Headers.of("Content-Disposition", "file; filename=\"file1.txt\""),
+                    RequestBody.create(
+                        MediaType.parse("text/plain"), "... contents of file1.txt ..."))
+                .addPart(
+                    Headers.of(
+                        "Content-Disposition", "file; filename=\"file2.gif\"",
+                        "Content-Transfer-Encoding", "binary"),
+                    RequestBody.create(
+                        MediaType.parse("image/gif"),
+                        "... contents of file2.gif ...".getBytes(UTF_8)))
+                .build())
+        .build();
+
+    assertEquals("multipart/form-data; boundary=AaB03x", requestBody.contentType().toString());
+
+    Buffer buffer = new Buffer();
+    requestBody.writeTo(buffer);
+    assertEquals(568, requestBody.contentLength());
+    assertEquals(buffer.size(), requestBody.contentLength());
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void stringEscapingIsWeird() throws Exception {
+    String expected = ""
+        + "--AaB03x\r\n"
+        + "Content-Disposition: form-data; name=\"field with spaces\"; filename=\"filename with spaces.txt\"\r\n"
+        + "Content-Type: text/plain; charset=utf-8\r\n"
+        + "Content-Length: 4\r\n"
+        + "\r\n"
+        + "okay\r\n"
+        + "--AaB03x\r\n"
+        + "Content-Disposition: form-data; name=\"field with %22\"\r\n"
+        + "Content-Length: 1\r\n"
+        + "\r\n"
+        + "\"\r\n"
+        + "--AaB03x\r\n"
+        + "Content-Disposition: form-data; name=\"field with %22\"\r\n"
+        + "Content-Length: 3\r\n"
+        + "\r\n"
+        + "%22\r\n"
+        + "--AaB03x\r\n"
+        + "Content-Disposition: form-data; name=\"field with \u0391\"\r\n"
+        + "Content-Length: 5\r\n"
+        + "\r\n"
+        + "Alpha\r\n"
+        + "--AaB03x--\r\n";
+
+    RequestBody requestBody = new MultipartBuilder("AaB03x")
+        .type(MultipartBuilder.FORM)
+        .addFormDataPart("field with spaces", "filename with spaces.txt",
+            RequestBody.create(MediaType.parse("text/plain; charset=utf-8"), "okay"))
+        .addFormDataPart("field with \"", "\"")
+        .addFormDataPart("field with %22", "%22")
+        .addFormDataPart("field with \u0391", "Alpha")
+        .build();
+
+    Buffer buffer = new Buffer();
+    requestBody.writeTo(buffer);
+    assertEquals(expected, buffer.readUtf8());
+  }
+
+  @Test public void streamingPartHasNoLength() throws Exception {
+    class StreamingBody extends RequestBody {
+      private final String body;
+
+      StreamingBody(String body) {
+        this.body = body;
+      }
+
+      @Override public MediaType contentType() {
+        return null;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8(body);
+      }
+    }
+
+    String expected = ""
+        + "--123\r\n"
+        + "Content-Length: 5\r\n"
+        + "\r\n"
+        + "Quick\r\n"
+        + "--123\r\n"
+        + "\r\n"
+        + "Brown\r\n"
+        + "--123\r\n"
+        + "Content-Length: 3\r\n"
+        + "\r\n"
+        + "Fox\r\n"
+        + "--123--\r\n";
+
+    RequestBody requestBody = new MultipartBuilder("123")
+        .addPart(RequestBody.create(null, "Quick"))
+        .addPart(new StreamingBody("Brown"))
+        .addPart(RequestBody.create(null, "Fox"))
+        .build();
+
+    assertEquals("multipart/mixed; boundary=123", requestBody.contentType().toString());
+
+    Buffer buffer = new Buffer();
+    requestBody.writeTo(buffer);
+    assertEquals(expected, buffer.readUtf8());
+    assertEquals(-1, requestBody.contentLength());
+  }
+
+  @Test public void contentTypeHeaderIsForbidden() throws Exception {
+    try {
+      new MultipartBuilder().addPart(
+          Headers.of("Content-Type", "text/plain"),
+          RequestBody.create(null, "Hello, World!"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void contentLengthHeaderIsForbidden() throws Exception {
+    try {
+      new MultipartBuilder().addPart(
+          Headers.of("Content-Length", "13"),
+          RequestBody.create(null, "Hello, World!"));
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java
new file mode 100644
index 0000000000..7ecd2a1ff1
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/OkHttpClientTest.java
@@ -0,0 +1,167 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.RecordingAuthenticator;
+import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
+import com.squareup.okhttp.internal.http.RecordingProxySelector;
+import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
+import java.io.IOException;
+import java.net.Authenticator;
+import java.net.CookieHandler;
+import java.net.CookieManager;
+import java.net.ProxySelector;
+import java.net.ResponseCache;
+import java.util.Arrays;
+import javax.net.SocketFactory;
+import org.junit.After;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+
+public final class OkHttpClientTest {
+  private static final ProxySelector DEFAULT_PROXY_SELECTOR = ProxySelector.getDefault();
+  private static final CookieHandler DEFAULT_COOKIE_HANDLER = CookieManager.getDefault();
+  private static final ResponseCache DEFAULT_RESPONSE_CACHE = ResponseCache.getDefault();
+  private static final Authenticator DEFAULT_AUTHENTICATOR = null; // No Authenticator.getDefault().
+
+  @After public void tearDown() throws Exception {
+    ProxySelector.setDefault(DEFAULT_PROXY_SELECTOR);
+    CookieManager.setDefault(DEFAULT_COOKIE_HANDLER);
+    ResponseCache.setDefault(DEFAULT_RESPONSE_CACHE);
+    Authenticator.setDefault(DEFAULT_AUTHENTICATOR);
+  }
+
+  /** Confirm that {@code copyWithDefaults} gets expected constant values. */
+  @Test public void copyWithDefaultsWhenDefaultIsAConstant() throws Exception {
+    OkHttpClient client = new OkHttpClient().copyWithDefaults();
+    assertNull(client.internalCache());
+    assertEquals(0, client.getConnectTimeout());
+    assertEquals(0, client.getReadTimeout());
+    assertEquals(0, client.getWriteTimeout());
+    assertTrue(client.getFollowSslRedirects());
+    assertNull(client.getProxy());
+    assertEquals(Arrays.asList(Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1),
+        client.getProtocols());
+  }
+
+  /**
+   * Confirm that {@code copyWithDefaults} gets some default implementations
+   * from the core library.
+   */
+  @Test public void copyWithDefaultsWhenDefaultIsGlobal() throws Exception {
+    ProxySelector proxySelector = new RecordingProxySelector();
+    CookieManager cookieManager = new CookieManager();
+    Authenticator authenticator = new RecordingAuthenticator();
+    SocketFactory socketFactory = SocketFactory.getDefault(); // Global isn't configurable.
+    OkHostnameVerifier hostnameVerifier = OkHostnameVerifier.INSTANCE; // Global isn't configurable.
+
+    CookieManager.setDefault(cookieManager);
+    ProxySelector.setDefault(proxySelector);
+    Authenticator.setDefault(authenticator);
+
+    OkHttpClient client = new OkHttpClient().copyWithDefaults();
+
+    assertSame(proxySelector, client.getProxySelector());
+    assertSame(cookieManager, client.getCookieHandler());
+    assertSame(AuthenticatorAdapter.INSTANCE, client.getAuthenticator());
+    assertSame(socketFactory, client.getSocketFactory());
+    assertSame(hostnameVerifier, client.getHostnameVerifier());
+  }
+
+  /** There is no default cache. */
+  @Test public void copyWithDefaultsCacheIsNull() throws Exception {
+    OkHttpClient client = new OkHttpClient().copyWithDefaults();
+    assertNull(client.getCache());
+  }
+
+  @Test public void copyWithDefaultsDoesNotHonorGlobalResponseCache() throws Exception {
+    ResponseCache responseCache = new AbstractResponseCache();
+    ResponseCache.setDefault(responseCache);
+
+    OkHttpClient client = new OkHttpClient().copyWithDefaults();
+    assertNull(client.internalCache());
+  }
+
+  /**
+   * When copying the client, stateful things like the connection pool are
+   * shared across all clients.
+   */
+  @Test public void cloneSharesStatefulInstances() throws Exception {
+    OkHttpClient client = new OkHttpClient();
+
+    // Values should be non-null.
+    OkHttpClient a = client.clone().copyWithDefaults();
+    assertNotNull(a.routeDatabase());
+    assertNotNull(a.getDispatcher());
+    assertNotNull(a.getConnectionPool());
+    assertNotNull(a.getSslSocketFactory());
+
+    // Multiple clients share the instances.
+    OkHttpClient b = client.clone().copyWithDefaults();
+    assertSame(a.routeDatabase(), b.routeDatabase());
+    assertSame(a.getDispatcher(), b.getDispatcher());
+    assertSame(a.getConnectionPool(), b.getConnectionPool());
+    assertSame(a.getSslSocketFactory(), b.getSslSocketFactory());
+  }
+
+  /** We don't want to run user code inside of HttpEngine, etc. */
+  @Test public void copyWithDefaultsDoesNotReturnSubclass() throws Exception {
+    OkHttpClient subclass = new OkHttpClient() {};
+    OkHttpClient copy = subclass.copyWithDefaults();
+    assertEquals(OkHttpClient.class, copy.getClass());
+  }
+
+  @Test public void cloneReturnsSubclass() throws Exception {
+    OkHttpClient subclass = new OkHttpClient() {};
+    OkHttpClient clone = subclass.clone();
+    assertEquals(subclass.getClass(), clone.getClass());
+  }
+
+  /** Exercise a synchronous mocking case. */
+  @Test public void mock() throws Exception {
+    final Request request = new Request.Builder()
+        .url("http://example.com/")
+        .build();
+    final Response response = new Response.Builder()
+        .protocol(Protocol.HTTP_1_1)
+        .request(request)
+        .code(200)
+        .message("Alright")
+        .build();
+
+    OkHttpClient mockClient = new OkHttpClient() {
+      @Override public Call newCall(Request request) {
+        return new Call(this, request) {
+          @Override public Response execute() throws IOException {
+            return response;
+          }
+          @Override public void enqueue(Callback responseCallback) {
+          }
+          @Override public void cancel() {
+          }
+        };
+      }
+    };
+
+    Response actualResponse = mockClient.newCall(request).execute();
+    assertSame(response, actualResponse);
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java b/okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java
index f2341d13c5..4140b3b2f4 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java
@@ -15,9 +15,15 @@
  */
 package com.squareup.okhttp;
 
+import java.io.IOException;
+import java.net.URL;
+import java.util.Arrays;
+
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
 
 /**
  * A received response or failure recorded by the response recorder.
@@ -26,22 +32,47 @@
   public final Request request;
   public final Response response;
   public final String body;
-  public final Failure failure;
+  public final IOException failure;
 
-  RecordedResponse(Request request, Response response, String body, Failure failure) {
+  RecordedResponse(Request request, Response response, String body, IOException failure) {
     this.request = request;
     this.response = response;
     this.body = body;
     this.failure = failure;
   }
 
+  public RecordedResponse assertRequestUrl(URL url) {
+    assertEquals(url, request.url());
+    return this;
+  }
+
+  public RecordedResponse assertRequestMethod(String method) {
+    assertEquals(method, request.method());
+    return this;
+  }
+
+  public RecordedResponse assertRequestHeader(String name, String... values) {
+    assertEquals(Arrays.asList(values), request.headers(name));
+    return this;
+  }
+
   public RecordedResponse assertCode(int expectedCode) {
     assertEquals(expectedCode, response.code());
     return this;
   }
 
-  public RecordedResponse assertHeader(String name, String value) {
-    assertEquals(value, response.header(name));
+  public RecordedResponse assertSuccessful() {
+    assertTrue(response.isSuccessful());
+    return this;
+  }
+
+  public RecordedResponse assertNotSuccessful() {
+    assertFalse(response.isSuccessful());
+    return this;
+  }
+
+  public RecordedResponse assertHeader(String name, String... values) {
+    assertEquals(Arrays.asList(values), response.headers(name));
     return this;
   }
 
@@ -61,18 +92,52 @@ public RecordedResponse assertHandshake() {
   }
 
   /**
-   * Asserts that the current response was redirected and returns a new recorded
-   * response for the original request.
+   * Asserts that the current response was redirected and returns the prior
+   * response.
+   */
+  public RecordedResponse priorResponse() {
+    Response priorResponse = response.priorResponse();
+    assertNotNull(priorResponse);
+    assertNull(priorResponse.body());
+    return new RecordedResponse(priorResponse.request(), priorResponse, null, null);
+  }
+
+  /**
+   * Asserts that the current response used the network and returns the network
+   * response.
+   */
+  public RecordedResponse networkResponse() {
+    Response networkResponse = response.networkResponse();
+    assertNotNull(networkResponse);
+    assertNull(networkResponse.body());
+    return new RecordedResponse(networkResponse.request(), networkResponse, null, null);
+  }
+
+  /** Asserts that the current response didn't use the network. */
+  public RecordedResponse assertNoNetworkResponse() {
+    assertNull(response.networkResponse());
+    return this;
+  }
+
+  /** Asserts that the current response didn't use the cache. */
+  public RecordedResponse assertNoCacheResponse() {
+    assertNull(response.cacheResponse());
+    return this;
+  }
+
+  /**
+   * Asserts that the current response used the cache and returns the cache
+   * response.
    */
-  public RecordedResponse redirectedBy() {
-    Response redirectedBy = response.redirectedBy();
-    assertNotNull(redirectedBy);
-    assertNull(redirectedBy.body());
-    return new RecordedResponse(redirectedBy.request(), redirectedBy, null, null);
+  public RecordedResponse cacheResponse() {
+    Response cacheResponse = response.cacheResponse();
+    assertNotNull(cacheResponse);
+    assertNull(cacheResponse.body());
+    return new RecordedResponse(cacheResponse.request(), cacheResponse, null, null);
   }
 
   public void assertFailure(String message) {
     assertNotNull(failure);
-    assertEquals(message, failure.exception().getMessage());
+    assertEquals(message, failure.getMessage());
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/RecordingCallback.java b/okhttp-tests/src/test/java/com/squareup/okhttp/RecordingCallback.java
index 6da0db00c3..040c15652f 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/RecordingCallback.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/RecordingCallback.java
@@ -26,19 +26,19 @@
 /**
  * Records received HTTP responses so they can be later retrieved by tests.
  */
-public class RecordingCallback implements Response.Callback {
+public class RecordingCallback implements Callback {
   public static final long TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(10);
 
-  private final List<RecordedResponse> responses = new ArrayList<RecordedResponse>();
+  private final List<RecordedResponse> responses = new ArrayList<>();
 
-  @Override public synchronized void onFailure(Failure failure) {
-    responses.add(new RecordedResponse(failure.request(), null, null, failure));
+  @Override public synchronized void onFailure(Request request, IOException e) {
+    responses.add(new RecordedResponse(request, null, null, e));
     notifyAll();
   }
 
   @Override public synchronized void onResponse(Response response) throws IOException {
     Buffer buffer = new Buffer();
-    Response.Body body = response.body();
+    ResponseBody body = response.body();
     body.source().readAll(buffer);
 
     responses.add(new RecordedResponse(response.request(), response, buffer.readUtf8(), null));
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java
index 1878da5cf7..00f1d05421 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java
@@ -19,6 +19,9 @@
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
+import java.net.URI;
+import java.net.URL;
+
 import okio.Buffer;
 import org.junit.Test;
 
@@ -28,7 +31,7 @@
 public final class RequestTest {
   @Test public void string() throws Exception {
     MediaType contentType = MediaType.parse("text/plain; charset=utf-8");
-    Request.Body body = Request.Body.create(contentType, "abc".getBytes(Util.UTF_8));
+    RequestBody body = RequestBody.create(contentType, "abc".getBytes(Util.UTF_8));
     assertEquals(contentType, body.contentType());
     assertEquals(3, body.contentLength());
     assertEquals("616263", bodyToHex(body));
@@ -37,7 +40,7 @@
 
   @Test public void stringWithDefaultCharsetAdded() throws Exception {
     MediaType contentType = MediaType.parse("text/plain");
-    Request.Body body = Request.Body.create(contentType, "\u0800");
+    RequestBody body = RequestBody.create(contentType, "\u0800");
     assertEquals(MediaType.parse("text/plain; charset=utf-8"), body.contentType());
     assertEquals(3, body.contentLength());
     assertEquals("e0a080", bodyToHex(body));
@@ -45,7 +48,7 @@
 
   @Test public void stringWithNonDefaultCharsetSpecified() throws Exception {
     MediaType contentType = MediaType.parse("text/plain; charset=utf-16be");
-    Request.Body body = Request.Body.create(contentType, "\u0800");
+    RequestBody body = RequestBody.create(contentType, "\u0800");
     assertEquals(contentType, body.contentType());
     assertEquals(2, body.contentLength());
     assertEquals("0800", bodyToHex(body));
@@ -53,7 +56,7 @@
 
   @Test public void byteArray() throws Exception {
     MediaType contentType = MediaType.parse("text/plain");
-    Request.Body body = Request.Body.create(contentType, "abc".getBytes(Util.UTF_8));
+    RequestBody body = RequestBody.create(contentType, "abc".getBytes(Util.UTF_8));
     assertEquals(contentType, body.contentType());
     assertEquals(3, body.contentLength());
     assertEquals("616263", bodyToHex(body));
@@ -67,7 +70,7 @@
     writer.close();
 
     MediaType contentType = MediaType.parse("text/plain");
-    Request.Body body = Request.Body.create(contentType, file);
+    RequestBody body = RequestBody.create(contentType, file);
     assertEquals(contentType, body.contentType());
     assertEquals(3, body.contentLength());
     assertEquals("616263", bodyToHex(body));
@@ -77,7 +80,7 @@
   /** Common verbs used for apis such as GitHub, AWS, and Google Cloud. */
   @Test public void crudVerbs() {
     MediaType contentType = MediaType.parse("application/json");
-    Request.Body body = Request.Body.create(contentType, "{}");
+    RequestBody body = RequestBody.create(contentType, "{}");
 
     Request get = new Request.Builder().url("http://localhost/api").get().build();
     assertEquals("GET", get.method());
@@ -104,7 +107,13 @@
     assertEquals(body, patch.body());
   }
 
-  private String bodyToHex(Request.Body body) throws IOException {
+  @Test public void uninitializedURI() throws Exception {
+    Request request = new Request.Builder().url("http://localhost/api").build();
+    assertEquals(new URI("http://localhost/api"), request.uri());
+    assertEquals(new URL("http://localhost/api"), request.url());
+  }
+
+  private String bodyToHex(RequestBody body) throws IOException {
     Buffer buffer = new Buffer();
     body.writeTo(buffer);
     return buffer.readByteString().hex();
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java
index 9eff91919a..292875bff6 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java
@@ -24,7 +24,7 @@
   /** base64("username:password") */
   public static final String BASE_64_CREDENTIALS = "dXNlcm5hbWU6cGFzc3dvcmQ=";
 
-  public final List<String> calls = new ArrayList<String>();
+  public final List<String> calls = new ArrayList<>();
   public final PasswordAuthentication authentication;
 
   public RecordingAuthenticator(PasswordAuthentication authentication) {
@@ -36,23 +36,14 @@ public RecordingAuthenticator() {
   }
 
   @Override protected PasswordAuthentication getPasswordAuthentication() {
-    this.calls
-        .add("host="
-            + getRequestingHost()
-            + " port="
-            + getRequestingPort()
-            + " site="
-            + getRequestingSite()
-            + " url="
-            + getRequestingURL()
-            + " type="
-            + getRequestorType()
-            + " prompt="
-            + getRequestingPrompt()
-            + " protocol="
-            + getRequestingProtocol()
-            + " scheme="
-            + getRequestingScheme());
+    this.calls.add("host=" + getRequestingHost()
+        + " port=" + getRequestingPort()
+        + " site=" + getRequestingSite().getHostName()
+        + " url=" + getRequestingURL()
+        + " type=" + getRequestorType()
+        + " prompt=" + getRequestingPrompt()
+        + " protocol=" + getRequestingProtocol()
+        + " scheme=" + getRequestingScheme());
     return authentication;
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java
index b3e2369b79..c9d914f5f2 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java
@@ -21,7 +21,7 @@
 import javax.net.ssl.SSLSession;
 
 public final class RecordingHostnameVerifier implements HostnameVerifier {
-  public final List<String> calls = new ArrayList<String>();
+  public final List<String> calls = new ArrayList<>();
 
   public boolean verify(String hostname, SSLSession session) {
     calls.add("verify " + hostname);
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java
index 6d1cd8318c..f5b3617d9d 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java
@@ -15,36 +15,43 @@
  */
 package com.squareup.okhttp.internal;
 
-import com.squareup.okhttp.OkAuthenticator;
+import com.squareup.okhttp.Authenticator;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import java.net.Proxy;
 import java.util.ArrayList;
 import java.util.List;
 
-public final class RecordingOkAuthenticator implements OkAuthenticator {
-  public final List<String> calls = new ArrayList<String>();
+public final class RecordingOkAuthenticator implements Authenticator {
+  public final List<Response> responses = new ArrayList<>();
+  public final List<Proxy> proxies = new ArrayList<>();
   public final String credential;
 
   public RecordingOkAuthenticator(String credential) {
     this.credential = credential;
   }
 
+  public Response onlyResponse() {
+    if (responses.size() != 1) throw new IllegalStateException();
+    return responses.get(0);
+  }
+
+  public Proxy onlyProxy() {
+    if (proxies.size() != 1) throw new IllegalStateException();
+    return proxies.get(0);
+  }
+
   @Override public Request authenticate(Proxy proxy, Response response) {
-    calls.add("authenticate"
-        + " proxy=" + proxy.type()
-        + " url=" + response.request().url()
-        + " challenges=" + response.challenges());
+    responses.add(response);
+    proxies.add(proxy);
     return response.request().newBuilder()
         .addHeader("Authorization", credential)
         .build();
   }
 
   @Override public Request authenticateProxy(Proxy proxy, Response response) {
-    calls.add("authenticateProxy"
-        + " proxy=" + proxy.type()
-        + " url=" + response.request().url()
-        + " challenges=" + response.challenges());
+    responses.add(response);
+    proxies.add(proxy);
     return response.request().newBuilder()
         .addHeader("Proxy-Authorization", credential)
         .build();
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java
index a44e6839f8..a738cde082 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java
@@ -17,14 +17,10 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.Test;
-
 import java.io.IOException;
 import java.net.CookieHandler;
 import java.net.CookieManager;
@@ -37,6 +33,9 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
 
 import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
 import static org.junit.Assert.assertEquals;
@@ -81,7 +80,7 @@ public void testNetscapeResponse() throws Exception {
     assertEquals(null, cookie.getComment());
     assertEquals(null, cookie.getCommentURL());
     assertEquals(false, cookie.getDiscard());
-    assertEquals(server.getCookieDomain(), cookie.getDomain());
+    assertTrue(server.getCookieDomain().equalsIgnoreCase(cookie.getDomain()));
     assertTrue(cookie.getMaxAge() > 100000000000L);
     assertEquals("/path", cookie.getPath());
     assertEquals(true, cookie.getSecure());
@@ -111,7 +110,7 @@ public void testNetscapeResponse() throws Exception {
     assertEquals("this cookie is delicious", cookie.getComment());
     assertEquals(null, cookie.getCommentURL());
     assertEquals(false, cookie.getDiscard());
-    assertEquals(server.getCookieDomain(), cookie.getDomain());
+    assertTrue(server.getCookieDomain().equalsIgnoreCase(cookie.getDomain()));
     assertEquals(60, cookie.getMaxAge());
     assertEquals("/path", cookie.getPath());
     assertEquals(true, cookie.getSecure());
@@ -144,7 +143,7 @@ public void testNetscapeResponse() throws Exception {
     assertEquals("this cookie is delicious", cookie.getComment());
     assertEquals("http://google.com/", cookie.getCommentURL());
     assertEquals(true, cookie.getDiscard());
-    assertEquals(server.getCookieDomain(), cookie.getDomain());
+    assertTrue(server.getCookieDomain().equalsIgnoreCase(cookie.getDomain()));
     assertEquals(60, cookie.getMaxAge());
     assertEquals("/path", cookie.getPath());
     assertEquals("80,443," + server.getPort(), cookie.getPortlist());
@@ -178,7 +177,7 @@ public void testNetscapeResponse() throws Exception {
     assertEquals("this cookie is delicious", cookie.getComment());
     assertEquals("http://google.com/", cookie.getCommentURL());
     assertEquals(true, cookie.getDiscard());
-    assertEquals(server.getCookieDomain(), cookie.getDomain());
+    assertTrue(server.getCookieDomain().equalsIgnoreCase(cookie.getDomain()));
     assertEquals(60, cookie.getMaxAge());
     assertEquals("/path", cookie.getPath());
     assertEquals("80,443," + server.getPort(), cookie.getPortlist());
@@ -253,13 +252,13 @@ public void testNetscapeResponse() throws Exception {
    * getRequestProperties}.
    */
   @Test public void testHeadersSentToCookieHandler() throws IOException, InterruptedException {
-    final Map<String, List<String>> cookieHandlerHeaders = new HashMap<String, List<String>>();
+    final Map<String, List<String>> cookieHandlerHeaders = new HashMap<>();
     CookieHandler.setDefault(new CookieManager() {
       @Override
       public Map<String, List<String>> get(URI uri,
           Map<String, List<String>> requestHeaders) throws IOException {
         cookieHandlerHeaders.putAll(requestHeaders);
-        Map<String, List<String>> result = new HashMap<String, List<String>>();
+        Map<String, List<String>> result = new HashMap<>();
         result.put("Cookie", Collections.singletonList("Bar=bar"));
         result.put("Cookie2", Collections.singletonList("Baz=baz"));
         result.put("Quux", Collections.singletonList("quux"));
@@ -270,7 +269,7 @@ public void testNetscapeResponse() throws Exception {
     server.enqueue(new MockResponse());
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
     assertEquals(Collections.<String, List<String>>emptyMap(),
         connection.getRequestProperties());
 
@@ -309,7 +308,7 @@ public void testNetscapeResponse() throws Exception {
     CookieHandler.setDefault(new CookieManager() {
       @Override public Map<String, List<String>> get(URI uri,
           Map<String, List<String>> requestHeaders) throws IOException {
-        Map<String, List<String>> result = new HashMap<String, List<String>>();
+        Map<String, List<String>> result = new HashMap<>();
         result.put("COOKIE", Collections.singletonList("Bar=bar"));
         result.put("cooKIE2", Collections.singletonList("Baz=baz"));
         return result;
@@ -342,7 +341,7 @@ private void assertContainsAll(Collection<String> collection, String... toFind)
   }
 
   private Map<String,List<String>> get(MockWebServer server, String path) throws Exception {
-    URLConnection connection = client.open(server.getUrl(path));
+    URLConnection connection = new OkUrlFactory(client).open(server.getUrl(path));
     Map<String, List<String>> headers = connection.getHeaderFields();
     connection.getInputStream().close();
     return headers;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/DisconnectTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/DisconnectTest.java
index db84214106..345211fefb 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/DisconnectTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/DisconnectTest.java
@@ -16,6 +16,7 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import java.io.IOException;
@@ -38,7 +39,7 @@
         .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
     disconnectLater(connection, 500);
 
     connection.setDoOutput(true);
@@ -65,7 +66,7 @@
         .throttleBody(64 * 1024, 125, TimeUnit.MILLISECONDS)); // 500 Kbps
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
     disconnectLater(connection, 500);
 
     InputStream responseBody = connection.getInputStream();
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
index b3f547095a..a9d097fe91 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
@@ -17,6 +17,7 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.Util;
 import java.io.BufferedReader;
@@ -31,9 +32,10 @@
 
 public final class ExternalHttp2Example {
   public static void main(String[] args) throws Exception {
-    URL url = new URL("https://http2.iijplus.jp/push/test1");
-    HttpsURLConnection connection = (HttpsURLConnection) new OkHttpClient()
-        .setProtocols(Util.immutableList(Protocol.HTTP_2, Protocol.HTTP_1_1))
+    URL url = new URL("https://twitter.com");
+    OkHttpClient client = new OkHttpClient()
+        .setProtocols(Util.immutableList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    HttpsURLConnection connection = (HttpsURLConnection) new OkUrlFactory(client)
         .open(url);
 
     connection.setHostnameVerifier(new HostnameVerifier() {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
index b155fb2782..7237583237 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
@@ -17,6 +17,7 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.Util;
 import java.io.BufferedReader;
@@ -32,8 +33,10 @@
 public final class ExternalSpdyExample {
   public static void main(String[] args) throws Exception {
     URL url = new URL("https://www.google.ca/");
-    HttpsURLConnection connection = (HttpsURLConnection) new OkHttpClient()
-        .setProtocols(Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1)).open(url);
+    OkHttpClient client = new OkHttpClient()
+        .setProtocols(Util.immutableList(Protocol.SPDY_3, Protocol.HTTP_1_1));
+    HttpsURLConnection connection = (HttpsURLConnection) new OkUrlFactory(client)
+        .open(url);
 
     connection.setHostnameVerifier(new HostnameVerifier() {
       @Override public boolean verify(String s, SSLSession sslSession) {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
index 5d3c950999..144ec78f46 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
@@ -27,6 +27,7 @@
 import static com.squareup.okhttp.internal.Util.headerEntries;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.fail;
 
 public final class HeadersTest {
   @Test public void parseNameValueBlock() throws IOException {
@@ -40,7 +41,7 @@
         SpdyTransport.readNameValueBlock(headerBlock, Protocol.SPDY_3).request(request).build();
     Headers headers = response.headers();
     assertEquals(4, headers.size());
-    assertEquals(Protocol.HTTP_1_1, response.protocol());
+    assertEquals(Protocol.SPDY_3, response.protocol());
     assertEquals(200, response.code());
     assertEquals("OK", response.message());
     assertEquals("no-cache, no-store", headers.get("cache-control"));
@@ -137,4 +138,57 @@
     assertEquals(expected,
         SpdyTransport.writeNameValueBlock(request, Protocol.HTTP_2, "HTTP/1.1"));
   }
+
+  @Test public void ofTrims() {
+    Headers headers = Headers.of("\t User-Agent \n", " \r OkHttp ");
+    assertEquals("User-Agent", headers.name(0));
+    assertEquals("OkHttp", headers.value(0));
+  }
+
+  @Test public void ofThrowsOddNumberOfHeaders() {
+    try {
+      Headers.of("User-Agent", "OkHttp", "Content-Length");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofThrowsOnNull() {
+    try {
+      Headers.of("User-Agent", null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofThrowsOnEmptyName() {
+    try {
+      Headers.of("", "OkHttp");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void ofAcceptsEmptyValue() {
+    Headers headers = Headers.of("User-Agent", "");
+    assertEquals("", headers.value(0));
+  }
+
+  @Test public void ofMakesDefensiveCopy() {
+    String[] namesAndValues = {
+        "User-Agent",
+        "OkHttp"
+    };
+    Headers headers = Headers.of(namesAndValues);
+    namesAndValues[1] = "Chrome";
+    assertEquals("OkHttp", headers.value(0));
+  }
+
+  @Test public void ofRejectsNulChar() {
+    try {
+      Headers.of("User-Agent", "Square\u0000OkHttp");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpDateTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpDateTest.java
new file mode 100644
index 0000000000..2181774f43
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpDateTest.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.util.Date;
+import java.util.TimeZone;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+public class HttpDateTest {
+
+  private TimeZone originalDefault;
+
+  @Before
+  public void setUp() throws Exception {
+    originalDefault = TimeZone.getDefault();
+    // The default timezone should affect none of these tests: HTTP specified GMT, so we set it to
+    // something else.
+    TimeZone.setDefault(TimeZone.getTimeZone("America/Los_Angeles"));
+  }
+
+  @After
+  public void tearDown() throws Exception {
+    TimeZone.setDefault(originalDefault);
+  }
+
+  @Test public void parseStandardFormats() throws Exception {
+    // RFC 822, updated by RFC 1123 with GMT.
+    assertEquals(0L, HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT").getTime());
+    assertEquals(1402057830000L, HttpDate.parse("Fri, 06 Jun 2014 12:30:30 GMT").getTime());
+
+    // RFC 850, obsoleted by RFC 1036 with GMT.
+    assertEquals(0L, HttpDate.parse("Thursday, 01-Jan-70 00:00:00 GMT").getTime());
+    assertEquals(1402057830000L, HttpDate.parse("Friday, 06-Jun-14 12:30:30 GMT").getTime());
+
+    // ANSI C's asctime(): should use GMT, not platform default.
+    assertEquals(0L, HttpDate.parse("Thu Jan 1 00:00:00 1970").getTime());
+    assertEquals(1402057830000L, HttpDate.parse("Fri Jun 6 12:30:30 2014").getTime());
+  }
+
+  @Test public void format() throws Exception {
+    assertEquals("Thu, 01 Jan 1970 00:00:00 GMT", HttpDate.format(new Date(0)));
+    assertEquals("Fri, 06 Jun 2014 12:30:30 GMT", HttpDate.format(new Date(1402057830000L)));
+  }
+
+  @Test public void parseNonStandardStrings() throws Exception {
+    // RFC 822, updated by RFC 1123 with any TZ
+    assertEquals(3600000L, HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT-01:00").getTime());
+    assertEquals(28800000L, HttpDate.parse("Thu, 01 Jan 1970 00:00:00 PST").getTime());
+    // Ignore trailing junk
+    assertEquals(0L, HttpDate.parse("Thu, 01 Jan 1970 00:00:00 GMT JUNK").getTime());
+    // Missing timezones treated as bad.
+    assertNull(HttpDate.parse("Thu, 01 Jan 1970 00:00:00"));
+    // Missing seconds treated as bad.
+    assertNull(HttpDate.parse("Thu, 01 Jan 1970 00:00 GMT"));
+    // Extra spaces treated as bad.
+    assertNull(HttpDate.parse("Thu,  01 Jan 1970 00:00 GMT"));
+    // Missing leading zero treated as bad.
+    assertNull(HttpDate.parse("Thu, 1 Jan 1970 00:00 GMT"));
+
+    // RFC 850, obsoleted by RFC 1036 with any TZ.
+    assertEquals(3600000L, HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 GMT-01:00").getTime());
+    assertEquals(28800000L, HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 PST").getTime());
+    // Ignore trailing junk
+    assertEquals(28800000L, HttpDate.parse("Thursday, 01-Jan-1970 00:00:00 PST JUNK").getTime());
+
+    // ANSI C's asctime() format
+    // This format ignores the timezone entirely even if it is present and uses GMT.
+    assertEquals(1402057830000L, HttpDate.parse("Fri Jun 6 12:30:30 2014 PST").getTime());
+    // Ignore trailing junk.
+    assertEquals(1402057830000L, HttpDate.parse("Fri Jun 6 12:30:30 2014 JUNK").getTime());
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft10Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft13Test.java
similarity index 96%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft10Test.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft13Test.java
index 0a3fee8e9c..b78fd10426 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft10Test.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft13Test.java
@@ -24,9 +24,9 @@
 
 import static org.junit.Assert.assertEquals;
 
-public class HttpOverHttp20Draft10Test extends HttpOverSpdyTest {
+public class HttpOverHttp20Draft13Test extends HttpOverSpdyTest {
 
-  public HttpOverHttp20Draft10Test() {
+  public HttpOverHttp20Draft13Test() {
     super(Protocol.HTTP_2);
     this.hostHeader = ":authority";
   }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
index ceb149eed0..f65d141bca 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
@@ -17,6 +17,7 @@
 
 import com.squareup.okhttp.Cache;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.RecordingAuthenticator;
 import com.squareup.okhttp.internal.SslContextBuilder;
@@ -80,15 +81,15 @@ public boolean verify(String hostname, SSLSession session) {
   private static final SSLContext sslContext = SslContextBuilder.localhost();
   protected final MockWebServer server = new MockWebServer();
   protected final String hostName = server.getHostName();
-  protected final OkHttpClient client = new OkHttpClient();
+  protected final OkUrlFactory client = new OkUrlFactory(new OkHttpClient());
   protected HttpURLConnection connection;
   protected Cache cache;
 
   @Before public void setUp() throws Exception {
     server.useHttps(sslContext.getSocketFactory(), false);
-    client.setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    client.client().setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     String systemTmpDir = System.getProperty("java.io.tmpdir");
     File cacheDir = new File(systemTmpDir, "HttpCache-" + protocol + "-" + UUID.randomUUID());
     cache = new Cache(cacheDir, Integer.MAX_VALUE);
@@ -331,7 +332,7 @@ public boolean verify(String hostname, SSLSession session) {
       readAscii(connection.getInputStream(), Integer.MAX_VALUE);
       fail("Should have timed out!");
     } catch (IOException e){
-      assertEquals("Read timed out", e.getMessage());
+      assertEquals("timeout", e.getMessage());
     }
   }
 
@@ -351,7 +352,7 @@ public boolean verify(String hostname, SSLSession session) {
   }
 
   @Test public void responsesAreCached() throws IOException {
-    client.setCache(cache);
+    client.client().setCache(cache);
 
     server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("A"));
     server.play();
@@ -368,7 +369,7 @@ public boolean verify(String hostname, SSLSession session) {
   }
 
   @Test public void conditionalCache() throws IOException {
-    client.setCache(cache);
+    client.client().setCache(cache);
 
     server.enqueue(new MockResponse().addHeader("ETag: v1").setBody("A"));
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
@@ -385,7 +386,7 @@ public boolean verify(String hostname, SSLSession session) {
   }
 
   @Test public void responseCachedWithoutConsumingFullBody() throws IOException {
-    client.setCache(cache);
+    client.client().setCache(cache);
 
     server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("ABCD"));
     server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("EFGH"));
@@ -404,7 +405,7 @@ public boolean verify(String hostname, SSLSession session) {
 
   @Test public void acceptAndTransmitCookies() throws Exception {
     CookieManager cookieManager = new CookieManager();
-    client.setCookieHandler(cookieManager);
+    client.client().setCookieHandler(cookieManager);
     server.enqueue(
         new MockResponse().addHeader("set-cookie: c=oreo; domain=" + server.getCookieDomain())
             .setBody("A"));
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RecordingProxySelector.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RecordingProxySelector.java
new file mode 100644
index 0000000000..ed9cfa4ba9
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RecordingProxySelector.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.net.ProxySelector;
+import java.net.SocketAddress;
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+
+public final class RecordingProxySelector extends ProxySelector {
+  final List<URI> requestedUris = new ArrayList<>();
+  List<Proxy> proxies = new ArrayList<>();
+  final List<String> failures = new ArrayList<>();
+
+  @Override public List<Proxy> select(URI uri) {
+    requestedUris.add(uri);
+    return proxies;
+  }
+
+  public void assertRequests(URI... expectedUris) {
+    assertEquals(Arrays.asList(expectedUris), requestedUris);
+    requestedUris.clear();
+  }
+
+  @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
+    InetSocketAddress socketAddress = (InetSocketAddress) sa;
+    failures.add(
+        String.format("%s %s:%d %s", uri, socketAddress.getHostName(), socketAddress.getPort(),
+            ioe.getMessage()));
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
index 5f437030ef..0284c6242e 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
@@ -16,21 +16,20 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.Address;
+import com.squareup.okhttp.Authenticator;
 import com.squareup.okhttp.Connection;
 import com.squareup.okhttp.ConnectionPool;
-import com.squareup.okhttp.OkAuthenticator;
+import com.squareup.okhttp.HostResolver;
+import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.RouteDatabase;
-import com.squareup.okhttp.internal.Dns;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.internal.Internal;
+import com.squareup.okhttp.internal.RouteDatabase;
 import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.huc.AuthenticatorAdapter;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.Proxy;
-import java.net.ProxySelector;
-import java.net.SocketAddress;
-import java.net.URI;
 import java.net.UnknownHostException;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -42,6 +41,7 @@
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLSocketFactory;
+import org.junit.Before;
 import org.junit.Test;
 
 import static com.squareup.okhttp.internal.http.RouteSelector.SSL_V3;
@@ -61,86 +61,95 @@
   private static final String proxyBHost = "proxyB";
   private static final Proxy proxyB =
       new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyBHost, proxyBPort));
-  private static final URI uri;
-  private static final String uriHost = "hostA";
-  private static final int uriPort = 80;
+  private String uriHost = "hostA";
+  private int uriPort = 1003;
 
-  private static final SocketFactory socketFactory;
-  private static final SSLContext sslContext = SslContextBuilder.localhost();
-  private static final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
-  private static final HostnameVerifier hostnameVerifier;
-  private static final ConnectionPool pool;
+  private SocketFactory socketFactory;
+  private final SSLContext sslContext = SslContextBuilder.localhost();
+  private final SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
+  private HostnameVerifier hostnameVerifier;
 
-  static {
-    try {
-      uri = new URI("http://" + uriHost + ":" + uriPort + "/path");
-      socketFactory = SocketFactory.getDefault();
-      pool = ConnectionPool.getDefault();
-      hostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();
-    } catch (Exception e) {
-      throw new AssertionError(e);
-    }
-  }
-
-  private final OkAuthenticator authenticator = AuthenticatorAdapter.INSTANCE;
+  private final Authenticator authenticator = AuthenticatorAdapter.INSTANCE;
   private final List<Protocol> protocols = Arrays.asList(Protocol.HTTP_1_1);
   private final FakeDns dns = new FakeDns();
-  private final FakeProxySelector proxySelector = new FakeProxySelector();
+  private final RecordingProxySelector proxySelector = new RecordingProxySelector();
+  private OkHttpClient client;
+  private RouteDatabase routeDatabase;
+  private Request httpRequest;
+  private Request httpsRequest;
+
+  @Before public void setUp() throws Exception {
+    socketFactory = SocketFactory.getDefault();
+    hostnameVerifier = HttpsURLConnection.getDefaultHostnameVerifier();
+
+    client = new OkHttpClient()
+        .setAuthenticator(authenticator)
+        .setProxySelector(proxySelector)
+        .setSocketFactory(socketFactory)
+        .setSslSocketFactory(sslSocketFactory)
+        .setHostnameVerifier(hostnameVerifier)
+        .setProtocols(protocols)
+        .setConnectionPool(ConnectionPool.getDefault())
+        .setHostResolver(dns);
+    routeDatabase = Internal.instance.routeDatabase(client);
+
+    httpRequest = new Request.Builder()
+        .url("http://" + uriHost + ":" + uriPort + "/path")
+        .build();
+    httpsRequest = new Request.Builder()
+        .url("https://" + uriHost + ":" + uriPort + "/path")
+        .build();
+  }
 
   @Test public void singleRoute() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, null, null, authenticator, null,
-        protocols);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
+    Address address = httpAddress();
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        SSL_V3);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+        uriPort, SSL_V3);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
     try {
-      routeSelector.next("GET");
+      routeSelector.nextUnconnected();
       fail();
     } catch (NoSuchElementException expected) {
     }
   }
 
   @Test public void singleRouteReturnsFailedRoute() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, null, null, authenticator, null,
-        protocols);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
+    Address address = httpAddress();
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    Connection connection = routeSelector.next("GET");
-    RouteDatabase routeDatabase = new RouteDatabase();
+    Connection connection = routeSelector.nextUnconnected();
     routeDatabase.failed(connection.getRoute());
-    routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns, routeDatabase);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        SSL_V3);
+    routeSelector = RouteSelector.get(httpRequest, client);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+        uriPort, SSL_V3);
     assertFalse(routeSelector.hasNext());
     try {
-      routeSelector.next("GET");
+      routeSelector.nextUnconnected();
       fail();
     } catch (NoSuchElementException expected) {
     }
   }
 
-  @Test public void explicitProxyTriesThatProxiesAddressesOnly() throws Exception {
+  @Test public void explicitProxyTriesThatProxysAddressesOnly() throws Exception {
     Address address = new Address(uriHost, uriPort, socketFactory, null, null, authenticator,
         proxyA, protocols);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
+    client.setProxy(proxyA);
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[0], proxyAPort,
-        SSL_V3);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[1], proxyAPort,
-        SSL_V3);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[0],
+        proxyAPort, SSL_V3);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[1],
+        proxyAPort, SSL_V3);
 
     assertFalse(routeSelector.hasNext());
     dns.assertRequests(proxyAHost);
@@ -150,87 +159,81 @@
   @Test public void explicitDirectProxy() throws Exception {
     Address address = new Address(uriHost, uriPort, socketFactory, null, null, authenticator,
         NO_PROXY, protocols);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
+    client.setProxy(NO_PROXY);
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        SSL_V3);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[1], uriPort,
-        SSL_V3);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+        uriPort, SSL_V3);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[1],
+        uriPort, SSL_V3);
 
     assertFalse(routeSelector.hasNext());
-    dns.assertRequests(uri.getHost());
+    dns.assertRequests(uriHost);
     proxySelector.assertRequests(); // No proxy selector requests!
   }
 
   @Test public void proxySelectorReturnsNull() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, null, null, authenticator, null,
-        protocols);
+    Address address = httpAddress();
 
     proxySelector.proxies = null;
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-    proxySelector.assertRequests(uri);
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
+    proxySelector.assertRequests(httpRequest.uri());
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        SSL_V3);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+        uriPort, SSL_V3);
     dns.assertRequests(uriHost);
 
     assertFalse(routeSelector.hasNext());
   }
 
   @Test public void proxySelectorReturnsNoProxies() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, null, null, authenticator, null,
-        protocols);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
+    Address address = httpAddress();
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        SSL_V3);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[1], uriPort,
-        SSL_V3);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+        uriPort, SSL_V3);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[1],
+        uriPort, SSL_V3);
 
     assertFalse(routeSelector.hasNext());
-    dns.assertRequests(uri.getHost());
-    proxySelector.assertRequests(uri);
+    dns.assertRequests(uriHost);
+    proxySelector.assertRequests(httpRequest.uri());
   }
 
   @Test public void proxySelectorReturnsMultipleProxies() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, null, null, authenticator, null,
-        protocols);
+    Address address = httpAddress();
 
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-    proxySelector.assertRequests(uri);
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
+    proxySelector.assertRequests(httpRequest.uri());
 
     // First try the IP addresses of the first proxy, in sequence.
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[0], proxyAPort,
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[0], proxyAPort,
         SSL_V3);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[1], proxyAPort,
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[1], proxyAPort,
         SSL_V3);
     dns.assertRequests(proxyAHost);
 
     // Next try the IP address of the second proxy.
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(254, 1);
-    assertConnection(routeSelector.next("GET"), address, proxyB, dns.inetAddresses[0], proxyBPort,
+    assertConnection(routeSelector.nextUnconnected(), address, proxyB, dns.inetAddresses[0], proxyBPort,
         SSL_V3);
     dns.assertRequests(proxyBHost);
 
     // Finally try the only IP address of the origin server.
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(253, 1);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0], uriPort,
         SSL_V3);
     dns.assertRequests(uriHost);
 
@@ -238,18 +241,16 @@
   }
 
   @Test public void proxySelectorDirectConnectionsAreSkipped() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, null, null, authenticator, null,
-        protocols);
+    Address address = httpAddress();
 
     proxySelector.proxies.add(NO_PROXY);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-    proxySelector.assertRequests(uri);
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
+    proxySelector.assertRequests(httpRequest.uri());
 
     // Only the origin server will be attempted.
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0], uriPort,
         SSL_V3);
     dns.assertRequests(uriHost);
 
@@ -257,26 +258,24 @@
   }
 
   @Test public void proxyDnsFailureContinuesToNextProxy() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, null, null, authenticator, null,
-        protocols);
+    Address address = httpAddress();
 
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
     proxySelector.proxies.add(proxyA);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
-    proxySelector.assertRequests(uri);
+    RouteSelector routeSelector = RouteSelector.get(httpRequest, client);
+    proxySelector.assertRequests(httpRequest.uri());
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[0], proxyAPort,
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[0], proxyAPort,
         SSL_V3);
     dns.assertRequests(proxyAHost);
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = null;
     try {
-      routeSelector.next("GET");
+      routeSelector.nextUnconnected();
       fail();
     } catch (UnknownHostException expected) {
     }
@@ -284,13 +283,13 @@
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[0], proxyAPort,
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[0], proxyAPort,
         SSL_V3);
     dns.assertRequests(proxyAHost);
 
     assertTrue(routeSelector.hasNext());
     dns.inetAddresses = makeFakeAddresses(254, 1);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0], uriPort,
         SSL_V3);
     dns.assertRequests(uriHost);
 
@@ -299,28 +298,22 @@
 
   // https://github.com/square/okhttp/issues/442
   @Test public void nonSslErrorAddsAllTlsModesToFailedRoute() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, sslSocketFactory,
-        hostnameVerifier, authenticator, Proxy.NO_PROXY, protocols);
-    RouteDatabase routeDatabase = new RouteDatabase();
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        routeDatabase);
+    client.setProxy(Proxy.NO_PROXY);
+    RouteSelector routeSelector = RouteSelector.get(httpsRequest, client);
 
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    Connection connection = routeSelector.next("GET");
+    Connection connection = routeSelector.nextUnconnected();
     routeSelector.connectFailed(connection, new IOException("Non SSL exception"));
     assertTrue(routeDatabase.failedRoutesCount() == 2);
     assertFalse(routeSelector.hasNext());
   }
 
   @Test public void sslErrorAddsOnlyFailedTlsModeToFailedRoute() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, sslSocketFactory,
-        hostnameVerifier, authenticator, Proxy.NO_PROXY, protocols);
-    RouteDatabase routeDatabase = new RouteDatabase();
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        routeDatabase);
+    client.setProxy(Proxy.NO_PROXY);
+    RouteSelector routeSelector = RouteSelector.get(httpsRequest, client);
 
     dns.inetAddresses = makeFakeAddresses(255, 1);
-    Connection connection = routeSelector.next("GET");
+    Connection connection = routeSelector.nextUnconnected();
     routeSelector.connectFailed(connection, new SSLHandshakeException("SSL exception"));
     assertTrue(routeDatabase.failedRoutesCount() == 1);
     assertTrue(routeSelector.hasNext());
@@ -331,61 +324,57 @@
         hostnameVerifier, authenticator, null, protocols);
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        new RouteDatabase());
+    RouteSelector routeSelector = RouteSelector.get(httpsRequest, client);
 
     // Proxy A
     dns.inetAddresses = makeFakeAddresses(255, 2);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[0], proxyAPort,
-        TLS_V1);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[0],
+        proxyAPort, TLS_V1);
     dns.assertRequests(proxyAHost);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[0], proxyAPort,
-        SSL_V3);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[1], proxyAPort,
-        TLS_V1);
-    assertConnection(routeSelector.next("GET"), address, proxyA, dns.inetAddresses[1], proxyAPort,
-        SSL_V3);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[0],
+        proxyAPort, SSL_V3);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[1],
+        proxyAPort, TLS_V1);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyA, dns.inetAddresses[1],
+        proxyAPort, SSL_V3);
 
     // Proxy B
     dns.inetAddresses = makeFakeAddresses(254, 2);
-    assertConnection(routeSelector.next("GET"), address, proxyB, dns.inetAddresses[0], proxyBPort,
-        TLS_V1);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyB, dns.inetAddresses[0],
+        proxyBPort, TLS_V1);
     dns.assertRequests(proxyBHost);
-    assertConnection(routeSelector.next("GET"), address, proxyB, dns.inetAddresses[0], proxyBPort,
-        SSL_V3);
-    assertConnection(routeSelector.next("GET"), address, proxyB, dns.inetAddresses[1], proxyBPort,
-        TLS_V1);
-    assertConnection(routeSelector.next("GET"), address, proxyB, dns.inetAddresses[1], proxyBPort,
-        SSL_V3);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyB, dns.inetAddresses[0],
+        proxyBPort, SSL_V3);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyB, dns.inetAddresses[1],
+        proxyBPort, TLS_V1);
+    assertConnection(routeSelector.nextUnconnected(), address, proxyB, dns.inetAddresses[1],
+        proxyBPort, SSL_V3);
 
     // Origin
     dns.inetAddresses = makeFakeAddresses(253, 2);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        TLS_V1);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+        uriPort, TLS_V1);
     dns.assertRequests(uriHost);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[0], uriPort,
-        SSL_V3);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[1], uriPort,
-        TLS_V1);
-    assertConnection(routeSelector.next("GET"), address, NO_PROXY, dns.inetAddresses[1], uriPort,
-        SSL_V3);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[0],
+        uriPort, SSL_V3);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[1],
+        uriPort, TLS_V1);
+    assertConnection(routeSelector.nextUnconnected(), address, NO_PROXY, dns.inetAddresses[1],
+        uriPort, SSL_V3);
 
     assertFalse(routeSelector.hasNext());
   }
 
   @Test public void failedRoutesAreLast() throws Exception {
-    Address address = new Address(uriHost, uriPort, socketFactory, sslSocketFactory,
-        hostnameVerifier, authenticator, Proxy.NO_PROXY, protocols);
+    client.setProxy(Proxy.NO_PROXY);
+    RouteSelector routeSelector = RouteSelector.get(httpsRequest, client);
 
-    RouteDatabase routeDatabase = new RouteDatabase();
-    RouteSelector routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns,
-        routeDatabase);
     dns.inetAddresses = makeFakeAddresses(255, 1);
 
     // Extract the regular sequence of routes from selector.
-    List<Connection> regularRoutes = new ArrayList<Connection>();
+    List<Connection> regularRoutes = new ArrayList<>();
     while (routeSelector.hasNext()) {
-      regularRoutes.add(routeSelector.next("GET"));
+      regularRoutes.add(routeSelector.nextUnconnected());
     }
 
     // Check that we do indeed have more than one route.
@@ -393,11 +382,11 @@
     // Add first regular route as failed.
     routeDatabase.failed(regularRoutes.get(0).getRoute());
     // Reset selector
-    routeSelector = new RouteSelector(address, uri, proxySelector, pool, dns, routeDatabase);
+    routeSelector = RouteSelector.get(httpsRequest, client);
 
-    List<Connection> routesWithFailedRoute = new ArrayList<Connection>();
+    List<Connection> routesWithFailedRoute = new ArrayList<>();
     while (routeSelector.hasNext()) {
-      routesWithFailedRoute.add(routeSelector.next("GET"));
+      routesWithFailedRoute.add(routeSelector.nextUnconnected());
     }
 
     assertEquals(regularRoutes.get(0).getRoute(),
@@ -414,6 +403,11 @@ private void assertConnection(Connection connection, Address address, Proxy prox
     assertEquals(tlsVersion, connection.getRoute().getTlsVersion());
   }
 
+  /** Returns an address that's without an SSL socket factory or hostname verifier. */
+  private Address httpAddress() {
+    return new Address(uriHost, uriPort, socketFactory, null, null, authenticator, null, protocols);
+  }
+
   private static InetAddress[] makeFakeAddresses(int prefix, int count) {
     try {
       InetAddress[] result = new InetAddress[count];
@@ -427,8 +421,8 @@ private void assertConnection(Connection connection, Address address, Proxy prox
     }
   }
 
-  private static class FakeDns implements Dns {
-    List<String> requestedHosts = new ArrayList<String>();
+  private static class FakeDns implements HostResolver {
+    List<String> requestedHosts = new ArrayList<>();
     InetAddress[] inetAddresses;
 
     @Override public InetAddress[] getAllByName(String host) throws UnknownHostException {
@@ -442,27 +436,4 @@ public void assertRequests(String... expectedHosts) {
       requestedHosts.clear();
     }
   }
-
-  private static class FakeProxySelector extends ProxySelector {
-    List<URI> requestedUris = new ArrayList<URI>();
-    List<Proxy> proxies = new ArrayList<Proxy>();
-    List<String> failures = new ArrayList<String>();
-
-    @Override public List<Proxy> select(URI uri) {
-      requestedUris.add(uri);
-      return proxies;
-    }
-
-    public void assertRequests(URI... expectedUris) {
-      assertEquals(Arrays.asList(expectedUris), requestedUris);
-      requestedUris.clear();
-    }
-
-    @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
-      InetSocketAddress socketAddress = (InetSocketAddress) sa;
-      failures.add(
-          String.format("%s %s:%d %s", uri, socketAddress.getHostName(), socketAddress.getPort(),
-              ioe.getMessage()));
-    }
-  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ThreadInterruptTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ThreadInterruptTest.java
index bbb7715f1f..6a64034b7c 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ThreadInterruptTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ThreadInterruptTest.java
@@ -16,6 +16,7 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import java.io.InputStream;
@@ -40,7 +41,7 @@
 
     interruptLater(500);
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
     connection.setDoOutput(true);
     connection.setFixedLengthStreamingMode(requestBodySize);
     OutputStream requestBody = connection.getOutputStream();
@@ -67,7 +68,7 @@
 
     interruptLater(500);
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    HttpURLConnection connection = new OkUrlFactory(client).open(server.getUrl("/"));
     InputStream responseBody = connection.getInputStream();
     byte[] buffer = new byte[1024];
     try {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index 0161da4ba1..4ccd56abd1 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -18,16 +18,20 @@
 
 import com.squareup.okhttp.AbstractResponseCache;
 import com.squareup.okhttp.Cache;
+import com.squareup.okhttp.Challenge;
 import com.squareup.okhttp.ConnectionPool;
 import com.squareup.okhttp.Credentials;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
 import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.RecordingAuthenticator;
 import com.squareup.okhttp.internal.RecordingHostnameVerifier;
 import com.squareup.okhttp.internal.RecordingOkAuthenticator;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.huc.CacheAdapter;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
@@ -45,6 +49,7 @@
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.ProxySelector;
+import java.net.Socket;
 import java.net.SocketAddress;
 import java.net.URI;
 import java.net.URL;
@@ -65,6 +70,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.zip.GZIPInputStream;
+import javax.net.SocketFactory;
 import javax.net.ssl.HttpsURLConnection;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLException;
@@ -104,7 +110,7 @@
   private MockWebServer server = new MockWebServer();
   private MockWebServer server2 = new MockWebServer();
 
-  private final OkHttpClient client = new OkHttpClient();
+  private final OkUrlFactory client = new OkUrlFactory(new OkHttpClient());
   private HttpURLConnection connection;
   private Cache cache;
   private String hostName;
@@ -118,6 +124,7 @@
     Authenticator.setDefault(null);
     System.clearProperty("proxyHost");
     System.clearProperty("proxyPort");
+    System.clearProperty("http.agent");
     System.clearProperty("http.proxyHost");
     System.clearProperty("http.proxyPort");
     System.clearProperty("https.proxyHost");
@@ -315,7 +322,7 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
     server2.play();
     FakeProxySelector proxySelector = new FakeProxySelector();
     proxySelector.proxies.add(server2.toProxyAddress());
-    client.setProxySelector(proxySelector);
+    client.client().setProxySelector(proxySelector);
     server2.shutdown();
 
     connection = client.open(server.getUrl("/def"));
@@ -526,8 +533,8 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
     server.play();
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
     connection = client.open(server.getUrl("/foo"));
 
     assertContent("this response comes via HTTPS", connection);
@@ -541,8 +548,8 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     server.enqueue(new MockResponse());
     server.play();
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
 
     HttpsURLConnection httpsConnection = (HttpsURLConnection) client.open(server.getUrl("/foo"));
 
@@ -576,8 +583,8 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     SSLSocketFactory clientSocketFactory = sslContext.getSocketFactory();
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
-    client.setSslSocketFactory(clientSocketFactory);
-    client.setHostnameVerifier(hostnameVerifier);
+    client.client().setSslSocketFactory(clientSocketFactory);
+    client.client().setHostnameVerifier(hostnameVerifier);
     connection = client.open(server.getUrl("/"));
     assertContent("this response comes via HTTPS", connection);
 
@@ -596,12 +603,12 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     server.play();
 
     // install a custom SSL socket factory so the server can be authorized
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
     HttpURLConnection connection1 = client.open(server.getUrl("/"));
     assertContent("this response comes via HTTPS", connection1);
 
-    client.setSslSocketFactory(null);
+    client.client().setSslSocketFactory(null);
     HttpURLConnection connection2 = client.open(server.getUrl("/"));
     try {
       readAscii(connection2.getInputStream(), Integer.MAX_VALUE);
@@ -616,8 +623,8 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     server.enqueue(new MockResponse().setBody("this response comes via SSL"));
     server.play();
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
     connection = client.open(server.getUrl("/foo"));
 
     assertContent("this response comes via SSL", connection);
@@ -640,8 +647,8 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     server.enqueue(new MockResponse().setBody("def"));
     server.play();
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
 
     assertContent("abc", client.open(server.getUrl("/")));
     assertContent("def", client.open(server.getUrl("/")));
@@ -709,6 +716,48 @@ private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
     assertContent("abc", client.open(server.getUrl("/")));
   }
 
+  public void testConnectViaSocketFactory(boolean useHttps) throws IOException {
+    SocketFactory uselessSocketFactory = new SocketFactory() {
+      public Socket createSocket() { throw new IllegalArgumentException("useless"); }
+      public Socket createSocket(InetAddress host, int port) { return null; }
+      public Socket createSocket(InetAddress address, int port, InetAddress localAddress,
+          int localPort) { return null; }
+      public Socket createSocket(String host, int port) { return null; }
+      public Socket createSocket(String host, int port, InetAddress localHost, int localPort) {
+        return null;
+      }
+    };
+
+    if (useHttps) {
+      server.useHttps(sslContext.getSocketFactory(), false);
+      client.client().setSslSocketFactory(sslContext.getSocketFactory());
+      client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    }
+
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 OK"));
+    server.play();
+
+    client.client().setSocketFactory(uselessSocketFactory);
+    connection = client.open(server.getUrl("/"));
+    try {
+      connection.getResponseCode();
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+
+    client.client().setSocketFactory(SocketFactory.getDefault());
+    connection = client.open(server.getUrl("/"));
+    assertEquals(200, connection.getResponseCode());
+  }
+
+  @Test public void connectHttpViaSocketFactory() throws Exception {
+    testConnectViaSocketFactory(false);
+  }
+
+  @Test public void connectHttpsViaSocketFactory() throws Exception {
+    testConnectViaSocketFactory(true);
+  }
+
   @Test public void contentDisagreesWithChunkedHeader() throws IOException {
     MockResponse mockResponse = new MockResponse();
     mockResponse.setChunkedBody("abc", 3);
@@ -740,8 +789,8 @@ private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Ex
     server.play();
 
     URL url = server.getUrl("/foo");
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
     connection = proxyConfig.connect(server, client, url);
 
     assertContent("this response comes via HTTPS", connection);
@@ -780,8 +829,8 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
     server.play();
 
     URL url = new URL("https://android.com/foo");
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(hostnameVerifier);
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(hostnameVerifier);
     connection = proxyConfig.connect(server, client, url);
 
     assertContent("this response comes via a secure proxy", connection);
@@ -814,10 +863,10 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
       server.enqueue(response); // For the backwards-compatible SSLv3 retry
     }
     server.play();
-    client.setProxy(server.toProxyAddress());
+    client.client().setProxy(server.toProxyAddress());
 
     URL url = new URL("https://android.com/foo");
-    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
     connection = client.open(url);
 
     try {
@@ -839,7 +888,7 @@ private void initResponseCache() throws IOException {
     String tmp = System.getProperty("java.io.tmpdir");
     File cacheDir = new File(tmp, "HttpCache-" + UUID.randomUUID());
     cache = new Cache(cacheDir, Integer.MAX_VALUE);
-    client.setCache(cache);
+    client.client().setCache(cache);
   }
 
   /** Test which headers are sent unencrypted to the HTTP proxy. */
@@ -852,11 +901,11 @@ private void initResponseCache() throws IOException {
         new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("encrypted response from the origin server"));
     server.play();
-    client.setProxy(server.toProxyAddress());
+    client.client().setProxy(server.toProxyAddress());
 
     URL url = new URL("https://android.com/foo");
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(hostnameVerifier);
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(hostnameVerifier);
     connection = client.open(url);
     connection.addRequestProperty("Private", "Secret");
     connection.addRequestProperty("Proxy-Authorization", "bar");
@@ -884,11 +933,11 @@ private void initResponseCache() throws IOException {
         new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
-    client.setProxy(server.toProxyAddress());
+    client.client().setProxy(server.toProxyAddress());
 
     URL url = new URL("https://android.com/foo");
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
     connection = client.open(url);
     assertContent("A", connection);
 
@@ -914,11 +963,11 @@ private void initResponseCache() throws IOException {
         new MockResponse().setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("this response comes via a proxy"));
     server.play();
-    client.setProxy(server.toProxyAddress());
+    client.client().setProxy(server.toProxyAddress());
 
     URL url = new URL("https://android.com/foo");
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
     connection = client.open(url);
     connection.setRequestProperty("Connection", "close");
 
@@ -935,11 +984,11 @@ private void initResponseCache() throws IOException {
     server.enqueue(new MockResponse().setBody("response 1"));
     server.enqueue(new MockResponse().setBody("response 2"));
     server.play();
-    client.setProxy(server.toProxyAddress());
+    client.client().setProxy(server.toProxyAddress());
 
     URL url = new URL("https://android.com/foo");
-    client.setSslSocketFactory(socketFactory);
-    client.setHostnameVerifier(hostnameVerifier);
+    client.client().setSslSocketFactory(socketFactory);
+    client.client().setHostnameVerifier(hostnameVerifier);
     assertContent("response 1", client.open(url));
     assertContent("response 2", client.open(url));
   }
@@ -1159,8 +1208,8 @@ private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferK
       SSLSocketFactory socketFactory = sslContext.getSocketFactory();
       RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
       server.useHttps(socketFactory, false);
-      client.setSslSocketFactory(socketFactory);
-      client.setHostnameVerifier(hostnameVerifier);
+      client.client().setSslSocketFactory(socketFactory);
+      client.client().setHostnameVerifier(hostnameVerifier);
     }
 
     MockResponse responseOne = new MockResponse();
@@ -1225,11 +1274,11 @@ private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferK
 
     ConnectionPool pool = ConnectionPool.getDefault();
     pool.evictAll();
-    client.setConnectionPool(pool);
+    client.client().setConnectionPool(pool);
 
     HttpURLConnection connection = client.open(server.getUrl("/"));
     assertContent("{}", connection);
-    assertEquals(0, client.getConnectionPool().getConnectionCount());
+    assertEquals(0, client.client().getConnectionPool().getConnectionCount());
   }
 
   @Test public void earlyDisconnectDoesntHarmPoolingWithChunkedEncoding() throws Exception {
@@ -1377,7 +1426,7 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
     String call = calls.get(0);
     assertTrue(call, call.contains("host=" + url.getHost()));
     assertTrue(call, call.contains("port=" + url.getPort()));
-    assertTrue(call, call.contains("site=" + InetAddress.getAllByName(url.getHost())[0]));
+    assertTrue(call, call.contains("site=" + url.getHost()));
     assertTrue(call, call.contains("url=" + url));
     assertTrue(call, call.contains("type=" + Authenticator.RequestorType.SERVER));
     assertTrue(call, call.contains("prompt=Bar"));
@@ -1392,7 +1441,7 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
     String call = calls.get(0);
     assertTrue(call, call.contains("host=" + url.getHost()));
     assertTrue(call, call.contains("port=" + url.getPort()));
-    assertTrue(call, call.contains("site=" + InetAddress.getAllByName(url.getHost())[0]));
+    assertTrue(call, call.contains("site=" + url.getHost()));
     assertTrue(call, call.contains("url=http://android.com"));
     assertTrue(call, call.contains("type=" + Authenticator.RequestorType.PROXY));
     assertTrue(call, call.contains("prompt=Bar"));
@@ -1412,7 +1461,7 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
     server.play();
 
     if (proxy) {
-      client.setProxy(server.toProxyAddress());
+      client.client().setProxy(server.toProxyAddress());
       connection = client.open(new URL("http://android.com"));
     } else {
       connection = client.open(server.getUrl("/"));
@@ -1563,8 +1612,8 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     server.enqueue(new MockResponse().setBody("Success!"));
     server.play();
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
     connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     byte[] requestBody = { 'A', 'B', 'C', 'D' };
@@ -1656,6 +1705,39 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     }
   }
 
+  /** https://code.google.com/p/android/issues/detail?id=74026 */
+  @Test public void authenticateWithGetAndTransparentGzip() throws Exception {
+    MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate.");
+    // fail auth three times...
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(pleaseAuthenticate);
+    server.enqueue(pleaseAuthenticate);
+    // ...then succeed the fourth time
+    MockResponse successfulResponse = new MockResponse()
+        .addHeader("Content-Encoding", "gzip")
+        .setBody(gzip("Successful auth!"));
+    server.enqueue(successfulResponse);
+    server.play();
+
+    Authenticator.setDefault(new RecordingAuthenticator());
+    connection = client.open(server.getUrl("/"));
+    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+
+    // no authorization header for the first request...
+    RecordedRequest request = server.takeRequest();
+    assertContainsNoneMatching(request.getHeaders(), "Authorization: Basic .*");
+
+    // ...but the three requests that follow requests include an authorization header
+    for (int i = 0; i < 3; i++) {
+      request = server.takeRequest();
+      assertEquals("GET / HTTP/1.1", request.getRequestLine());
+      assertContains(request.getHeaders(),
+          "Authorization: Basic " + RecordingAuthenticator.BASE_64_CREDENTIALS);
+    }
+  }
+
   /** https://github.com/square/okhttp/issues/342 */
   @Test public void authenticateRealmUppercase() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(401)
@@ -1710,8 +1792,8 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
     server.enqueue(new MockResponse().setBody("This is the new location!"));
     server.play();
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
     connection = client.open(server.getUrl("/"));
     assertEquals("This is the new location!",
         readAscii(connection.getInputStream(), Integer.MAX_VALUE));
@@ -1730,9 +1812,9 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
         .setBody("This page has moved!"));
     server.play();
 
-    client.setFollowSslRedirects(false);
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setFollowSslRedirects(false);
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
     connection = client.open(server.getUrl("/"));
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
@@ -1743,7 +1825,7 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
         .setBody("This page has moved!"));
     server.play();
 
-    client.setFollowSslRedirects(false);
+    client.client().setFollowSslRedirects(false);
     connection = client.open(server.getUrl("/"));
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
@@ -1759,9 +1841,9 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
         .setBody("This page has moved!"));
     server.play();
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    client.setFollowSslRedirects(true);
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setFollowSslRedirects(true);
     HttpsURLConnection connection = (HttpsURLConnection) client.open(server.getUrl("/"));
     assertContent("This is insecure HTTP!", connection);
     assertNull(connection.getCipherSuite());
@@ -1782,9 +1864,9 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
         .setBody("This page has moved!"));
     server.play();
 
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    client.setFollowSslRedirects(true);
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setFollowSslRedirects(true);
     connection = client.open(server.getUrl("/"));
     assertContent("This is secure HTTPS!", connection);
     assertFalse(connection instanceof HttpsURLConnection);
@@ -1804,8 +1886,8 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
       server.useHttps(sslContext.getSocketFactory(), false);
       server2.useHttps(sslContext.getSocketFactory(), false);
       server2.setProtocolNegotiationEnabled(false);
-      client.setSslSocketFactory(sslContext.getSocketFactory());
-      client.setHostnameVerifier(new RecordingHostnameVerifier());
+      client.client().setSslSocketFactory(sslContext.getSocketFactory());
+      client.client().setHostnameVerifier(new RecordingHostnameVerifier());
     }
 
     server2.enqueue(new MockResponse().setBody("This is the 2nd server!"));
@@ -1836,18 +1918,18 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
 
   @Test public void redirectWithProxySelector() throws Exception {
     final List<URI> proxySelectionRequests = new ArrayList<URI>();
-    client.setProxySelector(new ProxySelector() {
+    client.client().setProxySelector(new ProxySelector() {
       @Override public List<Proxy> select(URI uri) {
         proxySelectionRequests.add(uri);
         MockWebServer proxyServer = (uri.getPort() == server.getPort()) ? server : server2;
         return Arrays.asList(proxyServer.toProxyAddress());
       }
+
       @Override public void connectFailed(URI uri, SocketAddress address, IOException failure) {
         throw new AssertionError();
       }
     });
 
-    server2 = new MockWebServer();
     server2.enqueue(new MockResponse().setBody("This is the 2nd server!"));
     server2.play();
 
@@ -1864,6 +1946,24 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
     server2.shutdown();
   }
 
+  @Test public void redirectWithAuthentication() throws Exception {
+    server2.enqueue(new MockResponse().setBody("Page 2"));
+    server2.play();
+
+    server.enqueue(new MockResponse().setResponseCode(401));
+    server.enqueue(new MockResponse().setResponseCode(302)
+        .addHeader("Location: " + server2.getUrl("/b")));
+    server.play();
+
+    client.client().setAuthenticator(
+        new RecordingOkAuthenticator(Credentials.basic("jesse", "secret")));
+    assertContent("Page 2", client.open(server.getUrl("/a")));
+
+    RecordedRequest redirectRequest = server2.takeRequest();
+    assertContainsNoneMatching(redirectRequest.getHeaders(), "Authorization.*");
+    assertEquals("/b", redirectRequest.getPath());
+  }
+
   @Test public void response300MultipleChoiceWithPost() throws Exception {
     // Chrome doesn't follow the redirect, but Firefox and the RI both do
     testResponseRedirectedWithPost(HttpURLConnection.HTTP_MULT_CHOICE, TransferKind.END_OF_STREAM);
@@ -2061,8 +2161,8 @@ private void test307Redirect(String method) throws Exception {
     SSLContext sc = SSLContext.getInstance("TLS");
     sc.init(null, new TrustManager[] { trustManager }, new java.security.SecureRandom());
 
-    client.setHostnameVerifier(hostnameVerifier);
-    client.setSslSocketFactory(sc.getSocketFactory());
+    client.client().setHostnameVerifier(hostnameVerifier);
+    client.client().setSslSocketFactory(sc.getSocketFactory());
     server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
@@ -2107,7 +2207,7 @@ private void test307Redirect(String method) throws Exception {
         .throttleBody(1, 3600, TimeUnit.SECONDS)); // Prevent the server from reading!
     server.play();
 
-    client.setWriteTimeout(500, TimeUnit.MILLISECONDS);
+    client.client().setWriteTimeout(500, TimeUnit.MILLISECONDS);
     connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     connection.setChunkedStreamingMode(0);
@@ -2329,7 +2429,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   /** Don't explode if the cache returns a null body. http://b/3373699 */
   @Test public void responseCacheReturnsNullOutputStream() throws Exception {
     final AtomicBoolean aborted = new AtomicBoolean();
-    Internal.instance.setResponseCache(client, new AbstractResponseCache() {
+    Internal.instance.setCache(client.client(), new CacheAdapter(new AbstractResponseCache() {
       @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
         return new CacheRequest() {
           @Override public void abort() {
@@ -2341,7 +2441,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
           }
         };
       }
-    });
+    }));
 
     server.enqueue(new MockResponse().setBody("abcdef"));
     server.play();
@@ -2718,18 +2818,17 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
 
     String credential = Credentials.basic("jesse", "peanutbutter");
     RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(credential);
-    client.setAuthenticator(authenticator);
+    client.client().setAuthenticator(authenticator);
     assertContent("A", client.open(server.getUrl("/private")));
 
     assertContainsNoneMatching(server.takeRequest().getHeaders(), "Authorization: .*");
     assertContains(server.takeRequest().getHeaders(),
         "Authorization: " + credential);
 
-    assertEquals(1, authenticator.calls.size());
-    String call = authenticator.calls.get(0);
-    assertTrue(call, call.contains("proxy=DIRECT"));
-    assertTrue(call, call.contains("url=" + server.getUrl("/private")));
-    assertTrue(call, call.contains("challenges=[Basic realm=\"protected area\"]"));
+    assertEquals(Proxy.NO_PROXY, authenticator.onlyProxy());
+    Response response = authenticator.onlyResponse();
+    assertEquals("/private", response.request().url().getPath());
+    assertEquals(Arrays.asList(new Challenge("Basic", "protected area")), response.challenges());
   }
   
   @Test public void customTokenAuthenticator() throws Exception {
@@ -2741,17 +2840,37 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     server.play();
 
     RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator("oauthed abc123");
-    client.setAuthenticator(authenticator);
+    client.client().setAuthenticator(authenticator);
     assertContent("A", client.open(server.getUrl("/private")));
 
     assertContainsNoneMatching(server.takeRequest().getHeaders(), "Authorization: .*");
     assertContains(server.takeRequest().getHeaders(), "Authorization: oauthed abc123");
 
-    assertEquals(1, authenticator.calls.size());
-    String call = authenticator.calls.get(0);
-    assertTrue(call, call.contains("proxy=DIRECT"));
-    assertTrue(call, call.contains("url=" + server.getUrl("/private")));
-    assertTrue(call, call.contains("challenges=[Bearer realm=\"oauthed\"]"));
+    Response response = authenticator.onlyResponse();
+    assertEquals("/private", response.request().url().getPath());
+    assertEquals(Arrays.asList(new Challenge("Bearer", "oauthed")), response.challenges());
+  }
+
+  @Test public void authenticateCallsTrackedAsRedirects() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /b"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\""));
+    server.enqueue(new MockResponse().setBody("c"));
+    server.play();
+
+    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(
+        Credentials.basic("jesse", "peanutbutter"));
+    client.client().setAuthenticator(authenticator);
+    assertContent("c", client.open(server.getUrl("/a")));
+
+    Response challengeResponse = authenticator.responses.get(0);
+    assertEquals("/b", challengeResponse.request().url().getPath());
+
+    Response redirectedBy = challengeResponse.priorResponse();
+    assertEquals("/a", redirectedBy.request().url().getPath());
   }
 
   @Test public void setsNegotiatedProtocolHeader_SPDY_3() throws Exception {
@@ -2766,7 +2885,7 @@ private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException
     enableProtocol(protocol);
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
-    client.setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
+    client.client().setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
     connection = client.open(server.getUrl("/"));
     List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
     assertEquals(Arrays.asList(protocol.toString()), protocolValues);
@@ -2835,16 +2954,31 @@ private void zeroLengthPayload(String method)
     assertEquals(0L, zeroLengthPayload.getBodySize());
   }
 
+  @Test public void unspecifiedRequestBodyContentTypeGetsDefault() throws Exception {
+    server.enqueue(new MockResponse());
+    server.play();
+
+    connection = client.open(server.getUrl("/"));
+    connection.setDoOutput(true);
+    connection.getOutputStream().write("abc".getBytes(UTF_8));
+    assertEquals(200, connection.getResponseCode());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("application/x-www-form-urlencoded", request.getHeader("Content-Type"));
+    assertEquals("3", request.getHeader("Content-Length"));
+    assertEquals("abc", request.getUtf8Body());
+  }
+
   @Test public void setProtocols() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
-    client.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    client.client().setProtocols(Arrays.asList(Protocol.HTTP_1_1));
     assertContent("A", client.open(server.getUrl("/")));
   }
 
   @Test public void setProtocolsWithoutHttp11() throws Exception {
     try {
-      client.setProtocols(Arrays.asList(Protocol.SPDY_3));
+      client.client().setProtocols(Arrays.asList(Protocol.SPDY_3));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -2852,7 +2986,7 @@ private void zeroLengthPayload(String method)
 
   @Test public void setProtocolsWithNull() throws Exception {
     try {
-      client.setProtocols(Arrays.asList(Protocol.HTTP_1_1, null));
+      client.client().setProtocols(Arrays.asList(Protocol.HTTP_1_1, null));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -2952,6 +3086,27 @@ private void zeroLengthPayload(String method)
     assertEquals("BODY", new String(request.getBody(), UTF_8));
   }
 
+  @Test public void userAgentPicksUpHttpAgentSystemProperty() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.play();
+
+    System.setProperty("http.agent", "foo");
+    assertContent("abc", client.open(server.getUrl("/")));
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("foo", request.getHeader("User-Agent"));
+  }
+
+  @Test public void userAgentDefaultsToJavaVersion() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.play();
+
+    assertContent("abc", client.open(server.getUrl("/")));
+
+    RecordedRequest request = server.takeRequest();
+    assertTrue(request.getHeader("User-Agent").startsWith("Java"));
+  }
+
   /** Returns a gzipped copy of {@code bytes}. */
   public Buffer gzip(String data) throws IOException {
     Buffer result = new Buffer();
@@ -3035,49 +3190,55 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
 
   enum ProxyConfig {
     NO_PROXY() {
-      @Override public HttpURLConnection connect(MockWebServer server, OkHttpClient client, URL url)
+      @Override public HttpURLConnection connect(
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
           throws IOException {
-        client.setProxy(Proxy.NO_PROXY);
-        return client.open(url);
+        streamHandlerFactory.client().setProxy(Proxy.NO_PROXY);
+        return streamHandlerFactory.open(url);
       }
     },
 
     CREATE_ARG() {
-      @Override public HttpURLConnection connect(MockWebServer server, OkHttpClient client, URL url)
+      @Override public HttpURLConnection connect(
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
           throws IOException {
-        client.setProxy(server.toProxyAddress());
-        return client.open(url);
+        streamHandlerFactory.client().setProxy(server.toProxyAddress());
+        return streamHandlerFactory.open(url);
       }
     },
 
     PROXY_SYSTEM_PROPERTY() {
-      @Override public HttpURLConnection connect(MockWebServer server, OkHttpClient client, URL url)
+      @Override public HttpURLConnection connect(
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
           throws IOException {
         System.setProperty("proxyHost", "localhost");
         System.setProperty("proxyPort", Integer.toString(server.getPort()));
-        return client.open(url);
+        return streamHandlerFactory.open(url);
       }
     },
 
     HTTP_PROXY_SYSTEM_PROPERTY() {
-      @Override public HttpURLConnection connect(MockWebServer server, OkHttpClient client, URL url)
+      @Override public HttpURLConnection connect(
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
           throws IOException {
         System.setProperty("http.proxyHost", "localhost");
         System.setProperty("http.proxyPort", Integer.toString(server.getPort()));
-        return client.open(url);
+        return streamHandlerFactory.open(url);
       }
     },
 
     HTTPS_PROXY_SYSTEM_PROPERTY() {
-      @Override public HttpURLConnection connect(MockWebServer server, OkHttpClient client, URL url)
+      @Override public HttpURLConnection connect(
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
           throws IOException {
         System.setProperty("https.proxyHost", "localhost");
         System.setProperty("https.proxyPort", Integer.toString(server.getPort()));
-        return client.open(url);
+        return streamHandlerFactory.open(url);
       }
     };
 
-    public abstract HttpURLConnection connect(MockWebServer server, OkHttpClient client, URL url)
+    public abstract HttpURLConnection connect(
+        MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
         throws IOException;
   }
 
@@ -3125,11 +3286,11 @@ private String certificatesToString(X509Certificate[] certificates) {
    * -Xbootclasspath/p:/tmp/alpn-boot-8.0.0.v20140317}
    */
   private void enableProtocol(Protocol protocol) {
-    client.setSslSocketFactory(sslContext.getSocketFactory());
-    client.setHostnameVerifier(new RecordingHostnameVerifier());
-    client.setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
+    client.client().setSslSocketFactory(sslContext.getSocketFactory());
+    client.client().setHostnameVerifier(new RecordingHostnameVerifier());
+    client.client().setProtocols(Arrays.asList(protocol, Protocol.HTTP_1_1));
     server.useHttps(sslContext.getSocketFactory(), false);
     server.setProtocolNegotiationEnabled(true);
-    server.setProtocols(client.getProtocols());
+    server.setProtocols(client.client().getProtocols());
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLEncodingTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLEncodingTest.java
index ab99511891..547f009b67 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLEncodingTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLEncodingTest.java
@@ -18,7 +18,9 @@
 
 import com.squareup.okhttp.AbstractResponseCache;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
 import com.squareup.okhttp.internal.Internal;
+import com.squareup.okhttp.internal.huc.CacheAdapter;
 import java.io.IOException;
 import java.net.CacheResponse;
 import java.net.HttpURLConnection;
@@ -120,19 +122,19 @@ private void testUrlToUriMapping(String string, String asAuthority, String asFil
   }
 
   private URI backdoorUrlToUri(URL url) throws Exception {
-    final AtomicReference<URI> uriReference = new AtomicReference<URI>();
+    final AtomicReference<URI> uriReference = new AtomicReference<>();
 
     OkHttpClient client = new OkHttpClient();
-    Internal.instance.setResponseCache(client, new AbstractResponseCache() {
+    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
       @Override public CacheResponse get(URI uri, String requestMethod,
           Map<String, List<String>> requestHeaders) throws IOException {
         uriReference.set(uri);
         throw new UnsupportedOperationException();
       }
-    });
+    }));
 
     try {
-      HttpURLConnection connection = client.open(url);
+      HttpURLConnection connection = new OkUrlFactory(client).open(url);
       connection.getResponseCode();
     } catch (Exception expected) {
       if (expected.getCause() instanceof URISyntaxException) {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/CacheAdapterTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/CacheAdapterTest.java
index d700789f04..270fb837ee 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/CacheAdapterTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/CacheAdapterTest.java
@@ -17,6 +17,7 @@
 
 import com.squareup.okhttp.AbstractResponseCache;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.mockwebserver.MockResponse;
@@ -94,9 +95,9 @@ public CacheResponse get(URI uri, String method, Map<String, List<String>> heade
         return null;
       }
     };
-    Internal.instance.setResponseCache(client, responseCache);
+    Internal.instance.setCache(client, new CacheAdapter(responseCache));
 
-    connection = client.open(serverUrl);
+    connection = new OkUrlFactory(client).open(serverUrl);
     connection.setRequestProperty("key1", "value1");
 
     executeGet(connection);
@@ -117,11 +118,11 @@ public CacheResponse get(URI uri, String method, Map<String, List<String>> heade
         return null;
       }
     };
-    Internal.instance.setResponseCache(client, responseCache);
+    Internal.instance.setCache(client, new CacheAdapter(responseCache));
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
 
-    connection = client.open(serverUrl);
+    connection = new OkUrlFactory(client).open(serverUrl);
     connection.setRequestProperty("key1", "value1");
 
     executeGet(connection);
@@ -159,9 +160,9 @@ public CacheResponse get(URI uri, String method, Map<String, List<String>> heade
         return null;
       }
     };
-    Internal.instance.setResponseCache(client, responseCache);
+    Internal.instance.setCache(client, new CacheAdapter(responseCache));
 
-    connection = client.open(serverUrl);
+    connection = new OkUrlFactory(client).open(serverUrl);
     connection.setRequestProperty("key", "value");
     executeGet(connection);
   }
@@ -198,9 +199,9 @@ public CacheResponse get(URI uri, String method, Map<String, List<String>> heade
         return null;
       }
     };
-    Internal.instance.setResponseCache(client, responseCache);
+    Internal.instance.setCache(client, new CacheAdapter(responseCache));
 
-    connection = client.open(serverUrl);
+    connection = new OkUrlFactory(client).open(serverUrl);
 
     executePost(connection);
   }
@@ -230,11 +231,11 @@ public CacheResponse get(URI uri, String method, Map<String, List<String>> heade
         return null;
       }
     };
-    Internal.instance.setResponseCache(client, responseCache);
+    Internal.instance.setCache(client, new CacheAdapter(responseCache));
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
 
-    connection = client.open(serverUrl);
+    connection = new OkUrlFactory(client).open(serverUrl);
     executeGet(connection);
   }
 
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/HttpUrlConnectionImplTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/HttpUrlConnectionImplTest.java
deleted file mode 100644
index 313e0d7427..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/HttpUrlConnectionImplTest.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package com.squareup.okhttp.internal.huc;
-
-import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.mockwebserver.MockResponse;
-import com.squareup.okhttp.mockwebserver.MockWebServer;
-import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
-import java.io.IOException;
-import java.net.HttpURLConnection;
-import java.net.URL;
-import org.junit.Before;
-import org.junit.Rule;
-import org.junit.Test;
-
-import static org.junit.Assert.fail;
-
-public class HttpUrlConnectionImplTest {
-  @Rule public MockWebServerRule serverRule = new MockWebServerRule();
-
-  private OkHttpClient client = new OkHttpClient();
-  private MockWebServer server;
-
-  @Before public void setUp() {
-    server = serverRule.get();
-  }
-
-  /**
-   * Response code 407 should only come from proxy servers. Android's client
-   * throws if it is sent by an origin server.
-   */
-  @Test public void originServerSends407() throws Exception {
-    server.enqueue(new MockResponse().setResponseCode(407));
-
-    URL url = server.getUrl("/");
-    HttpURLConnection conn = client.open(url);
-    try {
-      conn.getResponseCode();
-      fail();
-    } catch (IOException ignored) {
-    }
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
index 060b11a954..4a4befeb06 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/JavaApiConverterTest.java
@@ -20,9 +20,12 @@
 import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.OkUrlFactory;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseBody;
 import com.squareup.okhttp.internal.SslContextBuilder;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.mockwebserver.MockResponse;
@@ -213,7 +216,7 @@ private void testCreateOkResponseInternal(HttpURLConnectionFactory httpUrlConnec
     CacheResponse cacheResponse = new CacheResponse() {
       @Override
       public Map<String, List<String>> getHeaders() throws IOException {
-        Map<String, List<String>> headers = new HashMap<String, List<String>>();
+        Map<String, List<String>> headers = new HashMap<>();
         headers.put(null, Collections.singletonList(statusLine));
         headers.put("xyzzy", Arrays.asList("bar", "baz"));
         return headers;
@@ -248,7 +251,7 @@ public InputStream getBody() throws IOException {
     SecureCacheResponse cacheResponse = new SecureCacheResponse() {
       @Override
       public Map<String, List<String>> getHeaders() throws IOException {
-        Map<String, List<String>> headers = new HashMap<String, List<String>>();
+        Map<String, List<String>> headers = new HashMap<>();
         headers.put(null, Collections.singletonList(statusLine));
         headers.put("xyzzy", Arrays.asList("bar", "baz"));
         return headers;
@@ -320,7 +323,7 @@ public Principal getLocalPrincipal() {
   @Test public void createOkRequest_nonNullRequestHeaders() throws Exception {
     URI uri = new URI("https://foo/bar");
 
-    Map<String,List<String>> javaRequestHeaders = new HashMap<String, List<String>>();
+    Map<String,List<String>> javaRequestHeaders = new HashMap<>();
     javaRequestHeaders.put("Foo", Arrays.asList("Bar"));
     Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
     assertTrue(request.isHttps());
@@ -339,7 +342,7 @@ public Principal getLocalPrincipal() {
   @Test public void createOkRequest_nullRequestHeaderKey() throws Exception {
     URI uri = new URI("https://foo/bar");
 
-    Map<String,List<String>> javaRequestHeaders = new HashMap<String, List<String>>();
+    Map<String,List<String>> javaRequestHeaders = new HashMap<>();
     javaRequestHeaders.put(null, Arrays.asList("GET / HTTP 1.1"));
     javaRequestHeaders.put("Foo", Arrays.asList("Bar"));
     Request request = JavaApiConverter.createOkRequest(uri, "POST", javaRequestHeaders);
@@ -432,7 +435,7 @@ public Principal getLocalPrincipal() {
   }
 
   @Test public void createJavaUrlConnection_responseHeadersOk() throws Exception {
-    Response.Body responseBody = createResponseBody("BodyText");
+    ResponseBody responseBody = createResponseBody("BodyText");
     Response okResponse = new Response.Builder()
         .request(createArbitraryOkRequest())
         .protocol(Protocol.HTTP_1_1)
@@ -609,7 +612,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
             .url("http://insecure/request")
             .post(createRequestBody("RequestBody"))
             .build();
-    Response.Body responseBody = createResponseBody("ResponseBody");
+    ResponseBody responseBody = createResponseBody("ResponseBody");
     Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
         .protocol(Protocol.HTTP_1_1)
         .code(200)
@@ -633,7 +636,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
             .url("https://secure/request")
             .post(createRequestBody("RequestBody") )
             .build();
-    Response.Body responseBody = createResponseBody("ResponseBody");
+    ResponseBody responseBody = createResponseBody("ResponseBody");
     Handshake handshake = Handshake.get("SecureCipher", Arrays.<Certificate>asList(SERVER_CERT),
         Arrays.<Certificate>asList(LOCAL_CERT));
     Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
@@ -672,7 +675,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
   }
 
   @Test public void extractOkHeaders() {
-    Map<String, List<String>> javaResponseHeaders = new HashMap<String, List<String>>();
+    Map<String, List<String>> javaResponseHeaders = new HashMap<>();
     javaResponseHeaders.put(null, Arrays.asList("StatusLine"));
     javaResponseHeaders.put("key1", Arrays.asList("value1_1", "value1_2"));
     javaResponseHeaders.put("key2", Arrays.asList("value2"));
@@ -684,7 +687,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
   }
 
   @Test public void extractStatusLine() {
-    Map<String, List<String>> javaResponseHeaders = new HashMap<String, List<String>>();
+    Map<String, List<String>> javaResponseHeaders = new HashMap<>();
     javaResponseHeaders.put(null, Arrays.asList("StatusLine"));
     javaResponseHeaders.put("key1", Arrays.asList("value1_1", "value1_2"));
     javaResponseHeaders.put("key2", Arrays.asList("value2"));
@@ -724,7 +727,7 @@ private OkHttpURLConnectionFactory(OkHttpClient client) {
 
     @Override
     public HttpURLConnection open(URL serverUrl) {
-      return client.open(serverUrl);
+      return new OkUrlFactory(client).open(serverUrl);
     }
   }
 
@@ -750,7 +753,7 @@ private static X509Certificate certificate(String certificate) {
   }
 
   private static <T> Set<T> newSet(List<T> elements) {
-    return new LinkedHashSet<T>(elements);
+    return new LinkedHashSet<>(elements);
   }
 
   private static Request createArbitraryOkRequest() {
@@ -770,14 +773,14 @@ private static Response createArbitraryOkResponse() {
     return createArbitraryOkResponse(createArbitraryOkRequest());
   }
 
-  private static Request.Body createRequestBody(String bodyText) {
-    return Request.Body.create(MediaType.parse("text/plain"), bodyText);
+  private static RequestBody createRequestBody(String bodyText) {
+    return RequestBody.create(MediaType.parse("text/plain"), bodyText);
   }
 
-  private static Response.Body createResponseBody(String bodyText) {
+  private static ResponseBody createResponseBody(String bodyText) {
     final Buffer source = new Buffer().writeUtf8(bodyText);
     final long contentLength = source.size();
-    return new Response.Body() {
+    return new ResponseBody() {
       @Override public MediaType contentType() {
         return MediaType.parse("text/plain; charset=utf-8");
       }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
index 3af3b15dc8..21ad7f4991 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/huc/ResponseCacheTest.java
@@ -18,10 +18,10 @@
 
 import com.squareup.okhttp.AbstractResponseCache;
 import com.squareup.okhttp.OkHttpClient;
-import com.squareup.okhttp.ResponseSource;
+import com.squareup.okhttp.OkUrlFactory;
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.SslContextBuilder;
-import com.squareup.okhttp.internal.http.OkHeaders;
+import com.squareup.okhttp.internal.http.HttpDate;
 import com.squareup.okhttp.mockwebserver.MockResponse;
 import com.squareup.okhttp.mockwebserver.MockWebServer;
 import com.squareup.okhttp.mockwebserver.RecordedRequest;
@@ -112,7 +112,7 @@
 
     client = new OkHttpClient();
     cache = new InMemoryResponseCache();
-    ResponseCache.setDefault(cache);
+    Internal.instance.setCache(client, new CacheAdapter(cache));
   }
 
   @After public void tearDown() throws Exception {
@@ -120,20 +120,7 @@
   }
 
   private HttpURLConnection openConnection(URL url) {
-    return client.open(url);
-  }
-
-  @Test public void responseCacheAccessWithOkHttpMember() throws IOException {
-    ResponseCache.setDefault(null);
-    Internal.instance.setResponseCache(client, cache);
-    assertTrue(Internal.instance.internalCache(client) instanceof CacheAdapter);
-  }
-
-  @Test public void responseCacheAccessWithGlobalDefault() throws IOException {
-    ResponseCache.setDefault(cache);
-    Internal.instance.setResponseCache(client, null);
-    assertNull(Internal.instance.internalCache(client));
-    assertNull(client.getCache());
+    return new OkUrlFactory(client).open(url);
   }
 
   @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
@@ -215,8 +202,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse().setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
 
-    Internal.instance.setResponseCache(client,
-        new InsecureResponseCache(new InMemoryResponseCache()));
+    Internal.instance.setCache(client,
+        new CacheAdapter(new InsecureResponseCache(new InMemoryResponseCache())));
 
     HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.getUrl("/"));
     connection1.setSSLSocketFactory(sslContext.getSocketFactory());
@@ -332,13 +319,13 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
 
     final AtomicReference<Map<String, List<String>>> requestHeadersRef =
         new AtomicReference<Map<String, List<String>>>();
-    Internal.instance.setResponseCache(client, new AbstractResponseCache() {
+    Internal.instance.setCache(client, new CacheAdapter(new AbstractResponseCache() {
       @Override public CacheResponse get(URI uri, String requestMethod,
           Map<String, List<String>> requestHeaders) throws IOException {
         requestHeadersRef.set(requestHeaders);
         return null;
       }
-    });
+    }));
 
     URL url = server.getUrl("/");
     URLConnection urlConnection = openConnection(url);
@@ -925,7 +912,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     connection.setIfModifiedSince(since.getTime());
     assertEquals("A", readAscii(connection));
     RecordedRequest request = server.takeRequest();
-    assertTrue(request.getHeaders().contains("If-Modified-Since: " + formatDate(since)));
+    assertTrue(request.getHeaders().contains("If-Modified-Since: " + HttpDate.format(since)));
   }
 
   @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
@@ -1227,9 +1214,6 @@ public void assertCookies(CookieManager cookieManager, URL url, String... expect
     URLConnection connection = openConnection(server.getUrl("/"));
     connection.addRequestProperty("Cache-Control", "only-if-cached");
     assertEquals("A", readAscii(connection));
-
-    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.CACHE + " 200", source);
   }
 
   @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
@@ -1243,9 +1227,6 @@ public void assertCookies(CookieManager cookieManager, URL url, String... expect
     assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
     HttpURLConnection connection = openConnection(server.getUrl("/"));
     assertEquals("B", readAscii(connection));
-
-    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.CONDITIONAL_CACHE + " 200", source);
   }
 
   @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
@@ -1257,9 +1238,6 @@ public void assertCookies(CookieManager cookieManager, URL url, String... expect
     assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
     HttpURLConnection connection = openConnection(server.getUrl("/"));
     assertEquals("A", readAscii(connection));
-
-    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.CONDITIONAL_CACHE + " 304", source);
   }
 
   @Test public void responseSourceHeaderFetched() throws IOException {
@@ -1267,9 +1245,6 @@ public void assertCookies(CookieManager cookieManager, URL url, String... expect
 
     URLConnection connection = openConnection(server.getUrl("/"));
     assertEquals("A", readAscii(connection));
-
-    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
-    assertEquals(ResponseSource.NETWORK + " 200", source);
   }
 
   @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
@@ -1288,13 +1263,7 @@ public void assertCookies(CookieManager cookieManager, URL url, String... expect
    * future.
    */
   private String formatDate(long delta, TimeUnit timeUnit) {
-    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
-  }
-
-  private String formatDate(Date date) {
-    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
-    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
-    return rfc1123.format(date);
+    return HttpDate.format(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
   }
 
   private void addRequestBodyIfNecessary(String requestMethod, HttpURLConnection invalidate)
@@ -1414,8 +1383,6 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
     }
     assertEquals(504, connection.getResponseCode());
     assertEquals(-1, connection.getErrorStream().read());
-    assertEquals(ResponseSource.NONE + " 504",
-        connection.getHeaderField(OkHeaders.RESPONSE_SOURCE));
   }
 
   enum TransferKind {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
index 8f709220ed..d0b5e97ddb 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
@@ -30,7 +30,7 @@
 
   @Override
   public void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-      int priority, List<Header> headerBlock, HeadersMode headersMode) {
+      List<Header> headerBlock, HeadersMode headersMode) {
     fail();
   }
 
@@ -58,7 +58,8 @@ public void headers(boolean outFinished, boolean inFinished, int streamId, int a
     fail();
   }
 
-  @Override public void priority(int streamId, int priority) {
+  @Override public void priority(int streamId, int streamDependency, int weight,
+      boolean exclusive) {
     fail();
   }
 
@@ -66,4 +67,9 @@ public void headers(boolean outFinished, boolean inFinished, int streamId, int a
   public void pushPromise(int streamId, int associatedStreamId, List<Header> headerBlock) {
     fail();
   }
+
+  @Override public void alternateService(int streamId, String origin, ByteString protocol,
+      String host, int port, long maxAge) {
+    fail();
+  }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft06Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft08Test.java
similarity index 69%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft06Test.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft08Test.java
index 8c17465a8e..2b74c8df5e 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft06Test.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft08Test.java
@@ -24,28 +24,29 @@
 import org.junit.Test;
 
 import static com.squareup.okhttp.internal.Util.headerEntries;
+import static okio.ByteString.decodeHex;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-public class HpackDraft06Test {
+public class HpackDraft08Test {
 
   private final Buffer bytesIn = new Buffer();
-  private HpackDraft06.Reader hpackReader;
+  private HpackDraft08.Reader hpackReader;
   private Buffer bytesOut = new Buffer();
-  private HpackDraft06.Writer hpackWriter;
+  private HpackDraft08.Writer hpackWriter;
 
   @Before public void reset() {
     hpackReader = newReader(bytesIn);
-    hpackWriter = new HpackDraft06.Writer(bytesOut);
+    hpackWriter = new HpackDraft08.Writer(bytesOut);
   }
 
   /**
    * Variable-length quantity special cases strings which are longer than 127
    * bytes.  Values such as cookies can be 4KiB, and should be possible to send.
    *
-   * <p> http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06#section-4.1.2
+   * <p> http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08#section-4.1.1
    */
   @Test public void largeHeaderValue() throws IOException {
     char[] value = new char[4096];
@@ -67,17 +68,14 @@
    * Ensure the larger header content is not lost.
    */
   @Test public void tooLargeToHPackIsStillEmitted() throws IOException {
-    Buffer out = new Buffer();
+    bytesIn.writeByte(0x00); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
 
-    out.writeByte(0x00); // Literal indexed
-    out.writeByte(0x0a); // Literal name (len = 10)
-    out.writeUtf8("custom-key");
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
 
-    out.writeByte(0x0d); // Literal value (len = 13)
-    out.writeUtf8("custom-header");
-
-    bytesIn.writeAll(out);
-    hpackReader.maxHeaderTableByteCount(1);
+    hpackReader.maxHeaderTableByteCountSetting(1);
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -88,32 +86,29 @@
 
   /** Oldest entries are evicted to support newer ones. */
   @Test public void testEviction() throws IOException {
-    Buffer out = new Buffer();
-
-    out.writeByte(0x00); // Literal indexed
-    out.writeByte(0x0a); // Literal name (len = 10)
-    out.writeUtf8("custom-foo");
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-foo");
 
-    out.writeByte(0x0d); // Literal value (len = 13)
-    out.writeUtf8("custom-header");
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
 
-    out.writeByte(0x00); // Literal indexed
-    out.writeByte(0x0a); // Literal name (len = 10)
-    out.writeUtf8("custom-bar");
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-bar");
 
-    out.writeByte(0x0d); // Literal value (len = 13)
-    out.writeUtf8("custom-header");
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
 
-    out.writeByte(0x00); // Literal indexed
-    out.writeByte(0x0a); // Literal name (len = 10)
-    out.writeUtf8("custom-baz");
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-baz");
 
-    out.writeByte(0x0d); // Literal value (len = 13)
-    out.writeUtf8("custom-header");
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
 
-    bytesIn.writeAll(out);
     // Set to only support 110 bytes (enough for 2 headers).
-    hpackReader.maxHeaderTableByteCount(110);
+    hpackReader.maxHeaderTableByteCountSetting(110);
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -133,25 +128,22 @@
         hpackReader.getAndReset());
 
     // Simulate receiving a small settings frame, that implies eviction.
-    hpackReader.maxHeaderTableByteCount(55);
+    hpackReader.maxHeaderTableByteCountSetting(55);
     assertEquals(1, hpackReader.headerCount);
   }
 
   /** Header table backing array is initially 8 long, let's ensure it grows. */
   @Test public void dynamicallyGrowsBeyond64Entries() throws IOException {
-    Buffer out = new Buffer();
-
     for (int i = 0; i < 256; i++) {
-      out.writeByte(0x00); // Literal indexed
-      out.writeByte(0x0a); // Literal name (len = 10)
-      out.writeUtf8("custom-foo");
+      bytesIn.writeByte(0x40); // Literal indexed
+      bytesIn.writeByte(0x0a); // Literal name (len = 10)
+      bytesIn.writeUtf8("custom-foo");
 
-      out.writeByte(0x0d); // Literal value (len = 13)
-      out.writeUtf8("custom-header");
+      bytesIn.writeByte(0x0d); // Literal value (len = 13)
+      bytesIn.writeUtf8("custom-header");
     }
 
-    bytesIn.writeAll(out);
-    hpackReader.maxHeaderTableByteCount(16384); // Lots of headers need more room!
+    hpackReader.maxHeaderTableByteCountSetting(16384); // Lots of headers need more room!
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -161,19 +153,12 @@
   }
 
   @Test public void huffmanDecodingSupported() throws IOException {
-    Buffer out = new Buffer();
-
-    out.writeByte(0x04); // == Literal indexed ==
-                         // Indexed name (idx = 4) -> :path
-    out.writeByte(0x8b); // Literal value Huffman encoded 11 bytes
-                         // decodes to www.example.com which is length 15
-    byte[] huffmanBytes = new byte[] {
-        (byte) 0xdb, (byte) 0x6d, (byte) 0x88, (byte) 0x3e,
-        (byte) 0x68, (byte) 0xd1, (byte) 0xcb, (byte) 0x12,
-        (byte) 0x25, (byte) 0xba, (byte) 0x7f};
-    out.write(huffmanBytes, 0, huffmanBytes.length);
-
-    bytesIn.writeAll(out);
+    bytesIn.writeByte(0x44); // == Literal indexed ==
+                             // Indexed name (idx = 4) -> :path
+    bytesIn.writeByte(0x8c); // Literal value Huffman encoded 12 bytes
+                             // decodes to www.example.com which is length 15
+    bytesIn.write(decodeHex("f1e3c2e5f23a6ba0ab90f4ff"));
+
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -186,19 +171,16 @@
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06#appendix-D.1.1
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08#appendix-D.1.1
    */
   @Test public void readLiteralHeaderFieldWithIndexing() throws IOException {
-    Buffer out = new Buffer();
-
-    out.writeByte(0x00); // Literal indexed
-    out.writeByte(0x0a); // Literal name (len = 10)
-    out.writeUtf8("custom-key");
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
 
-    out.writeByte(0x0d); // Literal value (len = 13)
-    out.writeUtf8("custom-header");
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
 
-    bytesIn.writeAll(out);
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -213,24 +195,40 @@
   }
 
   /**
-   * Literal Header Field without Indexing - New Name
+   * https://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08#appendix-D.2.2
    */
+  @Test public void literalHeaderFieldWithoutIndexingIndexedName() throws IOException {
+    List<Header> headerBlock = headerEntries(":path", "/sample/path");
+
+    bytesIn.writeByte(0x04); // == Literal not indexed ==
+                             // Indexed name (idx = 4) -> :path
+    bytesIn.writeByte(0x0c); // Literal value (len = 12)
+    bytesIn.writeUtf8("/sample/path");
+
+    hpackWriter.writeHeaders(headerBlock);
+    assertEquals(bytesIn, bytesOut);
+
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndReset());
+  }
+
   @Test public void literalHeaderFieldWithoutIndexingNewName() throws IOException {
     List<Header> headerBlock = headerEntries("custom-key", "custom-header");
 
-    Buffer expectedBytes = new Buffer();
+    bytesIn.writeByte(0x00); // Not indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
 
-    expectedBytes.writeByte(0x40); // Not indexed
-    expectedBytes.writeByte(0x0a); // Literal name (len = 10)
-    expectedBytes.write("custom-key".getBytes(), 0, 10);
-
-    expectedBytes.writeByte(0x0d); // Literal value (len = 13)
-    expectedBytes.write("custom-header".getBytes(), 0, 13);
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
 
     hpackWriter.writeHeaders(headerBlock);
-    assertEquals(expectedBytes, bytesOut);
+    assertEquals(bytesIn, bytesOut);
 
-    bytesIn.writeAll(bytesOut);
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -239,32 +237,38 @@
     assertEquals(headerBlock, hpackReader.getAndReset());
   }
 
-  /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06#appendix-D.1.2
-   */
-  @Test public void literalHeaderFieldWithoutIndexingIndexedName() throws IOException {
-    List<Header> headerBlock = headerEntries(":path", "/sample/path");
+  @Test public void literalHeaderFieldNeverIndexedIndexedName() throws IOException {
+    bytesIn.writeByte(0x14); // == Literal never indexed ==
+                             // Indexed name (idx = 4) -> :path
+    bytesIn.writeByte(0x0c); // Literal value (len = 12)
+    bytesIn.writeUtf8("/sample/path");
 
-    Buffer expectedBytes = new Buffer();
-    expectedBytes.writeByte(0x44); // == Literal not indexed ==
-                                   // Indexed name (idx = 4) -> :path
-    expectedBytes.writeByte(0x0c); // Literal value (len = 12)
-    expectedBytes.write("/sample/path".getBytes(), 0, 12);
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
 
-    hpackWriter.writeHeaders(headerBlock);
-    assertEquals(expectedBytes, bytesOut);
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerEntries(":path", "/sample/path"), hpackReader.getAndReset());
+  }
+
+  @Test public void literalHeaderFieldNeverIndexedNewName() throws IOException {
+    bytesIn.writeByte(0x10); // Never indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+
+    bytesIn.writeByte(0x0d); // Literal value (len = 13)
+    bytesIn.writeUtf8("custom-header");
 
-    bytesIn.writeAll(bytesOut);
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
     assertEquals(0, hpackReader.headerCount);
 
-    assertEquals(headerBlock, hpackReader.getAndReset());
+    assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndReset());
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06#appendix-D.1.3
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08#appendix-D.1.3
    */
   @Test public void readIndexedHeaderField() throws IOException {
     bytesIn.writeByte(0x82); // == Indexed - Add ==
@@ -283,10 +287,21 @@
     assertEquals(headerEntries(":method", "GET"), hpackReader.getAndReset());
   }
 
+  // Example taken from twitter/hpack DecoderTest.testUnusedIndex
+  @Test public void readIndexedHeaderFieldIndex0() throws IOException {
+    bytesIn.writeByte(0x80); // == Indexed - Add idx = 0
+
+    try {
+      hpackReader.readHeaders();
+      fail();
+    } catch (IOException e) {
+      assertEquals("index == 0", e.getMessage());
+    }
+  }
+
   // Example taken from twitter/hpack DecoderTest.testIllegalIndex
   @Test public void readIndexedHeaderFieldTooLargeIndex() throws IOException {
-    bytesIn.writeByte(0xff); // == Indexed - Add ==
-    bytesIn.writeByte(0x00); // idx = 127
+    bytesIn.writeShort(0xff00); // == Indexed - Add idx = 127
 
     try {
       hpackReader.readHeaders();
@@ -299,11 +314,7 @@
   // Example taken from twitter/hpack DecoderTest.testInsidiousIndex
   @Test public void readIndexedHeaderFieldInsidiousIndex() throws IOException {
     bytesIn.writeByte(0xff); // == Indexed - Add ==
-    bytesIn.writeByte(0x80); // idx = -2147483521
-    bytesIn.writeByte(0x80);
-    bytesIn.writeByte(0x80);
-    bytesIn.writeByte(0x80);
-    bytesIn.writeByte(0x08);
+    bytesIn.write(decodeHex("8080808008")); // idx = -2147483521
 
     try {
       hpackReader.readHeaders();
@@ -315,37 +326,60 @@
 
   // Example taken from twitter/hpack DecoderTest.testIllegalEncodeContextUpdate
   @Test public void readHeaderTableStateChangeInvalid() throws IOException {
-    bytesIn.writeByte(0x80); // header table state change
-    bytesIn.writeByte(0x81); // should be 0x80 for empty!
+    bytesIn.writeByte(0x31); // header table state should be 0x30 for empty!
+
+    try {
+      hpackReader.readHeaders();
+      fail();
+    } catch (IOException e) {
+      assertEquals("Invalid header table state change 49", e.getMessage());
+    }
+  }
+
+  // Example taken from twitter/hpack DecoderTest.testMaxHeaderTableSize
+  @Test public void minMaxHeaderTableSize() throws IOException {
+    bytesIn.writeByte(0x20);
+    hpackReader.readHeaders();
+
+    assertEquals(0, hpackReader.maxHeaderTableByteCount());
+
+    bytesIn.writeByte(0x2f); // encode size 4096
+    bytesIn.writeByte(0xf1);
+    bytesIn.writeByte(0x1f);
+    hpackReader.readHeaders();
+
+    assertEquals(4096, hpackReader.maxHeaderTableByteCount());
+  }
+
+  // Example taken from twitter/hpack DecoderTest.testIllegalMaxHeaderTableSize
+  @Test public void cannotSetTableSizeLargerThanSettingsValue() throws IOException {
+    bytesIn.writeByte(0x2f); // encode size 4097
+    bytesIn.writeByte(0xf2);
+    bytesIn.writeByte(0x1f);
 
     try {
       hpackReader.readHeaders();
       fail();
     } catch (IOException e) {
-      assertEquals("Invalid header table state change -127", e.getMessage());
+      assertEquals("Invalid header table byte count 4097", e.getMessage());
     }
   }
 
   // Example taken from twitter/hpack DecoderTest.testInsidiousMaxHeaderSize
   @Test public void readHeaderTableStateChangeInsidiousMaxHeaderByteCount() throws IOException {
-    bytesIn.writeByte(0x80); // header table state change
-    bytesIn.writeByte(0x7F); // encoded -1879048193
-    bytesIn.writeByte(0x80);
-    bytesIn.writeByte(0xFF);
-    bytesIn.writeByte(0xFF);
-    bytesIn.writeByte(0xFF);
-    bytesIn.writeByte(0x08);
+    bytesIn.writeByte(0x2f); // TODO: header table state change
+    bytesIn.write(decodeHex("f1ffffff07")); // count = -2147483648
 
     try {
       hpackReader.readHeaders();
       fail();
     } catch (IOException e) {
-      assertEquals("Invalid header table byte count -1879048193", e.getMessage());
+      assertEquals("Invalid header table byte count -2147483648", e.getMessage());
     }
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06#section-3.2.1
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08#section-3.2.1
    */
   @Test public void toggleIndex() throws IOException {
     // Static table entries are copied to the top of the reference set.
@@ -370,7 +404,6 @@
 
   /** Ensure a later toggle of the same index emits! */
   @Test public void toggleIndexOffOn() throws IOException {
-
     bytesIn.writeByte(0x82); // Copy static header 1 to the header table as index 1.
     bytesIn.writeByte(0x81); // Remove index 1 from the reference set.
 
@@ -411,13 +444,13 @@
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06#appendix-D.1.4
+   * https://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08#appendix-D.2.4
    */
   @Test public void readIndexedHeaderFieldFromStaticTableWithoutBuffering() throws IOException {
     bytesIn.writeByte(0x82); // == Indexed - Add ==
                              // idx = 2 -> :method: GET
 
-    hpackReader.maxHeaderTableByteCount(0); // SETTINGS_HEADER_TABLE_SIZE == 0
+    hpackReader.maxHeaderTableByteCountSetting(0); // SETTINGS_HEADER_TABLE_SIZE == 0
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -428,40 +461,36 @@
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06#appendix-D.2
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08#appendix-D.2
    */
   @Test public void readRequestExamplesWithoutHuffman() throws IOException {
-    bytesIn.writeAll(firstRequestWithoutHuffman());
+    firstRequestWithoutHuffman();
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkReadFirstRequestWithoutHuffman();
 
-    bytesIn.writeAll(secondRequestWithoutHuffman());
+    secondRequestWithoutHuffman();
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkReadSecondRequestWithoutHuffman();
 
-    bytesIn.writeAll(thirdRequestWithoutHuffman());
+    thirdRequestWithoutHuffman();
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkReadThirdRequestWithoutHuffman();
   }
 
-  private Buffer firstRequestWithoutHuffman() {
-    Buffer out = new Buffer();
-
-    out.writeByte(0x82); // == Indexed - Add ==
-                         // idx = 2 -> :method: GET
-    out.writeByte(0x87); // == Indexed - Add ==
-                         // idx = 7 -> :scheme: http
-    out.writeByte(0x86); // == Indexed - Add ==
-                         // idx = 6 -> :path: /
-    out.writeByte(0x04); // == Literal indexed ==
-                         // Indexed name (idx = 4) -> :authority
-    out.writeByte(0x0f); // Literal value (len = 15)
-    out.writeUtf8("www.example.com");
-
-    return out;
+  private void firstRequestWithoutHuffman() {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+    bytesIn.writeByte(0x87); // == Indexed - Add ==
+                             // idx = 7 -> :scheme: http
+    bytesIn.writeByte(0x86); // == Indexed - Add ==
+                             // idx = 6 -> :path: /
+    bytesIn.writeByte(0x44); // == Literal indexed ==
+                             // Indexed name (idx = 4) -> :authority
+    bytesIn.writeByte(0x0f); // Literal value (len = 15)
+    bytesIn.writeUtf8("www.example.com");
   }
 
   private void checkReadFirstRequestWithoutHuffman() {
@@ -498,15 +527,11 @@ private void checkReadFirstRequestWithoutHuffman() {
         ":authority", "www.example.com"), hpackReader.getAndReset());
   }
 
-  private Buffer secondRequestWithoutHuffman() {
-    Buffer out = new Buffer();
-
-    out.writeByte(0x1b); // == Literal indexed ==
-                         // Indexed name (idx = 27) -> cache-control
-    out.writeByte(0x08); // Literal value (len = 8)
-    out.writeUtf8("no-cache");
-
-    return out;
+  private void secondRequestWithoutHuffman() {
+    bytesIn.writeByte(0x5c); // == Literal indexed ==
+                             // Indexed name (idx = 28) -> cache-control
+    bytesIn.writeByte(0x08); // Literal value (len = 8)
+    bytesIn.writeUtf8("no-cache");
   }
 
   private void checkReadSecondRequestWithoutHuffman() {
@@ -549,26 +574,21 @@ private void checkReadSecondRequestWithoutHuffman() {
         "cache-control", "no-cache"), hpackReader.getAndReset());
   }
 
-  private Buffer thirdRequestWithoutHuffman() {
-    Buffer out = new Buffer();
-
-    out.writeByte(0x80); // == Empty reference set ==
-    out.writeByte(0x80); // idx = 0, flag = 1
-    out.writeByte(0x85); // == Indexed - Add ==
-                         // idx = 5 -> :method: GET
-    out.writeByte(0x8c); // == Indexed - Add ==
-                         // idx = 12 -> :scheme: https
-    out.writeByte(0x8b); // == Indexed - Add ==
-                         // idx = 11 -> :path: /index.html
-    out.writeByte(0x84); // == Indexed - Add ==
-                         // idx = 4 -> :authority: www.example.com
-    out.writeByte(0x00); // Literal indexed
-    out.writeByte(0x0a); // Literal name (len = 10)
-    out.writeUtf8("custom-key");
-    out.writeByte(0x0c); // Literal value (len = 12)
-    out.writeUtf8("custom-value");
-
-    return out;
+  private void thirdRequestWithoutHuffman() {
+    bytesIn.writeByte(0x30); // == Empty reference set ==
+    bytesIn.writeByte(0x85); // == Indexed - Add ==
+                             // idx = 5 -> :method: GET
+    bytesIn.writeByte(0x8c); // == Indexed - Add ==
+                             // idx = 12 -> :scheme: https
+    bytesIn.writeByte(0x8b); // == Indexed - Add ==
+                             // idx = 11 -> :path: /index.html
+    bytesIn.writeByte(0x84); // == Indexed - Add ==
+                             // idx = 4 -> :authority: www.example.com
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-key");
+    bytesIn.writeByte(0x0c); // Literal value (len = 12)
+    bytesIn.writeUtf8("custom-value");
   }
 
   private void checkReadThirdRequestWithoutHuffman() {
@@ -628,45 +648,37 @@ private void checkReadThirdRequestWithoutHuffman() {
   }
 
   /**
-   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06#appendix-D.3
+   * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08#appendix-D.3
    */
   @Test public void readRequestExamplesWithHuffman() throws IOException {
-    bytesIn.writeAll(firstRequestWithHuffman());
+    firstRequestWithHuffman();
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkReadFirstRequestWithHuffman();
 
-    bytesIn.writeAll(secondRequestWithHuffman());
+    secondRequestWithHuffman();
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkReadSecondRequestWithHuffman();
 
-    bytesIn.writeAll(thirdRequestWithHuffman());
+    thirdRequestWithHuffman();
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
     checkReadThirdRequestWithHuffman();
   }
 
-  private Buffer firstRequestWithHuffman() {
-    Buffer out = new Buffer();
-
-    out.writeByte(0x82); // == Indexed - Add ==
-                         // idx = 2 -> :method: GET
-    out.writeByte(0x87); // == Indexed - Add ==
-                         // idx = 7 -> :scheme: http
-    out.writeByte(0x86); // == Indexed - Add ==
-                         // idx = 6 -> :path: /
-    out.writeByte(0x04); // == Literal indexed ==
-                         // Indexed name (idx = 4) -> :authority
-    out.writeByte(0x8b); // Literal value Huffman encoded 11 bytes
-                         // decodes to www.example.com which is length 15
-    byte[] huffmanBytes = new byte[] {
-        (byte) 0xdb, (byte) 0x6d, (byte) 0x88, (byte) 0x3e,
-        (byte) 0x68, (byte) 0xd1, (byte) 0xcb, (byte) 0x12,
-        (byte) 0x25, (byte) 0xba, (byte) 0x7f};
-    out.write(huffmanBytes, 0, huffmanBytes.length);
-
-    return out;
+  private void firstRequestWithHuffman() {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
+    bytesIn.writeByte(0x87); // == Indexed - Add ==
+                             // idx = 7 -> :scheme: http
+    bytesIn.writeByte(0x86); // == Indexed - Add ==
+                             // idx = 6 -> :path: /
+    bytesIn.writeByte(0x44); // == Literal indexed ==
+                             // Indexed name (idx = 4) -> :authority
+    bytesIn.writeByte(0x0f); // Literal value Huffman encoded 12 bytes
+                             // decodes to www.example.com which is length 15
+    bytesIn.write(decodeHex("7777772e6578616d706c652e636f6d"));
   }
 
   private void checkReadFirstRequestWithHuffman() {
@@ -703,19 +715,12 @@ private void checkReadFirstRequestWithHuffman() {
         ":authority", "www.example.com"), hpackReader.getAndReset());
   }
 
-  private Buffer secondRequestWithHuffman() {
-    Buffer out = new Buffer();
-
-    out.writeByte(0x1b); // == Literal indexed ==
-                         // Indexed name (idx = 27) -> cache-control
-    out.writeByte(0x86); // Literal value Huffman encoded 6 bytes
-                         // decodes to no-cache which is length 8
-    byte[] huffmanBytes = new byte[] {
-        (byte) 0x63, (byte) 0x65, (byte) 0x4a, (byte) 0x13,
-        (byte) 0x98, (byte) 0xff};
-    out.write(huffmanBytes, 0, huffmanBytes.length);
-
-    return out;
+  private void secondRequestWithHuffman() {
+    bytesIn.writeByte(0x5c); // == Literal indexed ==
+                             // Indexed name (idx = 28) -> cache-control
+    bytesIn.writeByte(0x86); // Literal value Huffman encoded 6 bytes
+                             // decodes to no-cache which is length 8
+    bytesIn.write(decodeHex("a8eb10649cbf"));
   }
 
   private void checkReadSecondRequestWithHuffman() {
@@ -758,35 +763,23 @@ private void checkReadSecondRequestWithHuffman() {
         "cache-control", "no-cache"), hpackReader.getAndReset());
   }
 
-  private Buffer thirdRequestWithHuffman() {
-    Buffer out = new Buffer();
-
-    out.writeByte(0x80); // == Empty reference set ==
-    out.writeByte(0x80); // idx = 0, flag = 1
-    out.writeByte(0x85); // == Indexed - Add ==
-                         // idx = 5 -> :method: GET
-    out.writeByte(0x8c); // == Indexed - Add ==
-                         // idx = 12 -> :scheme: https
-    out.writeByte(0x8b); // == Indexed - Add ==
-                         // idx = 11 -> :path: /index.html
-    out.writeByte(0x84); // == Indexed - Add ==
-                         // idx = 4 -> :authority: www.example.com
-    out.writeByte(0x00); // Literal indexed
-    out.writeByte(0x88); // Literal name Huffman encoded 8 bytes
-                         // decodes to custom-key which is length 10
-    byte[] huffmanBytes = new byte[] {
-        (byte) 0x4e, (byte) 0xb0, (byte) 0x8b, (byte) 0x74,
-        (byte) 0x97, (byte) 0x90, (byte) 0xfa, (byte) 0x7f};
-    out.write(huffmanBytes, 0, huffmanBytes.length);
-    out.writeByte(0x89); // Literal value Huffman encoded 6 bytes
-                         // decodes to custom-value which is length 12
-    huffmanBytes = new byte[] {
-        (byte) 0x4e, (byte) 0xb0, (byte) 0x8b, (byte) 0x74,
-        (byte) 0x97, (byte) 0x9a, (byte) 0x17, (byte) 0xa8,
-        (byte) 0xff};
-    out.write(huffmanBytes, 0, huffmanBytes.length);
-
-    return out;
+  private void thirdRequestWithHuffman() {
+    bytesIn.writeByte(0x30); // == Empty reference set ==
+    bytesIn.writeByte(0x85); // == Indexed - Add ==
+                             // idx = 5 -> :method: GET
+    bytesIn.writeByte(0x8c); // == Indexed - Add ==
+                             // idx = 12 -> :scheme: https
+    bytesIn.writeByte(0x8b); // == Indexed - Add ==
+                             // idx = 11 -> :path: /index.html
+    bytesIn.writeByte(0x84); // == Indexed - Add ==
+                             // idx = 4 -> :authority: www.example.com
+    bytesIn.writeByte(0x40); // Literal indexed
+    bytesIn.writeByte(0x88); // Literal name Huffman encoded 8 bytes
+                             // decodes to custom-key which is length 10
+    bytesIn.write(decodeHex("25a849e95ba97d7f"));
+    bytesIn.writeByte(0x89); // Literal value Huffman encoded 9 bytes
+                             // decodes to custom-value which is length 12
+    bytesIn.write(decodeHex("25a849e95bb8e8b4bf"));
   }
 
   private void checkReadThirdRequestWithHuffman() {
@@ -893,21 +886,28 @@ private void checkReadThirdRequestWithHuffman() {
     assertEquals(0, newReader(byteStream()).readInt(0, 31));
   }
 
-  @Test public void headerName() throws IOException {
-    hpackWriter.writeByteString(ByteString.encodeUtf8("foo"));
-    assertBytes(3, 'f', 'o', 'o');
-    assertEquals("foo", newReader(byteStream(3, 'F', 'o', 'o')).readByteString(true).utf8());
+  @Test public void lowercaseHeaderNameBeforeEmit() throws IOException {
+    hpackWriter.writeHeaders(Arrays.asList(new Header("FoO", "BaR")));
+    assertBytes(0, 3, 'f', 'o', 'o', 3, 'B', 'a', 'R');
+  }
+
+  @Test public void mixedCaseHeaderNameIsMalformed() throws IOException {
+    try {
+      newReader(byteStream(0, 3, 'F', 'o', 'o', 3, 'B', 'a', 'R')).readHeaders();
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR response malformed: mixed case name: Foo", e.getMessage());
+    }
   }
 
   @Test public void emptyHeaderName() throws IOException {
     hpackWriter.writeByteString(ByteString.encodeUtf8(""));
     assertBytes(0);
-    assertEquals(ByteString.EMPTY, newReader(byteStream(0)).readByteString(true));
-    assertEquals(ByteString.EMPTY, newReader(byteStream(0)).readByteString(false));
+    assertEquals(ByteString.EMPTY, newReader(byteStream(0)).readByteString());
   }
 
-  private HpackDraft06.Reader newReader(Buffer source) {
-    return new HpackDraft06.Reader(4096, source);
+  private HpackDraft08.Reader newReader(Buffer source) {
+    return new HpackDraft08.Reader(4096, source);
   }
 
   private Buffer byteStream(int... bytes) {
@@ -920,10 +920,9 @@ private void checkEntry(Header entry, String name, String value, int size) {
     assertEquals(size, entry.hpackSize);
   }
 
-  private void assertBytes(int... bytes) {
+  private void assertBytes(int... bytes) throws IOException {
     ByteString expected = intArrayToByteArray(bytes);
-    // TODO change to bytesOut.readByteString() once Okio 0.8.1+ is available.
-    ByteString actual = bytesOut.readByteString(bytesOut.size());
+    ByteString actual = bytesOut.readByteString();
     assertEquals(expected, actual);
   }
 
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft10FrameLoggerTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft10FrameLoggerTest.java
deleted file mode 100644
index f342e5c6bf..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft10FrameLoggerTest.java
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.spdy;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import org.junit.Test;
-
-import static com.squareup.okhttp.internal.spdy.Http20Draft10.FLAG_ACK;
-import static com.squareup.okhttp.internal.spdy.Http20Draft10.FLAG_END_HEADERS;
-import static com.squareup.okhttp.internal.spdy.Http20Draft10.FLAG_END_STREAM;
-import static com.squareup.okhttp.internal.spdy.Http20Draft10.FLAG_NONE;
-import static com.squareup.okhttp.internal.spdy.Http20Draft10.FrameLogger.formatFlags;
-import static com.squareup.okhttp.internal.spdy.Http20Draft10.FrameLogger.formatHeader;
-import static com.squareup.okhttp.internal.spdy.Http20Draft10.TYPE_DATA;
-import static com.squareup.okhttp.internal.spdy.Http20Draft10.TYPE_GOAWAY;
-import static com.squareup.okhttp.internal.spdy.Http20Draft10.TYPE_HEADERS;
-import static com.squareup.okhttp.internal.spdy.Http20Draft10.TYPE_SETTINGS;
-import static org.junit.Assert.assertEquals;
-
-public class Http20Draft10FrameLoggerTest {
-
-  /** Real stream traffic applied to the log format. */
-  @Test public void exampleStream() {
-    assertEquals(">> 0x00000000     5 SETTINGS      ",
-        formatHeader(false, 0, 5, TYPE_SETTINGS, FLAG_NONE));
-    assertEquals(">> 0x00000003   100 HEADERS       END_HEADERS",
-        formatHeader(false, 3, 100, TYPE_HEADERS, FLAG_END_HEADERS));
-    assertEquals(">> 0x00000003     0 DATA          END_STREAM",
-        formatHeader(false, 3, 0, TYPE_DATA, FLAG_END_STREAM));
-    assertEquals("<< 0x00000000    15 SETTINGS      ",
-        formatHeader(true, 0, 15, TYPE_SETTINGS, FLAG_NONE));
-    assertEquals(">> 0x00000000     0 SETTINGS      ACK",
-        formatHeader(false, 0, 0, TYPE_SETTINGS, FLAG_ACK));
-    assertEquals("<< 0x00000000     0 SETTINGS      ACK",
-        formatHeader(true, 0, 0, TYPE_SETTINGS, FLAG_ACK));
-    assertEquals("<< 0x00000003    22 HEADERS       END_HEADERS",
-        formatHeader(true, 3, 22, TYPE_HEADERS, FLAG_END_HEADERS));
-    assertEquals("<< 0x00000003   226 DATA          END_STREAM",
-        formatHeader(true, 3, 226, TYPE_DATA, FLAG_END_STREAM));
-    assertEquals(">> 0x00000000     8 GOAWAY        ",
-        formatHeader(false, 0, 8, TYPE_GOAWAY, FLAG_NONE));
-  }
-
-  /**
-   * Ensures that valid flag combinations appear visually correct, and invalid show in hex.  This
-   * also demonstrates how sparse the lookup table is.
-   */
-  @Test public void allFormattedFlagsWithValidBits() {
-    List<String> formattedFlags = new ArrayList<String>(0x40); // Highest valid flag is 0x20.
-    for (byte i = 0; i < 0x40; i++) formattedFlags.add(formatFlags(TYPE_HEADERS, i));
-
-    assertEquals(Arrays.asList(
-        "",
-        "END_STREAM",
-        "END_SEGMENT",
-        "END_STREAM|END_SEGMENT",
-        "END_HEADERS",
-        "END_STREAM|END_HEADERS",
-        "END_SEGMENT|END_HEADERS",
-        "END_STREAM|END_SEGMENT|END_HEADERS",
-        "PRIORITY",
-        "END_STREAM|PRIORITY",
-        "END_SEGMENT|PRIORITY",
-        "END_STREAM|END_SEGMENT|PRIORITY",
-        "END_HEADERS|PRIORITY",
-        "END_STREAM|END_HEADERS|PRIORITY",
-        "END_SEGMENT|END_HEADERS|PRIORITY",
-        "END_STREAM|END_SEGMENT|END_HEADERS|PRIORITY",
-        "PAD_LOW",
-        "END_STREAM|PAD_LOW",
-        "END_SEGMENT|PAD_LOW",
-        "END_STREAM|END_SEGMENT|PAD_LOW",
-        "00010100",
-        "END_STREAM|END_HEADERS|PAD_LOW",
-        "END_SEGMENT|END_HEADERS|PAD_LOW",
-        "END_STREAM|END_SEGMENT|END_HEADERS|PAD_LOW",
-        "00011000",
-        "END_STREAM|PRIORITY|PAD_LOW",
-        "END_SEGMENT|PRIORITY|PAD_LOW",
-        "END_STREAM|END_SEGMENT|PRIORITY|PAD_LOW",
-        "00011100",
-        "END_STREAM|END_HEADERS|PRIORITY|PAD_LOW",
-        "END_SEGMENT|END_HEADERS|PRIORITY|PAD_LOW",
-        "END_STREAM|END_SEGMENT|END_HEADERS|PRIORITY|PAD_LOW",
-        "00100000",
-        "00100001",
-        "00100010",
-        "00100011",
-        "00100100",
-        "00100101",
-        "00100110",
-        "00100111",
-        "00101000",
-        "00101001",
-        "00101010",
-        "00101011",
-        "00101100",
-        "00101101",
-        "00101110",
-        "00101111",
-        "PAD_LOW|PAD_HIGH",
-        "END_STREAM|PAD_LOW|PAD_HIGH",
-        "END_SEGMENT|PAD_LOW|PAD_HIGH",
-        "END_STREAM|END_SEGMENT|PAD_LOW|PAD_HIGH",
-        "00110100",
-        "END_STREAM|END_HEADERS|PAD_LOW|PAD_HIGH",
-        "END_SEGMENT|END_HEADERS|PAD_LOW|PAD_HIGH",
-        "END_STREAM|END_SEGMENT|END_HEADERS|PAD_LOW|PAD_HIGH",
-        "00111000",
-        "END_STREAM|PRIORITY|PAD_LOW|PAD_HIGH",
-        "END_SEGMENT|PRIORITY|PAD_LOW|PAD_HIGH",
-        "END_STREAM|END_SEGMENT|PRIORITY|PAD_LOW|PAD_HIGH",
-        "00111100",
-        "END_STREAM|END_HEADERS|PRIORITY|PAD_LOW|PAD_HIGH",
-        "END_SEGMENT|END_HEADERS|PRIORITY|PAD_LOW|PAD_HIGH",
-        "END_STREAM|END_SEGMENT|END_HEADERS|PRIORITY|PAD_LOW|PAD_HIGH"
-    ), formattedFlags);
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft10Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft10Test.java
deleted file mode 100644
index 35fbb4f6ef..0000000000
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft10Test.java
+++ /dev/null
@@ -1,1008 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.spdy;
-
-import com.squareup.okhttp.internal.Util;
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.List;
-import okio.BufferedSource;
-import okio.ByteString;
-import okio.Buffer;
-import org.junit.Test;
-
-import static com.squareup.okhttp.internal.Util.headerEntries;
-import static com.squareup.okhttp.internal.spdy.Http20Draft10.FLAG_END_HEADERS;
-import static com.squareup.okhttp.internal.spdy.Http20Draft10.FLAG_END_STREAM;
-import static com.squareup.okhttp.internal.spdy.Http20Draft10.FLAG_NONE;
-import static com.squareup.okhttp.internal.spdy.Http20Draft10.FLAG_PAD_HIGH;
-import static com.squareup.okhttp.internal.spdy.Http20Draft10.FLAG_PAD_LOW;
-import static com.squareup.okhttp.internal.spdy.Http20Draft10.FLAG_PRIORITY;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public class Http20Draft10Test {
-  static final int expectedStreamId = 15;
-
-  @Test public void unknownFrameTypeProtocolError() throws IOException {
-    Buffer frame = new Buffer();
-
-    frame.writeShort(4); // has a 4-byte field
-    frame.writeByte(99); // type 99
-    frame.writeByte(0); // no flags
-    frame.writeInt(expectedStreamId);
-    frame.writeInt(111111111); // custom data
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-
-    // Consume the unknown frame.
-    try {
-      fr.nextFrame(new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR: unknown frame type 99", e.getMessage());
-    }
-  }
-
-  @Test public void onlyOneLiteralHeadersFrame() throws IOException {
-    final List<Header> sentHeaders = headerEntries("name", "value");
-
-    Buffer frame = new Buffer();
-
-    // Write the headers frame, specifying no more frames are expected.
-    {
-      Buffer headerBytes = literalHeaders(sentHeaders);
-      frame.writeShort((int) headerBytes.size());
-      frame.writeByte(Http20Draft10.TYPE_HEADERS);
-      frame.writeByte(FLAG_END_HEADERS | FLAG_END_STREAM);
-      frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.writeAll(headerBytes);
-    }
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-
-    // Consume the headers frame.
-    fr.nextFrame(new BaseTestHandler() {
-
-      @Override
-      public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, int priority, List<Header> headerBlock,
-          HeadersMode headersMode) {
-        assertFalse(outFinished);
-        assertTrue(inFinished);
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(-1, associatedStreamId);
-        assertEquals(-1, priority);
-        assertEquals(sentHeaders, headerBlock);
-        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
-      }
-    });
-  }
-
-  @Test public void headersWithPriority() throws IOException {
-    Buffer frame = new Buffer();
-
-    final List<Header> sentHeaders = headerEntries("name", "value");
-
-    { // Write the headers frame, specifying priority flag and value.
-      Buffer headerBytes = literalHeaders(sentHeaders);
-      frame.writeShort((int) (headerBytes.size() + 4));
-      frame.writeByte(Http20Draft10.TYPE_HEADERS);
-      frame.writeByte(FLAG_END_HEADERS | FLAG_PRIORITY);
-      frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.writeInt(0); // Highest priority is 0.
-      frame.writeAll(headerBytes);
-    }
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-
-    // Consume the headers frame.
-    fr.nextFrame(new BaseTestHandler() {
-
-      @Override
-      public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, int priority, List<Header> nameValueBlock,
-          HeadersMode headersMode) {
-        assertFalse(outFinished);
-        assertFalse(inFinished);
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(-1, associatedStreamId);
-        assertEquals(0, priority);
-        assertEquals(sentHeaders, nameValueBlock);
-        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
-      }
-    });
-  }
-
-  /** Headers are compressed, then framed. */
-  @Test public void headersFrameThenContinuation() throws IOException {
-
-    Buffer frame = new Buffer();
-
-    // Decoding the first header will cross frame boundaries.
-    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
-    { // Write the first headers frame.
-      frame.writeShort((int) (headerBlock.size() / 2));
-      frame.writeByte(Http20Draft10.TYPE_HEADERS);
-      frame.writeByte(0); // no flags
-      frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.write(headerBlock, headerBlock.size() / 2);
-    }
-
-    { // Write the continuation frame, specifying no more frames are expected.
-      frame.writeShort((int) headerBlock.size());
-      frame.writeByte(Http20Draft10.TYPE_CONTINUATION);
-      frame.writeByte(FLAG_END_HEADERS);
-      frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.writeAll(headerBlock);
-    }
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-
-    // Reading the above frames should result in a concatenated headerBlock.
-    fr.nextFrame(new BaseTestHandler() {
-
-      @Override
-      public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, int priority, List<Header> headerBlock,
-          HeadersMode headersMode) {
-        assertFalse(outFinished);
-        assertFalse(inFinished);
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(-1, associatedStreamId);
-        assertEquals(-1, priority);
-        assertEquals(headerEntries("foo", "barrr", "baz", "qux"), headerBlock);
-        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
-      }
-    });
-  }
-
-  @Test public void pushPromise() throws IOException {
-    Buffer frame = new Buffer();
-
-    final int expectedPromisedStreamId = 11;
-
-    final List<Header> pushPromise = Arrays.asList(
-        new Header(Header.TARGET_METHOD, "GET"),
-        new Header(Header.TARGET_SCHEME, "https"),
-        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
-        new Header(Header.TARGET_PATH, "/")
-    );
-
-    { // Write the push promise frame, specifying the associated stream ID.
-      Buffer headerBytes = literalHeaders(pushPromise);
-      frame.writeShort((int) (headerBytes.size() + 4));
-      frame.writeByte(Http20Draft10.TYPE_PUSH_PROMISE);
-      frame.writeByte(Http20Draft10.FLAG_END_PUSH_PROMISE);
-      frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
-      frame.writeAll(headerBytes);
-    }
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-
-    // Consume the headers frame.
-    fr.nextFrame(new BaseTestHandler() {
-      @Override
-      public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(expectedPromisedStreamId, promisedStreamId);
-        assertEquals(pushPromise, headerBlock);
-      }
-    });
-  }
-
-  /** Headers are compressed, then framed. */
-  @Test public void pushPromiseThenContinuation() throws IOException {
-    Buffer frame = new Buffer();
-
-    final int expectedPromisedStreamId = 11;
-
-    final List<Header> pushPromise = Arrays.asList(
-        new Header(Header.TARGET_METHOD, "GET"),
-        new Header(Header.TARGET_SCHEME, "https"),
-        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
-        new Header(Header.TARGET_PATH, "/")
-    );
-
-    // Decoding the first header will cross frame boundaries.
-    Buffer headerBlock = literalHeaders(pushPromise);
-    int firstFrameLength = (int) (headerBlock.size() - 1);
-    { // Write the first headers frame.
-      frame.writeShort(firstFrameLength + 4);
-      frame.writeByte(Http20Draft10.TYPE_PUSH_PROMISE);
-      frame.writeByte(0); // no flags
-      frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
-      frame.write(headerBlock, firstFrameLength);
-    }
-
-    { // Write the continuation frame, specifying no more frames are expected.
-      frame.writeShort(1);
-      frame.writeByte(Http20Draft10.TYPE_CONTINUATION);
-      frame.writeByte(FLAG_END_HEADERS);
-      frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.write(headerBlock, 1);
-    }
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-
-    // Reading the above frames should result in a concatenated headerBlock.
-    fr.nextFrame(new BaseTestHandler() {
-      @Override
-      public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(expectedPromisedStreamId, promisedStreamId);
-        assertEquals(pushPromise, headerBlock);
-      }
-    });
-  }
-
-  @Test public void readRstStreamFrame() throws IOException {
-    Buffer frame = new Buffer();
-
-    frame.writeShort(4);
-    frame.writeByte(Http20Draft10.TYPE_RST_STREAM);
-    frame.writeByte(0); // No flags
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeInt(ErrorCode.COMPRESSION_ERROR.httpCode);
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-
-    // Consume the reset frame.
-    fr.nextFrame(new BaseTestHandler() {
-      @Override public void rstStream(int streamId, ErrorCode errorCode) {
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(ErrorCode.COMPRESSION_ERROR, errorCode);
-      }
-    });
-  }
-
-  @Test public void readSettingsFrame() throws IOException {
-    Buffer frame = new Buffer();
-
-    final int reducedTableSizeBytes = 16;
-
-    frame.writeShort(10); // 2 settings * 1 bytes for the code and 4 for the value.
-    frame.writeByte(Http20Draft10.TYPE_SETTINGS);
-    frame.writeByte(0); // No flags
-    frame.writeInt(0); // Settings are always on the connection stream 0.
-    frame.writeByte(1); // SETTINGS_HEADER_TABLE_SIZE
-    frame.writeInt(reducedTableSizeBytes);
-    frame.writeByte(2); // SETTINGS_ENABLE_PUSH
-    frame.writeInt(0);
-
-    final Http20Draft10.Reader fr = new Http20Draft10.Reader(frame, 4096, false);
-
-    // Consume the settings frame.
-    fr.nextFrame(new BaseTestHandler() {
-      @Override public void settings(boolean clearPrevious, Settings settings) {
-        assertFalse(clearPrevious); // No clearPrevious in HTTP/2.
-        assertEquals(reducedTableSizeBytes, settings.getHeaderTableSize());
-        assertEquals(false, settings.getEnablePush(true));
-      }
-    });
-  }
-
-  @Test public void readSettingsFrameInvalidPushValue() throws IOException {
-    Buffer frame = new Buffer();
-
-    frame.writeShort(5); // 1 settings * 1 bytes for the code and 4 for the value.
-    frame.writeByte(Http20Draft10.TYPE_SETTINGS);
-    frame.writeByte(0); // No flags
-    frame.writeInt(0); // Settings are always on the connection stream 0.
-    frame.writeByte(2);
-    frame.writeInt(2);
-
-    final Http20Draft10.Reader fr = new Http20Draft10.Reader(frame, 4096, false);
-
-    try {
-      fr.nextFrame(new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1", e.getMessage());
-    }
-  }
-
-  @Test public void readSettingsFrameInvalidSettingId() throws IOException {
-    Buffer frame = new Buffer();
-
-    frame.writeShort(5); // 1 settings * 1 bytes for the code and 4 for the value.
-    frame.writeByte(Http20Draft10.TYPE_SETTINGS);
-    frame.writeByte(0); // No flags
-    frame.writeInt(0); // Settings are always on the connection stream 0.
-    frame.writeByte(7); // old number for SETTINGS_INITIAL_WINDOW_SIZE
-    frame.writeInt(1);
-
-    final Http20Draft10.Reader fr = new Http20Draft10.Reader(frame, 4096, false);
-
-    try {
-      fr.nextFrame(new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR invalid settings id: 7", e.getMessage());
-    }
-  }
-
-  @Test public void readSettingsFrameNegativeWindowSize() throws IOException {
-    Buffer frame = new Buffer();
-
-    frame.writeShort(5); // 1 settings * 1 bytes for the code and 4 for the value.
-    frame.writeByte(Http20Draft10.TYPE_SETTINGS);
-    frame.writeByte(0); // No flags
-    frame.writeInt(0); // Settings are always on the connection stream 0.
-    frame.writeByte(4); // SETTINGS_INITIAL_WINDOW_SIZE
-    frame.writeInt(Integer.MIN_VALUE);
-
-    final Http20Draft10.Reader fr = new Http20Draft10.Reader(frame, 4096, false);
-
-    try {
-      fr.nextFrame(new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1", e.getMessage());
-    }
-  }
-
-  @Test public void pingRoundTrip() throws IOException {
-    Buffer frame = new Buffer();
-
-    final int expectedPayload1 = 7;
-    final int expectedPayload2 = 8;
-
-    // Compose the expected PING frame.
-    frame.writeShort(8); // length
-    frame.writeByte(Http20Draft10.TYPE_PING);
-    frame.writeByte(Http20Draft10.FLAG_ACK);
-    frame.writeInt(0); // connection-level
-    frame.writeInt(expectedPayload1);
-    frame.writeInt(expectedPayload2);
-
-    // Check writer sends the same bytes.
-    assertEquals(frame, sendPingFrame(true, expectedPayload1, expectedPayload2));
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-
-    fr.nextFrame(new BaseTestHandler() { // Consume the ping frame.
-      @Override public void ping(boolean ack, int payload1, int payload2) {
-        assertTrue(ack);
-        assertEquals(expectedPayload1, payload1);
-        assertEquals(expectedPayload2, payload2);
-      }
-    });
-  }
-
-  @Test public void maxLengthDataFrame() throws IOException {
-    Buffer frame = new Buffer();
-
-    final byte[] expectedData = new byte[16383];
-    Arrays.fill(expectedData, (byte) 2);
-
-    // Write the data frame.
-    frame.writeShort(expectedData.length);
-    frame.writeByte(Http20Draft10.TYPE_DATA);
-    frame.writeByte(0); // no flags
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.write(expectedData);
-
-    // Check writer sends the same bytes.
-    assertEquals(frame, sendDataFrame(new Buffer().write(expectedData)));
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-
-    fr.nextFrame(new BaseTestHandler() {
-      @Override public void data(
-          boolean inFinished, int streamId, BufferedSource source, int length) throws IOException {
-        assertFalse(inFinished);
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(16383, length);
-        ByteString data = source.readByteString(length);
-        for (byte b : data.toByteArray()) {
-          assertEquals(2, b);
-        }
-      }
-    });
-  }
-
-  @Test public void readPaddedDataFrame() throws IOException {
-    final Buffer frame = new Buffer();
-
-    final int dataLength = 1123;
-    final byte[] expectedData = new byte[dataLength];
-    Arrays.fill(expectedData, (byte) 2);
-
-    final int paddingLength = 257;
-    final byte[] padding = new byte[paddingLength];
-    Arrays.fill(padding, (byte) 0);
-
-    // Write the data frame.
-    frame.writeShort(dataLength + paddingLength + 2); // 2 for PAD_HIGH,LOW.
-    frame.writeByte(Http20Draft10.TYPE_DATA);
-    frame.writeByte(FLAG_PAD_HIGH | FLAG_PAD_LOW);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeShort(paddingLength);
-    frame.write(expectedData);
-    frame.write(padding);
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-    fr.nextFrame(assertData());
-    assertTrue(frame.exhausted()); // Padding was skipped.
-  }
-
-  @Test public void readPaddedDataFrameZeroPaddingHigh() throws IOException {
-    final Buffer frame = new Buffer();
-
-    final int dataLength = 1123;
-    final byte[] expectedData = new byte[dataLength];
-    Arrays.fill(expectedData, (byte) 2);
-
-    // Write the data frame.
-    frame.writeShort(dataLength + 2); // 2 for PAD_HIGH,LOW.
-    frame.writeByte(Http20Draft10.TYPE_DATA);
-    frame.writeByte(FLAG_PAD_HIGH | FLAG_PAD_LOW);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeShort(0);
-    frame.write(expectedData);
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-    fr.nextFrame(assertData());
-  }
-
-  @Test public void readPaddedDataFrameZeroPaddingLow() throws IOException {
-    final Buffer frame = new Buffer();
-
-    final int dataLength = 1123;
-    final byte[] expectedData = new byte[dataLength];
-    Arrays.fill(expectedData, (byte) 2);
-
-    // Write the data frame.
-    frame.writeShort(dataLength + 1);
-    frame.writeByte(Http20Draft10.TYPE_DATA);
-    frame.writeByte(FLAG_PAD_LOW);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeByte(0);
-    frame.write(expectedData);
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-    fr.nextFrame(assertData());
-  }
-
-  @Test public void readPaddedDataFrameMissingLowFlag() throws IOException {
-    final Buffer frame = new Buffer();
-
-    final int dataLength = 1123;
-    final byte[] expectedData = new byte[dataLength];
-    Arrays.fill(expectedData, (byte) 2);
-
-    final int paddingLength = 257;
-    final byte[] padding = new byte[paddingLength];
-    Arrays.fill(padding, (byte) 0);
-
-    // Write the data frame.
-    frame.writeShort(dataLength + paddingLength + 2); // 2 for PAD_HIGH,LOW.
-    frame.writeByte(Http20Draft10.TYPE_DATA);
-    frame.writeByte(FLAG_PAD_HIGH);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeShort(paddingLength);
-    frame.write(expectedData);
-    frame.write(padding);
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-
-    try {
-      fr.nextFrame(new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR FLAG_PAD_HIGH set without FLAG_PAD_LOW", e.getMessage());
-    }
-  }
-
-  /**
-   * Padding is encoded over 2 bytes, so maximum value is 65535, but maximum frame size is 16383.
-   */
-  @Test public void readPaddedDataFrameWithTooMuchPadding() throws IOException {
-    final Buffer frame = new Buffer();
-
-    final int dataLength = 1123;
-    final byte[] expectedData = new byte[dataLength];
-    Arrays.fill(expectedData, (byte) 2);
-
-    final byte[] padding = new byte[0xffff];
-    Arrays.fill(padding, (byte) 0);
-
-    // Write the data frame.
-    frame.writeShort(dataLength + 2); // 2 for PAD_HIGH,LOW.
-    frame.writeByte(Http20Draft10.TYPE_HEADERS);
-    frame.writeByte(FLAG_PAD_HIGH | FLAG_PAD_LOW);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeShort(0xffff);
-    frame.write(expectedData);
-    frame.write(padding);
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-
-    try {
-      fr.nextFrame(new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR padding > 16383: 65535", e.getMessage());
-    }
-  }
-
-  @Test public void readPaddedHeadersFrame() throws IOException {
-    final Buffer frame = new Buffer();
-
-    final int paddingLength = 257;
-    final byte[] padding = new byte[paddingLength];
-    Arrays.fill(padding, (byte) 0);
-
-    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
-    frame.writeShort((int) headerBlock.size() + paddingLength + 2); // 2 for PAD_HIGH,LOW.
-    frame.writeByte(Http20Draft10.TYPE_HEADERS);
-    frame.writeByte(FLAG_END_HEADERS | FLAG_PAD_HIGH | FLAG_PAD_LOW);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeShort(paddingLength);
-    frame.writeAll(headerBlock);
-    frame.write(padding);
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-    fr.nextFrame(assertHeaderBlock());
-    assertTrue(frame.exhausted()); // Padding was skipped.
-  }
-
-  @Test public void readPaddedHeadersFrameZeroPaddingHigh() throws IOException {
-    final Buffer frame = new Buffer();
-
-    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
-    frame.writeShort((int) headerBlock.size() + 2); // 2 for PAD_HIGH,LOW.
-    frame.writeByte(Http20Draft10.TYPE_HEADERS);
-    frame.writeByte(FLAG_END_HEADERS | FLAG_PAD_HIGH | FLAG_PAD_LOW);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeShort(0);
-    frame.writeAll(headerBlock);
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-    fr.nextFrame(assertHeaderBlock());
-  }
-
-  @Test public void readPaddedHeadersFrameZeroPaddingLow() throws IOException {
-    final Buffer frame = new Buffer();
-
-    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
-    frame.writeShort((int) headerBlock.size() + 2); // 2 for PAD_HIGH,LOW.
-    frame.writeByte(Http20Draft10.TYPE_HEADERS);
-    frame.writeByte(FLAG_END_HEADERS | FLAG_PAD_LOW);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeByte(0);
-    frame.writeAll(headerBlock);
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-    fr.nextFrame(assertHeaderBlock());
-  }
-
-  @Test public void readPaddedHeadersFrameMissingLowFlag() throws IOException {
-    final Buffer frame = new Buffer();
-
-    final int paddingLength = 257;
-    final byte[] padding = new byte[paddingLength];
-    Arrays.fill(padding, (byte) 0);
-
-    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
-    frame.writeShort((int) headerBlock.size() + 1);
-    frame.writeByte(Http20Draft10.TYPE_HEADERS);
-    frame.writeByte(FLAG_PAD_HIGH);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeShort(paddingLength);
-    frame.writeAll(headerBlock);
-    frame.write(padding);
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-
-    try {
-      fr.nextFrame(new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR FLAG_PAD_HIGH set without FLAG_PAD_LOW", e.getMessage());
-    }
-  }
-
-  /**
-   * Padding is encoded over 2 bytes, so maximum value is 65535, but maximum frame size is 16383.
-   */
-  @Test public void readPaddedHeadersFrameWithTooMuchPadding() throws IOException {
-    final Buffer frame = new Buffer();
-
-    final byte[] padding = new byte[0xffff];
-    Arrays.fill(padding, (byte) 0);
-
-    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
-    frame.writeShort((int) headerBlock.size() + 2); // 2 for PAD_HIGH,LOW.
-    frame.writeByte(Http20Draft10.TYPE_HEADERS);
-    frame.writeByte(FLAG_PAD_HIGH | FLAG_PAD_LOW);
-    frame.writeInt(expectedStreamId & 0x7fffffff);
-    frame.writeShort(0xffff);
-    frame.writeAll(headerBlock);
-    frame.write(padding);
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-
-    try {
-      fr.nextFrame(new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR padding > 16383: 65535", e.getMessage());
-    }
-  }
-
-  /** Headers are compressed, then framed. */
-  @Test public void readPaddedHeadersFrameThenContinuation() throws IOException {
-
-    Buffer frame = new Buffer();
-
-    final int paddingLength = 257;
-    final byte[] padding = new byte[paddingLength];
-    Arrays.fill(padding, (byte) 0);
-
-    // Decoding the first header will cross frame boundaries.
-    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
-    { // Write the first headers frame.
-      frame.writeShort((int) (headerBlock.size() / 2) + paddingLength + 2); // 2 for PAD_HIGH,LOW.
-      frame.writeByte(Http20Draft10.TYPE_HEADERS);
-      frame.writeByte(FLAG_PAD_HIGH | FLAG_PAD_LOW);
-      frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.writeShort(paddingLength);
-      frame.write(headerBlock, headerBlock.size() / 2);
-      frame.write(padding);
-    }
-
-    { // Write the continuation frame, specifying no more frames are expected.
-      frame.writeShort((int) headerBlock.size() + paddingLength + 2);
-      frame.writeByte(Http20Draft10.TYPE_CONTINUATION); // 2 for PAD_HIGH,LOW.
-      frame.writeByte(FLAG_END_HEADERS | FLAG_PAD_HIGH | FLAG_PAD_LOW);
-      frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.writeShort(paddingLength);
-      frame.writeAll(headerBlock);
-      frame.write(padding);
-    }
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-    fr.nextFrame(assertHeaderBlock());
-    assertTrue(frame.exhausted()); // Padding was skipped.
-  }
-
-  @Test public void readPaddedContinuationFrameZeroPaddingHigh() throws IOException {
-    final Buffer frame = new Buffer();
-
-    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
-    { // Write the first headers frame.
-      frame.writeShort((int) (headerBlock.size() / 2));
-      frame.writeByte(Http20Draft10.TYPE_HEADERS);
-      frame.writeByte(0);
-      frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.write(headerBlock, headerBlock.size() / 2);
-    }
-
-    { // Write the continuation frame, specifying no more frames are expected.
-      frame.writeShort((int) headerBlock.size() + 2); // 2 for PAD_HIGH,LOW.
-      frame.writeByte(Http20Draft10.TYPE_CONTINUATION);
-      frame.writeByte(FLAG_END_HEADERS | FLAG_PAD_HIGH | FLAG_PAD_LOW);
-      frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.writeShort(0);
-      frame.writeAll(headerBlock);
-    }
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-    fr.nextFrame(assertHeaderBlock());
-  }
-
-  @Test public void readPaddedContinuationFrameZeroPaddingLow() throws IOException {
-    final Buffer frame = new Buffer();
-
-    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
-    { // Write the first headers frame.
-      frame.writeShort((int) (headerBlock.size() / 2));
-      frame.writeByte(Http20Draft10.TYPE_HEADERS);
-      frame.writeByte(0);
-      frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.write(headerBlock, headerBlock.size() / 2);
-    }
-
-    { // Write the continuation frame, specifying no more frames are expected.
-      frame.writeShort((int) headerBlock.size() + 2); // 2 for PAD_HIGH,LOW.
-      frame.writeByte(Http20Draft10.TYPE_CONTINUATION);
-      frame.writeByte(FLAG_END_HEADERS | FLAG_PAD_LOW);
-      frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.writeByte(0);
-      frame.writeAll(headerBlock);
-    }
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-    fr.nextFrame(assertHeaderBlock());
-  }
-
-  @Test public void readPaddedContinuationFrameMissingLowFlag() throws IOException {
-    final Buffer frame = new Buffer();
-
-    final int paddingLength = 257;
-    final byte[] padding = new byte[paddingLength];
-    Arrays.fill(padding, (byte) 0);
-
-    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
-    { // Write the first headers frame.
-      frame.writeShort((int) (headerBlock.size() / 2));
-      frame.writeByte(Http20Draft10.TYPE_HEADERS);
-      frame.writeByte(0);
-      frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.write(headerBlock, headerBlock.size() / 2);
-    }
-
-    { // Write the continuation frame, specifying no more frames are expected.
-      frame.writeShort((int) headerBlock.size() + 1);
-      frame.writeByte(Http20Draft10.TYPE_CONTINUATION);
-      frame.writeByte(FLAG_PAD_HIGH);
-      frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.writeShort(paddingLength);
-      frame.writeAll(headerBlock);
-      frame.write(padding);
-    }
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-
-    try {
-      fr.nextFrame(new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR FLAG_PAD_HIGH set without FLAG_PAD_LOW", e.getMessage());
-    }
-  }
-
-  /**
-   * Padding is encoded over 2 bytes, so maximum value is 65535, but maximum frame size is 16383.
-   */
-  @Test public void readPaddedContinuationFrameWithTooMuchPadding() throws IOException {
-    final Buffer frame = new Buffer();
-
-    final byte[] padding = new byte[0xffff];
-    Arrays.fill(padding, (byte) 0);
-
-    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
-    { // Write the first headers frame.
-      frame.writeShort((int) (headerBlock.size() / 2));
-      frame.writeByte(Http20Draft10.TYPE_HEADERS);
-      frame.writeByte(0);
-      frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.write(headerBlock, headerBlock.size() / 2);
-    }
-
-    { // Write the continuation frame, specifying no more frames are expected.
-      frame.writeShort((int) (headerBlock.size() / 2) + 2); // 2 for PAD_HIGH,LOW.
-      frame.writeByte(Http20Draft10.TYPE_CONTINUATION);
-      frame.writeByte(FLAG_PAD_HIGH | FLAG_PAD_LOW);
-      frame.writeInt(expectedStreamId & 0x7fffffff);
-      frame.writeShort(0xffff);
-      frame.write(headerBlock, (headerBlock.size() / 2));
-      frame.write(padding);
-    }
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-
-    try {
-      fr.nextFrame(new BaseTestHandler());
-      fail();
-    } catch (IOException e) {
-      assertEquals("PROTOCOL_ERROR padding > 16383: 65535", e.getMessage());
-    }
-  }
-
-  @Test public void tooLargeDataFrame() throws IOException {
-    try {
-      sendDataFrame(new Buffer().write(new byte[0x1000000]));
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("FRAME_SIZE_ERROR length > 16383: 16777216", e.getMessage());
-    }
-  }
-
-  @Test public void windowUpdateRoundTrip() throws IOException {
-    Buffer frame = new Buffer();
-
-    final long expectedWindowSizeIncrement = 0x7fffffff;
-
-    // Compose the expected window update frame.
-    frame.writeShort(4); // length
-    frame.writeByte(Http20Draft10.TYPE_WINDOW_UPDATE);
-    frame.writeByte(0); // No flags.
-    frame.writeInt(expectedStreamId);
-    frame.writeInt((int) expectedWindowSizeIncrement);
-
-    // Check writer sends the same bytes.
-    assertEquals(frame, windowUpdate(expectedWindowSizeIncrement));
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-
-    fr.nextFrame(new BaseTestHandler() { // Consume the window update frame.
-      @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(expectedWindowSizeIncrement, windowSizeIncrement);
-      }
-    });
-  }
-
-  @Test public void badWindowSizeIncrement() throws IOException {
-    try {
-      windowUpdate(0);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 0",
-          e.getMessage());
-    }
-    try {
-      windowUpdate(0x80000000L);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 2147483648",
-          e.getMessage());
-    }
-  }
-
-  @Test public void goAwayWithoutDebugDataRoundTrip() throws IOException {
-    Buffer frame = new Buffer();
-
-    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
-
-    // Compose the expected GOAWAY frame without debug data.
-    frame.writeShort(8); // Without debug data there's only 2 32-bit fields.
-    frame.writeByte(Http20Draft10.TYPE_GOAWAY);
-    frame.writeByte(0); // no flags.
-    frame.writeInt(0); // connection-scope
-    frame.writeInt(expectedStreamId); // last good stream.
-    frame.writeInt(expectedError.httpCode);
-
-    // Check writer sends the same bytes.
-    assertEquals(frame, sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-
-    fr.nextFrame(new BaseTestHandler() { // Consume the go away frame.
-      @Override public void goAway(
-          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
-        assertEquals(expectedStreamId, lastGoodStreamId);
-        assertEquals(expectedError, errorCode);
-        assertEquals(0, debugData.size());
-      }
-    });
-  }
-
-  @Test public void goAwayWithDebugDataRoundTrip() throws IOException {
-    Buffer frame = new Buffer();
-
-    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
-    final ByteString expectedData = ByteString.encodeUtf8("abcdefgh");
-
-    // Compose the expected GOAWAY frame without debug data.
-    frame.writeShort(8 + expectedData.size());
-    frame.writeByte(Http20Draft10.TYPE_GOAWAY);
-    frame.writeByte(0); // no flags.
-    frame.writeInt(0); // connection-scope
-    frame.writeInt(0); // never read any stream!
-    frame.writeInt(expectedError.httpCode);
-    frame.write(expectedData.toByteArray());
-
-    // Check writer sends the same bytes.
-    assertEquals(frame, sendGoAway(0, expectedError, expectedData.toByteArray()));
-
-    FrameReader fr = new Http20Draft10.Reader(frame, 4096, false);
-
-    fr.nextFrame(new BaseTestHandler() { // Consume the go away frame.
-      @Override public void goAway(
-          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
-        assertEquals(0, lastGoodStreamId);
-        assertEquals(expectedError, errorCode);
-        assertEquals(expectedData, debugData);
-      }
-    });
-  }
-
-  @Test public void frameSizeError() throws IOException {
-    Http20Draft10.Writer writer = new Http20Draft10.Writer(new Buffer(), true);
-
-    try {
-      writer.frameHeader(0, 16384, Http20Draft10.TYPE_DATA, FLAG_NONE);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("FRAME_SIZE_ERROR length > 16383: 16384", e.getMessage());
-    }
-  }
-
-  @Test public void streamIdHasReservedBit() throws IOException {
-    Http20Draft10.Writer writer = new Http20Draft10.Writer(new Buffer(), true);
-
-    try {
-      int streamId = 3;
-      streamId |= 1L << 31; // set reserved bit
-      writer.frameHeader(streamId, 16383, Http20Draft10.TYPE_DATA, FLAG_NONE);
-      fail();
-    } catch (IllegalArgumentException e) {
-      assertEquals("reserved bit set: -2147483645", e.getMessage());
-    }
-  }
-
-  private Buffer literalHeaders(List<Header> sentHeaders) throws IOException {
-    Buffer out = new Buffer();
-    new HpackDraft06.Writer(out).writeHeaders(sentHeaders);
-    return out;
-  }
-
-  private Buffer sendPingFrame(boolean ack, int payload1, int payload2) throws IOException {
-    Buffer out = new Buffer();
-    new Http20Draft10.Writer(out, true).ping(ack, payload1, payload2);
-    return out;
-  }
-
-  private Buffer sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
-      throws IOException {
-    Buffer out = new Buffer();
-    new Http20Draft10.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
-    return out;
-  }
-
-  private Buffer sendDataFrame(Buffer data) throws IOException {
-    Buffer out = new Buffer();
-    new Http20Draft10.Writer(out, true).dataFrame(expectedStreamId, FLAG_NONE, data,
-        (int) data.size());
-    return out;
-  }
-
-  private Buffer windowUpdate(long windowSizeIncrement) throws IOException {
-    Buffer out = new Buffer();
-    new Http20Draft10.Writer(out, true).windowUpdate(expectedStreamId, windowSizeIncrement);
-    return out;
-  }
-
-  private FrameReader.Handler assertHeaderBlock() {
-    return new BaseTestHandler() {
-      @Override
-      public void headers(boolean outFinished, boolean inFinished, int streamId,
-          int associatedStreamId, int priority, List<Header> headerBlock,
-          HeadersMode headersMode) {
-        assertFalse(outFinished);
-        assertFalse(inFinished);
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(-1, associatedStreamId);
-        assertEquals(-1, priority);
-        assertEquals(headerEntries("foo", "barrr", "baz", "qux"), headerBlock);
-        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
-      }
-    };
-  }
-
-  private FrameReader.Handler assertData() {
-    return new BaseTestHandler() {
-      @Override public void data(
-          boolean inFinished, int streamId, BufferedSource source, int length) throws IOException {
-        assertFalse(inFinished);
-        assertEquals(expectedStreamId, streamId);
-        assertEquals(1123, length);
-        ByteString data = source.readByteString(length);
-        for (byte b : data.toByteArray()) {
-          assertEquals(2, b);
-        }
-      }
-    };
-  }
-}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft13FrameLoggerTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft13FrameLoggerTest.java
new file mode 100644
index 0000000000..3ab2ca39cc
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft13FrameLoggerTest.java
@@ -0,0 +1,164 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import org.junit.Test;
+
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.FLAG_ACK;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.FLAG_END_HEADERS;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.FLAG_END_STREAM;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.FLAG_NONE;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.FrameLogger.formatFlags;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.FrameLogger.formatHeader;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.TYPE_CONTINUATION;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.TYPE_DATA;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.TYPE_GOAWAY;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.TYPE_HEADERS;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.TYPE_PING;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.TYPE_PUSH_PROMISE;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.TYPE_SETTINGS;
+import static org.junit.Assert.assertEquals;
+
+public class Http20Draft13FrameLoggerTest {
+
+  /** Real stream traffic applied to the log format. */
+  @Test public void exampleStream() {
+    assertEquals(">> 0x00000000     5 SETTINGS      ",
+        formatHeader(false, 0, 5, TYPE_SETTINGS, FLAG_NONE));
+    assertEquals(">> 0x00000003   100 HEADERS       END_HEADERS",
+        formatHeader(false, 3, 100, TYPE_HEADERS, FLAG_END_HEADERS));
+    assertEquals(">> 0x00000003     0 DATA          END_STREAM",
+        formatHeader(false, 3, 0, TYPE_DATA, FLAG_END_STREAM));
+    assertEquals("<< 0x00000000    15 SETTINGS      ",
+        formatHeader(true, 0, 15, TYPE_SETTINGS, FLAG_NONE));
+    assertEquals(">> 0x00000000     0 SETTINGS      ACK",
+        formatHeader(false, 0, 0, TYPE_SETTINGS, FLAG_ACK));
+    assertEquals("<< 0x00000000     0 SETTINGS      ACK",
+        formatHeader(true, 0, 0, TYPE_SETTINGS, FLAG_ACK));
+    assertEquals("<< 0x00000003    22 HEADERS       END_HEADERS",
+        formatHeader(true, 3, 22, TYPE_HEADERS, FLAG_END_HEADERS));
+    assertEquals("<< 0x00000003   226 DATA          END_STREAM",
+        formatHeader(true, 3, 226, TYPE_DATA, FLAG_END_STREAM));
+    assertEquals(">> 0x00000000     8 GOAWAY        ",
+        formatHeader(false, 0, 8, TYPE_GOAWAY, FLAG_NONE));
+  }
+
+  @Test public void flagOverlapOn0x1() {
+    assertEquals("<< 0x00000000     0 SETTINGS      ACK",
+        formatHeader(true, 0, 0, TYPE_SETTINGS, (byte) 0x1));
+    assertEquals("<< 0x00000000     8 PING          ACK",
+        formatHeader(true, 0, 8, TYPE_PING, (byte) 0x1));
+    assertEquals("<< 0x00000003     0 HEADERS       END_STREAM",
+        formatHeader(true, 3, 0, TYPE_HEADERS, (byte) 0x1));
+    assertEquals("<< 0x00000003     0 DATA          END_STREAM",
+        formatHeader(true, 3, 0, TYPE_DATA, (byte) 0x1));
+  }
+
+  @Test public void flagOverlapOn0x4() {
+    assertEquals("<< 0x00000003 10000 HEADERS       END_HEADERS",
+        formatHeader(true, 3, 10000, TYPE_HEADERS, (byte) 0x4));
+    assertEquals("<< 0x00000003 10000 CONTINUATION  END_HEADERS",
+        formatHeader(true, 3, 10000, TYPE_CONTINUATION, (byte) 0x4));
+    assertEquals("<< 0x00000004 10000 PUSH_PROMISE  END_PUSH_PROMISE",
+        formatHeader(true, 4, 10000, TYPE_PUSH_PROMISE, (byte) 0x4));
+  }
+
+  @Test public void flagOverlapOn0x20() {
+    assertEquals("<< 0x00000003 10000 HEADERS       PRIORITY",
+        formatHeader(true, 3, 10000, TYPE_HEADERS, (byte) 0x20));
+    assertEquals("<< 0x00000003 10000 DATA          COMPRESSED",
+        formatHeader(true, 3, 10000, TYPE_DATA, (byte) 0x20));
+  }
+
+  /**
+   * Ensures that valid flag combinations appear visually correct, and invalid show in hex.  This
+   * also demonstrates how sparse the lookup table is.
+   */
+  @Test public void allFormattedFlagsWithValidBits() {
+    List<String> formattedFlags = new ArrayList<>(0x40); // Highest valid flag is 0x20.
+    for (byte i = 0; i < 0x40; i++) formattedFlags.add(formatFlags(TYPE_HEADERS, i));
+
+    assertEquals(Arrays.asList(
+        "",
+        "END_STREAM",
+        "END_SEGMENT",
+        "END_STREAM|END_SEGMENT",
+        "END_HEADERS",
+        "END_STREAM|END_HEADERS",
+        "END_SEGMENT|END_HEADERS",
+        "END_STREAM|END_SEGMENT|END_HEADERS",
+        "PADDED",
+        "END_STREAM|PADDED",
+        "END_SEGMENT|PADDED",
+        "END_STREAM|END_SEGMENT|PADDED",
+        "00001100",
+        "END_STREAM|END_HEADERS|PADDED",
+        "END_SEGMENT|END_HEADERS|PADDED",
+        "END_STREAM|END_SEGMENT|END_HEADERS|PADDED",
+        "00010000",
+        "00010001",
+        "00010010",
+        "00010011",
+        "00010100",
+        "00010101",
+        "00010110",
+        "00010111",
+        "00011000",
+        "00011001",
+        "00011010",
+        "00011011",
+        "00011100",
+        "00011101",
+        "00011110",
+        "00011111",
+        "PRIORITY",
+        "END_STREAM|PRIORITY",
+        "END_SEGMENT|PRIORITY",
+        "END_STREAM|END_SEGMENT|PRIORITY",
+        "END_HEADERS|PRIORITY",
+        "END_STREAM|END_HEADERS|PRIORITY",
+        "END_SEGMENT|END_HEADERS|PRIORITY",
+        "END_STREAM|END_SEGMENT|END_HEADERS|PRIORITY",
+        "00101000",
+        "END_STREAM|PRIORITY|PADDED",
+        "END_SEGMENT|PRIORITY|PADDED",
+        "END_STREAM|END_SEGMENT|PRIORITY|PADDED",
+        "00101100",
+        "END_STREAM|END_HEADERS|PRIORITY|PADDED",
+        "END_SEGMENT|END_HEADERS|PRIORITY|PADDED",
+        "END_STREAM|END_SEGMENT|END_HEADERS|PRIORITY|PADDED",
+        "00110000",
+        "00110001",
+        "00110010",
+        "00110011",
+        "00110100",
+        "00110101",
+        "00110110",
+        "00110111",
+        "00111000",
+        "00111001",
+        "00111010",
+        "00111011",
+        "00111100",
+        "00111101",
+        "00111110",
+        "00111111"
+    ), formattedFlags);
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft13Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft13Test.java
new file mode 100644
index 0000000000..4f626fa80e
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft13Test.java
@@ -0,0 +1,679 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.List;
+
+import com.squareup.okhttp.internal.Util;
+
+import org.junit.Test;
+
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.GzipSink;
+import okio.Okio;
+import static com.squareup.okhttp.internal.Util.headerEntries;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.FLAG_COMPRESSED;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.FLAG_END_HEADERS;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.FLAG_END_STREAM;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.FLAG_NONE;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.FLAG_PADDED;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.FLAG_PRIORITY;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public class Http20Draft13Test {
+  final Buffer frame = new Buffer();
+  final FrameReader fr = new Http20Draft13.Reader(frame, 4096, false);
+  final int expectedStreamId = 15;
+
+  @Test public void unknownFrameTypeSkipped() throws IOException {
+    frame.writeShort(4); // has a 4-byte field
+    frame.writeByte(99); // type 99
+    frame.writeByte(0); // no flags
+    frame.writeInt(expectedStreamId);
+    frame.writeInt(111111111); // custom data
+
+    fr.nextFrame(new BaseTestHandler()); // Should not callback.
+  }
+
+  @Test public void onlyOneLiteralHeadersFrame() throws IOException {
+    final List<Header> sentHeaders = headerEntries("name", "value");
+
+    Buffer headerBytes = literalHeaders(sentHeaders);
+    frame.writeShort((int) headerBytes.size());
+    frame.writeByte(Http20Draft13.TYPE_HEADERS);
+    frame.writeByte(FLAG_END_HEADERS | FLAG_END_STREAM);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeAll(headerBytes);
+
+    assertEquals(frame, sendHeaderFrames(true, sentHeaders)); // Check writer sends the same bytes.
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override
+      public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
+        assertFalse(outFinished);
+        assertTrue(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(sentHeaders, headerBlock);
+        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
+      }
+    });
+  }
+
+  @Test public void headersWithPriority() throws IOException {
+    final List<Header> sentHeaders = headerEntries("name", "value");
+
+    Buffer headerBytes = literalHeaders(sentHeaders);
+    frame.writeShort((int) (headerBytes.size() + 5));
+    frame.writeByte(Http20Draft13.TYPE_HEADERS);
+    frame.writeByte(FLAG_END_HEADERS | FLAG_PRIORITY);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeInt(0); // Independent stream.
+    frame.writeByte(255); // Heaviest weight, zero-indexed.
+    frame.writeAll(headerBytes);
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void priority(int streamId, int streamDependency, int weight,
+          boolean exclusive) {
+        assertEquals(0, streamDependency);
+        assertEquals(256, weight);
+        assertFalse(exclusive);
+      }
+
+      @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> nameValueBlock,
+          HeadersMode headersMode) {
+        assertFalse(outFinished);
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(sentHeaders, nameValueBlock);
+        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
+      }
+    });
+  }
+
+  /** Headers are compressed, then framed. */
+  @Test public void headersFrameThenContinuation() throws IOException {
+    final List<Header> sentHeaders = largeHeaders();
+
+    Buffer headerBlock = literalHeaders(sentHeaders);
+
+    // Write the first headers frame.
+    frame.writeShort(Http20Draft13.MAX_FRAME_SIZE);
+    frame.writeByte(Http20Draft13.TYPE_HEADERS);
+    frame.writeByte(0); // no flags
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.write(headerBlock, Http20Draft13.MAX_FRAME_SIZE);
+
+    // Write the continuation frame, specifying no more frames are expected.
+    frame.writeShort((int) headerBlock.size());
+    frame.writeByte(Http20Draft13.TYPE_CONTINUATION);
+    frame.writeByte(FLAG_END_HEADERS);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeAll(headerBlock);
+
+    assertEquals(frame, sendHeaderFrames(false, sentHeaders)); // Check writer sends the same bytes.
+
+    // Reading the above frames should result in a concatenated headerBlock.
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
+        assertFalse(outFinished);
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(sentHeaders, headerBlock);
+        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
+      }
+    });
+  }
+
+  @Test public void pushPromise() throws IOException {
+    final int expectedPromisedStreamId = 11;
+
+    final List<Header> pushPromise = Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/")
+    );
+
+    // Write the push promise frame, specifying the associated stream ID.
+    Buffer headerBytes = literalHeaders(pushPromise);
+    frame.writeShort((int) (headerBytes.size() + 4));
+    frame.writeByte(Http20Draft13.TYPE_PUSH_PROMISE);
+    frame.writeByte(Http20Draft13.FLAG_END_PUSH_PROMISE);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
+    frame.writeAll(headerBytes);
+
+    assertEquals(frame, sendPushPromiseFrames(expectedPromisedStreamId, pushPromise));
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override
+      public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(expectedPromisedStreamId, promisedStreamId);
+        assertEquals(pushPromise, headerBlock);
+      }
+    });
+  }
+
+  /** Headers are compressed, then framed. */
+  @Test public void pushPromiseThenContinuation() throws IOException {
+    final int expectedPromisedStreamId = 11;
+    final List<Header> pushPromise = largeHeaders();
+
+    // Decoding the first header will cross frame boundaries.
+    Buffer headerBlock = literalHeaders(pushPromise);
+
+    // Write the first headers frame.
+    frame.writeShort(Http20Draft13.MAX_FRAME_SIZE);
+    frame.writeByte(Http20Draft13.TYPE_PUSH_PROMISE);
+    frame.writeByte(0); // no flags
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
+    frame.write(headerBlock, 16379);
+
+    // Write the continuation frame, specifying no more frames are expected.
+    frame.writeShort((int) headerBlock.size());
+    frame.writeByte(Http20Draft13.TYPE_CONTINUATION);
+    frame.writeByte(FLAG_END_HEADERS);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeAll(headerBlock);
+
+    assertEquals(frame, sendPushPromiseFrames(expectedPromisedStreamId, pushPromise));
+
+    // Reading the above frames should result in a concatenated headerBlock.
+    fr.nextFrame(new BaseTestHandler() {
+      @Override
+      public void pushPromise(int streamId, int promisedStreamId, List<Header> headerBlock) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(expectedPromisedStreamId, promisedStreamId);
+        assertEquals(pushPromise, headerBlock);
+      }
+    });
+  }
+
+  @Test public void readRstStreamFrame() throws IOException {
+    frame.writeShort(4);
+    frame.writeByte(Http20Draft13.TYPE_RST_STREAM);
+    frame.writeByte(0); // No flags
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeInt(ErrorCode.COMPRESSION_ERROR.httpCode);
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void rstStream(int streamId, ErrorCode errorCode) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(ErrorCode.COMPRESSION_ERROR, errorCode);
+      }
+    });
+  }
+
+  @Test public void readSettingsFrame() throws IOException {
+    final int reducedTableSizeBytes = 16;
+
+    frame.writeShort(12); // 2 settings * 6 bytes (2 for the code and 4 for the value).
+    frame.writeByte(Http20Draft13.TYPE_SETTINGS);
+    frame.writeByte(0); // No flags
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(1); // SETTINGS_HEADER_TABLE_SIZE
+    frame.writeInt(reducedTableSizeBytes);
+    frame.writeShort(2); // SETTINGS_ENABLE_PUSH
+    frame.writeInt(0);
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void settings(boolean clearPrevious, Settings settings) {
+        assertFalse(clearPrevious); // No clearPrevious in HTTP/2.
+        assertEquals(reducedTableSizeBytes, settings.getHeaderTableSize());
+        assertEquals(false, settings.getEnablePush(true));
+      }
+    });
+  }
+
+  @Test public void readSettingsFrameInvalidPushValue() throws IOException {
+    frame.writeShort(6); // 2 for the code and 4 for the value
+    frame.writeByte(Http20Draft13.TYPE_SETTINGS);
+    frame.writeByte(0); // No flags
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(2);
+    frame.writeInt(2);
+
+    try {
+      fr.nextFrame(new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR SETTINGS_ENABLE_PUSH != 0 or 1", e.getMessage());
+    }
+  }
+
+  @Test public void readSettingsFrameInvalidSettingId() throws IOException {
+    frame.writeShort(6); // 2 for the code and 4 for the value
+    frame.writeByte(Http20Draft13.TYPE_SETTINGS);
+    frame.writeByte(0); // No flags
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(7); // old number for SETTINGS_INITIAL_WINDOW_SIZE
+    frame.writeInt(1);
+
+    try {
+      fr.nextFrame(new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR invalid settings id: 7", e.getMessage());
+    }
+  }
+
+  @Test public void readSettingsFrameNegativeWindowSize() throws IOException {
+    frame.writeShort(6); // 2 for the code and 4 for the value
+    frame.writeByte(Http20Draft13.TYPE_SETTINGS);
+    frame.writeByte(0); // No flags
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.writeShort(4); // SETTINGS_INITIAL_WINDOW_SIZE
+    frame.writeInt(Integer.MIN_VALUE);
+
+    try {
+      fr.nextFrame(new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1", e.getMessage());
+    }
+  }
+
+  @Test public void pingRoundTrip() throws IOException {
+    final int expectedPayload1 = 7;
+    final int expectedPayload2 = 8;
+
+    frame.writeShort(8); // length
+    frame.writeByte(Http20Draft13.TYPE_PING);
+    frame.writeByte(Http20Draft13.FLAG_ACK);
+    frame.writeInt(0); // connection-level
+    frame.writeInt(expectedPayload1);
+    frame.writeInt(expectedPayload2);
+
+    // Check writer sends the same bytes.
+    assertEquals(frame, sendPingFrame(true, expectedPayload1, expectedPayload2));
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void ping(boolean ack, int payload1, int payload2) {
+        assertTrue(ack);
+        assertEquals(expectedPayload1, payload1);
+        assertEquals(expectedPayload2, payload2);
+      }
+    });
+  }
+
+  @Test public void maxLengthDataFrame() throws IOException {
+    final byte[] expectedData = new byte[Http20Draft13.MAX_FRAME_SIZE];
+    Arrays.fill(expectedData, (byte) 2);
+
+    frame.writeShort(expectedData.length);
+    frame.writeByte(Http20Draft13.TYPE_DATA);
+    frame.writeByte(0); // no flags
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.write(expectedData);
+
+    // Check writer sends the same bytes.
+    assertEquals(frame, sendDataFrame(new Buffer().write(expectedData)));
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void data(boolean inFinished, int streamId, BufferedSource source,
+          int length) throws IOException {
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(Http20Draft13.MAX_FRAME_SIZE, length);
+        ByteString data = source.readByteString(length);
+        for (byte b : data.toByteArray()) {
+          assertEquals(2, b);
+        }
+      }
+    });
+  }
+
+  /** We do not send SETTINGS_COMPRESS_DATA = 1, nor want to. Let's make sure we error. */
+  @Test public void compressedDataFrameWhenSettingDisabled() throws IOException {
+    byte[] expectedData = new byte[Http20Draft13.MAX_FRAME_SIZE];
+    Arrays.fill(expectedData, (byte) 2);
+    Buffer zipped = gzip(expectedData);
+    int zippedSize = (int) zipped.size();
+
+    frame.writeShort(zippedSize);
+    frame.writeByte(Http20Draft13.TYPE_DATA);
+    frame.writeByte(FLAG_COMPRESSED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    zipped.readAll(frame);
+
+    try {
+      fr.nextFrame(new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA",
+          e.getMessage());
+    }
+  }
+
+  @Test public void readPaddedDataFrame() throws IOException {
+    int dataLength = 1123;
+    byte[] expectedData = new byte[dataLength];
+    Arrays.fill(expectedData, (byte) 2);
+
+    int paddingLength = 254;
+    byte[] padding = new byte[paddingLength];
+    Arrays.fill(padding, (byte) 0);
+
+    frame.writeShort(dataLength + paddingLength + 1);
+    frame.writeByte(Http20Draft13.TYPE_DATA);
+    frame.writeByte(FLAG_PADDED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeByte(paddingLength);
+    frame.write(expectedData);
+    frame.write(padding);
+
+    fr.nextFrame(assertData());
+    assertTrue(frame.exhausted()); // Padding was skipped.
+  }
+
+  @Test public void readPaddedDataFrameZeroPadding() throws IOException {
+    int dataLength = 1123;
+    byte[] expectedData = new byte[dataLength];
+    Arrays.fill(expectedData, (byte) 2);
+
+    frame.writeShort(dataLength + 1);
+    frame.writeByte(Http20Draft13.TYPE_DATA);
+    frame.writeByte(FLAG_PADDED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeByte(0);
+    frame.write(expectedData);
+
+    fr.nextFrame(assertData());
+  }
+
+  @Test public void readPaddedHeadersFrame() throws IOException {
+    int paddingLength = 254;
+    byte[] padding = new byte[paddingLength];
+    Arrays.fill(padding, (byte) 0);
+
+    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
+    frame.writeShort((int) headerBlock.size() + paddingLength + 1);
+    frame.writeByte(Http20Draft13.TYPE_HEADERS);
+    frame.writeByte(FLAG_END_HEADERS | FLAG_PADDED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeByte(paddingLength);
+    frame.writeAll(headerBlock);
+    frame.write(padding);
+
+    fr.nextFrame(assertHeaderBlock());
+    assertTrue(frame.exhausted()); // Padding was skipped.
+  }
+
+  @Test public void readPaddedHeadersFrameZeroPadding() throws IOException {
+    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
+    frame.writeShort((int) headerBlock.size() + 1);
+    frame.writeByte(Http20Draft13.TYPE_HEADERS);
+    frame.writeByte(FLAG_END_HEADERS | FLAG_PADDED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeByte(0);
+    frame.writeAll(headerBlock);
+
+    fr.nextFrame(assertHeaderBlock());
+  }
+
+  /** Headers are compressed, then framed. */
+  @Test public void readPaddedHeadersFrameThenContinuation() throws IOException {
+    int paddingLength = 254;
+    byte[] padding = new byte[paddingLength];
+    Arrays.fill(padding, (byte) 0);
+
+    // Decoding the first header will cross frame boundaries.
+    Buffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
+
+    // Write the first headers frame.
+    frame.writeShort((int) (headerBlock.size() / 2) + paddingLength + 1);
+    frame.writeByte(Http20Draft13.TYPE_HEADERS);
+    frame.writeByte(FLAG_PADDED);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeByte(paddingLength);
+    frame.write(headerBlock, headerBlock.size() / 2);
+    frame.write(padding);
+
+    // Write the continuation frame, specifying no more frames are expected.
+    frame.writeShort((int) headerBlock.size());
+    frame.writeByte(Http20Draft13.TYPE_CONTINUATION);
+    frame.writeByte(FLAG_END_HEADERS);
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeAll(headerBlock);
+
+    fr.nextFrame(assertHeaderBlock());
+    assertTrue(frame.exhausted());
+  }
+
+  @Test public void tooLargeDataFrame() throws IOException {
+    try {
+      sendDataFrame(new Buffer().write(new byte[0x1000000]));
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("FRAME_SIZE_ERROR length > 16383: 16777216", e.getMessage());
+    }
+  }
+
+  @Test public void windowUpdateRoundTrip() throws IOException {
+    final long expectedWindowSizeIncrement = 0x7fffffff;
+
+    frame.writeShort(4); // length
+    frame.writeByte(Http20Draft13.TYPE_WINDOW_UPDATE);
+    frame.writeByte(0); // No flags.
+    frame.writeInt(expectedStreamId);
+    frame.writeInt((int) expectedWindowSizeIncrement);
+
+    // Check writer sends the same bytes.
+    assertEquals(frame, windowUpdate(expectedWindowSizeIncrement));
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(expectedWindowSizeIncrement, windowSizeIncrement);
+      }
+    });
+  }
+
+  @Test public void badWindowSizeIncrement() throws IOException {
+    try {
+      windowUpdate(0);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 0",
+          e.getMessage());
+    }
+    try {
+      windowUpdate(0x80000000L);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: 2147483648",
+          e.getMessage());
+    }
+  }
+
+  @Test public void goAwayWithoutDebugDataRoundTrip() throws IOException {
+    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
+
+    frame.writeShort(8); // Without debug data there's only 2 32-bit fields.
+    frame.writeByte(Http20Draft13.TYPE_GOAWAY);
+    frame.writeByte(0); // no flags.
+    frame.writeInt(0); // connection-scope
+    frame.writeInt(expectedStreamId); // last good stream.
+    frame.writeInt(expectedError.httpCode);
+
+    // Check writer sends the same bytes.
+    assertEquals(frame, sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void goAway(
+          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
+        assertEquals(expectedStreamId, lastGoodStreamId);
+        assertEquals(expectedError, errorCode);
+        assertEquals(0, debugData.size());
+      }
+    });
+  }
+
+  @Test public void goAwayWithDebugDataRoundTrip() throws IOException {
+    final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
+    final ByteString expectedData = ByteString.encodeUtf8("abcdefgh");
+
+    // Compose the expected GOAWAY frame without debug data.
+    frame.writeShort(8 + expectedData.size());
+    frame.writeByte(Http20Draft13.TYPE_GOAWAY);
+    frame.writeByte(0); // no flags.
+    frame.writeInt(0); // connection-scope
+    frame.writeInt(0); // never read any stream!
+    frame.writeInt(expectedError.httpCode);
+    frame.write(expectedData.toByteArray());
+
+    // Check writer sends the same bytes.
+    assertEquals(frame, sendGoAway(0, expectedError, expectedData.toByteArray()));
+
+    fr.nextFrame(new BaseTestHandler() {
+      @Override public void goAway(
+          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
+        assertEquals(0, lastGoodStreamId);
+        assertEquals(expectedError, errorCode);
+        assertEquals(expectedData, debugData);
+      }
+    });
+  }
+
+  @Test public void frameSizeError() throws IOException {
+    Http20Draft13.Writer writer = new Http20Draft13.Writer(new Buffer(), true);
+
+    try {
+      writer.frameHeader(0, 16384, Http20Draft13.TYPE_DATA, FLAG_NONE);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("FRAME_SIZE_ERROR length > 16383: 16384", e.getMessage());
+    }
+  }
+
+  @Test public void streamIdHasReservedBit() throws IOException {
+    Http20Draft13.Writer writer = new Http20Draft13.Writer(new Buffer(), true);
+
+    try {
+      int streamId = 3;
+      streamId |= 1L << 31; // set reserved bit
+      writer.frameHeader(streamId, Http20Draft13.MAX_FRAME_SIZE, Http20Draft13.TYPE_DATA, FLAG_NONE);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("reserved bit set: -2147483645", e.getMessage());
+    }
+  }
+
+  private Buffer literalHeaders(List<Header> sentHeaders) throws IOException {
+    Buffer out = new Buffer();
+    new HpackDraft08.Writer(out).writeHeaders(sentHeaders);
+    return out;
+  }
+
+  private Buffer sendHeaderFrames(boolean outFinished, List<Header> headers) throws IOException {
+    Buffer out = new Buffer();
+    new Http20Draft13.Writer(out, true).headers(outFinished, expectedStreamId, headers);
+    return out;
+  }
+
+  private Buffer sendPushPromiseFrames(int streamId, List<Header> headers) throws IOException {
+    Buffer out = new Buffer();
+    new Http20Draft13.Writer(out, true).pushPromise(expectedStreamId, streamId, headers);
+    return out;
+  }
+
+  private Buffer sendPingFrame(boolean ack, int payload1, int payload2) throws IOException {
+    Buffer out = new Buffer();
+    new Http20Draft13.Writer(out, true).ping(ack, payload1, payload2);
+    return out;
+  }
+
+  private Buffer sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
+      throws IOException {
+    Buffer out = new Buffer();
+    new Http20Draft13.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
+    return out;
+  }
+
+  private Buffer sendDataFrame(Buffer data) throws IOException {
+    Buffer out = new Buffer();
+    new Http20Draft13.Writer(out, true).dataFrame(expectedStreamId, FLAG_NONE, data,
+        (int) data.size());
+    return out;
+  }
+
+  private Buffer windowUpdate(long windowSizeIncrement) throws IOException {
+    Buffer out = new Buffer();
+    new Http20Draft13.Writer(out, true).windowUpdate(expectedStreamId, windowSizeIncrement);
+    return out;
+  }
+
+  private FrameReader.Handler assertHeaderBlock() {
+    return new BaseTestHandler() {
+      @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
+          int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
+        assertFalse(outFinished);
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(-1, associatedStreamId);
+        assertEquals(headerEntries("foo", "barrr", "baz", "qux"), headerBlock);
+        assertEquals(HeadersMode.HTTP_20_HEADERS, headersMode);
+      }
+    };
+  }
+
+  private FrameReader.Handler assertData() {
+    return new BaseTestHandler() {
+      @Override public void data(boolean inFinished, int streamId, BufferedSource source,
+          int length) throws IOException {
+        assertFalse(inFinished);
+        assertEquals(expectedStreamId, streamId);
+        assertEquals(1123, length);
+        ByteString data = source.readByteString(length);
+        for (byte b : data.toByteArray()) {
+          assertEquals(2, b);
+        }
+      }
+    };
+  }
+
+  private static Buffer gzip(byte[] data) throws IOException {
+    Buffer buffer = new Buffer();
+    Okio.buffer(new GzipSink(buffer)).write(data).close();
+    return buffer;
+  }
+
+  /** Create a sufficiently large header set to overflow Http20Draft12.MAX_FRAME_SIZE bytes. */
+  private static List<Header> largeHeaders() {
+    String[] nameValues = new String[32];
+    char[] chars = new char[512];
+    for (int i = 0; i < nameValues.length;) {
+      Arrays.fill(chars, (char) i);
+      nameValues[i++] = nameValues[i++] = String.valueOf(chars);
+    }
+    return headerEntries(nameValues);
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2ConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2ConnectionTest.java
new file mode 100644
index 0000000000..0aee3bfaf7
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http2ConnectionTest.java
@@ -0,0 +1,509 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Source;
+import org.junit.After;
+import org.junit.Test;
+
+import static com.squareup.okhttp.internal.Util.headerEntries;
+import static com.squareup.okhttp.internal.spdy.ErrorCode.CANCEL;
+import static com.squareup.okhttp.internal.spdy.ErrorCode.PROTOCOL_ERROR;
+import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
+import static com.squareup.okhttp.internal.spdy.Settings.PERSIST_VALUE;
+import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_DATA;
+import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_HEADERS;
+import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_PING;
+import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_RST_STREAM;
+import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_SETTINGS;
+import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_WINDOW_UPDATE;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class Http2ConnectionTest {
+  private static final Variant HTTP_2 = new Http20Draft13();
+  private final MockSpdyPeer peer = new MockSpdyPeer();
+
+  @After public void tearDown() throws Exception {
+    peer.close();
+  }
+
+  @Test public void serverPingsClientHttp2() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    // write the mocking script
+    peer.sendFrame().ping(false, 2, 3);
+    peer.acceptFrame(); // PING
+    peer.play();
+
+    // play it back
+    connection(peer, HTTP_2);
+
+    // verify the peer received what was expected
+    MockSpdyPeer.InFrame ping = peer.takeFrame();
+    assertEquals(TYPE_PING, ping.type);
+    assertEquals(0, ping.streamId);
+    assertEquals(2, ping.payload1);
+    assertEquals(3, ping.payload2);
+    assertTrue(ping.ack);
+  }
+
+  @Test public void clientPingsServerHttp2() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    // write the mocking script
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 5);
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, HTTP_2);
+    Ping ping = connection.ping();
+    assertTrue(ping.roundTripTime() > 0);
+    assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
+
+    // verify the peer received what was expected
+    MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
+    assertEquals(0, pingFrame.streamId);
+    assertEquals(1, pingFrame.payload1);
+    assertEquals(0x4f4b6f6b, pingFrame.payload2); // connection.ping() sets this.
+    assertFalse(pingFrame.ack);
+  }
+
+  @Test public void peerHttp2ServerLowersInitialWindowSize() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    Settings initial = new Settings();
+    initial.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 1684);
+    Settings shouldntImpactConnection = new Settings();
+    shouldntImpactConnection.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 3368);
+
+    peer.sendFrame().settings(initial);
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().settings(shouldntImpactConnection);
+    peer.acceptFrame(); // ACK 2
+    peer.acceptFrame(); // HEADERS
+    peer.play();
+
+    SpdyConnection connection = connection(peer, HTTP_2);
+
+    // Default is 64KiB - 1.
+    assertEquals(65535, connection.peerSettings.getInitialWindowSize(-1));
+
+    // Verify the peer received the ACK.
+    MockSpdyPeer.InFrame ackFrame = peer.takeFrame();
+    assertEquals(TYPE_SETTINGS, ackFrame.type);
+    assertEquals(0, ackFrame.streamId);
+    assertTrue(ackFrame.ack);
+    ackFrame = peer.takeFrame();
+    assertEquals(TYPE_SETTINGS, ackFrame.type);
+    assertEquals(0, ackFrame.streamId);
+    assertTrue(ackFrame.ack);
+
+    // This stream was created *after* the connection settings were adjusted.
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
+
+    assertEquals(3368, connection.peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
+    assertEquals(1684, connection.bytesLeftInWriteWindow); // initial wasn't affected.
+    // New Stream is has the most recent initial window size.
+    assertEquals(3368, stream.bytesLeftInWriteWindow);
+  }
+
+  @Test public void peerHttp2ServerZerosCompressionTable() throws Exception {
+    boolean client = false; // Peer is server, so we are client.
+    Settings settings = new Settings();
+    settings.set(Settings.HEADER_TABLE_SIZE, PERSIST_VALUE, 0);
+
+    SpdyConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
+
+    // verify the peer's settings were read and applied.
+    assertEquals(0, connection.peerSettings.getHeaderTableSize());
+    Http20Draft13.Reader frameReader = (Http20Draft13.Reader) connection.readerRunnable.frameReader;
+    assertEquals(0, frameReader.hpackReader.maxHeaderTableByteCount());
+    // TODO: when supported, check the frameWriter's compression table is unaffected.
+  }
+
+  @Test public void peerHttp2ClientDisablesPush() throws Exception {
+    boolean client = false; // Peer is client, so we are server.
+    Settings settings = new Settings();
+    settings.set(Settings.ENABLE_PUSH, 0, 0); // The peer client disables push.
+
+    SpdyConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
+
+    // verify the peer's settings were read and applied.
+    assertFalse(connection.peerSettings.getEnablePush(true));
+  }
+
+  @Test public void receiveGoAwayHttp2() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM 3
+    peer.acceptFrame(); // SYN_STREAM 5
+    peer.sendFrame().goAway(3, PROTOCOL_ERROR, Util.EMPTY_BYTE_ARRAY);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // DATA STREAM 3
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, HTTP_2);
+    SpdyStream stream1 = connection.newStream(headerEntries("a", "android"), true, true);
+    SpdyStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
+    connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
+    BufferedSink sink1 = Okio.buffer(stream1.getSink());
+    BufferedSink sink2 = Okio.buffer(stream2.getSink());
+    sink1.writeUtf8("abc");
+    try {
+      sink2.writeUtf8("abc");
+      sink2.flush();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
+    }
+    sink1.writeUtf8("def");
+    sink1.close();
+    try {
+      connection.newStream(headerEntries("c", "cola"), true, true);
+      fail();
+    } catch (IOException expected) {
+      assertEquals("shutdown", expected.getMessage());
+    }
+    assertTrue(stream1.isOpen());
+    assertFalse(stream2.isOpen());
+    assertEquals(1, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    MockSpdyPeer.InFrame synStream1 = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream1.type);
+    MockSpdyPeer.InFrame synStream2 = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream2.type);
+    MockSpdyPeer.InFrame ping = peer.takeFrame();
+    assertEquals(TYPE_PING, ping.type);
+    MockSpdyPeer.InFrame data1 = peer.takeFrame();
+    assertEquals(TYPE_DATA, data1.type);
+    assertEquals(3, data1.streamId);
+    assertTrue(Arrays.equals("abcdef".getBytes("UTF-8"), data1.data));
+  }
+
+  @Test public void readSendsWindowUpdateHttp2() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    int windowSize = 100;
+    int windowUpdateThreshold = 50;
+
+    // Write the mocking script.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    for (int i = 0; i < 3; i++) {
+      // Send frames of summing to size 50, which is windowUpdateThreshold.
+      peer.sendFrame().data(false, 3, data(24));
+      peer.sendFrame().data(false, 3, data(25));
+      peer.sendFrame().data(false, 3, data(1));
+      peer.acceptFrame(); // connection WINDOW UPDATE
+      peer.acceptFrame(); // stream WINDOW UPDATE
+    }
+    peer.sendFrame().data(true, 3, data(0));
+    peer.play();
+
+    // Play it back.
+    SpdyConnection connection = connection(peer, HTTP_2);
+    connection.okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, windowSize);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), false, true);
+    assertEquals(0, stream.unacknowledgedBytesRead);
+    assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
+    Source in = stream.getSource();
+    Buffer buffer = new Buffer();
+    buffer.writeAll(in);
+    assertEquals(-1, in.read(buffer, 1));
+    assertEquals(150, buffer.size());
+
+    MockSpdyPeer.InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    for (int i = 0; i < 3; i++) {
+      List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
+      for (int j = 0; j < 2; j++) {
+        MockSpdyPeer.InFrame windowUpdate = peer.takeFrame();
+        assertEquals(TYPE_WINDOW_UPDATE, windowUpdate.type);
+        windowUpdateStreamIds.add(windowUpdate.streamId);
+        assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
+      }
+      assertTrue(windowUpdateStreamIds.contains(0)); // connection
+      assertTrue(windowUpdateStreamIds.contains(3)); // stream
+    }
+  }
+
+  private Buffer data(int byteCount) {
+    return new Buffer().write(new byte[byteCount]);
+  }
+
+  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdateHttp2() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    // Write the mocking script.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 3, data(0));
+    peer.play();
+
+    // Play it back.
+    SpdyConnection connection = connection(peer, HTTP_2);
+    SpdyStream client = connection.newStream(headerEntries("b", "banana"), false, true);
+    assertEquals(-1, client.getSource().read(new Buffer(), 1));
+
+    // Verify the peer received what was expected.
+    MockSpdyPeer.InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    assertEquals(3, peer.frameCount());
+  }
+
+  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdateHttp2() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    // Write the mocking script.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // DATA
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.play();
+
+    // Play it back.
+    SpdyConnection connection = connection(peer, HTTP_2);
+    SpdyStream client = connection.newStream(headerEntries("b", "banana"), true, true);
+    BufferedSink out = Okio.buffer(client.getSink());
+    out.write(Util.EMPTY_BYTE_ARRAY);
+    out.flush();
+    out.close();
+
+    // Verify the peer received what was expected.
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(TYPE_DATA, peer.takeFrame().type);
+    assertEquals(3, peer.frameCount());
+  }
+
+  @Test public void maxFrameSizeHonored() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    byte[] buff = new byte[HTTP_2.maxFrameSize() + 1];
+    Arrays.fill(buff, (byte) '*');
+
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // DATA
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, HTTP_2);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    BufferedSink out = Okio.buffer(stream.getSink());
+    out.write(buff);
+    out.flush();
+    out.close();
+
+    MockSpdyPeer.InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    MockSpdyPeer.InFrame data = peer.takeFrame();
+    assertEquals(HTTP_2.maxFrameSize(), data.data.length);
+    data = peer.takeFrame();
+    assertEquals(1, data.data.length);
+  }
+
+  @Test public void pushPromiseStream() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    final List<Header> expectedRequestHeaders = Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/cached")
+    );
+    peer.sendFrame().pushPromise(3, 2, expectedRequestHeaders);
+    final List<Header> expectedResponseHeaders = Arrays.asList(
+        new Header(Header.RESPONSE_STATUS, "200")
+    );
+    peer.sendFrame().synReply(true, 2, expectedResponseHeaders);
+    peer.sendFrame().data(true, 3, data(0));
+    peer.play();
+
+    RecordingPushObserver observer = new RecordingPushObserver();
+
+    // play it back
+    SpdyConnection connection = connectionBuilder(peer, HTTP_2)
+        .pushObserver(observer).build();
+    SpdyStream client = connection.newStream(headerEntries("b", "banana"), false, true);
+    assertEquals(-1, client.getSource().read(new Buffer(), 1));
+
+    // verify the peer received what was expected
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+
+    assertEquals(expectedRequestHeaders, observer.takeEvent());
+    assertEquals(expectedResponseHeaders, observer.takeEvent());
+  }
+
+  @Test public void doublePushPromise() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    // write the mocking script
+    peer.sendFrame().pushPromise(3, 2, headerEntries("a", "android"));
+    peer.acceptFrame(); // SYN_REPLY
+    peer.sendFrame().pushPromise(3, 2, headerEntries("b", "banana"));
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connectionBuilder(peer, HTTP_2).build();
+    connection.newStream(headerEntries("b", "banana"), false, true);
+
+    // verify the peer received what was expected
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(PROTOCOL_ERROR, peer.takeFrame().errorCode);
+  }
+
+  @Test public void pushPromiseStreamsAutomaticallyCancel() throws Exception {
+    peer.setVariantAndClient(HTTP_2, false);
+
+    // write the mocking script
+    peer.sendFrame().pushPromise(3, 2, Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/cached")
+    ));
+    peer.sendFrame().synReply(true, 2, Arrays.asList(
+        new Header(Header.RESPONSE_STATUS, "200")
+    ));
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    connectionBuilder(peer, HTTP_2)
+        .pushObserver(PushObserver.CANCEL).build();
+
+    // verify the peer received what was expected
+    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
+    assertEquals(TYPE_RST_STREAM, rstStream.type);
+    assertEquals(2, rstStream.streamId);
+    assertEquals(CANCEL, rstStream.errorCode);
+  }
+
+  private SpdyConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings settings)
+      throws IOException, InterruptedException {
+    peer.setVariantAndClient(HTTP_2, client);
+    peer.sendFrame().settings(settings);
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, HTTP_2);
+
+    // verify the peer received the ACK
+    MockSpdyPeer.InFrame ackFrame = peer.takeFrame();
+    assertEquals(TYPE_SETTINGS, ackFrame.type);
+    assertEquals(0, ackFrame.streamId);
+    assertTrue(ackFrame.ack);
+
+    connection.ping().roundTripTime(); // Ensure that settings have been applied before returning.
+    return connection;
+  }
+
+  private SpdyConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
+    return connectionBuilder(peer, variant).build();
+  }
+
+  private SpdyConnection.Builder connectionBuilder(MockSpdyPeer peer, Variant variant)
+      throws IOException {
+    return new SpdyConnection.Builder(true, peer.openSocket())
+        .pushObserver(IGNORE)
+        .protocol(variant.getProtocol());
+  }
+
+  static final PushObserver IGNORE = new PushObserver() {
+
+    @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
+      return false;
+    }
+
+    @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
+      return false;
+    }
+
+    @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
+        boolean last) throws IOException {
+      source.skip(byteCount);
+      return false;
+    }
+
+    @Override public void onReset(int streamId, ErrorCode errorCode) {
+    }
+  };
+
+  private static class RecordingPushObserver implements PushObserver {
+    final List<Object> events = new ArrayList<>();
+
+    public synchronized Object takeEvent() throws InterruptedException {
+      while (events.isEmpty()) {
+        wait();
+      }
+      return events.remove(0);
+    }
+
+    @Override public synchronized boolean onRequest(int streamId, List<Header> requestHeaders) {
+      assertEquals(2, streamId);
+      events.add(requestHeaders);
+      notifyAll();
+      return false;
+    }
+
+    @Override public synchronized boolean onHeaders(
+        int streamId, List<Header> responseHeaders, boolean last) {
+      assertEquals(2, streamId);
+      assertTrue(last);
+      events.add(responseHeaders);
+      notifyAll();
+      return false;
+    }
+
+    @Override public synchronized boolean onData(
+        int streamId, BufferedSource source, int byteCount, boolean last) {
+      events.add(new AssertionError("onData"));
+      notifyAll();
+      return false;
+    }
+
+    @Override public synchronized void onReset(int streamId, ErrorCode errorCode) {
+      events.add(new AssertionError("onReset"));
+      notifyAll();
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index 014684a831..7e1823b73d 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -42,8 +42,8 @@
   private Variant variant = new Spdy3();
   private final Buffer bytesOut = new Buffer();
   private FrameWriter frameWriter = variant.newWriter(bytesOut, client);
-  private final List<OutFrame> outFrames = new ArrayList<OutFrame>();
-  private final BlockingQueue<InFrame> inFrames = new LinkedBlockingQueue<InFrame>();
+  private final List<OutFrame> outFrames = new ArrayList<>();
+  private final BlockingQueue<InFrame> inFrames = new LinkedBlockingQueue<>();
   private int port;
   private final ExecutorService executor = Executors.newSingleThreadExecutor(
       Util.threadFactory("MockSpdyPeer", false));
@@ -192,7 +192,6 @@ private OutFrame(int sequence, long start, int truncateToLength) {
     public boolean inFinished;
     public int streamId;
     public int associatedStreamId;
-    public int priority;
     public ErrorCode errorCode;
     public long windowSizeIncrement;
     public List<Header> headerBlock;
@@ -222,15 +221,13 @@ public InFrame(int sequence, FrameReader reader) {
     }
 
     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, List<Header> headerBlock,
-        HeadersMode headersMode) {
+        int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Spdy3.TYPE_HEADERS;
       this.outFinished = outFinished;
       this.inFinished = inFinished;
       this.streamId = streamId;
       this.associatedStreamId = associatedStreamId;
-      this.priority = priority;
       this.headerBlock = headerBlock;
       this.headersMode = headersMode;
     }
@@ -274,16 +271,22 @@ public InFrame(int sequence, FrameReader reader) {
       this.windowSizeIncrement = windowSizeIncrement;
     }
 
-    @Override public void priority(int streamId, int priority) {
+    @Override public void priority(int streamId, int streamDependency, int weight,
+        boolean exclusive) {
       throw new UnsupportedOperationException();
     }
 
     @Override
     public void pushPromise(int streamId, int associatedStreamId, List<Header> headerBlock) {
-      this.type = Http20Draft10.TYPE_PUSH_PROMISE;
+      this.type = Http20Draft13.TYPE_PUSH_PROMISE;
       this.streamId = streamId;
       this.associatedStreamId = associatedStreamId;
       this.headerBlock = headerBlock;
     }
+
+    @Override public void alternateService(int streamId, String origin, ByteString protocol,
+        String host, int port, long maxAge) {
+      throw new UnsupportedOperationException();
+    }
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
index e92ba18955..a33b1d52e0 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
@@ -46,12 +46,13 @@
     assertEquals(8096, settings.getHeaderTableSize());
 
     // WARNING: clash on flags between spdy/3 and HTTP/2!
-    assertEquals(-3, settings.getDownloadBandwidth(-3));
     assertEquals(true, settings.getEnablePush(true));
+    settings.set(Settings.ENABLE_PUSH, 0, 1);
+    assertEquals(true, settings.getEnablePush(false));
+    settings.clear();
+    assertEquals(-3, settings.getDownloadBandwidth(-3));
     settings.set(DOWNLOAD_BANDWIDTH, 0, 53);
     assertEquals(53, settings.getDownloadBandwidth(-3));
-    settings.set(Settings.ENABLE_PUSH, 0, 0);
-    assertEquals(false, settings.getEnablePush(true));
 
     assertEquals(-3, settings.getRoundTripTime(-3));
     settings.set(Settings.ROUND_TRIP_TIME, 0, 64);
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java
similarity index 70%
rename from okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java
index 07eb1cb6e8..a6c9703627 100644
--- a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3ConnectionTest.java
@@ -25,9 +25,9 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import okio.Buffer;
 import okio.BufferedSink;
-import okio.BufferedSource;
 import okio.ByteString;
 import okio.Okio;
+import okio.Sink;
 import okio.Source;
 import org.junit.After;
 import org.junit.Test;
@@ -46,16 +46,14 @@
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_HEADERS;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_PING;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_RST_STREAM;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_SETTINGS;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_WINDOW_UPDATE;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-public final class SpdyConnectionTest {
+public final class Spdy3ConnectionTest {
   private static final Variant SPDY3 = new Spdy3();
-  private static final Variant HTTP_20_DRAFT_09 = new Http20Draft10();
   private final MockSpdyPeer peer = new MockSpdyPeer();
 
   @After public void tearDown() throws Exception {
@@ -66,8 +64,8 @@
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame()
-        .synReply(false, 3, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("robot"));
+        .synReply(false, 1, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("robot"));
     peer.acceptFrame(); // DATA
     peer.play();
 
@@ -87,7 +85,7 @@
     assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
     assertFalse(synStream.inFinished);
     assertFalse(synStream.outFinished);
-    assertEquals(3, synStream.streamId);
+    assertEquals(1, synStream.streamId);
     assertEquals(0, synStream.associatedStreamId);
     assertEquals(headerEntries("b", "banana"), synStream.headerBlock);
     MockSpdyPeer.InFrame requestData = peer.takeFrame();
@@ -96,7 +94,7 @@
 
   @Test public void headersOnlyStreamIsClosedAfterReplyHeaders() throws Exception {
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
@@ -113,7 +111,7 @@
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(true, 3, headerEntries("a", "android"));
+    peer.sendFrame().synReply(true, 1, headerEntries("a", "android"));
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
@@ -142,7 +140,7 @@
         ":version", "HTTP/1.1",
         "content-type", "text/html");
     // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, 5, 129, pushHeaders);
+    peer.sendFrame().synStream(false, false, 2, 0, pushHeaders);
     peer.acceptFrame(); // SYN_REPLY
     peer.play();
 
@@ -153,7 +151,6 @@
         receiveCount.incrementAndGet();
         assertEquals(pushHeaders, stream.getRequestHeaders());
         assertEquals(null, stream.getErrorCode());
-        assertEquals(5, stream.getPriority());
         stream.reply(headerEntries("b", "banana"), true);
       }
     };
@@ -171,7 +168,7 @@
 
   @Test public void replyWithNoData() throws Exception {
     // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, headerEntries("a", "android"));
+    peer.sendFrame().synStream(false, false, 2, 0, headerEntries("a", "android"));
     peer.acceptFrame(); // SYN_REPLY
     peer.play();
 
@@ -212,26 +209,6 @@
     assertTrue(ping.ack);
   }
 
-  @Test public void serverPingsClientHttp2() throws Exception {
-    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
-
-    // write the mocking script
-    peer.sendFrame().ping(false, 2, 3);
-    peer.acceptFrame(); // PING
-    peer.play();
-
-    // play it back
-    connection(peer, HTTP_20_DRAFT_09);
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_PING, ping.type);
-    assertEquals(0, ping.streamId);
-    assertEquals(2, ping.payload1);
-    assertEquals(3, ping.payload2);
-    assertTrue(ping.ack);
-  }
-
   @Test public void clientPingsServer() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // PING
@@ -252,64 +229,6 @@
     assertFalse(pingFrame.ack);
   }
 
-  @Test public void clientPingsServerHttp2() throws Exception {
-    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
-
-    // write the mocking script
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 5);
-    peer.play();
-
-    // play it back
-    SpdyConnection connection = connection(peer, HTTP_20_DRAFT_09);
-    Ping ping = connection.ping();
-    assertTrue(ping.roundTripTime() > 0);
-    assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
-    assertEquals(0, pingFrame.streamId);
-    assertEquals(1, pingFrame.payload1);
-    assertEquals(0x4f4b6f6b, pingFrame.payload2); // connection.ping() sets this.
-    assertFalse(pingFrame.ack);
-  }
-
-  @Test public void peerHttp2ServerLowersInitialWindowSize() throws Exception {
-    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
-
-    Settings initial = new Settings();
-    initial.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 1684);
-    Settings shouldntImpactConnection = new Settings();
-    shouldntImpactConnection.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 3368);
-
-    peer.sendFrame().settings(initial);
-    peer.acceptFrame(); // ACK
-    peer.sendFrame().settings(shouldntImpactConnection);
-    peer.acceptFrame(); // ACK 2
-    peer.acceptFrame(); // HEADERS
-    peer.play();
-
-    SpdyConnection connection = connection(peer, HTTP_20_DRAFT_09);
-
-    // verify the peer received the ACK
-    MockSpdyPeer.InFrame ackFrame = peer.takeFrame();
-    assertEquals(TYPE_SETTINGS, ackFrame.type);
-    assertEquals(0, ackFrame.streamId);
-    assertTrue(ackFrame.ack);
-    ackFrame = peer.takeFrame();
-    assertEquals(TYPE_SETTINGS, ackFrame.type);
-    assertEquals(0, ackFrame.streamId);
-    assertTrue(ackFrame.ack);
-
-    // This stream was created *after* the connection settings were adjusted.
-    SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
-
-    assertEquals(3368, connection.peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
-    assertEquals(1684, connection.bytesLeftInWriteWindow); // initial wasn't affected.
-    // New Stream is has the most recent initial window size.
-    assertEquals(3368, stream.bytesLeftInWriteWindow);
-  }
-
   @Test public void unexpectedPingIsNotReturned() throws Exception {
     // write the mocking script
     peer.sendFrame().ping(false, 2, 0);
@@ -329,31 +248,6 @@
     assertEquals(4, ping4.payload1);
   }
 
-  @Test public void peerHttp2ServerZerosCompressionTable() throws Exception {
-    boolean client = false; // Peer is server, so we are client.
-    Settings settings = new Settings();
-    settings.set(Settings.HEADER_TABLE_SIZE, PERSIST_VALUE, 0);
-
-    SpdyConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
-
-    // verify the peer's settings were read and applied.
-    assertEquals(0, connection.peerSettings.getHeaderTableSize());
-    Http20Draft10.Reader frameReader = (Http20Draft10.Reader) connection.readerRunnable.frameReader;
-    assertEquals(0, frameReader.hpackReader.maxHeaderTableByteCount());
-    // TODO: when supported, check the frameWriter's compression table is unaffected.
-  }
-
-  @Test public void peerHttp2ClientDisablesPush() throws Exception {
-    boolean client = false; // Peer is client, so we are server.
-    Settings settings = new Settings();
-    settings.set(Settings.ENABLE_PUSH, 0, 0); // The peer client disables push.
-
-    SpdyConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
-
-    // verify the peer's settings were read and applied.
-    assertFalse(connection.peerSettings.getEnablePush(true));
-  }
-
   @Test public void serverSendsSettingsToClient() throws Exception {
     // write the mocking script
     Settings settings = new Settings();
@@ -476,7 +370,7 @@
   @Test public void clientClosesClientOutputStream() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
     peer.acceptFrame(); // TYPE_DATA
     peer.acceptFrame(); // TYPE_DATA with FLAG_FIN
     peer.acceptFrame(); // PING
@@ -521,7 +415,7 @@
   @Test public void serverClosesClientOutputStream() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().rstStream(3, CANCEL);
+    peer.sendFrame().rstStream(1, CANCEL);
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
@@ -649,8 +543,8 @@
   @Test public void serverClosesClientInputStream() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
-    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("square"));
+    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
+    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("square"));
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
@@ -674,9 +568,9 @@
   @Test public void remoteDoubleSynReply() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
     peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
+    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
     peer.sendFrame().ping(true, 1, 0);
     peer.acceptFrame(); // RST_STREAM
     peer.play();
@@ -701,15 +595,15 @@
     assertEquals(TYPE_PING, ping.type);
     MockSpdyPeer.InFrame rstStream = peer.takeFrame();
     assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(3, rstStream.streamId);
+    assertEquals(1, rstStream.streamId);
     assertEquals(STREAM_IN_USE, rstStream.errorCode);
   }
 
   @Test public void remoteDoubleSynStream() throws Exception {
     // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, headerEntries("a", "android"));
+    peer.sendFrame().synStream(false, false, 2, 0, headerEntries("a", "android"));
     peer.acceptFrame(); // SYN_REPLY
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, headerEntries("b", "banana"));
+    peer.sendFrame().synStream(false, false, 2, 0, headerEntries("b", "banana"));
     peer.acceptFrame(); // RST_STREAM
     peer.play();
 
@@ -739,9 +633,9 @@
   @Test public void remoteSendsDataAfterInFinished() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("robot"));
-    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("c3po")); // Ignored.
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("robot"));
+    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("c3po")); // Ignored.
     peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
     peer.acceptFrame(); // PING
     peer.play();
@@ -764,8 +658,8 @@
   @Test public void clientDoesNotLimitFlowControl() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("b", "banana"));
-    peer.sendFrame().data(false, 3, new Buffer().write(new byte[64 * 1024 + 1]));
+    peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
+    peer.sendFrame().data(false, 1, new Buffer().write(new byte[64 * 1024 + 1]));
     peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
     peer.acceptFrame(); // PING
     peer.play();
@@ -787,7 +681,7 @@
   @Test public void remoteSendsRefusedStreamBeforeReplyHeaders() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().rstStream(3, REFUSED_STREAM);
+    peer.sendFrame().rstStream(1, REFUSED_STREAM);
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame(); // PING
     peer.play();
@@ -814,30 +708,22 @@
 
 
   @Test public void receiveGoAway() throws Exception {
-    receiveGoAway(SPDY3);
-  }
-
-  @Test public void receiveGoAwayHttp2() throws Exception {
-    receiveGoAway(HTTP_20_DRAFT_09);
-  }
-
-  private void receiveGoAway(Variant variant) throws Exception {
-    peer.setVariantAndClient(variant, false);
+    peer.setVariantAndClient(SPDY3, false);
 
     // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM 1
     peer.acceptFrame(); // SYN_STREAM 3
-    peer.acceptFrame(); // SYN_STREAM 5
-    peer.sendFrame().goAway(3, PROTOCOL_ERROR, Util.EMPTY_BYTE_ARRAY);
+    peer.sendFrame().goAway(1, PROTOCOL_ERROR, Util.EMPTY_BYTE_ARRAY);
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // DATA STREAM 3
+    peer.acceptFrame(); // DATA STREAM 1
     peer.play();
 
     // play it back
-    SpdyConnection connection = connection(peer, variant);
+    SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream1 = connection.newStream(headerEntries("a", "android"), true, true);
     SpdyStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
-    connection.ping().roundTripTime(); // Ensure that the GO_AWAY has been received.
+    connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
     BufferedSink sink1 = Okio.buffer(stream1.getSink());
     BufferedSink sink2 = Okio.buffer(stream2.getSink());
     sink1.writeUtf8("abc");
@@ -856,6 +742,8 @@ private void receiveGoAway(Variant variant) throws Exception {
     } catch (IOException expected) {
       assertEquals("shutdown", expected.getMessage());
     }
+    assertTrue(stream1.isOpen());
+    assertFalse(stream2.isOpen());
     assertEquals(1, connection.openStreamCount());
 
     // verify the peer received what was expected
@@ -867,16 +755,16 @@ private void receiveGoAway(Variant variant) throws Exception {
     assertEquals(TYPE_PING, ping.type);
     MockSpdyPeer.InFrame data1 = peer.takeFrame();
     assertEquals(TYPE_DATA, data1.type);
-    assertEquals(3, data1.streamId);
+    assertEquals(1, data1.streamId);
     assertTrue(Arrays.equals("abcdef".getBytes("UTF-8"), data1.data));
   }
 
   @Test public void sendGoAway() throws Exception {
     // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM 3
+    peer.acceptFrame(); // SYN_STREAM 1
     peer.acceptFrame(); // GOAWAY
     peer.acceptFrame(); // PING
-    peer.sendFrame().synStream(false, false, 2, 0, 0, 0, headerEntries("b", "b")); // Should be ignored!
+    peer.sendFrame().synStream(false, false, 2, 0, headerEntries("b", "b")); // Should be ignored!
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
@@ -962,7 +850,7 @@ private void receiveGoAway(Variant variant) throws Exception {
     assertEquals(TYPE_GOAWAY, goaway.type);
     MockSpdyPeer.InFrame rstStream = peer.takeFrame();
     assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(3, rstStream.streamId);
+    assertEquals(1, rstStream.streamId);
   }
 
   @Test public void closeCancelsPings() throws Exception {
@@ -978,41 +866,102 @@ private void receiveGoAway(Variant variant) throws Exception {
     assertEquals(-1, ping.roundTripTime());
   }
 
-  @Test public void readTimeoutExpires() throws Exception {
+  @Test public void getResponseHeadersTimesOut() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // RST_STREAM
     peer.play();
 
     // play it back
     SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    stream.setReadTimeout(1000);
+    stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
+    long startNanos = System.nanoTime();
+    try {
+      stream.getResponseHeaders();
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
+  }
+
+  @Test public void readTimesOut() throws Exception {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    stream.readTimeout().timeout(500, TimeUnit.MILLISECONDS);
     Source source = stream.getSource();
     long startNanos = System.nanoTime();
     try {
       source.read(new Buffer(), 1);
       fail();
-    } catch (IOException expected) {
+    } catch (InterruptedIOException expected) {
     }
     long elapsedNanos = System.nanoTime() - startNanos;
-    assertEquals(1000d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
-    assertEquals(1, connection.openStreamCount());
-    connection.ping().roundTripTime(); // Prevent the peer from exiting prematurely.
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
 
     // verify the peer received what was expected
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
+  }
+
+  @Test public void writeTimesOutAwaitingStreamWindow() throws Exception {
+    // Set the peer's receive window to 5 bytes!
+    Settings peerSettings = new Settings().set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 5);
+
+    // write the mocking script
+    peer.sendFrame().settings(peerSettings);
+    peer.acceptFrame(); // PING
+    peer.sendFrame().ping(true, 1, 0);
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.acceptFrame(); // DATA
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, SPDY3);
+    connection.ping().roundTripTime(); // Make sure settings have been received.
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
+    Sink sink = stream.getSink();
+    sink.write(new Buffer().writeUtf8("abcde"), 5);
+    stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
+    long startNanos = System.nanoTime();
+    try {
+      sink.write(new Buffer().writeUtf8("f"), 1); // This will time out waiting on the write window.
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+    long elapsedNanos = System.nanoTime() - startNanos;
+    assertEquals(500d, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 200d /* 200ms delta */);
+    assertEquals(0, connection.openStreamCount());
+
+    // verify the peer received what was expected
+    assertEquals(TYPE_PING, peer.takeFrame().type);
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(TYPE_DATA, peer.takeFrame().type);
+    assertEquals(TYPE_RST_STREAM, peer.takeFrame().type);
   }
 
   @Test public void headers() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
-    peer.sendFrame().headers(3, headerEntries("c", "c3po"));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.sendFrame().headers(1, headerEntries("c", "c3po"));
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
 
@@ -1034,7 +983,7 @@ private void receiveGoAway(Variant variant) throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // PING
-    peer.sendFrame().headers(3, headerEntries("c", "c3po"));
+    peer.sendFrame().headers(1, headerEntries("c", "c3po"));
     peer.acceptFrame(); // RST_STREAM
     peer.sendFrame().ping(true, 1, 0);
     peer.play();
@@ -1062,50 +1011,41 @@ private void receiveGoAway(Variant variant) throws Exception {
   }
 
   @Test public void readSendsWindowUpdate() throws Exception {
-    readSendsWindowUpdate(SPDY3);
-  }
+    peer.setVariantAndClient(SPDY3, false);
 
-  @Test public void readSendsWindowUpdateHttp2() throws Exception {
-    readSendsWindowUpdate(HTTP_20_DRAFT_09);
-  }
-
-  private void readSendsWindowUpdate(Variant variant)
-      throws IOException, InterruptedException {
-    peer.setVariantAndClient(variant, false);
-
-    int windowUpdateThreshold = DEFAULT_INITIAL_WINDOW_SIZE / 2;
+    int windowSize = 100;
+    int windowUpdateThreshold = 50;
 
     // Write the mocking script.
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
     for (int i = 0; i < 3; i++) {
-      // Send frames summing to windowUpdateThreshold.
-      for (int sent = 0, count; sent < windowUpdateThreshold; sent += count) {
-        count = Math.min(variant.maxFrameSize(), windowUpdateThreshold - sent);
-        peer.sendFrame().data(false, 3, data(count));
-      }
+      // Send frames of summing to size 50, which is windowUpdateThreshold.
+      peer.sendFrame().data(false, 1, data(24));
+      peer.sendFrame().data(false, 1, data(25));
+      peer.sendFrame().data(false, 1, data(1));
       peer.acceptFrame(); // connection WINDOW UPDATE
       peer.acceptFrame(); // stream WINDOW UPDATE
     }
-    peer.sendFrame().data(true, 3, data(0));
+    peer.sendFrame().data(true, 1, data(0));
     peer.play();
 
     // Play it back.
-    SpdyConnection connection = connection(peer, variant);
+    SpdyConnection connection = connection(peer, SPDY3);
+    connection.okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, windowSize);
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), false, true);
     assertEquals(0, stream.unacknowledgedBytesRead);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     Source in = stream.getSource();
     Buffer buffer = new Buffer();
-    while (in.read(buffer, 1024) != -1) {
-      if (buffer.size() == 3 * windowUpdateThreshold) break;
-    }
+    buffer.writeAll(in);
     assertEquals(-1, in.read(buffer, 1));
+    assertEquals(150, buffer.size());
 
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
     assertEquals(TYPE_HEADERS, synStream.type);
     for (int i = 0; i < 3; i++) {
-      List<Integer> windowUpdateStreamIds = new ArrayList(2);
+      List<Integer> windowUpdateStreamIds = new ArrayList<>(2);
       for (int j = 0; j < 2; j++) {
         MockSpdyPeer.InFrame windowUpdate = peer.takeFrame();
         assertEquals(TYPE_WINDOW_UPDATE, windowUpdate.type);
@@ -1113,7 +1053,7 @@ private void readSendsWindowUpdate(Variant variant)
         assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
       }
       assertTrue(windowUpdateStreamIds.contains(0)); // connection
-      assertTrue(windowUpdateStreamIds.contains(3)); // stream
+      assertTrue(windowUpdateStreamIds.contains(1)); // stream
     }
   }
 
@@ -1122,25 +1062,16 @@ private Buffer data(int byteCount) {
   }
 
   @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdate() throws Exception {
-    serverSendsEmptyDataClientDoesntSendWindowUpdate(SPDY3);
-  }
-
-  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdateHttp2() throws Exception {
-    serverSendsEmptyDataClientDoesntSendWindowUpdate(HTTP_20_DRAFT_09);
-  }
-
-  private void serverSendsEmptyDataClientDoesntSendWindowUpdate(Variant variant)
-      throws IOException, InterruptedException {
-    peer.setVariantAndClient(variant, false);
+    peer.setVariantAndClient(SPDY3, false);
 
     // Write the mocking script.
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 3, data(0));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 1, data(0));
     peer.play();
 
     // Play it back.
-    SpdyConnection connection = connection(peer, variant);
+    SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream client = connection.newStream(headerEntries("b", "banana"), false, true);
     assertEquals(-1, client.getSource().read(new Buffer(), 1));
 
@@ -1151,25 +1082,16 @@ private void serverSendsEmptyDataClientDoesntSendWindowUpdate(Variant variant)
   }
 
   @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdate() throws Exception {
-    clientSendsEmptyDataServerDoesntSendWindowUpdate(SPDY3);
-  }
-
-  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdateHttp2() throws Exception {
-    clientSendsEmptyDataServerDoesntSendWindowUpdate(HTTP_20_DRAFT_09);
-  }
-
-  private void clientSendsEmptyDataServerDoesntSendWindowUpdate(Variant variant)
-      throws IOException, InterruptedException {
-    peer.setVariantAndClient(variant, false);
+    peer.setVariantAndClient(SPDY3, false);
 
     // Write the mocking script.
     peer.acceptFrame(); // SYN_STREAM
     peer.acceptFrame(); // DATA
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
     peer.play();
 
     // Play it back.
-    SpdyConnection connection = connection(peer, variant);
+    SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream client = connection.newStream(headerEntries("b", "banana"), true, true);
     BufferedSink out = Okio.buffer(client.getSink());
     out.write(Util.EMPTY_BYTE_ARRAY);
@@ -1182,102 +1104,11 @@ private void clientSendsEmptyDataServerDoesntSendWindowUpdate(Variant variant)
     assertEquals(3, peer.frameCount());
   }
 
-  @Test public void writeAwaitsWindowUpdate() throws Exception {
-    int framesThatFillWindow = roundUp(DEFAULT_INITIAL_WINDOW_SIZE, HTTP_20_DRAFT_09.maxFrameSize());
-
-    // Write the mocking script. This accepts more data frames than necessary!
-    peer.acceptFrame(); // SYN_STREAM
-    for (int i = 0; i < framesThatFillWindow; i++) {
-      peer.acceptFrame(); // DATA
-    }
-    peer.acceptFrame(); // DATA we won't be able to flush until a window update.
-    peer.play();
-
-    // Play it back.
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    out.write(new byte[DEFAULT_INITIAL_WINDOW_SIZE]);
-    out.flush();
-
-    // Check that we've filled the window for both the stream and also the connection.
-    assertEquals(0, connection.bytesLeftInWriteWindow);
-    assertEquals(0, connection.getStream(3).bytesLeftInWriteWindow);
-
-    out.writeByte('a');
-    assertFlushBlocks(out);
-
-    // receiving a window update on the connection isn't enough.
-    connection.readerRunnable.windowUpdate(0, 1);
-    assertFlushBlocks(out);
-
-    // receiving a window update on the stream will unblock the stream.
-    connection.readerRunnable.windowUpdate(3, 1);
-    out.flush();
-
-    // Verify the peer received what was expected.
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    for (int i = 0; i < framesThatFillWindow; i++) {
-      MockSpdyPeer.InFrame data = peer.takeFrame();
-      assertEquals(TYPE_DATA, data.type);
-    }
-  }
-
-  @Test public void initialSettingsWithWindowSizeAdjustsConnection() throws Exception {
-    int framesThatFillWindow = roundUp(DEFAULT_INITIAL_WINDOW_SIZE, HTTP_20_DRAFT_09.maxFrameSize());
-
-    // Write the mocking script. This accepts more data frames than necessary!
-    peer.acceptFrame(); // SYN_STREAM
-    for (int i = 0; i < framesThatFillWindow; i++) {
-      peer.acceptFrame(); // DATA on stream 3
-    }
-    peer.acceptFrame(); // DATA on stream 2
-    peer.play();
-
-    // Play it back.
-    SpdyConnection connection = connection(peer, SPDY3);
-    SpdyStream stream = connection.newStream(headerEntries("a", "apple"), true, true);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    out.write(new byte[DEFAULT_INITIAL_WINDOW_SIZE]);
-    out.flush();
-
-    // write 1 more than the window size
-    out.writeByte('a');
-    assertFlushBlocks(out);
-
-    // Check that we've filled the window for both the stream and also the connection.
-    assertEquals(0, connection.bytesLeftInWriteWindow);
-    assertEquals(0, connection.getStream(3).bytesLeftInWriteWindow);
-
-    // Receiving a Settings with a larger window size will unblock the streams.
-    Settings initial = new Settings();
-    initial.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, DEFAULT_INITIAL_WINDOW_SIZE + 1);
-    connection.readerRunnable.settings(false, initial);
-
-    assertEquals(1, connection.bytesLeftInWriteWindow);
-    assertEquals(1, connection.getStream(3).bytesLeftInWriteWindow);
-
-    // The stream should no longer be blocked.
-    out.flush();
-
-    assertEquals(0, connection.bytesLeftInWriteWindow);
-    assertEquals(0, connection.getStream(3).bytesLeftInWriteWindow);
-
-    // Settings after the initial do not affect the connection window size.
-    Settings next = new Settings();
-    next.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, DEFAULT_INITIAL_WINDOW_SIZE + 2);
-    connection.readerRunnable.settings(false, next);
-
-    assertEquals(0, connection.bytesLeftInWriteWindow); // connection wasn't affected.
-    assertEquals(1, connection.getStream(3).bytesLeftInWriteWindow);
-  }
-
   @Test public void testTruncatedDataFrame() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
-    peer.sendTruncatedFrame(8 + 100).data(false, 3, data(1024));
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.sendTruncatedFrame(8 + 100).data(false, 1, data(1024));
     peer.play();
 
     // play it back
@@ -1297,12 +1128,12 @@ private void clientSendsEmptyDataServerDoesntSendWindowUpdate(Variant variant)
     int framesThatFillWindow = roundUp(DEFAULT_INITIAL_WINDOW_SIZE, SPDY3.maxFrameSize());
 
     // Write the mocking script. This accepts more data frames than necessary!
-    peer.acceptFrame(); // SYN_STREAM on stream 3
+    peer.acceptFrame(); // SYN_STREAM on stream 1
     for (int i = 0; i < framesThatFillWindow; i++) {
-      peer.acceptFrame(); // DATA on stream 3
+      peer.acceptFrame(); // DATA on stream 1
     }
-    peer.acceptFrame(); // SYN_STREAM on stream 5
-    peer.acceptFrame(); // DATA on stream 5
+    peer.acceptFrame(); // SYN_STREAM on stream 2
+    peer.acceptFrame(); // DATA on stream 2
     peer.play();
 
     // Play it back.
@@ -1314,13 +1145,13 @@ private void clientSendsEmptyDataServerDoesntSendWindowUpdate(Variant variant)
 
     // Check that we've filled the window for both the stream and also the connection.
     assertEquals(0, connection.bytesLeftInWriteWindow);
-    assertEquals(0, connection.getStream(3).bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
 
     // receiving a window update on the the connection will unblock new streams.
     connection.readerRunnable.windowUpdate(0, 3);
 
     assertEquals(3, connection.bytesLeftInWriteWindow);
-    assertEquals(0, connection.getStream(3).bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
 
     // Another stream should be able to send data even though 1 is blocked.
     SpdyStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
@@ -1329,37 +1160,8 @@ private void clientSendsEmptyDataServerDoesntSendWindowUpdate(Variant variant)
     out2.flush();
 
     assertEquals(0, connection.bytesLeftInWriteWindow);
-    assertEquals(0, connection.getStream(3).bytesLeftInWriteWindow);
-    assertEquals(DEFAULT_INITIAL_WINDOW_SIZE - 3, connection.getStream(5).bytesLeftInWriteWindow);
-  }
-
-  @Test public void maxFrameSizeHonored() throws Exception {
-    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
-
-    byte[] buff = new byte[HTTP_20_DRAFT_09.maxFrameSize() + 1];
-    Arrays.fill(buff, (byte) '*');
-
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
-    peer.acceptFrame(); // DATA
-    peer.acceptFrame(); // DATA
-    peer.play();
-
-    // play it back
-    SpdyConnection connection = connection(peer, HTTP_20_DRAFT_09);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    BufferedSink out = Okio.buffer(stream.getSink());
-    out.write(buff);
-    out.flush();
-    out.close();
-
-    MockSpdyPeer.InFrame synStream = peer.takeFrame();
-    assertEquals(TYPE_HEADERS, synStream.type);
-    MockSpdyPeer.InFrame data = peer.takeFrame();
-    assertEquals(HTTP_20_DRAFT_09.maxFrameSize(), data.data.length);
-    data = peer.takeFrame();
-    assertEquals(1, data.data.length);
+    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
+    assertEquals(DEFAULT_INITIAL_WINDOW_SIZE - 3, connection.getStream(3).bytesLeftInWriteWindow);
   }
 
   /** https://github.com/square/okhttp/issues/333 */
@@ -1418,9 +1220,9 @@ private void headerBlockHasTrailingCompressedBytes(String frame, int length) thr
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     byte[] trailingCompressedBytes = ByteString.decodeBase64(frame).toByteArray();
-    trailingCompressedBytes[11] = 3; // Set SPDY/3 stream ID to 3.
+    trailingCompressedBytes[11] = 1; // Set SPDY/3 stream ID to 3.
     peer.sendFrame(trailingCompressedBytes);
-    peer.sendFrame().data(true, 3, new Buffer().writeUtf8("robot"));
+    peer.sendFrame().data(true, 1, new Buffer().writeUtf8("robot"));
     peer.acceptFrame(); // DATA
     peer.play();
 
@@ -1432,109 +1234,6 @@ private void headerBlockHasTrailingCompressedBytes(String frame, int length) thr
     assertStreamData("robot", stream.getSource());
   }
 
-  @Test public void pushPromiseStream() throws Exception {
-    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
-
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
-    peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
-    final List<Header> expectedRequestHeaders = Arrays.asList(
-        new Header(Header.TARGET_METHOD, "GET"),
-        new Header(Header.TARGET_SCHEME, "https"),
-        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
-        new Header(Header.TARGET_PATH, "/cached")
-    );
-    peer.sendFrame().pushPromise(3, 2, expectedRequestHeaders);
-    final List<Header> expectedResponseHeaders = Arrays.asList(
-        new Header(Header.RESPONSE_STATUS, "200")
-    );
-    peer.sendFrame().synReply(true, 2, expectedResponseHeaders);
-    peer.sendFrame().data(true, 3, data(0));
-    peer.play();
-
-    RecordingPushObserver observer = new RecordingPushObserver();
-
-    // play it back
-    SpdyConnection connection = connectionBuilder(peer, HTTP_20_DRAFT_09)
-        .pushObserver(observer).build();
-    SpdyStream client = connection.newStream(headerEntries("b", "banana"), false, true);
-    assertEquals(-1, client.getSource().read(new Buffer(), 1));
-
-    // verify the peer received what was expected
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-
-    assertEquals(expectedRequestHeaders, observer.takeEvent());
-    assertEquals(expectedResponseHeaders, observer.takeEvent());
-  }
-
-  @Test public void doublePushPromise() throws Exception {
-    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
-
-    // write the mocking script
-    peer.sendFrame().pushPromise(3, 2, headerEntries("a", "android"));
-    peer.acceptFrame(); // SYN_REPLY
-    peer.sendFrame().pushPromise(3, 2, headerEntries("b", "banana"));
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    SpdyConnection connection = connectionBuilder(peer, HTTP_20_DRAFT_09).build();
-    connection.newStream(headerEntries("b", "banana"), false, true);
-
-    // verify the peer received what was expected
-    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
-    assertEquals(PROTOCOL_ERROR, peer.takeFrame().errorCode);
-  }
-
-  @Test public void pushPromiseStreamsAutomaticallyCancel() throws Exception {
-    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
-
-    // write the mocking script
-    peer.sendFrame().pushPromise(3, 2, Arrays.asList(
-        new Header(Header.TARGET_METHOD, "GET"),
-        new Header(Header.TARGET_SCHEME, "https"),
-        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
-        new Header(Header.TARGET_PATH, "/cached")
-    ));
-    peer.sendFrame().synReply(true, 2, Arrays.asList(
-        new Header(Header.RESPONSE_STATUS, "200")
-    ));
-    peer.acceptFrame(); // RST_STREAM
-    peer.play();
-
-    // play it back
-    connectionBuilder(peer, HTTP_20_DRAFT_09)
-        .pushObserver(PushObserver.CANCEL).build();
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(2, rstStream.streamId);
-    assertEquals(CANCEL, rstStream.errorCode);
-  }
-
-  private SpdyConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings settings)
-      throws IOException, InterruptedException {
-    peer.setVariantAndClient(HTTP_20_DRAFT_09, client);
-    peer.sendFrame().settings(settings);
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 0);
-    peer.play();
-
-    // play it back
-    SpdyConnection connection = connection(peer, HTTP_20_DRAFT_09);
-
-    // verify the peer received the ACK
-    MockSpdyPeer.InFrame ackFrame = peer.takeFrame();
-    assertEquals(TYPE_SETTINGS, ackFrame.type);
-    assertEquals(0, ackFrame.streamId);
-    assertTrue(ackFrame.ack);
-
-    connection.ping().roundTripTime(); // Ensure that settings have been applied before returning.
-    return connection;
-  }
-
   private SpdyConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
     return connectionBuilder(peer, variant).build();
   }
@@ -1542,7 +1241,6 @@ private SpdyConnection connection(MockSpdyPeer peer, Variant variant) throws IOE
   private SpdyConnection.Builder connectionBuilder(MockSpdyPeer peer, Variant variant)
       throws IOException {
     return new SpdyConnection.Builder(true, peer.openSocket())
-        .pushObserver(IGNORE)
         .protocol(variant.getProtocol());
   }
 
@@ -1578,63 +1276,4 @@ private void interruptAfterDelay(final long delayMillis) {
   static int roundUp(int num, int divisor) {
     return (num + divisor - 1) / divisor;
   }
-
-  static final PushObserver IGNORE = new PushObserver() {
-
-    @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
-      return false;
-    }
-
-    @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
-      return false;
-    }
-
-    @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
-        boolean last) throws IOException {
-      source.skip(byteCount);
-      return false;
-    }
-
-    @Override public void onReset(int streamId, ErrorCode errorCode) {
-    }
-  };
-
-  private static class RecordingPushObserver implements PushObserver {
-    final List<Object> events = new ArrayList<Object>();
-
-    public synchronized Object takeEvent() throws InterruptedException {
-      while (events.isEmpty()) {
-        wait();
-      }
-      return events.remove(0);
-    }
-
-    @Override public synchronized boolean onRequest(int streamId, List<Header> requestHeaders) {
-      assertEquals(2, streamId);
-      events.add(requestHeaders);
-      notifyAll();
-      return false;
-    }
-
-    @Override public synchronized boolean onHeaders(
-        int streamId, List<Header> responseHeaders, boolean last) {
-      assertEquals(2, streamId);
-      assertTrue(last);
-      events.add(responseHeaders);
-      notifyAll();
-      return false;
-    }
-
-    @Override public synchronized boolean onData(
-        int streamId, BufferedSource source, int byteCount, boolean last) {
-      events.add(new AssertionError("onData"));
-      notifyAll();
-      return false;
-    }
-
-    @Override public synchronized void onReset(int streamId, ErrorCode errorCode) {
-      events.add(new AssertionError("onReset"));
-      notifyAll();
-    }
-  }
 }
diff --git a/okhttp-urlconnection/pom.xml b/okhttp-urlconnection/pom.xml
new file mode 100644
index 0000000000..dc743a9950
--- /dev/null
+++ b/okhttp-urlconnection/pom.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp</groupId>
+    <artifactId>parent</artifactId>
+    <version>2.0.1-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-urlconnection</artifactId>
+  <name>OkHttp URLConnection</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <configuration>
+          <excludePackageNames>com.squareup.okhttp.internal.*</excludePackageNames>
+          <links>
+            <link>http://square.github.io/okhttp/javadoc/</link>
+          </links>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp-urlconnection/src/main/java/com/squareup/okhttp/OkUrlFactory.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/OkUrlFactory.java
new file mode 100644
index 0000000000..2c5f95ff79
--- /dev/null
+++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/OkUrlFactory.java
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.InternalCache;
+import com.squareup.okhttp.internal.huc.CacheAdapter;
+import com.squareup.okhttp.internal.huc.HttpURLConnectionImpl;
+import com.squareup.okhttp.internal.huc.HttpsURLConnectionImpl;
+import java.net.HttpURLConnection;
+import java.net.Proxy;
+import java.net.ResponseCache;
+import java.net.URL;
+import java.net.URLConnection;
+import java.net.URLStreamHandler;
+import java.net.URLStreamHandlerFactory;
+
+public final class OkUrlFactory implements URLStreamHandlerFactory, Cloneable {
+  private final OkHttpClient client;
+
+  public OkUrlFactory(OkHttpClient client) {
+    this.client = client;
+  }
+
+  public OkHttpClient client() {
+    return client;
+  }
+
+  /** Sets the response cache to be used to read and write cached responses. */
+  OkUrlFactory setResponseCache(ResponseCache responseCache) {
+    client.setInternalCache(responseCache != null ? new CacheAdapter(responseCache) : null);
+    return this;
+  }
+
+  ResponseCache getResponseCache() {
+    InternalCache cache = client.internalCache();
+    return cache instanceof CacheAdapter ? ((CacheAdapter) cache).getDelegate() : null;
+  }
+
+  /**
+   * Returns a copy of this stream handler factory that includes a shallow copy
+   * of the internal {@linkplain OkHttpClient HTTP client}.
+   */
+  @Override public OkUrlFactory clone() {
+    return new OkUrlFactory(client.clone());
+  }
+
+  public HttpURLConnection open(URL url) {
+    return open(url, client.getProxy());
+  }
+
+  HttpURLConnection open(URL url, Proxy proxy) {
+    String protocol = url.getProtocol();
+    OkHttpClient copy = client.copyWithDefaults();
+    copy.setProxy(proxy);
+
+    if (protocol.equals("http")) return new HttpURLConnectionImpl(url, copy);
+    if (protocol.equals("https")) return new HttpsURLConnectionImpl(url, copy);
+    throw new IllegalArgumentException("Unexpected protocol: " + protocol);
+  }
+
+  /**
+   * Creates a URLStreamHandler as a {@link java.net.URL#setURLStreamHandlerFactory}.
+   *
+   * <p>This code configures OkHttp to handle all HTTP and HTTPS connections
+   * created with {@link java.net.URL#openConnection()}: <pre>   {@code
+   *
+   *   OkHttpClient okHttpClient = new OkHttpClient();
+   *   URL.setURLStreamHandlerFactory(new OkUrlFactory(okHttpClient));
+   * }</pre>
+   */
+  @Override public URLStreamHandler createURLStreamHandler(final String protocol) {
+    if (!protocol.equals("http") && !protocol.equals("https")) return null;
+
+    return new URLStreamHandler() {
+      @Override protected URLConnection openConnection(URL url) {
+        return open(url);
+      }
+
+      @Override protected URLConnection openConnection(URL url, Proxy proxy) {
+        return open(url, proxy);
+      }
+
+      @Override protected int getDefaultPort() {
+        if (protocol.equals("http")) return 80;
+        if (protocol.equals("https")) return 443;
+        throw new AssertionError();
+      }
+    };
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java
similarity index 73%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java
rename to okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java
index 932a07d9a1..13a34c032b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java
+++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/CacheAdapter.java
@@ -17,16 +17,19 @@
 
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseSource;
 import com.squareup.okhttp.internal.InternalCache;
+import com.squareup.okhttp.internal.http.CacheRequest;
+import com.squareup.okhttp.internal.http.CacheStrategy;
 import java.io.IOException;
-import java.net.CacheRequest;
+import java.io.OutputStream;
 import java.net.CacheResponse;
 import java.net.HttpURLConnection;
 import java.net.ResponseCache;
 import java.net.URI;
 import java.util.List;
 import java.util.Map;
+import okio.Okio;
+import okio.Sink;
 
 /** Adapts {@link ResponseCache} to {@link InternalCache}. */
 public final class CacheAdapter implements InternalCache {
@@ -40,8 +43,7 @@ public ResponseCache getDelegate() {
     return delegate;
   }
 
-  @Override
-  public Response get(Request request) throws IOException {
+  @Override public Response get(Request request) throws IOException {
     CacheResponse javaResponse = getJavaCachedResponse(request);
     if (javaResponse == null) {
       return null;
@@ -49,15 +51,26 @@ public Response get(Request request) throws IOException {
     return JavaApiConverter.createOkResponse(request, javaResponse);
   }
 
-  @Override
-  public CacheRequest put(Response response) throws IOException {
+  @Override public CacheRequest put(Response response) throws IOException {
     URI uri = response.request().uri();
     HttpURLConnection connection = JavaApiConverter.createJavaUrlConnection(response);
-    return delegate.put(uri, connection);
+    final java.net.CacheRequest request = delegate.put(uri, connection);
+    if (request == null) {
+      return null;
+    }
+    return new CacheRequest() {
+      @Override public Sink body() throws IOException {
+        OutputStream body = request.getBody();
+        return body != null ? Okio.sink(body) : null;
+      }
+
+      @Override public void abort() {
+        request.abort();
+      }
+    };
   }
 
-  @Override
-  public void remove(Request request) throws IOException {
+  @Override public void remove(Request request) throws IOException {
     // This method is treated as optional and there is no obvious way of implementing it with
     // ResponseCache. Removing items from the cache due to modifications made from this client is
     // not essential given that modifications could be made from any other client. We have to assume
@@ -65,8 +78,7 @@ public void remove(Request request) throws IOException {
     // cacheable or the client should be careful about caching it.
   }
 
-  @Override
-  public void update(Response cached, Response network) throws IOException {
+  @Override public void update(Response cached, Response network) throws IOException {
     // This method is treated as optional and there is no obvious way of implementing it with
     // ResponseCache. Updating headers is useful if the server changes the metadata for a resource
     // (e.g. max age) to extend or truncate the life of that resource in the cache. If the metadata
@@ -74,14 +86,12 @@ public void update(Response cached, Response network) throws IOException {
     // with the original cached response.
   }
 
-  @Override
-  public void trackConditionalCacheHit() {
-    // This method is treated as optional.
+  @Override public void trackConditionalCacheHit() {
+    // This method is optional.
   }
 
-  @Override
-  public void trackResponse(ResponseSource source) {
-    // This method is treated as optional.
+  @Override public void trackResponse(CacheStrategy cacheStrategy) {
+    // This method is optional.
   }
 
   /**
@@ -92,5 +102,4 @@ private CacheResponse getJavaCachedResponse(Request request) throws IOException
     Map<String, List<String>> headers = JavaApiConverter.extractJavaHeaders(request);
     return delegate.get(request.uri(), request.method(), headers);
   }
-
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/huc/DelegatingHttpsURLConnection.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/DelegatingHttpsURLConnection.java
similarity index 100%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/huc/DelegatingHttpsURLConnection.java
rename to okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/DelegatingHttpsURLConnection.java
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
similarity index 87%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
rename to okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
index 78cf9d0520..85fa7f3b8c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
+++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpURLConnectionImpl.java
@@ -78,6 +78,8 @@
   private int redirectionCount;
   protected IOException httpEngineFailure;
   protected HttpEngine httpEngine;
+  /** Lazily created (with synthetic headers) on first call to getHeaders(). */
+  private Headers responseHeaders;
 
   /**
    * The most recently attempted route. This will be null if we haven't sent a
@@ -133,13 +135,38 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
     }
   }
 
+  private Headers getHeaders() throws IOException {
+    if (responseHeaders == null) {
+      Response response = getResponse().getResponse();
+      Headers headers = response.headers();
+
+      responseHeaders = headers.newBuilder()
+          .add(Platform.get().getPrefix() + "-Response-Source", responseSourceHeader(response))
+          .build();
+    }
+    return responseHeaders;
+  }
+
+  private static String responseSourceHeader(Response response) {
+    if (response.networkResponse() == null) {
+      if (response.cacheResponse() == null) {
+        return "NONE";
+      }
+      return "CACHE " + response.code();
+    }
+    if (response.cacheResponse() == null) {
+      return "NETWORK " + response.code();
+    }
+    return "CONDITIONAL_CACHE " + response.networkResponse().code();
+  }
+
   /**
    * Returns the value of the field at {@code position}. Returns null if there
    * are fewer than {@code position} headers.
    */
   @Override public final String getHeaderField(int position) {
     try {
-      return getResponse().getResponse().headers().value(position);
+      return getHeaders().value(position);
     } catch (IOException e) {
       return null;
     }
@@ -152,10 +179,9 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
    */
   @Override public final String getHeaderField(String fieldName) {
     try {
-      Response response = getResponse().getResponse();
       return fieldName == null
-          ? StatusLine.get(response).toString()
-          : response.headers().get(fieldName);
+          ? StatusLine.get(getResponse().getResponse()).toString()
+          : getHeaders().get(fieldName);
     } catch (IOException e) {
       return null;
     }
@@ -163,7 +189,7 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
 
   @Override public final String getHeaderFieldKey(int position) {
     try {
-      return getResponse().getResponse().headers().name(position);
+      return getHeaders().name(position);
     } catch (IOException e) {
       return null;
     }
@@ -171,8 +197,8 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
 
   @Override public final Map<String, List<String>> getHeaderFields() {
     try {
-      Response response = getResponse().getResponse();
-      return OkHeaders.toMultimap(response.headers(), StatusLine.get(response).toString());
+      return OkHeaders.toMultimap(getHeaders(),
+          StatusLine.get(getResponse().getResponse()).toString());
     } catch (IOException e) {
       return Collections.emptyMap();
     }
@@ -242,6 +268,11 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
     client.setConnectTimeout(timeoutMillis, TimeUnit.MILLISECONDS);
   }
 
+  @Override
+  public void setInstanceFollowRedirects(boolean followRedirects) {
+    client.setFollowRedirects(followRedirects);
+  }
+
   @Override public int getConnectTimeout() {
     return client.getConnectTimeout();
   }
@@ -272,7 +303,9 @@ private void initHttpEngine() throws IOException {
           throw new ProtocolException(method + " does not support writing");
         }
       }
-      httpEngine = newHttpEngine(method, null, null);
+      // If the user set content length to zero, we know there will not be a request body.
+      RetryableSink requestBody = doOutput && fixedContentLength == 0 ? Util.emptySink() : null;
+      httpEngine = newHttpEngine(method, null, requestBody, null);
     } catch (IOException e) {
       httpEngineFailure = e;
       throw e;
@@ -280,7 +313,7 @@ private void initHttpEngine() throws IOException {
   }
 
   private HttpEngine newHttpEngine(String method, Connection connection,
-      RetryableSink requestBody) {
+      RetryableSink requestBody, Response priorResponse) {
     Request.Builder builder = new Request.Builder()
         .url(getURL())
         .method(method, null /* No body; that's passed separately. */);
@@ -291,6 +324,7 @@ private HttpEngine newHttpEngine(String method, Connection connection,
 
     boolean bufferRequestBody = false;
     if (HttpMethod.hasRequestBody(method)) {
+      // Specify how the request body is terminated.
       if (fixedContentLength != -1) {
         builder.header("Content-Length", Long.toString(fixedContentLength));
       } else if (chunkLength > 0) {
@@ -298,6 +332,15 @@ private HttpEngine newHttpEngine(String method, Connection connection,
       } else {
         bufferRequestBody = true;
       }
+
+      // Add a content type for the request body, if one isn't already present.
+      if (headers.get("Content-Type") == null) {
+        builder.header("Content-Type", "application/x-www-form-urlencoded");
+      }
+    }
+
+    if (headers.get("User-Agent") == null) {
+      builder.header("User-Agent", defaultUserAgent());
     }
 
     Request request = builder.build();
@@ -308,7 +351,13 @@ private HttpEngine newHttpEngine(String method, Connection connection,
       engineClient = client.clone().setCache(null);
     }
 
-    return new HttpEngine(engineClient, request, bufferRequestBody, connection, null, requestBody);
+    return new HttpEngine(engineClient, request, bufferRequestBody, connection, null, requestBody,
+        priorResponse);
+  }
+
+  private String defaultUserAgent() {
+    String agent = System.getProperty("http.agent");
+    return agent != null ? agent : ("Java" + System.getProperty("java.version"));
   }
 
   /**
@@ -356,12 +405,13 @@ private HttpEngine getResponse() throws IOException {
         throw new HttpRetryException("Cannot retry streamed HTTP body", responseCode);
       }
 
-      if (!httpEngine.sameConnection(followUp)) {
+      if (!httpEngine.sameConnection(followUp.url())) {
         httpEngine.releaseConnection();
       }
 
       Connection connection = httpEngine.close();
-      httpEngine = newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody);
+      httpEngine = newHttpEngine(followUp.method(), connection, (RetryableSink) requestBody,
+          response);
     }
   }
 
@@ -487,7 +537,7 @@ private boolean execute(boolean readResponse) throws IOException {
    * defined in {@link Protocol OkHttp's protocol enumeration}.
    */
   private void setProtocols(String protocolsString, boolean append) {
-    List<Protocol> protocolsList = new ArrayList<Protocol>();
+    List<Protocol> protocolsList = new ArrayList<>();
     if (append) {
       protocolsList.addAll(client.getProtocols());
     }
@@ -513,8 +563,7 @@ private void setProtocols(String protocolsString, boolean append) {
     setFixedLengthStreamingMode((long) contentLength);
   }
 
-  // @Override Don't override: this overload method doesn't exist prior to Java 1.7.
-  public void setFixedLengthStreamingMode(long contentLength) {
+  @Override public void setFixedLengthStreamingMode(long contentLength) {
     if (super.connected) throw new IllegalStateException("Already connected");
     if (chunkLength > 0) throw new IllegalStateException("Already in chunked mode");
     if (contentLength < 0) throw new IllegalArgumentException("contentLength < 0");
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpsURLConnectionImpl.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpsURLConnectionImpl.java
similarity index 100%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/huc/HttpsURLConnectionImpl.java
rename to okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/HttpsURLConnectionImpl.java
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
similarity index 97%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
rename to okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
index d3e9d8813c..1d2492246a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
+++ b/okhttp-urlconnection/src/main/java/com/squareup/okhttp/internal/huc/JavaApiConverter.java
@@ -20,7 +20,7 @@
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseSource;
+import com.squareup.okhttp.ResponseBody;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.OkHeaders;
 import com.squareup.okhttp.internal.http.StatusLine;
@@ -78,11 +78,8 @@ public static Response createOkResponse(URI uri, URLConnection urlConnection) th
     Headers okHeaders = extractOkResponseHeaders(httpUrlConnection);
     okResponseBuilder.headers(okHeaders);
 
-    // Meta data: Defaulted
-    okResponseBuilder.setResponseSource(ResponseSource.NETWORK);
-
     // Response body
-    Response.Body okBody = createOkBody(okHeaders, urlConnection.getInputStream());
+    ResponseBody okBody = createOkBody(okHeaders, urlConnection.getInputStream());
     okResponseBuilder.body(okBody);
 
     // Handle SSL handshake information as needed.
@@ -128,11 +125,8 @@ static Response createOkResponse(Request request, CacheResponse javaResponse)
     Headers okHeaders = extractOkHeaders(javaResponse);
     okResponseBuilder.headers(okHeaders);
 
-    // Meta data: Defaulted
-    okResponseBuilder.setResponseSource(ResponseSource.CACHE);
-
     // Response body
-    Response.Body okBody = createOkBody(okHeaders, javaResponse.getBody());
+    ResponseBody okBody = createOkBody(okHeaders, javaResponse.getBody());
     okResponseBuilder.body(okBody);
 
     // Handle SSL handshake information as needed.
@@ -185,7 +179,7 @@ public static Request createOkRequest(
    */
   public static CacheResponse createJavaCacheResponse(final Response response) {
     final Headers headers = response.headers();
-    final Response.Body body = response.body();
+    final ResponseBody body = response.body();
     if (response.request().isHttps()) {
       final Handshake handshake = response.handshake();
       return new SecureCacheResponse() {
@@ -345,9 +339,9 @@ static String extractStatusLine(Map<String, List<String>> javaResponseHeaders) {
   /**
    * Creates an OkHttp Response.Body containing the supplied information.
    */
-  private static Response.Body createOkBody(final Headers okHeaders, InputStream body) {
+  private static ResponseBody createOkBody(final Headers okHeaders, InputStream body) {
     final BufferedSource source = Okio.buffer(Okio.source(body));
-    return new Response.Body() {
+    return new ResponseBody() {
       @Override public MediaType contentType() {
         String contentTypeHeader = okHeaders.get("Content-Type");
         return contentTypeHeader == null ? null : MediaType.parse(contentTypeHeader);
diff --git a/okhttp-urlconnection/src/test/java/com/squareup/okhttp/OkUrlFactoryTest.java b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/OkUrlFactoryTest.java
new file mode 100644
index 0000000000..5a2d565bf1
--- /dev/null
+++ b/okhttp-urlconnection/src/test/java/com/squareup/okhttp/OkUrlFactoryTest.java
@@ -0,0 +1,165 @@
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.rule.MockWebServerRule;
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+import java.util.TimeZone;
+import java.util.concurrent.TimeUnit;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+
+import static java.nio.charset.StandardCharsets.US_ASCII;
+import static okio.Okio.buffer;
+import static okio.Okio.source;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public class OkUrlFactoryTest {
+  @Rule public MockWebServerRule serverRule = new MockWebServerRule();
+  @Rule public TemporaryFolder cacheFolder = new TemporaryFolder();
+
+  private MockWebServer server;
+  private OkUrlFactory factory;
+
+  @Before public void setUp() throws IOException {
+    server = serverRule.get();
+
+    OkHttpClient client = new OkHttpClient();
+    client.setCache(new Cache(cacheFolder.getRoot(), 10 * 1024 * 1024));
+    factory = new OkUrlFactory(client);
+  }
+
+  /**
+   * Response code 407 should only come from proxy servers. Android's client
+   * throws if it is sent by an origin server.
+   */
+  @Test public void originServerSends407() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(407));
+
+    HttpURLConnection conn = factory.open(server.getUrl("/"));
+    try {
+      conn.getResponseCode();
+      fail();
+    } catch (IOException ignored) {
+    }
+  }
+
+  @Test public void networkResponseSourceHeader() throws Exception {
+    server.enqueue(new MockResponse().setBody("Isla Sorna"));
+
+    HttpURLConnection connection = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection, "NETWORK 200");
+    assertResponseBody(connection, "Isla Sorna");
+  }
+
+  @Test public void networkFailureResponseSourceHeader() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(404));
+
+    HttpURLConnection connection = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection, "NETWORK 404");
+  }
+
+  @Test public void conditionalCacheHitResponseSourceHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("Isla Nublar"));
+    server.enqueue(new MockResponse().setResponseCode(304));
+
+    HttpURLConnection connection1 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection1, "NETWORK 200");
+    assertResponseBody(connection1, "Isla Nublar");
+
+    HttpURLConnection connection2 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection2, "CONDITIONAL_CACHE 304");
+    assertResponseBody(connection2, "Isla Nublar");
+  }
+
+  @Test public void conditionalCacheMissResponseSourceHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("Isla Nublar"));
+    server.enqueue(new MockResponse().setBody("Isla Sorna"));
+
+    HttpURLConnection connection1 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection1, "NETWORK 200");
+    assertResponseBody(connection1, "Isla Nublar");
+
+    HttpURLConnection connection2 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection2, "CONDITIONAL_CACHE 200");
+    assertResponseBody(connection2, "Isla Sorna");
+  }
+
+  @Test public void cacheResponseSourceHeaders() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Expires: " + formatDate(2, TimeUnit.HOURS))
+        .setBody("Isla Nublar"));
+
+    HttpURLConnection connection1 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection1, "NETWORK 200");
+    assertResponseBody(connection1, "Isla Nublar");
+
+    HttpURLConnection connection2 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection2, "CACHE 200");
+    assertResponseBody(connection2, "Isla Nublar");
+  }
+
+  @Test public void noneResponseSourceHeaders() throws Exception {
+    server.enqueue(new MockResponse().setBody("Isla Nublar"));
+
+    HttpURLConnection connection1 = factory.open(server.getUrl("/"));
+    assertResponseHeader(connection1, "NETWORK 200");
+    assertResponseBody(connection1, "Isla Nublar");
+
+    HttpURLConnection connection2 = factory.open(server.getUrl("/"));
+    connection2.setRequestProperty("Cache-Control", "only-if-cached");
+    assertResponseHeader(connection2, "NONE");
+  }
+
+  @Test
+  public void setInstanceFollowRedirectsFalse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /b")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    HttpURLConnection connection = factory.open(server.getUrl("/a"));
+    connection.setInstanceFollowRedirects(false);
+    assertResponseBody(connection, "A");
+    assertResponseCode(connection, 302);
+  }
+
+  private void assertResponseBody(HttpURLConnection connection, String expected) throws Exception {
+    String actual = buffer(source(connection.getInputStream())).readString(US_ASCII);
+    assertEquals(expected, actual);
+  }
+
+  private void assertResponseHeader(HttpURLConnection connection, String expected) {
+    assertEquals(expected, connection.getHeaderField("OkHttp-Response-Source"));
+  }
+
+  private void assertResponseCode(HttpURLConnection connection, int expected) throws IOException {
+    assertEquals(expected, connection.getResponseCode());
+  }
+
+  private static String formatDate(long delta, TimeUnit timeUnit) {
+    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
+  }
+
+  private static String formatDate(Date date) {
+    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
+    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
+    return rfc1123.format(date);
+  }
+}
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index 8b994410ab..c98e5dbcaf 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.0.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp</artifactId>
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Address.java b/okhttp/src/main/java/com/squareup/okhttp/Address.java
index 11be67a88d..80d59145dd 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Address.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Address.java
@@ -17,7 +17,6 @@
 
 import com.squareup.okhttp.internal.Util;
 import java.net.Proxy;
-import java.net.UnknownHostException;
 import java.util.List;
 import javax.net.SocketFactory;
 import javax.net.ssl.HostnameVerifier;
@@ -42,13 +41,12 @@
   final SocketFactory socketFactory;
   final SSLSocketFactory sslSocketFactory;
   final HostnameVerifier hostnameVerifier;
-  final OkAuthenticator authenticator;
+  final Authenticator authenticator;
   final List<Protocol> protocols;
 
   public Address(String uriHost, int uriPort, SocketFactory socketFactory,
       SSLSocketFactory sslSocketFactory, HostnameVerifier hostnameVerifier,
-      OkAuthenticator authenticator, Proxy proxy, List<Protocol> protocols)
-      throws UnknownHostException {
+      Authenticator authenticator, Proxy proxy, List<Protocol> protocols) {
     if (uriHost == null) throw new NullPointerException("uriHost == null");
     if (uriPort <= 0) throw new IllegalArgumentException("uriPort <= 0: " + uriPort);
     if (authenticator == null) throw new IllegalArgumentException("authenticator == null");
@@ -100,7 +98,7 @@ public HostnameVerifier getHostnameVerifier() {
   /**
    * Returns the client's authenticator. This method never returns null.
    */
-  public OkAuthenticator getAuthenticator() {
+  public Authenticator getAuthenticator() {
     return authenticator;
   }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkAuthenticator.java b/okhttp/src/main/java/com/squareup/okhttp/Authenticator.java
similarity index 98%
rename from okhttp/src/main/java/com/squareup/okhttp/OkAuthenticator.java
rename to okhttp/src/main/java/com/squareup/okhttp/Authenticator.java
index 728649981a..cb66dc6249 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkAuthenticator.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Authenticator.java
@@ -21,7 +21,7 @@
 /**
  * Responds to authentication challenges from the remote web or proxy server.
  */
-public interface OkAuthenticator {
+public interface Authenticator {
   /**
    * Returns a request that includes a credential to satisfy an authentication
    * challenge in {@code response}. Returns null if the challenge cannot be
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Cache.java b/okhttp/src/main/java/com/squareup/okhttp/Cache.java
index 67fa3a2387..373feb0313 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Cache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Cache.java
@@ -19,19 +19,14 @@
 import com.squareup.okhttp.internal.DiskLruCache;
 import com.squareup.okhttp.internal.InternalCache;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.http.CacheRequest;
+import com.squareup.okhttp.internal.http.CacheStrategy;
 import com.squareup.okhttp.internal.http.HttpMethod;
 import com.squareup.okhttp.internal.http.OkHeaders;
 import com.squareup.okhttp.internal.http.StatusLine;
-import java.io.BufferedWriter;
 import java.io.ByteArrayInputStream;
 import java.io.File;
-import java.io.FilterOutputStream;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.OutputStreamWriter;
-import java.io.Writer;
-import java.net.CacheRequest;
 import java.security.cert.Certificate;
 import java.security.cert.CertificateEncodingException;
 import java.security.cert.CertificateException;
@@ -39,14 +34,15 @@
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.ByteString;
+import okio.ForwardingSink;
 import okio.ForwardingSource;
 import okio.Okio;
+import okio.Sink;
 import okio.Source;
 
-import static com.squareup.okhttp.internal.Util.UTF_8;
-
 /**
  * Caches HTTP and HTTPS responses to the filesystem so they may be reused,
  * saving time and bandwidth.
@@ -127,8 +123,8 @@
     @Override public void trackConditionalCacheHit() {
       Cache.this.trackConditionalCacheHit();
     }
-    @Override public void trackResponse(ResponseSource source) {
-      Cache.this.trackResponse(source);
+    @Override public void trackResponse(CacheStrategy cacheStrategy) {
+      Cache.this.trackResponse(cacheStrategy);
     }
   };
 
@@ -145,8 +141,8 @@ public Cache(File directory, long maxSize) throws IOException {
     cache = DiskLruCache.open(directory, VERSION, ENTRY_COUNT, maxSize);
   }
 
-  private static String urlToKey(Request requst) {
-    return Util.hash(requst.urlString());
+  private static String urlToKey(Request request) {
+    return Util.hash(request.urlString());
   }
 
   Response get(Request request) {
@@ -164,7 +160,7 @@ Response get(Request request) {
     }
 
     try {
-      entry = new Entry(snapshot.getInputStream(ENTRY_METADATA));
+      entry = new Entry(snapshot.getSource(ENTRY_METADATA));
     } catch (IOException e) {
       Util.closeQuietly(snapshot);
       return null;
@@ -287,17 +283,16 @@ public boolean isClosed() {
     return cache.isClosed();
   }
 
-  private synchronized void trackResponse(ResponseSource source) {
+  private synchronized void trackResponse(CacheStrategy cacheStrategy) {
     requestCount++;
 
-    switch (source) {
-      case CACHE:
-        hitCount++;
-        break;
-      case CONDITIONAL_CACHE:
-      case NETWORK:
-        networkCount++;
-        break;
+    if (cacheStrategy.networkRequest != null) {
+      // If this is a conditional request, we'll increment hitCount if/when it hits.
+      networkCount++;
+
+    } else if (cacheStrategy.cacheResponse != null) {
+      // This response uses the cache and not the network. That's a cache hit.
+      hitCount++;
     }
   }
 
@@ -317,16 +312,16 @@ public synchronized int getRequestCount() {
     return requestCount;
   }
 
-  private final class CacheRequestImpl extends CacheRequest {
+  private final class CacheRequestImpl implements CacheRequest {
     private final DiskLruCache.Editor editor;
-    private OutputStream cacheOut;
+    private Sink cacheOut;
     private boolean done;
-    private OutputStream body;
+    private Sink body;
 
     public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
       this.editor = editor;
-      this.cacheOut = editor.newOutputStream(ENTRY_BODY);
-      this.body = new FilterOutputStream(cacheOut) {
+      this.cacheOut = editor.newSink(ENTRY_BODY);
+      this.body = new ForwardingSink(cacheOut) {
         @Override public void close() throws IOException {
           synchronized (Cache.this) {
             if (done) {
@@ -338,12 +333,6 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
           super.close();
           editor.commit();
         }
-
-        @Override public void write(byte[] buffer, int offset, int length) throws IOException {
-          // Since we don't override "write(int oneByte)", we can write directly to "out"
-          // and avoid the inefficient implementation from the FilterOutputStream.
-          out.write(buffer, offset, length);
-        }
       };
     }
 
@@ -362,7 +351,7 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
       }
     }
 
-    @Override public OutputStream getBody() throws IOException {
+    @Override public Sink body() {
       return body;
     }
   }
@@ -426,9 +415,9 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
      * certificates are also base64-encoded and appear each on their own
      * line. A length of -1 is used to encode a null array.
      */
-    public Entry(InputStream in) throws IOException {
+    public Entry(Source in) throws IOException {
       try {
-        BufferedSource source = Okio.buffer(Okio.source(in));
+        BufferedSource source = Okio.buffer(in);
         url = source.readUtf8LineStrict();
         requestMethod = source.readUtf8LineStrict();
         Headers.Builder varyHeadersBuilder = new Headers.Builder();
@@ -478,41 +467,40 @@ public Entry(Response response) {
     }
 
     public void writeTo(DiskLruCache.Editor editor) throws IOException {
-      OutputStream out = editor.newOutputStream(ENTRY_METADATA);
-      Writer writer = new BufferedWriter(new OutputStreamWriter(out, UTF_8));
-
-      writer.write(url);
-      writer.write('\n');
-      writer.write(requestMethod);
-      writer.write('\n');
-      writer.write(Integer.toString(varyHeaders.size()));
-      writer.write('\n');
+      BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA));
+
+      sink.writeUtf8(url);
+      sink.writeByte('\n');
+      sink.writeUtf8(requestMethod);
+      sink.writeByte('\n');
+      sink.writeUtf8(Integer.toString(varyHeaders.size()));
+      sink.writeByte('\n');
       for (int i = 0; i < varyHeaders.size(); i++) {
-        writer.write(varyHeaders.name(i));
-        writer.write(": ");
-        writer.write(varyHeaders.value(i));
-        writer.write('\n');
+        sink.writeUtf8(varyHeaders.name(i));
+        sink.writeUtf8(": ");
+        sink.writeUtf8(varyHeaders.value(i));
+        sink.writeByte('\n');
       }
 
-      writer.write(new StatusLine(protocol, code, message).toString());
-      writer.write('\n');
-      writer.write(Integer.toString(responseHeaders.size()));
-      writer.write('\n');
+      sink.writeUtf8(new StatusLine(protocol, code, message).toString());
+      sink.writeByte('\n');
+      sink.writeUtf8(Integer.toString(responseHeaders.size()));
+      sink.writeByte('\n');
       for (int i = 0; i < responseHeaders.size(); i++) {
-        writer.write(responseHeaders.name(i));
-        writer.write(": ");
-        writer.write(responseHeaders.value(i));
-        writer.write('\n');
+        sink.writeUtf8(responseHeaders.name(i));
+        sink.writeUtf8(": ");
+        sink.writeUtf8(responseHeaders.value(i));
+        sink.writeByte('\n');
       }
 
       if (isHttps()) {
-        writer.write('\n');
-        writer.write(handshake.cipherSuite());
-        writer.write('\n');
-        writeCertArray(writer, handshake.peerCertificates());
-        writeCertArray(writer, handshake.localCertificates());
+        sink.writeByte('\n');
+        sink.writeUtf8(handshake.cipherSuite());
+        sink.writeByte('\n');
+        writeCertArray(sink, handshake.peerCertificates());
+        writeCertArray(sink, handshake.localCertificates());
       }
-      writer.close();
+      sink.close();
     }
 
     private boolean isHttps() {
@@ -525,7 +513,7 @@ private boolean isHttps() {
 
       try {
         CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
-        List<Certificate> result = new ArrayList<Certificate>(length);
+        List<Certificate> result = new ArrayList<>(length);
         for (int i = 0; i < length; i++) {
           String line = source.readUtf8LineStrict();
           byte[] bytes = ByteString.decodeBase64(line).toByteArray();
@@ -537,15 +525,16 @@ private boolean isHttps() {
       }
     }
 
-    private void writeCertArray(Writer writer, List<Certificate> certificates) throws IOException {
+    private void writeCertArray(BufferedSink sink, List<Certificate> certificates)
+        throws IOException {
       try {
-        writer.write(Integer.toString(certificates.size()));
-        writer.write('\n');
+        sink.writeUtf8(Integer.toString(certificates.size()));
+        sink.writeByte('\n');
         for (int i = 0, size = certificates.size(); i < size; i++) {
           byte[] bytes = certificates.get(i).getEncoded();
           String line = ByteString.of(bytes).base64();
-          writer.write(line);
-          writer.write('\n');
+          sink.writeUtf8(line);
+          sink.writeByte('\n');
         }
       } catch (CertificateEncodingException e) {
         throw new IOException(e.getMessage());
@@ -561,8 +550,13 @@ public boolean matches(Request request, Response response) {
     public Response response(Request request, DiskLruCache.Snapshot snapshot) {
       String contentType = responseHeaders.get("Content-Type");
       String contentLength = responseHeaders.get("Content-Length");
+      Request cacheRequest = new Request.Builder()
+          .url(url)
+          .method(requestMethod, null)
+          .headers(varyHeaders)
+          .build();
       return new Response.Builder()
-          .request(request)
+          .request(cacheRequest)
           .protocol(protocol)
           .code(code)
           .message(message)
@@ -582,7 +576,7 @@ private static int readInt(BufferedSource source) throws IOException {
     }
   }
 
-  private static class CacheResponseBody extends Response.Body {
+  private static class CacheResponseBody extends ResponseBody {
     private final DiskLruCache.Snapshot snapshot;
     private final BufferedSource bodySource;
     private final String contentType;
@@ -594,8 +588,8 @@ public CacheResponseBody(final DiskLruCache.Snapshot snapshot,
       this.contentType = contentType;
       this.contentLength = contentLength;
 
-      Source in = Okio.source(snapshot.getInputStream(ENTRY_BODY));
-      bodySource = Okio.buffer(new ForwardingSource(in) {
+      Source source = snapshot.getSource(ENTRY_BODY);
+      bodySource = Okio.buffer(new ForwardingSource(source) {
         @Override public void close() throws IOException {
           snapshot.close();
           super.close();
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Call.java b/okhttp/src/main/java/com/squareup/okhttp/Call.java
index de14eaa432..db2cf61076 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Call.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Call.java
@@ -33,9 +33,8 @@
  * canceled. As this object represents a single request/response pair (stream),
  * it cannot be executed twice.
  */
-public final class Call {
+public class Call {
   private final OkHttpClient client;
-  private final Dispatcher dispatcher;
   private int redirectionCount;
 
   // Guarded by this.
@@ -46,9 +45,10 @@
   private Request request;
   HttpEngine engine;
 
-  Call(OkHttpClient client, Dispatcher dispatcher, Request request) {
-    this.client = client;
-    this.dispatcher = dispatcher;
+  protected Call(OkHttpClient client, Request request) {
+    // Copy the client. Otherwise changes (socket factory, redirect policy,
+    // etc.) may incorrectly be reflected in the request when it is executed.
+    this.client = client.copyWithDefaults();
     this.request = request;
   }
 
@@ -58,7 +58,7 @@
    *
    * <p>The caller may read the response body with the response's
    * {@link Response#body} method.  To facilitate connection recycling, callers
-   * should always {@link Response.Body#close() close the response body}.
+   * should always {@link ResponseBody#close() close the response body}.
    *
    * <p>Note that transport-layer success (receiving a HTTP response code,
    * headers and body) does not necessarily indicate application-layer success:
@@ -96,12 +96,12 @@ public Response execute() throws IOException {
    *
    * @throws IllegalStateException when the call has already been executed.
    */
-  public void enqueue(Response.Callback responseCallback) {
+  public void enqueue(Callback responseCallback) {
     synchronized (this) {
       if (executed) throw new IllegalStateException("Already Executed");
       executed = true;
     }
-    dispatcher.enqueue(new AsyncCall(responseCallback));
+    client.getDispatcher().enqueue(new AsyncCall(responseCallback));
   }
 
   /**
@@ -114,9 +114,9 @@ public void cancel() {
   }
 
   final class AsyncCall extends NamedRunnable {
-    private final Response.Callback responseCallback;
+    private final Callback responseCallback;
 
-    private AsyncCall(Response.Callback responseCallback) {
+    private AsyncCall(Callback responseCallback) {
       super("OkHttp %s", request.urlString());
       this.responseCallback = responseCallback;
     }
@@ -143,23 +143,17 @@ Call get() {
         Response response = getResponse();
         if (canceled) {
           signalledCallback = true;
-          responseCallback.onFailure(new Failure.Builder()
-              .request(request)
-              .exception(new IOException("Canceled"))
-              .build());
+          responseCallback.onFailure(request, new IOException("Canceled"));
         } else {
           signalledCallback = true;
+          engine.releaseConnection();
           responseCallback.onResponse(response);
         }
       } catch (IOException e) {
-        if (signalledCallback) return; // Do not signal the callback twice!
-        responseCallback.onFailure(new Failure.Builder()
-            .request(request)
-            .exception(e)
-            .build());
+        if (signalledCallback) throw new RuntimeException(e); // Do not signal the callback twice!
+        responseCallback.onFailure(request, e);
       } finally {
-        engine.close(); // Close the connection if it isn't already.
-        dispatcher.finished(this);
+        client.getDispatcher().finished(this);
       }
     }
   }
@@ -169,17 +163,16 @@ Call get() {
    * call was canceled.
    */
   private Response getResponse() throws IOException {
-    Response redirectedBy = null;
-
     // Copy body metadata to the appropriate request headers.
-    Request.Body body = request.body();
+    RequestBody body = request.body();
     RetryableSink requestBodyOut = null;
     if (body != null) {
-      MediaType contentType = body.contentType();
-      if (contentType == null) throw new IllegalStateException("contentType == null");
-
       Request.Builder requestBuilder = request.newBuilder();
-      requestBuilder.header("Content-Type", contentType.toString());
+
+      MediaType contentType = body.contentType();
+      if (contentType != null) {
+        requestBuilder.header("Content-Type", contentType.toString());
+      }
 
       long contentLength = body.contentLength();
       if (contentLength != -1) {
@@ -196,7 +189,7 @@ private Response getResponse() throws IOException {
     }
 
     // Create the initial HTTP engine. Retries and redirects need new engine for each attempt.
-    engine = new HttpEngine(client, request, false, null, null, requestBodyOut);
+    engine = new HttpEngine(client, request, false, null, null, requestBodyOut, null);
 
     while (true) {
       if (canceled) return null;
@@ -228,7 +221,6 @@ private Response getResponse() throws IOException {
         engine.releaseConnection();
         return response.newBuilder()
             .body(new RealResponseBody(response, engine.getResponseBody()))
-            .redirectedBy(redirectedBy)
             .build();
       }
 
@@ -236,18 +228,17 @@ private Response getResponse() throws IOException {
         throw new ProtocolException("Too many redirects: " + redirectionCount);
       }
 
-      if (!engine.sameConnection(followUp)) {
+      if (!engine.sameConnection(followUp.url())) {
         engine.releaseConnection();
       }
 
       Connection connection = engine.close();
-      redirectedBy = response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.
       request = followUp;
-      engine = new HttpEngine(client, request, false, connection, null, null);
+      engine = new HttpEngine(client, request, false, connection, null, null, response);
     }
   }
 
-  private static class RealResponseBody extends Response.Body {
+  private static class RealResponseBody extends ResponseBody {
     private final Response response;
     private final BufferedSource source;
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Callback.java b/okhttp/src/main/java/com/squareup/okhttp/Callback.java
new file mode 100644
index 0000000000..d86960fe05
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/Callback.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import java.io.IOException;
+
+public interface Callback {
+  /**
+   * Called when the request could not be executed due to cancellation, a
+   * connectivity problem or timeout. Because networks can fail during an
+   * exchange, it is possible that the remote server accepted the request
+   * before the failure.
+   */
+  void onFailure(Request request, IOException e);
+
+  /**
+   * Called when the HTTP response was successfully returned by the remote
+   * server. The callback may proceed to read the response body with {@link
+   * Response#body}. The response is still live until its response body is
+   * closed with {@code response.body().close()}. The recipient of the callback
+   * may even consume the response body on another thread.
+   *
+   * <p>Note that transport-layer success (receiving a HTTP response code,
+   * headers and body) does not necessarily indicate application-layer
+   * success: {@code response} may still indicate an unhappy HTTP response
+   * code like 404 or 500.
+   */
+  void onResponse(Response response) throws IOException;
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index 28a938927c..42dc9b19ca 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -30,6 +30,8 @@
 import java.net.URL;
 import javax.net.ssl.SSLSocket;
 
+import static com.squareup.okhttp.internal.Util.getDefaultPort;
+import static com.squareup.okhttp.internal.Util.getEffectivePort;
 import static java.net.HttpURLConnection.HTTP_OK;
 import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
 
@@ -138,10 +140,10 @@ void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunn
       throws IOException {
     if (connected) throw new IllegalStateException("already connected");
 
-    if (route.proxy.type() != Proxy.Type.HTTP) {
-      socket = new Socket(route.proxy);
-    } else {
+    if (route.proxy.type() == Proxy.Type.DIRECT || route.proxy.type() == Proxy.Type.HTTP) {
       socket = route.address.socketFactory.createSocket();
+    } else {
+      socket = new Socket(route.proxy);
     }
 
     socket.setSoTimeout(readTimeout);
@@ -155,6 +157,59 @@ void connect(int connectTimeout, int readTimeout, int writeTimeout, Request tunn
     connected = true;
   }
 
+  /**
+   * Connects this connection if it isn't already. This creates tunnels, shares
+   * the connection with the connection pool, and configures timeouts.
+   */
+  void connectAndSetOwner(OkHttpClient client, Object owner, Request request) throws IOException {
+    setOwner(owner);
+
+    if (!isConnected()) {
+      Request tunnelRequest = tunnelRequest(request);
+      connect(client.getConnectTimeout(), client.getReadTimeout(),
+          client.getWriteTimeout(), tunnelRequest);
+      if (isSpdy()) {
+        client.getConnectionPool().share(this);
+      }
+      client.routeDatabase().connected(getRoute());
+    }
+
+    setTimeouts(client.getReadTimeout(), client.getWriteTimeout());
+  }
+
+  /**
+   * Returns a request that creates a TLS tunnel via an HTTP proxy, or null if
+   * no tunnel is necessary. Everything in the tunnel request is sent
+   * unencrypted to the proxy server, so tunnels include only the minimum set of
+   * headers. This avoids sending potentially sensitive data like HTTP cookies
+   * to the proxy unencrypted.
+   */
+  private Request tunnelRequest(Request request) throws IOException {
+    if (!route.requiresTunnel()) return null;
+
+    String host = request.url().getHost();
+    int port = getEffectivePort(request.url());
+    String authority = (port == getDefaultPort("https")) ? host : (host + ":" + port);
+    Request.Builder result = new Request.Builder()
+        .url(new URL("https", host, port, "/"))
+        .header("Host", authority)
+        .header("Proxy-Connection", "Keep-Alive"); // For HTTP/1.0 proxies like Squid.
+
+    // Copy over the User-Agent header if it exists.
+    String userAgent = request.header("User-Agent");
+    if (userAgent != null) {
+      result.header("User-Agent", userAgent);
+    }
+
+    // Copy over the Proxy-Authorization header if it exists.
+    String proxyAuthorization = request.header("Proxy-Authorization");
+    if (proxyAuthorization != null) {
+      result.header("Proxy-Authorization", proxyAuthorization);
+    }
+
+    return result.build();
+  }
+
   /**
    * Create an {@code SSLSocket} and perform the TLS handshake and certificate
    * validation.
@@ -174,10 +229,9 @@ private void upgradeToTls(Request tunnelRequest, int readTimeout, int writeTimeo
     SSLSocket sslSocket = (SSLSocket) socket;
     platform.configureTls(sslSocket, route.address.uriHost, route.tlsVersion);
 
-    boolean useNpn = false;
-    if (route.supportsNpn() && route.address.protocols.size() > 1) {
+    boolean useNpn = route.supportsNpn();
+    if (useNpn) {
       platform.setProtocols(sslSocket, route.address.protocols);
-      useNpn = true;
     }
 
     // Force handshake. This can throw!
@@ -199,7 +253,7 @@ private void upgradeToTls(Request tunnelRequest, int readTimeout, int writeTimeo
       sslSocket.setSoTimeout(0); // SPDY timeouts are set per-stream.
       spdyConnection = new SpdyConnection.Builder(route.address.getUriHost(), true, socket)
           .protocol(protocol).build();
-      spdyConnection.sendConnectionHeader();
+      spdyConnection.sendConnectionPreface();
     } else {
       httpConnection = new HttpConnection(pool, this, socket);
     }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
index aac94c060a..b52c234e45 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
@@ -76,7 +76,7 @@
   private final int maxIdleConnections;
   private final long keepAliveDurationNs;
 
-  private final LinkedList<Connection> connections = new LinkedList<Connection>();
+  private final LinkedList<Connection> connections = new LinkedList<>();
 
   /** We use a single background thread to cleanup expired connections. */
   private final ExecutorService executorService = new ThreadPoolExecutor(0, 1,
@@ -84,7 +84,7 @@
       Util.threadFactory("OkHttp ConnectionPool", true));
   private final Runnable connectionsCleanupRunnable = new Runnable() {
     @Override public void run() {
-      List<Connection> expiredConnections = new ArrayList<Connection>(MAX_CONNECTIONS_TO_CLEANUP);
+      List<Connection> expiredConnections = new ArrayList<>(MAX_CONNECTIONS_TO_CLEANUP);
       int idleConnectionCount = 0;
       synchronized (ConnectionPool.this) {
         for (ListIterator<Connection> i = connections.listIterator(connections.size());
@@ -127,7 +127,7 @@ public ConnectionPool(int maxIdleConnections, long keepAliveDurationMs) {
   List<Connection> getConnections() {
     waitForCleanupCallableToRun();
     synchronized (this) {
-      return new ArrayList<Connection>(connections);
+      return new ArrayList<>(connections);
     }
   }
 
@@ -263,7 +263,7 @@ void share(Connection connection) {
   public void evictAll() {
     List<Connection> connections;
     synchronized (this) {
-      connections = new ArrayList<Connection>(this.connections);
+      connections = new ArrayList<>(this.connections);
       this.connections.clear();
     }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
index 4569867cd5..0e4644d5b7 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
@@ -41,10 +41,10 @@
   private ExecutorService executorService;
 
   /** Ready calls in the order they'll be run. */
-  private final Deque<AsyncCall> readyCalls = new ArrayDeque<AsyncCall>();
+  private final Deque<AsyncCall> readyCalls = new ArrayDeque<>();
 
   /** Running calls. Includes canceled calls that haven't finished yet. */
-  private final Deque<AsyncCall> runningCalls = new ArrayDeque<AsyncCall>();
+  private final Deque<AsyncCall> runningCalls = new ArrayDeque<>();
 
   public Dispatcher(ExecutorService executorService) {
     this.executorService = executorService;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Failure.java b/okhttp/src/main/java/com/squareup/okhttp/Failure.java
deleted file mode 100644
index 51ee2eae34..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/Failure.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-/**
- * A failure attempting to retrieve an HTTP response.
- */
-public final class Failure {
-  private final Request request;
-  private final Throwable exception;
-
-  private Failure(Builder builder) {
-    this.request = builder.request;
-    this.exception = builder.exception;
-  }
-
-  public Request request() {
-    return request;
-  }
-
-  public Throwable exception() {
-    return exception;
-  }
-
-  public static class Builder {
-    private Request request;
-    private Throwable exception;
-
-    public Builder request(Request request) {
-      this.request = request;
-      return this;
-    }
-
-    public Builder exception(Throwable exception) {
-      this.exception = exception;
-      return this;
-    }
-
-    public Failure build() {
-      return new Failure(this);
-    }
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java b/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java
new file mode 100644
index 0000000000..891fbff005
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/FormEncodingBuilder.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.UnsupportedEncodingException;
+import java.net.URLEncoder;
+
+/**
+ * Fluent API to build <a href="http://www.w3.org/MarkUp/html-spec/html-spec_8.html#SEC8.2.1">HTML
+ * 2.0</a>-compliant form data.
+ */
+public final class FormEncodingBuilder {
+  private static final MediaType CONTENT_TYPE
+      = MediaType.parse("application/x-www-form-urlencoded");
+
+  private final StringBuilder content = new StringBuilder();
+
+  /** Add new key-value pair. */
+  public FormEncodingBuilder add(String name, String value) {
+    if (content.length() > 0) {
+      content.append('&');
+    }
+    try {
+      content.append(URLEncoder.encode(name, "UTF-8"))
+          .append('=')
+          .append(URLEncoder.encode(value, "UTF-8"));
+    } catch (UnsupportedEncodingException e) {
+      throw new AssertionError(e);
+    }
+    return this;
+  }
+
+  public RequestBody build() {
+    if (content.length() == 0) {
+      throw new IllegalStateException("Form encoded body must have at least one part.");
+    }
+
+    // Convert to bytes so RequestBody.create() doesn't add a charset to the content-type.
+    byte[] contentBytes = content.toString().getBytes(Util.UTF_8);
+    return RequestBody.create(CONTENT_TYPE, contentBytes);
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Headers.java b/okhttp/src/main/java/com/squareup/okhttp/Headers.java
index 45a0de5ac9..f397616d64 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Headers.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Headers.java
@@ -51,9 +51,13 @@ private Headers(Builder builder) {
     this.namesAndValues = builder.namesAndValues.toArray(new String[builder.namesAndValues.size()]);
   }
 
+  private Headers(String[] namesAndValues) {
+    this.namesAndValues = namesAndValues;
+  }
+
   /** Returns the last value corresponding to the specified field, or null. */
-  public String get(String fieldName) {
-    return get(namesAndValues, fieldName);
+  public String get(String name) {
+    return get(namesAndValues, name);
   }
 
   /**
@@ -61,8 +65,8 @@ public String get(String fieldName) {
    * HTTP date, or null if either the field is absent or cannot be parsed as a
    * date.
    */
-  public Date getDate(String fieldName) {
-    String value = get(fieldName);
+  public Date getDate(String name) {
+    String value = get(name);
     return value != null ? HttpDate.parse(value) : null;
   }
 
@@ -73,11 +77,11 @@ public int size() {
 
   /** Returns the field at {@code position} or null if that is out of range. */
   public String name(int index) {
-    int fieldNameIndex = index * 2;
-    if (fieldNameIndex < 0 || fieldNameIndex >= namesAndValues.length) {
+    int nameIndex = index * 2;
+    if (nameIndex < 0 || nameIndex >= namesAndValues.length) {
       return null;
     }
-    return namesAndValues[fieldNameIndex];
+    return namesAndValues[nameIndex];
   }
 
   /** Returns the value at {@code index} or null if that is out of range. */
@@ -91,7 +95,7 @@ public String value(int index) {
 
   /** Returns an immutable case-insensitive set of header names. */
   public Set<String> names() {
-    TreeSet<String> result = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);
+    TreeSet<String> result = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
     for (int i = 0; i < size(); i++) {
       result.add(name(i));
     }
@@ -103,7 +107,7 @@ public String value(int index) {
     List<String> result = null;
     for (int i = 0; i < size(); i++) {
       if (name.equalsIgnoreCase(name(i))) {
-        if (result == null) result = new ArrayList<String>(2);
+        if (result == null) result = new ArrayList<>(2);
         result.add(value(i));
       }
     }
@@ -126,17 +130,46 @@ public Builder newBuilder() {
     return result.toString();
   }
 
-  private static String get(String[] namesAndValues, String fieldName) {
+  private static String get(String[] namesAndValues, String name) {
     for (int i = namesAndValues.length - 2; i >= 0; i -= 2) {
-      if (fieldName.equalsIgnoreCase(namesAndValues[i])) {
+      if (name.equalsIgnoreCase(namesAndValues[i])) {
         return namesAndValues[i + 1];
       }
     }
     return null;
   }
 
+  /**
+   * Returns headers for the alternating header names and values. There must be
+   * an even number of arguments, and they must alternate between header names
+   * and values.
+   */
+  public static Headers of(String... namesAndValues) {
+    if (namesAndValues == null || namesAndValues.length % 2 != 0) {
+      throw new IllegalArgumentException("Expected alternating header names and values");
+    }
+
+    // Make a defensive copy and clean it up.
+    namesAndValues = namesAndValues.clone();
+    for (int i = 0; i < namesAndValues.length; i++) {
+      if (namesAndValues[i] == null) throw new IllegalArgumentException("Headers cannot be null");
+      namesAndValues[i] = namesAndValues[i].trim();
+    }
+
+    // Check for malformed headers.
+    for (int i = 0; i < namesAndValues.length; i += 2) {
+      String name = namesAndValues[i];
+      String value = namesAndValues[i + 1];
+      if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
+        throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
+      }
+    }
+
+    return new Headers(namesAndValues);
+  }
+
   public static class Builder {
-    private final List<String> namesAndValues = new ArrayList<String>(20);
+    private final List<String> namesAndValues = new ArrayList<>(20);
 
     /** Add an header line containing a field name, a literal colon, and a value. */
     Builder addLine(String line) {
@@ -153,30 +186,31 @@ Builder addLine(String line) {
     }
 
     /** Add a field with the specified value. */
-    public Builder add(String fieldName, String value) {
-      if (fieldName == null) throw new IllegalArgumentException("fieldname == null");
+    public Builder add(String name, String value) {
+      if (name == null) throw new IllegalArgumentException("name == null");
       if (value == null) throw new IllegalArgumentException("value == null");
-      if (fieldName.length() == 0 || fieldName.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
-        throw new IllegalArgumentException("Unexpected header: " + fieldName + ": " + value);
+      if (name.length() == 0 || name.indexOf('\0') != -1 || value.indexOf('\0') != -1) {
+        throw new IllegalArgumentException("Unexpected header: " + name + ": " + value);
       }
-      return addLenient(fieldName, value);
+      return addLenient(name, value);
     }
 
     /**
      * Add a field with the specified value without any validation. Only
      * appropriate for headers from the remote peer.
      */
-    private Builder addLenient(String fieldName, String value) {
-      namesAndValues.add(fieldName);
+    private Builder addLenient(String name, String value) {
+      namesAndValues.add(name);
       namesAndValues.add(value.trim());
       return this;
     }
 
-    public Builder removeAll(String fieldName) {
+    public Builder removeAll(String name) {
       for (int i = 0; i < namesAndValues.size(); i += 2) {
-        if (fieldName.equalsIgnoreCase(namesAndValues.get(i))) {
-          namesAndValues.remove(i); // field name
+        if (name.equalsIgnoreCase(namesAndValues.get(i))) {
+          namesAndValues.remove(i); // name
           namesAndValues.remove(i); // value
+          i -= 2;
         }
       }
       return this;
@@ -186,16 +220,16 @@ public Builder removeAll(String fieldName) {
      * Set a field with the specified value. If the field is not found, it is
      * added. If the field is found, the existing values are replaced.
      */
-    public Builder set(String fieldName, String value) {
-      removeAll(fieldName);
-      add(fieldName, value);
+    public Builder set(String name, String value) {
+      removeAll(name);
+      add(name, value);
       return this;
     }
 
-    /** Equivalent to {@code build().get(fieldName)}, but potentially faster. */
-    public String get(String fieldName) {
+    /** Equivalent to {@code build().get(name)}, but potentially faster. */
+    public String get(String name) {
       for (int i = namesAndValues.size() - 2; i >= 0; i -= 2) {
-        if (fieldName.equalsIgnoreCase(namesAndValues.get(i))) {
+        if (name.equalsIgnoreCase(namesAndValues.get(i))) {
           return namesAndValues.get(i + 1);
         }
       }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Dns.java b/okhttp/src/main/java/com/squareup/okhttp/HostResolver.java
similarity index 90%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/Dns.java
rename to okhttp/src/main/java/com/squareup/okhttp/HostResolver.java
index a89b293c08..c7a1edbaa6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Dns.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/HostResolver.java
@@ -13,7 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal;
+package com.squareup.okhttp;
 
 import java.net.InetAddress;
 import java.net.UnknownHostException;
@@ -22,8 +22,8 @@
  * Domain name service. Prefer this over {@link InetAddress#getAllByName} to
  * make code more testable.
  */
-public interface Dns {
-  Dns DEFAULT = new Dns() {
+public interface HostResolver {
+  HostResolver DEFAULT = new HostResolver() {
     @Override public InetAddress[] getAllByName(String host) throws UnknownHostException {
       if (host == null) throw new UnknownHostException("host == null");
       return InetAddress.getAllByName(host);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/MediaType.java b/okhttp/src/main/java/com/squareup/okhttp/MediaType.java
index b0b7f45f5f..4d2f1fcf44 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/MediaType.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/MediaType.java
@@ -61,10 +61,13 @@ public static MediaType parse(String string) {
 
       String name = parameter.group(1);
       if (name == null || !name.equalsIgnoreCase("charset")) continue;
-      if (charset != null) throw new IllegalArgumentException("Multiple charsets: " + string);
-      charset = parameter.group(2) != null
+      String charsetParameter = parameter.group(2) != null
           ? parameter.group(2)  // Value is a token.
           : parameter.group(3); // Value is a quoted string.
+      if (charset != null && !charsetParameter.equalsIgnoreCase(charset)) {
+        throw new IllegalArgumentException("Multiple different charsets: " + string);
+      }
+      charset = charsetParameter;
     }
 
     return new MediaType(string, type, subtype, charset);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java b/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java
new file mode 100644
index 0000000000..e31d183951
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/MultipartBuilder.java
@@ -0,0 +1,288 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.UUID;
+import okio.Buffer;
+import okio.BufferedSink;
+import okio.ByteString;
+
+/**
+ * Fluent API to build <a href="http://www.ietf.org/rfc/rfc2387.txt">RFC
+ * 2387</a>-compliant request bodies.
+ */
+public final class MultipartBuilder {
+  /**
+   * The "mixed" subtype of "multipart" is intended for use when the body
+   * parts are independent and need to be bundled in a particular order. Any
+   * "multipart" subtypes that an implementation does not recognize must be
+   * treated as being of subtype "mixed".
+   */
+  public static final MediaType MIXED = MediaType.parse("multipart/mixed");
+
+  /**
+   * The "multipart/alternative" type is syntactically identical to
+   * "multipart/mixed", but the semantics are different. In particular, each
+   * of the body parts is an "alternative" version of the same information.
+   */
+  public static final MediaType ALTERNATIVE = MediaType.parse("multipart/alternative");
+
+  /**
+   * This type is syntactically identical to "multipart/mixed", but the
+   * semantics are different. In particular, in a digest, the default {@code
+   * Content-Type} value for a body part is changed from "text/plain" to
+   * "message/rfc822".
+   */
+  public static final MediaType DIGEST = MediaType.parse("multipart/digest");
+
+  /**
+   * This type is syntactically identical to "multipart/mixed", but the
+   * semantics are different. In particular, in a parallel entity, the order
+   * of body parts is not significant.
+   */
+  public static final MediaType PARALLEL = MediaType.parse("multipart/parallel");
+
+  /**
+   * The media-type multipart/form-data follows the rules of all multipart
+   * MIME data streams as outlined in RFC 2046. In forms, there are a series
+   * of fields to be supplied by the user who fills out the form. Each field
+   * has a name. Within a given form, the names are unique.
+   */
+  public static final MediaType FORM = MediaType.parse("multipart/form-data");
+
+  private static final byte[] COLONSPACE = { ':', ' ' };
+  private static final byte[] CRLF = { '\r', '\n' };
+  private static final byte[] DASHDASH = { '-', '-' };
+
+  private final ByteString boundary;
+  private MediaType type = MIXED;
+  private long length = 0;
+
+  // Parallel lists of nullable headings (boundary + headers) and non-null bodies.
+  private final List<Buffer> partHeadings = new ArrayList<>();
+  private final List<RequestBody> partBodies = new ArrayList<>();
+
+  /** Creates a new multipart builder that uses a random boundary token. */
+  public MultipartBuilder() {
+    this(UUID.randomUUID().toString());
+  }
+
+  /**
+   * Creates a new multipart builder that uses {@code boundary} to separate
+   * parts. Prefer the no-argument constructor to defend against injection
+   * attacks.
+   */
+  public MultipartBuilder(String boundary) {
+    this.boundary = ByteString.encodeUtf8(boundary);
+  }
+
+  /**
+   * Set the MIME type. Expected values for {@code type} are {@link #MIXED} (the
+   * default), {@link #ALTERNATIVE}, {@link #DIGEST}, {@link #PARALLEL} and
+   * {@link #FORM}.
+   */
+  public MultipartBuilder type(MediaType type) {
+    if (type == null) {
+      throw new NullPointerException("type == null");
+    }
+    if (!type.type().equals("multipart")) {
+      throw new IllegalArgumentException("multipart != " + type);
+    }
+    this.type = type;
+    return this;
+  }
+
+  /** Add a part to the body. */
+  public MultipartBuilder addPart(RequestBody body) {
+    return addPart(null, body);
+  }
+
+  /** Add a part to the body. */
+  public MultipartBuilder addPart(Headers headers, RequestBody body) {
+    if (body == null) {
+      throw new NullPointerException("body == null");
+    }
+    if (headers != null && headers.get("Content-Type") != null) {
+      throw new IllegalArgumentException("Unexpected header: Content-Type");
+    }
+    if (headers != null && headers.get("Content-Length") != null) {
+      throw new IllegalArgumentException("Unexpected header: Content-Length");
+    }
+
+    Buffer heading = createPartHeading(headers, body, partHeadings.isEmpty());
+    partHeadings.add(heading);
+    partBodies.add(body);
+
+    long bodyContentLength = body.contentLength();
+    if (bodyContentLength == -1) {
+      length = -1;
+    } else if (length != -1) {
+      length += heading.size() + bodyContentLength;
+    }
+
+    return this;
+  }
+
+  /**
+   * Appends a quoted-string to a StringBuilder.
+   *
+   * <p>RFC 2388 is rather vague about how one should escape special characters
+   * in form-data parameters, and as it turns out Firefox and Chrome actually
+   * do rather different things, and both say in their comments that they're
+   * not really sure what the right approach is. We go with Chrome's behavior
+   * (which also experimentally seems to match what IE does), but if you
+   * actually want to have a good chance of things working, please avoid
+   * double-quotes, newlines, percent signs, and the like in your field names.
+   */
+  private static StringBuilder appendQuotedString(StringBuilder target, String key) {
+    target.append('"');
+    for (int i = 0, len = key.length(); i < len; i++) {
+      char ch = key.charAt(i);
+      switch (ch) {
+        case '\n':
+          target.append("%0A");
+          break;
+        case '\r':
+          target.append("%0D");
+          break;
+        case '"':
+          target.append("%22");
+          break;
+        default:
+          target.append(ch);
+          break;
+      }
+    }
+    target.append('"');
+    return target;
+  }
+
+  /** Add a form data part to the body. */
+  public MultipartBuilder addFormDataPart(String name, String value) {
+    return addFormDataPart(name, null, RequestBody.create(null, value));
+  }
+
+  /** Add a form data part to the body. */
+  public MultipartBuilder addFormDataPart(String name, String filename, RequestBody value) {
+    if (name == null) {
+      throw new NullPointerException("name == null");
+    }
+    StringBuilder disposition = new StringBuilder("form-data; name=");
+    appendQuotedString(disposition, name);
+
+    if (filename != null) {
+      disposition.append("; filename=");
+      appendQuotedString(disposition, filename);
+    }
+
+    return addPart(Headers.of("Content-Disposition", disposition.toString()), value);
+  }
+
+  /** Creates a part "heading" from the boundary and any real or generated headers. */
+  private Buffer createPartHeading(Headers headers, RequestBody body, boolean isFirst) {
+    Buffer sink = new Buffer();
+
+    if (!isFirst) {
+      sink.write(CRLF);
+    }
+    sink.write(DASHDASH);
+    sink.write(boundary);
+    sink.write(CRLF);
+
+    if (headers != null) {
+      for (int i = 0; i < headers.size(); i++) {
+        sink.writeUtf8(headers.name(i))
+            .write(COLONSPACE)
+            .writeUtf8(headers.value(i))
+            .write(CRLF);
+      }
+    }
+
+    MediaType contentType = body.contentType();
+    if (contentType != null) {
+      sink.writeUtf8("Content-Type: ")
+          .writeUtf8(contentType.toString())
+          .write(CRLF);
+    }
+
+    long contentLength = body.contentLength();
+    if (contentLength != -1) {
+      sink.writeUtf8("Content-Length: ")
+          .writeUtf8(Long.toString(contentLength))
+          .write(CRLF);
+    }
+
+    sink.write(CRLF);
+
+    return sink;
+  }
+
+  /** Assemble the specified parts into a request body. */
+  public RequestBody build() {
+    if (partHeadings.isEmpty()) {
+      throw new IllegalStateException("Multipart body must have at least one part.");
+    }
+    return new MultipartRequestBody(type, boundary, partHeadings, partBodies, length);
+  }
+
+  private static final class MultipartRequestBody extends RequestBody {
+    private final ByteString boundary;
+    private final MediaType contentType;
+    private final List<Buffer> partHeadings;
+    private final List<RequestBody> partBodies;
+    private final long length;
+
+    public MultipartRequestBody(MediaType type, ByteString boundary, List<Buffer> partHeadings,
+        List<RequestBody> partBodies, long length) {
+      if (type == null) throw new NullPointerException("type == null");
+
+      this.boundary = boundary;
+      this.contentType = MediaType.parse(type + "; boundary=" + boundary.utf8());
+      this.partHeadings = Util.immutableList(partHeadings);
+      this.partBodies = Util.immutableList(partBodies);
+      if (length != -1) {
+        // Add the length of the final boundary.
+        length += CRLF.length + DASHDASH.length + boundary.size() + DASHDASH.length + CRLF.length;
+      }
+      this.length = length;
+    }
+
+    @Override public long contentLength() {
+      return length;
+    }
+
+    @Override public MediaType contentType() {
+      return contentType;
+    }
+
+    @Override public void writeTo(BufferedSink sink) throws IOException {
+      for (int i = 0, size = partHeadings.size(); i < size; i++) {
+        sink.writeAll(partHeadings.get(i).clone());
+        partBodies.get(i).writeTo(sink);
+      }
+
+      sink.write(CRLF);
+      sink.write(DASHDASH);
+      sink.write(boundary);
+      sink.write(DASHDASH);
+      sink.write(CRLF);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
index dc730ec53c..c49f1ec28a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
@@ -17,24 +17,17 @@
 
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.InternalCache;
+import com.squareup.okhttp.internal.RouteDatabase;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.http.AuthenticatorAdapter;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.Transport;
-import com.squareup.okhttp.internal.huc.AuthenticatorAdapter;
-import com.squareup.okhttp.internal.huc.CacheAdapter;
-import com.squareup.okhttp.internal.huc.HttpURLConnectionImpl;
-import com.squareup.okhttp.internal.huc.HttpsURLConnectionImpl;
 import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
 import java.io.IOException;
 import java.net.CookieHandler;
-import java.net.HttpURLConnection;
 import java.net.Proxy;
 import java.net.ProxySelector;
-import java.net.ResponseCache;
-import java.net.URL;
 import java.net.URLConnection;
-import java.net.URLStreamHandler;
-import java.net.URLStreamHandlerFactory;
 import java.security.GeneralSecurityException;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
@@ -54,7 +47,7 @@
  * {@link #clone()} to make a shallow copy of the OkHttpClient that can be
  * safely modified with further configuration changes.
  */
-public final class OkHttpClient implements URLStreamHandlerFactory, Cloneable {
+public class OkHttpClient implements Cloneable {
   static {
     Internal.instance = new Internal() {
       @Override public Transport newTransport(
@@ -74,10 +67,6 @@
         return connection.recycleCount();
       }
 
-      @Override public Object getOwner(Connection connection) {
-        return connection.getOwner();
-      }
-
       @Override public void setProtocol(Connection connection, Protocol protocol) {
         connection.setProtocol(protocol);
       }
@@ -86,24 +75,6 @@
         connection.setOwner(httpEngine);
       }
 
-      @Override public void connect(Connection connection, int connectTimeout, int readTimeout,
-          int writeTimeout, Request request) throws IOException {
-        connection.connect(connectTimeout, readTimeout, writeTimeout, request);
-      }
-
-      @Override public boolean isConnected(Connection connection) {
-        return connection.isConnected();
-      }
-
-      @Override public boolean isSpdy(Connection connection) {
-        return connection.isSpdy();
-      }
-
-      @Override public void setTimeouts(Connection connection, int readTimeout, int writeTimeout)
-          throws IOException {
-        connection.setTimeouts(readTimeout, writeTimeout);
-      }
-
       @Override public boolean isReadable(Connection pooled) {
         return pooled.isReadable();
       }
@@ -112,8 +83,8 @@
         builder.addLine(line);
       }
 
-      @Override public void setResponseCache(OkHttpClient client, ResponseCache responseCache) {
-        client.setResponseCache(responseCache);
+      @Override public void setCache(OkHttpClient client, InternalCache internalCache) {
+        client.setInternalCache(internalCache);
       }
 
       @Override public InternalCache internalCache(OkHttpClient client) {
@@ -124,12 +95,20 @@
         pool.recycle(connection);
       }
 
-      @Override public void share(ConnectionPool connectionPool, Connection connection) {
-        connectionPool.share(connection);
+      @Override public RouteDatabase routeDatabase(OkHttpClient client) {
+        return client.routeDatabase();
+      }
+
+      @Override public void connectAndSetOwner(OkHttpClient client, Connection connection,
+          HttpEngine owner, Request request) throws IOException {
+        connection.connectAndSetOwner(client, owner, request);
       }
     };
   }
 
+  /** Lazily-initialized. */
+  private static SSLSocketFactory defaultSslSocketFactory;
+
   private final RouteDatabase routeDatabase;
   private Dispatcher dispatcher;
   private Proxy proxy;
@@ -137,16 +116,18 @@
   private ProxySelector proxySelector;
   private CookieHandler cookieHandler;
 
-  // At least one of the two cache fields will be null.
+  /** Non-null if this client is caching; possibly by {@code cache}. */
+  private InternalCache internalCache;
   private Cache cache;
-  private CacheAdapter cacheAdapter;
 
   private SocketFactory socketFactory;
   private SSLSocketFactory sslSocketFactory;
   private HostnameVerifier hostnameVerifier;
-  private OkAuthenticator authenticator;
+  private Authenticator authenticator;
   private ConnectionPool connectionPool;
+  private HostResolver hostResolver;
   private boolean followSslRedirects = true;
+  private boolean followRedirects = true;
   private int connectTimeout;
   private int readTimeout;
   private int writeTimeout;
@@ -157,22 +138,42 @@ public OkHttpClient() {
     dispatcher = new Dispatcher();
   }
 
+  private OkHttpClient(OkHttpClient okHttpClient) {
+    this.routeDatabase = okHttpClient.routeDatabase();
+    this.dispatcher = okHttpClient.getDispatcher();
+    this.proxy = okHttpClient.getProxy();
+    this.protocols = okHttpClient.getProtocols();
+    this.proxySelector = okHttpClient.getProxySelector();
+    this.cookieHandler = okHttpClient.getCookieHandler();
+    this.cache = okHttpClient.getCache();
+    this.internalCache = cache != null ? cache.internalCache : okHttpClient.internalCache;
+    this.socketFactory = okHttpClient.getSocketFactory();
+    this.sslSocketFactory = okHttpClient.getSslSocketFactory();
+    this.hostnameVerifier = okHttpClient.getHostnameVerifier();
+    this.authenticator = okHttpClient.getAuthenticator();
+    this.connectionPool = okHttpClient.getConnectionPool();
+    this.followSslRedirects = okHttpClient.getFollowSslRedirects();
+    this.followRedirects = okHttpClient.getFollowRedirects();
+    this.connectTimeout = okHttpClient.getConnectTimeout();
+    this.readTimeout = okHttpClient.getReadTimeout();
+    this.writeTimeout = okHttpClient.getWriteTimeout();
+  }
+
   /**
    * Sets the default connect timeout for new connections. A value of 0 means no timeout.
    *
    * @see URLConnection#setConnectTimeout(int)
    */
-  public OkHttpClient setConnectTimeout(long timeout, TimeUnit unit) {
+  public final void setConnectTimeout(long timeout, TimeUnit unit) {
     if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
     if (unit == null) throw new IllegalArgumentException("unit == null");
     long millis = unit.toMillis(timeout);
     if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
     connectTimeout = (int) millis;
-    return this;
   }
 
   /** Default connect timeout (in milliseconds). */
-  public int getConnectTimeout() {
+  public final int getConnectTimeout() {
     return connectTimeout;
   }
 
@@ -181,34 +182,32 @@ public int getConnectTimeout() {
    *
    * @see URLConnection#setReadTimeout(int)
    */
-  public OkHttpClient setReadTimeout(long timeout, TimeUnit unit) {
+  public final void setReadTimeout(long timeout, TimeUnit unit) {
     if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
     if (unit == null) throw new IllegalArgumentException("unit == null");
     long millis = unit.toMillis(timeout);
     if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
     readTimeout = (int) millis;
-    return this;
   }
 
   /** Default read timeout (in milliseconds). */
-  public int getReadTimeout() {
+  public final int getReadTimeout() {
     return readTimeout;
   }
 
   /**
    * Sets the default write timeout for new connections. A value of 0 means no timeout.
    */
-  public OkHttpClient setWriteTimeout(long timeout, TimeUnit unit) {
+  public final void setWriteTimeout(long timeout, TimeUnit unit) {
     if (timeout < 0) throw new IllegalArgumentException("timeout < 0");
     if (unit == null) throw new IllegalArgumentException("unit == null");
     long millis = unit.toMillis(timeout);
     if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException("Timeout too large.");
     writeTimeout = (int) millis;
-    return this;
   }
 
   /** Default write timeout (in milliseconds). */
-  public int getWriteTimeout() {
+  public final int getWriteTimeout() {
     return writeTimeout;
   }
 
@@ -218,12 +217,12 @@ public int getWriteTimeout() {
    * only honored when this proxy is null (which it is by default). To disable
    * proxy use completely, call {@code setProxy(Proxy.NO_PROXY)}.
    */
-  public OkHttpClient setProxy(Proxy proxy) {
+  public final OkHttpClient setProxy(Proxy proxy) {
     this.proxy = proxy;
     return this;
   }
 
-  public Proxy getProxy() {
+  public final Proxy getProxy() {
     return proxy;
   }
 
@@ -236,12 +235,12 @@ public Proxy getProxy() {
    * <p>If unset, the {@link ProxySelector#getDefault() system-wide default}
    * proxy selector will be used.
    */
-  public OkHttpClient setProxySelector(ProxySelector proxySelector) {
+  public final OkHttpClient setProxySelector(ProxySelector proxySelector) {
     this.proxySelector = proxySelector;
     return this;
   }
 
-  public ProxySelector getProxySelector() {
+  public final ProxySelector getProxySelector() {
     return proxySelector;
   }
 
@@ -252,52 +251,47 @@ public ProxySelector getProxySelector() {
    * <p>If unset, the {@link CookieHandler#getDefault() system-wide default}
    * cookie handler will be used.
    */
-  public OkHttpClient setCookieHandler(CookieHandler cookieHandler) {
+  public final OkHttpClient setCookieHandler(CookieHandler cookieHandler) {
     this.cookieHandler = cookieHandler;
     return this;
   }
 
-  public CookieHandler getCookieHandler() {
+  public final CookieHandler getCookieHandler() {
     return cookieHandler;
   }
 
   /** Sets the response cache to be used to read and write cached responses. */
-  OkHttpClient setResponseCache(ResponseCache responseCache) {
-    this.cacheAdapter = responseCache != null ? new CacheAdapter(responseCache) : null;
+  final void setInternalCache(InternalCache internalCache) {
+    this.internalCache = internalCache;
     this.cache = null;
-    return this;
   }
 
-  ResponseCache getResponseCache() {
-    return cacheAdapter != null ? cacheAdapter.getDelegate() : null;
+  final InternalCache internalCache() {
+    return internalCache;
   }
 
-  public OkHttpClient setCache(Cache cache) {
+  public final OkHttpClient setCache(Cache cache) {
     this.cache = cache;
-    this.cacheAdapter = null;
+    this.internalCache = null;
     return this;
   }
 
-  public Cache getCache() {
+  public final Cache getCache() {
     return cache;
   }
 
-  InternalCache internalCache() {
-    return cache != null ? cache.internalCache : cacheAdapter;
-  }
-
   /**
    * Sets the socket factory used to create connections.
    *
    * <p>If unset, the {@link SocketFactory#getDefault() system-wide default}
    * socket factory will be used.
    */
-  public OkHttpClient setSocketFactory(SocketFactory socketFactory) {
+  public final OkHttpClient setSocketFactory(SocketFactory socketFactory) {
     this.socketFactory = socketFactory;
     return this;
   }
 
-  public SocketFactory getSocketFactory() {
+  public final SocketFactory getSocketFactory() {
     return socketFactory;
   }
 
@@ -306,12 +300,12 @@ public SocketFactory getSocketFactory() {
    *
    * <p>If unset, a lazily created SSL socket factory will be used.
    */
-  public OkHttpClient setSslSocketFactory(SSLSocketFactory sslSocketFactory) {
+  public final OkHttpClient setSslSocketFactory(SSLSocketFactory sslSocketFactory) {
     this.sslSocketFactory = sslSocketFactory;
     return this;
   }
 
-  public SSLSocketFactory getSslSocketFactory() {
+  public final SSLSocketFactory getSslSocketFactory() {
     return sslSocketFactory;
   }
 
@@ -323,12 +317,12 @@ public SSLSocketFactory getSslSocketFactory() {
    * {@link javax.net.ssl.HttpsURLConnection#getDefaultHostnameVerifier()
    * system-wide default} hostname verifier will be used.
    */
-  public OkHttpClient setHostnameVerifier(HostnameVerifier hostnameVerifier) {
+  public final OkHttpClient setHostnameVerifier(HostnameVerifier hostnameVerifier) {
     this.hostnameVerifier = hostnameVerifier;
     return this;
   }
 
-  public HostnameVerifier getHostnameVerifier() {
+  public final HostnameVerifier getHostnameVerifier() {
     return hostnameVerifier;
   }
 
@@ -339,12 +333,12 @@ public HostnameVerifier getHostnameVerifier() {
    * <p>If unset, the {@link java.net.Authenticator#setDefault system-wide default}
    * authenticator will be used.
    */
-  public OkHttpClient setAuthenticator(OkAuthenticator authenticator) {
+  public final OkHttpClient setAuthenticator(Authenticator authenticator) {
     this.authenticator = authenticator;
     return this;
   }
 
-  public OkAuthenticator getAuthenticator() {
+  public final Authenticator getAuthenticator() {
     return authenticator;
   }
 
@@ -354,12 +348,12 @@ public OkAuthenticator getAuthenticator() {
    * <p>If unset, the {@link ConnectionPool#getDefault() system-wide
    * default} connection pool will be used.
    */
-  public OkHttpClient setConnectionPool(ConnectionPool connectionPool) {
+  public final OkHttpClient setConnectionPool(ConnectionPool connectionPool) {
     this.connectionPool = connectionPool;
     return this;
   }
 
-  public ConnectionPool getConnectionPool() {
+  public final ConnectionPool getConnectionPool() {
     return connectionPool;
   }
 
@@ -385,16 +379,30 @@ public OkHttpClient setTransparentGzip(boolean enabledTransparentGzip) {
    * <p>If unset, protocol redirects will be followed. This is different than
    * the built-in {@code HttpURLConnection}'s default.
    */
-  public OkHttpClient setFollowSslRedirects(boolean followProtocolRedirects) {
+  public final OkHttpClient setFollowSslRedirects(boolean followProtocolRedirects) {
     this.followSslRedirects = followProtocolRedirects;
     return this;
   }
 
-  public boolean getFollowSslRedirects() {
+  public final boolean getFollowSslRedirects() {
     return followSslRedirects;
   }
 
-  public RouteDatabase getRoutesDatabase() {
+  /**
+   * Configure this client to follow redirects.
+   *
+   * <p>If unset, redirects will not be followed. This is the equivalent as the
+   * built-in {@code HttpURLConnection}'s default.
+   */
+  public final void setFollowRedirects(boolean followRedirects) {
+    this.followRedirects = followRedirects;
+  }
+
+  public final boolean getFollowRedirects() {
+    return followRedirects;
+  }
+
+  final RouteDatabase routeDatabase() {
     return routeDatabase;
   }
 
@@ -402,13 +410,13 @@ public RouteDatabase getRoutesDatabase() {
    * Sets the dispatcher used to set policy and execute asynchronous requests.
    * Must not be null.
    */
-  public OkHttpClient setDispatcher(Dispatcher dispatcher) {
+  public final OkHttpClient setDispatcher(Dispatcher dispatcher) {
     if (dispatcher == null) throw new IllegalArgumentException("dispatcher == null");
     this.dispatcher = dispatcher;
     return this;
   }
 
-  public Dispatcher getDispatcher() {
+  public final Dispatcher getDispatcher() {
     return dispatcher;
   }
 
@@ -423,11 +431,11 @@ public Dispatcher getDispatcher() {
    * <ul>
    *   <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
    *   <li><a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">spdy/3.1</a>
-   *   <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-10">h2-10</a>
+   *   <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-13">h2-13</a>
    * </ul>
    *
    * <p><strong>This is an evolving set.</strong> Future releases may drop
-   * support for transitional protocols (like h2-10), in favor of their
+   * support for transitional protocols (like h2-13), in favor of their
    * successors (h2). The http/1.1 transport will never be dropped.
    *
    * <p>If multiple protocols are specified, <a
@@ -438,7 +446,7 @@ public Dispatcher getDispatcher() {
    * @param protocols the protocols to use, in order of preference. The list
    *     must contain {@link Protocol#HTTP_1_1}. It must not contain null.
    */
-  public OkHttpClient setProtocols(List<Protocol> protocols) {
+  public final OkHttpClient setProtocols(List<Protocol> protocols) {
     protocols = Util.immutableList(protocols);
     if (!protocols.contains(Protocol.HTTP_1_1)) {
       throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
@@ -450,18 +458,28 @@ public OkHttpClient setProtocols(List<Protocol> protocols) {
     return this;
   }
 
-  public List<Protocol> getProtocols() {
+  public final List<Protocol> getProtocols() {
     return protocols;
   }
 
+  /*
+   * Sets the {@code HostResolver} that will be used by this client to resolve
+   * hostnames to IP addresses.
+   */
+  public OkHttpClient setHostResolver(HostResolver hostResolver) {
+    this.hostResolver = hostResolver;
+    return this;
+  }
+
+  public HostResolver getHostResolver() {
+    return hostResolver;
+  }
+
   /**
    * Prepares the {@code request} to be executed at some point in the future.
    */
   public Call newCall(Request request) {
-    // Copy the client. Otherwise changes (socket factory, redirect policy,
-    // etc.) may incorrectly be reflected in the request when it is executed.
-    OkHttpClient client = copyWithDefaults();
-    return new Call(client, dispatcher, request);
+    return new Call(this, request);
   }
 
   /**
@@ -469,41 +487,22 @@ public Call newCall(Request request) {
    * complete cannot be canceled.
    */
   public OkHttpClient cancel(Object tag) {
-    dispatcher.cancel(tag);
+    getDispatcher().cancel(tag);
     return this;
   }
 
-  public HttpURLConnection open(URL url) {
-    return open(url, proxy);
-  }
-
-  HttpURLConnection open(URL url, Proxy proxy) {
-    String protocol = url.getProtocol();
-    OkHttpClient copy = copyWithDefaults();
-    copy.proxy = proxy;
-
-    if (protocol.equals("http")) return new HttpURLConnectionImpl(url, copy);
-    if (protocol.equals("https")) return new HttpsURLConnectionImpl(url, copy);
-    throw new IllegalArgumentException("Unexpected protocol: " + protocol);
-  }
-
   /**
    * Returns a shallow copy of this OkHttpClient that uses the system-wide
    * default for each field that hasn't been explicitly configured.
    */
-  OkHttpClient copyWithDefaults() {
-    OkHttpClient result = clone();
+  final OkHttpClient copyWithDefaults() {
+    OkHttpClient result = new OkHttpClient(this);
     if (result.proxySelector == null) {
       result.proxySelector = ProxySelector.getDefault();
     }
     if (result.cookieHandler == null) {
       result.cookieHandler = CookieHandler.getDefault();
     }
-    if (result.cache == null && result.cacheAdapter == null) {
-      // TODO: drop support for the default response cache.
-      ResponseCache defaultCache = ResponseCache.getDefault();
-      result.cacheAdapter = defaultCache != null ? new CacheAdapter(defaultCache) : null;
-    }
     if (result.socketFactory == null) {
       result.socketFactory = SocketFactory.getDefault();
     }
@@ -522,6 +521,9 @@ OkHttpClient copyWithDefaults() {
     if (result.protocols == null) {
       result.protocols = Util.immutableList(Protocol.HTTP_2, Protocol.SPDY_3, Protocol.HTTP_1_1);
     }
+    if (result.hostResolver == null) {
+      result.hostResolver = HostResolver.DEFAULT;
+    }
     return result;
   }
 
@@ -531,60 +533,30 @@ OkHttpClient copyWithDefaults() {
    * used the shared SSL context, when OkHttp enables NPN for its SPDY-related
    * stuff, it would also enable NPN for other usages, which might crash them
    * because NPN is enabled when it isn't expected to be.
-   * <p>
-   * This code avoids that by defaulting to an OkHttp created SSL context. The
-   * significant drawback of this approach is that apps that customize the
-   * global SSL context will lose these customizations.
+   *
+   * <p>This code avoids that by defaulting to an OkHttp-created SSL context.
+   * The drawback of this approach is that apps that customize the global SSL
+   * context will lose these customizations.
    */
   private synchronized SSLSocketFactory getDefaultSSLSocketFactory() {
-    if (sslSocketFactory == null) {
+    if (defaultSslSocketFactory == null) {
       try {
         SSLContext sslContext = SSLContext.getInstance("TLS");
         sslContext.init(null, null, null);
-        sslSocketFactory = sslContext.getSocketFactory();
+        defaultSslSocketFactory = sslContext.getSocketFactory();
       } catch (GeneralSecurityException e) {
         throw new AssertionError(); // The system has no TLS. Just give up.
       }
     }
-    return sslSocketFactory;
+    return defaultSslSocketFactory;
   }
 
   /** Returns a shallow copy of this OkHttpClient. */
-  @Override public OkHttpClient clone() {
+  @Override public final OkHttpClient clone() {
     try {
       return (OkHttpClient) super.clone();
     } catch (CloneNotSupportedException e) {
       throw new AssertionError();
     }
   }
-
-  /**
-   * Creates a URLStreamHandler as a {@link URL#setURLStreamHandlerFactory}.
-   *
-   * <p>This code configures OkHttp to handle all HTTP and HTTPS connections
-   * created with {@link URL#openConnection()}: <pre>   {@code
-   *
-   *   OkHttpClient okHttpClient = new OkHttpClient();
-   *   URL.setURLStreamHandlerFactory(okHttpClient);
-   * }</pre>
-   */
-  public URLStreamHandler createURLStreamHandler(final String protocol) {
-    if (!protocol.equals("http") && !protocol.equals("https")) return null;
-
-    return new URLStreamHandler() {
-      @Override protected URLConnection openConnection(URL url) {
-        return open(url);
-      }
-
-      @Override protected URLConnection openConnection(URL url, Proxy proxy) {
-        return open(url, proxy);
-      }
-
-      @Override protected int getDefaultPort() {
-        if (protocol.equals("http")) return 80;
-        if (protocol.equals("https")) return 443;
-        throw new AssertionError();
-      }
-    };
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
index 354d825f84..ddde627310 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
@@ -63,13 +63,13 @@
    * HTTP/1.1 semantics are layered on HTTP/2.
    *
    * <p>This version of OkHttp implements HTTP/2 <a
-   * href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-10">draft 10</a>
+   * href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-13">draft 12</a>
    * with HPACK <a
-   * href="http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06">draft
+   * href="http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08">draft
    * 6</a>. Future releases of OkHttp may use this identifier for a newer draft
    * of these specs.
    */
-  HTTP_2("h2-10");
+  HTTP_2("h2-13");
 
   private final String protocol;
 
@@ -92,7 +92,7 @@ public static Protocol get(String protocol) throws IOException {
 
   /**
    * Returns the string used to identify this protocol for ALPN and NPN, like
-   * "http/1.1", "spdy/3.1" or "h2-10".
+   * "http/1.1", "spdy/3.1" or "h2-13".
    */
   @Override public String toString() {
     return protocol;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Request.java b/okhttp/src/main/java/com/squareup/okhttp/Request.java
index a6108e18f2..b8f417ebe3 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Request.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Request.java
@@ -16,56 +16,58 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.internal.Util;
-import java.io.File;
+import com.squareup.okhttp.internal.http.HttpMethod;
 import java.io.IOException;
-import java.io.UnsupportedEncodingException;
 import java.net.MalformedURLException;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
 import java.util.List;
-import okio.BufferedSink;
-import okio.Okio;
-import okio.Source;
 
 /**
  * An HTTP request. Instances of this class are immutable if their {@link #body}
  * is null or itself immutable.
  */
 public final class Request {
-  private final URL url;
+  private final String urlString;
   private final String method;
   private final Headers headers;
-  private final Body body;
+  private final RequestBody body;
   private final Object tag;
 
+  private volatile URL url; // Lazily initialized.
   private volatile URI uri; // Lazily initialized.
   private volatile CacheControl cacheControl; // Lazily initialized.
 
   private Request(Builder builder) {
-    this.url = builder.url;
+    this.urlString = builder.urlString;
     this.method = builder.method;
     this.headers = builder.headers.build();
     this.body = builder.body;
     this.tag = builder.tag != null ? builder.tag : this;
+    this.url = builder.url;
   }
 
   public URL url() {
-    return url;
+    try {
+      URL result = url;
+      return result != null ? result : (url = new URL(urlString));
+    } catch (MalformedURLException e) {
+      throw new RuntimeException("Malformed URL: " + urlString, e);
+    }
   }
 
   public URI uri() throws IOException {
     try {
       URI result = uri;
-      return result != null ? result : (uri = Platform.get().toUriLenient(url));
+      return result != null ? result : (uri = Platform.get().toUriLenient(url()));
     } catch (URISyntaxException e) {
       throw new IOException(e.getMessage());
     }
   }
 
   public String urlString() {
-    return url.toString();
+    return urlString;
   }
 
   public String method() {
@@ -84,7 +86,7 @@ public String header(String name) {
     return headers.values(name);
   }
 
-  public Body body() {
+  public RequestBody body() {
     return body;
   }
 
@@ -96,10 +98,6 @@ public Builder newBuilder() {
     return new Builder(this);
   }
 
-  public Headers getHeaders() {
-    return headers;
-  }
-
   /**
    * Returns the cache control directives for this response. This is never null,
    * even if this response contains no {@code Cache-Control} header.
@@ -117,95 +115,18 @@ public boolean isHttps() {
     return "Request{method="
         + method
         + ", url="
-        + url
+        + urlString
         + ", tag="
         + (tag != this ? tag : null)
         + '}';
   }
 
-  public abstract static class Body {
-    /** Returns the Content-Type header for this body. */
-    public abstract MediaType contentType();
-
-    /**
-     * Returns the number of bytes that will be written to {@code out} in a call
-     * to {@link #writeTo}, or -1 if that count is unknown.
-     */
-    public long contentLength() {
-      return -1;
-    }
-
-    /** Writes the content of this request to {@code out}. */
-    public abstract void writeTo(BufferedSink sink) throws IOException;
-
-    /**
-     * Returns a new request body that transmits {@code content}. If {@code
-     * contentType} lacks a charset, this will use UTF-8.
-     */
-    public static Body create(MediaType contentType, String content) {
-      contentType = contentType.charset() != null
-          ? contentType
-          : MediaType.parse(contentType + "; charset=utf-8");
-      try {
-        byte[] bytes = content.getBytes(contentType.charset().name());
-        return create(contentType, bytes);
-      } catch (UnsupportedEncodingException e) {
-        throw new AssertionError();
-      }
-    }
-
-    /** Returns a new request body that transmits {@code content}. */
-    public static Body create(final MediaType contentType, final byte[] content) {
-      if (contentType == null) throw new NullPointerException("contentType == null");
-      if (content == null) throw new NullPointerException("content == null");
-
-      return new Body() {
-        @Override public MediaType contentType() {
-          return contentType;
-        }
-
-        @Override public long contentLength() {
-          return content.length;
-        }
-
-        @Override public void writeTo(BufferedSink sink) throws IOException {
-          sink.write(content);
-        }
-      };
-    }
-
-    /** Returns a new request body that transmits the content of {@code file}. */
-    public static Body create(final MediaType contentType, final File file) {
-      if (contentType == null) throw new NullPointerException("contentType == null");
-      if (file == null) throw new NullPointerException("content == null");
-
-      return new Body() {
-        @Override public MediaType contentType() {
-          return contentType;
-        }
-
-        @Override public long contentLength() {
-          return file.length();
-        }
-
-        @Override public void writeTo(BufferedSink sink) throws IOException {
-          Source source = null;
-          try {
-            source = Okio.source(file);
-            sink.writeAll(source);
-          } finally {
-            Util.closeQuietly(source);
-          }
-        }
-      };
-    }
-  }
-
   public static class Builder {
+    private String urlString;
     private URL url;
     private String method;
     private Headers.Builder headers;
-    private Body body;
+    private RequestBody body;
     private Object tag;
 
     public Builder() {
@@ -214,6 +135,7 @@ public Builder() {
     }
 
     private Builder(Request request) {
+      this.urlString = request.urlString;
       this.url = request.url;
       this.method = request.method;
       this.body = request.body;
@@ -222,16 +144,15 @@ private Builder(Request request) {
     }
 
     public Builder url(String url) {
-      try {
-        return url(new URL(url));
-      } catch (MalformedURLException e) {
-        throw new IllegalArgumentException("Malformed URL: " + url);
-      }
+      if (url == null) throw new IllegalArgumentException("url == null");
+      urlString = url;
+      return this;
     }
 
     public Builder url(URL url) {
       if (url == null) throw new IllegalArgumentException("url == null");
       this.url = url;
+      this.urlString = url.toString();
       return this;
     }
 
@@ -272,7 +193,7 @@ public Builder head() {
       return method("HEAD", null);
     }
 
-    public Builder post(Body body) {
+    public Builder post(RequestBody body) {
       return method("POST", body);
     }
 
@@ -280,18 +201,21 @@ public Builder delete() {
       return method("DELETE", null);
     }
 
-    public Builder put(Body body) {
+    public Builder put(RequestBody body) {
       return method("PUT", body);
     }
 
-    public Builder patch(Body body) {
+    public Builder patch(RequestBody body) {
       return method("PATCH", body);
     }
 
-    public Builder method(String method, Body body) {
+    public Builder method(String method, RequestBody body) {
       if (method == null || method.length() == 0) {
         throw new IllegalArgumentException("method == null || method.length() == 0");
       }
+      if (body != null && !HttpMethod.hasRequestBody(method)) {
+        throw new IllegalArgumentException("method " + method + " must not have a request body.");
+      }
       this.method = method;
       this.body = body;
       return this;
@@ -308,7 +232,7 @@ public Builder tag(Object tag) {
     }
 
     public Request build() {
-      if (url == null) throw new IllegalStateException("url == null");
+      if (urlString == null) throw new IllegalStateException("url == null");
       return new Request(this);
     }
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java b/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java
new file mode 100644
index 0000000000..83203c3dbd
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/RequestBody.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.File;
+import java.io.IOException;
+import java.nio.charset.Charset;
+import okio.BufferedSink;
+import okio.Okio;
+import okio.Source;
+
+public abstract class RequestBody {
+  /** Returns the Content-Type header for this body. */
+  public abstract MediaType contentType();
+
+  /**
+   * Returns the number of bytes that will be written to {@code out} in a call
+   * to {@link #writeTo}, or -1 if that count is unknown.
+   */
+  public long contentLength() {
+    return -1;
+  }
+
+  /** Writes the content of this request to {@code out}. */
+  public abstract void writeTo(BufferedSink sink) throws IOException;
+
+  /**
+   * Returns a new request body that transmits {@code content}. If {@code
+   * contentType} is non-null and lacks a charset, this will use UTF-8.
+   */
+  public static RequestBody create(MediaType contentType, String content) {
+    Charset charset = Util.UTF_8;
+    if (contentType != null) {
+      charset = contentType.charset();
+      if (charset == null) {
+        charset = Util.UTF_8;
+        contentType = MediaType.parse(contentType + "; charset=utf-8");
+      }
+    }
+    byte[] bytes = content.getBytes(charset);
+    return create(contentType, bytes);
+  }
+
+  /** Returns a new request body that transmits {@code content}. */
+  public static RequestBody create(final MediaType contentType, final byte[] content) {
+    if (content == null) throw new NullPointerException("content == null");
+
+    return new RequestBody() {
+      @Override public MediaType contentType() {
+        return contentType;
+      }
+
+      @Override public long contentLength() {
+        return content.length;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.write(content);
+      }
+    };
+  }
+
+  /** Returns a new request body that transmits the content of {@code file}. */
+  public static RequestBody create(final MediaType contentType, final File file) {
+    if (file == null) throw new NullPointerException("content == null");
+
+    return new RequestBody() {
+      @Override public MediaType contentType() {
+        return contentType;
+      }
+
+      @Override public long contentLength() {
+        return file.length();
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        Source source = null;
+        try {
+          source = Okio.source(file);
+          sink.writeAll(source);
+        } finally {
+          Util.closeQuietly(source);
+        }
+      }
+    };
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Response.java b/okhttp/src/main/java/com/squareup/okhttp/Response.java
index bbec1ddec8..6a644333c6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Response.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Response.java
@@ -15,19 +15,10 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.OkHeaders;
-import java.io.Closeable;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.nio.charset.Charset;
 import java.util.Collections;
 import java.util.List;
-import okio.BufferedSource;
 
-import static com.squareup.okhttp.internal.Util.UTF_8;
 import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 import static java.net.HttpURLConnection.HTTP_MOVED_PERM;
 import static java.net.HttpURLConnection.HTTP_MOVED_TEMP;
@@ -48,8 +39,10 @@
   private final String message;
   private final Handshake handshake;
   private final Headers headers;
-  private final Body body;
-  private final Response redirectedBy;
+  private final ResponseBody body;
+  private Response networkResponse;
+  private Response cacheResponse;
+  private final Response priorResponse;
 
   private volatile CacheControl cacheControl; // Lazily initialized.
 
@@ -61,19 +54,20 @@ private Response(Builder builder) {
     this.handshake = builder.handshake;
     this.headers = builder.headers.build();
     this.body = builder.body;
-    this.redirectedBy = builder.redirectedBy;
+    this.networkResponse = builder.networkResponse;
+    this.cacheResponse = builder.cacheResponse;
+    this.priorResponse = builder.priorResponse;
   }
 
   /**
-   * The wire-level request that initiated this HTTP response. This is usually
-   * <strong>not</strong> the same request instance provided to the HTTP client:
+   * The wire-level request that initiated this HTTP response. This is not
+   * necessarily the same request issued by the application:
    * <ul>
    *     <li>It may be transformed by the HTTP client. For example, the client
-   *         may have added its own {@code Content-Encoding} header to enable
-   *         response compression.
-   *     <li>It may be the request generated in response to an HTTP redirect.
-   *         In this case the request URL may be different than the initial
-   *         request URL.
+   *         may copy headers like {@code Content-Length} from the request body.
+   *     <li>It may be the request generated in response to an HTTP redirect or
+   *         authentication challenge. In this case the request URL may be
+   *         different than the initial request URL.
    * </ul>
    */
   public Request request() {
@@ -88,11 +82,19 @@ public Protocol protocol() {
     return protocol;
   }
 
-  /** Returns the HTTP status code or -1 if it is unknown. */
+  /** Returns the HTTP status code. */
   public int code() {
     return code;
   }
 
+  /**
+   * Returns true if the code is in [200..300), which means the request was
+   * successfully received, understood, and accepted.
+   */
+  public boolean isSuccessful() {
+    return code >= 200 && code < 300;
+  }
+
   /** Returns the HTTP status message or null if it is unknown. */
   public String message() {
     return message;
@@ -123,7 +125,7 @@ public Headers headers() {
     return headers;
   }
 
-  public Body body() {
+  public ResponseBody body() {
     return body;
   }
 
@@ -145,14 +147,33 @@ public boolean isRedirect() {
     }
   }
 
+  /**
+   * Returns the raw response received from the network. Will be null if this
+   * response didn't use the network, such as when the response is fully cached.
+   * The body of the returned response should not be read.
+   */
+  public Response networkResponse() {
+    return networkResponse;
+  }
+
+  /**
+   * Returns the raw response received from the cache. Will be null if this
+   * response didn't use the cache. For conditional get requests the cache
+   * response and network response may both be non-null. The body of the
+   * returned response should not be read.
+   */
+  public Response cacheResponse() {
+    return cacheResponse;
+  }
+
   /**
    * Returns the response for the HTTP redirect or authorization challenge that
    * triggered this response, or null if this response wasn't triggered by an
    * automatic retry. The body of the returned response should not be read
    * because it has already been consumed by the redirecting client.
    */
-  public Response redirectedBy() {
-    return redirectedBy;
+  public Response priorResponse() {
+    return priorResponse;
   }
 
   /**
@@ -174,72 +195,6 @@ public Response redirectedBy() {
     return OkHeaders.parseChallenges(headers(), responseField);
   }
 
-  public abstract static class Body implements Closeable {
-    /** Multiple calls to {@link #charStream()} must return the same instance. */
-    private Reader reader;
-
-    public abstract MediaType contentType();
-
-    /**
-     * Returns the number of bytes in that will returned by {@link #bytes}, or
-     * {@link #byteStream}, or -1 if unknown.
-     */
-    public abstract long contentLength();
-
-    public final InputStream byteStream() {
-      return source().inputStream();
-    }
-
-    public abstract BufferedSource source();
-
-    public final byte[] bytes() throws IOException {
-      long contentLength = contentLength();
-      if (contentLength > Integer.MAX_VALUE) {
-        throw new IOException("Cannot buffer entire body for content length: " + contentLength);
-      }
-
-      BufferedSource source = source();
-      byte[] bytes;
-      try {
-        bytes = source.readByteArray();
-      } finally {
-        Util.closeQuietly(source);
-      }
-      if (contentLength != -1 && contentLength != bytes.length) {
-        throw new IOException("Content-Length and stream length disagree");
-      }
-      return bytes;
-    }
-
-    /**
-     * Returns the response as a character stream decoded with the charset
-     * of the Content-Type header. If that header is either absent or lacks a
-     * charset, this will attempt to decode the response body as UTF-8.
-     */
-    public final Reader charStream() {
-      Reader r = reader;
-      return r != null ? r : (reader = new InputStreamReader(byteStream(), charset()));
-    }
-
-    /**
-     * Returns the response as a string decoded with the charset of the
-     * Content-Type header. If that header is either absent or lacks a charset,
-     * this will attempt to decode the response body as UTF-8.
-     */
-    public final String string() throws IOException {
-      return new String(bytes(), charset().name());
-    }
-
-    private Charset charset() {
-      MediaType contentType = contentType();
-      return contentType != null ? contentType.charset(UTF_8) : UTF_8;
-    }
-
-    @Override public void close() throws IOException {
-      source().close();
-    }
-  }
-
   /**
    * Returns the cache control directives for this response. This is never null,
    * even if this response contains no {@code Cache-Control} header.
@@ -261,28 +216,6 @@ public CacheControl cacheControl() {
         + '}';
   }
 
-  public interface Callback {
-    /**
-     * Called when the request could not be executed due to cancellation, a
-     * connectivity problem or timeout. Because networks can fail during an
-     * exchange, it is possible that the remote server accepted the request
-     * before the failure.
-     */
-    void onFailure(Failure failure);
-
-    /**
-     * Called when the HTTP response was successfully returned by the remote
-     * server. The callback may proceed to read the response body with the
-     * response's {@link #body} method.
-     *
-     * <p>Note that transport-layer success (receiving a HTTP response code,
-     * headers and body) does not necessarily indicate application-layer
-     * success: {@code response} may still indicate an unhappy HTTP response
-     * code like 404 or 500.
-     */
-    void onResponse(Response response) throws IOException;
-  }
-
   public static class Builder {
     private Request request;
     private Protocol protocol;
@@ -290,8 +223,10 @@ public CacheControl cacheControl() {
     private String message;
     private Handshake handshake;
     private Headers.Builder headers;
-    private Body body;
-    private Response redirectedBy;
+    private ResponseBody body;
+    private Response networkResponse;
+    private Response cacheResponse;
+    private Response priorResponse;
 
     public Builder() {
       headers = new Headers.Builder();
@@ -305,7 +240,9 @@ private Builder(Response response) {
       this.handshake = response.handshake;
       this.headers = response.headers.newBuilder();
       this.body = response.body;
-      this.redirectedBy = response.redirectedBy;
+      this.networkResponse = response.networkResponse;
+      this.cacheResponse = response.cacheResponse;
+      this.priorResponse = response.priorResponse;
     }
 
     public Builder request(Request request) {
@@ -362,21 +299,47 @@ public Builder headers(Headers headers) {
       return this;
     }
 
-    public Builder body(Body body) {
+    public Builder body(ResponseBody body) {
       this.body = body;
       return this;
     }
 
-    // TODO: move out of public API
-    public Builder setResponseSource(ResponseSource responseSource) {
-      return header(OkHeaders.RESPONSE_SOURCE, responseSource + " " + code);
+    public Builder networkResponse(Response networkResponse) {
+      if (networkResponse != null) checkSupportResponse("networkResponse", networkResponse);
+      this.networkResponse = networkResponse;
+      return this;
+    }
+
+    public Builder cacheResponse(Response cacheResponse) {
+      if (cacheResponse != null) checkSupportResponse("cacheResponse", cacheResponse);
+      this.cacheResponse = cacheResponse;
+      return this;
+    }
+
+    private void checkSupportResponse(String name, Response response) {
+      if (response.body != null) {
+        throw new IllegalArgumentException(name + ".body != null");
+      } else if (response.networkResponse != null) {
+        throw new IllegalArgumentException(name + ".networkResponse != null");
+      } else if (response.cacheResponse != null) {
+        throw new IllegalArgumentException(name + ".cacheResponse != null");
+      } else if (response.priorResponse != null) {
+        throw new IllegalArgumentException(name + ".priorResponse != null");
+      }
     }
 
-    public Builder redirectedBy(Response redirectedBy) {
-      this.redirectedBy = redirectedBy;
+    public Builder priorResponse(Response priorResponse) {
+      if (priorResponse != null) checkPriorResponse(priorResponse);
+      this.priorResponse = priorResponse;
       return this;
     }
 
+    private void checkPriorResponse(Response response) {
+      if (response.body != null) {
+        throw new IllegalArgumentException("priorResponse.body != null");
+      }
+    }
+
     public Response build() {
       if (request == null) throw new IllegalStateException("request == null");
       if (protocol == null) throw new IllegalStateException("protocol == null");
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java b/okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java
new file mode 100644
index 0000000000..e91238a0f2
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/ResponseBody.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.Util;
+import java.io.Closeable;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.nio.charset.Charset;
+import okio.BufferedSource;
+
+import static com.squareup.okhttp.internal.Util.UTF_8;
+
+public abstract class ResponseBody implements Closeable {
+  /** Multiple calls to {@link #charStream()} must return the same instance. */
+  private Reader reader;
+
+  public abstract MediaType contentType();
+
+  /**
+   * Returns the number of bytes in that will returned by {@link #bytes}, or
+   * {@link #byteStream}, or -1 if unknown.
+   */
+  public abstract long contentLength();
+
+  public final InputStream byteStream() {
+    return source().inputStream();
+  }
+
+  public abstract BufferedSource source();
+
+  public final byte[] bytes() throws IOException {
+    long contentLength = contentLength();
+    if (contentLength > Integer.MAX_VALUE) {
+      throw new IOException("Cannot buffer entire body for content length: " + contentLength);
+    }
+
+    BufferedSource source = source();
+    byte[] bytes;
+    try {
+      bytes = source.readByteArray();
+    } finally {
+      Util.closeQuietly(source);
+    }
+    if (contentLength != -1 && contentLength != bytes.length) {
+      throw new IOException("Content-Length and stream length disagree");
+    }
+    return bytes;
+  }
+
+  /**
+   * Returns the response as a character stream decoded with the charset
+   * of the Content-Type header. If that header is either absent or lacks a
+   * charset, this will attempt to decode the response body as UTF-8.
+   */
+  public final Reader charStream() {
+    Reader r = reader;
+    return r != null ? r : (reader = new InputStreamReader(byteStream(), charset()));
+  }
+
+  /**
+   * Returns the response as a string decoded with the charset of the
+   * Content-Type header. If that header is either absent or lacks a charset,
+   * this will attempt to decode the response body as UTF-8.
+   */
+  public final String string() throws IOException {
+    return new String(bytes(), charset().name());
+  }
+
+  private Charset charset() {
+    MediaType contentType = contentType();
+    return contentType != null ? contentType.charset(UTF_8) : UTF_8;
+  }
+
+  @Override public void close() throws IOException {
+    source().close();
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ResponseSource.java b/okhttp/src/main/java/com/squareup/okhttp/ResponseSource.java
deleted file mode 100644
index 915fa58e68..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/ResponseSource.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2011 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp;
-
-/** The source of an HTTP response. */
-public enum ResponseSource {
-
-  /** The response was returned from the local cache. */
-  CACHE,
-
-  /**
-   * The response is available in the cache but must be validated with the
-   * network. The cache result will be used if it is still valid; otherwise
-   * the network's response will be used.
-   */
-  CONDITIONAL_CACHE,
-
-  /** The response was returned from the network. */
-  NETWORK,
-
-  /**
-   * The request demanded a cached response that the cache couldn't satisfy.
-   * This yields a 504 (Gateway Timeout) response as specified by
-   * http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.4.
-   */
-  NONE;
-
-  public boolean requiresConnection() {
-    return this == CONDITIONAL_CACHE || this == NETWORK;
-  }
-
-  public boolean usesCache() {
-    return this == CACHE || this == CONDITIONAL_CACHE;
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Route.java b/okhttp/src/main/java/com/squareup/okhttp/Route.java
index 197cf101f4..b6c42f530d 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Route.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Route.java
@@ -60,7 +60,8 @@ public Address getAddress() {
    * Returns the {@link Proxy} of this route.
    *
    * <strong>Warning:</strong> This may disagree with {@link Address#getProxy}
-   * is null. When the address's proxy is null, the proxy selector will be used.
+   * when it is null. When the address's proxy is null, the proxy selector is
+   * used.
    */
   public Proxy getProxy() {
     return proxy;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
index 926cb31655..05e06f5959 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
@@ -19,13 +19,9 @@
 import java.io.Closeable;
 import java.io.EOFException;
 import java.io.File;
-import java.io.FileInputStream;
 import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.FilterOutputStream;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
+import java.util.Arrays;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.Map;
@@ -37,7 +33,11 @@
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
+import okio.ForwardingSink;
 import okio.Okio;
+import okio.Sink;
+import okio.Source;
+import okio.Timeout;
 
 /**
  * A cache that uses a bounded amount of space on a filesystem. Each cache
@@ -145,8 +145,7 @@
   private final int valueCount;
   private long size = 0;
   private BufferedSink journalWriter;
-  private final LinkedHashMap<String, Entry> lruEntries =
-      new LinkedHashMap<String, Entry>(0, 0.75f, true);
+  private final LinkedHashMap<String, Entry> lruEntries = new LinkedHashMap<>(0, 0.75f, true);
   private int redundantOpCount;
 
   /**
@@ -224,7 +223,7 @@ public static DiskLruCache open(File directory, int appVersion, int valueCount,
       try {
         cache.readJournal();
         cache.processJournal();
-        cache.journalWriter = Okio.buffer(Okio.sink(new FileOutputStream(cache.journalFile, true)));
+        cache.journalWriter = Okio.buffer(Okio.appendingSink(cache.journalFile));
         return cache;
       } catch (IOException journalIsCorrupt) {
         Platform.get().logW("DiskLruCache " + directory + " is corrupt: "
@@ -326,8 +325,8 @@ private void processJournal() throws IOException {
       } else {
         entry.currentEditor = null;
         for (int t = 0; t < valueCount; t++) {
-          deleteIfExists(entry.getCleanFile(t));
-          deleteIfExists(entry.getDirtyFile(t));
+          deleteIfExists(entry.cleanFiles[t]);
+          deleteIfExists(entry.dirtyFiles[t]);
         }
         i.remove();
       }
@@ -343,7 +342,7 @@ private synchronized void rebuildJournal() throws IOException {
       journalWriter.close();
     }
 
-    BufferedSink writer = Okio.buffer(Okio.sink(new FileOutputStream(journalFileTmp)));
+    BufferedSink writer = Okio.buffer(Okio.sink(journalFileTmp));
     try {
       writer.writeUtf8(MAGIC).writeByte('\n');
       writer.writeUtf8(VERSION_1).writeByte('\n');
@@ -373,7 +372,7 @@ private synchronized void rebuildJournal() throws IOException {
     renameTo(journalFileTmp, journalFile, false);
     journalFileBackup.delete();
 
-    journalWriter = Okio.buffer(Okio.sink(new FileOutputStream(journalFile, true)));
+    journalWriter = Okio.buffer(Okio.appendingSink(journalFile));
   }
 
   private static void deleteIfExists(File file) throws IOException {
@@ -412,16 +411,16 @@ public synchronized Snapshot get(String key) throws IOException {
     // Open all streams eagerly to guarantee that we see a single published
     // snapshot. If we opened streams lazily then the streams could come
     // from different edits.
-    InputStream[] ins = new InputStream[valueCount];
+    Source[] sources = new Source[valueCount];
     try {
       for (int i = 0; i < valueCount; i++) {
-        ins[i] = new FileInputStream(entry.getCleanFile(i));
+        sources[i] = Okio.source(entry.cleanFiles[i]);
       }
     } catch (FileNotFoundException e) {
       // A file must have been deleted manually!
       for (int i = 0; i < valueCount; i++) {
-        if (ins[i] != null) {
-          Util.closeQuietly(ins[i]);
+        if (sources[i] != null) {
+          Util.closeQuietly(sources[i]);
         } else {
           break;
         }
@@ -435,7 +434,7 @@ public synchronized Snapshot get(String key) throws IOException {
       executorService.execute(cleanupRunnable);
     }
 
-    return new Snapshot(key, entry.sequenceNumber, ins, entry.lengths);
+    return new Snapshot(key, entry.sequenceNumber, sources, entry.lengths);
   }
 
   /**
@@ -514,7 +513,7 @@ private synchronized void completeEdit(Editor editor, boolean success) throws IO
           editor.abort();
           throw new IllegalStateException("Newly created entry didn't create value for index " + i);
         }
-        if (!entry.getDirtyFile(i).exists()) {
+        if (!entry.dirtyFiles[i].exists()) {
           editor.abort();
           return;
         }
@@ -522,10 +521,10 @@ private synchronized void completeEdit(Editor editor, boolean success) throws IO
     }
 
     for (int i = 0; i < valueCount; i++) {
-      File dirty = entry.getDirtyFile(i);
+      File dirty = entry.dirtyFiles[i];
       if (success) {
         if (dirty.exists()) {
-          File clean = entry.getCleanFile(i);
+          File clean = entry.cleanFiles[i];
           dirty.renameTo(clean);
           long oldLength = entry.lengths[i];
           long newLength = clean.length();
@@ -586,7 +585,7 @@ public synchronized boolean remove(String key) throws IOException {
     }
 
     for (int i = 0; i < valueCount; i++) {
-      File file = entry.getCleanFile(i);
+      File file = entry.cleanFiles[i];
       deleteIfExists(file);
       size -= entry.lengths[i];
       entry.lengths[i] = 0;
@@ -662,11 +661,9 @@ private void validateKey(String key) {
     }
   }
 
-  private static String inputStreamToString(InputStream in) throws IOException {
+  private static String sourceToString(Source in) throws IOException {
     try {
-      Buffer buffer = new Buffer();
-      buffer.writeAll(Okio.source(in));
-      return buffer.readUtf8();
+      return Okio.buffer(in).readUtf8();
     } finally {
       Util.closeQuietly(in);
     }
@@ -676,13 +673,13 @@ private static String inputStreamToString(InputStream in) throws IOException {
   public final class Snapshot implements Closeable {
     private final String key;
     private final long sequenceNumber;
-    private final InputStream[] ins;
+    private final Source[] sources;
     private final long[] lengths;
 
-    private Snapshot(String key, long sequenceNumber, InputStream[] ins, long[] lengths) {
+    private Snapshot(String key, long sequenceNumber, Source[] sources, long[] lengths) {
       this.key = key;
       this.sequenceNumber = sequenceNumber;
-      this.ins = ins;
+      this.sources = sources;
       this.lengths = lengths;
     }
 
@@ -696,13 +693,13 @@ public Editor edit() throws IOException {
     }
 
     /** Returns the unbuffered stream with the value for {@code index}. */
-    public InputStream getInputStream(int index) {
-      return ins[index];
+    public Source getSource(int index) {
+      return sources[index];
     }
 
     /** Returns the string value for {@code index}. */
     public String getString(int index) throws IOException {
-      return inputStreamToString(getInputStream(index));
+      return sourceToString(getSource(index));
     }
 
     /** Returns the byte length of the value for {@code index}. */
@@ -711,17 +708,26 @@ public long getLength(int index) {
     }
 
     public void close() {
-      for (InputStream in : ins) {
+      for (Source in : sources) {
         Util.closeQuietly(in);
       }
     }
   }
 
-  private static final OutputStream NULL_OUTPUT_STREAM = new OutputStream() {
-    @Override
-    public void write(int b) throws IOException {
+  private static final Sink NULL_SINK = new Sink() {
+    @Override public void write(Buffer source, long byteCount) throws IOException {
       // Eat all writes silently. Nom nom.
     }
+
+    @Override public void flush() throws IOException {
+    }
+
+    @Override public Timeout timeout() {
+      return Timeout.NONE;
+    }
+
+    @Override public void close() throws IOException {
+    }
   };
 
   /** Edits the values for an entry. */
@@ -740,7 +746,7 @@ private Editor(Entry entry) {
      * Returns an unbuffered input stream to read the last committed value,
      * or null if no value has been committed.
      */
-    public InputStream newInputStream(int index) throws IOException {
+    public Source newSource(int index) throws IOException {
       synchronized (DiskLruCache.this) {
         if (entry.currentEditor != this) {
           throw new IllegalStateException();
@@ -749,7 +755,7 @@ public InputStream newInputStream(int index) throws IOException {
           return null;
         }
         try {
-          return new FileInputStream(entry.getCleanFile(index));
+          return Okio.source(entry.cleanFiles[index]);
         } catch (FileNotFoundException e) {
           return null;
         }
@@ -761,8 +767,8 @@ public InputStream newInputStream(int index) throws IOException {
      * has been committed.
      */
     public String getString(int index) throws IOException {
-      InputStream in = newInputStream(index);
-      return in != null ? inputStreamToString(in) : null;
+      Source source = newSource(index);
+      return source != null ? sourceToString(source) : null;
     }
 
     /**
@@ -772,7 +778,7 @@ public String getString(int index) throws IOException {
      * {@link #commit} is called. The returned output stream does not throw
      * IOExceptions.
      */
-    public OutputStream newOutputStream(int index) throws IOException {
+    public Sink newSink(int index) throws IOException {
       synchronized (DiskLruCache.this) {
         if (entry.currentEditor != this) {
           throw new IllegalStateException();
@@ -780,27 +786,27 @@ public OutputStream newOutputStream(int index) throws IOException {
         if (!entry.readable) {
           written[index] = true;
         }
-        File dirtyFile = entry.getDirtyFile(index);
-        FileOutputStream outputStream;
+        File dirtyFile = entry.dirtyFiles[index];
+        Sink sink;
         try {
-          outputStream = new FileOutputStream(dirtyFile);
+          sink = Okio.sink(dirtyFile);
         } catch (FileNotFoundException e) {
           // Attempt to recreate the cache directory.
           directory.mkdirs();
           try {
-            outputStream = new FileOutputStream(dirtyFile);
+            sink = Okio.sink(dirtyFile);
           } catch (FileNotFoundException e2) {
             // We are unable to recover. Silently eat the writes.
-            return NULL_OUTPUT_STREAM;
+            return NULL_SINK;
           }
         }
-        return new FaultHidingOutputStream(outputStream);
+        return new FaultHidingSink(sink);
       }
     }
 
     /** Sets the value at {@code index} to {@code value}. */
     public void set(int index, String value) throws IOException {
-      BufferedSink writer = Okio.buffer(Okio.sink(newOutputStream(index)));
+      BufferedSink writer = Okio.buffer(newSink(index));
       writer.writeUtf8(value);
       writer.close();
     }
@@ -836,38 +842,30 @@ public void abortUnlessCommitted() {
       }
     }
 
-    private class FaultHidingOutputStream extends FilterOutputStream {
-      private FaultHidingOutputStream(OutputStream out) {
-        super(out);
-      }
-
-      @Override public void write(int oneByte) {
-        try {
-          out.write(oneByte);
-        } catch (IOException e) {
-          hasErrors = true;
-        }
+    private class FaultHidingSink extends ForwardingSink {
+      public FaultHidingSink(Sink delegate) {
+        super(delegate);
       }
 
-      @Override public void write(byte[] buffer, int offset, int length) {
+      @Override public void write(Buffer source, long byteCount) throws IOException {
         try {
-          out.write(buffer, offset, length);
+          super.write(source, byteCount);
         } catch (IOException e) {
           hasErrors = true;
         }
       }
 
-      @Override public void close() {
+      @Override public void flush() throws IOException {
         try {
-          out.close();
+          super.flush();
         } catch (IOException e) {
           hasErrors = true;
         }
       }
 
-      @Override public void flush() {
+      @Override public void close() throws IOException {
         try {
-          out.flush();
+          super.close();
         } catch (IOException e) {
           hasErrors = true;
         }
@@ -880,6 +878,8 @@ private FaultHidingOutputStream(OutputStream out) {
 
     /** Lengths of this entry's files. */
     private final long[] lengths;
+    private final File[] cleanFiles;
+    private final File[] dirtyFiles;
 
     /** True if this entry has ever been published. */
     private boolean readable;
@@ -892,7 +892,21 @@ private FaultHidingOutputStream(OutputStream out) {
 
     private Entry(String key) {
       this.key = key;
-      this.lengths = new long[valueCount];
+
+      lengths = new long[valueCount];
+      cleanFiles = new File[valueCount];
+      dirtyFiles = new File[valueCount];
+
+      // The names are repetitive so re-use the same builder to avoid allocations.
+      StringBuilder fileBuilder = new StringBuilder(key).append('.');
+      int truncateTo = fileBuilder.length();
+      for (int i = 0; i < valueCount; i++) {
+        fileBuilder.append(i);
+        cleanFiles[i] = new File(directory, fileBuilder.toString());
+        fileBuilder.append(".tmp");
+        dirtyFiles[i] = new File(directory, fileBuilder.toString());
+        fileBuilder.setLength(truncateTo);
+      }
     }
 
     public String getLengths() throws IOException {
@@ -919,15 +933,7 @@ private void setLengths(String[] strings) throws IOException {
     }
 
     private IOException invalidLengths(String[] strings) throws IOException {
-      throw new IOException("unexpected journal line: " + java.util.Arrays.toString(strings));
-    }
-
-    public File getCleanFile(int i) {
-      return new File(directory, key + "." + i);
-    }
-
-    public File getDirtyFile(int i) {
-      return new File(directory, key + "." + i + ".tmp");
+      throw new IOException("unexpected journal line: " + Arrays.toString(strings));
     }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java
index 97abbb4f60..a4d3a6229a 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Internal.java
@@ -24,7 +24,6 @@
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.Transport;
 import java.io.IOException;
-import java.net.ResponseCache;
 
 /**
  * Escalate internal APIs in {@code com.squareup.okhttp} so they can be used
@@ -43,31 +42,22 @@ public abstract Transport newTransport(Connection connection, HttpEngine httpEng
 
   public abstract int recycleCount(Connection connection);
 
-  public abstract Object getOwner(Connection connection);
-
   public abstract void setProtocol(Connection connection, Protocol protocol);
 
   public abstract void setOwner(Connection connection, HttpEngine httpEngine);
 
-  public abstract void connect(Connection connection,
-      int connectTimeout, int readTimeout, int writeTimeout, Request request) throws IOException;
-
-  public abstract boolean isConnected(Connection connection);
-
-  public abstract boolean isSpdy(Connection connection);
-
-  public abstract void setTimeouts(Connection connection, int readTimeout, int writeTimeout)
-      throws IOException;
-
   public abstract boolean isReadable(Connection pooled);
 
   public abstract void addLine(Headers.Builder builder, String line);
 
-  public abstract void setResponseCache(OkHttpClient client, ResponseCache responseCache);
+  public abstract void setCache(OkHttpClient client, InternalCache internalCache);
 
   public abstract InternalCache internalCache(OkHttpClient client);
 
   public abstract void recycle(ConnectionPool pool, Connection connection);
 
-  public abstract void share(ConnectionPool connectionPool, Connection connection);
+  public abstract RouteDatabase routeDatabase(OkHttpClient client);
+
+  public abstract void connectAndSetOwner(OkHttpClient client, Connection connection,
+      HttpEngine owner, Request request) throws IOException;
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/InternalCache.java b/okhttp/src/main/java/com/squareup/okhttp/internal/InternalCache.java
index 73f124545d..4925358225 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/InternalCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/InternalCache.java
@@ -17,9 +17,9 @@
 
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseSource;
+import com.squareup.okhttp.internal.http.CacheRequest;
+import com.squareup.okhttp.internal.http.CacheStrategy;
 import java.io.IOException;
-import java.net.CacheRequest;
 
 /**
  * OkHttp's internal cache interface. Applications shouldn't implement this:
@@ -47,6 +47,6 @@
   /** Track an conditional GET that was satisfied by this cache. */
   void trackConditionalCacheHit();
 
-  /** Track an HTTP response being satisfied by {@code source}. */
-  void trackResponse(ResponseSource source);
+  /** Track an HTTP response being satisfied with {@code cacheStrategy}. */
+  void trackResponse(CacheStrategy cacheStrategy);
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
index c4518fa39b..70ae3ee6d4 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
@@ -132,16 +132,28 @@ private static Platform findPlatform() {
       setUseSessionTickets = openSslSocketClass.getMethod("setUseSessionTickets", boolean.class);
       setHostname = openSslSocketClass.getMethod("setHostname", String.class);
 
+      // Attempt to find Android 4.0+ APIs.
+      Method trafficStatsTagSocket = null;
+      Method trafficStatsUntagSocket = null;
+      try {
+        Class<?> trafficStats = Class.forName("android.net.TrafficStats");
+        trafficStatsTagSocket = trafficStats.getMethod("tagSocket", Socket.class);
+        trafficStatsUntagSocket = trafficStats.getMethod("untagSocket", Socket.class);
+      } catch (ClassNotFoundException ignored) {
+      } catch (NoSuchMethodException ignored) {
+      }
+
       // Attempt to find Android 4.1+ APIs.
       Method setNpnProtocols = null;
       Method getNpnSelectedProtocol = null;
       try {
         setNpnProtocols = openSslSocketClass.getMethod("setNpnProtocols", byte[].class);
-        getNpnSelectedProtocol = openSslSocketClass.getMethod("getSelectedProtocol");
+        getNpnSelectedProtocol = openSslSocketClass.getMethod("getNpnSelectedProtocol");
       } catch (NoSuchMethodException ignored) {
       }
 
-      return new Android(openSslSocketClass, setUseSessionTickets, setHostname, setNpnProtocols,
+      return new Android(openSslSocketClass, setUseSessionTickets, setHostname,
+          trafficStatsTagSocket, trafficStatsUntagSocket, setNpnProtocols,
           getNpnSelectedProtocol);
     } catch (ClassNotFoundException ignored) {
       // This isn't an Android runtime.
@@ -182,15 +194,22 @@ private static Platform findPlatform() {
     private final Method setUseSessionTickets;
     private final Method setHostname;
 
+    // Non-null on Android 4.0+.
+    private final Method trafficStatsTagSocket;
+    private final Method trafficStatsUntagSocket;
+
     // Non-null on Android 4.1+.
     private final Method setNpnProtocols;
     private final Method getNpnSelectedProtocol;
 
     private Android(Class<?> openSslSocketClass, Method setUseSessionTickets, Method setHostname,
-        Method setNpnProtocols, Method getNpnSelectedProtocol) {
+        Method trafficStatsTagSocket, Method trafficStatsUntagSocket, Method setNpnProtocols,
+        Method getNpnSelectedProtocol) {
       this.openSslSocketClass = openSslSocketClass;
       this.setUseSessionTickets = setUseSessionTickets;
       this.setHostname = setHostname;
+      this.trafficStatsTagSocket = trafficStatsTagSocket;
+      this.trafficStatsUntagSocket = trafficStatsUntagSocket;
       this.setNpnProtocols = setNpnProtocols;
       this.getNpnSelectedProtocol = getNpnSelectedProtocol;
     }
@@ -249,6 +268,30 @@ private Android(Class<?> openSslSocketClass, Method setUseSessionTickets, Method
         throw new AssertionError(e);
       }
     }
+
+    @Override public void tagSocket(Socket socket) throws SocketException {
+      if (trafficStatsTagSocket == null) return;
+
+      try {
+        trafficStatsTagSocket.invoke(null, socket);
+      } catch (IllegalAccessException e) {
+        throw new RuntimeException(e);
+      } catch (InvocationTargetException e) {
+        throw new RuntimeException(e);
+      }
+    }
+
+    @Override public void untagSocket(Socket socket) throws SocketException {
+      if (trafficStatsUntagSocket == null) return;
+
+      try {
+        trafficStatsUntagSocket.invoke(null, socket);
+      } catch (IllegalAccessException e) {
+        throw new RuntimeException(e);
+      } catch (InvocationTargetException e) {
+        throw new RuntimeException(e);
+      }
+    }
   }
 
   /**
@@ -271,7 +314,7 @@ public JdkWithJettyBootPlatform(Method putMethod, Method getMethod,
 
     @Override public void setProtocols(SSLSocket socket, List<Protocol> protocols) {
       try {
-        List<String> names = new ArrayList<String>(protocols.size());
+        List<String> names = new ArrayList<>(protocols.size());
         for (int i = 0, size = protocols.size(); i < size; i++) {
           Protocol protocol = protocols.get(i);
           if (protocol == Protocol.HTTP_1_0) continue; // No HTTP/1.0 for NPN or ALPN.
@@ -367,7 +410,6 @@ public JettyNegoProvider(List<String> protocols) {
       result.writeByte(protocol.toString().length());
       result.writeUtf8(protocol.toString());
     }
-    // TODO change to result.readByteArray() when Okio 0.8.1+ is available.
-    return result.readByteArray(result.size());
+    return result.readByteArray();
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/RouteDatabase.java b/okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java
similarity index 92%
rename from okhttp/src/main/java/com/squareup/okhttp/RouteDatabase.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java
index 4177c0fb1b..52c211eb54 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/RouteDatabase.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/RouteDatabase.java
@@ -13,8 +13,9 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp;
+package com.squareup.okhttp.internal;
 
+import com.squareup.okhttp.Route;
 import java.util.LinkedHashSet;
 import java.util.Set;
 
@@ -26,7 +27,7 @@
  * preferred.
  */
 public final class RouteDatabase {
-  private final Set<Route> failedRoutes = new LinkedHashSet<Route>();
+  private final Set<Route> failedRoutes = new LinkedHashSet<>();
 
   /** Records a failure connecting to {@code failedRoute}. */
   public synchronized void failed(Route failedRoute) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
index 1b86147d15..64857d35fa 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
@@ -198,7 +198,7 @@ public static String hash(String s) {
 
   /** Returns an immutable copy of {@code list}. */
   public static <T> List<T> immutableList(List<T> list) {
-    return Collections.unmodifiableList(new ArrayList<T>(list));
+    return Collections.unmodifiableList(new ArrayList<>(list));
   }
 
   /** Returns an immutable list containing {@code elements}. */
@@ -217,7 +217,7 @@ public static ThreadFactory threadFactory(final String name, final boolean daemo
   }
 
   public static List<Header> headerEntries(String... elements) {
-    List<Header> result = new ArrayList<Header>(elements.length / 2);
+    List<Header> result = new ArrayList<>(elements.length / 2);
     for (int i = 0; i < elements.length; i += 2) {
       result.add(new Header(elements[i], elements[i + 1]));
     }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/huc/AuthenticatorAdapter.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java
similarity index 79%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/huc/AuthenticatorAdapter.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java
index 79e1f9938b..a517ada7cc 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/huc/AuthenticatorAdapter.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/AuthenticatorAdapter.java
@@ -13,15 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.huc;
+package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.Authenticator;
 import com.squareup.okhttp.Challenge;
 import com.squareup.okhttp.Credentials;
-import com.squareup.okhttp.OkAuthenticator;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import java.io.IOException;
-import java.net.Authenticator;
+import java.net.Authenticator.RequestorType;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.PasswordAuthentication;
@@ -29,10 +29,10 @@
 import java.net.URL;
 import java.util.List;
 
-/** Adapts {@link Authenticator} to {@link OkAuthenticator}. */
-public final class AuthenticatorAdapter implements OkAuthenticator {
+/** Adapts {@link java.net.Authenticator} to {@link com.squareup.okhttp.Authenticator}. */
+public final class AuthenticatorAdapter implements Authenticator {
   /** Uses the global authenticator to get the password. */
-  public static final OkAuthenticator INSTANCE = new AuthenticatorAdapter();
+  public static final Authenticator INSTANCE = new AuthenticatorAdapter();
 
   @Override public Request authenticate(Proxy proxy, Response response) throws IOException {
     List<Challenge> challenges = response.challenges();
@@ -42,9 +42,9 @@
       Challenge challenge = challenges.get(i);
       if (!"Basic".equalsIgnoreCase(challenge.getScheme())) continue;
 
-      PasswordAuthentication auth = Authenticator.requestPasswordAuthentication(url.getHost(),
-          getConnectToInetAddress(proxy, url), url.getPort(), url.getProtocol(),
-          challenge.getRealm(), challenge.getScheme(), url, Authenticator.RequestorType.SERVER);
+      PasswordAuthentication auth = java.net.Authenticator.requestPasswordAuthentication(
+          url.getHost(), getConnectToInetAddress(proxy, url), url.getPort(), url.getProtocol(),
+          challenge.getRealm(), challenge.getScheme(), url, RequestorType.SERVER);
       if (auth == null) continue;
 
       String credential = Credentials.basic(auth.getUserName(), new String(auth.getPassword()));
@@ -65,10 +65,10 @@
       if (!"Basic".equalsIgnoreCase(challenge.getScheme())) continue;
 
       InetSocketAddress proxyAddress = (InetSocketAddress) proxy.address();
-      PasswordAuthentication auth = Authenticator.requestPasswordAuthentication(
+      PasswordAuthentication auth = java.net.Authenticator.requestPasswordAuthentication(
           proxyAddress.getHostName(), getConnectToInetAddress(proxy, url), proxyAddress.getPort(),
           url.getProtocol(), challenge.getRealm(), challenge.getScheme(), url,
-          Authenticator.RequestorType.PROXY);
+          RequestorType.PROXY);
       if (auth == null) continue;
 
       String credential = Credentials.basic(auth.getUserName(), new String(auth.getPassword()));
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheRequest.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheRequest.java
new file mode 100644
index 0000000000..b8153e4f07
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheRequest.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import java.io.IOException;
+import okio.Sink;
+
+public interface CacheRequest {
+  Sink body() throws IOException;
+  void abort();
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
index d6b2770afe..ddf1b38ce1 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
@@ -1,15 +1,10 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.CacheControl;
-import com.squareup.okhttp.MediaType;
-import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseSource;
 import java.net.HttpURLConnection;
 import java.util.Date;
-import okio.Buffer;
-import okio.BufferedSource;
 
 import static java.util.concurrent.TimeUnit.SECONDS;
 
@@ -22,27 +17,15 @@
  * response (if the cached data is potentially stale).
  */
 public final class CacheStrategy {
-  private static final Response.Body EMPTY_BODY = new Response.Body() {
-    @Override public MediaType contentType() {
-      return null;
-    }
-    @Override public long contentLength() {
-      return 0;
-    }
-    @Override public BufferedSource source() {
-      return new Buffer();
-    }
-  };
+  /** The request to send on the network, or null if this call doesn't use the network. */
+  public final Request networkRequest;
 
-  public final Request request;
-  public final Response response;
-  public final ResponseSource source;
+  /** The cached response to return or validate; or null if this call doesn't use a cache. */
+  public final Response cacheResponse;
 
-  private CacheStrategy(
-      Request request, Response response, ResponseSource source) {
-    this.request = request;
-    this.response = response;
-    this.source = source;
+  private CacheStrategy(Request networkRequest, Response cacheResponse) {
+    this.networkRequest = networkRequest;
+    this.cacheResponse = cacheResponse;
   }
 
   /**
@@ -152,17 +135,9 @@ public Factory(long nowMillis, Request request, Response cacheResponse) {
     public CacheStrategy get() {
       CacheStrategy candidate = getCandidate();
 
-      if (candidate.source != ResponseSource.CACHE && request.cacheControl().onlyIfCached()) {
-        // We're forbidden from using the network, but the cache is insufficient.
-        Response noneResponse = new Response.Builder()
-            .request(candidate.request)
-            .protocol(Protocol.HTTP_1_1)
-            .code(504)
-            .message("Gateway Timeout")
-            .setResponseSource(ResponseSource.NONE)
-            .body(EMPTY_BODY)
-            .build();
-        return new CacheStrategy(candidate.request, noneResponse, ResponseSource.NONE);
+      if (candidate.networkRequest != null && request.cacheControl().onlyIfCached()) {
+        // We're forbidden from using the network and the cache is insufficient.
+        return new CacheStrategy(null, null);
       }
 
       return candidate;
@@ -172,24 +147,24 @@ public CacheStrategy get() {
     private CacheStrategy getCandidate() {
       // No cached response.
       if (cacheResponse == null) {
-        return new CacheStrategy(request, cacheResponse, ResponseSource.NETWORK);
+        return new CacheStrategy(request, null);
       }
 
       // Drop the cached response if it's missing a required handshake.
       if (request.isHttps() && cacheResponse.handshake() == null) {
-        return new CacheStrategy(request, cacheResponse, ResponseSource.NETWORK);
+        return new CacheStrategy(request, null);
       }
 
       // If this response shouldn't have been stored, it should never be used
       // as a response source. This check should be redundant as long as the
       // persistence store is well-behaved and the rules are constant.
       if (!isCacheable(cacheResponse, request)) {
-        return new CacheStrategy(request, cacheResponse, ResponseSource.NETWORK);
+        return new CacheStrategy(request, null);
       }
 
       CacheControl requestCaching = request.cacheControl();
       if (requestCaching.noCache() || hasConditions(request)) {
-        return new CacheStrategy(request, cacheResponse, ResponseSource.NETWORK);
+        return new CacheStrategy(request, null);
       }
 
       long ageMillis = cacheResponseAge();
@@ -211,8 +186,7 @@ private CacheStrategy getCandidate() {
       }
 
       if (!responseCaching.noCache() && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
-        Response.Builder builder = cacheResponse.newBuilder()
-            .setResponseSource(ResponseSource.CACHE); // Overwrite any stored response source.
+        Response.Builder builder = cacheResponse.newBuilder();
         if (ageMillis + minFreshMillis >= freshMillis) {
           builder.addHeader("Warning", "110 HttpURLConnection \"Response is stale\"");
         }
@@ -220,7 +194,7 @@ private CacheStrategy getCandidate() {
         if (ageMillis > oneDayMillis && isFreshnessLifetimeHeuristic()) {
           builder.addHeader("Warning", "113 HttpURLConnection \"Heuristic expiration\"");
         }
-        return new CacheStrategy(request, builder.build(), ResponseSource.CACHE);
+        return new CacheStrategy(null, builder.build());
       }
 
       Request.Builder conditionalRequestBuilder = request.newBuilder();
@@ -236,10 +210,9 @@ private CacheStrategy getCandidate() {
       }
 
       Request conditionalRequest = conditionalRequestBuilder.build();
-      ResponseSource responseSource = hasConditions(conditionalRequest)
-          ? ResponseSource.CONDITIONAL_CACHE
-          : ResponseSource.NETWORK;
-      return new CacheStrategy(conditionalRequest, cacheResponse, responseSource);
+      return hasConditions(conditionalRequest)
+          ? new CacheStrategy(conditionalRequest, cacheResponse)
+          : new CacheStrategy(conditionalRequest, null);
     }
 
     /**
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
index 75b3db6afe..b10dea0876 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
@@ -23,8 +23,6 @@
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
-import java.io.OutputStream;
-import java.net.CacheRequest;
 import java.net.ProtocolException;
 import java.net.Socket;
 import java.net.SocketTimeoutException;
@@ -373,12 +371,12 @@ private void writeHex(long i) throws IOException {
 
   private class AbstractSource {
     private final CacheRequest cacheRequest;
-    protected final OutputStream cacheBody;
+    protected final Sink cacheBody;
     protected boolean closed;
 
     AbstractSource(CacheRequest cacheRequest) throws IOException {
       // Some apps return a null body; for compatibility we treat that like a null cache request.
-      OutputStream cacheBody = cacheRequest != null ? cacheRequest.getBody() : null;
+      Sink cacheBody = cacheRequest != null ? cacheRequest.body() : null;
       if (cacheBody == null) {
         cacheRequest = null;
       }
@@ -390,7 +388,8 @@ private void writeHex(long i) throws IOException {
     /** Copy the last {@code byteCount} bytes of {@code source} to the cache body. */
     protected final void cacheWrite(Buffer source, long byteCount) throws IOException {
       if (cacheBody != null) {
-        source.copyTo(cacheBody, source.size() - byteCount, byteCount);
+        // TODO source.copyTo(cacheBody, byteCount);
+        cacheBody.write(source.clone(), byteCount);
       }
     }
 
@@ -411,7 +410,7 @@ protected final void endOfInput(boolean recyclable) throws IOException {
         Internal.instance.recycle(pool, connection);
       } else if (onIdle == ON_IDLE_CLOSE) {
         state = STATE_CLOSED;
-        connection.getSocket();
+        connection.getSocket().close();
       }
     }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java
index cdb697318b..27511b37ca 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java
@@ -17,7 +17,7 @@
 package com.squareup.okhttp.internal.http;
 
 import java.text.DateFormat;
-import java.text.ParseException;
+import java.text.ParsePosition;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Locale;
@@ -28,6 +28,8 @@
  */
 public final class HttpDate {
 
+  private static final TimeZone GMT = TimeZone.getTimeZone("GMT");
+
   /**
    * Most websites serve cookies in the blessed format. Eagerly create the parser to ensure such
    * cookies are on the fast path.
@@ -35,16 +37,21 @@
   private static final ThreadLocal<DateFormat> STANDARD_DATE_FORMAT =
       new ThreadLocal<DateFormat>() {
         @Override protected DateFormat initialValue() {
-          DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
-          rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
+          // RFC 2616 specified: RFC 822, updated by RFC 1123 format with fixed GMT.
+          DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss 'GMT'", Locale.US);
+          rfc1123.setLenient(false);
+          rfc1123.setTimeZone(GMT);
           return rfc1123;
         }
       };
 
   /** If we fail to parse a date in a non-standard format, try each of these formats in sequence. */
   private static final String[] BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS = new String[] {
-      "EEEE, dd-MMM-yy HH:mm:ss zzz", // RFC 1036
-      "EEE MMM d HH:mm:ss yyyy", // ANSI C asctime()
+      // HTTP formats required by RFC2616 but with any timezone.
+      "EEE, dd MMM yyyy HH:mm:ss zzz", // RFC 822, updated by RFC 1123 with any TZ
+      "EEEE, dd-MMM-yy HH:mm:ss zzz", // RFC 850, obsoleted by RFC 1036 with any TZ.
+      "EEE MMM d HH:mm:ss yyyy", // ANSI C's asctime() format
+       // Alternative formats.
       "EEE, dd-MMM-yyyy HH:mm:ss z",
       "EEE, dd-MMM-yyyy HH-mm-ss z",
       "EEE, dd MMM yy HH:mm:ss z",
@@ -66,20 +73,36 @@
 
   /** Returns the date for {@code value}. Returns null if the value couldn't be parsed. */
   public static Date parse(String value) {
-    try {
-      return STANDARD_DATE_FORMAT.get().parse(value);
-    } catch (ParseException ignored) {
+    if (value.length() == 0) {
+      return null;
+    }
+
+    ParsePosition position = new ParsePosition(0);
+    Date result = STANDARD_DATE_FORMAT.get().parse(value, position);
+    if (position.getIndex() == value.length()) {
+      // STANDARD_DATE_FORMAT must match exactly; all text must be consumed, e.g. no ignored
+      // non-standard trailing "+01:00". Those cases are covered below.
+      return result;
     }
     synchronized (BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS) {
       for (int i = 0, count = BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS.length; i < count; i++) {
         DateFormat format = BROWSER_COMPATIBLE_DATE_FORMATS[i];
         if (format == null) {
           format = new SimpleDateFormat(BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS[i], Locale.US);
+          // Set the timezone to use when interpreting formats that don't have a timezone. GMT is
+          // specified by RFC 2616.
+          format.setTimeZone(GMT);
           BROWSER_COMPATIBLE_DATE_FORMATS[i] = format;
         }
-        try {
-          return format.parse(value);
-        } catch (ParseException ignored) {
+        position.setIndex(0);
+        result = format.parse(value, position);
+        if (position.getIndex() != 0) {
+          // Something was parsed. It's possible the entire string was not consumed but we ignore
+          // that. If any of the BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS ended in "'GMT'" we'd have
+          // to also check that position.getIndex() == value.length() otherwise parsing might have
+          // terminated early, ignoring things like "+01:00". Leaving this as != 0 means that any
+          // trailing junk is ignored.
+          return result;
         }
       }
     }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index b19fb1aa94..c69a65be1e 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -17,34 +17,30 @@
 
 package com.squareup.okhttp.internal.http;
 
-import com.squareup.okhttp.Address;
 import com.squareup.okhttp.Connection;
 import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
-import com.squareup.okhttp.ResponseSource;
+import com.squareup.okhttp.ResponseBody;
 import com.squareup.okhttp.Route;
-import com.squareup.okhttp.internal.Dns;
 import com.squareup.okhttp.internal.Internal;
 import com.squareup.okhttp.internal.InternalCache;
 import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
 import java.io.InputStream;
-import java.net.CacheRequest;
 import java.net.CookieHandler;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.URL;
-import java.net.UnknownHostException;
 import java.security.cert.CertificateException;
 import java.util.Date;
 import java.util.List;
 import java.util.Map;
-import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLSocketFactory;
+import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.GzipSource;
@@ -91,11 +87,24 @@
    */
   public static final int MAX_REDIRECTS = 20;
 
+  private static final ResponseBody EMPTY_BODY = new ResponseBody() {
+    @Override public MediaType contentType() {
+      return null;
+    }
+    @Override public long contentLength() {
+      return 0;
+    }
+    @Override public BufferedSource source() {
+      return new Buffer();
+    }
+  };
+
   final OkHttpClient client;
 
   private Connection connection;
   private RouteSelector routeSelector;
   private Route route;
+  private final Response priorResponse;
 
   private Transport transport;
 
@@ -116,29 +125,50 @@
    */
   public final boolean bufferRequestBody;
 
-  private Request originalRequest;
-  private Request request;
+  /**
+   * The original application-provided request. Never modified by OkHttp. When
+   * follow-up requests are necessary, they are derived from this request.
+   */
+  private final Request userRequest;
+
+  /**
+   * The request to send on the network, or null for no network request. This is
+   * derived from the user request, and customized to support OkHttp features
+   * like compression and caching.
+   */
+  private Request networkRequest;
+
+  /**
+   * The cached response, or null if the cache doesn't exist or cannot be used
+   * for this request. Conditional caching means this may be non-null even when
+   * the network request is non-null. Never modified by OkHttp.
+   */
+  private Response cacheResponse;
+
+  /**
+   * The response read from the network. Null if the network response hasn't
+   * been read yet, or if the network is not used. Never modified by OkHttp.
+   */
+  private Response networkResponse;
+
+  /**
+   * The user-visible response. This is derived from either the network
+   * response, cache response, or both. It is customized to support OkHttp
+   * features like compression and caching.
+   */
+  private Response userResponse;
+
   private Sink requestBodyOut;
   private BufferedSink bufferedRequestBody;
 
-  private ResponseSource responseSource;
-
   /** Null until a response is received from the network or the cache. */
-  private Response response;
   private Source responseTransferSource;
   private BufferedSource responseBody;
   private InputStream responseBodyBytes;
 
-  /**
-   * The cache response currently being validated on a conditional get. Null
-   * if the cached response doesn't exist or doesn't need validation. If the
-   * conditional get succeeds, these will be used for the response. If it fails,
-   * it will be set to null.
-   */
-  private Response validatingResponse;
-
   /** The cache request currently being populated from a network response. */
-  private CacheRequest cacheRequest;
+  private CacheRequest storeRequest;
+  private CacheStrategy cacheStrategy;
 
   /**
    * @param request the HTTP request without a body. The body must be
@@ -152,14 +182,15 @@
    *     recover from a failure.
    */
   public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBody,
-      Connection connection, RouteSelector routeSelector, RetryableSink requestBodyOut) {
+      Connection connection, RouteSelector routeSelector, RetryableSink requestBodyOut,
+      Response priorResponse) {
     this.client = client;
-    this.originalRequest = request;
-    this.request = request;
+    this.userRequest = request;
     this.bufferRequestBody = bufferRequestBody;
     this.connection = connection;
     this.routeSelector = routeSelector;
     this.requestBodyOut = requestBodyOut;
+    this.priorResponse = priorResponse;
 
     if (connection != null) {
       Internal.instance.setOwner(connection, this);
@@ -175,41 +206,33 @@ public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBod
    * writing the request body if it exists.
    */
   public void sendRequest() throws IOException {
-    if (responseSource != null) return; // Already sent.
+    if (cacheStrategy != null) return; // Already sent.
     if (transport != null) throw new IllegalStateException();
 
-    prepareRawRequestHeaders();
-    InternalCache responseCache = Internal.instance.internalCache(client);
+    Request request = networkRequest(userRequest);
 
-    Response cacheResponse = responseCache != null
+    InternalCache responseCache = Internal.instance.internalCache(client);
+    Response cacheCandidate = responseCache != null
         ? responseCache.get(request)
         : null;
+
     long now = System.currentTimeMillis();
-    CacheStrategy cacheStrategy = new CacheStrategy.Factory(now, request, cacheResponse).get();
-    responseSource = cacheStrategy.source;
-    request = cacheStrategy.request;
+    cacheStrategy = new CacheStrategy.Factory(now, request, cacheCandidate).get();
+    networkRequest = cacheStrategy.networkRequest;
+    cacheResponse = cacheStrategy.cacheResponse;
 
     if (responseCache != null) {
-      responseCache.trackResponse(responseSource);
+      responseCache.trackResponse(cacheStrategy);
     }
 
-    if (responseSource != ResponseSource.NETWORK) {
-      validatingResponse = cacheStrategy.response;
+    if (cacheCandidate != null && cacheResponse == null) {
+      closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it.
     }
 
-    if (cacheResponse != null && !responseSource.usesCache()) {
-      closeQuietly(cacheResponse.body()); // We don't need this cached response. Close it.
-    }
-
-    if (responseSource.requiresConnection()) {
+    if (networkRequest != null) {
       // Open a connection unless we inherited one from a redirect.
       if (connection == null) {
-        connect();
-      }
-
-      // Blow up if we aren't the current owner of the connection.
-      if (Internal.instance.getOwner(connection) != this && !Internal.instance.isSpdy(connection)) {
-        throw new AssertionError();
+        connect(networkRequest);
       }
 
       transport = Internal.instance.newTransport(connection, this);
@@ -221,60 +244,52 @@ public void sendRequest() throws IOException {
       }
 
     } else {
-      // We're using a cached response. Recycle a connection we may have inherited from a redirect.
+      // We aren't using the network. Recycle a connection we may have inherited from a redirect.
       if (connection != null) {
         Internal.instance.recycle(client.getConnectionPool(), connection);
         connection = null;
       }
 
-      // No need for the network! Promote the cached response immediately.
-      this.response = validatingResponse;
-      if (validatingResponse.body() != null) {
-        initContentStream(validatingResponse.body().source());
+      if (cacheResponse != null) {
+        // We have a valid cached response. Promote it to the user response immediately.
+        this.userResponse = cacheResponse.newBuilder()
+            .request(userRequest)
+            .priorResponse(stripBody(priorResponse))
+            .cacheResponse(stripBody(cacheResponse))
+            .build();
+      } else {
+        // We're forbidden from using the network, and the cache is insufficient.
+        this.userResponse = new Response.Builder()
+            .request(userRequest)
+            .priorResponse(stripBody(priorResponse))
+            .protocol(Protocol.HTTP_1_1)
+            .code(504)
+            .message("Unsatisfiable Request (only-if-cached)")
+            .body(EMPTY_BODY)
+            .build();
+      }
+
+      if (userResponse.body() != null) {
+        initContentStream(userResponse.body().source());
       }
     }
   }
 
-  private Response cacheableResponse() {
-    // Use an unreadable response body when offering the response to the cache.
-    // The cache isn't allowed to consume the response body bytes!
-    return response.newBuilder().body(null).build();
+  private static Response stripBody(Response response) {
+    return response != null && response.body() != null
+        ? response.newBuilder().body(null).build()
+        : response;
   }
 
   /** Connect to the origin server either directly or via a proxy. */
-  private void connect() throws IOException {
+  private void connect(Request request) throws IOException {
     if (connection != null) throw new IllegalStateException();
 
     if (routeSelector == null) {
-      String uriHost = request.url().getHost();
-      if (uriHost == null || uriHost.length() == 0) {
-        throw new UnknownHostException(request.url().toString());
-      }
-      SSLSocketFactory sslSocketFactory = null;
-      HostnameVerifier hostnameVerifier = null;
-      if (request.isHttps()) {
-        sslSocketFactory = client.getSslSocketFactory();
-        hostnameVerifier = client.getHostnameVerifier();
-      }
-      Address address = new Address(uriHost, getEffectivePort(request.url()),
-          client.getSocketFactory(), sslSocketFactory, hostnameVerifier, client.getAuthenticator(),
-          client.getProxy(), client.getProtocols());
-      routeSelector = new RouteSelector(address, request.uri(), client.getProxySelector(),
-          client.getConnectionPool(), Dns.DEFAULT, client.getRoutesDatabase());
+      routeSelector = RouteSelector.get(request, client);
     }
 
-    connection = routeSelector.next(request.method());
-    Internal.instance.setOwner(connection, this);
-
-    if (!Internal.instance.isConnected(connection)) {
-      Internal.instance.connect(connection, client.getConnectTimeout(), client.getReadTimeout(),
-          client.getWriteTimeout(), tunnelRequest(connection, request));
-      if (Internal.instance.isSpdy(connection)) {
-        Internal.instance.share(client.getConnectionPool(), connection);
-      }
-      client.getRoutesDatabase().connected(connection.getRoute());
-    }
-    Internal.instance.setTimeouts(connection, client.getReadTimeout(), client.getWriteTimeout());
+    connection = routeSelector.next(this);
     route = connection.getRoute();
   }
 
@@ -288,12 +303,13 @@ public void writingRequestHeaders() {
   }
 
   boolean hasRequestBody() {
-    return HttpMethod.hasRequestBody(request.method()) && !Util.emptySink().equals(requestBodyOut);
+    return HttpMethod.hasRequestBody(userRequest.method())
+        && !Util.emptySink().equals(requestBodyOut);
   }
 
   /** Returns the request body or null if this request doesn't have a body. */
   public Sink getRequestBody() {
-    if (responseSource == null) throw new IllegalStateException();
+    if (cacheStrategy == null) throw new IllegalStateException();
     return requestBodyOut;
   }
 
@@ -307,26 +323,22 @@ public BufferedSink getBufferedRequestBody() {
   }
 
   public boolean hasResponse() {
-    return response != null;
-  }
-
-  public ResponseSource responseSource() {
-    return responseSource;
+    return userResponse != null;
   }
 
   public Request getRequest() {
-    return request;
+    return userRequest;
   }
 
   /** Returns the engine's response. */
   // TODO: the returned body will always be null.
   public Response getResponse() {
-    if (response == null) throw new IllegalStateException();
-    return response;
+    if (userResponse == null) throw new IllegalStateException();
+    return userResponse;
   }
 
   public BufferedSource getResponseBody() {
-    if (response == null) throw new IllegalStateException();
+    if (userResponse == null) throw new IllegalStateException();
     return responseBody;
   }
 
@@ -363,8 +375,8 @@ public HttpEngine recover(IOException e, Sink requestBodyOut) {
     Connection connection = close();
 
     // For failure recovery, use the same route selector with a new connection.
-    return new HttpEngine(client, originalRequest, bufferRequestBody, connection, routeSelector,
-        (RetryableSink) requestBodyOut);
+    return new HttpEngine(client, userRequest, bufferRequestBody, connection, routeSelector,
+        (RetryableSink) requestBodyOut, priorResponse);
   }
 
   public HttpEngine recover(IOException e) {
@@ -393,10 +405,10 @@ private void maybeCache() throws IOException {
     if (responseCache == null) return;
 
     // Should we cache this response for this request?
-    if (!CacheStrategy.isCacheable(response, request)) {
-      if (HttpMethod.invalidatesCache(request.method())) {
+    if (!CacheStrategy.isCacheable(userResponse, networkRequest)) {
+      if (HttpMethod.invalidatesCache(networkRequest.method())) {
         try {
-          responseCache.remove(request);
+          responseCache.remove(networkRequest);
         } catch (IOException ignored) {
           // The cache cannot be written.
         }
@@ -405,7 +417,7 @@ private void maybeCache() throws IOException {
     }
 
     // Offer this request to the cache.
-    cacheRequest = responseCache.put(cacheableResponse());
+    storeRequest = responseCache.put(stripBody(userResponse));
   }
 
   /**
@@ -461,7 +473,7 @@ public Connection close() {
     closeQuietly(responseBodyBytes);
 
     // Close the connection if it cannot be reused.
-    if (transport != null && !transport.canReuseConnection()) {
+    if (transport != null && connection != null && !transport.canReuseConnection()) {
       closeQuietly(connection.getSocket());
       connection = null;
       return null;
@@ -495,8 +507,8 @@ public Connection close() {
    */
   private void initContentStream(Source transferSource) throws IOException {
     responseTransferSource = transferSource;
-    if (transparentGzip && "gzip".equalsIgnoreCase(response.header("Content-Encoding"))) {
-      response = response.newBuilder()
+    if (transparentGzip && "gzip".equalsIgnoreCase(userResponse.header("Content-Encoding"))) {
+      userResponse = userResponse.newBuilder()
           .removeHeader("Content-Encoding")
           .removeHeader("Content-Length")
           .build();
@@ -512,11 +524,11 @@ private void initContentStream(Source transferSource) throws IOException {
    */
   public boolean hasResponseBody() {
     // HEAD requests never yield a body regardless of the response headers.
-    if (request.method().equals("HEAD")) {
+    if (userRequest.method().equals("HEAD")) {
       return false;
     }
 
-    int responseCode = response.code();
+    int responseCode = userResponse.code();
     if ((responseCode < HTTP_CONTINUE || responseCode >= 200)
         && responseCode != HTTP_NO_CONTENT
         && responseCode != HTTP_NOT_MODIFIED) {
@@ -526,8 +538,8 @@ public boolean hasResponseBody() {
     // If the Content-Length or Transfer-Encoding headers disagree with the
     // response code, the response is malformed. For best compatibility, we
     // honor the headers.
-    if (OkHeaders.contentLength(response) != -1
-        || "chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
+    if (OkHeaders.contentLength(networkResponse) != -1
+        || "chunked".equalsIgnoreCase(networkResponse.header("Transfer-Encoding"))) {
       return true;
     }
 
@@ -540,13 +552,9 @@ public boolean hasResponseBody() {
    * <p>This client doesn't specify a default {@code Accept} header because it
    * doesn't know what content types the application is interested in.
    */
-  private void prepareRawRequestHeaders() throws IOException {
+  private Request networkRequest(Request request) throws IOException {
     Request.Builder result = request.newBuilder();
 
-    if (request.header("User-Agent") == null) {
-      result.header("User-Agent", getDefaultUserAgent());
-    }
-
     if (request.header("Host") == null) {
       result.header("Host", hostHeader(request.url()));
     }
@@ -561,10 +569,6 @@ private void prepareRawRequestHeaders() throws IOException {
       result.header("Accept-Encoding", "gzip");
     }
 
-    if (hasRequestBody() && request.header("Content-Type") == null) {
-      result.header("Content-Type", "application/x-www-form-urlencoded");
-    }
-
     CookieHandler cookieHandler = client.getCookieHandler();
     if (cookieHandler != null) {
       // Capture the request headers added so far so that they can be offered to the CookieHandler.
@@ -578,12 +582,7 @@ private void prepareRawRequestHeaders() throws IOException {
       OkHeaders.addCookies(result, cookies);
     }
 
-    request = result.build();
-  }
-
-  public static String getDefaultUserAgent() {
-    String agent = System.getProperty("http.agent");
-    return agent != null ? agent : ("Java" + System.getProperty("java.version"));
+    return result.build();
   }
 
   public static String hostHeader(URL url) {
@@ -597,9 +596,15 @@ public static String hostHeader(URL url) {
    * headers and starts reading the HTTP response body if it exists.
    */
   public void readResponse() throws IOException {
-    if (response != null) return;
-    if (responseSource == null) throw new IllegalStateException("call sendRequest() first!");
-    if (!responseSource.requiresConnection()) return;
+    if (userResponse != null) {
+      return; // Already ready.
+    }
+    if (networkRequest == null && cacheResponse == null) {
+      throw new IllegalStateException("call sendRequest() first!");
+    }
+    if (networkRequest == null) {
+      return; // No network response to read.
+    }
 
     // Flush the request body if there's data outstanding.
     if (bufferedRequestBody != null && bufferedRequestBody.buffer().size() > 0) {
@@ -607,14 +612,15 @@ public void readResponse() throws IOException {
     }
 
     if (sentRequestMillis == -1) {
-      if (OkHeaders.contentLength(request) == -1 && requestBodyOut instanceof RetryableSink) {
+      if (OkHeaders.contentLength(networkRequest) == -1
+          && requestBodyOut instanceof RetryableSink) {
         // We might not learn the Content-Length until the request body has been buffered.
         long contentLength = ((RetryableSink) requestBodyOut).contentLength();
-        request = request.newBuilder()
+        networkRequest = networkRequest.newBuilder()
             .header("Content-Length", Long.toString(contentLength))
             .build();
       }
-      transport.writeRequestHeaders(request);
+      transport.writeRequestHeaders(networkRequest);
     }
 
     if (requestBodyOut != null) {
@@ -631,46 +637,59 @@ public void readResponse() throws IOException {
 
     transport.flushRequest();
 
-    response = transport.readResponseHeaders()
-        .request(request)
+    networkResponse = transport.readResponseHeaders()
+        .request(networkRequest)
         .handshake(connection.getHandshake())
         .header(OkHeaders.SENT_MILLIS, Long.toString(sentRequestMillis))
         .header(OkHeaders.RECEIVED_MILLIS, Long.toString(System.currentTimeMillis()))
-        .setResponseSource(responseSource)
         .build();
-    Internal.instance.setProtocol(connection, response.protocol());
-    receiveHeaders(response.headers());
-
-    if (responseSource == ResponseSource.CONDITIONAL_CACHE) {
-      if (validate(validatingResponse, response)) {
+    Internal.instance.setProtocol(connection, networkResponse.protocol());
+    receiveHeaders(networkResponse.headers());
+
+    // If we have a cache response too, then we're doing a conditional get.
+    if (cacheResponse != null) {
+      if (validate(cacheResponse, networkResponse)) {
+        userResponse = cacheResponse.newBuilder()
+            .request(userRequest)
+            .priorResponse(stripBody(priorResponse))
+            .headers(combine(cacheResponse.headers(), networkResponse.headers()))
+            .cacheResponse(stripBody(cacheResponse))
+            .networkResponse(stripBody(networkResponse))
+            .build();
         transport.emptyTransferStream();
         releaseConnection();
-        response = combine(validatingResponse, response);
 
         // Update the cache after combining headers but before stripping the
         // Content-Encoding header (as performed by initContentStream()).
         InternalCache responseCache = Internal.instance.internalCache(client);
         responseCache.trackConditionalCacheHit();
-        responseCache.update(validatingResponse, cacheableResponse());
+        responseCache.update(cacheResponse, stripBody(userResponse));
 
-        if (validatingResponse.body() != null) {
-          initContentStream(validatingResponse.body().source());
+        if (cacheResponse.body() != null) {
+          initContentStream(cacheResponse.body().source());
         }
         return;
       } else {
-        closeQuietly(validatingResponse.body());
+        closeQuietly(cacheResponse.body());
       }
     }
 
+    userResponse = networkResponse.newBuilder()
+        .request(userRequest)
+        .priorResponse(stripBody(priorResponse))
+        .cacheResponse(stripBody(cacheResponse))
+        .networkResponse(stripBody(networkResponse))
+        .build();
+
     if (!hasResponseBody()) {
       // Don't call initContentStream() when the response doesn't have any content.
-      responseTransferSource = transport.getTransferStream(cacheRequest);
+      responseTransferSource = transport.getTransferStream(storeRequest);
       responseBody = Okio.buffer(responseTransferSource);
       return;
     }
 
     maybeCache();
-    initContentStream(transport.getTransferStream(cacheRequest));
+    initContentStream(transport.getTransferStream(storeRequest));
   }
 
   /**
@@ -701,22 +720,20 @@ private static boolean validate(Response cached, Response network) {
    * Combines cached headers with a network headers as defined by RFC 2616,
    * 13.5.3.
    */
-  private static Response combine(Response cached, Response network) throws IOException {
+  private static Headers combine(Headers cachedHeaders, Headers networkHeaders) throws IOException {
     Headers.Builder result = new Headers.Builder();
 
-    Headers cachedHeaders = cached.headers();
     for (int i = 0; i < cachedHeaders.size(); i++) {
       String fieldName = cachedHeaders.name(i);
       String value = cachedHeaders.value(i);
       if ("Warning".equals(fieldName) && value.startsWith("1")) {
         continue; // drop 100-level freshness warnings
       }
-      if (!OkHeaders.isEndToEnd(fieldName) || network.header(fieldName) == null) {
+      if (!OkHeaders.isEndToEnd(fieldName) || networkHeaders.get(fieldName) == null) {
         result.add(fieldName, value);
       }
     }
 
-    Headers networkHeaders = network.headers();
     for (int i = 0; i < networkHeaders.size(); i++) {
       String fieldName = networkHeaders.name(i);
       if (OkHeaders.isEndToEnd(fieldName)) {
@@ -724,44 +741,13 @@ private static Response combine(Response cached, Response network) throws IOExce
       }
     }
 
-    return cached.newBuilder().headers(result.build()).build();
-  }
-
-  /**
-   * Returns a request that creates a TLS tunnel via an HTTP proxy, or null if
-   * no tunnel is necessary. Everything in the tunnel request is sent
-   * unencrypted to the proxy server, so tunnels include only the minimum set of
-   * headers. This avoids sending potentially sensitive data like HTTP cookies
-   * to the proxy unencrypted.
-   */
-  private Request tunnelRequest(Connection connection, Request request) throws IOException {
-    if (!connection.getRoute().requiresTunnel()) return null;
-
-    String userAgent = request.header("User-Agent");
-    if (userAgent == null) userAgent = getDefaultUserAgent();
-
-    String host = request.url().getHost();
-    int port = getEffectivePort(request.url());
-    String authority = (port == getDefaultPort("https")) ? host : (host + ":" + port);
-    Request.Builder result = new Request.Builder()
-        .url(new URL("https", host, port, "/"))
-        .header("Host", authority)
-        .header("User-Agent", userAgent)
-        .header("Proxy-Connection", "Keep-Alive"); // For HTTP/1.0 proxies like Squid.
-
-    // Copy over the Proxy-Authorization header if it exists.
-    String proxyAuthorization = request.header("Proxy-Authorization");
-    if (proxyAuthorization != null) {
-      result.header("Proxy-Authorization", proxyAuthorization);
-    }
-
     return result.build();
   }
 
   public void receiveHeaders(Headers headers) throws IOException {
     CookieHandler cookieHandler = client.getCookieHandler();
     if (cookieHandler != null) {
-      cookieHandler.put(request.uri(), OkHeaders.toMultimap(headers, null));
+      cookieHandler.put(userRequest.uri(), OkHeaders.toMultimap(headers, null));
     }
   }
 
@@ -771,11 +757,11 @@ public void receiveHeaders(Headers headers) throws IOException {
    * If a follow-up is either unnecessary or not applicable, this returns null.
    */
   public Request followUpRequest() throws IOException {
-    if (response == null) throw new IllegalStateException();
+    if (userResponse == null) throw new IllegalStateException();
     Proxy selectedProxy = getRoute() != null
         ? getRoute().getProxy()
         : client.getProxy();
-    int responseCode = response.code();
+    int responseCode = userResponse.code();
 
     switch (responseCode) {
       case HTTP_PROXY_AUTH:
@@ -784,37 +770,49 @@ public Request followUpRequest() throws IOException {
         }
         // fall-through
       case HTTP_UNAUTHORIZED:
-        return OkHeaders.processAuthHeader(client.getAuthenticator(), response, selectedProxy);
+        return OkHeaders.processAuthHeader(client.getAuthenticator(), userResponse, selectedProxy);
 
       case HTTP_TEMP_REDIRECT:
         // "If the 307 status code is received in response to a request other than GET or HEAD,
         // the user agent MUST NOT automatically redirect the request"
-        if (!request.method().equals("GET") && !request.method().equals("HEAD")) return null;
+        if (!userRequest.method().equals("GET") && !userRequest.method().equals("HEAD")) {
+          return null;
+        }
         // fall-through
       case HTTP_MULT_CHOICE:
       case HTTP_MOVED_PERM:
       case HTTP_MOVED_TEMP:
       case HTTP_SEE_OTHER:
-        String location = response.header("Location");
+        // Does the client allow redirects?
+        if (!client.getFollowRedirects()) return null;
+
+        String location = userResponse.header("Location");
         if (location == null) return null;
-        URL url = new URL(request.url(), location);
+        URL url = new URL(userRequest.url(), location);
 
         // Don't follow redirects to unsupported protocols.
         if (!url.getProtocol().equals("https") && !url.getProtocol().equals("http")) return null;
 
         // If configured, don't follow redirects between SSL and non-SSL.
-        boolean sameProtocol = url.getProtocol().equals(request.url().getProtocol());
+        boolean sameProtocol = url.getProtocol().equals(userRequest.url().getProtocol());
         if (!sameProtocol && !client.getFollowSslRedirects()) return null;
 
         // Redirects don't include a request body.
-        Request.Builder requestBuilder = originalRequest.newBuilder();
-        if (HttpMethod.hasRequestBody(originalRequest.method())) {
+        Request.Builder requestBuilder = userRequest.newBuilder();
+        if (HttpMethod.hasRequestBody(userRequest.method())) {
           requestBuilder.method("GET", null);
           requestBuilder.removeHeader("Transfer-Encoding");
           requestBuilder.removeHeader("Content-Length");
           requestBuilder.removeHeader("Content-Type");
         }
 
+        // When redirecting across hosts, drop all authentication headers. This
+        // is potentially annoying to the application layer since they have no
+        // way to retain them.
+        if (!sameConnection(url)) {
+          requestBuilder.removeHeader("Authorization");
+        }
+
         return requestBuilder.url(url).build();
 
       default:
@@ -823,14 +821,13 @@ public Request followUpRequest() throws IOException {
   }
 
   /**
-   * Returns true if an HTTP request for {@code followUp} can use the same
-   * engine as this connection.
+   * Returns true if an HTTP request for {@code followUp} can reuse the
+   * connection used by this engine.
    */
-  public boolean sameConnection(Request followUp) {
-    URL a = request.url();
-    URL b = followUp.url();
-    return a.getHost().equals(b.getHost())
-        && getEffectivePort(a) == getEffectivePort(b)
-        && a.getProtocol().equals(b.getProtocol());
+  public boolean sameConnection(URL followUp) {
+    URL url = userRequest.url();
+    return url.getHost().equals(followUp.getHost())
+        && getEffectivePort(url) == getEffectivePort(followUp)
+        && url.getProtocol().equals(followUp.getProtocol());
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java
index 1577d1018d..b9f839dd46 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java
@@ -20,7 +20,7 @@
 import java.util.Set;
 
 public final class HttpMethod {
-  public static final Set<String> METHODS = new LinkedHashSet<String>(Arrays.asList(
+  public static final Set<String> METHODS = new LinkedHashSet<>(Arrays.asList(
       "OPTIONS", "GET", "HEAD", "POST", "PUT", "DELETE", "TRACE", "PATCH"));
 
   public static boolean invalidatesCache(String method) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
index 0a1f8a7e33..c61bf20b71 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
@@ -19,7 +19,6 @@
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import java.io.IOException;
-import java.net.CacheRequest;
 import okio.Sink;
 import okio.Source;
 
@@ -94,7 +93,7 @@ public void writeRequestHeaders(Request request) throws IOException {
     String requestLine = RequestLine.get(request,
         httpEngine.getConnection().getRoute().getProxy().type(),
         httpEngine.getConnection().getProtocol());
-    httpConnection.writeRequest(request.getHeaders(), requestLine);
+    httpConnection.writeRequest(request.headers(), requestLine);
   }
 
   @Override public Response.Builder readResponseHeaders() throws IOException {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
index cf684700e9..b09801b487 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
@@ -1,8 +1,8 @@
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.Authenticator;
 import com.squareup.okhttp.Challenge;
 import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.OkAuthenticator;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.Platform;
@@ -49,12 +49,6 @@
    */
   public static final String RECEIVED_MILLIS = PREFIX + "-Received-Millis";
 
-  /**
-   * Synthetic response header: the response source and status code like
-   * "CONDITIONAL_CACHE 304".
-   */
-  public static final String RESPONSE_SOURCE = PREFIX + "-Response-Source";
-
   /**
    * Synthetic response header: the selected
    * {@link com.squareup.okhttp.Protocol protocol} ("spdy/3.1", "http/1.1", etc).
@@ -92,12 +86,12 @@ private static long stringToLong(String s) {
    *     for responses. If non-null, this value is mapped to the null key.
    */
   public static Map<String, List<String>> toMultimap(Headers headers, String valueForNullKey) {
-    Map<String, List<String>> result = new TreeMap<String, List<String>>(FIELD_NAME_COMPARATOR);
+    Map<String, List<String>> result = new TreeMap<>(FIELD_NAME_COMPARATOR);
     for (int i = 0; i < headers.size(); i++) {
       String fieldName = headers.name(i);
       String value = headers.value(i);
 
-      List<String> allValues = new ArrayList<String>();
+      List<String> allValues = new ArrayList<>();
       List<String> otherValues = result.get(fieldName);
       if (otherValues != null) {
         allValues.addAll(otherValues);
@@ -163,7 +157,7 @@ public static boolean hasVaryAll(Response response) {
 
       String value = headers.value(i);
       if (result.isEmpty()) {
-        result = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);
+        result = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);
       }
       for (String varyField : value.split(",")) {
         result.add(varyField.trim());
@@ -180,8 +174,12 @@ public static Headers varyHeaders(Response response) {
     Set<String> varyFields = varyFields(response);
     if (varyFields.isEmpty()) return new Headers.Builder().build();
 
+    // Use the request headers sent over the network, since that's what the
+    // response varies on. Otherwise OkHttp-supplied headers like
+    // "Accept-Encoding: gzip" may be lost.
+    Headers requestHeaders = response.networkResponse().request().headers();
+
     Headers.Builder result = new Headers.Builder();
-    Headers requestHeaders = response.request().headers();
     for (int i = 0; i < requestHeaders.size(); i++) {
       String fieldName = requestHeaders.name(i);
       if (varyFields.contains(fieldName)) {
@@ -216,7 +214,7 @@ static boolean isEndToEnd(String fieldName) {
     // challenge   = auth-scheme 1*SP 1#auth-param
     // realm       = "realm" "=" realm-value
     // realm-value = quoted-string
-    List<Challenge> result = new ArrayList<Challenge>();
+    List<Challenge> result = new ArrayList<>();
     for (int h = 0; h < responseHeaders.size(); h++) {
       if (!challengeHeader.equalsIgnoreCase(responseHeaders.name(h))) {
         continue;
@@ -257,7 +255,7 @@ static boolean isEndToEnd(String fieldName) {
    * Returns a request for a subsequent attempt, or null if no further attempts
    * should be made.
    */
-  public static Request processAuthHeader(OkAuthenticator authenticator, Response response,
+  public static Request processAuthHeader(Authenticator authenticator, Response response,
       Proxy proxy) throws IOException {
     return response.code() == HTTP_PROXY_AUTH
         ? authenticator.authenticateProxy(proxy, response)
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java
index 9e36d74f9b..f764afd326 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RequestLine.java
@@ -2,7 +2,7 @@
 
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
-import com.squareup.okhttp.internal.huc.HttpURLConnectionImpl;
+import java.net.HttpURLConnection;
 import java.net.Proxy;
 import java.net.URL;
 
@@ -12,13 +12,13 @@ private RequestLine() {
 
   /**
    * Returns the request status line, like "GET / HTTP/1.1". This is exposed
-   * to the application by {@link HttpURLConnectionImpl#getHeaderFields}, so
-   * it needs to be set even if the transport is SPDY.
+   * to the application by {@link HttpURLConnection#getHeaderFields}, so it
+   * needs to be set even if the transport is SPDY.
    */
   static String get(Request request, Proxy.Type proxyType, Protocol protocol) {
     StringBuilder result = new StringBuilder();
     result.append(request.method());
-    result.append(" ");
+    result.append(' ');
 
     if (includeAuthorityInRequestLine(request, proxyType)) {
       result.append(request.url());
@@ -26,7 +26,7 @@ static String get(Request request, Proxy.Type proxyType, Protocol protocol) {
       result.append(requestPath(request.url()));
     }
 
-    result.append(" ");
+    result.append(' ');
     result.append(version(protocol));
     return result.toString();
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
index de33b0bc5c..50e19ef180 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
@@ -18,10 +18,12 @@
 import com.squareup.okhttp.Address;
 import com.squareup.okhttp.Connection;
 import com.squareup.okhttp.ConnectionPool;
+import com.squareup.okhttp.HostResolver;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Route;
-import com.squareup.okhttp.RouteDatabase;
-import com.squareup.okhttp.internal.Dns;
 import com.squareup.okhttp.internal.Internal;
+import com.squareup.okhttp.internal.RouteDatabase;
 import java.io.IOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
@@ -30,12 +32,14 @@
 import java.net.SocketAddress;
 import java.net.URI;
 import java.net.UnknownHostException;
+import java.util.ArrayList;
 import java.util.Iterator;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.NoSuchElementException;
+import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLProtocolException;
+import javax.net.ssl.SSLSocketFactory;
 
 import static com.squareup.okhttp.internal.Util.getEffectivePort;
 
@@ -50,10 +54,12 @@
 
   private final Address address;
   private final URI uri;
+  private final HostResolver hostResolver;
+  private final OkHttpClient client;
   private final ProxySelector proxySelector;
   private final ConnectionPool pool;
-  private final Dns dns;
   private final RouteDatabase routeDatabase;
+  private final Request request;
 
   /* The most recently attempted route. */
   private Proxy lastProxy;
@@ -73,21 +79,41 @@
   private String nextTlsVersion;
 
   /* State for negotiating failed routes */
-  private final List<Route> postponedRoutes;
+  private final List<Route> postponedRoutes = new ArrayList<>();
 
-  public RouteSelector(Address address, URI uri, ProxySelector proxySelector, ConnectionPool pool,
-      Dns dns, RouteDatabase routeDatabase) {
+  private RouteSelector(Address address, URI uri, OkHttpClient client, Request request) {
     this.address = address;
     this.uri = uri;
-    this.proxySelector = proxySelector;
-    this.pool = pool;
-    this.dns = dns;
-    this.routeDatabase = routeDatabase;
-    this.postponedRoutes = new LinkedList<Route>();
+    this.client = client;
+    this.proxySelector = client.getProxySelector();
+    this.pool = client.getConnectionPool();
+    this.routeDatabase = Internal.instance.routeDatabase(client);
+    this.hostResolver = client.getHostResolver();
+    this.request = request;
 
     resetNextProxy(uri, address.getProxy());
   }
 
+  public static RouteSelector get(Request request, OkHttpClient client) throws IOException {
+    String uriHost = request.url().getHost();
+    if (uriHost == null || uriHost.length() == 0) {
+      throw new UnknownHostException(request.url().toString());
+    }
+
+    SSLSocketFactory sslSocketFactory = null;
+    HostnameVerifier hostnameVerifier = null;
+    if (request.isHttps()) {
+      sslSocketFactory = client.getSslSocketFactory();
+      hostnameVerifier = client.getHostnameVerifier();
+    }
+
+    Address address = new Address(uriHost, getEffectivePort(request.url()),
+        client.getSocketFactory(), sslSocketFactory, hostnameVerifier, client.getAuthenticator(),
+        client.getProxy(), client.getProtocols());
+
+    return new RouteSelector(address, request.uri(), client, request);
+  }
+
   /**
    * Returns true if there's another route to attempt. Every address has at
    * least one route.
@@ -99,15 +125,22 @@ public boolean hasNext() {
         || hasNextPostponed();
   }
 
+  /** Selects a route to attempt and connects it if it isn't already. */
+  public Connection next(HttpEngine owner) throws IOException {
+    Connection connection = nextUnconnected();
+    Internal.instance.connectAndSetOwner(client, connection, owner, request);
+    return connection;
+  }
+
   /**
-   * Returns the next route address to attempt.
+   * Returns the next connection to attempt.
    *
    * @throws NoSuchElementException if there are no more routes to attempt.
    */
-  public Connection next(String method) throws IOException {
+  Connection nextUnconnected() throws IOException {
     // Always prefer pooled connections over new connections.
     for (Connection pooled; (pooled = pool.get(address)) != null; ) {
-      if (method.equals("GET") || Internal.instance.isReadable(pooled)) return pooled;
+      if (request.method().equals("GET") || Internal.instance.isReadable(pooled)) return pooled;
       pooled.getSocket().close();
     }
 
@@ -133,7 +166,7 @@ public Connection next(String method) throws IOException {
       postponedRoutes.add(route);
       // We will only recurse in order to skip previously failed routes. They will be
       // tried last.
-      return next(method);
+      return nextUnconnected();
     }
 
     return new Connection(pool, route);
@@ -228,7 +261,7 @@ private void resetNextInetSocketAddress(Proxy proxy) throws UnknownHostException
     }
 
     // Try each address for best behavior in mixed IPv4/IPv6 environments.
-    socketAddresses = dns.getAllByName(socketHost);
+    socketAddresses = hostResolver.getAllByName(socketHost);
     nextSocketAddressIndex = 0;
   }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index 426b6a4a2c..e07d105dc2 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -26,14 +26,13 @@
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
 import com.squareup.okhttp.internal.spdy.SpdyStream;
 import java.io.IOException;
-import java.io.OutputStream;
-import java.net.CacheRequest;
 import java.net.ProtocolException;
 import java.util.ArrayList;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Locale;
 import java.util.Set;
+import java.util.concurrent.TimeUnit;
 import okio.Buffer;
 import okio.ByteString;
 import okio.Sink;
@@ -93,7 +92,7 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
     stream = spdyConnection.newStream(
         writeNameValueBlock(request, spdyConnection.getProtocol(), version), hasRequestBody,
         hasResponseBody);
-    stream.setReadTimeout(httpEngine.client.getReadTimeout());
+    stream.readTimeout().timeout(httpEngine.client.getReadTimeout(), TimeUnit.MILLISECONDS);
   }
 
   @Override public void writeRequestBody(RetryableSink requestBody) throws IOException {
@@ -116,8 +115,7 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
   public static List<Header> writeNameValueBlock(Request request, Protocol protocol,
       String version) {
     Headers headers = request.headers();
-    // TODO: make the known header names constants.
-    List<Header> result = new ArrayList<Header>(headers.size() + 10);
+    List<Header> result = new ArrayList<>(headers.size() + 10);
     result.add(new Header(TARGET_METHOD, request.method()));
     result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
     String host = HttpEngine.hostHeader(request.url());
@@ -204,7 +202,7 @@ private static String joinOnNull(String first, String second) {
 
     StatusLine statusLine = StatusLine.parse(version + " " + status);
     return new Response.Builder()
-        .protocol(statusLine.protocol)
+        .protocol(protocol)
         .code(statusLine.code)
         .message(statusLine.message)
         .headers(headersBuilder.build());
@@ -245,7 +243,7 @@ private static boolean isProhibitedHeader(Protocol protocol, ByteString name) {
     private final SpdyStream stream;
     private final Source source;
     private final CacheRequest cacheRequest;
-    private final OutputStream cacheBody;
+    private final Sink cacheBody;
 
     private boolean inputExhausted;
     private boolean closed;
@@ -255,7 +253,7 @@ private static boolean isProhibitedHeader(Protocol protocol, ByteString name) {
       this.source = stream.getSource();
 
       // Some apps return a null body; for compatibility we treat that like a null cache request.
-      OutputStream cacheBody = cacheRequest != null ? cacheRequest.getBody() : null;
+      Sink cacheBody = cacheRequest != null ? cacheRequest.body() : null;
       if (cacheBody == null) {
         cacheRequest = null;
       }
@@ -264,13 +262,13 @@ private static boolean isProhibitedHeader(Protocol protocol, ByteString name) {
       this.cacheRequest = cacheRequest;
     }
 
-    @Override public long read(Buffer sink, long byteCount)
+    @Override public long read(Buffer buffer, long byteCount)
         throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
       if (closed) throw new IllegalStateException("closed");
       if (inputExhausted) return -1;
 
-      long read = source.read(sink, byteCount);
+      long read = source.read(buffer, byteCount);
       if (read == -1) {
         inputExhausted = true;
         if (cacheRequest != null) {
@@ -280,7 +278,8 @@ private static boolean isProhibitedHeader(Protocol protocol, ByteString name) {
       }
 
       if (cacheBody != null) {
-        sink.copyTo(cacheBody, sink.size() - read, read);
+        // TODO get buffer.copyTo(cacheBody, read);
+        cacheBody.write(buffer.clone(), read);
       }
 
       return read;
@@ -308,18 +307,15 @@ private static boolean isProhibitedHeader(Protocol protocol, ByteString name) {
     }
 
     private boolean discardStream() {
+      long oldTimeoutNanos = stream.readTimeout().timeoutNanos();
+      stream.readTimeout().timeout(DISCARD_STREAM_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);
       try {
-        long socketTimeout = stream.getReadTimeoutMillis();
-        stream.setReadTimeout(socketTimeout);
-        stream.setReadTimeout(DISCARD_STREAM_TIMEOUT_MILLIS);
-        try {
-          Util.skipAll(this, DISCARD_STREAM_TIMEOUT_MILLIS);
-          return true;
-        } finally {
-          stream.setReadTimeout(socketTimeout);
-        }
+        Util.skipAll(this, DISCARD_STREAM_TIMEOUT_MILLIS);
+        return true;
       } catch (IOException e) {
         return false;
+      } finally {
+        stream.readTimeout().timeout(oldTimeoutNanos, TimeUnit.NANOSECONDS);
       }
     }
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
index 31d7187f1e..7416981277 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/StatusLine.java
@@ -80,9 +80,9 @@ public static StatusLine parse(String statusLine) throws IOException {
   @Override public String toString() {
     StringBuilder result = new StringBuilder();
     result.append(protocol == Protocol.HTTP_1_0 ? "HTTP/1.0" : "HTTP/1.1");
-    result.append(" ").append(code);
+    result.append(' ').append(code);
     if (message != null) {
-      result.append(" ").append(message);
+      result.append(' ').append(message);
     }
     return result.toString();
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
index 31fceca8c7..05a398ab80 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
@@ -19,7 +19,6 @@
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import java.io.IOException;
-import java.net.CacheRequest;
 import okio.Sink;
 import okio.Source;
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
index 6d3c9c8652..db3028222d 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
@@ -1,6 +1,21 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package com.squareup.okhttp.internal.spdy;
 
-// http://tools.ietf.org/html/draft-ietf-httpbis-http2-10#section-7
+// http://tools.ietf.org/html/draft-ietf-httpbis-http2-13#section-7
 public enum ErrorCode {
   /** Not an error! For SPDY stream resets, prefer null over NO_ERROR. */
   NO_ERROR(0, -1, 0),
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
index 798be8ab62..f9b3a66480 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
@@ -24,7 +24,7 @@
 
 /** Reads transport frames for SPDY/3 or HTTP/2. */
 public interface FrameReader extends Closeable {
-  void readConnectionHeader() throws IOException;
+  void readConnectionPreface() throws IOException;
   boolean nextFrame(Handler handler) throws IOException;
 
   public interface Handler {
@@ -40,13 +40,10 @@ void data(boolean inFinished, int streamId, BufferedSource source, int length)
      * @param inFinished true if the sender will not send further frames.
      * @param streamId the stream owning these headers.
      * @param associatedStreamId the stream that triggered the sender to create
-     * this stream.
-     * @param priority or -1 for no priority. For SPDY, priorities range from 0
-     * (highest) thru 7 (lowest). For HTTP/2, priorities range from 0
-     * (highest) thru 2^31-1 (lowest), defaulting to 2^30.
+     *     this stream.
      */
     void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-        int priority, List<Header> headerBlock, HeadersMode headersMode);
+        List<Header> headerBlock, HeadersMode headersMode);
     void rstStream(int streamId, ErrorCode errorCode);
     void settings(boolean clearPrevious, Settings settings);
 
@@ -85,7 +82,18 @@ void headers(boolean outFinished, boolean inFinished, int streamId, int associat
      * sent on {@code streamId}, or the connection if {@code streamId} is zero.
      */
     void windowUpdate(int streamId, long windowSizeIncrement);
-    void priority(int streamId, int priority);
+
+    /**
+     * Called when reading a headers or priority frame. This may be used to
+     * change the stream's weight from the default (16) to a new value.
+     *
+     * @param streamId stream which has a priority change.
+     * @param streamDependency the stream ID this stream is dependent on.
+     * @param weight relative proportion of priority in [1..256].
+     * @param exclusive inserts this stream ID as the sole child of
+     *     {@code streamDependency}.
+     */
+    void priority(int streamId, int streamDependency, int weight, boolean exclusive);
 
     /**
      * HTTP/2 only. Receive a push promise header block.
@@ -93,8 +101,7 @@ void headers(boolean outFinished, boolean inFinished, int streamId, int associat
      * A push promise contains all the headers that pertain to a server-initiated
      * request, and a {@code promisedStreamId} to which response frames will be
      * delivered. Push promise frames are sent as a part of the response to
-     * {@code streamId}.  The {@code promisedStreamId} has a priority of one
-     * greater than {@code streamId}.
+     * {@code streamId}.
      *
      * @param streamId client-initiated stream ID.  Must be an odd number.
      * @param promisedStreamId server-initiated stream ID.  Must be an even
@@ -104,5 +111,27 @@ void headers(boolean outFinished, boolean inFinished, int streamId, int associat
      */
     void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
         throws IOException;
+
+    /**
+     * HTTP/2 only. Expresses that resources for the connection or a client-
+     * initiated stream are available from a different network location or
+     * protocol configuration.
+     *
+     * <p>See <a href="https://tools.ietf.org/html/draft-ietf-httpbis-alt-svc-01">alt-svc</a>
+     *
+     * @param streamId when a client-initiated stream ID (odd number), the
+     *     origin of this alternate service is the origin of the stream. When
+     *     zero, the origin is specified in the {@code origin} parameter.
+     * @param origin when present, the
+     *     <a href="http://tools.ietf.org/html/rfc6454">origin</a> is typically
+     *     represented as a combination of scheme, host and port. When empty,
+     *     the origin is that of the {@code streamId}.
+     * @param protocol an ALPN protocol, such as {@code h2}.
+     * @param host an IP address or hostname.
+     * @param port the IP port associated with the service.
+     * @param maxAge time in seconds that this alternative is considered fresh.
+     */
+    void alternateService(int streamId, String origin, ByteString protocol, String host, int port,
+        long maxAge);
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
index 2883a279f9..02412b0fa2 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
@@ -24,7 +24,7 @@
 /** Writes transport frames for SPDY/3 or HTTP/2. */
 public interface FrameWriter extends Closeable {
   /** HTTP/2 only. */
-  void connectionHeader() throws IOException;
+  void connectionPreface() throws IOException;
   void ackSettings() throws IOException;
 
   /**
@@ -48,7 +48,7 @@ void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders
   /** SPDY/3 only. */
   void flush() throws IOException;
   void synStream(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
-      int priority, int slot, List<Header> headerBlock) throws IOException;
+      List<Header> headerBlock) throws IOException;
   void synReply(boolean outFinished, int streamId, List<Header> headerBlock)
       throws IOException;
   void headers(int streamId, List<Header> headerBlock) throws IOException;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft06.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft08.java
similarity index 74%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft06.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft08.java
index 5cd798ec0a..2f78403554 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft06.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft08.java
@@ -1,3 +1,18 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.internal.BitArray;
@@ -15,15 +30,16 @@
 import okio.Source;
 
 /**
- * Read and write HPACK v06.
+ * Read and write HPACK v08.
  *
- * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06
+ * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08
  *
  * This implementation uses an array for the header table with a bitset for
  * references.  Dynamic entries are added to the array, starting in the last
  * position moving forward.  When the array fills, it is doubled.
  */
-final class HpackDraft06 {
+final class HpackDraft08 {
+  private static final int PREFIX_4_BITS = 0x0f;
   private static final int PREFIX_6_BITS = 0x3f;
   private static final int PREFIX_7_BITS = 0x7f;
 
@@ -36,13 +52,14 @@
       new Header(Header.TARGET_SCHEME, "http"),
       new Header(Header.TARGET_SCHEME, "https"),
       new Header(Header.RESPONSE_STATUS, "200"),
-      new Header(Header.RESPONSE_STATUS, "500"),
-      new Header(Header.RESPONSE_STATUS, "404"),
-      new Header(Header.RESPONSE_STATUS, "403"),
+      new Header(Header.RESPONSE_STATUS, "204"),
+      new Header(Header.RESPONSE_STATUS, "206"),
+      new Header(Header.RESPONSE_STATUS, "304"),
       new Header(Header.RESPONSE_STATUS, "400"),
-      new Header(Header.RESPONSE_STATUS, "401"),
+      new Header(Header.RESPONSE_STATUS, "404"),
+      new Header(Header.RESPONSE_STATUS, "500"),
       new Header("accept-charset", ""),
-      new Header("accept-encoding", ""),
+      new Header("accept-encoding", "gzip, deflate"),
       new Header("accept-language", ""),
       new Header("accept-ranges", ""),
       new Header("accept", ""),
@@ -90,16 +107,17 @@
       new Header("www-authenticate", "")
   };
 
-  private HpackDraft06() {
+  private HpackDraft08() {
   }
 
-  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06#section-3.2
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08#section-3.2
   static final class Reader {
 
-    private final List<Header> emittedHeaders = new ArrayList<Header>();
+    private final List<Header> emittedHeaders = new ArrayList<>();
     private final BufferedSource source;
-    private int maxHeaderTableByteCount;
 
+    private int maxHeaderTableByteCountSetting;
+    private int maxHeaderTableByteCount;
     // Visible for testing.
     Header[] headerTable = new Header[8];
     // Array is populated back to front, so new entries always have lowest index.
@@ -118,8 +136,9 @@ private HpackDraft06() {
     BitArray emittedReferencedHeaders = new BitArray.FixedCapacity();
     int headerTableByteCount = 0;
 
-    Reader(int maxHeaderTableByteCount, Source source) {
-      this.maxHeaderTableByteCount = maxHeaderTableByteCount;
+    Reader(int maxHeaderTableByteCountSetting, Source source) {
+      this.maxHeaderTableByteCountSetting = maxHeaderTableByteCountSetting;
+      this.maxHeaderTableByteCount = maxHeaderTableByteCountSetting;
       this.source = Okio.buffer(source);
     }
 
@@ -129,11 +148,18 @@ int maxHeaderTableByteCount() {
 
     /**
      * Called by the reader when the peer sent a new header table size setting.
-     * <p>
-     * Evicts entries or clears the table as needed.
+     * While this establishes the maximum header table size, the
+     * {@link #maxHeaderTableByteCount} set during processing may limit the
+     * table size to a smaller amount.
+     * <p> Evicts entries or clears the table as needed.
      */
-    void maxHeaderTableByteCount(int newMaxHeaderTableByteCount) {
-      this.maxHeaderTableByteCount = newMaxHeaderTableByteCount;
+    void maxHeaderTableByteCountSetting(int newMaxHeaderTableByteCountSetting) {
+      this.maxHeaderTableByteCountSetting = newMaxHeaderTableByteCountSetting;
+      this.maxHeaderTableByteCount = maxHeaderTableByteCountSetting;
+      adjustHeaderTableByteCount();
+    }
+
+    private void adjustHeaderTableByteCount() {
       if (maxHeaderTableByteCount < headerTableByteCount) {
         if (maxHeaderTableByteCount == 0) {
           clearHeaderTable();
@@ -173,46 +199,39 @@ private int evictToRecoverBytes(int bytesToRecover) {
 
     /**
      * Read {@code byteCount} bytes of headers from the source stream into the
-     * set of emitted headers.
+     * set of emitted headers. This implementation does not propagate the never
+     * indexed flag of a header.
      */
     void readHeaders() throws IOException {
       while (!source.exhausted()) {
         int b = source.readByte() & 0xff;
         if (b == 0x80) { // 10000000
-          b = source.readByte();
-          if ((b & 0x80) == 0x80) { // 1NNNNNNN
-            if ((b & PREFIX_7_BITS) == 0) {
-              clearReferenceSet();
-            } else {
-              throw new IOException("Invalid header table state change " + b);
-            }
-          } else {
-            int headerTableByteCount = b != PREFIX_7_BITS ? b : readInt(b, PREFIX_7_BITS);
-            if (headerTableByteCount < 0) {
-              throw new IOException("Invalid header table byte count " + headerTableByteCount);
-            }
-            maxHeaderTableByteCount = Math.min(headerTableByteCount, maxHeaderTableByteCount);
-            int toEvict = headerTableByteCount - maxHeaderTableByteCount;
-            if (toEvict > 0) evictToRecoverBytes(toEvict);
-          }
+          throw new IOException("index == 0");
         } else if ((b & 0x80) == 0x80) { // 1NNNNNNN
           int index = readInt(b, PREFIX_7_BITS);
           readIndexedHeader(index - 1);
-        } else { // 0NNNNNNN
-          if (b == 0x40) { // 01000000
-            readLiteralHeaderWithoutIndexingNewName();
-          } else if ((b & 0x40) == 0x40) {  // 01NNNNNN
-            int index = readInt(b, PREFIX_6_BITS);
-            readLiteralHeaderWithoutIndexingIndexedName(index - 1);
-          } else if (b == 0) { // 00000000
-            readLiteralHeaderWithIncrementalIndexingNewName();
-          } else if ((b & 0xc0) == 0) { // 00NNNNNN
-            int index = readInt(b, PREFIX_6_BITS);
-            readLiteralHeaderWithIncrementalIndexingIndexedName(index - 1);
-          } else {
-            // TODO: we should throw something that we can coerce to a PROTOCOL_ERROR
-            throw new AssertionError("unhandled byte: " + Integer.toBinaryString(b));
+        } else if (b == 0x40) { // 01000000
+          readLiteralHeaderWithIncrementalIndexingNewName();
+        } else if ((b & 0x40) == 0x40) {  // 01NNNNNN
+          int index = readInt(b, PREFIX_6_BITS);
+          readLiteralHeaderWithIncrementalIndexingIndexedName(index - 1);
+        } else if ((b & 0x20) == 0x20) {  // 001NNNNN
+          if ((b & 0x10) == 0x10) { // 0011NNNN
+            if ((b & 0x0f) != 0) throw new IOException("Invalid header table state change " + b);
+            clearReferenceSet(); // 00110000
+          } else { // 0010NNNN
+            maxHeaderTableByteCount = readInt(b, PREFIX_4_BITS);
+            if (maxHeaderTableByteCount < 0
+                || maxHeaderTableByteCount > maxHeaderTableByteCountSetting) {
+              throw new IOException("Invalid header table byte count " + maxHeaderTableByteCount);
+            }
+            adjustHeaderTableByteCount();
           }
+        } else if (b == 0x10 || b == 0) { // 000?0000 - Ignore never indexed bit.
+          readLiteralHeaderWithoutIndexingNewName();
+        } else { // 000?NNNN - Ignore never indexed bit.
+          int index = readInt(b, PREFIX_4_BITS);
+          readLiteralHeaderWithoutIndexingIndexedName(index - 1);
         }
       }
     }
@@ -235,7 +254,7 @@ void emitReferenceSet() {
      * emitted headers.
      */
     List<Header> getAndReset() {
-      List<Header> result = new ArrayList<Header>(emittedHeaders);
+      List<Header> result = new ArrayList<>(emittedHeaders);
       emittedHeaders.clear();
       emittedReferencedHeaders.clear();
       return result;
@@ -270,26 +289,26 @@ private int headerTableIndex(int index) {
 
     private void readLiteralHeaderWithoutIndexingIndexedName(int index) throws IOException {
       ByteString name = getName(index);
-      ByteString value = readByteString(false);
+      ByteString value = readByteString();
       emittedHeaders.add(new Header(name, value));
     }
 
     private void readLiteralHeaderWithoutIndexingNewName() throws IOException {
-      ByteString name = readByteString(true);
-      ByteString value = readByteString(false);
+      ByteString name = checkLowercase(readByteString());
+      ByteString value = readByteString();
       emittedHeaders.add(new Header(name, value));
     }
 
     private void readLiteralHeaderWithIncrementalIndexingIndexedName(int nameIndex)
         throws IOException {
       ByteString name = getName(nameIndex);
-      ByteString value = readByteString(false);
+      ByteString value = readByteString();
       insertIntoHeaderTable(-1, new Header(name, value));
     }
 
     private void readLiteralHeaderWithIncrementalIndexingNewName() throws IOException {
-      ByteString name = readByteString(true);
-      ByteString value = readByteString(false);
+      ByteString name = checkLowercase(readByteString());
+      ByteString value = readByteString();
       insertIntoHeaderTable(-1, new Header(name, value));
     }
 
@@ -376,34 +395,24 @@ int readInt(int firstByte, int prefixMask) throws IOException {
       return result;
     }
 
-    /**
-     * Reads a potentially Huffman encoded string byte string. When
-     * {@code asciiLowercase} is true, bytes will be converted to lowercase.
-     */
-    ByteString readByteString(boolean asciiLowercase) throws IOException {
+    /** Reads a potentially Huffman encoded byte string. */
+    ByteString readByteString() throws IOException {
       int firstByte = readByte();
       boolean huffmanDecode = (firstByte & 0x80) == 0x80; // 1NNNNNNN
       int length = readInt(firstByte, PREFIX_7_BITS);
 
-      ByteString byteString = source.readByteString(length);
-
       if (huffmanDecode) {
-        byteString = Huffman.get().decode(byteString); // TODO: streaming Huffman!
-      }
-
-      if (asciiLowercase) {
-        byteString = byteString.toAsciiLowercase();
+        return ByteString.of(Huffman.get().decode(source.readByteArray(length)));
+      } else {
+        return source.readByteString(length);
       }
-
-      return byteString;
     }
   }
 
   private static final Map<ByteString, Integer> NAME_TO_FIRST_INDEX = nameToFirstIndex();
 
   private static Map<ByteString, Integer> nameToFirstIndex() {
-    Map<ByteString, Integer> result =
-        new LinkedHashMap<ByteString, Integer>(STATIC_HEADER_TABLE.length);
+    Map<ByteString, Integer> result = new LinkedHashMap<>(STATIC_HEADER_TABLE.length);
     for (int i = 0; i < STATIC_HEADER_TABLE.length; i++) {
       if (!result.containsKey(STATIC_HEADER_TABLE[i].name)) {
         result.put(STATIC_HEADER_TABLE[i].name, i);
@@ -419,24 +428,26 @@ ByteString readByteString(boolean asciiLowercase) throws IOException {
       this.out = out;
     }
 
+    /** This does not use "never indexed" semantics for sensitive headers. */
+    // https://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08#section-4.3.3
     void writeHeaders(List<Header> headerBlock) throws IOException {
       // TODO: implement index tracking
       for (int i = 0, size = headerBlock.size(); i < size; i++) {
-        ByteString name = headerBlock.get(i).name;
+        ByteString name = headerBlock.get(i).name.toAsciiLowercase();
         Integer staticIndex = NAME_TO_FIRST_INDEX.get(name);
         if (staticIndex != null) {
           // Literal Header Field without Indexing - Indexed Name.
-          writeInt(staticIndex + 1, PREFIX_6_BITS, 0x40);
+          writeInt(staticIndex + 1, PREFIX_4_BITS, 0);
           writeByteString(headerBlock.get(i).value);
         } else {
-          out.writeByte(0x40); // Literal Header without Indexing - New Name.
+          out.writeByte(0x00); // Literal Header without Indexing - New Name.
           writeByteString(name);
           writeByteString(headerBlock.get(i).value);
         }
       }
     }
 
-    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06#section-4.1.1
+    // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08#section-4.1.1
     void writeInt(int value, int prefixMask, int bits) throws IOException {
       // Write the raw value for a single byte value.
       if (value < prefixMask) {
@@ -462,4 +473,18 @@ void writeByteString(ByteString data) throws IOException {
       out.write(data);
     }
   }
+
+  /**
+   * An HTTP/2 response cannot contain uppercase header characters and must
+   * be treated as malformed.
+   */
+  private static ByteString checkLowercase(ByteString name) throws IOException {
+    for (int i = 0, length = name.size(); i < length; i++) {
+      byte c = name.getByte(i);
+      if (c >= 'A' && c <= 'Z') {
+        throw new IOException("PROTOCOL_ERROR response malformed: mixed case name: " + name.utf8());
+      }
+    }
+    return name;
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft10.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft13.java
similarity index 78%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft10.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft13.java
index 036f0986a6..4c40a17a66 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft10.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft13.java
@@ -15,35 +15,39 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.Protocol;
 import java.io.IOException;
 import java.util.List;
 import java.util.logging.Logger;
+
+import com.squareup.okhttp.Protocol;
+
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
 import okio.ByteString;
 import okio.Source;
 import okio.Timeout;
-
-import static com.squareup.okhttp.internal.spdy.Http20Draft10.FrameLogger.formatHeader;
+import static com.squareup.okhttp.internal.spdy.Http20Draft13.FrameLogger.formatHeader;
 import static java.lang.String.format;
 import static java.util.logging.Level.FINE;
+import static okio.ByteString.EMPTY;
 
 /**
- * Read and write HTTP/2 v10 frames.
- * <p>http://tools.ietf.org/html/draft-ietf-httpbis-http2-10
+ * Read and write HTTP/2 v13 frames.
+ * <p>http://tools.ietf.org/html/draft-ietf-httpbis-http2-13
  */
-public final class Http20Draft10 implements Variant {
-  private static final Logger logger = Logger.getLogger(Http20Draft10.class.getName());
+public final class Http20Draft13 implements Variant {
+  private static final Logger logger = Logger.getLogger(Http20Draft13.class.getName());
 
   @Override public Protocol getProtocol() {
     return Protocol.HTTP_2;
   }
 
-  private static final ByteString CONNECTION_HEADER
+  private static final ByteString CONNECTION_PREFACE
       = ByteString.encodeUtf8("PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n");
 
+  static final int MAX_FRAME_SIZE = 0x3fff; // 16383
+
   static final byte TYPE_DATA = 0x0;
   static final byte TYPE_HEADERS = 0x1;
   static final byte TYPE_PRIORITY = 0x2;
@@ -61,10 +65,14 @@
   static final byte FLAG_END_SEGMENT = 0x2;
   static final byte FLAG_END_HEADERS = 0x4; // Used for headers and continuation.
   static final byte FLAG_END_PUSH_PROMISE = 0x4;
-  static final byte FLAG_PRIORITY = 0x8; // Used for headers
-  static final byte FLAG_PAD_LOW = 0x10; // Used for headers, data, and continuation
-  static final byte FLAG_PAD_HIGH = 0x20; // Used for headers, data, and continuation
+  static final byte FLAG_PADDED = 0x8; // Used for headers and data.
+  static final byte FLAG_PRIORITY = 0x20; // Used for headers.
+  static final byte FLAG_COMPRESSED = 0x20; // Used for data.
 
+  /**
+   * Creates a frame reader with max header table size of 4096 and data frame
+   * compression disabled.
+   */
   @Override public FrameReader newReader(BufferedSource source, boolean client) {
     return new Reader(source, 4096, client);
   }
@@ -74,7 +82,7 @@
   }
 
   @Override public int maxFrameSize() {
-    return 16383;
+    return MAX_FRAME_SIZE;
   }
 
   static final class Reader implements FrameReader {
@@ -83,21 +91,21 @@
     private final boolean client;
 
     // Visible for testing.
-    final HpackDraft06.Reader hpackReader;
+    final HpackDraft08.Reader hpackReader;
 
     Reader(BufferedSource source, int headerTableSize, boolean client) {
       this.source = source;
       this.client = client;
       this.continuation = new ContinuationSource(this.source);
-      this.hpackReader = new HpackDraft06.Reader(headerTableSize, continuation);
+      this.hpackReader = new HpackDraft08.Reader(headerTableSize, continuation);
     }
 
-    @Override public void readConnectionHeader() throws IOException {
-      if (client) return; // Nothing to read; servers don't send connection headers!
-      ByteString connectionHeader = source.readByteString(CONNECTION_HEADER.size());
-      if (logger.isLoggable(FINE)) logger.fine(format("<< CONNECTION %s", connectionHeader.hex()));
-      if (!CONNECTION_HEADER.equals(connectionHeader)) {
-        throw ioException("Expected a connection header but was %s", connectionHeader.utf8());
+    @Override public void readConnectionPreface() throws IOException {
+      if (client) return; // Nothing to read; servers doesn't send a connection preface!
+      ByteString connectionPreface = source.readByteString(CONNECTION_PREFACE.size());
+      if (logger.isLoggable(FINE)) logger.fine(format("<< CONNECTION %s", connectionPreface.hex()));
+      if (!CONNECTION_PREFACE.equals(connectionPreface)) {
+        throw ioException("Expected a connection header but was %s", connectionPreface.utf8());
       }
     }
 
@@ -112,7 +120,7 @@
       }
 
       // boolean r = (w1 & 0xc0000000) != 0; // Reserved: Ignore first 2 bits.
-      short length = (short) ((w1 & 0x3fff0000) >> 16); // 14-bit unsigned == max 16383
+      short length = (short) ((w1 & 0x3fff0000) >> 16); // 14-bit unsigned == MAX_FRAME_SIZE
       byte type = (byte) ((w1 & 0xff00) >> 8);
       byte flags = (byte) (w1 & 0xff);
       // boolean r = (w2 & 0x80000000) != 0; // Reserved: Ignore first bit.
@@ -157,7 +165,8 @@
           break;
 
         default:
-          throw ioException("PROTOCOL_ERROR: unknown frame type %s", type);
+          // Implementations MUST discard frames that have unknown or unsupported types.
+          source.skip(length);
       }
       return true;
     }
@@ -168,25 +177,22 @@ private void readHeaders(Handler handler, short length, byte flags, int streamId
 
       boolean endStream = (flags & FLAG_END_STREAM) != 0;
 
-      short padding = readPadding(source, flags);
+      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
 
-      int priority = -1;
       if ((flags & FLAG_PRIORITY) != 0) {
-        priority = source.readInt() & 0x7fffffff;
-        length -= 4; // account for above read.
+        readPriority(handler, streamId);
+        length -= 5; // account for above read.
       }
 
       length = lengthWithoutPadding(length, flags, padding);
 
       List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
 
-      handler.headers(false, endStream, streamId, -1, priority, headerBlock,
-          HeadersMode.HTTP_20_HEADERS);
+      handler.headers(false, endStream, streamId, -1, headerBlock, HeadersMode.HTTP_20_HEADERS);
     }
 
     private List<Header> readHeaderBlock(short length, short padding, byte flags, int streamId)
         throws IOException {
-
       continuation.length = continuation.left = length;
       continuation.padding = padding;
       continuation.flags = flags;
@@ -201,10 +207,14 @@ private void readHeaders(Handler handler, short length, byte flags, int streamId
 
     private void readData(Handler handler, short length, byte flags, int streamId)
         throws IOException {
-      boolean inFinished = (flags & FLAG_END_STREAM) != 0;
       // TODO: checkState open or half-closed (local) or raise STREAM_CLOSED
+      boolean inFinished = (flags & FLAG_END_STREAM) != 0;
+      boolean gzipped = (flags & FLAG_COMPRESSED) != 0;
+      if (gzipped) {
+        throw ioException("PROTOCOL_ERROR: FLAG_COMPRESSED without SETTINGS_COMPRESS_DATA");
+      }
 
-      short padding = readPadding(source, flags);
+      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
       length = lengthWithoutPadding(length, flags, padding);
 
       handler.data(inFinished, streamId, source, length);
@@ -213,12 +223,17 @@ private void readData(Handler handler, short length, byte flags, int streamId)
 
     private void readPriority(Handler handler, short length, byte flags, int streamId)
         throws IOException {
-      if (length != 4) throw ioException("TYPE_PRIORITY length: %d != 4", length);
+      if (length != 5) throw ioException("TYPE_PRIORITY length: %d != 5", length);
       if (streamId == 0) throw ioException("TYPE_PRIORITY streamId == 0");
+      readPriority(handler, streamId);
+    }
+
+    private void readPriority(Handler handler, int streamId) throws IOException {
       int w1 = source.readInt();
-      // boolean r = (w1 & 0x80000000) != 0; // Reserved.
-      int priority = (w1 & 0x7fffffff);
-      handler.priority(streamId, priority);
+      boolean exclusive = (w1 & 0x80000000) != 0;
+      int streamDependency = (w1 & 0x7fffffff);
+      int weight = (source.readByte() & 0xff) + 1;
+      handler.priority(streamId, streamDependency, weight, exclusive);
     }
 
     private void readRstStream(Handler handler, short length, byte flags, int streamId)
@@ -242,10 +257,10 @@ private void readSettings(Handler handler, short length, byte flags, int streamI
         return;
       }
 
-      if (length % 5 != 0) throw ioException("TYPE_SETTINGS length %% 5 != 0: %s", length);
+      if (length % 6 != 0) throw ioException("TYPE_SETTINGS length %% 6 != 0: %s", length);
       Settings settings = new Settings();
-      for (int i = 0; i < length; i += 5) {
-        int id = source.readByte();
+      for (int i = 0; i < length; i += 6) {
+        short id = source.readShort();
         int value = source.readInt();
 
         switch (id) {
@@ -265,6 +280,8 @@ private void readSettings(Handler handler, short length, byte flags, int streamI
               throw ioException("PROTOCOL_ERROR SETTINGS_INITIAL_WINDOW_SIZE > 2^31 - 1");
             }
             break;
+          case 5: // SETTINGS_COMPRESS_DATA
+            break;
           default:
             throw ioException("PROTOCOL_ERROR invalid settings id: %s", id);
         }
@@ -272,7 +289,7 @@ private void readSettings(Handler handler, short length, byte flags, int streamI
       }
       handler.settings(false, settings);
       if (settings.getHeaderTableSize() >= 0) {
-        hpackReader.maxHeaderTableByteCount(settings.getHeaderTableSize());
+        hpackReader.maxHeaderTableByteCountSetting(settings.getHeaderTableSize());
       }
     }
 
@@ -281,9 +298,10 @@ private void readPushPromise(Handler handler, short length, byte flags, int stre
       if (streamId == 0) {
         throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0");
       }
+      short padding = (flags & FLAG_PADDED) != 0 ? (short) (source.readByte() & 0xff) : 0;
       int promisedStreamId = source.readInt() & 0x7fffffff;
       length -= 4; // account for above read.
-      short padding = 0; // no padding for push promise.
+      length = lengthWithoutPadding(length, flags, padding);
       List<Header> headerBlock = readHeaderBlock(length, padding, flags, streamId);
       handler.pushPromise(streamId, promisedStreamId, headerBlock);
     }
@@ -309,7 +327,7 @@ private void readGoAway(Handler handler, short length, byte flags, int streamId)
       if (errorCode == null) {
         throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
       }
-      ByteString debugData = ByteString.EMPTY;
+      ByteString debugData = EMPTY;
       if (opaqueDataLength > 0) { // Must read debug data in order to not corrupt the connection.
         debugData = source.readByteString(opaqueDataLength);
       }
@@ -319,7 +337,7 @@ private void readGoAway(Handler handler, short length, byte flags, int streamId)
     private void readWindowUpdate(Handler handler, short length, byte flags, int streamId)
         throws IOException {
       if (length != 4) throw ioException("TYPE_WINDOW_UPDATE length !=4: %s", length);
-      long increment = (source.readInt() & 0x7fffffff);
+      long increment = (source.readInt() & 0x7fffffffL);
       if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
       handler.windowUpdate(streamId, increment);
     }
@@ -333,14 +351,14 @@ private void readWindowUpdate(Handler handler, short length, byte flags, int str
     private final BufferedSink sink;
     private final boolean client;
     private final Buffer hpackBuffer;
-    private final HpackDraft06.Writer hpackWriter;
+    private final HpackDraft08.Writer hpackWriter;
     private boolean closed;
 
     Writer(BufferedSink sink, boolean client) {
       this.sink = sink;
       this.client = client;
       this.hpackBuffer = new Buffer();
-      this.hpackWriter = new HpackDraft06.Writer(hpackBuffer);
+      this.hpackWriter = new HpackDraft08.Writer(hpackBuffer);
     }
 
     @Override public synchronized void flush() throws IOException {
@@ -358,32 +376,34 @@ private void readWindowUpdate(Handler handler, short length, byte flags, int str
       sink.flush();
     }
 
-    @Override public synchronized void connectionHeader() throws IOException {
+    @Override public synchronized void connectionPreface() throws IOException {
       if (closed) throw new IOException("closed");
       if (!client) return; // Nothing to write; servers don't send connection headers!
-      if (logger.isLoggable(FINE)) logger.fine(format(">> CONNECTION %s", CONNECTION_HEADER.hex()));
-      sink.write(CONNECTION_HEADER.toByteArray());
+      if (logger.isLoggable(FINE)) {
+        logger.fine(format(">> CONNECTION %s", CONNECTION_PREFACE.hex()));
+      }
+      sink.write(CONNECTION_PREFACE.toByteArray());
       sink.flush();
     }
 
     @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
-        int streamId, int associatedStreamId, int priority, int slot, List<Header> headerBlock)
+        int streamId, int associatedStreamId, List<Header> headerBlock)
         throws IOException {
       if (inFinished) throw new UnsupportedOperationException();
       if (closed) throw new IOException("closed");
-      headers(outFinished, streamId, priority, headerBlock);
+      headers(outFinished, streamId, headerBlock);
     }
 
     @Override public synchronized void synReply(boolean outFinished, int streamId,
         List<Header> headerBlock) throws IOException {
       if (closed) throw new IOException("closed");
-      headers(outFinished, streamId, -1, headerBlock);
+      headers(outFinished, streamId, headerBlock);
     }
 
     @Override public synchronized void headers(int streamId, List<Header> headerBlock)
         throws IOException {
       if (closed) throw new IOException("closed");
-      headers(false, streamId, -1, headerBlock);
+      headers(false, streamId, headerBlock);
     }
 
     @Override public synchronized void pushPromise(int streamId, int promisedStreamId,
@@ -392,29 +412,40 @@ private void readWindowUpdate(Handler handler, short length, byte flags, int str
       if (hpackBuffer.size() != 0) throw new IllegalStateException();
       hpackWriter.writeHeaders(requestHeaders);
 
-      int length = (int) (4 + hpackBuffer.size());
+      long byteCount = hpackBuffer.size();
+      int length = (int) Math.min(MAX_FRAME_SIZE - 4, byteCount);
       byte type = TYPE_PUSH_PROMISE;
-      byte flags = FLAG_END_HEADERS;
-      frameHeader(streamId, length, type, flags); // TODO: CONTINUATION
+      byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
+      frameHeader(streamId, length + 4, type, flags);
       sink.writeInt(promisedStreamId & 0x7fffffff);
-      sink.writeAll(hpackBuffer);
+      sink.write(hpackBuffer, length);
+
+      if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
     }
 
-    private void headers(boolean outFinished, int streamId, int priority,
-        List<Header> headerBlock) throws IOException {
+    void headers(boolean outFinished, int streamId, List<Header> headerBlock) throws IOException {
       if (closed) throw new IOException("closed");
       if (hpackBuffer.size() != 0) throw new IllegalStateException();
       hpackWriter.writeHeaders(headerBlock);
 
-      int length = (int) hpackBuffer.size();
+      long byteCount = hpackBuffer.size();
+      int length = (int) Math.min(MAX_FRAME_SIZE, byteCount);
       byte type = TYPE_HEADERS;
-      byte flags = FLAG_END_HEADERS;
+      byte flags = byteCount == length ? FLAG_END_HEADERS : 0;
       if (outFinished) flags |= FLAG_END_STREAM;
-      if (priority != -1) flags |= FLAG_PRIORITY;
-      if (priority != -1) length += 4;
-      frameHeader(streamId, length, type, flags); // TODO: CONTINUATION
-      if (priority != -1) sink.writeInt(priority & 0x7fffffff);
-      sink.writeAll(hpackBuffer);
+      frameHeader(streamId, length, type, flags);
+      sink.write(hpackBuffer, length);
+
+      if (byteCount > length) writeContinuationFrames(streamId, byteCount - length);
+    }
+
+    private void writeContinuationFrames(int streamId, long byteCount) throws IOException {
+      while (byteCount > 0) {
+        int length = (int) Math.min(MAX_FRAME_SIZE, byteCount);
+        byteCount -= length;
+        frameHeader(streamId, length, TYPE_CONTINUATION, byteCount == 0 ? FLAG_END_HEADERS : 0);
+        sink.write(hpackBuffer, length);
+      }
     }
 
     @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
@@ -453,7 +484,7 @@ void dataFrame(int streamId, byte flags, Buffer buffer, int byteCount) throws IO
 
     @Override public synchronized void settings(Settings settings) throws IOException {
       if (closed) throw new IOException("closed");
-      int length = settings.size() * 5;
+      int length = settings.size() * 6;
       byte type = TYPE_SETTINGS;
       byte flags = FLAG_NONE;
       int streamId = 0;
@@ -463,7 +494,7 @@ void dataFrame(int streamId, byte flags, Buffer buffer, int byteCount) throws IO
         int id = i;
         if (id == 4) id = 3; // SETTINGS_MAX_CONCURRENT_STREAMS renumbered.
         else if (id == 7) id = 4; // SETTINGS_INITIAL_WINDOW_SIZE renumbered.
-        sink.writeByte(id);
+        sink.writeShort(id);
         sink.writeInt(settings.get(i));
       }
       sink.flush();
@@ -521,7 +552,9 @@ void dataFrame(int streamId, byte flags, Buffer buffer, int byteCount) throws IO
 
     void frameHeader(int streamId, int length, byte type, byte flags) throws IOException {
       if (logger.isLoggable(FINE)) logger.fine(formatHeader(false, streamId, length, type, flags));
-      if (length > 16383) throw illegalArgument("FRAME_SIZE_ERROR length > 16383: %s", length);
+      if (length > MAX_FRAME_SIZE) {
+        throw illegalArgument("FRAME_SIZE_ERROR length > %d: %d", MAX_FRAME_SIZE, length);
+      }
       if ((streamId & 0x80000000) != 0) throw illegalArgument("reserved bit set: %s", streamId);
       sink.writeInt((length & 0x3fff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
       sink.writeInt(streamId & 0x7fffffff);
@@ -539,7 +572,7 @@ private static IOException ioException(String message, Object... args) throws IO
   /**
    * Decompression of the header block occurs above the framing layer. This
    * class lazily reads continuation frames as they are needed by {@link
-   * HpackDraft06.Reader#readHeaders()}.
+   * HpackDraft08.Reader#readHeaders()}.
    */
   static final class ContinuationSource implements Source {
     private final BufferedSource source;
@@ -581,39 +614,19 @@ private void readContinuationHeader() throws IOException {
       int previousStreamId = streamId;
       int w1 = source.readInt();
       int w2 = source.readInt();
-      length = (short) ((w1 & 0x3fff0000) >> 16);
+      length = left = (short) ((w1 & 0x3fff0000) >> 16);
       byte type = (byte) ((w1 & 0xff00) >> 8);
       flags = (byte) (w1 & 0xff);
       if (logger.isLoggable(FINE)) logger.fine(formatHeader(true, streamId, length, type, flags));
-      padding = readPadding(source, flags);
-      length = left = lengthWithoutPadding(length, flags, padding);
       streamId = (w2 & 0x7fffffff);
       if (type != TYPE_CONTINUATION) throw ioException("%s != TYPE_CONTINUATION", type);
       if (streamId != previousStreamId) throw ioException("TYPE_CONTINUATION streamId changed");
     }
   }
 
-  private static short readPadding(BufferedSource source, byte flags) throws IOException {
-    if ((flags & FLAG_PAD_HIGH) != 0 && (flags & FLAG_PAD_LOW) == 0) {
-      throw ioException("PROTOCOL_ERROR FLAG_PAD_HIGH set without FLAG_PAD_LOW");
-    }
-    int padding = 0;
-    if ((flags & FLAG_PAD_HIGH) != 0) {
-      padding = source.readShort() & 0xffff;
-    } else if ((flags & FLAG_PAD_LOW) != 0) {
-      padding = source.readByte() & 0xff;
-    }
-    if (padding > 16383) throw ioException("PROTOCOL_ERROR padding > 16383: %s", padding);
-    return (short) padding;
-  }
-
   private static short lengthWithoutPadding(short length, byte flags, short padding)
       throws IOException {
-    if ((flags & FLAG_PAD_HIGH) != 0) { // account for reading the padding length.
-      length -= 2;
-    } else if ((flags & FLAG_PAD_LOW) != 0) {
-      length--;
-    }
+    if ((flags & FLAG_PADDED) != 0) length--; // Account for reading the padding length.
     if (padding > length) {
       throw ioException("PROTOCOL_ERROR padding %s > remaining length %s", padding, length);
     }
@@ -655,8 +668,6 @@ static String formatHeader(boolean inbound, int streamId, int length, byte type,
     static String formatFlags(byte type, byte flags) {
       if (flags == 0) return "";
       switch (type) { // Special case types that have 0 or 1 flag.
-        case TYPE_PUSH_PROMISE:
-          return flags == FLAG_END_PUSH_PROMISE ? "END_PUSH_PROMISE" : BINARY[flags];
         case TYPE_SETTINGS:
         case TYPE_PING:
           return flags == FLAG_ACK ? "ACK" : BINARY[flags];
@@ -666,7 +677,14 @@ static String formatFlags(byte type, byte flags) {
         case TYPE_WINDOW_UPDATE:
           return BINARY[flags];
       }
-      return flags < FLAGS.length ? FLAGS[flags] : BINARY[flags];
+      String result = flags < FLAGS.length ? FLAGS[flags] : BINARY[flags];
+      // Special case types that have overlap flag values.
+      if (type == TYPE_PUSH_PROMISE && (flags & FLAG_END_PUSH_PROMISE) != 0) {
+        return result.replace("HEADERS", "PUSH_PROMISE"); // TODO: Avoid allocation.
+      } else if (type == TYPE_DATA && (flags & FLAG_COMPRESSED) != 0) {
+        return result.replace("PRIORITY", "COMPRESSED"); // TODO: Avoid allocation.
+      }
+      return result;
     }
 
     /** Lookup table for valid frame types. */
@@ -702,29 +720,22 @@ static String formatFlags(byte type, byte flags) {
       int[] prefixFlags =
           new int[] {FLAG_END_STREAM, FLAG_END_SEGMENT, FLAG_END_SEGMENT | FLAG_END_STREAM};
 
-      FLAGS[FLAG_PAD_LOW] = "PAD_LOW";
-      FLAGS[FLAG_PAD_LOW | FLAG_PAD_HIGH] = "PAD_LOW|PAD_HIGH";
-      int[] suffixFlags = new int[] {FLAG_PAD_LOW, FLAG_PAD_LOW | FLAG_PAD_HIGH};
-
+      FLAGS[FLAG_PADDED] = "PADDED";
       for (int prefixFlag : prefixFlags) {
-        for (int suffixFlag : suffixFlags) {
-          FLAGS[prefixFlag | suffixFlag] = FLAGS[prefixFlag] + '|' + FLAGS[suffixFlag];
-        }
+         FLAGS[prefixFlag | FLAG_PADDED] = FLAGS[prefixFlag] + "|PADDED";
       }
 
-      FLAGS[FLAG_END_HEADERS] = "END_HEADERS";
-      FLAGS[FLAG_PRIORITY] = "PRIORITY";
-      FLAGS[FLAG_END_HEADERS | FLAG_PRIORITY] = "END_HEADERS|PRIORITY";
+      FLAGS[FLAG_END_HEADERS] = "END_HEADERS"; // Same as END_PUSH_PROMISE.
+      FLAGS[FLAG_PRIORITY] = "PRIORITY"; // Same as FLAG_COMPRESSED.
+      FLAGS[FLAG_END_HEADERS | FLAG_PRIORITY] = "END_HEADERS|PRIORITY"; // Only valid on HEADERS.
       int[] frameFlags =
           new int[] {FLAG_END_HEADERS, FLAG_PRIORITY, FLAG_END_HEADERS | FLAG_PRIORITY};
 
       for (int frameFlag : frameFlags) {
         for (int prefixFlag : prefixFlags) {
           FLAGS[prefixFlag | frameFlag] = FLAGS[prefixFlag] + '|' + FLAGS[frameFlag];
-          for (int suffixFlag : suffixFlags) {
-            FLAGS[prefixFlag | frameFlag | suffixFlag] =
-                FLAGS[prefixFlag] + '|' + FLAGS[frameFlag] + '|' + FLAGS[suffixFlag];
-          }
+          FLAGS[prefixFlag | frameFlag | FLAG_PADDED] =
+              FLAGS[prefixFlag] + '|' + FLAGS[frameFlag] + "|PADDED";
         }
       }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
index 5b9c22f5c4..ab15011150 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
@@ -18,7 +18,6 @@
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
-import okio.ByteString;
 
 /**
  * This class was originally composed from the following classes in
@@ -32,49 +31,47 @@
 class Huffman {
 
   // Appendix C: Huffman Codes
-  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-06#appendix-C
+  // http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-08#appendix-C
   private static final int[] CODES = {
-      0x7ffffba, 0x7ffffbb, 0x7ffffbc, 0x7ffffbd, 0x7ffffbe, 0x7ffffbf, 0x7ffffc0, 0x7ffffc1,
-      0x7ffffc2, 0x7ffffc3, 0x7ffffc4, 0x7ffffc5, 0x7ffffc6, 0x7ffffc7, 0x7ffffc8, 0x7ffffc9,
-      0x7ffffca, 0x7ffffcb, 0x7ffffcc, 0x7ffffcd, 0x7ffffce, 0x7ffffcf, 0x7ffffd0, 0x7ffffd1,
-      0x7ffffd2, 0x7ffffd3, 0x7ffffd4, 0x7ffffd5, 0x7ffffd6, 0x7ffffd7, 0x7ffffd8, 0x7ffffd9, 0xe8,
-      0xffc, 0x3ffa, 0x7ffc, 0x7ffd, 0x24, 0x6e, 0x7ffe, 0x7fa, 0x7fb, 0x3fa, 0x7fc, 0xe9, 0x25,
-      0x4, 0x0, 0x5, 0x6, 0x7, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x1ec, 0xea, 0x3fffe, 0x2d,
-      0x1fffc, 0x1ed, 0x3ffb, 0x6f, 0xeb, 0xec, 0xed, 0xee, 0x70, 0x1ee, 0x1ef, 0x1f0, 0x1f1, 0x3fb,
-      0x1f2, 0xef, 0x1f3, 0x1f4, 0x1f5, 0x1f6, 0x1f7, 0xf0, 0xf1, 0x1f8, 0x1f9, 0x1fa, 0x1fb, 0x1fc,
-      0x3fc, 0x3ffc, 0x7ffffda, 0x1ffc, 0x3ffd, 0x2e, 0x7fffe, 0x8, 0x2f, 0x9, 0x30, 0x1, 0x31,
-      0x32, 0x33, 0xa, 0x71, 0x72, 0xb, 0x34, 0xc, 0xd, 0xe, 0xf2, 0xf, 0x10, 0x11, 0x35, 0x73,
-      0x36, 0xf3, 0xf4, 0xf5, 0x1fffd, 0x7fd, 0x1fffe, 0xffd, 0x7ffffdb, 0x7ffffdc, 0x7ffffdd,
-      0x7ffffde, 0x7ffffdf, 0x7ffffe0, 0x7ffffe1, 0x7ffffe2, 0x7ffffe3, 0x7ffffe4, 0x7ffffe5,
-      0x7ffffe6, 0x7ffffe7, 0x7ffffe8, 0x7ffffe9, 0x7ffffea, 0x7ffffeb, 0x7ffffec, 0x7ffffed,
-      0x7ffffee, 0x7ffffef, 0x7fffff0, 0x7fffff1, 0x7fffff2, 0x7fffff3, 0x7fffff4, 0x7fffff5,
-      0x7fffff6, 0x7fffff7, 0x7fffff8, 0x7fffff9, 0x7fffffa, 0x7fffffb, 0x7fffffc, 0x7fffffd,
-      0x7fffffe, 0x7ffffff, 0x3ffff80, 0x3ffff81, 0x3ffff82, 0x3ffff83, 0x3ffff84, 0x3ffff85,
-      0x3ffff86, 0x3ffff87, 0x3ffff88, 0x3ffff89, 0x3ffff8a, 0x3ffff8b, 0x3ffff8c, 0x3ffff8d,
-      0x3ffff8e, 0x3ffff8f, 0x3ffff90, 0x3ffff91, 0x3ffff92, 0x3ffff93, 0x3ffff94, 0x3ffff95,
-      0x3ffff96, 0x3ffff97, 0x3ffff98, 0x3ffff99, 0x3ffff9a, 0x3ffff9b, 0x3ffff9c, 0x3ffff9d,
-      0x3ffff9e, 0x3ffff9f, 0x3ffffa0, 0x3ffffa1, 0x3ffffa2, 0x3ffffa3, 0x3ffffa4, 0x3ffffa5,
-      0x3ffffa6, 0x3ffffa7, 0x3ffffa8, 0x3ffffa9, 0x3ffffaa, 0x3ffffab, 0x3ffffac, 0x3ffffad,
-      0x3ffffae, 0x3ffffaf, 0x3ffffb0, 0x3ffffb1, 0x3ffffb2, 0x3ffffb3, 0x3ffffb4, 0x3ffffb5,
-      0x3ffffb6, 0x3ffffb7, 0x3ffffb8, 0x3ffffb9, 0x3ffffba, 0x3ffffbb, 0x3ffffbc, 0x3ffffbd,
-      0x3ffffbe, 0x3ffffbf, 0x3ffffc0, 0x3ffffc1, 0x3ffffc2, 0x3ffffc3, 0x3ffffc4, 0x3ffffc5,
-      0x3ffffc6, 0x3ffffc7, 0x3ffffc8, 0x3ffffc9, 0x3ffffca, 0x3ffffcb, 0x3ffffcc, 0x3ffffcd,
-      0x3ffffce, 0x3ffffcf, 0x3ffffd0, 0x3ffffd1, 0x3ffffd2, 0x3ffffd3, 0x3ffffd4, 0x3ffffd5,
-      0x3ffffd6, 0x3ffffd7, 0x3ffffd8, 0x3ffffd9, 0x3ffffda, 0x3ffffdb
+      0x1ff8, 0x7fffd8, 0xfffffe2, 0xfffffe3, 0xfffffe4, 0xfffffe5, 0xfffffe6, 0xfffffe7, 0xfffffe8,
+      0xffffea, 0x3ffffffc, 0xfffffe9, 0xfffffea, 0x3ffffffd, 0xfffffeb, 0xfffffec, 0xfffffed,
+      0xfffffee, 0xfffffef, 0xffffff0, 0xffffff1, 0xffffff2, 0x3ffffffe, 0xffffff3, 0xffffff4,
+      0xffffff5, 0xffffff6, 0xffffff7, 0xffffff8, 0xffffff9, 0xffffffa, 0xffffffb, 0x14, 0x3f8,
+      0x3f9, 0xffa, 0x1ff9, 0x15, 0xf8, 0x7fa, 0x3fa, 0x3fb, 0xf9, 0x7fb, 0xfa, 0x16, 0x17, 0x18,
+      0x0, 0x1, 0x2, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x5c, 0xfb, 0x7ffc, 0x20, 0xffb,
+      0x3fc, 0x1ffa, 0x21, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
+      0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0xfc, 0x73, 0xfd, 0x1ffb, 0x7fff0,
+      0x1ffc, 0x3ffc, 0x22, 0x7ffd, 0x3, 0x23, 0x4, 0x24, 0x5, 0x25, 0x26, 0x27, 0x6, 0x74, 0x75,
+      0x28, 0x29, 0x2a, 0x7, 0x2b, 0x76, 0x2c, 0x8, 0x9, 0x2d, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7ffe,
+      0x7fc, 0x3ffd, 0x1ffd, 0xffffffc, 0xfffe6, 0x3fffd2, 0xfffe7, 0xfffe8, 0x3fffd3, 0x3fffd4,
+      0x3fffd5, 0x7fffd9, 0x3fffd6, 0x7fffda, 0x7fffdb, 0x7fffdc, 0x7fffdd, 0x7fffde, 0xffffeb,
+      0x7fffdf, 0xffffec, 0xffffed, 0x3fffd7, 0x7fffe0, 0xffffee, 0x7fffe1, 0x7fffe2, 0x7fffe3,
+      0x7fffe4, 0x1fffdc, 0x3fffd8, 0x7fffe5, 0x3fffd9, 0x7fffe6, 0x7fffe7, 0xffffef, 0x3fffda,
+      0x1fffdd, 0xfffe9, 0x3fffdb, 0x3fffdc, 0x7fffe8, 0x7fffe9, 0x1fffde, 0x7fffea, 0x3fffdd,
+      0x3fffde, 0xfffff0, 0x1fffdf, 0x3fffdf, 0x7fffeb, 0x7fffec, 0x1fffe0, 0x1fffe1, 0x3fffe0,
+      0x1fffe2, 0x7fffed, 0x3fffe1, 0x7fffee, 0x7fffef, 0xfffea, 0x3fffe2, 0x3fffe3, 0x3fffe4,
+      0x7ffff0, 0x3fffe5, 0x3fffe6, 0x7ffff1, 0x3ffffe0, 0x3ffffe1, 0xfffeb, 0x7fff1, 0x3fffe7,
+      0x7ffff2, 0x3fffe8, 0x1ffffec, 0x3ffffe2, 0x3ffffe3, 0x3ffffe4, 0x7ffffde, 0x7ffffdf,
+      0x3ffffe5, 0xfffff1, 0x1ffffed, 0x7fff2, 0x1fffe3, 0x3ffffe6, 0x7ffffe0, 0x7ffffe1, 0x3ffffe7,
+      0x7ffffe2, 0xfffff2, 0x1fffe4, 0x1fffe5, 0x3ffffe8, 0x3ffffe9, 0xffffffd, 0x7ffffe3,
+      0x7ffffe4, 0x7ffffe5, 0xfffec, 0xfffff3, 0xfffed, 0x1fffe6, 0x3fffe9, 0x1fffe7, 0x1fffe8,
+      0x7ffff3, 0x3fffea, 0x3fffeb, 0x1ffffee, 0x1ffffef, 0xfffff4, 0xfffff5, 0x3ffffea, 0x7ffff4,
+      0x3ffffeb, 0x7ffffe6, 0x3ffffec, 0x3ffffed, 0x7ffffe7, 0x7ffffe8, 0x7ffffe9, 0x7ffffea,
+      0x7ffffeb, 0xffffffe, 0x7ffffec, 0x7ffffed, 0x7ffffee, 0x7ffffef, 0x7fffff0, 0x3ffffee
   };
 
   private static final byte[] CODE_LENGTHS = {
-      27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
-      27, 27, 27, 27, 27, 27, 27, 27, 27, 8, 12, 14, 15, 15, 6, 7, 15, 11, 11, 10, 11, 8, 6, 5, 4,
-      5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 9, 8, 18, 6, 17, 9, 14, 7, 8, 8, 8, 8, 7, 9, 9, 9, 9, 10, 9, 8,
-      9, 9, 9, 9, 9, 8, 8, 9, 9, 9, 9, 9, 10, 14, 27, 13, 14, 6, 19, 5, 6, 5, 6, 4, 6, 6, 6, 5, 7,
-      7, 5, 6, 5, 5, 5, 8, 5, 5, 5, 6, 7, 6, 8, 8, 8, 17, 11, 17, 12, 27, 27, 27, 27, 27, 27, 27,
-      27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
-      27, 27, 27, 27, 27, 27, 27, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-      26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
-      26, 26, 26, 26, 26, 26, 26
+      13, 23, 28, 28, 28, 28, 28, 28, 28, 24, 30, 28, 28, 30, 28, 28, 28, 28, 28, 28, 28, 28, 30,
+      28, 28, 28, 28, 28, 28, 28, 28, 28, 6, 10, 10, 12, 13, 6, 8, 11, 10, 10, 8, 11, 8, 6, 6, 6, 5,
+      5, 5, 6, 6, 6, 6, 6, 6, 6, 7, 8, 15, 6, 12, 10, 13, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
+      7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 8, 13, 19, 13, 14, 6, 15, 5, 6, 5, 6, 5, 6, 6, 6, 5, 7, 7, 6,
+      6, 6, 5, 6, 7, 6, 5, 5, 6, 7, 7, 7, 7, 7, 15, 11, 14, 13, 28, 20, 22, 20, 20, 22, 22, 22, 23,
+      22, 23, 23, 23, 23, 23, 24, 23, 24, 24, 22, 23, 24, 23, 23, 23, 23, 21, 22, 23, 22, 23, 23,
+      24, 22, 21, 20, 22, 22, 23, 23, 21, 23, 22, 22, 24, 21, 22, 23, 23, 21, 21, 22, 21, 23, 22,
+      23, 23, 20, 22, 22, 22, 23, 22, 22, 23, 26, 26, 20, 19, 22, 23, 22, 25, 26, 26, 26, 27, 27,
+      26, 24, 25, 19, 21, 26, 27, 27, 26, 27, 24, 21, 21, 26, 26, 28, 27, 27, 27, 20, 24, 20, 21,
+      22, 21, 21, 23, 22, 22, 25, 25, 24, 24, 26, 23, 26, 27, 26, 26, 27, 27, 27, 27, 27, 28, 27,
+      27, 27, 27, 27, 26
   };
 
   private static final Huffman INSTANCE = new Huffman();
@@ -126,12 +123,7 @@ int encodedLength(byte[] bytes) {
     return (int) ((len + 7) >> 3);
   }
 
-  ByteString decode(ByteString buf) throws IOException {
-    return ByteString.of(decode(buf.toByteArray()));
-  }
-
   byte[] decode(byte[] buf) throws IOException {
-    // FIXME
     ByteArrayOutputStream baos = new ByteArrayOutputStream();
     Node node = root;
     int current = 0;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
index 03268e1d8a..6413f36345 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
@@ -1,3 +1,18 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package com.squareup.okhttp.internal.spdy;
 
 import java.io.IOException;
@@ -70,7 +85,7 @@ public NameValueBlockReader(BufferedSource source) {
     if (numberOfPairs < 0) throw new IOException("numberOfPairs < 0: " + numberOfPairs);
     if (numberOfPairs > 1024) throw new IOException("numberOfPairs > 1024: " + numberOfPairs);
 
-    List<Header> entries = new ArrayList<Header>(numberOfPairs);
+    List<Header> entries = new ArrayList<>(numberOfPairs);
     for (int i = 0; i < numberOfPairs; i++) {
       ByteString name = readByteString().toAsciiLowercase();
       ByteString values = readByteString();
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java
index fa478adf97..cdb51f65a5 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java
@@ -21,9 +21,19 @@
 
 /**
  * {@link com.squareup.okhttp.Protocol#HTTP_2 HTTP/2} only.
- * Processes server-initiated HTTP requests on the client.
+ * Processes server-initiated HTTP requests on the client. Implementations must
+ * quickly dispatch callbacks to avoid creating a bottleneck.
  *
- * <p>Use the stream ID to correlate response headers and data.
+ * <p>While {@link #onReset} may occur at any time, the following callbacks are
+ * expected in order, correlated by stream ID.
+ * <ul>
+ *   <li>{@link #onRequest}</li>
+ *   <li>{@link #onHeaders} (unless canceled)</li>
+ *   <li>{@link #onData} (optional sequence of data frames)</li>
+ * </ul>
+ *
+ * <p>As a stream ID is scoped to a single HTTP/2 connection, implementations
+ * which target multiple connections should expect repetition of stream IDs.
  *
  * <p>Return true to request cancellation of a pushed stream.  Note that this
  * does not guarantee future frames won't arrive on the stream ID.
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
index c40bfeda25..9c914db867 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
@@ -42,7 +42,7 @@
   static final int HEADER_TABLE_SIZE = 1;
   /** spdy/3: Sender's estimate of max outgoing kbps. */
   static final int DOWNLOAD_BANDWIDTH = 2;
-  /** HTTP/2: An endpoint must not send a PUSH_PROMISE frame when this is 0. */
+  /** HTTP/2: The peer must not send a PUSH_PROMISE frame when this is 0. */
   static final int ENABLE_PUSH = 2;
   /** spdy/3: Sender's estimate of millis between sending a request and receiving a response. */
   static final int ROUND_TRIP_TIME = 3;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
index 535d71f227..83ccdb9ee7 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -119,7 +119,7 @@
       this.client = client;
     }
 
-    @Override public void readConnectionHeader() {
+    @Override public void readConnectionPreface() {
     }
 
     /**
@@ -196,17 +196,15 @@
     private void readSynStream(Handler handler, int flags, int length) throws IOException {
       int w1 = source.readInt();
       int w2 = source.readInt();
-      int s3 = source.readShort();
       int streamId = w1 & 0x7fffffff;
       int associatedStreamId = w2 & 0x7fffffff;
-      int priority = (s3 & 0xe000) >>> 13;
-      // int slot = s3 & 0xff;
+      source.readShort(); // int priority = (s3 & 0xe000) >>> 13; int slot = s3 & 0xff;
       List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 10);
 
       boolean inFinished = (flags & FLAG_FIN) != 0;
       boolean outFinished = (flags & FLAG_UNIDIRECTIONAL) != 0;
-      handler.headers(outFinished, inFinished, streamId, associatedStreamId, priority,
-          headerBlock, HeadersMode.SPDY_SYN_STREAM);
+      handler.headers(outFinished, inFinished, streamId, associatedStreamId, headerBlock,
+          HeadersMode.SPDY_SYN_STREAM);
     }
 
     private void readSynReply(Handler handler, int flags, int length) throws IOException {
@@ -214,7 +212,7 @@ private void readSynReply(Handler handler, int flags, int length) throws IOExcep
       int streamId = w1 & 0x7fffffff;
       List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
       boolean inFinished = (flags & FLAG_FIN) != 0;
-      handler.headers(false, inFinished, streamId, -1, -1, headerBlock, HeadersMode.SPDY_REPLY);
+      handler.headers(false, inFinished, streamId, -1, headerBlock, HeadersMode.SPDY_REPLY);
     }
 
     private void readRstStream(Handler handler, int flags, int length) throws IOException {
@@ -232,7 +230,7 @@ private void readHeaders(Handler handler, int flags, int length) throws IOExcept
       int w1 = source.readInt();
       int streamId = w1 & 0x7fffffff;
       List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
-      handler.headers(false, false, streamId, -1, -1, headerBlock, HeadersMode.SPDY_HEADERS);
+      handler.headers(false, false, streamId, -1, headerBlock, HeadersMode.SPDY_HEADERS);
     }
 
     private void readWindowUpdate(Handler handler, int flags, int length) throws IOException {
@@ -317,8 +315,8 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> request
       // Do nothing: no push promise for SPDY/3.
     }
 
-    @Override public synchronized void connectionHeader() {
-      // Do nothing: no connection header for SPDY/3.
+    @Override public synchronized void connectionPreface() {
+      // Do nothing: no connection preface for SPDY/3.
     }
 
     @Override public synchronized void flush() throws IOException {
@@ -327,7 +325,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> request
     }
 
     @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
-        int streamId, int associatedStreamId, int priority, int slot, List<Header> headerBlock)
+        int streamId, int associatedStreamId, List<Header> headerBlock)
         throws IOException {
       if (closed) throw new IOException("closed");
       writeNameValueBlockToBuffer(headerBlock);
@@ -340,7 +338,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> request
       sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
       sink.writeInt(streamId & 0x7fffffff);
       sink.writeInt(associatedStreamId & 0x7fffffff);
-      sink.writeShort((priority & 0x7) << 13 | (unused & 0x1f) << 8 | (slot & 0xff));
+      sink.writeShort((unused & 0x7) << 13 | (unused & 0x1f) << 8 | (unused & 0xff));
       sink.writeAll(headerBlockBuffer);
       sink.flush();
     }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index adfed78296..d5f80e177f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -30,6 +30,7 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ExecutorService;
+import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
@@ -78,13 +79,16 @@
    * run on the callback executor.
    */
   private final IncomingStreamHandler handler;
-  private final Map<Integer, SpdyStream> streams = new HashMap<Integer, SpdyStream>();
+  private final Map<Integer, SpdyStream> streams = new HashMap<>();
   private final String hostName;
   private int lastGoodStreamId;
   private int nextStreamId;
   private boolean shutdown;
   private long idleStartTimeNs = System.nanoTime();
 
+  /** Ensures push promise callbacks events are sent in order per stream. */
+  private final ExecutorService pushExecutor;
+
   /** Lazily-created map of in-flight pings awaiting a response. Guarded by this. */
   private Map<Integer, Ping> pings;
   /** User code to run in response to push promise events. */
@@ -109,6 +113,7 @@
   // TODO: Do we want to dynamically adjust settings, or KISS and only set once?
   final Settings okHttpSettings = new Settings();
       // okHttpSettings.set(Settings.MAX_CONCURRENT_STREAMS, 0, max);
+  private static final int OKHTTP_CLIENT_WINDOW_SIZE = 16 * 1024 * 1024;
 
   /** Settings we receive from the peer. */
   // TODO: MWS will need to guard on this setting before attempting to push.
@@ -128,8 +133,12 @@ private SpdyConnection(Builder builder) throws IOException {
     pushObserver = builder.pushObserver;
     client = builder.client;
     handler = builder.handler;
-    // http://tools.ietf.org/html/draft-ietf-httpbis-http2-10#section-5.1.1
-    nextStreamId = builder.client ? 3 : 2; // 1 on client is reserved for Upgrade
+    // http://tools.ietf.org/html/draft-ietf-httpbis-http2-13#section-5.1.1
+    nextStreamId = builder.client ? 1 : 2;
+    if (builder.client && protocol == Protocol.HTTP_2) {
+      nextStreamId += 2; // In HTTP/2, 1 on client is reserved for Upgrade.
+    }
+
     nextPingId = builder.client ? 1 : 2;
 
     // Flow control was designed more for servers, or proxies than edge clients.
@@ -137,15 +146,23 @@ private SpdyConnection(Builder builder) throws IOException {
     // thrashing window updates every 64KiB, yet small enough to avoid blowing
     // up the heap.
     if (builder.client) {
-      okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, 16 * 1024 * 1024);
+      okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, OKHTTP_CLIENT_WINDOW_SIZE);
     }
 
     hostName = builder.hostName;
 
     if (protocol == Protocol.HTTP_2) {
-      variant = new Http20Draft10();
+      variant = new Http20Draft13();
+      // Like newSingleThreadExecutor, except lazy creates the thread.
+      pushExecutor = new ThreadPoolExecutor(0, 1,
+          0L, TimeUnit.MILLISECONDS,
+          new LinkedBlockingQueue<Runnable>(),
+          Util.threadFactory(String.format("OkHttp %s Push Observer", hostName), true));
+      // 1 less than SPDY http://tools.ietf.org/html/draft-ietf-httpbis-http2-13#section-6.9.2
+      peerSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, 65535);
     } else if (protocol == Protocol.SPDY_3) {
       variant = new Spdy3();
+      pushExecutor = null;
     } else {
       throw new AssertionError(protocol);
     }
@@ -232,8 +249,6 @@ private SpdyStream newStream(int associatedStreamId, List<Header> requestHeaders
       boolean in) throws IOException {
     boolean outFinished = !out;
     boolean inFinished = !in;
-    int priority = -1; // TODO: permit the caller to specify a priority?
-    int slot = 0; // TODO: permit the caller to specify a slot?
     SpdyStream stream;
     int streamId;
 
@@ -244,14 +259,14 @@ private SpdyStream newStream(int associatedStreamId, List<Header> requestHeaders
         }
         streamId = nextStreamId;
         nextStreamId += 2;
-        stream = new SpdyStream(streamId, this, outFinished, inFinished, priority, requestHeaders);
+        stream = new SpdyStream(streamId, this, outFinished, inFinished, requestHeaders);
         if (stream.isOpen()) {
           streams.put(streamId, stream);
           setIdle(false);
         }
       }
       if (associatedStreamId == 0) {
-        frameWriter.synStream(outFinished, inFinished, streamId, associatedStreamId, priority, slot,
+        frameWriter.synStream(outFinished, inFinished, streamId, associatedStreamId,
             requestHeaders);
       } else if (client) {
         throw new IllegalArgumentException("client streams shouldn't have associated stream IDs");
@@ -362,7 +377,7 @@ public Ping ping() throws IOException {
       }
       pingId = nextPingId;
       nextPingId += 2;
-      if (pings == null) pings = new HashMap<Integer, Ping>();
+      if (pings == null) pings = new HashMap<>();
       pings.put(pingId, ping);
     }
     writePing(false, pingId, 0x4f4b6f6b /* ASCII "OKok" */, ping);
@@ -488,9 +503,13 @@ private void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOExce
    * Sends a connection header if the current variant requires it. This should
    * be called after {@link Builder#build} for all new connections.
    */
-  public void sendConnectionHeader() throws IOException {
-    frameWriter.connectionHeader();
+  public void sendConnectionPreface() throws IOException {
+    frameWriter.connectionPreface();
     frameWriter.settings(okHttpSettings);
+    int windowSize = okHttpSettings.getInitialWindowSize(Settings.DEFAULT_INITIAL_WINDOW_SIZE);
+    if (windowSize != Settings.DEFAULT_INITIAL_WINDOW_SIZE) {
+      frameWriter.windowUpdate(0, windowSize - Settings.DEFAULT_INITIAL_WINDOW_SIZE);
+    }
   }
 
   public static class Builder {
@@ -552,7 +571,7 @@ private Reader() {
       try {
         frameReader = variant.newReader(Okio.buffer(Okio.source(socket)), client);
         if (!client) {
-          frameReader.readConnectionHeader();
+          frameReader.readConnectionPreface();
         }
         while (frameReader.nextFrame(this)) {
         }
@@ -589,7 +608,7 @@ private Reader() {
     }
 
     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, List<Header> headerBlock, HeadersMode headersMode) {
+        int associatedStreamId, List<Header> headerBlock, HeadersMode headersMode) {
       if (pushedStream(streamId)) {
         pushHeadersLater(streamId, headerBlock, inFinished);
         return;
@@ -616,7 +635,7 @@ private Reader() {
 
           // Create a stream.
           final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,
-              inFinished, priority, headerBlock);
+              inFinished, headerBlock);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
           executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
@@ -748,7 +767,8 @@ private void ackSettingsLater() {
       }
     }
 
-    @Override public void priority(int streamId, int priority) {
+    @Override public void priority(int streamId, int streamDependency, int weight,
+        boolean exclusive) {
       // TODO: honor priority.
     }
 
@@ -756,6 +776,11 @@ private void ackSettingsLater() {
     public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders) {
       pushRequestLater(promisedStreamId, requestHeaders);
     }
+
+    @Override public void alternateService(int streamId, String origin, ByteString protocol,
+        String host, int port, long maxAge) {
+      // TODO: register alternate service.
+    }
   }
 
   /** Even, positive numbered streams are pushed streams in HTTP/2. */
@@ -764,7 +789,7 @@ private boolean pushedStream(int streamId) {
   }
 
   // Guarded by this.
-  private final Set<Integer> currentPushRequests = new LinkedHashSet<Integer>();
+  private final Set<Integer> currentPushRequests = new LinkedHashSet<>();
 
   private void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
     synchronized (this) {
@@ -774,7 +799,7 @@ private void pushRequestLater(final int streamId, final List<Header> requestHead
       }
       currentPushRequests.add(streamId);
     }
-    executor.submit(new NamedRunnable("OkHttp %s Push Request[%s]", hostName, streamId) {
+    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Request[%s]", hostName, streamId) {
       @Override public void execute() {
         boolean cancel = pushObserver.onRequest(streamId, requestHeaders);
         try {
@@ -792,7 +817,7 @@ private void pushRequestLater(final int streamId, final List<Header> requestHead
 
   private void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
       final boolean inFinished) {
-    executor.submit(new NamedRunnable("OkHttp %s Push Headers[%s]", hostName, streamId) {
+    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Headers[%s]", hostName, streamId) {
       @Override public void execute() {
         boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished);
         try {
@@ -818,7 +843,7 @@ private void pushDataLater(final int streamId, final BufferedSource source, fina
     source.require(byteCount); // Eagerly read the frame before firing client thread.
     source.read(buffer, byteCount);
     if (buffer.size() != byteCount) throw new IOException(buffer.size() + " != " + byteCount);
-    executor.submit(new NamedRunnable("OkHttp %s Push Data[%s]", hostName, streamId) {
+    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Data[%s]", hostName, streamId) {
       @Override public void execute() {
         try {
           boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished);
@@ -835,7 +860,7 @@ private void pushDataLater(final int streamId, final BufferedSource source, fina
   }
 
   private void pushResetLater(final int streamId, final ErrorCode errorCode) {
-    executor.submit(new NamedRunnable("OkHttp %s Push Reset[%s]", hostName, streamId) {
+    pushExecutor.submit(new NamedRunnable("OkHttp %s Push Reset[%s]", hostName, streamId) {
       @Override public void execute() {
         pushObserver.onReset(streamId, errorCode);
         synchronized (SpdyConnection.this) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index ea06d468ff..331536d376 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -19,9 +19,9 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.io.InterruptedIOException;
-import java.net.SocketTimeoutException;
 import java.util.ArrayList;
 import java.util.List;
+import okio.AsyncTimeout;
 import okio.Buffer;
 import okio.BufferedSource;
 import okio.Sink;
@@ -53,7 +53,6 @@
 
   private final int id;
   private final SpdyConnection connection;
-  private final int priority;
   private long readTimeoutMillis = 0;
 
   /** Headers sent by the stream initiator. Immutable and non null. */
@@ -64,6 +63,8 @@
 
   private final SpdyDataSource source;
   final SpdyDataSink sink;
+  private final SpdyTimeout readTimeout = new SpdyTimeout();
+  private final SpdyTimeout writeTimeout = new SpdyTimeout();
 
   /**
    * The reason why this stream was abnormally closed. If there are multiple
@@ -73,7 +74,7 @@
   private ErrorCode errorCode = null;
 
   SpdyStream(int id, SpdyConnection connection, boolean outFinished, boolean inFinished,
-      int priority, List<Header> requestHeaders) {
+      List<Header> requestHeaders) {
     if (connection == null) throw new NullPointerException("connection == null");
     if (requestHeaders == null) throw new NullPointerException("requestHeaders == null");
     this.id = id;
@@ -85,7 +86,6 @@
     this.sink = new SpdyDataSink();
     this.source.finished = inFinished;
     this.sink.finished = outFinished;
-    this.priority = priority;
     this.requestHeaders = requestHeaders;
   }
 
@@ -134,33 +134,16 @@ public SpdyConnection getConnection() {
    * have not been received yet.
    */
   public synchronized List<Header> getResponseHeaders() throws IOException {
-    long remaining = 0;
-    long start = 0;
-    if (readTimeoutMillis != 0) {
-      start = (System.nanoTime() / 1000000);
-      remaining = readTimeoutMillis;
-    }
+    readTimeout.enter();
     try {
       while (responseHeaders == null && errorCode == null) {
-        if (readTimeoutMillis == 0) { // No timeout configured.
-          wait();
-        } else if (remaining > 0) {
-          wait(remaining);
-          remaining = start + readTimeoutMillis - (System.nanoTime() / 1000000);
-        } else {
-          throw new SocketTimeoutException("Read response header timeout. readTimeoutMillis: "
-                            + readTimeoutMillis);
-        }
-      }
-      if (responseHeaders != null) {
-        return responseHeaders;
+        waitForIo();
       }
-      throw new IOException("stream was reset: " + errorCode);
-    } catch (InterruptedException e) {
-      InterruptedIOException rethrow = new InterruptedIOException();
-      rethrow.initCause(e);
-      throw rethrow;
+    } finally {
+      readTimeout.exitAndThrowIfTimedOut();
     }
+    if (responseHeaders != null) return responseHeaders;
+    throw new IOException("stream was reset: " + errorCode);
   }
 
   /**
@@ -200,16 +183,12 @@ public void reply(List<Header> responseHeaders, boolean out) throws IOException
     }
   }
 
-  /**
-   * Sets the maximum time to wait on input stream reads before failing with a
-   * {@code SocketTimeoutException}, or {@code 0} to wait indefinitely.
-   */
-  public void setReadTimeout(long readTimeoutMillis) {
-    this.readTimeoutMillis = readTimeoutMillis;
+  public Timeout readTimeout() {
+    return readTimeout;
   }
 
-  public long getReadTimeoutMillis() {
-    return readTimeoutMillis;
+  public Timeout writeTimeout() {
+    return writeTimeout;
   }
 
   /** Returns a source that reads data from the peer. */
@@ -288,7 +267,7 @@ void receiveHeaders(List<Header> headers, HeadersMode headersMode) {
         if (headersMode.failIfHeadersPresent()) {
           errorCode = ErrorCode.STREAM_IN_USE;
         } else {
-          List<Header> newHeaders = new ArrayList<Header>();
+          List<Header> newHeaders = new ArrayList<>();
           newHeaders.addAll(responseHeaders);
           newHeaders.addAll(headers);
           this.responseHeaders = newHeaders;
@@ -327,10 +306,6 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
     }
   }
 
-  int getPriority() {
-    return priority;
-  }
-
   /**
    * A source that reads the incoming data frames of a stream. Although this
    * class uses synchronization to safely receive incoming data frames, it is
@@ -375,7 +350,7 @@ private SpdyDataSource(long maxByteCount) {
         // Flow control: notify the peer that we're ready for more data!
         unacknowledgedBytesRead += read;
         if (unacknowledgedBytesRead
-            >= connection.peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE) / 2) {
+            >= connection.okHttpSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE) / 2) {
           connection.writeWindowUpdateLater(id, unacknowledgedBytesRead);
           unacknowledgedBytesRead = 0;
         }
@@ -385,7 +360,7 @@ private SpdyDataSource(long maxByteCount) {
       synchronized (connection) { // Multiple application threads may hit this section.
         connection.unacknowledgedBytesRead += read;
         if (connection.unacknowledgedBytesRead
-            >= connection.peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE) / 2) {
+            >= connection.okHttpSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE) / 2) {
           connection.writeWindowUpdateLater(0, connection.unacknowledgedBytesRead);
           connection.unacknowledgedBytesRead = 0;
         }
@@ -394,31 +369,15 @@ private SpdyDataSource(long maxByteCount) {
       return read;
     }
 
-    /**
-     * Returns once the input stream is either readable or finished. Throws
-     * a {@link SocketTimeoutException} if the read timeout elapses before
-     * that happens.
-     */
+    /** Returns once the source is either readable or finished. */
     private void waitUntilReadable() throws IOException {
-      long start = 0;
-      long remaining = 0;
-      if (readTimeoutMillis != 0) {
-        start = (System.nanoTime() / 1000000);
-        remaining = readTimeoutMillis;
-      }
+      readTimeout.enter();
       try {
         while (readBuffer.size() == 0 && !finished && !closed && errorCode == null) {
-          if (readTimeoutMillis == 0) {
-            SpdyStream.this.wait();
-          } else if (remaining > 0) {
-            SpdyStream.this.wait(remaining);
-            remaining = start + readTimeoutMillis - (System.nanoTime() / 1000000);
-          } else {
-            throw new SocketTimeoutException("Read timed out");
-          }
+          waitForIo();
         }
-      } catch (InterruptedException e) {
-        throw new InterruptedIOException();
+      } finally {
+        readTimeout.exitAndThrowIfTimedOut();
       }
     }
 
@@ -463,8 +422,7 @@ void receive(BufferedSource in, long byteCount) throws IOException {
     }
 
     @Override public Timeout timeout() {
-      // TODO: honor timeouts.
-      return Timeout.NONE;
+      return readTimeout;
     }
 
     @Override public void close() throws IOException {
@@ -523,12 +481,13 @@ private void cancelStreamIfNecessary() throws IOException {
       while (byteCount > 0) {
         long toWrite;
         synchronized (SpdyStream.this) {
+          writeTimeout.enter();
           try {
-            while (bytesLeftInWriteWindow <= 0) {
-              SpdyStream.this.wait(); // Wait until we receive a WINDOW_UPDATE.
+            while (bytesLeftInWriteWindow <= 0 && !finished && !closed && errorCode == null) {
+              waitForIo(); // Wait until we receive a WINDOW_UPDATE.
             }
-          } catch (InterruptedException e) {
-            throw new InterruptedIOException();
+          } finally {
+            writeTimeout.exitAndThrowIfTimedOut();
           }
 
           checkOutNotClosed(); // Kick out if the stream was reset or closed while waiting.
@@ -550,8 +509,7 @@ private void cancelStreamIfNecessary() throws IOException {
     }
 
     @Override public Timeout timeout() {
-      // TODO: honor timeouts.
-      return Timeout.NONE;
+      return writeTimeout;
     }
 
     @Override public void close() throws IOException {
@@ -588,4 +546,31 @@ private void checkOutNotClosed() throws IOException {
       throw new IOException("stream was reset: " + errorCode);
     }
   }
+
+  /**
+   * Like {@link #wait}, but throws an {@code InterruptedIOException} when
+   * interrupted instead of the more awkward {@link InterruptedException}.
+   */
+  private void waitForIo() throws InterruptedIOException {
+    try {
+      wait();
+    } catch (InterruptedException e) {
+      throw new InterruptedIOException();
+    }
+  }
+
+  /**
+   * The Okio timeout watchdog will call {@link #timedOut} if the timeout is
+   * reached. In that case we close the stream (asynchronously) which will
+   * notify the waiting thread.
+   */
+  class SpdyTimeout extends AsyncTimeout {
+    @Override protected void timedOut() {
+      closeLater(ErrorCode.CANCEL);
+    }
+
+    public void exitAndThrowIfTimedOut() throws InterruptedIOException {
+      if (exit()) throw new InterruptedIOException("timeout");
+    }
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java b/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java
index 326872a939..0438f6617b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/tls/OkHostnameVerifier.java
@@ -115,7 +115,7 @@ private boolean verifyHostName(String hostName, X509Certificate certificate) {
   }
 
   private List<String> getSubjectAltNames(X509Certificate certificate, int type) {
-    List<String> result = new ArrayList<String>();
+    List<String> result = new ArrayList<>();
     try {
       Collection<?> subjectAltNames = certificate.getSubjectAlternativeNames();
       if (subjectAltNames == null) {
diff --git a/pom.xml b/pom.xml
index 96155c9b5c..392779f27e 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
 
   <groupId>com.squareup.okhttp</groupId>
   <artifactId>parent</artifactId>
-  <version>2.0.0-SNAPSHOT</version>
+  <version>2.0.1-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>OkHttp (Parent)</name>
@@ -21,7 +21,9 @@
   <modules>
     <module>okhttp</module>
     <module>okhttp-apache</module>
+    <module>okhttp-hpacktests</module>
     <module>okhttp-tests</module>
+    <module>okhttp-urlconnection</module>
     <module>okcurl</module>
     <module>mockwebserver</module>
     <module>samples</module>
@@ -32,13 +34,13 @@
     <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
 
     <!-- Compilation -->
-    <java.version>1.6</java.version>
-    <okio.version>0.8.0</okio.version>
+    <java.version>1.7</java.version>
+    <okio.version>1.0.1</okio.version>
     <!-- Targetted to jdk7u60-b13; Oracle jdk7u55-b13. -->
     <npn.version>1.1.7.v20140316</npn.version>
     <!-- Targetted to OpenJDK 8 b132 -->
     <alpn.version>8.0.0.v20140317</alpn.version>
-    <bouncycastle.version>1.48</bouncycastle.version>
+    <bouncycastle.version>1.50</bouncycastle.version>
     <gson.version>2.2.3</gson.version>
     <apache.http.version>4.2.2</apache.http.version>
     <airlift.version>0.6</airlift.version>
@@ -216,7 +218,7 @@
         <jdk>1.7</jdk>
       </activation>
       <properties>
-        <bootclasspath>${settings.localRepository}/org/mortbay/jetty/npn/npn-boot/${npn.version}/npn-boot-${npn.version}.jar</bootclasspath>
+        <bootclasspathPrefix>${settings.localRepository}/org/mortbay/jetty/npn/npn-boot/${npn.version}/npn-boot-${npn.version}.jar</bootclasspathPrefix>
       </properties>
       <build>
         <pluginManagement>
@@ -225,7 +227,7 @@
               <groupId>org.apache.maven.plugins</groupId>
               <artifactId>maven-surefire-plugin</artifactId>
               <configuration>
-                <argLine>-Xbootclasspath/p:${bootclasspath}</argLine>
+                <argLine>-Xbootclasspath/p:${bootclasspathPrefix}</argLine>
               </configuration>
               <dependencies>
                 <dependency>
@@ -245,7 +247,7 @@
         <jdk>1.8</jdk>
       </activation>
       <properties>
-        <bootclasspath>${settings.localRepository}/org/mortbay/jetty/alpn/alpn-boot/${alpn.version}/alpn-boot-${alpn.version}.jar</bootclasspath>
+        <bootclasspathPrefix>${settings.localRepository}/org/mortbay/jetty/alpn/alpn-boot/${alpn.version}/alpn-boot-${alpn.version}.jar</bootclasspathPrefix>
       </properties>
       <build>
         <pluginManagement>
@@ -254,7 +256,7 @@
               <groupId>org.apache.maven.plugins</groupId>
               <artifactId>maven-surefire-plugin</artifactId>
               <configuration>
-                <argLine>-Xbootclasspath/p:${bootclasspath}</argLine>
+                <argLine>-Xbootclasspath/p:${bootclasspathPrefix}</argLine>
               </configuration>
               <dependencies>
                 <dependency>
diff --git a/samples/crawler/pom.xml b/samples/crawler/pom.xml
index 0015f7c1d3..0af4e32ebd 100644
--- a/samples/crawler/pom.xml
+++ b/samples/crawler/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.0.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>crawler</artifactId>
diff --git a/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java b/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java
index 42f72eeb7e..24383fe47e 100644
--- a/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java
+++ b/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java
@@ -19,7 +19,6 @@
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.http.OkHeaders;
 import java.io.File;
 import java.io.IOException;
 import java.net.MalformedURLException;
@@ -40,7 +39,7 @@
 public final class Crawler {
   private final OkHttpClient client;
   private final Set<URL> fetchedUrls = Collections.synchronizedSet(new LinkedHashSet<URL>());
-  private final LinkedBlockingQueue<URL> queue = new LinkedBlockingQueue<URL>();
+  private final LinkedBlockingQueue<URL> queue = new LinkedBlockingQueue<>();
 
   public Crawler(OkHttpClient client) {
     this.client = client;
@@ -81,7 +80,9 @@ public void fetch(URL url) throws IOException {
         .url(url)
         .build();
     Response response = client.newCall(request).execute();
-    String responseSource = response.header(OkHeaders.RESPONSE_SOURCE);
+    String responseSource = response.networkResponse() != null
+        ? ("(network: " + response.networkResponse().code() + ")")
+        : "(cache)";
     int responseCode = response.code();
 
     System.out.printf("%03d: %s %s%n", responseCode, url, responseSource);
diff --git a/samples/guide/pom.xml b/samples/guide/pom.xml
index 61e58756a1..c257c16363 100644
--- a/samples/guide/pom.xml
+++ b/samples/guide/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.0.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>guide</artifactId>
@@ -18,5 +18,9 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.gson</groupId>
+      <artifactId>gson</artifactId>
+    </dependency>
   </dependencies>
 </project>
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java b/samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java
index 25f9c86849..aa2f200e40 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java
+++ b/samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java
@@ -8,16 +8,18 @@
 public class GetExample {
   OkHttpClient client = new OkHttpClient();
 
-  void run() throws IOException {
+  String run(String url) throws IOException {
     Request request = new Request.Builder()
-        .url("https://raw.github.com/square/okhttp/master/README.md")
+        .url(url)
         .build();
 
     Response response = client.newCall(request).execute();
-    System.out.println(response.body().string());
+    return response.body().string();
   }
 
   public static void main(String[] args) throws IOException {
-    new GetExample().run();
+    GetExample example = new GetExample();
+    String response = example.run("https://raw.github.com/square/okhttp/master/README.md");
+    System.out.println(response);
   }
 }
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java b/samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java
index 313e827446..5de644c7d7 100644
--- a/samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java
+++ b/samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java
@@ -3,19 +3,24 @@
 import com.squareup.okhttp.MediaType;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
 import com.squareup.okhttp.Response;
 import java.io.IOException;
 
 public class PostExample {
-  OkHttpClient client = new OkHttpClient();
+  public static final MediaType JSON
+      = MediaType.parse("application/json; charset=utf-8");
 
-  void run() throws IOException {
-    String json = bowlingJson("Jesse", "Jake");
-    Request.Body body = Request.Body.create(MediaType.parse("application/json"), json);
-    Request request = new Request.Builder().url("http://www.roundsapp.com/post").post(body).build();
+  OkHttpClient client = new OkHttpClient();
 
+  String post(String url, String json) throws IOException {
+    RequestBody body = RequestBody.create(JSON, json);
+    Request request = new Request.Builder()
+        .url(url)
+        .post(body)
+        .build();
     Response response = client.newCall(request).execute();
-    System.out.println(response.body().string());
+    return response.body().string();
   }
 
   String bowlingJson(String player1, String player2) {
@@ -31,6 +36,9 @@ String bowlingJson(String player1, String player2) {
   }
 
   public static void main(String[] args) throws IOException {
-    new PostExample().run();
+    PostExample example = new PostExample();
+    String json = example.bowlingJson("Jesse", "Jake");
+    String response = example.post("http://www.roundsapp.com/post", json);
+    System.out.println(response);
   }
 }
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/AccessHeaders.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/AccessHeaders.java
new file mode 100644
index 0000000000..9fe9d1ab67
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/AccessHeaders.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+
+public final class AccessHeaders {
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://api.github.com/repos/square/okhttp/issues")
+        .header("User-Agent", "OkHttp Headers.java")
+        .addHeader("Accept", "application/json; q=0.5")
+        .addHeader("Accept", "application/vnd.github.v3+json")
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println("Server: " + response.header("Server"));
+    System.out.println("Date: " + response.header("Date"));
+    System.out.println("Vary: " + response.headers("Vary"));
+  }
+
+  public static void main(String... args) throws Exception {
+    new AccessHeaders().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/AsynchronousGet.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/AsynchronousGet.java
new file mode 100644
index 0000000000..1667c59ee2
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/AsynchronousGet.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.Callback;
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+
+public final class AsynchronousGet {
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://publicobject.com/helloworld.txt")
+        .build();
+
+    client.newCall(request).enqueue(new Callback() {
+      @Override public void onFailure(Request request, IOException e) {
+        e.printStackTrace();
+      }
+
+      @Override public void onResponse(Response response) throws IOException {
+        if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+        Headers responseHeaders = response.headers();
+        for (int i = 0; i < responseHeaders.size(); i++) {
+          System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+        }
+
+        System.out.println(response.body().string());
+      }
+    });
+  }
+
+  public static void main(String... args) throws Exception {
+    new AsynchronousGet().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/Authenticate.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/Authenticate.java
new file mode 100644
index 0000000000..44581aed33
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/Authenticate.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.Authenticator;
+import com.squareup.okhttp.Credentials;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import java.net.Proxy;
+
+public final class Authenticate {
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    client.setAuthenticator(new Authenticator() {
+      @Override public Request authenticate(Proxy proxy, Response response) {
+        System.out.println("Authenticating for response: " + response);
+        System.out.println("Challenges: " + response.challenges());
+        String credential = Credentials.basic("jesse", "password1");
+        return response.request().newBuilder()
+            .header("Authorization", credential)
+            .build();
+      }
+
+      @Override public Request authenticateProxy(Proxy proxy, Response response) {
+        return null; // Null indicates no attempt to authenticate.
+      }
+    });
+
+    Request request = new Request.Builder()
+        .url("http://publicobject.com/secrets/hellosecret.txt")
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println(response.body().string());
+  }
+
+  public static void main(String... args) throws Exception {
+    new Authenticate().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CacheResponse.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/CacheResponse.java
new file mode 100644
index 0000000000..3335ebe668
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/CacheResponse.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.Cache;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.File;
+import java.io.IOException;
+
+public final class CacheResponse {
+  private final OkHttpClient client;
+
+  public CacheResponse(File cacheDirectory) throws Exception {
+    int cacheSize = 10 * 1024 * 1024; // 10 MiB
+    Cache cache = new Cache(cacheDirectory, cacheSize);
+
+    client = new OkHttpClient();
+    client.setCache(cache);
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://publicobject.com/helloworld.txt")
+        .build();
+
+    Response response1 = client.newCall(request).execute();
+    if (!response1.isSuccessful()) throw new IOException("Unexpected code " + response1);
+
+    String response1Body = response1.body().string();
+    System.out.println("Response 1 response:          " + response1);
+    System.out.println("Response 1 cache response:    " + response1.cacheResponse());
+    System.out.println("Response 1 network response:  " + response1.networkResponse());
+
+    Response response2 = client.newCall(request).execute();
+    if (!response2.isSuccessful()) throw new IOException("Unexpected code " + response2);
+
+    String response2Body = response2.body().string();
+    System.out.println("Response 2 response:          " + response2);
+    System.out.println("Response 2 cache response:    " + response2.cacheResponse());
+    System.out.println("Response 2 network response:  " + response2.networkResponse());
+
+    System.out.println("Response 2 equals Response 1? " + response1Body.equals(response2Body));
+  }
+
+  public static void main(String... args) throws Exception {
+    new CacheResponse(new File("CacheResponse.tmp")).run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/CancelCall.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/CancelCall.java
new file mode 100644
index 0000000000..9f8d37305c
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/CancelCall.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.Call;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+
+public class CancelCall {
+  private final ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
+        .build();
+
+    final long startNanos = System.nanoTime();
+    final Call call = client.newCall(request);
+
+    // Schedule a job to cancel the call in 1 second.
+    executor.schedule(new Runnable() {
+      @Override public void run() {
+        System.out.printf("%.2f Canceling call.%n", (System.nanoTime() - startNanos) / 1e9f);
+        call.cancel();
+        System.out.printf("%.2f Canceled call.%n", (System.nanoTime() - startNanos) / 1e9f);
+      }
+    }, 1, TimeUnit.SECONDS);
+
+    try {
+      System.out.printf("%.2f Executing call.%n", (System.nanoTime() - startNanos) / 1e9f);
+      Response response = call.execute();
+      System.out.printf("%.2f Call was expected to fail, but completed: %s%n",
+          (System.nanoTime() - startNanos) / 1e9f, response);
+    } catch (IOException e) {
+      System.out.printf("%.2f Call failed as expected: %s%n",
+          (System.nanoTime() - startNanos) / 1e9f, e);
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new CancelCall().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/ConfigureTimeouts.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/ConfigureTimeouts.java
new file mode 100644
index 0000000000..f358a4564f
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/ConfigureTimeouts.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.util.concurrent.TimeUnit;
+
+public final class ConfigureTimeouts {
+  private final OkHttpClient client;
+
+  public ConfigureTimeouts() throws Exception {
+    client = new OkHttpClient();
+    client.setConnectTimeout(10, TimeUnit.SECONDS);
+    client.setWriteTimeout(10, TimeUnit.SECONDS);
+    client.setReadTimeout(30, TimeUnit.SECONDS);
+  }
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://httpbin.org/delay/2") // This URL is served with a 2 second delay.
+        .build();
+
+    Response response = client.newCall(request).execute();
+    System.out.println("Response completed: " + response);
+  }
+
+  public static void main(String... args) throws Exception {
+    new ConfigureTimeouts().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/ParseResponseWithGson.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/ParseResponseWithGson.java
new file mode 100644
index 0000000000..cf63f0d4b1
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/ParseResponseWithGson.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.google.gson.Gson;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import java.util.Map;
+
+public final class ParseResponseWithGson {
+  private final OkHttpClient client = new OkHttpClient();
+  private final Gson gson = new Gson();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://api.github.com/gists/c2a7c39532239ff261be")
+        .build();
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    Gist gist = gson.fromJson(response.body().charStream(), Gist.class);
+    for (Map.Entry<String, GistFile> entry : gist.files.entrySet()) {
+      System.out.println(entry.getKey());
+      System.out.println(entry.getValue().content);
+    }
+  }
+
+  static class Gist {
+    Map<String, GistFile> files;
+  }
+
+  static class GistFile {
+    String content;
+  }
+
+  public static void main(String... args) throws Exception {
+    new ParseResponseWithGson().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PerCallSettings.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PerCallSettings.java
new file mode 100644
index 0000000000..af4956e17f
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PerCallSettings.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+
+public final class PerCallSettings {
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://httpbin.org/delay/1") // This URL is served with a 1 second delay.
+        .build();
+
+    try {
+      OkHttpClient cloned = client.clone(); // Clone to make a customized OkHttp for this request.
+      cloned.setReadTimeout(500, TimeUnit.MILLISECONDS);
+
+      Response response = cloned.newCall(request).execute();
+      System.out.println("Response 1 succeeded: " + response);
+    } catch (IOException e) {
+      System.out.println("Response 1 failed: " + e);
+    }
+
+    try {
+      OkHttpClient cloned = client.clone(); // Clone to make a customized OkHttp for this request.
+      cloned.setReadTimeout(3000, TimeUnit.MILLISECONDS);
+
+      Response response = cloned.newCall(request).execute();
+      System.out.println("Response 2 succeeded: " + response);
+    } catch (IOException e) {
+      System.out.println("Response 2 failed: " + e);
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new PerCallSettings().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostFile.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostFile.java
new file mode 100644
index 0000000000..a0d98df45f
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostFile.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
+import java.io.File;
+import java.io.IOException;
+
+public final class PostFile {
+  public static final MediaType MEDIA_TYPE_MARKDOWN
+      = MediaType.parse("text/x-markdown; charset=utf-8");
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    File file = new File("README.md");
+
+    Request request = new Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, file))
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println(response.body().string());
+  }
+
+  public static void main(String... args) throws Exception {
+    new PostFile().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostForm.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostForm.java
new file mode 100644
index 0000000000..30054f1905
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostForm.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.FormEncodingBuilder;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+
+public final class PostForm {
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    RequestBody formBody = new FormEncodingBuilder()
+        .add("search", "Jurassic Park")
+        .build();
+    Request request = new Request.Builder()
+        .url("https://en.wikipedia.org/w/index.php")
+        .post(formBody)
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println(response.body().string());
+  }
+
+  public static void main(String... args) throws Exception {
+    new PostForm().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostMultipart.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostMultipart.java
new file mode 100644
index 0000000000..8e5334aa39
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostMultipart.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.MultipartBuilder;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
+import java.io.File;
+import java.io.IOException;
+
+public final class PostMultipart {
+  /**
+   * The imgur client ID for OkHttp recipes. If you're using imgur for anything
+   * other than running these examples, please request your own client ID!
+   *   https://api.imgur.com/oauth2
+   */
+  private static final String IMGUR_CLIENT_ID = "9199fdef135c122";
+  private static final MediaType MEDIA_TYPE_PNG = MediaType.parse("image/png");
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image
+    RequestBody requestBody = new MultipartBuilder()
+        .type(MultipartBuilder.FORM)
+        .addFormDataPart("title", "Square Logo")
+        .addFormDataPart("image", null,
+            RequestBody.create(MEDIA_TYPE_PNG, new File("website/static/logo-square.png")))
+        .build();
+
+    Request request = new Request.Builder()
+        .header("Authorization", "Client-ID " + IMGUR_CLIENT_ID)
+        .url("https://api.imgur.com/3/image")
+        .post(requestBody)
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println(response.body().string());
+  }
+
+  public static void main(String... args) throws Exception {
+    new PostMultipart().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostStreaming.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostStreaming.java
new file mode 100644
index 0000000000..500344c7e9
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostStreaming.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+import okio.BufferedSink;
+
+public final class PostStreaming {
+  public static final MediaType MEDIA_TYPE_MARKDOWN
+      = MediaType.parse("text/x-markdown; charset=utf-8");
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    RequestBody requestBody = new RequestBody() {
+      @Override public MediaType contentType() {
+        return MEDIA_TYPE_MARKDOWN;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.writeUtf8("Numbers\n");
+        sink.writeUtf8("-------\n");
+        for (int i = 2; i <= 997; i++) {
+          sink.writeUtf8(String.format(" * %s = %s\n", i, factor(i)));
+        }
+      }
+
+      private String factor(int n) {
+        for (int i = 2; i < n; i++) {
+          int x = n / i;
+          if (x * i == n) return factor(x) + "  " + i;
+        }
+        return Integer.toString(n);
+      }
+    };
+
+    Request request = new Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(requestBody)
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println(response.body().string());
+  }
+
+  public static void main(String... args) throws Exception {
+    new PostStreaming().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostString.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostString.java
new file mode 100644
index 0000000000..943636abb5
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/PostString.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.RequestBody;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+
+public final class PostString {
+  public static final MediaType MEDIA_TYPE_MARKDOWN
+      = MediaType.parse("text/x-markdown; charset=utf-8");
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    String postBody = ""
+        + "Releases\n"
+        + "--------\n"
+        + "\n"
+        + " * _1.0_ May 6, 2013\n"
+        + " * _1.1_ June 15, 2013\n"
+        + " * _1.2_ August 11, 2013\n";
+
+    Request request = new Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(RequestBody.create(MEDIA_TYPE_MARKDOWN, postBody))
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    System.out.println(response.body().string());
+  }
+
+  public static void main(String... args) throws Exception {
+    new PostString().run();
+  }
+}
diff --git a/samples/guide/src/main/java/com/squareup/okhttp/recipes/SynchronousGet.java b/samples/guide/src/main/java/com/squareup/okhttp/recipes/SynchronousGet.java
new file mode 100644
index 0000000000..3c1ad20842
--- /dev/null
+++ b/samples/guide/src/main/java/com/squareup/okhttp/recipes/SynchronousGet.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.recipes;
+
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import java.io.IOException;
+
+public final class SynchronousGet {
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("http://publicobject.com/helloworld.txt")
+        .build();
+
+    Response response = client.newCall(request).execute();
+    if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+    Headers responseHeaders = response.headers();
+    for (int i = 0; i < responseHeaders.size(); i++) {
+      System.out.println(responseHeaders.name(i) + ": " + responseHeaders.value(i));
+    }
+
+    System.out.println(response.body().string());
+  }
+
+  public static void main(String... args) throws Exception {
+    new SynchronousGet().run();
+  }
+}
diff --git a/samples/pom.xml b/samples/pom.xml
index 62d1240d7e..7a41400d90 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp</groupId>
     <artifactId>parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.0.1-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.okhttp.sample</groupId>
diff --git a/samples/simple-client/pom.xml b/samples/simple-client/pom.xml
index 93657e2f2f..484f9d2642 100644
--- a/samples/simple-client/pom.xml
+++ b/samples/simple-client/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.0.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple-client</artifactId>
diff --git a/samples/static-server/pom.xml b/samples/static-server/pom.xml
index 70188c725c..b9f3db6f2b 100644
--- a/samples/static-server/pom.xml
+++ b/samples/static-server/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>2.0.0-SNAPSHOT</version>
+    <version>2.0.1-SNAPSHOT</version>
   </parent>
 
   <artifactId>static-server</artifactId>
diff --git a/website/index.html b/website/index.html
index e9ccd189b4..fcb9ad72f9 100644
--- a/website/index.html
+++ b/website/index.html
@@ -43,7 +43,7 @@ <h2>An <strong>HTTP &amp; SPDY</strong> client for Android and Java applications
         <div class="row">
           <div class="span9">
             <h3 id="overview">Overview</h3>
-            <p>HTTP is the way modern applications network. Its how we exchange data & media.
+            <p>HTTP is the way modern applications network. Its how we exchange data &amp; media.
                 Doing HTTP efficiently makes your stuff load faster and saves bandwidth.</p>
 
             <p>OkHttp is an HTTP client thats efficient by default:</p>
@@ -61,75 +61,58 @@ <h3 id="overview">Overview</h3>
                 with modern TLS features (SNI, ALPN), and falls back to SSLv3 if the handshake
                 fails.</p>
 
-            <p>You can try OkHttp without rewriting your network code. The core module implements
-                the familiar <code>java.net.HttpURLConnection</code> API. And the optional
-                okhttp-apache module implements the Apache <code>HttpClient</code> API.</p>
+            <p>Using OkHttp is easy. Its 2.0 API is designed with fluent builders and
+                immutability. It supports both synchronous blocking calls and async calls with
+                callbacks.</p>
 
-            <p>OkHttp supports Android 2.2 and above. For Java, the minimum requirement is 1.5.</p>
+            <p>You can try out OkHttp without rewriting your network code. The
+                <code>okhttp-urlconnection</code> module implements the familiar
+                <code>java.net.HttpURLConnection</code> API and the <code>okhttp-apache</code>
+                module implements the Apache <code>HttpClient</code> API.</p>
+
+            <p>OkHttp supports Android 2.3 and above. For Java, the minimum requirement is 1.7.</p>
 
             <h3 id="examples">Examples</h3>
             <h4>Get a URL</h4>
             <p>This program downloads a URL and print its contents as a string. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/com/squareup/okhttp/guide/GetExample.java">Full source</a>.
 <pre class="prettyprint">
-    OkHttpClient client = new OkHttpClient();
-
-    String get(URL url) throws IOException {
-      HttpURLConnection connection = client.open(url);
-      InputStream in = null;
-      try {
-        // Read the response.
-        in = connection.getInputStream();
-        byte[] response = readFully(in);
-        return new String(response, "UTF-8");
-      } finally {
-        if (in != null) in.close();
-      }
-    }
+OkHttpClient client = new OkHttpClient();
+
+String run(String url) throws IOException {
+  Request request = new Request.Builder()
+      .url(url)
+      .build();
+
+  Response response = client.newCall(request).execute();
+  return response.body().string();
+}
 </pre>
             <h4>Post to a Server</h4>
             <p>This program posts data to a service. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/com/squareup/okhttp/guide/PostExample.java">Full source</a>.
 
 <pre class="prettyprint">
-    OkHttpClient client = new OkHttpClient();
-
-    String post(URL url, byte[] body) throws IOException {
-      HttpURLConnection connection = client.open(url);
-      OutputStream out = null;
-      InputStream in = null;
-      try {
-        // Write the request.
-        connection.setRequestMethod("POST");
-        out = connection.getOutputStream();
-        out.write(body);
-        out.close();
-
-        // Read the response.
-        if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) {
-          throw new IOException("Unexpected HTTP response: "
-              + connection.getResponseCode() + " " + connection.getResponseMessage());
-        }
-        in = connection.getInputStream();
-        return readFirstLine(in);
-      } finally {
-        // Clean up.
-        if (out != null) out.close();
-        if (in != null) in.close();
-      }
-    }
+public static final MediaType JSON
+    = MediaType.parse("application/json; charset=utf-8");
+
+OkHttpClient client = new OkHttpClient();
+
+String post(String url, String json) throws IOException {
+  RequestBody body = RequestBody.create(JSON, json);
+  Request request = new Request.Builder()
+      .url(url)
+      .post(body)
+      .build();
+  Response response = client.newCall(request).execute();
+  return response.body().string();
+}
 </pre>
 
-                <!--
-                TODO
-                Error Handling
-                Authentication
-                Cookies
-                Response Caching
-                Captive Gateways
-                -->
-
             <h3 id="download">Download</h3>
             <p><a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.okhttp&a=okhttp&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
-            <p>The source code to the OkHttp, its samples, and this website is <a href="http://github.com/square/okhttp">available on GitHub</a>.</p>
+            <p>You'll also need <a href="http://github.com/square/okio">Okio</a>, which OkHttp
+                uses for fast I/O and resizable buffers. Download the
+                <a href="http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.okio&a=okio&v=LATEST">latest JAR</a>.
+            <p>The source code to OkHttp, its samples, and this website is <a href="http://github.com/square/okhttp">available on GitHub</a>.</p>
 
             <h4>Maven</h4>
             <pre class="prettyprint">&lt;dependency>
@@ -144,7 +127,7 @@ <h3 id="contributing">Contributing</h3>
             <p>Before your code can be accepted into the project you must also sign the <a href="http://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
 
             <h3 id="license">License</h3>
-            <pre>Copyright 2013 Square, Inc.
+            <pre>Copyright 2014 Square, Inc.
 
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
@@ -168,6 +151,7 @@ <h3 id="license">License</h3>
                 <li><a href="#license">License</a></li>
               </ul>
               <ul class="nav nav-pills nav-stacked secondary">
+                <li><a href="https://github.com/square/okhttp/wiki">Wiki</a></li>
                 <li><a href="javadoc/index.html">Javadoc</a></li>
                 <li><a href="http://stackoverflow.com/questions/tagged/okhttp?sort=active">StackOverflow</a></li>
               </ul>
