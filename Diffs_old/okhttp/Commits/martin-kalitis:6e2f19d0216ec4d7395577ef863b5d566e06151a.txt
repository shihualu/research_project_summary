diff --git a/.buildscript/deploy_snapshot.sh b/.buildscript/deploy_snapshot.sh
index 4e141cad64..d9a8e909da 100755
--- a/.buildscript/deploy_snapshot.sh
+++ b/.buildscript/deploy_snapshot.sh
@@ -3,7 +3,7 @@
 # Deploy a jar, source jar, and javadoc jar to Sonatype's snapshot repo.
 #
 # Adapted from https://coderwall.com/p/9b_lfq and
-# http://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/
+# https://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/
 
 SLUG="square/okhttp"
 JDK="oraclejdk8"
@@ -21,6 +21,6 @@ elif [ "$TRAVIS_BRANCH" != "$BRANCH" ]; then
   echo "Skipping snapshot deployment: wrong branch. Expected '$BRANCH' but was '$TRAVIS_BRANCH'."
 else
   echo "Deploying snapshot..."
-  mvn clean source:jar javadoc:jar deploy --settings=".buildscript/settings.xml" -Dmaven.test.skip=true
+  mvn clean source:jar javadoc:jar deploy --settings=".buildscript/settings.xml" -DskipTests
   echo "Snapshot deployed!"
 fi
diff --git a/.travis.yml b/.travis.yml
index 1835d337fb..1ebb5eb306 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,8 +1,15 @@
 language: java
 
 jdk:
-  - oraclejdk7
   - oraclejdk8
+#  - openjdk11
+
+addons:
+  apt:
+    packages:
+      - oracle-java8-installer # Updates JDK 8 to the latest available.
+
+script: mvn test javadoc:jar source:jar -B
 
 after_success:
   - .buildscript/deploy_snapshot.sh
@@ -24,8 +31,3 @@ sudo: false
 cache:
   directories:
     - $HOME/.m2
-
-addons:
-  apt:
-    packages:
-      - oracle-java8-installer
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 0165564107..c10297c598 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,6 +1,350 @@
 Change Log
 ==========
 
+## Version 3.11.0
+
+_2018-07-12_
+
+ *  **OkHttp's new okhttp-tls submodule tames HTTPS and TLS.**
+
+    `HeldCertificate` is a TLS certificate and its private key. Generate a certificate with its
+    builder then use it to sign another certificate or perform a TLS handshake. The
+    `certificatePem()` method encodes the certificate in the familiar PEM format
+    (`--- BEGIN CERTIFICATE ---`); the `privateKeyPkcs8Pem()` does likewise for the private key.
+
+    `HandshakeCertificates` holds the TLS certificates required for a TLS handshake. On the server
+    it keeps your `HeldCertificate` and its chain. On the client it keeps the root certificates
+    that are trusted to sign a server's certificate chain. `HandshakeCertificates` also works with
+    mutual TLS where these roles are reversed.
+
+    These classes make it possible to enable HTTPS in MockWebServer in [just a few lines of
+    code][https_server_sample].
+
+ *  **OkHttp now supports prior knowledge cleartext HTTP/2.** Enable this by setting
+    `Protocol.H2_PRIOR_KNOWLEDGE` as the lone protocol on an `OkHttpClient.Builder`. This mode
+    only supports `http:` URLs and is best suited in closed environments where HTTPS is
+    inappropriate.
+
+ *  New: `HttpUrl.get(String)` is an alternative to `HttpUrl.parse(String)` that throws an exception
+    when the URL is malformed instead of returning null. Use this to avoid checking for null in
+    situations where the input is known to be well-formed. We've also added `MediaType.get(String)`
+    which is an exception-throwing alternative to `MediaType.parse(String)`.
+ *  New: The `EventListener` API previewed in OkHttp 3.9 has graduated to a stable API. Use this
+    interface to track metrics and monitor HTTP requests' size and duration.
+ *  New: `okhttp-dnsoverhttps` is an experimental API for doing DNS queries over HTTPS. Using HTTPS
+    for DNS offers better security and potentially better performance. This feature is a preview:
+    the API is subject to change.
+ *  New: `okhttp-sse` is an early preview of Server-Sent Events (SSE). This feature is incomplete
+    and is only suitable for experimental use.
+ *  New: MockWebServer now supports client authentication (mutual TLS). Call `requestClientAuth()`
+    to permit an optional client certificate or `requireClientAuth()` to require one.
+ *  New: `RecordedRequest.getHandshake()` returns the HTTPS handshake of a request sent to
+    `MockWebServer`.
+ *  Fix: Honor the `MockResponse` header delay in MockWebServer.
+ *  Fix: Don't release HTTP/2 connections that have multiple canceled calls. We had a bug where
+    canceling calls would cause the shared HTTP/2 connection to be unnecessarily released. This
+    harmed connection reuse.
+ *  Fix: Ensure canceled and discarded HTTP/2 data is not permanently counted against the limited
+    flow control window. We had a few bugs where window size accounting was broken when streams
+    were canceled or reset.
+ *  Fix: Recover gracefully if the TLS session returns an unexpected version (`NONE`) or cipher
+    suite (`SSL_NULL_WITH_NULL_NULL`).
+ *  Fix: Don't change Conscrypt configuration globally. We migrated from a process-wide setting to
+    configuring only OkHttp's TLS sockets.
+ *  Fix: Prefer TLSv1.2 where it is available. On certain older platforms it is necessary to opt-in
+    to TLSv1.2.
+ *  New: `Request.tag()` permits multiple tags. Use a `Class<?>` as a key to identify tags. Note
+    that `tag()` now returns null if the request has no tag. Previously this would return the
+    request itself.
+ *  New: `Headers.Builder.addAll(Headers)`.
+ *  New: `ResponseBody.create(MediaType, ByteString)`.
+ *  New: Embed R8/ProGuard rules in the jar. These will be applied automatically by R8.
+ *  Fix: Release the connection if `Authenticator` throws an exception.
+ *  Fix: Change the declaration of `OkHttpClient.cache()` to return a `@Nullable Cache`. The return
+    value has always been nullable but it wasn't declared properly.
+ *  Fix: Reverse suppression of connect exceptions. When both a call and its retry fail, we now
+    throw the initial exception which is most likely to be actionable.
+ *  Fix: Retain interrupted state when throwing `InterruptedIOException`. A single interrupt should
+    now be sufficient to break out an in-flight OkHttp call.
+ *  Fix: Don't drop a call to `EventListener.callEnd()` when the response body is consumed inside an
+    interceptor.
+
+
+## Version 3.10.0
+
+_2018-02-24_
+
+ *  **The pingInterval() feature now aggressively checks connectivity for web
+    sockets and HTTP/2 connections.**
+
+    Previously if you configured a ping interval that would cause OkHttp to send
+    pings, but it did not track whether the reply pongs were received. With this
+    update OkHttp requires that every ping receive a response: if it does not
+    the connection will be closed and the listener's `onFailure()` method will
+    be called.
+
+    Web sockets have always been had pings, but pings on HTTP/2 connections is
+    new in this release. Pings are used for connections that are busy carrying
+    calls and for idle connections in the connection pool. (Pings do not impact
+    when pooled connections are evicted).
+
+    If you have a configured ping interval, you should confirm that it is long
+    enough for a roundtrip from client to server. If your ping interval is too
+    short, slow connections may be misinterpreted as failed connections. A ping
+    interval of 30 seconds is reasonable for most use cases.
+
+ *  **OkHttp now supports [Conscrypt][conscrypt].** Conscrypt is a Java Security
+    Provider that integrates BoringSSL into the Java platform. Conscrypt
+    supports more cipher suites than the JVMâ€™s default provider and may also
+    execute more efficiently.
+
+    To use it, first register a [Conscrypt dependency][conscrypt_dependency] in
+    your build system.
+
+    OkHttp will use Conscrypt if you set the `okhttp.platform` system property
+    to `conscrypt`.
+
+    Alternatively, OkHttp will also use Conscrypt if you install it as your
+    preferred security provider. To do so, add the following code to execute
+    before you create your `OkHttpClient`.
+
+    ```
+    Security.insertProviderAt(
+        new org.conscrypt.OpenSSLProvider(), 1);
+    ```
+
+    Conscrypt is the bundled security provider on Android so it is not necessary
+    to configure it on that platform.
+
+ *  New: `HttpUrl.addQueryParameter()` percent-escapes more characters.
+    Previously several ASCII punctuation characters were not percent-escaped
+    when used with this method. This does not impact already-encoded query
+    parameters in APIs like `HttpUrl.parse()` and
+    `HttpUrl.Builder.addEncodedQueryParameter()`.
+ *  New: CBC-mode ECDSA cipher suites have been removed from OkHttp's default
+    configuration: `TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA` and
+    `TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA`. This tracks a [Chromium
+    change][remove_cbc_ecdsa] to remove these cipher suites because they are
+    fragile and rarely-used.
+ *  New: Don't fall back to common name (CN) verification for hostnames. This
+    behavior was deprecated with RFC 2818 in May 2000 and was recently dropped
+    from major web browsers.
+ *  New: Honor the `Retry-After` response header. HTTP 503 (Unavailable)
+    responses are retried automatically if this header is present and its delay
+    is 0 seconds. HTTP 408 (Client Timeout) responses are retried automatically
+    if the header is absent or its delay is 0 seconds.
+ *  New: Allow request bodies for all HTTP methods except GET and HEAD.
+ *  New: Automatic module name of `okhttp3` for use with the Java Platform
+    Module System.
+ *  New: Log gzipped bodies when `HttpLoggingInterceptor` is used as a network
+    interceptor.
+ *  New: `Protocol.QUIC` constant. This protocol is not supported but this
+    constant is included for completeness.
+ *  New: Upgrade to Okio 1.14.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.14.0</version>
+     </dependency>
+
+     com.squareup.okio:okio:1.14.0
+     ```
+
+ *  Fix: Handle `HTTP/1.1 100 Continue` status lines, even on requests that did
+    not send the `Expect: continue` request header.
+ *  Fix: Do not count web sockets toward the dispatcher's per-host connection
+    limit.
+ *  Fix: Avoid using invalid HTTPS sessions. This prevents OkHttp from crashing
+    with the error, `Unexpected TLS version: NONE`.
+ *  Fix: Don't corrupt the response cache when a 304 (Not Modified) response
+    overrides the stored "Content-Encoding" header.
+ *  Fix: Gracefully shut down the HTTP/2 connection before it exhausts the
+    namespace of stream IDs (~536 million streams).
+ *  Fix: Never pass a null `Route` to `Authenticator`. There was a bug where
+    routes were omitted for eagerly-closed connections.
+
+## Version 3.9.1
+
+_2017-11-18_
+
+ *  New: Recover gracefully when Android's DNS crashes with an unexpected
+    `NullPointerException`.
+ *  New: Recover gracefully when Android's socket connections crash with an
+    unexpected `ClassCastException`.
+ *  Fix: Don't include the URL's fragment in `encodedQuery()` when the query
+    itself is empty.
+
+## Version 3.9.0
+
+_2017-09-03_
+
+ *  **Interceptors are more capable.** The `Chain` interface now offers access
+    to the call and can adjust all call timeouts. Note that this change is
+    source-incompatible for code that implements the `Chain` interface.
+    We don't expect this to be a problem in practice!
+
+ *  **OkHttp has an experimental new API for tracking metrics.** The new
+    `EventListener` API is designed to help developers monitor HTTP requests'
+    size and duration. This feature is an unstable preview: the API is subject
+    to change, and the implementation is incomplete. This is a big new API we
+    are eager for feedback.
+
+ *  New: Support ALPN via Google Play Services' Dynamic Security Provider. This
+    expands HTTP/2 support to older Android devices that have Google Play
+    Services.
+ *  New: Consider all routes when looking for candidate coalesced connections.
+    This increases the likelihood that HTTP/2 connections will be shared.
+ *  New: Authentication challenges and credentials now use a charset. Use this in
+    your authenticator to support user names and passwords with non-ASCII
+    characters.
+ *  New: Accept a charset in `FormBody.Builder`. Previously form bodies were
+    always UTF-8.
+ *  New: Support the `immutable` cache-control directive.
+ *  Fix: Don't crash when an HTTP/2 call is redirected while the connection is
+    being shut down.
+ *  Fix: Don't drop headers of healthy streams that raced with `GOAWAY` frames.
+    This bug would cause HTTP/2 streams to occasional hang when the connection
+    was shutting down.
+ *  Fix: Honor `OkHttpClient.retryOnConnectionFailure()` when the response is a
+    HTTP 408 Request Timeout. If retries are enabled, OkHttp will retry exactly
+    once in response to a 408.
+ *  Fix: Don't crash when reading the empty `HEAD` response body if it specifies
+    a `Content-Length`.
+ *  Fix: Don't crash if the thread is interrupted while reading the public
+    suffix database.
+ *  Fix: Use relative resource path when loading the public suffix database.
+    Loading the resource using a path relative to the class prevents conflicts
+    when the OkHttp classes are relocated (shaded) by allowing multiple private
+    copies of the database.
+ *  Fix: Accept cookies for URLs that have an IPv6 address for a host.
+ *  Fix: Don't log the protocol (HTTP/1.1, h2) in HttpLoggingInterceptor if the
+    protocol isn't negotiated yet! Previously we'd log HTTP/1.1 by default, and
+    this was confusing.
+ *  Fix: Omit the message from MockWebServer's HTTP/2 `:status` header.
+ *  Fix: Handle 'Expect: 100 Continue' properly in MockWebServer.
+
+
+## Version 3.8.1
+
+_2017-06-18_
+
+ *  Fix: Recover gracefully from stale coalesced connections. We had a bug where
+    connection coalescing (introduced in OkHttp 3.7.0) and stale connection
+    recovery could interact to cause a `NoSuchElementException` crash in the
+    `RouteSelector`.
+
+
+## Version 3.8.0
+
+_2017-05-13_
+
+
+ *  **OkHttp now uses `@Nullable` to annotate all possibly-null values.** We've
+    added a compile-time dependency on the JSR 305 annotations. This is a
+    [provided][maven_provided] dependency and does not need to be included in
+    your build configuration, `.jar` file, or `.apk`. We use
+    `@ParametersAreNonnullByDefault` and all parameters and return types are
+    never null unless explicitly annotated `@Nullable`.
+
+ *  **Warning: this release is source-incompatible for Kotlin users.**
+    Nullability was previously ambiguous and lenient but now the compiler will
+    enforce strict null checks.
+
+ *  New: The response message is now non-null. This is the "Not Found" in the
+    status line "HTTP 404 Not Found". If you are building responses
+    programmatically (with `new Response.Builder()`) you must now always supply
+    a message. An empty string `""` is permitted. This value was never null on
+    responses returned by OkHttp itself, and it was an old mistake to permit
+    application code to omit a message.
+
+ *  The challenge's scheme and realm are now non-null. If you are calling
+    `new Challenge(scheme, realm)` you must provide non-null values. These were
+    never null in challenges created by OkHttp, but could have been null in
+    application code that creates challenges.
+
+ *  New: The `TlsVersion` of a `Handshake` is now non-null. If you are calling
+    `Handshake.get()` with a null TLS version, you must instead now provide a
+    non-null `TlsVersion`. Cache responses persisted prior to OkHttp 3.0 did not
+    store a TLS version; for these unknown values the handshake is defaulted to
+    `TlsVersion.SSL_3_0`.
+
+ *  New: Upgrade to Okio 1.13.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.13.0</version>
+     </dependency>
+
+     com.squareup.okio:okio:1.13.0
+     ```
+
+ *  Fix: gracefully recover when Android 7.0's sockets throw an unexpected
+    `NullPointerException`.
+
+## Version 3.7.0
+
+_2017-04-15_
+
+ *  **OkHttp no longer recovers from TLS handshake failures by attempting a TLSv1 connection.**
+    The fallback was necessary for servers that implemented version negotiation incorrectly. Now
+    that 99.99% of servers do it right this fallback is obsolete.
+ *  Fix: Do not honor cookies set on a public domain. Previously a malicious site could inject
+    cookies on top-level domains like `co.uk` because our cookie parser didn't honor the [public
+    suffix][public_suffix] list. Alongside this fix is a new API, `HttpUrl.topPrivateDomain()`,
+    which returns the privately domain name if the URL has one.
+ *  Fix: Change `MediaType.charset()` to return null for unexpected charsets.
+ *  Fix: Don't skip cache invalidation if the invalidating response has no body.
+ *  Fix: Don't use a cryptographic random number generator for web sockets. Some Android devices
+    implement `SecureRandom` incorrectly!
+ *  Fix: Correctly canonicalize IPv6 addresses in `HttpUrl`. This prevented OkHttp from trusting
+    HTTPS certificates issued to certain IPv6 addresses.
+ *  Fix: Don't reuse connections after an unsuccessful `Expect: 100-continue`.
+ *  Fix: Handle either `TLS_` or `SSL_` prefixes for cipher suite names. This is necessary for
+    IBM JVMs that use the `SSL_` prefix exclusively.
+ *  Fix: Reject HTTP/2 data frames if the stream ID is 0.
+ *  New: Upgrade to Okio 1.12.0.
+
+     ```xml
+     <dependency>
+       <groupId>com.squareup.okio</groupId>
+       <artifactId>okio</artifactId>
+       <version>1.12.0</version>
+     </dependency>
+
+     com.squareup.okio:okio:1.12.0
+     ```
+
+ *  New: Connection coalescing. OkHttp may reuse HTTP/2 connections across calls that share an IP
+    address and HTTPS certificate, even if their domain names are different.
+ *  New: MockWebServer's `RecordedRequest` exposes the requested `HttpUrl` with `getRequestUrl()`.
+
+
+## Version 3.6.0
+
+_2017-01-29_
+
+ *  Fix: Don't crash with a "cache is closed" error when there is an error initializing the cache.
+ *  Fix: Calling `disconnect()` on a connecting `HttpUrlConnection` could cause it to retry in an
+    infinite loop! This regression was introduced in OkHttp 2.7.0.
+ *  Fix: Drop cookies that contain ASCII NULL and other bad characters. Previously such cookies
+    would cause OkHttp to crash when they were included in a request.
+ *  Fix: Release duplicated multiplexed connections. If we concurrently establish connections to an
+    HTTP/2 server, close all but the first connection.
+ *  Fix: Fail the HTTP/2 connection if first frame isn't `SETTINGS`.
+ *  Fix: Forbid spaces in header names.
+ *  Fix: Don't offer to do gzip if the request is partial.
+ *  Fix: MockWebServer is now usable with JUnit 5. That update [broke the rules][junit_5_rules].
+ *  New: Support `Expect: 100-continue` as a request header. Callers can use this header to
+    pessimistically hold off on transmitting a request body until a server gives the go-ahead.
+ *  New: Permit network interceptors to rewrite the host header for HTTP/2. This makes it possible
+    to do domain fronting.
+ *  New: charset support for `Credentials.basic()`.
+
+
 ## Version 3.5.0
 
 _2016-11-30_
@@ -31,7 +375,7 @@ _2016-11-30_
  *  New: Expose `Part` headers and body in `Multipart`.
  *  New: Make `ResponseBody.string()` and `ResponseBody.charStream()` BOM-aware. If your HTTP
     response body begins with a [byte order mark][bom] it will be consumed and used to select a
-    charset for the remaining bytes. Most applications should not not need a byte order mark.
+    charset for the remaining bytes. Most applications should not need a byte order mark.
 
  *  New: Upgrade to Okio 1.11.0.
 
@@ -719,7 +1063,7 @@ _2014-12-30_
     for OkHttp 2.0 and 2.1 will continue to work with this update.
 
  *  **`COMPATIBLE_TLS` no longer supports SSLv3.** In response to the
-    [POODLE](http://googleonlinesecurity.blogspot.ca/2014/10/this-poodle-bites-exploiting-ssl-30.html)
+    [POODLE](https://googleonlinesecurity.blogspot.ca/2014/10/this-poodle-bites-exploiting-ssl-30.html)
     vulnerability, OkHttp no longer offers SSLv3 when negotiation an
     HTTPS connection. If you continue to need to connect to webservers
     running SSLv3, you must manually configure your own `ConnectionSpec`.
@@ -732,7 +1076,7 @@ _2014-12-30_
  *  New: APIs to iterate and selectively clear the response cache.
  *  New: Support for SOCKS proxies.
  *  New: Support for `TLS_FALLBACK_SCSV`.
- *  New: Update HTTP/2 support to to `h2-16` and `hpack-10`.
+ *  New: Update HTTP/2 support to `h2-16` and `hpack-10`.
  *  New: APIs to prevent retrying non-idempotent requests.
  *  Fix: Drop NPN support. Going forward we support ALPN only.
  *  Fix: The hostname verifier is now strict. This is consistent with the hostname
@@ -1199,3 +1543,10 @@ Initial release.
  [nginx_959]: https://trac.nginx.org/nginx/ticket/959
  [okhttp_idling_resource]: https://github.com/JakeWharton/okhttp-idling-resource
  [bom]: https://en.wikipedia.org/wiki/Byte_order_mark
+ [junit_5_rules]: https://junit.org/junit5/docs/current/user-guide/#migrating-from-junit4-rulesupport
+ [public_suffix]: https://publicsuffix.org/
+ [maven_provided]: https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html
+ [remove_cbc_ecdsa]: https://developers.google.com/web/updates/2016/12/chrome-56-deprecations#remove_cbc-mode_ecdsa_ciphers_in_tls
+ [conscrypt]: https://github.com/google/conscrypt/
+ [conscrypt_dependency]: https://github.com/google/conscrypt/#download
+ [https_server_sample]: https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/HttpsServer.java
\ No newline at end of file
diff --git a/README.md b/README.md
index 1f1f83f7d9..638bf27c82 100644
--- a/README.md
+++ b/README.md
@@ -11,12 +11,12 @@ Download [the latest JAR][3] or grab via Maven:
 <dependency>
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>okhttp</artifactId>
-  <version>3.5.0</version>
+  <version>3.11.0</version>
 </dependency>
 ```
 or Gradle:
 ```groovy
-compile 'com.squareup.okhttp3:okhttp:3.5.0'
+implementation 'com.squareup.okhttp3:okhttp:3.11.0'
 ```
 
 Snapshots of the development version are available in [Sonatype's `snapshots` repository][snap].
@@ -36,22 +36,23 @@ Download [the latest JAR][4] or grab via Maven:
 <dependency>
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>mockwebserver</artifactId>
-  <version>3.5.0</version>
+  <version>3.11.0</version>
   <scope>test</scope>
 </dependency>
 ```
 or Gradle:
 ```groovy
-testCompile 'com.squareup.okhttp3:mockwebserver:3.5.0'
+testImplementation 'com.squareup.okhttp3:mockwebserver:3.11.0'
 ```
 
-ProGuard
---------
+R8 / ProGuard
+-------------
+
+If you are using R8 or ProGuard add the options from
+[this file](https://github.com/square/okhttp/blob/master/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro).
+
+You might also need rules for Okio which is a dependency of this library.
 
-If you are using ProGuard you might need to add the following option:
-```
--dontwarn okhttp3.**
-```
 
 License
 -------
@@ -69,7 +70,7 @@ License
     limitations under the License.
 
 
- [1]: http://square.github.io/okhttp
+ [1]: https://square.github.io/okhttp
  [2]: https://github.com/square/okhttp/wiki
  [3]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=okhttp&v=LATEST
  [4]: https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=mockwebserver&v=LATEST
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
index e6067ec658..1ede888fe5 100644
--- a/benchmarks/pom.xml
+++ b/benchmarks/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.6.0-SNAPSHOT</version>
+    <version>3.12.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>benchmarks</artifactId>
@@ -36,12 +36,13 @@
     </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
-      <artifactId>mockwebserver</artifactId>
+      <artifactId>okhttp-tls</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
-      <groupId>org.bouncycastle</groupId>
-      <artifactId>bcprov-jdk15on</artifactId>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
     </dependency>
     <dependency>
       <groupId>org.apache.httpcomponents</groupId>
@@ -74,6 +75,7 @@
       <plugin>
         <groupId>org.codehaus.mojo</groupId>
         <artifactId>exec-maven-plugin</artifactId>
+        <version>1.5.0</version>
         <executions>
           <execution>
             <goals>
@@ -129,6 +131,7 @@
             <!-- Fails on caliper's ASM on OpenJDK 8. -->
             <groupId>org.codehaus.mojo</groupId>
             <artifactId>animal-sniffer-maven-plugin</artifactId>
+            <version>1.15</version>
             <executions>
               <execution>
                 <phase>none</phase>
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
index a5c632fa0f..e3dbd3084c 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/ApacheHttpClient.java
@@ -20,7 +20,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.zip.GZIPInputStream;
 import okhttp3.HttpUrl;
-import okhttp3.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
 import org.apache.http.Header;
 import org.apache.http.HttpResponse;
 import org.apache.http.client.HttpClient;
@@ -31,6 +31,8 @@
 import org.apache.http.impl.client.DefaultHttpClient;
 import org.apache.http.impl.conn.PoolingClientConnectionManager;
 
+import static okhttp3.tls.internal.TlsUtil.localhost;
+
 /** Benchmark Apache HTTP client. */
 class ApacheHttpClient extends SynchronousHttpClient {
   private static final boolean VERBOSE = false;
@@ -41,9 +43,9 @@
     super.prepare(benchmark);
     ClientConnectionManager connectionManager = new PoolingClientConnectionManager();
     if (benchmark.tls) {
-      SslClient sslClient = SslClient.localhost();
+      HandshakeCertificates handshakeCertificates = localhost();
       connectionManager.getSchemeRegistry().register(
-          new Scheme("https", 443, new SSLSocketFactory(sslClient.sslContext)));
+          new Scheme("https", 443, new SSLSocketFactory(handshakeCertificates.sslContext())));
     }
     client = new DefaultHttpClient(connectionManager);
   }
@@ -55,7 +57,7 @@
   class ApacheHttpClientRequest implements Runnable {
     private final HttpUrl url;
 
-    public ApacheHttpClientRequest(HttpUrl url) {
+    ApacheHttpClientRequest(HttpUrl url) {
       this.url = url;
     }
 
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java b/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
index 0ec59a0573..081fcfccb9 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/Benchmark.java
@@ -28,14 +28,16 @@
 import java.util.logging.Logger;
 import okhttp3.HttpUrl;
 import okhttp3.Protocol;
-import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.GzipSink;
 
+import static okhttp3.tls.internal.TlsUtil.localhost;
+
 /**
  * This benchmark is fake, but may be useful for certain relative comparisons. It uses a local
  * connection to a MockWebServer to measure how many identical requests per second can be carried
@@ -160,8 +162,8 @@ private MockWebServer startServer() throws IOException {
     MockWebServer server = new MockWebServer();
 
     if (tls) {
-      SslClient sslClient = SslClient.localhost();
-      server.useHttps(sslClient.socketFactory, false);
+      HandshakeCertificates handshakeCertificates = localhost();
+      server.useHttps(handshakeCertificates.sslSocketFactory(), false);
       server.setProtocols(protocols);
     }
 
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java b/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
index 01e6f6e257..35731fa3b1 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/NettyHttpClient.java
@@ -44,7 +44,9 @@
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.SSLEngine;
 import okhttp3.HttpUrl;
-import okhttp3.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
+
+import static okhttp3.tls.internal.TlsUtil.localhost;
 
 /** Netty isn't an HTTP client, but it's almost one. */
 class NettyHttpClient implements HttpClient {
@@ -64,12 +66,12 @@
     this.targetBacklog = benchmark.targetBacklog;
 
     ChannelInitializer<SocketChannel> channelInitializer = new ChannelInitializer<SocketChannel>() {
-      @Override public void initChannel(SocketChannel channel) throws Exception {
+      @Override public void initChannel(SocketChannel channel) {
         ChannelPipeline pipeline = channel.pipeline();
 
         if (benchmark.tls) {
-          SslClient sslClient = SslClient.localhost();
-          SSLEngine engine = sslClient.sslContext.createSSLEngine();
+          HandshakeCertificates handshakeCertificates = localhost();
+          SSLEngine engine = handshakeCertificates.sslContext().createSSLEngine();
           engine.setUseClientMode(true);
           pipeline.addLast("ssl", new SslHandler(engine));
         }
@@ -137,7 +139,7 @@ private void release(HttpChannel httpChannel) {
     int total;
     long start;
 
-    public HttpChannel(SocketChannel channel) {
+    HttpChannel(SocketChannel channel) {
       this.channel = channel;
     }
 
@@ -152,7 +154,7 @@ private void sendRequest(HttpUrl url) {
     }
 
     @Override protected void channelRead0(
-        ChannelHandlerContext context, HttpObject message) throws Exception {
+        ChannelHandlerContext context, HttpObject message) {
       if (message instanceof HttpResponse) {
         receive((HttpResponse) message);
       }
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
index 7c90e5e6b5..86b44523a2 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttp.java
@@ -25,7 +25,9 @@
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.ResponseBody;
-import okhttp3.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
+
+import static okhttp3.tls.internal.TlsUtil.localhost;
 
 class OkHttp extends SynchronousHttpClient {
   private static final boolean VERBOSE = false;
@@ -39,15 +41,15 @@
         .build();
 
     if (benchmark.tls) {
-      SslClient sslClient = SslClient.localhost();
-      SSLSocketFactory socketFactory = sslClient.socketFactory;
+      HandshakeCertificates handshakeCertificates = localhost();
+      SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
       HostnameVerifier hostnameVerifier = new HostnameVerifier() {
         @Override public boolean verify(String s, SSLSession session) {
           return true;
         }
       };
       client = new OkHttpClient.Builder()
-          .sslSocketFactory(socketFactory, sslClient.trustManager)
+          .sslSocketFactory(socketFactory, handshakeCertificates.trustManager())
           .hostnameVerifier(hostnameVerifier)
           .build();
     }
@@ -61,7 +63,7 @@
   class OkHttpRequest implements Runnable {
     private final Call call;
 
-    public OkHttpRequest(Call call) {
+    OkHttpRequest(Call call) {
       this.call = call;
     }
 
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
index 57cb75cacc..d6d0bc5cb4 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/OkHttpAsync.java
@@ -31,7 +31,9 @@
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
-import okhttp3.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
+
+import static okhttp3.tls.internal.TlsUtil.localhost;
 
 class OkHttpAsync implements HttpClient {
   private static final boolean VERBOSE = false;
@@ -54,15 +56,15 @@
         .build();
 
     if (benchmark.tls) {
-      SslClient sslClient = SslClient.localhost();
-      SSLSocketFactory socketFactory = sslClient.socketFactory;
+      HandshakeCertificates handshakeCertificates = localhost();
+      SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
       HostnameVerifier hostnameVerifier = new HostnameVerifier() {
         @Override public boolean verify(String s, SSLSession session) {
           return true;
         }
       };
       client = client.newBuilder()
-          .sslSocketFactory(socketFactory, sslClient.trustManager)
+          .sslSocketFactory(socketFactory, handshakeCertificates.trustManager())
           .hostnameVerifier(hostnameVerifier)
           .build();
     }
diff --git a/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java b/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
index f75d160835..96eb7422cd 100644
--- a/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
+++ b/benchmarks/src/main/java/okhttp3/benchmarks/UrlConnection.java
@@ -25,7 +25,9 @@
 import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.HttpUrl;
-import okhttp3.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
+
+import static okhttp3.tls.internal.TlsUtil.localhost;
 
 class UrlConnection extends SynchronousHttpClient {
   private static final boolean VERBOSE = false;
@@ -33,8 +35,8 @@
   @Override public void prepare(Benchmark benchmark) {
     super.prepare(benchmark);
     if (benchmark.tls) {
-      SslClient sslClient = SslClient.localhost();
-      SSLSocketFactory socketFactory = sslClient.socketFactory;
+      HandshakeCertificates handshakeCertificates = localhost();
+      SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
       HostnameVerifier hostnameVerifier = new HostnameVerifier() {
         @Override public boolean verify(String s, SSLSession session) {
           return true;
@@ -52,7 +54,7 @@
   static class UrlConnectionRequest implements Runnable {
     private final HttpUrl url;
 
-    public UrlConnectionRequest(HttpUrl url) {
+    UrlConnectionRequest(HttpUrl url) {
       this.url = url;
     }
 
diff --git a/checkstyle.xml b/checkstyle.xml
index e2660531c3..1e4d8e6d1d 100644
--- a/checkstyle.xml
+++ b/checkstyle.xml
@@ -1,7 +1,7 @@
 <?xml version="1.0"?>
 <!DOCTYPE module PUBLIC
-    "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
-    "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
+    "-//Puppy Crawl//DTD Check Configuration 1.3//EN"
+    "http://www.puppycrawl.com/dtds/configuration_1_3.dtd">
 
 <module name="Checker">
   <module name="SuppressWarningsFilter"/>
@@ -121,7 +121,7 @@
     <!--module name="InnerAssignment"/-->
     <!--module name="MagicNumber"/-->
     <!--module name="MissingSwitchDefault"/-->
-    <module name="RedundantThrows"/>
+    <!--<module name="RedundantThrows"/>-->
     <module name="SimplifyBooleanExpression"/>
     <module name="SimplifyBooleanReturn"/>
 
diff --git a/mockwebserver/README.md b/mockwebserver/README.md
index 06cf0723f5..73503bb6d2 100644
--- a/mockwebserver/README.md
+++ b/mockwebserver/README.md
@@ -152,7 +152,7 @@ Get MockWebServer via Maven:
 
 or via Gradle 
 ```groovy
-testCompile 'com.squareup.okhttp3:mockwebserver:(insert latest version)'
+testImplementation 'com.squareup.okhttp3:mockwebserver:(insert latest version)'
 ```
 
 ### License
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index 12f9cf46a9..eb19007574 100644
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.6.0-SNAPSHOT</version>
+    <version>3.12.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>mockwebserver</artifactId>
@@ -25,8 +25,10 @@
       <scope>test</scope>
     </dependency>
     <dependency>
-      <groupId>org.bouncycastle</groupId>
-      <artifactId>bcprov-jdk15on</artifactId>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-tls</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
     </dependency>
     <dependency>
       <groupId>junit</groupId>
@@ -39,6 +41,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
         <configuration>
           <links>
             <link>http://square.github.io/okhttp/javadoc/</link>
@@ -49,6 +52,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-assembly-plugin</artifactId>
+        <version>3.0.0</version>
         <configuration>
           <descriptorRefs>
             <descriptorRef>jar-with-dependencies</descriptorRef>
@@ -63,6 +67,18 @@
           </execution>
         </executions>
       </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>okhttp3.mockwebserver</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java b/mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java
deleted file mode 100644
index eedfc2a094..0000000000
--- a/mockwebserver/src/main/java/okhttp3/internal/tls/HeldCertificate.java
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
- * Copyright (C) 2016 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.tls;
-
-import java.math.BigInteger;
-import java.security.GeneralSecurityException;
-import java.security.KeyPair;
-import java.security.KeyPairGenerator;
-import java.security.SecureRandom;
-import java.security.Security;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Date;
-import java.util.List;
-import java.util.UUID;
-import javax.security.auth.x500.X500Principal;
-import org.bouncycastle.asn1.ASN1Encodable;
-import org.bouncycastle.asn1.DERSequence;
-import org.bouncycastle.asn1.x509.BasicConstraints;
-import org.bouncycastle.asn1.x509.GeneralName;
-import org.bouncycastle.asn1.x509.X509Extensions;
-import org.bouncycastle.jce.provider.BouncyCastleProvider;
-import org.bouncycastle.x509.X509V3CertificateGenerator;
-
-import static okhttp3.internal.Util.verifyAsIpAddress;
-
-/**
- * A certificate and its private key. This can be used on the server side by HTTPS servers, or on
- * the client side to verify those HTTPS servers. A held certificate can also be used to sign other
- * held certificates, as done in practice by certificate authorities.
- */
-public final class HeldCertificate {
-  public final X509Certificate certificate;
-  public final KeyPair keyPair;
-
-  public HeldCertificate(X509Certificate certificate, KeyPair keyPair) {
-    this.certificate = certificate;
-    this.keyPair = keyPair;
-  }
-
-  public static final class Builder {
-    static {
-      Security.addProvider(new BouncyCastleProvider());
-    }
-
-    private final long duration = 1000L * 60 * 60 * 24; // One day.
-    private String hostname;
-    private List<String> altNames = new ArrayList<>();
-    private String serialNumber = "1";
-    private KeyPair keyPair;
-    private HeldCertificate issuedBy;
-    private int maxIntermediateCas;
-
-    public Builder serialNumber(String serialNumber) {
-      this.serialNumber = serialNumber;
-      return this;
-    }
-
-    /**
-     * Set this certificate's name. Typically this is the URL hostname for TLS certificates. This is
-     * the CN (common name) in the certificate. Will be a random string if no value is provided.
-     */
-    public Builder commonName(String hostname) {
-      this.hostname = hostname;
-      return this;
-    }
-
-    public Builder keyPair(KeyPair keyPair) {
-      this.keyPair = keyPair;
-      return this;
-    }
-
-    /**
-     * Set the certificate that signs this certificate. If unset, a self-signed certificate will be
-     * generated.
-     */
-    public Builder issuedBy(HeldCertificate signedBy) {
-      this.issuedBy = signedBy;
-      return this;
-    }
-
-    /**
-     * Set this certificate to be a certificate authority, with up to {@code maxIntermediateCas}
-     * intermediate certificate authorities beneath it.
-     */
-    public Builder ca(int maxIntermediateCas) {
-      this.maxIntermediateCas = maxIntermediateCas;
-      return this;
-    }
-
-    /**
-     * Adds a subject alternative name to the certificate. This is usually a hostname or IP address.
-     * If no subject alternative names are added that extension will not be used.
-     */
-    public Builder subjectAlternativeName(String altName) {
-      altNames.add(altName);
-      return this;
-    }
-
-    public HeldCertificate build() throws GeneralSecurityException {
-      // Subject, public & private keys for this certificate.
-      KeyPair heldKeyPair = keyPair != null
-          ? keyPair
-          : generateKeyPair();
-      X500Principal subject = hostname != null
-          ? new X500Principal("CN=" + hostname)
-          : new X500Principal("CN=" + UUID.randomUUID());
-
-      // Subject, public & private keys for this certificate's signer. It may be self signed!
-      KeyPair signedByKeyPair;
-      X500Principal signedByPrincipal;
-      if (issuedBy != null) {
-        signedByKeyPair = issuedBy.keyPair;
-        signedByPrincipal = issuedBy.certificate.getSubjectX500Principal();
-      } else {
-        signedByKeyPair = heldKeyPair;
-        signedByPrincipal = subject;
-      }
-
-      // Generate & sign the certificate.
-      long now = System.currentTimeMillis();
-      X509V3CertificateGenerator generator = new X509V3CertificateGenerator();
-      generator.setSerialNumber(new BigInteger(serialNumber));
-      generator.setIssuerDN(signedByPrincipal);
-      generator.setNotBefore(new Date(now));
-      generator.setNotAfter(new Date(now + duration));
-      generator.setSubjectDN(subject);
-      generator.setPublicKey(heldKeyPair.getPublic());
-      generator.setSignatureAlgorithm("SHA256WithRSAEncryption");
-
-      if (maxIntermediateCas > 0) {
-        generator.addExtension(X509Extensions.BasicConstraints, true,
-            new BasicConstraints(maxIntermediateCas));
-      }
-
-      if (!altNames.isEmpty()) {
-        ASN1Encodable[] encodableAltNames = new ASN1Encodable[altNames.size()];
-        for (int i = 0, size = altNames.size(); i < size; i++) {
-          String altName = altNames.get(i);
-          int tag = verifyAsIpAddress(altName)
-              ? GeneralName.iPAddress
-              : GeneralName.dNSName;
-          encodableAltNames[i] = new GeneralName(tag, altName);
-        }
-        generator.addExtension(X509Extensions.SubjectAlternativeName, true,
-            new DERSequence(encodableAltNames));
-      }
-
-      X509Certificate certificate = generator.generateX509Certificate(
-          signedByKeyPair.getPrivate(), "BC");
-      return new HeldCertificate(certificate, heldKeyPair);
-    }
-
-    public KeyPair generateKeyPair() throws GeneralSecurityException {
-      KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA", "BC");
-      keyPairGenerator.initialize(1024, new SecureRandom());
-      return keyPairGenerator.generateKeyPair();
-    }
-  }
-}
diff --git a/mockwebserver/src/main/java/okhttp3/internal/tls/SslClient.java b/mockwebserver/src/main/java/okhttp3/internal/tls/SslClient.java
deleted file mode 100644
index 8fb994394a..0000000000
--- a/mockwebserver/src/main/java/okhttp3/internal/tls/SslClient.java
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.tls;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.security.GeneralSecurityException;
-import java.security.KeyPair;
-import java.security.KeyStore;
-import java.security.SecureRandom;
-import java.security.cert.Certificate;
-import java.security.cert.X509Certificate;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import javax.net.ssl.KeyManagerFactory;
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLSocketFactory;
-import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
-import javax.net.ssl.X509TrustManager;
-
-/**
- * Combines an SSL socket factory and trust manager, a pairing enough for OkHttp or MockWebServer to
- * create a secure connection.
- */
-public final class SslClient {
-  private static SslClient localhost; // Lazily initialized.
-
-  public final SSLContext sslContext;
-  public final SSLSocketFactory socketFactory;
-  public final X509TrustManager trustManager;
-
-  private SslClient(SSLContext sslContext, X509TrustManager trustManager) {
-    this.sslContext = sslContext;
-    this.socketFactory = sslContext.getSocketFactory();
-    this.trustManager = trustManager;
-  }
-
-  /** Returns an SSL client for this host's localhost address. */
-  public static synchronized SslClient localhost() {
-    if (localhost != null) return localhost;
-
-    try {
-      // Generate a self-signed cert for the server to serve and the client to trust.
-      HeldCertificate heldCertificate = new HeldCertificate.Builder()
-          .serialNumber("1")
-          .commonName(InetAddress.getByName("localhost").getHostName())
-          .build();
-
-      localhost = new Builder()
-          .certificateChain(heldCertificate.keyPair, heldCertificate.certificate)
-          .addTrustedCertificate(heldCertificate.certificate)
-          .build();
-
-      return localhost;
-    } catch (GeneralSecurityException | UnknownHostException e) {
-      throw new RuntimeException(e);
-    }
-  }
-
-  public static class Builder {
-    private final List<X509Certificate> chainCertificates = new ArrayList<>();
-    private final List<X509Certificate> certificates = new ArrayList<>();
-    private KeyPair keyPair;
-    private String keyStoreType = KeyStore.getDefaultType();
-
-    /**
-     * Configure the certificate chain to use when serving HTTPS responses. The first certificate is
-     * the server's certificate, further certificates are included in the handshake so the client
-     * can build a trusted path to a CA certificate.
-     */
-    public Builder certificateChain(HeldCertificate localCert, HeldCertificate... chain) {
-      X509Certificate[] certificates = new X509Certificate[chain.length];
-      for (int i = 0; i < chain.length; i++) {
-        certificates[i] = chain[i].certificate;
-      }
-      return certificateChain(localCert.keyPair, localCert.certificate, certificates);
-    }
-
-    public Builder certificateChain(KeyPair keyPair, X509Certificate keyCert,
-        X509Certificate... certificates) {
-      this.keyPair = keyPair;
-      this.chainCertificates.add(keyCert);
-      this.chainCertificates.addAll(Arrays.asList(certificates));
-      this.certificates.addAll(Arrays.asList(certificates));
-      return this;
-    }
-
-    /**
-     * Add a certificate authority that this client trusts. Servers that provide certificate chains
-     * signed by these roots (or their intermediates) will be accepted.
-     */
-    public Builder addTrustedCertificate(X509Certificate certificate) {
-      this.certificates.add(certificate);
-      return this;
-    }
-
-    public Builder keyStoreType(String keyStoreType) {
-      this.keyStoreType = keyStoreType;
-      return this;
-    }
-
-    public SslClient build() {
-      try {
-        // Put the certificate in a key store.
-        char[] password = "password".toCharArray();
-        KeyStore keyStore = newEmptyKeyStore(password);
-
-        if (keyPair != null) {
-          Certificate[] certificates = chainCertificates.toArray(
-              new Certificate[chainCertificates.size()]);
-          keyStore.setKeyEntry("private", keyPair.getPrivate(), password, certificates);
-        }
-
-        for (int i = 0; i < certificates.size(); i++) {
-          keyStore.setCertificateEntry("cert_" + i, certificates.get(i));
-        }
-
-        // Wrap it up in an SSL context.
-        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(
-            KeyManagerFactory.getDefaultAlgorithm());
-        keyManagerFactory.init(keyStore, password);
-        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-            TrustManagerFactory.getDefaultAlgorithm());
-        trustManagerFactory.init(keyStore);
-        TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
-
-        if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
-          throw new IllegalStateException("Unexpected default trust managers:"
-              + Arrays.toString(trustManagers));
-        }
-
-        SSLContext sslContext = SSLContext.getInstance("TLS");
-        sslContext.init(keyManagerFactory.getKeyManagers(), trustManagers, new SecureRandom());
-
-        return new SslClient(sslContext, (X509TrustManager) trustManagers[0]);
-      } catch (GeneralSecurityException gse) {
-        throw new AssertionError(gse);
-      }
-    }
-
-    private KeyStore newEmptyKeyStore(char[] password) throws GeneralSecurityException {
-      try {
-        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
-        InputStream in = null; // By convention, 'null' creates an empty key store.
-        keyStore.load(in, password);
-        return keyStore;
-      } catch (IOException e) {
-        throw new AssertionError(e);
-      }
-    }
-  }
-}
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
index 73691d4b54..36457229ed 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockResponse.java
@@ -43,6 +43,9 @@
   private long bodyDelayAmount = 0;
   private TimeUnit bodyDelayUnit = TimeUnit.MILLISECONDS;
 
+  private long headersDelayAmount = 0;
+  private TimeUnit headersDelayUnit = TimeUnit.MILLISECONDS;
+
   private List<PushPromise> promises = new ArrayList<>();
   private Settings settings;
   private WebSocketListener webSocketListener;
@@ -253,6 +256,16 @@ public long getBodyDelay(TimeUnit unit) {
     return unit.convert(bodyDelayAmount, bodyDelayUnit);
   }
 
+  public MockResponse setHeadersDelay(long delay, TimeUnit unit) {
+    headersDelayAmount = delay;
+    headersDelayUnit = unit;
+    return this;
+  }
+
+  public long getHeadersDelay(TimeUnit unit) {
+    return unit.convert(headersDelayAmount, headersDelayUnit);
+  }
+
   /**
    * When {@link MockWebServer#setProtocols(java.util.List) protocols} include {@linkplain
    * okhttp3.Protocol#HTTP_2}, this attaches a pushed stream to this response.
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
index 17ea30300d..f85cd96ca5 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/MockWebServer.java
@@ -19,7 +19,6 @@
 
 import java.io.Closeable;
 import java.io.IOException;
-import java.io.InterruptedIOException;
 import java.net.InetAddress;
 import java.net.InetSocketAddress;
 import java.net.ProtocolException;
@@ -76,11 +75,10 @@
 import okio.Okio;
 import okio.Sink;
 import okio.Timeout;
-import org.junit.rules.TestRule;
-import org.junit.runner.Description;
-import org.junit.runners.model.Statement;
+import org.junit.rules.ExternalResource;
 
 import static okhttp3.internal.Util.closeQuietly;
+import static okhttp3.mockwebserver.SocketPolicy.CONTINUE_ALWAYS;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AFTER_REQUEST;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
@@ -92,17 +90,22 @@
 import static okhttp3.mockwebserver.SocketPolicy.RESET_STREAM_AT_START;
 import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
 import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
+import static okhttp3.mockwebserver.SocketPolicy.STALL_SOCKET_AT_START;
 import static okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END;
 
 /**
  * A scriptable web server. Callers supply canned responses and the server replays them upon request
  * in sequence.
  */
-public final class MockWebServer implements TestRule, Closeable {
+public final class MockWebServer extends ExternalResource implements Closeable {
   static {
     Internal.initializeInstanceForTests();
   }
 
+  private static final int CLIENT_AUTH_NONE = 0;
+  private static final int CLIENT_AUTH_REQUESTED = 1;
+  private static final int CLIENT_AUTH_REQUIRED = 2;
+
   private static final X509TrustManager UNTRUSTED_TRUST_MANAGER = new X509TrustManager() {
     @Override public void checkClientTrusted(X509Certificate[] chain, String authType)
         throws CertificateException {
@@ -133,6 +136,7 @@
   private SSLSocketFactory sslSocketFactory;
   private ExecutorService executor;
   private boolean tunnelProxy;
+  private int clientAuth = CLIENT_AUTH_NONE;
   private Dispatcher dispatcher = new QueueDispatcher();
 
   private int port = -1;
@@ -142,7 +146,7 @@
 
   private boolean started;
 
-  private synchronized void maybeStart() {
+  @Override protected synchronized void before() {
     if (started) return;
     try {
       start();
@@ -151,36 +155,20 @@ private synchronized void maybeStart() {
     }
   }
 
-  @Override public Statement apply(final Statement base, Description description) {
-    return new Statement() {
-      @Override public void evaluate() throws Throwable {
-        maybeStart();
-        try {
-          base.evaluate();
-        } finally {
-          try {
-            shutdown();
-          } catch (IOException e) {
-            logger.log(Level.WARNING, "MockWebServer shutdown failed", e);
-          }
-        }
-      }
-    };
-  }
-
   public int getPort() {
-    maybeStart();
+    before();
     return port;
   }
 
   public String getHostName() {
-    maybeStart();
-    return inetSocketAddress.getHostName();
+    before();
+    return inetSocketAddress.getAddress().getCanonicalHostName();
   }
 
   public Proxy toProxyAddress() {
-    maybeStart();
-    InetSocketAddress address = new InetSocketAddress(inetSocketAddress.getAddress(), getPort());
+    before();
+    InetSocketAddress address = new InetSocketAddress(inetSocketAddress.getAddress()
+            .getCanonicalHostName(), getPort());
     return new Proxy(Proxy.Type.HTTP, address);
   }
 
@@ -230,7 +218,12 @@ public void setProtocolNegotiationEnabled(boolean protocolNegotiationEnabled) {
    */
   public void setProtocols(List<Protocol> protocols) {
     protocols = Util.immutableList(protocols);
-    if (!protocols.contains(Protocol.HTTP_1_1)) {
+    if (protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE) && protocols.size() > 1) {
+      // when using h2_prior_knowledge, no other protocol should be supported.
+      throw new IllegalArgumentException(
+          "protocols containing h2_prior_knowledge cannot use other protocols: " + protocols);
+    } else if (!protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE)
+        && !protocols.contains(Protocol.HTTP_1_1)) {
       throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
     }
     if (protocols.contains(null)) {
@@ -239,6 +232,10 @@ public void setProtocols(List<Protocol> protocols) {
     this.protocols = protocols;
   }
 
+  public List<Protocol> protocols() {
+    return protocols;
+  }
+
   /**
    * Serve requests with HTTPS rather than otherwise.
    *
@@ -249,6 +246,36 @@ public void useHttps(SSLSocketFactory sslSocketFactory, boolean tunnelProxy) {
     this.tunnelProxy = tunnelProxy;
   }
 
+  /**
+   * Configure the server to not perform SSL authentication of the client. This leaves
+   * authentication to another layer such as in an HTTP cookie or header. This is the default and
+   * most common configuration.
+   */
+  public void noClientAuth() {
+    this.clientAuth = CLIENT_AUTH_NONE;
+  }
+
+  /**
+   * Configure the server to {@linkplain SSLSocket#setWantClientAuth want client auth}. If the
+   * client presents a certificate that is {@linkplain TrustManager trusted} the handshake will
+   * proceed normally. The connection will also proceed normally if the client presents no
+   * certificate at all! But if the client presents an untrusted certificate the handshake will fail
+   * and no connection will be established.
+   */
+  public void requestClientAuth() {
+    this.clientAuth = CLIENT_AUTH_REQUESTED;
+  }
+
+  /**
+   * Configure the server to {@linkplain SSLSocket#setNeedClientAuth need client auth}. If the
+   * client presents a certificate that is {@linkplain TrustManager trusted} the handshake will
+   * proceed normally. If the client presents an untrusted certificate or no certificate at all the
+   * handshake will fail and no connection will be established.
+   */
+  public void requireClientAuth() {
+    this.clientAuth = CLIENT_AUTH_REQUIRED;
+  }
+
   /**
    * Awaits the next HTTP request, removes it, and returns it. Callers should use this to verify the
    * request was sent as intended. This method will block until the request is available, possibly
@@ -398,6 +425,14 @@ public synchronized void shutdown() throws IOException {
     }
   }
 
+  @Override protected synchronized void after() {
+    try {
+      shutdown();
+    } catch (IOException e) {
+      logger.log(Level.WARNING, "MockWebServer shutdown failed", e);
+    }
+  }
+
   private void serveConnection(final Socket raw) {
     executor.execute(new NamedRunnable("MockWebServer %s", raw.getRemoteSocketAddress()) {
       int sequenceNumber = 0;
@@ -415,13 +450,13 @@ private void serveConnection(final Socket raw) {
       }
 
       public void processConnection() throws Exception {
+        SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
         Protocol protocol = Protocol.HTTP_1_1;
         Socket socket;
         if (sslSocketFactory != null) {
           if (tunnelProxy) {
             createTunnel();
           }
-          SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
           if (socketPolicy == FAIL_HANDSHAKE) {
             dispatchBookkeepingRequest(sequenceNumber, raw);
             processHandshakeFailure(raw);
@@ -431,6 +466,11 @@ public void processConnection() throws Exception {
               raw.getPort(), true);
           SSLSocket sslSocket = (SSLSocket) socket;
           sslSocket.setUseClientMode(false);
+          if (clientAuth == CLIENT_AUTH_REQUIRED) {
+            sslSocket.setNeedClientAuth(true);
+          } else if (clientAuth == CLIENT_AUTH_REQUESTED) {
+            sslSocket.setWantClientAuth(true);
+          }
           openClientSockets.add(socket);
 
           if (protocolNegotiationEnabled) {
@@ -444,15 +484,22 @@ public void processConnection() throws Exception {
             protocol = protocolString != null ? Protocol.get(protocolString) : Protocol.HTTP_1_1;
           }
           openClientSockets.remove(raw);
+        } else if (protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
+          socket = raw;
+          protocol = Protocol.H2_PRIOR_KNOWLEDGE;
         } else {
           socket = raw;
         }
 
-        if (protocol == Protocol.HTTP_2) {
-          FramedSocketHandler framedSocketListener = new FramedSocketHandler(socket, protocol);
+        if (socketPolicy == STALL_SOCKET_AT_START) {
+          return; // Ignore the socket until the server is shut down!
+        }
+
+        if (protocol == Protocol.HTTP_2 || protocol == Protocol.H2_PRIOR_KNOWLEDGE) {
+          Http2SocketHandler http2SocketHandler = new Http2SocketHandler(socket, protocol);
           Http2Connection connection = new Http2Connection.Builder(false)
               .socket(socket)
-              .listener(framedSocketListener)
+              .listener(http2SocketHandler)
               .build();
           connection.start();
           openConnections.add(connection);
@@ -475,8 +522,6 @@ public void processConnection() throws Exception {
               + " didn't make a request");
         }
 
-        source.close();
-        sink.close();
         socket.close();
         openClientSockets.remove(socket);
       }
@@ -591,7 +636,7 @@ private RecordedRequest readRequest(Socket socket, BufferedSource source, Buffer
     Headers.Builder headers = new Headers.Builder();
     long contentLength = -1;
     boolean chunked = false;
-    boolean readBody = true;
+    boolean expectContinue = false;
     String header;
     while ((header = source.readUtf8LineStrict()).length() != 0) {
       Internal.instance.addLenient(headers, header);
@@ -605,25 +650,23 @@ private RecordedRequest readRequest(Socket socket, BufferedSource source, Buffer
       }
       if (lowercaseHeader.startsWith("expect:")
           && lowercaseHeader.substring(7).trim().equalsIgnoreCase("100-continue")) {
-        readBody = false;
+        expectContinue = true;
       }
     }
 
-    if (!readBody && dispatcher.peek().getSocketPolicy() == EXPECT_CONTINUE) {
+    final SocketPolicy socketPolicy = dispatcher.peek().getSocketPolicy();
+    if (expectContinue && socketPolicy == EXPECT_CONTINUE || socketPolicy == CONTINUE_ALWAYS) {
       sink.writeUtf8("HTTP/1.1 100 Continue\r\n");
       sink.writeUtf8("Content-Length: 0\r\n");
       sink.writeUtf8("\r\n");
       sink.flush();
-      readBody = true;
     }
 
     boolean hasBody = false;
     TruncatingBuffer requestBody = new TruncatingBuffer(bodyLimit);
     List<Integer> chunkSizes = new ArrayList<>();
     MockResponse policy = dispatcher.peek();
-    if (!readBody) {
-      // Don't read the body unless we've invited the client to send it.
-    } else if (contentLength != -1) {
+    if (contentLength != -1) {
       hasBody = contentLength > 0;
       throttledTransfer(policy, socket, source, Okio.buffer(requestBody), contentLength, true);
     } else if (chunked) {
@@ -678,24 +721,30 @@ private void handleWebSocketUpgrade(Socket socket, BufferedSource source, Buffer
       }
     };
     RealWebSocket webSocket = new RealWebSocket(fancyRequest,
-        response.getWebSocketListener(), new SecureRandom());
+        response.getWebSocketListener(), new SecureRandom(), 0);
     response.getWebSocketListener().onOpen(webSocket, fancyResponse);
     String name = "MockWebServer WebSocket " + request.getPath();
-    webSocket.initReaderAndWriter(name, 0, streams);
-    webSocket.loopReader();
-
-    // Even if messages are no longer being read we need to wait for the connection close signal.
+    webSocket.initReaderAndWriter(name, streams);
     try {
-      connectionClose.await();
-    } catch (InterruptedException ignored) {
-    }
+      webSocket.loopReader();
 
-    closeQuietly(sink);
-    closeQuietly(source);
+      // Even if messages are no longer being read we need to wait for the connection close signal.
+      try {
+        connectionClose.await();
+      } catch (InterruptedException e) {
+        throw new AssertionError(e);
+      }
+
+    } catch (IOException e) {
+      webSocket.failWebSocket(e, null);
+    } finally {
+      closeQuietly(source);
+    }
   }
 
   private void writeHttpResponse(Socket socket, BufferedSink sink, MockResponse response)
       throws IOException {
+    sleepIfDelayed(response.getHeadersDelay(TimeUnit.MILLISECONDS));
     sink.writeUtf8(response.getStatus());
     sink.writeUtf8("\r\n");
 
@@ -711,12 +760,11 @@ private void writeHttpResponse(Socket socket, BufferedSink sink, MockResponse re
 
     Buffer body = response.getBody();
     if (body == null) return;
-    sleepIfDelayed(response);
+    sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
     throttledTransfer(response, socket, body, sink, body.size(), false);
   }
 
-  private void sleepIfDelayed(MockResponse response) {
-    long delayMs = response.getBodyDelay(TimeUnit.MILLISECONDS);
+  private void sleepIfDelayed(long delayMs) {
     if (delayMs != 0) {
       try {
         Thread.sleep(delayMs);
@@ -773,7 +821,7 @@ private void throttledTransfer(MockResponse policy, Socket socket, BufferedSourc
         try {
           Thread.sleep(periodDelayMs);
         } catch (InterruptedException e) {
-          throw new AssertionError();
+          throw new AssertionError(e);
         }
       }
     }
@@ -836,13 +884,13 @@ public void setDispatcher(Dispatcher dispatcher) {
     }
   }
 
-  /** Processes HTTP requests layered over framed protocols. */
-  private class FramedSocketHandler extends Http2Connection.Listener {
+  /** Processes HTTP requests layered over HTTP/2. */
+  private class Http2SocketHandler extends Http2Connection.Listener {
     private final Socket socket;
     private final Protocol protocol;
     private final AtomicInteger sequenceNumber = new AtomicInteger();
 
-    private FramedSocketHandler(Socket socket, Protocol protocol) {
+    private Http2SocketHandler(Socket socket, Protocol protocol) {
       this.socket = socket;
       this.protocol = protocol;
     }
@@ -855,7 +903,7 @@ private FramedSocketHandler(Socket socket, Protocol protocol) {
           stream.close(ErrorCode.fromHttp2(peekedResponse.getHttp2ErrorCode()));
           return;
         } catch (InterruptedException e) {
-          throw new InterruptedIOException();
+          throw new AssertionError(e);
         }
       }
 
@@ -898,7 +946,7 @@ private RecordedRequest readRequest(Http2Stream stream) throws IOException {
           method = value;
         } else if (name.equals(Header.TARGET_PATH)) {
           path = value;
-        } else if (protocol == Protocol.HTTP_2) {
+        } else if (protocol == Protocol.HTTP_2 || protocol == Protocol.H2_PRIOR_KNOWLEDGE) {
           httpHeaders.add(name.utf8(), value);
         } else {
           throw new IllegalStateException();
@@ -908,8 +956,10 @@ private RecordedRequest readRequest(Http2Stream stream) throws IOException {
           readBody = false;
         }
       }
+      Headers headers = httpHeaders.build();
 
-      if (!readBody && dispatcher.peek().getSocketPolicy() == EXPECT_CONTINUE) {
+      MockResponse peek = dispatcher.peek();
+      if (!readBody && peek.getSocketPolicy() == EXPECT_CONTINUE) {
         stream.sendResponseHeaders(Collections.singletonList(
             new Header(Header.RESPONSE_STATUS, ByteString.encodeUtf8("100 Continue"))), true);
         stream.getConnection().flush();
@@ -918,12 +968,16 @@ private RecordedRequest readRequest(Http2Stream stream) throws IOException {
 
       Buffer body = new Buffer();
       if (readBody) {
-        body.writeAll(stream.getSource());
+        String contentLengthString = headers.get("content-length");
+        long byteCount = contentLengthString != null
+            ? Long.parseLong(contentLengthString)
+            : Long.MAX_VALUE;
+        throttledTransfer(peek, socket, Okio.buffer(stream.getSource()), body, byteCount, true);
       }
 
       String requestLine = method + ' ' + path + " HTTP/1.1";
       List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for HTTP/2.
-      return new RecordedRequest(requestLine, httpHeaders.build(), chunkSizes, body.size(), body,
+      return new RecordedRequest(requestLine, headers, chunkSizes, body.size(), body,
           sequenceNumber.getAndIncrement(), socket);
     }
 
@@ -937,8 +991,8 @@ private void writeResponse(Http2Stream stream, MockResponse response) throws IOE
         return;
       }
       List<Header> http2Headers = new ArrayList<>();
-      String[] statusParts = response.getStatus().split(" ", 2);
-      if (statusParts.length != 2) {
+      String[] statusParts = response.getStatus().split(" ", 3);
+      if (statusParts.length < 2) {
         throw new AssertionError("Unexpected status: " + response.getStatus());
       }
       // TODO: constants for well-known header names.
@@ -948,14 +1002,16 @@ private void writeResponse(Http2Stream stream, MockResponse response) throws IOE
         http2Headers.add(new Header(headers.name(i), headers.value(i)));
       }
 
+      sleepIfDelayed(response.getHeadersDelay(TimeUnit.MILLISECONDS));
+
       Buffer body = response.getBody();
       boolean closeStreamAfterHeaders = body != null || !response.getPushPromises().isEmpty();
       stream.sendResponseHeaders(http2Headers, closeStreamAfterHeaders);
       pushPromises(stream, response.getPushPromises());
       if (body != null) {
         BufferedSink sink = Okio.buffer(stream.getSink());
-        sleepIfDelayed(response);
-        throttledTransfer(response, socket, body, sink, bodyLimit, false);
+        sleepIfDelayed(response.getBodyDelay(TimeUnit.MILLISECONDS));
+        throttledTransfer(response, socket, body, sink, body.size(), false);
         sink.close();
       } else if (closeStreamAfterHeaders) {
         stream.close(ErrorCode.NO_ERROR);
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
index aa847001a2..f3b79d3e93 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/RecordedRequest.java
@@ -16,10 +16,13 @@
 
 package okhttp3.mockwebserver;
 
+import java.io.IOException;
 import java.net.Socket;
 import java.util.List;
 import javax.net.ssl.SSLSocket;
+import okhttp3.Handshake;
 import okhttp3.Headers;
+import okhttp3.HttpUrl;
 import okhttp3.TlsVersion;
 import okio.Buffer;
 
@@ -29,11 +32,12 @@
   private final String method;
   private final String path;
   private final Headers headers;
+  private final Handshake handshake;
   private final List<Integer> chunkSizes;
   private final long bodySize;
   private final Buffer body;
   private final int sequenceNumber;
-  private final TlsVersion tlsVersion;
+  private final HttpUrl requestUrl;
 
   public RecordedRequest(String requestLine, Headers headers, List<Integer> chunkSizes,
       long bodySize, Buffer body, int sequenceNumber, Socket socket) {
@@ -43,21 +47,37 @@ public RecordedRequest(String requestLine, Headers headers, List<Integer> chunkS
     this.bodySize = bodySize;
     this.body = body;
     this.sequenceNumber = sequenceNumber;
-    this.tlsVersion = socket instanceof SSLSocket
-        ? TlsVersion.forJavaName(((SSLSocket) socket).getSession().getProtocol())
-        : null;
+    if (socket instanceof SSLSocket) {
+      try {
+        this.handshake = Handshake.get(((SSLSocket) socket).getSession());
+      } catch (IOException e) {
+        throw new IllegalArgumentException(e);
+      }
+    } else {
+      this.handshake = null;
+    }
 
     if (requestLine != null) {
       int methodEnd = requestLine.indexOf(' ');
       int pathEnd = requestLine.indexOf(' ', methodEnd + 1);
       this.method = requestLine.substring(0, methodEnd);
       this.path = requestLine.substring(methodEnd + 1, pathEnd);
+
+      String scheme = socket instanceof SSLSocket ? "https" : "http";
+      String hostname = socket.getInetAddress().getHostName();
+      int port = socket.getLocalPort();
+      this.requestUrl = HttpUrl.parse(String.format("%s://%s:%s%s", scheme, hostname, port, path));
     } else {
+      this.requestUrl = null;
       this.method = null;
       this.path = null;
     }
   }
 
+  public HttpUrl getRequestUrl() {
+    return requestUrl;
+  }
+
   public String getRequestLine() {
     return requestLine;
   }
@@ -116,7 +136,15 @@ public int getSequenceNumber() {
 
   /** Returns the connection's TLS version or null if the connection doesn't use SSL. */
   public TlsVersion getTlsVersion() {
-    return tlsVersion;
+    return handshake != null ? handshake.tlsVersion() : null;
+  }
+
+  /**
+   * Returns the TLS handshake of the connection that carried this request, or null if the request
+   * was received without TLS.
+   */
+  public Handshake getHandshake() {
+    return handshake;
   }
 
   @Override public String toString() {
diff --git a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
index 521c5a0e58..e92da7657f 100644
--- a/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
+++ b/mockwebserver/src/main/java/okhttp3/mockwebserver/SocketPolicy.java
@@ -88,8 +88,14 @@
   SHUTDOWN_OUTPUT_AT_END,
 
   /**
-   * Don't respond to the request but keep the socket open. For testing read response header timeout
-   * issue.
+   * After accepting the connection and doing TLS (if configured) don't do HTTP/1.1 or HTTP/2
+   * framing. Ignore the socket completely until the server is shut down.
+   */
+  STALL_SOCKET_AT_START,
+
+  /**
+   * Read the request but don't respond to it. Just keep the socket open. For testing read response
+   * header timeout issue.
    */
   NO_RESPONSE,
 
@@ -104,5 +110,11 @@
    * Typically this response is sent when a client makes a request with the header {@code
    * Expect: 100-continue}.
    */
-  EXPECT_CONTINUE
+  EXPECT_CONTINUE,
+
+  /**
+   * Transmit a {@code HTTP/1.1 100 Continue} response before reading the HTTP request body even
+   * if the client does not send the header {@code Expect: 100-continue} in its request.
+   */
+  CONTINUE_ALWAYS
 }
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
index 5f189dc608..ec8317e95e 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/CustomDispatcherTest.java
@@ -39,7 +39,7 @@
     final List<RecordedRequest> requestsMade = new ArrayList<>();
     final Dispatcher dispatcher = new Dispatcher() {
       @Override
-      public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+      public MockResponse dispatch(RecordedRequest request) {
         requestsMade.add(request);
         return new MockResponse();
       }
diff --git a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
index b0a3ec06ee..cb4577b4f0 100644
--- a/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/MockWebServerTest.java
@@ -27,13 +27,21 @@
 import java.net.SocketTimeoutException;
 import java.net.URL;
 import java.net.URLConnection;
+import java.nio.charset.StandardCharsets;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import javax.net.ssl.HttpsURLConnection;
+import okhttp3.Handshake;
 import okhttp3.Headers;
+import okhttp3.HttpUrl;
+import okhttp3.Protocol;
+import okhttp3.RecordingHostnameVerifier;
 import okhttp3.internal.Util;
+import okhttp3.tls.HeldCertificate;
+import okhttp3.tls.HandshakeCertificates;
 import org.junit.After;
 import org.junit.Rule;
 import org.junit.Test;
@@ -42,9 +50,11 @@
 
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -105,6 +115,17 @@
     assertEquals(Arrays.asList("Cookies: delicious", "cookie: r=robot"), headersToList(response));
   }
 
+  @Test public void mockResponseSetHeaders() {
+    MockResponse response = new MockResponse()
+        .clearHeaders()
+        .addHeader("Cookie: s=square")
+        .addHeader("Cookies: delicious");
+
+    response.setHeaders(new Headers.Builder().add("Cookie", "a=android").build());
+
+    assertEquals(Arrays.asList("Cookie: a=android"), headersToList(response));
+  }
+
   @Test public void regularResponse() throws Exception {
     server.enqueue(new MockResponse().setBody("hello world"));
 
@@ -280,7 +301,7 @@
     in.close();
   }
 
-  @Test public void disconnectRequestHalfway() throws IOException {
+  @Test public void disconnectRequestHalfway() throws Exception {
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.DISCONNECT_DURING_REQUEST_BODY));
     // Limit the size of the request body that the server holds in memory to an arbitrary
     // 3.5 MBytes so this test can pass on devices with little memory.
@@ -299,11 +320,15 @@
       try {
         out.write(data);
         out.flush();
+        if (i == 513) {
+          // pause slightly after half way to make result more predictable
+          Thread.sleep(100);
+        }
       } catch (IOException e) {
         break;
       }
     }
-    assertEquals(512f, i, 10f); // Halfway +/- 1%
+    assertEquals(512f, i, 5f); // Halfway +/- 0.5%
   }
 
   @Test public void disconnectResponseHalfway() throws IOException {
@@ -405,4 +430,143 @@
     // Shutting down the server should unblock the dispatcher.
     server.shutdown();
   }
+
+  @Test public void requestUrlReconstructed() throws Exception {
+    server.enqueue(new MockResponse().setBody("hello world"));
+
+    URL url = server.url("/a/deep/path?key=foo%20bar").url();
+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+    InputStream in = connection.getInputStream();
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
+    assertEquals("hello world", reader.readLine());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /a/deep/path?key=foo%20bar HTTP/1.1", request.getRequestLine());
+
+    HttpUrl requestUrl = request.getRequestUrl();
+    assertEquals("http", requestUrl.scheme());
+    assertEquals(server.getHostName(), requestUrl.host());
+    assertEquals(server.getPort(), requestUrl.port());
+    assertEquals("/a/deep/path", requestUrl.encodedPath());
+    assertEquals("foo bar", requestUrl.queryParameter("key"));
+  }
+
+  @Test public void http100Continue() throws Exception {
+    server.enqueue(new MockResponse().setBody("response"));
+
+    URL url = server.url("/").url();
+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+    connection.setDoOutput(true);
+    connection.setRequestProperty("Expect", "100-Continue");
+    connection.getOutputStream().write("request".getBytes(StandardCharsets.UTF_8));
+
+    InputStream in = connection.getInputStream();
+    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+    assertEquals("response", reader.readLine());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("request", request.getBody().readUtf8());
+  }
+
+  @Test public void testH2PriorKnowledgeServerFallback() {
+    try {
+      server.setProtocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_1_1));
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("protocols containing h2_prior_knowledge cannot use other protocols: "
+              + "[h2_prior_knowledge, http/1.1]", expected.getMessage());
+    }
+  }
+
+  @Test public void testH2PriorKnowledgeServerDuplicates() {
+    try {
+      // Treating this use case as user error
+      server.setProtocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.H2_PRIOR_KNOWLEDGE));
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("protocols containing h2_prior_knowledge cannot use other protocols: "
+          + "[h2_prior_knowledge, h2_prior_knowledge]", expected.getMessage());
+    }
+  }
+
+  @Test public void testMockWebServerH2PriorKnowledgeProtocol() {
+    server.setProtocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE));
+
+    assertEquals(1, server.protocols().size());
+    assertEquals(Protocol.H2_PRIOR_KNOWLEDGE, server.protocols().get(0));
+  }
+
+  @Test public void https() throws Exception {
+    HandshakeCertificates handshakeCertificates = localhost();
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    HttpUrl url = server.url("/");
+    HttpsURLConnection connection = (HttpsURLConnection) url.url().openConnection();
+    connection.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
+    connection.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
+    BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
+    assertEquals("abc", reader.readLine());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("https", request.getRequestUrl().scheme());
+    Handshake handshake = request.getHandshake();
+    assertNotNull(handshake.tlsVersion());
+    assertNotNull(handshake.cipherSuite());
+    assertNotNull(handshake.localPrincipal());
+    assertEquals(1, handshake.localCertificates().size());
+    assertNull(handshake.peerPrincipal());
+    assertEquals(0, handshake.peerCertificates().size());
+  }
+
+  @Test public void httpsWithClientAuth() throws Exception {
+    HeldCertificate clientCa = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .build();
+    HeldCertificate serverCa = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .build();
+    HeldCertificate serverCertificate = new HeldCertificate.Builder()
+        .signedBy(serverCa)
+        .addSubjectAlternativeName(server.getHostName())
+        .build();
+    HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(clientCa.certificate())
+        .heldCertificate(serverCertificate)
+        .build();
+
+    server.useHttps(serverHandshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.requestClientAuth();
+
+    HeldCertificate clientCertificate = new HeldCertificate.Builder()
+        .signedBy(clientCa)
+        .build();
+    HandshakeCertificates clientHandshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(serverCa.certificate())
+        .heldCertificate(clientCertificate)
+        .build();
+
+    HttpUrl url = server.url("/");
+    HttpsURLConnection connection = (HttpsURLConnection) url.url().openConnection();
+    connection.setSSLSocketFactory(clientHandshakeCertificates.sslSocketFactory());
+    connection.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    assertEquals(HttpURLConnection.HTTP_OK, connection.getResponseCode());
+    BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
+    assertEquals("abc", reader.readLine());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("https", request.getRequestUrl().scheme());
+    Handshake handshake = request.getHandshake();
+    assertNotNull(handshake.tlsVersion());
+    assertNotNull(handshake.cipherSuite());
+    assertNotNull(handshake.localPrincipal());
+    assertEquals(1, handshake.localCertificates().size());
+    assertNotNull(handshake.peerPrincipal());
+    assertEquals(1, handshake.peerCertificates().size());
+  }
 }
diff --git a/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java b/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
similarity index 90%
rename from mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java
rename to mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
index c9a2da9a39..add3c9f157 100644
--- a/mockwebserver/src/main/java/okhttp3/internal/http2/Http2Server.java
+++ b/mockwebserver/src/test/java/okhttp3/mockwebserver/internal/http2/Http2Server.java
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-package okhttp3.internal.http2;
+package okhttp3.mockwebserver.internal.http2;
 
 import java.io.File;
 import java.io.IOException;
@@ -30,13 +30,16 @@
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.Protocol;
 import okhttp3.internal.Util;
+import okhttp3.internal.http2.Header;
+import okhttp3.internal.http2.Http2Connection;
+import okhttp3.internal.http2.Http2Stream;
 import okhttp3.internal.platform.Platform;
-import okhttp3.internal.tls.SslClient;
 import okio.BufferedSink;
 import okio.Okio;
 import okio.Source;
 
 import static okhttp3.internal.platform.Platform.INFO;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 
 /** A basic HTTP/2 server that serves the contents of a local directory. */
 public final class Http2Server extends Http2Connection.Listener {
@@ -71,10 +74,10 @@ private void run() throws Exception {
             .build();
         connection.start();
       } catch (IOException e) {
-        logger.log(Level.INFO, "FramedServer connection failure: " + e);
+        logger.log(Level.INFO, "Http2Server connection failure: " + e);
         Util.closeQuietly(socket);
       } catch (Exception e) {
-        logger.log(Level.WARNING, "FramedServer unexpected failure", e);
+        logger.log(Level.WARNING, "Http2Server unexpected failure", e);
         Util.closeQuietly(socket);
       }
     }
@@ -90,7 +93,7 @@ private SSLSocket doSsl(Socket socket) throws IOException {
     return sslSocket;
   }
 
-  @Override public void onStream(final Http2Stream stream) throws IOException {
+  @Override public void onStream(Http2Stream stream) throws IOException {
     try {
       List<Header> requestHeaders = stream.getRequestHeaders();
       String path = null;
@@ -116,7 +119,7 @@ private SSLSocket doSsl(Socket socket) throws IOException {
         send404(stream, path);
       }
     } catch (IOException e) {
-      Platform.get().log(INFO, "Failure serving FramedStream: " + e.getMessage(), null);
+      Platform.get().log(INFO, "Failure serving Http2Stream: " + e.getMessage(), null);
     }
   }
 
@@ -177,12 +180,12 @@ private String contentType(File file) {
 
   public static void main(String... args) throws Exception {
     if (args.length != 1 || args[0].startsWith("-")) {
-      System.out.println("Usage: FramedServer <base directory>");
+      System.out.println("Usage: Http2Server <base directory>");
       return;
     }
 
     Http2Server server = new Http2Server(new File(args[0]),
-        SslClient.localhost().sslContext.getSocketFactory());
+        localhost().sslContext().getSocketFactory());
     server.run();
   }
 }
diff --git a/okcurl/pom.xml b/okcurl/pom.xml
index f2fccf897b..6d1cc5c697 100644
--- a/okcurl/pom.xml
+++ b/okcurl/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.6.0-SNAPSHOT</version>
+    <version>3.12.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okcurl</artifactId>
@@ -24,10 +24,6 @@
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
-    <dependency>
-      <groupId>org.bouncycastle</groupId>
-      <artifactId>bcprov-jdk15on</artifactId>
-    </dependency>
     <dependency>
       <groupId>io.airlift</groupId>
       <artifactId>airline</artifactId>
@@ -56,6 +52,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-assembly-plugin</artifactId>
+        <version>3.0.0</version>
         <configuration>
           <descriptorRefs>
             <descriptorRef>jar-with-dependencies</descriptorRef>
@@ -91,6 +88,18 @@
           <flags>-Xbootclasspath/p:$0</flags>
         </configuration>
       </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>okhttp3.curl</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/okcurl/src/main/java/okhttp3/curl/Main.java b/okcurl/src/main/java/okhttp3/curl/Main.java
index ddff8e6790..cee2600619 100644
--- a/okcurl/src/main/java/okhttp3/curl/Main.java
+++ b/okcurl/src/main/java/okhttp3/curl/Main.java
@@ -47,6 +47,7 @@
 import okhttp3.internal.Util;
 import okhttp3.internal.http.StatusLine;
 import okhttp3.internal.http2.Http2;
+import okhttp3.internal.platform.Platform;
 import okio.BufferedSource;
 import okio.Okio;
 import okio.Sink;
@@ -257,7 +258,7 @@ private static X509TrustManager createInsecureTrustManager() {
 
   private static SSLSocketFactory createInsecureSslSocketFactory(TrustManager trustManager) {
     try {
-      SSLContext context = SSLContext.getInstance("TLS");
+      SSLContext context = Platform.get().getSSLContext();
       context.init(null, new TrustManager[] {trustManager}, null);
       return context.getSocketFactory();
     } catch (Exception e) {
diff --git a/okhttp-android-support/pom.xml b/okhttp-android-support/pom.xml
index 7ac8a4d245..ecb19d47a6 100644
--- a/okhttp-android-support/pom.xml
+++ b/okhttp-android-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.6.0-SNAPSHOT</version>
+    <version>3.12.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-android-support</artifactId>
@@ -16,12 +16,23 @@
   </description>
 
   <dependencies>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>okhttp-testing-support</artifactId>
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-tls</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>okhttp-urlconnection</artifactId>
@@ -46,6 +57,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
         <configuration>
           <excludePackageNames>okhttp3.internal.*</excludePackageNames>
           <links>
@@ -53,6 +65,18 @@
           </links>
         </configuration>
       </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>okhttp3.androidsupport</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java b/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
index b65d463b51..1dec85cdc0 100644
--- a/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
+++ b/okhttp-android-support/src/main/java/okhttp3/internal/huc/JavaApiConverter.java
@@ -42,6 +42,7 @@
 import okhttp3.RequestBody;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
+import okhttp3.TlsVersion;
 import okhttp3.internal.Internal;
 import okhttp3.internal.JavaNetHeaders;
 import okhttp3.internal.Util;
@@ -133,7 +134,7 @@ public static Response createOkResponseForCachePut(URI uri, URLConnection urlCon
 
       String cipherSuiteString = httpsUrlConnection.getCipherSuite();
       CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
-      Handshake handshake = Handshake.get(null, cipherSuite,
+      Handshake handshake = Handshake.get(TlsVersion.SSL_3_0, cipherSuite,
           nullSafeImmutableList(peerCertificates), nullSafeImmutableList(localCertificates));
       okResponseBuilder.handshake(handshake);
     }
@@ -260,7 +261,8 @@ static Response createOkResponseForCacheGet(Request request, CacheResponse javaR
 
       String cipherSuiteString = javaSecureCacheResponse.getCipherSuite();
       CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
-      Handshake handshake = Handshake.get(null, cipherSuite, peerCertificates, localCertificates);
+      Handshake handshake = Handshake.get(
+          TlsVersion.SSL_3_0, cipherSuite, peerCertificates, localCertificates);
       okResponseBuilder.handshake(handshake);
     }
 
@@ -566,7 +568,7 @@ private static ResponseBody createOkBody(final URLConnection urlConnection) thro
     private final Request request;
     private final Response response;
 
-    public CacheHttpURLConnection(Response response) {
+    CacheHttpURLConnection(Response response) {
       super(response.request().url().url());
       this.request = response.request();
       this.response = response;
@@ -833,7 +835,7 @@ public void setDefaultUseCaches(boolean defaultUseCaches) {
   private static final class CacheHttpsURLConnection extends DelegatingHttpsURLConnection {
     private final CacheHttpURLConnection delegate;
 
-    public CacheHttpsURLConnection(CacheHttpURLConnection delegate) {
+    CacheHttpsURLConnection(CacheHttpURLConnection delegate) {
       super(delegate);
       this.delegate = delegate;
     }
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
index 53470ce87b..09a438807f 100644
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/CacheAdapterTest.java
@@ -35,14 +35,15 @@
 import okhttp3.RecordingHostnameVerifier;
 import okhttp3.internal.Internal;
 import okhttp3.internal.cache.InternalCache;
-import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
@@ -58,7 +59,7 @@
  * </ul>
  */
 public class CacheAdapterTest {
-  private SslClient sslClient = SslClient.localhost();
+  private HandshakeCertificates handshakeCertificates = localhost();
   private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
   private MockWebServer server;
   private OkHttpClient client;
@@ -123,7 +124,8 @@
     };
     setInternalCache(new CacheAdapter(responseCache));
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build();
 
@@ -253,7 +255,8 @@
     };
     setInternalCache(new CacheAdapter(responseCache));
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build();
 
@@ -281,7 +284,7 @@ private URL configureServer(MockResponse mockResponse) throws Exception {
   }
 
   private URL configureHttpsServer(MockResponse mockResponse) throws Exception {
-    server.useHttps(sslClient.socketFactory, false /* tunnelProxy */);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false /* tunnelProxy */);
     server.enqueue(mockResponse);
     server.start();
     return server.url("/").url();
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
index 353931a072..ad5d3fdfd3 100644
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/JavaApiConverterTest.java
@@ -47,6 +47,7 @@
 import okhttp3.RequestBody;
 import okhttp3.Response;
 import okhttp3.ResponseBody;
+import okhttp3.TlsVersion;
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.mockwebserver.MockWebServer;
@@ -464,7 +465,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
         .get()
         .url("https://secure/request")
         .build();
-    Handshake handshake = Handshake.get(null, CipherSuite.TLS_RSA_WITH_NULL_MD5,
+    Handshake handshake = Handshake.get(TlsVersion.SSL_3_0, CipherSuite.TLS_RSA_WITH_NULL_MD5,
         Arrays.<Certificate>asList(SERVER_CERT), Arrays.<Certificate>asList(LOCAL_CERT));
     Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
         .handshake(handshake)
@@ -554,7 +555,7 @@ private void assertHeadersContainsMapping(Map<String, List<String>> headers, Str
             .post(createRequestBody("RequestBody"))
             .build();
     ResponseBody responseBody = createResponseBody("ResponseBody");
-    Handshake handshake = Handshake.get(null, CipherSuite.TLS_RSA_WITH_NULL_MD5,
+    Handshake handshake = Handshake.get(TlsVersion.SSL_3_0, CipherSuite.TLS_RSA_WITH_NULL_MD5,
         Arrays.<Certificate>asList(SERVER_CERT), Arrays.<Certificate>asList(LOCAL_CERT));
     Response okResponse = createArbitraryOkResponse(okRequest).newBuilder()
         .protocol(Protocol.HTTP_1_1)
@@ -659,7 +660,7 @@ private static Response createArbitraryOkResponse() {
   }
 
   private static RequestBody createRequestBody(String bodyText) {
-    return RequestBody.create(MediaType.parse("text/plain"), bodyText);
+    return RequestBody.create(MediaType.get("text/plain"), bodyText);
   }
 
   private static ResponseBody createResponseBody(String bodyText) {
@@ -667,7 +668,7 @@ private static ResponseBody createResponseBody(String bodyText) {
     final long contentLength = source.size();
     return new ResponseBody() {
       @Override public MediaType contentType() {
-        return MediaType.parse("text/plain; charset=utf-8");
+        return MediaType.get("text/plain; charset=utf-8");
       }
 
       @Override public long contentLength() {
diff --git a/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
index 51bf46cc88..eb95e3ea4e 100644
--- a/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
+++ b/okhttp-android-support/src/test/java/okhttp3/internal/huc/ResponseCacheTest.java
@@ -26,13 +26,11 @@
 import java.net.CacheRequest;
 import java.net.CacheResponse;
 import java.net.CookieManager;
-import java.net.HttpCookie;
 import java.net.HttpURLConnection;
 import java.net.ProtocolException;
 import java.net.ResponseCache;
 import java.net.SecureCacheResponse;
 import java.net.URI;
-import java.net.URISyntaxException;
 import java.net.URL;
 import java.net.URLConnection;
 import java.nio.charset.StandardCharsets;
@@ -40,7 +38,6 @@
 import java.security.cert.Certificate;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Date;
 import java.util.LinkedHashMap;
@@ -63,11 +60,11 @@
 import okhttp3.RecordingHostnameVerifier;
 import okhttp3.internal.Internal;
 import okhttp3.internal.cache.InternalCache;
-import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.GzipSink;
@@ -78,6 +75,7 @@
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
 
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -96,7 +94,7 @@
   @Rule public MockWebServer server2 = new MockWebServer();
 
   private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-  private SslClient sslClient = SslClient.localhost();
+  private HandshakeCertificates handshakeCertificates = localhost();
   private ResponseCache cache;
   private CookieManager cookieManager;
   private OkUrlFactory urlFactory;
@@ -111,7 +109,7 @@
     cookieManager = new CookieManager();
   }
 
-  @After public void tearDown() throws Exception {
+  @After public void tearDown() {
     ResponseCache.setDefault(null);
   }
 
@@ -272,14 +270,14 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   @Test public void secureResponseCaching() throws IOException {
     assumeFalse(getPlatform().equals("jdk9"));
 
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
 
     HttpsURLConnection c1 = (HttpsURLConnection) openConnection(server.url("/").url());
-    c1.setSSLSocketFactory(sslClient.socketFactory);
+    c1.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     c1.setHostnameVerifier(hostnameVerifier);
     assertEquals("ABC", readAscii(c1));
 
@@ -291,7 +289,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     Principal localPrincipal = c1.getLocalPrincipal();
 
     HttpsURLConnection c2 = (HttpsURLConnection) openConnection(server.url("/").url()); // cached!
-    c2.setSSLSocketFactory(sslClient.socketFactory);
+    c2.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     c2.setHostnameVerifier(hostnameVerifier);
     assertEquals("ABC", readAscii(c2));
 
@@ -350,7 +348,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   }
 
   @Test public void secureResponseCachingAndRedirects() throws IOException {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
@@ -364,7 +362,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .setBody("DEF"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build());
 
@@ -388,7 +387,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
    * https://github.com/square/okhttp/issues/214
    */
   @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
-    server2.useHttps(sslClient.socketFactory, false);
+    server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server2.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
@@ -403,7 +402,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Location: " + server2.url("/").url()));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build());
 
@@ -480,7 +480,7 @@ private void temporaryRedirectNotCachedWithoutCachingHeader(int responseCode) th
     testServerPrematureDisconnect(TransferKind.CHUNKED);
   }
 
-  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() throws IOException {
+  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() {
     // Intentionally empty. This case doesn't make sense because there's no
     // such thing as a premature disconnect when the disconnect itself
     // indicates the end of the data stream.
@@ -1196,7 +1196,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
     Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
     DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
-    dateFormat.setTimeZone(TimeZone.getTimeZone("EDT"));
+    dateFormat.setTimeZone(TimeZone.getTimeZone("America/New_York"));
     String lastModifiedString = dateFormat.format(lastModifiedDate);
     String servedString = dateFormat.format(servedDate);
 
@@ -1466,7 +1466,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   @Test public void varyAndHttps() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()
         .addHeader("Cache-Control: max-age=60")
         .addHeader("Vary: Accept-Language")
@@ -1475,7 +1475,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("B"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build());
 
@@ -1563,14 +1564,6 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     assertEquals("299 test danger", connection2.getHeaderField("Warning"));
   }
 
-  public void assertCookies(URL url, String... expectedCookies) throws Exception {
-    List<String> actualCookies = new ArrayList<>();
-    for (HttpCookie cookie : cookieManager.getCookieStore().get(url.toURI())) {
-      actualCookies.add(cookie.toString());
-    }
-    assertEquals(Arrays.asList(expectedCookies), actualCookies);
-  }
-
   @Test public void doNotCachePartialResponse() throws Exception {
     assertNotCached(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
@@ -1674,7 +1667,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     assertEquals("A", readAscii(connection));
   }
 
-  @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
+  @Test public void emptyResponseHeaderNameFromCacheIsLenient() {
     Headers.Builder headers = new Headers.Builder()
         .add("Cache-Control: max-age=120");
     Internal.instance.addLenient(headers, ": A");
@@ -1769,8 +1762,7 @@ private MockResponse truncateViolently(MockResponse response, int numBytesToKeep
 
   enum TransferKind {
     CHUNKED() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
-          throws IOException {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setChunkedBody(content, chunkSize);
       }
     },
@@ -1795,7 +1787,7 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
   }
 
   /** Returns a gzipped copy of {@code bytes}. */
-  public Buffer gzip(String data) throws IOException {
+  private Buffer gzip(String data) throws IOException {
     Buffer result = new Buffer();
     BufferedSink sink = Okio.buffer(new GzipSink(result));
     sink.writeUtf8(data);
@@ -1898,7 +1890,7 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
             aborted.set(true);
           }
 
-          @Override public OutputStream getBody() throws IOException {
+          @Override public OutputStream getBody() {
             return null;
           }
         };
@@ -1924,10 +1916,9 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
     setInternalCache(new CacheAdapter(new AbstractResponseCache() {
       @Override
       public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders)
-          throws IOException {
+          Map<String, List<String>> requestHeaders) {
         return new CacheResponse() {
-          @Override public Map<String, List<String>> getHeaders() throws IOException {
+          @Override public Map<String, List<String>> getHeaders() {
             String contentType = "text/plain";
             Map<String, List<String>> headers = new LinkedHashMap<>();
             headers.put("Content-Length", Arrays.asList(Integer.toString(cachedContent.length)));
@@ -1939,7 +1930,7 @@ public CacheResponse get(URI uri, String requestMethod,
             return headers;
           }
 
-          @Override public InputStream getBody() throws IOException {
+          @Override public InputStream getBody() {
             return new ByteArrayInputStream(cachedContent);
           }
         };
@@ -1988,32 +1979,32 @@ private InsecureResponseCache(ResponseCache delegate) {
   @Test public void cacheReturnsInsecureResponseForSecureRequest() throws IOException {
     assumeFalse(getPlatform().equals("jdk9"));
 
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
 
     AndroidInternal.setResponseCache(urlFactory, new InsecureResponseCache(cache));
 
     HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.url("/").url());
-    connection1.setSSLSocketFactory(sslClient.socketFactory);
+    connection1.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     connection1.setHostnameVerifier(hostnameVerifier);
     assertEquals("ABC", readAscii(connection1));
 
     // Not cached!
     HttpsURLConnection connection2 = (HttpsURLConnection) openConnection(server.url("/").url());
-    connection2.setSSLSocketFactory(sslClient.socketFactory);
+    connection2.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     connection2.setHostnameVerifier(hostnameVerifier);
     assertEquals("DEF", readAscii(connection2));
   }
 
-  @Test public void responseCacheRequestHeaders() throws IOException, URISyntaxException {
+  @Test public void responseCacheRequestHeaders() throws IOException {
     server.enqueue(new MockResponse()
         .setBody("ABC"));
 
     final AtomicReference<Map<String, List<String>>> requestHeadersRef = new AtomicReference<>();
     setInternalCache(new CacheAdapter(new AbstractResponseCache() {
       @Override public CacheResponse get(URI uri, String requestMethod,
-          Map<String, List<String>> requestHeaders) throws IOException {
+          Map<String, List<String>> requestHeaders) {
         requestHeadersRef.set(requestHeaders);
         return null;
       }
diff --git a/okhttp-apache/pom.xml b/okhttp-apache/pom.xml
index 4c1de9241f..85c666ba92 100644
--- a/okhttp-apache/pom.xml
+++ b/okhttp-apache/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.6.0-SNAPSHOT</version>
+    <version>3.12.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-apache</artifactId>
@@ -48,6 +48,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
         <configuration>
           <links>
             <link>http://square.github.io/okhttp/javadoc/</link>
@@ -56,6 +57,18 @@
           </links>
         </configuration>
       </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>okhttp3.apache</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java b/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java
index 45d27aafd1..c55543f569 100644
--- a/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java
+++ b/okhttp-apache/src/main/java/okhttp3/apache/HttpEntityBody.java
@@ -8,7 +8,7 @@
 
 /** Adapts an {@link HttpEntity} to OkHttp's {@link RequestBody}. */
 final class HttpEntityBody extends RequestBody {
-  private static final MediaType DEFAULT_MEDIA_TYPE = MediaType.parse("application/octet-stream");
+  private static final MediaType DEFAULT_MEDIA_TYPE = MediaType.get("application/octet-stream");
 
   private final HttpEntity entity;
   private final MediaType mediaType;
diff --git a/okhttp-dnsoverhttps/README.md b/okhttp-dnsoverhttps/README.md
new file mode 100644
index 0000000000..30132b47c8
--- /dev/null
+++ b/okhttp-dnsoverhttps/README.md
@@ -0,0 +1,5 @@
+OkHttp DNS over HTTPS Implementation
+====================================
+
+This module is an experimental implementation of DNS over HTTPS using OkHttp.
+API is not considered stable and may change at any time.
diff --git a/okhttp-dnsoverhttps/pom.xml b/okhttp-dnsoverhttps/pom.xml
new file mode 100644
index 0000000000..2fb9c3db1a
--- /dev/null
+++ b/okhttp-dnsoverhttps/pom.xml
@@ -0,0 +1,67 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.12.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-dnsoverhttps</artifactId>
+  <name>OkHttp DNS over HTTPS</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.conscrypt</groupId>
+      <artifactId>conscrypt-openjdk-uber</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>okhttp3.dnsoverhttps</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/BootstrapDns.java b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/BootstrapDns.java
new file mode 100644
index 0000000000..2cd474d30b
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/BootstrapDns.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.dnsoverhttps;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.List;
+import okhttp3.Dns;
+
+/**
+ * Internal Bootstrap DNS implementation for handling initial connection to DNS over HTTPS server.
+ *
+ * Returns hardcoded results for the known host.
+ */
+final class BootstrapDns implements Dns {
+  private final String dnsHostname;
+  private final List<InetAddress> dnsServers;
+
+  BootstrapDns(String dnsHostname, List<InetAddress> dnsServers) {
+    this.dnsHostname = dnsHostname;
+    this.dnsServers = dnsServers;
+  }
+
+  @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+    if (!this.dnsHostname.equals(hostname)) {
+      throw new UnknownHostException(
+          "BootstrapDns called for " + hostname + " instead of " + dnsHostname);
+    }
+
+    return dnsServers;
+  }
+}
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.java b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.java
new file mode 100644
index 0000000000..f19b37361e
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsOverHttps.java
@@ -0,0 +1,285 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.dnsoverhttps;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
+import okhttp3.CacheControl;
+import okhttp3.Dns;
+import okhttp3.HttpUrl;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.platform.Platform;
+import okhttp3.internal.publicsuffix.PublicSuffixDatabase;
+import okio.ByteString;
+
+/**
+ * DNS over HTTPS implementation.
+ *
+ * Implementation of https://tools.ietf.org/html/draft-ietf-doh-dns-over-https-11
+ *
+ * <blockquote>A DNS API client encodes a single DNS query into an HTTP request
+ * using either the HTTP GET or POST method and the other requirements
+ * of this section.  The DNS API server defines the URI used by the
+ * request through the use of a URI Template.</blockquote>
+ *
+ * <h3>Warning: This is a non-final API.</h3>
+ *
+ * <p><strong>As of OkHttp 3.11, this feature is an unstable preview: the API is subject to change,
+ * and the implementation is incomplete. We expect that OkHttp 3.12 or 3.13 will finalize this API.
+ * Until then, expect API and behavior changes when you update your OkHttp dependency.</strong>
+ */
+public class DnsOverHttps implements Dns {
+  public static final MediaType DNS_MESSAGE = MediaType.get("application/dns-message");
+  public static final MediaType UDPWIREFORMAT = MediaType.get("application/dns-udpwireformat");
+  public static final int MAX_RESPONSE_SIZE = 64 * 1024;
+  private final OkHttpClient client;
+  private final HttpUrl url;
+  private final boolean includeIPv6;
+  private final boolean post;
+  private final MediaType contentType;
+  private final boolean resolvePrivateAddresses;
+  private final boolean resolvePublicAddresses;
+
+  DnsOverHttps(Builder builder) {
+    if (builder.client == null) {
+      throw new NullPointerException("client not set");
+    }
+    if (builder.url == null) {
+      throw new NullPointerException("url not set");
+    }
+
+    this.url = builder.url;
+    this.includeIPv6 = builder.includeIPv6;
+    this.post = builder.post;
+    this.contentType = builder.contentType;
+    this.resolvePrivateAddresses = builder.resolvePrivateAddresses;
+    this.resolvePublicAddresses = builder.resolvePublicAddresses;
+    this.client = builder.client.newBuilder().dns(buildBootstrapClient(builder)).build();
+  }
+
+  private static Dns buildBootstrapClient(Builder builder) {
+    List<InetAddress> hosts = builder.bootstrapDnsHosts;
+
+    if (hosts != null) {
+      return new BootstrapDns(builder.url.host(), hosts);
+    } else {
+      return builder.systemDns;
+    }
+  }
+
+  public HttpUrl url() {
+    return url;
+  }
+
+  public boolean post() {
+    return post;
+  }
+
+  public boolean includeIPv6() {
+    return includeIPv6;
+  }
+
+  public MediaType contentType() {
+    return contentType;
+  }
+
+  public OkHttpClient client() {
+    return client;
+  }
+
+  public boolean resolvePrivateAddresses() {
+    return resolvePrivateAddresses;
+  }
+
+  public boolean resolvePublicAddresses() {
+    return resolvePublicAddresses;
+  }
+
+  @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
+    UnknownHostException firstUhe = null;
+
+    if (!resolvePrivateAddresses || !resolvePublicAddresses) {
+      boolean privateHost = isPrivateHost(hostname);
+
+      if (privateHost && !resolvePrivateAddresses) {
+        throw new UnknownHostException("private hosts not resolved");
+      }
+
+      if (!privateHost && !resolvePublicAddresses) {
+        throw new UnknownHostException("public hosts not resolved");
+      }
+    }
+
+    return lookupHttps(hostname);
+  }
+
+  private List<InetAddress> lookupHttps(String hostname) throws UnknownHostException {
+    try {
+      ByteString query = DnsRecordCodec.encodeQuery(hostname, includeIPv6);
+
+      Request request = buildRequest(query);
+      Response response = executeRequest(request);
+
+      return readResponse(hostname, response);
+    } catch (UnknownHostException uhe) {
+      throw uhe;
+    } catch (Exception e) {
+      UnknownHostException unknownHostException = new UnknownHostException(hostname);
+      unknownHostException.initCause(e);
+      throw unknownHostException;
+    }
+  }
+
+  private Response executeRequest(Request request) throws IOException {
+    // cached request
+    if (!post && client.cache() != null) {
+      CacheControl cacheControl =
+          new CacheControl.Builder().maxStale(Integer.MAX_VALUE, TimeUnit.SECONDS).build();
+      Request cacheRequest = request.newBuilder().cacheControl(cacheControl).build();
+
+      Response response = client.newCall(cacheRequest).execute();
+
+      if (response.isSuccessful()) {
+        return response;
+      }
+    }
+
+    return client.newCall(request).execute();
+  }
+
+  private List<InetAddress> readResponse(String hostname, Response response) throws Exception {
+    if (response.cacheResponse() == null && response.protocol() != Protocol.HTTP_2) {
+      Platform.get().log(Platform.WARN, "Incorrect protocol: " + response.protocol(), null);
+    }
+
+    try {
+      if (!response.isSuccessful()) {
+        throw new IOException("response: " + response.code() + " " + response.message());
+      }
+
+      ResponseBody body = response.body();
+
+      if (body.contentLength() > MAX_RESPONSE_SIZE) {
+        throw new IOException("response size exceeds limit ("
+            + MAX_RESPONSE_SIZE
+            + " bytes): "
+            + body.contentLength()
+            + " bytes");
+      }
+
+      ByteString responseBytes = body.source().readByteString();
+
+      return DnsRecordCodec.decodeAnswers(hostname, responseBytes);
+    } finally {
+      response.close();
+    }
+  }
+
+  private Request buildRequest(ByteString query) {
+    Request.Builder requestBuilder = new Request.Builder().header("Accept", contentType.toString());
+
+    if (post) {
+      requestBuilder = requestBuilder.url(url).post(RequestBody.create(contentType, query));
+    } else {
+      String encoded = query.base64Url().replace("=", "");
+      HttpUrl requestUrl = url.newBuilder().addQueryParameter("dns", encoded).build();
+
+      requestBuilder = requestBuilder.url(requestUrl);
+    }
+
+    return requestBuilder.build();
+  }
+
+  static boolean isPrivateHost(String host) {
+    return PublicSuffixDatabase.get().getEffectiveTldPlusOne(host) == null;
+  }
+
+  public static final class Builder {
+    @Nullable OkHttpClient client = null;
+    @Nullable HttpUrl url = null;
+    boolean includeIPv6 = true;
+    boolean post = false;
+    MediaType contentType = DNS_MESSAGE;
+    Dns systemDns = Dns.SYSTEM;
+    @Nullable List<InetAddress> bootstrapDnsHosts = null;
+    boolean resolvePrivateAddresses = false;
+    boolean resolvePublicAddresses = true;
+
+    public DnsOverHttps build() {
+      return new DnsOverHttps(this);
+    }
+
+    public Builder client(OkHttpClient client) {
+      this.client = client;
+      return this;
+    }
+
+    public Builder url(HttpUrl url) {
+      this.url = url;
+      return this;
+    }
+
+    public Builder includeIPv6(boolean includeIPv6) {
+      this.includeIPv6 = includeIPv6;
+      return this;
+    }
+
+    public Builder post(boolean post) {
+      this.post = post;
+      return this;
+    }
+
+    public Builder contentType(MediaType contentType) {
+      this.contentType = contentType;
+      return this;
+    }
+
+    public Builder resolvePrivateAddresses(boolean resolvePrivateAddresses) {
+      this.resolvePrivateAddresses = resolvePrivateAddresses;
+      return this;
+    }
+
+    public Builder resolvePublicAddresses(boolean resolvePublicAddresses) {
+      this.resolvePublicAddresses = resolvePublicAddresses;
+      return this;
+    }
+
+    public Builder bootstrapDnsHosts(@Nullable List<InetAddress> bootstrapDnsHosts) {
+      this.bootstrapDnsHosts = bootstrapDnsHosts;
+      return this;
+    }
+
+    public Builder bootstrapDnsHosts(InetAddress... bootstrapDnsHosts) {
+      return bootstrapDnsHosts(Arrays.asList(bootstrapDnsHosts));
+    }
+
+    public Builder systemDns(Dns systemDns) {
+      this.systemDns = systemDns;
+      return this;
+    }
+  }
+}
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.java b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.java
new file mode 100644
index 0000000000..271a05446c
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/DnsRecordCodec.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright 2016 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License, version 2.0 (the
+ * "License"); you may not use this file except in compliance with the License. You may obtain a
+ * copy of the License at:
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License
+ * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+ * or implied. See the License for the specific language governing permissions and limitations under
+ * the License.
+ */
+
+package okhttp3.dnsoverhttps;
+
+import java.io.EOFException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.List;
+import okio.Buffer;
+import okio.ByteString;
+import okio.Utf8;
+
+/**
+ * Trivial Dns Encoder/Decoder, basically ripped from Netty full implementation.
+ */
+class DnsRecordCodec {
+  private static final byte SERVFAIL = 2;
+  private static final byte NXDOMAIN = 3;
+  private static final int TYPE_A = 0x0001;
+  private static final int TYPE_AAAA = 0x001c;
+  private static final int TYPE_PTR = 0x000c;
+  private static final Charset ASCII = Charset.forName("ASCII");
+
+  private DnsRecordCodec() {
+  }
+
+  public static ByteString encodeQuery(String host, boolean includeIPv6) {
+    Buffer buf = new Buffer();
+
+    buf.writeShort(0); // query id
+    buf.writeShort(256); // flags with recursion
+    buf.writeShort(includeIPv6 ? 2 : 1); // question count
+    buf.writeShort(0); // answerCount
+    buf.writeShort(0); // authorityResourceCount
+    buf.writeShort(0); // additional
+
+    Buffer nameBuf = new Buffer();
+    final String[] labels = host.split("\\.");
+    for (String label : labels) {
+      long utf8ByteCount = Utf8.size(label);
+      if (utf8ByteCount != label.length()) {
+        throw new IllegalArgumentException("non-ascii hostname: " + host);
+      }
+      nameBuf.writeByte((byte) utf8ByteCount);
+      nameBuf.writeUtf8(label);
+    }
+    nameBuf.writeByte(0); // end
+
+    nameBuf.copyTo(buf, 0, nameBuf.size());
+    buf.writeShort(TYPE_A);
+    buf.writeShort(1); // CLASS_IN
+
+    if (includeIPv6) {
+      nameBuf.copyTo(buf, 0, nameBuf.size());
+      buf.writeShort(TYPE_AAAA);
+      buf.writeShort(1); // CLASS_IN
+    }
+
+    return buf.readByteString();
+  }
+
+  public static List<InetAddress> decodeAnswers(String hostname, ByteString byteString)
+      throws Exception {
+    List<InetAddress> result = new ArrayList<>();
+
+    Buffer buf = new Buffer();
+    buf.write(byteString);
+    buf.readShort(); // query id
+
+    final int flags = buf.readShort() & 0xffff;
+    if (flags >> 15 == 0) {
+      throw new IllegalArgumentException("not a response");
+    }
+
+    byte responseCode = (byte) (flags & 0xf);
+
+    if (responseCode == NXDOMAIN) {
+      throw new UnknownHostException(hostname + ": NXDOMAIN");
+    } else if (responseCode == SERVFAIL) {
+      throw new UnknownHostException(hostname + ": SERVFAIL");
+    }
+
+    final int questionCount = buf.readShort() & 0xffff;
+    final int answerCount = buf.readShort() & 0xffff;
+    buf.readShort(); // authority record count
+    buf.readShort(); // additional record count
+
+    for (int i = 0; i < questionCount; i++) {
+      skipName(buf); // name
+      buf.readShort(); // type
+      buf.readShort(); // class
+    }
+
+    for (int i = 0; i < answerCount; i++) {
+      skipName(buf); // name
+
+      int type = buf.readShort() & 0xffff;
+      buf.readShort(); // class
+      final long ttl = buf.readInt() & 0xffffffffL; // ttl
+      final int length = buf.readShort() & 0xffff;
+
+      if (type == TYPE_A || type == TYPE_AAAA) {
+        byte[] bytes = new byte[length];
+        buf.read(bytes);
+        result.add(InetAddress.getByAddress(bytes));
+      } else {
+        buf.skip(length);
+      }
+    }
+
+    return result;
+  }
+
+  private static void skipName(Buffer in) throws EOFException {
+    // 0 - 63 bytes
+    int length = in.readByte();
+
+    if (length < 0) {
+      // compressed name pointer, first two bits are 1
+      // drop second byte of compression offset
+      in.skip(1);
+    } else {
+      while (length > 0) {
+        // skip each part of the domain name
+        in.skip(length);
+        length = in.readByte();
+      }
+    }
+  }
+}
diff --git a/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.java b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.java
new file mode 100644
index 0000000000..1469a3bfa4
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/main/java/okhttp3/dnsoverhttps/package-info.java
@@ -0,0 +1,3 @@
+/** A DNS over HTTPS implementation for OkHttp. */
+@javax.annotation.ParametersAreNonnullByDefault
+package okhttp3.dnsoverhttps;
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsOverHttpsTest.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsOverHttpsTest.java
new file mode 100644
index 0000000000..31c8da16ca
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsOverHttpsTest.java
@@ -0,0 +1,189 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.dnsoverhttps;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.List;
+import okhttp3.Cache;
+import okhttp3.Dns;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okio.Buffer;
+import okio.ByteString;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static java.util.Collections.singletonList;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public class DnsOverHttpsTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private final OkHttpClient bootstrapClient =
+      new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1))
+          .build();
+  private final Dns dns = buildLocalhost(bootstrapClient);
+
+  @Before public void setUp() {
+    server.setProtocols(bootstrapClient.protocols());
+  }
+
+  @Test public void getOne() throws Exception {
+    server.enqueue(dnsResponse(
+        "0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010001c00c00050001"
+            + "00000a6d000603617069c012c0300005000100000cde000c04737461720463313072c012c04200010"
+            + "0010000003b00049df00112"));
+
+    List<InetAddress> result = dns.lookup("google.com");
+
+    assertEquals(singletonList(address("157.240.1.18")), result);
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("GET", recordedRequest.getMethod());
+    assertEquals("/lookup?ct&dns=AAABAAACAAAAAAAABmdvb2dsZQNjb20AAAEAAQZnb29nbGUDY29t"
+        + "AAAcAAE", recordedRequest.getPath());
+  }
+
+  @Test public void getIpv6() throws Exception {
+    server.enqueue(dnsResponse(
+        "0000818000010003000000000567726170680866616365626f6f6b03636f6d00001c0001c00c00050001"
+            + "00000a1b000603617069c012c0300005000100000b1f000c04737461720463313072c012c042001c0"
+            + "0010000003b00102a032880f0290011faceb00c00000002"));
+
+    List<InetAddress> result = dns.lookup("google.com");
+
+    assertEquals(singletonList(address("2a03:2880:f029:11:face:b00c:0:2")), result);
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("GET", recordedRequest.getMethod());
+    assertEquals("/lookup?ct&dns=AAABAAACAAAAAAAABmdvb2dsZQNjb20AAAEAAQZnb29nbGUDY29t"
+        + "AAAcAAE", recordedRequest.getPath());
+  }
+
+  @Test public void failure() throws Exception {
+    server.enqueue(dnsResponse(
+        "0000818300010000000100000e7364666c6b686673646c6b6a64660265650000010001c01b00060001"
+            + "000007070038026e7303746c64c01b0a686f73746d61737465720d6565737469696e7465726e657"
+            + "4c01b5adb12c100000e10000003840012750000000e10"));
+
+    try {
+      dns.lookup("google.com");
+      fail();
+    } catch (UnknownHostException uhe) {
+      uhe.printStackTrace();
+      assertEquals("google.com: NXDOMAIN", uhe.getMessage());
+    }
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("GET", recordedRequest.getMethod());
+    assertEquals("/lookup?ct&dns=AAABAAACAAAAAAAABmdvb2dsZQNjb20AAAEAAQZnb29nbGUDY29t"
+        + "AAAcAAE", recordedRequest.getPath());
+  }
+
+  @Test public void failOnExcessiveResponse() {
+    char[] array = new char[128 * 1024 + 2];
+    Arrays.fill(array, '0');
+    server.enqueue(dnsResponse(new String(array)));
+
+    try {
+      dns.lookup("google.com");
+      fail();
+    } catch (IOException ioe) {
+      assertEquals("google.com", ioe.getMessage());
+      Throwable cause = ioe.getCause();
+      assertTrue(cause instanceof IOException);
+      assertEquals("response size exceeds limit (65536 bytes): 65537 bytes", cause.getMessage());
+    }
+  }
+
+  @Test public void failOnBadResponse() {
+    server.enqueue(dnsResponse("00"));
+
+    try {
+      dns.lookup("google.com");
+      fail();
+    } catch (IOException ioe) {
+      assertEquals("google.com", ioe.getMessage());
+      Throwable cause = ioe.getCause();
+      assertTrue(cause instanceof RuntimeException);
+    }
+  }
+
+  // TODO GET preferred order - with tests to confirm this
+  // 1. successful fresh cached GET response
+  // 2. unsuccessful (404, 500) fresh cached GET response
+  // 3. successful network response
+  // 4. successful stale cached GET response
+  // 5. unsuccessful response
+
+  // TODO how closely to follow POST rules on caching?
+
+  @Test public void usesCache() throws Exception {
+    Cache cache = new Cache(new File("./target/DnsOverHttpsTest.cache"), 100 * 1024);
+    OkHttpClient cachedClient = bootstrapClient.newBuilder().cache(cache).build();
+    DnsOverHttps cachedDns = buildLocalhost(cachedClient);
+
+    server.enqueue(dnsResponse(
+        "0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010001c00c00050001"
+            + "00000a6d000603617069c012c0300005000100000cde000c04737461720463313072c012c04200010"
+            + "0010000003b00049df00112")
+        .setHeader("cache-control", "private, max-age=298"));
+
+    List<InetAddress> result = cachedDns.lookup("google.com");
+
+    assertEquals(singletonList(address("157.240.1.18")), result);
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("GET", recordedRequest.getMethod());
+    assertEquals("/lookup?ct&dns=AAABAAACAAAAAAAABmdvb2dsZQNjb20AAAEAAQZnb29nbGUDY29t"
+        + "AAAcAAE", recordedRequest.getPath());
+
+    result = cachedDns.lookup("google.com");
+    assertEquals(singletonList(address("157.240.1.18")), result);
+  }
+
+  private MockResponse dnsResponse(String s) {
+    return new MockResponse()
+        .setBody(new Buffer().write(ByteString.decodeHex(s)))
+        .addHeader("content-type", "application/dns-message")
+        .addHeader("content-length", s.length() / 2);
+  }
+
+  private DnsOverHttps buildLocalhost(OkHttpClient bootstrapClient) {
+    HttpUrl url = server.url("/lookup?ct");
+    return new DnsOverHttps.Builder().client(bootstrapClient).resolvePrivateAddresses(true).url(url).build();
+  }
+
+  private static InetAddress address(String host) {
+    try {
+      return InetAddress.getByName(host);
+    } catch (UnknownHostException e) {
+      // impossible for IP addresses
+      throw new RuntimeException(e);
+    }
+  }
+}
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java
new file mode 100644
index 0000000000..32700c2664
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DnsRecordCodecTest.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.dnsoverhttps;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.Collections;
+import java.util.List;
+import okio.ByteString;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public class DnsRecordCodecTest {
+  @Test public void testGoogleDotComEncoding() {
+    String encoded = encodeQuery("google.com", false);
+
+    assertEquals("AAABAAABAAAAAAAABmdvb2dsZQNjb20AAAEAAQ", encoded);
+  }
+
+  private String encodeQuery(String host, boolean includeIpv6) {
+    return DnsRecordCodec.encodeQuery(host, includeIpv6).base64Url().replace("=", "");
+  }
+
+  @Test public void testGoogleDotComEncodingWithIPv6() {
+    String encoded = encodeQuery("google.com", true);
+
+    assertEquals("AAABAAACAAAAAAAABmdvb2dsZQNjb20AAAEAAQZnb29nbGUDY29tAAAcAAE", encoded);
+  }
+
+  @Test public void testGoogleDotComDecodingFromCloudflare() throws Exception {
+    List<InetAddress> encoded = DnsRecordCodec.decodeAnswers("test.com", ByteString.decodeHex(
+        "00008180000100010000000006676f6f676c6503636f6d0000010001c00c00010001000000430004d83ad54e"));
+
+    assertEquals(Collections.singletonList(InetAddress.getByName("216.58.213.78")), encoded);
+  }
+
+  @Test public void testGoogleDotComDecodingFromGoogle() throws Exception {
+    List<InetAddress> decoded = DnsRecordCodec.decodeAnswers("test.com", ByteString.decodeHex(
+        "0000818000010003000000000567726170680866616365626f6f6b03636f6d0000010001c00c0005000100000a6d000603617069c012c0300005000100000cde000c04737461720463313072c012c042000100010000003b00049df00112"));
+
+    assertEquals(Collections.singletonList(InetAddress.getByName("157.240.1.18")), decoded);
+  }
+
+  @Test public void testGoogleDotComDecodingFromGoogleIPv6() throws Exception {
+    List<InetAddress> decoded = DnsRecordCodec.decodeAnswers("test.com", ByteString.decodeHex(
+        "0000818000010003000000000567726170680866616365626f6f6b03636f6d00001c0001c00c0005000100000a1b000603617069c012c0300005000100000b1f000c04737461720463313072c012c042001c00010000003b00102a032880f0290011faceb00c00000002"));
+
+    assertEquals(
+        Collections.singletonList(InetAddress.getByName("2a03:2880:f029:11:face:b00c:0:2")),
+        decoded);
+  }
+
+  @Test public void testGoogleDotComDecodingNxdomainFailure() throws Exception {
+    try {
+      DnsRecordCodec.decodeAnswers("sdflkhfsdlkjdf.ee", ByteString.decodeHex(
+          "0000818300010000000100000e7364666c6b686673646c6b6a64660265650000010001c01b00060001000007070038026e7303746c64c01b0a686f73746d61737465720d6565737469696e7465726e6574c01b5adb12c100000e10000003840012750000000e10"));
+      fail();
+    } catch (UnknownHostException uhe) {
+      assertEquals("sdflkhfsdlkjdf.ee: NXDOMAIN", uhe.getMessage());
+    }
+  }
+}
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DohProviders.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DohProviders.java
new file mode 100644
index 0000000000..0509e6002e
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/DohProviders.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.dnsoverhttps;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.util.ArrayList;
+import java.util.List;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+
+import static okhttp3.dnsoverhttps.DnsOverHttps.UDPWIREFORMAT;
+
+/**
+ * Temporary registry of known DNS over HTTPS providers.
+ *
+ * https://github.com/curl/curl/wiki/DNS-over-HTTPS
+ */
+public class DohProviders {
+  static DnsOverHttps buildGoogle(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://dns.google.com/experimental?ct=" + UDPWIREFORMAT))
+        .bootstrapDnsHosts(getByIp("216.58.204.78"), getByIp("2a00:1450:4009:814:0:0:0:200e"))
+        .contentType(UDPWIREFORMAT)
+        .build();
+  }
+
+  static DnsOverHttps buildGooglePost(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://dns.google.com/experimental"))
+        .bootstrapDnsHosts(getByIp("216.58.204.78"), getByIp("2a00:1450:4009:814:0:0:0:200e"))
+        .post(true)
+        .contentType(UDPWIREFORMAT)
+        .build();
+  }
+
+  static DnsOverHttps buildCloudflareIp(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://1.1.1.1/dns-query"))
+        .includeIPv6(false)
+        .build();
+  }
+
+  static DnsOverHttps buildCloudflare(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://cloudflare-dns.com/dns-query"))
+        .bootstrapDnsHosts(getByIp("1.1.1.1"))
+        .includeIPv6(false)
+        .build();
+  }
+
+  static DnsOverHttps buildCloudflarePost(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://cloudflare-dns.com/dns-query?ct=application/dns-udpwireformat"))
+        .bootstrapDnsHosts(getByIp("104.16.111.25"), getByIp("104.16.112.25"),
+            getByIp("2400:cb00:2048:1:0:0:6810:7019"), getByIp("2400:cb00:2048:1:0:0:6810:6f19"))
+        .includeIPv6(false)
+        .post(true)
+        .build();
+  }
+
+  static DnsOverHttps buildCleanBrowsing(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://doh.cleanbrowsing.org/doh/family-filter"))
+        .includeIPv6(false)
+        .build();
+  }
+
+  static DnsOverHttps buildChantra(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://dns.dnsoverhttps.net/dns-query"))
+        .includeIPv6(false)
+        .build();
+  }
+
+  static DnsOverHttps buildCryptoSx(OkHttpClient bootstrapClient) {
+    return new DnsOverHttps.Builder().client(bootstrapClient)
+        .url(HttpUrl.get("https://doh.crypto.sx/dns-query"))
+        .includeIPv6(false)
+        .build();
+  }
+
+  public static List<DnsOverHttps> providers(OkHttpClient client, boolean http2Only,
+      boolean workingOnly, boolean getOnly) {
+
+    List<DnsOverHttps> result = new ArrayList<>();
+
+    result.add(buildGoogle(client));
+    if (!getOnly) {
+      result.add(buildGooglePost(client));
+    }
+    result.add(buildCloudflare(client));
+    result.add(buildCloudflareIp(client));
+    if (!getOnly) {
+      result.add(buildCloudflarePost(client));
+    }
+    result.add(buildCleanBrowsing(client));
+    if (!workingOnly) {
+      result.add(buildCryptoSx(client)); // 521 - server down
+      result.add(buildChantra(client)); // 400
+    }
+
+    return result;
+  }
+
+  private static InetAddress getByIp(String host) {
+    try {
+      return InetAddress.getByName(host);
+    } catch (UnknownHostException e) {
+      // unlikely
+      throw new RuntimeException(e);
+    }
+  }
+}
diff --git a/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/TestDohMain.java b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/TestDohMain.java
new file mode 100644
index 0000000000..3c93dfeb91
--- /dev/null
+++ b/okhttp-dnsoverhttps/src/test/java/okhttp3/dnsoverhttps/TestDohMain.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.dnsoverhttps;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.security.Security;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import okhttp3.Cache;
+import okhttp3.HttpUrl;
+import okhttp3.OkHttpClient;
+
+import static okhttp3.dnsoverhttps.DnsOverHttps.UDPWIREFORMAT;
+
+public class TestDohMain {
+  public static void main(String[] args) throws IOException {
+    Security.insertProviderAt(new org.conscrypt.OpenSSLProvider(), 1);
+
+    OkHttpClient bootstrapClient = new OkHttpClient.Builder().build();
+
+    List<String> names = Arrays.asList("google.com", "graph.facebook.com", "sdflkhfsdlkjdf.ee");
+
+    try {
+      System.out.println("uncached\n********\n");
+      List<DnsOverHttps> dnsProviders =
+          DohProviders.providers(bootstrapClient, false, false, false);
+      runBatch(dnsProviders, names);
+
+      Cache dnsCache =
+          new Cache(new File("./target/TestDohMain.cache." + System.currentTimeMillis()),
+              10 * 1024 * 1024);
+
+      System.out.println("Bad targets\n***********\n");
+
+      HttpUrl url = HttpUrl.get("https://dns.cloudflare.com/.not-so-well-known/run-dmc-query");
+      List<DnsOverHttps> badProviders = Collections.singletonList(
+          new DnsOverHttps.Builder().client(bootstrapClient)
+              .url(url)
+              .post(true)
+              .contentType(UDPWIREFORMAT)
+              .build());
+      runBatch(badProviders, names);
+
+      System.out.println("cached first run\n****************\n");
+      names = Arrays.asList("google.com", "graph.facebook.com");
+      bootstrapClient = bootstrapClient.newBuilder().cache(dnsCache).build();
+      dnsProviders = DohProviders.providers(bootstrapClient, true, true, true);
+      runBatch(dnsProviders, names);
+
+      System.out.println("cached second run\n*****************\n");
+      dnsProviders = DohProviders.providers(bootstrapClient, true, true, true);
+      runBatch(dnsProviders, names);
+    } finally {
+      bootstrapClient.connectionPool().evictAll();
+      bootstrapClient.dispatcher().executorService().shutdownNow();
+      Cache cache = bootstrapClient.cache();
+      if (cache != null) {
+        cache.close();
+      }
+    }
+  }
+
+  private static void runBatch(List<DnsOverHttps> dnsProviders, List<String> names) {
+    long time = System.currentTimeMillis();
+
+    for (DnsOverHttps dns : dnsProviders) {
+      System.out.println("Testing " + dns.url());
+
+      for (String host : names) {
+        System.out.print(host + ": ");
+        System.out.flush();
+
+        try {
+          List<InetAddress> results = dns.lookup(host);
+          System.out.println(results);
+        } catch (UnknownHostException uhe) {
+          Throwable e = uhe;
+
+          while (e != null) {
+            System.out.println(e.toString());
+
+            e = e.getCause();
+          }
+        }
+      }
+
+      System.out.println();
+    }
+
+    time = System.currentTimeMillis() - time;
+
+    System.out.println("Time: " + (((double) time) / 1000) + " seconds\n");
+  }
+}
diff --git a/okhttp-logging-interceptor/README.md b/okhttp-logging-interceptor/README.md
index 1c5dcd952a..f312938fd1 100644
--- a/okhttp-logging-interceptor/README.md
+++ b/okhttp-logging-interceptor/README.md
@@ -42,7 +42,7 @@ Get via Maven:
 
 or via Gradle 
 ```groovy
-compile 'com.squareup.okhttp3:logging-interceptor:(insert latest version)'
+implementation 'com.squareup.okhttp3:logging-interceptor:(insert latest version)'
 ```
 
 
diff --git a/okhttp-logging-interceptor/pom.xml b/okhttp-logging-interceptor/pom.xml
index bec052a7ae..0e35c12c7b 100644
--- a/okhttp-logging-interceptor/pom.xml
+++ b/okhttp-logging-interceptor/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.6.0-SNAPSHOT</version>
+    <version>3.12.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>logging-interceptor</artifactId>
@@ -18,6 +18,11 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -36,5 +41,28 @@
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-tls</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>okhttp3.logging</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
index c5217b16c9..e088ea7c64 100644
--- a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/HttpLoggingInterceptor.java
@@ -18,14 +18,12 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.nio.charset.Charset;
-import java.nio.charset.UnsupportedCharsetException;
 import java.util.concurrent.TimeUnit;
 import okhttp3.Connection;
 import okhttp3.Headers;
 import okhttp3.Interceptor;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
-import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
@@ -34,6 +32,7 @@
 import okhttp3.internal.platform.Platform;
 import okio.Buffer;
 import okio.BufferedSource;
+import okio.GzipSource;
 
 import static okhttp3.internal.platform.Platform.INFO;
 
@@ -152,8 +151,10 @@ public Level getLevel() {
     boolean hasRequestBody = requestBody != null;
 
     Connection connection = chain.connection();
-    Protocol protocol = connection != null ? connection.protocol() : Protocol.HTTP_1_1;
-    String requestStartMessage = "--> " + request.method() + ' ' + request.url() + ' ' + protocol;
+    String requestStartMessage = "--> "
+        + request.method()
+        + ' ' + request.url()
+        + (connection != null ? " " + connection.protocol() : "");
     if (!logHeaders && hasRequestBody) {
       requestStartMessage += " (" + requestBody.contentLength() + "-byte body)";
     }
@@ -182,7 +183,7 @@ public Level getLevel() {
 
       if (!logBody || !hasRequestBody) {
         logger.log("--> END " + request.method());
-      } else if (bodyEncoded(request.headers())) {
+      } else if (bodyHasUnknownEncoding(request.headers())) {
         logger.log("--> END " + request.method() + " (encoded body omitted)");
       } else {
         Buffer buffer = new Buffer();
@@ -219,9 +220,11 @@ public Level getLevel() {
     ResponseBody responseBody = response.body();
     long contentLength = responseBody.contentLength();
     String bodySize = contentLength != -1 ? contentLength + "-byte" : "unknown-length";
-    logger.log("<-- " + response.code() + ' ' + response.message() + ' '
-        + response.request().url() + " (" + tookMs + "ms" + (!logHeaders ? ", "
-        + bodySize + " body" : "") + ')');
+    logger.log("<-- "
+        + response.code()
+        + (response.message().isEmpty() ? "" : ' ' + response.message())
+        + ' ' + response.request().url()
+        + " (" + tookMs + "ms" + (!logHeaders ? ", " + bodySize + " body" : "") + ')');
 
     if (logHeaders) {
       Headers headers = response.headers();
@@ -231,25 +234,32 @@ public Level getLevel() {
 
       if (!logBody || !HttpHeaders.hasBody(response)) {
         logger.log("<-- END HTTP");
-      } else if (bodyEncoded(response.headers())) {
+      } else if (bodyHasUnknownEncoding(response.headers())) {
         logger.log("<-- END HTTP (encoded body omitted)");
       } else {
         BufferedSource source = responseBody.source();
         source.request(Long.MAX_VALUE); // Buffer the entire body.
         Buffer buffer = source.buffer();
 
+        Long gzippedLength = null;
+        if ("gzip".equalsIgnoreCase(headers.get("Content-Encoding"))) {
+          gzippedLength = buffer.size();
+          GzipSource gzippedResponseBody = null;
+          try {
+            gzippedResponseBody = new GzipSource(buffer.clone());
+            buffer = new Buffer();
+            buffer.writeAll(gzippedResponseBody);
+          } finally {
+            if (gzippedResponseBody != null) {
+              gzippedResponseBody.close();
+            }
+          }
+        }
+
         Charset charset = UTF8;
         MediaType contentType = responseBody.contentType();
         if (contentType != null) {
-          try {
-            charset = contentType.charset(UTF8);
-          } catch (UnsupportedCharsetException e) {
-            logger.log("");
-            logger.log("Couldn't decode the response body; charset is likely malformed.");
-            logger.log("<-- END HTTP");
-
-            return response;
-          }
+          charset = contentType.charset(UTF8);
         }
 
         if (!isPlaintext(buffer)) {
@@ -263,7 +273,12 @@ public Level getLevel() {
           logger.log(buffer.clone().readString(charset));
         }
 
-        logger.log("<-- END HTTP (" + buffer.size() + "-byte body)");
+        if (gzippedLength != null) {
+            logger.log("<-- END HTTP (" + buffer.size() + "-byte, "
+                + gzippedLength + "-gzipped-byte body)");
+        } else {
+            logger.log("<-- END HTTP (" + buffer.size() + "-byte body)");
+        }
       }
     }
 
@@ -294,8 +309,10 @@ static boolean isPlaintext(Buffer buffer) {
     }
   }
 
-  private boolean bodyEncoded(Headers headers) {
+  private boolean bodyHasUnknownEncoding(Headers headers) {
     String contentEncoding = headers.get("Content-Encoding");
-    return contentEncoding != null && !contentEncoding.equalsIgnoreCase("identity");
+    return contentEncoding != null
+        && !contentEncoding.equalsIgnoreCase("identity")
+        && !contentEncoding.equalsIgnoreCase("gzip");
   }
 }
diff --git a/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java
new file mode 100644
index 0000000000..39904701cf
--- /dev/null
+++ b/okhttp-logging-interceptor/src/main/java/okhttp3/logging/package-info.java
@@ -0,0 +1,3 @@
+/** An OkHttp interceptor which logs HTTP request and response data. */
+@javax.annotation.ParametersAreNonnullByDefault
+package okhttp3.logging;
diff --git a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
index caa6cd72bd..ffac19fd69 100644
--- a/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
+++ b/okhttp-logging-interceptor/src/test/java/okhttp3/logging/HttpLoggingInterceptorTest.java
@@ -21,16 +21,21 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.regex.Pattern;
+import javax.net.ssl.HostnameVerifier;
 import okhttp3.Dns;
 import okhttp3.HttpUrl;
 import okhttp3.MediaType;
 import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.RecordingHostnameVerifier;
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
+import okhttp3.ResponseBody;
 import okhttp3.logging.HttpLoggingInterceptor.Level;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.ByteString;
@@ -39,17 +44,22 @@
 import org.junit.Rule;
 import org.junit.Test;
 
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.hamcrest.CoreMatchers.equalTo;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeThat;
 
 public final class HttpLoggingInterceptorTest {
-  private static final MediaType PLAIN = MediaType.parse("text/plain; charset=utf-8");
+  private static final MediaType PLAIN = MediaType.get("text/plain; charset=utf-8");
 
   @Rule public final MockWebServer server = new MockWebServer();
 
+  private HandshakeCertificates handshakeCertificates = localhost();
+  private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
   private OkHttpClient client;
   private String host;
   private HttpUrl url;
@@ -71,6 +81,9 @@ private void setLevel(Level level) {
     client = new OkHttpClient.Builder()
         .addNetworkInterceptor(networkInterceptor)
         .addInterceptor(applicationInterceptor)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(hostnameVerifier)
         .build();
 
     host = server.getHostName() + ":" + server.getPort();
@@ -117,7 +130,7 @@ private void setLevel(Level level) {
     client.newCall(request().build()).execute();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
         .assertNoMoreLogs();
 
@@ -134,7 +147,7 @@ private void setLevel(Level level) {
     client.newCall(request().post(RequestBody.create(PLAIN, "Hi?")).build()).execute();
 
     applicationLogs
-        .assertLogEqual("--> POST " + url + " http/1.1 (3-byte body)")
+        .assertLogEqual("--> POST " + url + " (3-byte body)")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 0-byte body\\)")
         .assertNoMoreLogs();
 
@@ -154,7 +167,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, 6-byte body\\)")
         .assertNoMoreLogs();
 
@@ -174,7 +187,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms, unknown-length body\\)")
         .assertNoMoreLogs();
 
@@ -192,7 +205,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 0")
@@ -221,7 +234,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("--> POST " + url)
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
         .assertLogEqual("Content-Length: 3")
         .assertLogEqual("--> END POST")
@@ -254,7 +267,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("--> POST " + url)
         .assertLogEqual("Content-Length: 3")
         .assertLogEqual("--> END POST")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
@@ -293,7 +306,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("--> POST " + url)
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
         .assertLogEqual("--> END POST")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
@@ -326,7 +339,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 6")
@@ -356,7 +369,7 @@ private void setLevel(Level level) {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 0")
@@ -393,7 +406,7 @@ private void bodyGetNoBody(int code) throws IOException {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- " + code + " No Content " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 0")
@@ -422,7 +435,7 @@ private void bodyGetNoBody(int code) throws IOException {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> POST " + url + " http/1.1")
+        .assertLogEqual("--> POST " + url)
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
         .assertLogEqual("Content-Length: 3")
         .assertLogEqual("")
@@ -460,7 +473,7 @@ private void bodyGetNoBody(int code) throws IOException {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 6")
@@ -496,7 +509,7 @@ private void bodyGetNoBody(int code) throws IOException {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Transfer-encoding: chunked")
@@ -522,7 +535,7 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertNoMoreLogs();
   }
 
-  @Test public void bodyResponseNotIdentityEncoded() throws IOException {
+  @Test public void bodyResponseGzipEncoded() throws IOException {
     setLevel(Level.BODY);
 
     server.enqueue(new MockResponse()
@@ -531,7 +544,10 @@ private void bodyGetNoBody(int code) throws IOException {
         .setBody(new Buffer().write(ByteString.decodeBase64(
             "H4sIAAAAAAAAAPNIzcnJ11HwQKIAdyO+9hMAAAA="))));
     Response response = client.newCall(request().build()).execute();
-    response.body().close();
+
+    ResponseBody responseBody = response.body();
+    assertEquals("Expected response body to be valid","Hello, Hello, Hello", responseBody.string());
+    responseBody.close();
 
     networkLogs
         .assertLogEqual("--> GET " + url + " http/1.1")
@@ -544,11 +560,13 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertLogEqual("Content-Encoding: gzip")
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
         .assertLogMatch("Content-Length: \\d+")
-        .assertLogEqual("<-- END HTTP (encoded body omitted)")
+        .assertLogEqual("")
+        .assertLogEqual("Hello, Hello, Hello")
+        .assertLogEqual("<-- END HTTP (19-byte, 29-gzipped-byte body)")
         .assertNoMoreLogs();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Type: text/plain; charset=utf-8")
@@ -558,12 +576,49 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertNoMoreLogs();
   }
 
+  @Test public void bodyResponseUnknownEncoded() throws IOException {
+      setLevel(Level.BODY);
+
+      server.enqueue(new MockResponse()
+          // It's invalid to return this if not requested, but the server might anyway
+          .setHeader("Content-Encoding", "br")
+          .setHeader("Content-Type", PLAIN)
+          .setBody(new Buffer().write(ByteString.decodeBase64(
+              "iwmASGVsbG8sIEhlbGxvLCBIZWxsbwoD"))));
+      Response response = client.newCall(request().build()).execute();
+      response.body().close();
+
+      networkLogs
+          .assertLogEqual("--> GET " + url + " http/1.1")
+          .assertLogEqual("Host: " + host)
+          .assertLogEqual("Connection: Keep-Alive")
+          .assertLogEqual("Accept-Encoding: gzip")
+          .assertLogMatch("User-Agent: okhttp/.+")
+          .assertLogEqual("--> END GET")
+          .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+          .assertLogEqual("Content-Encoding: br")
+          .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+          .assertLogMatch("Content-Length: \\d+")
+          .assertLogEqual("<-- END HTTP (encoded body omitted)")
+          .assertNoMoreLogs();
+
+      applicationLogs
+          .assertLogEqual("--> GET " + url)
+          .assertLogEqual("--> END GET")
+          .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
+          .assertLogEqual("Content-Encoding: br")
+          .assertLogEqual("Content-Type: text/plain; charset=utf-8")
+          .assertLogMatch("Content-Length: \\d+")
+          .assertLogEqual("<-- END HTTP (encoded body omitted)")
+          .assertNoMoreLogs();
+    }
+
   @Test public void bodyGetMalformedCharset() throws IOException {
     setLevel(Level.BODY);
 
     server.enqueue(new MockResponse()
         .setHeader("Content-Type", "text/html; charset=0")
-        .setBody("Ignore This"));
+        .setBody("Body with unknown charset"));
     Response response = client.newCall(request().build()).execute();
     response.body().close();
 
@@ -578,19 +633,19 @@ private void bodyGetNoBody(int code) throws IOException {
         .assertLogEqual("Content-Type: text/html; charset=0")
         .assertLogMatch("Content-Length: \\d+")
         .assertLogMatch("")
-        .assertLogEqual("Couldn't decode the response body; charset is likely malformed.")
-        .assertLogEqual("<-- END HTTP")
+        .assertLogEqual("Body with unknown charset")
+        .assertLogEqual("<-- END HTTP (25-byte body)")
         .assertNoMoreLogs();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Type: text/html; charset=0")
         .assertLogMatch("Content-Length: \\d+")
         .assertLogEqual("")
-        .assertLogEqual("Couldn't decode the response body; charset is likely malformed.")
-        .assertLogEqual("<-- END HTTP")
+        .assertLogEqual("Body with unknown charset")
+        .assertLogEqual("<-- END HTTP (25-byte body)")
         .assertNoMoreLogs();
   }
 
@@ -622,7 +677,7 @@ private void bodyGetNoBody(int code) throws IOException {
     response.body().close();
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("--> END GET")
         .assertLogMatch("<-- 200 OK " + url + " \\(\\d+ms\\)")
         .assertLogEqual("Content-Length: 9")
@@ -664,11 +719,32 @@ private void bodyGetNoBody(int code) throws IOException {
     }
 
     applicationLogs
-        .assertLogEqual("--> GET " + url + " http/1.1")
+        .assertLogEqual("--> GET " + url)
         .assertLogEqual("<-- HTTP FAILED: java.net.UnknownHostException: reason")
         .assertNoMoreLogs();
   }
 
+  @Test public void http2() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    url = server.url("/");
+
+    setLevel(Level.BASIC);
+
+    server.enqueue(new MockResponse());
+    Response response = client.newCall(request().build()).execute();
+    assumeThat(response.protocol(), equalTo(Protocol.HTTP_2));
+
+    applicationLogs
+        .assertLogEqual("--> GET " + url)
+        .assertLogMatch("<-- 200 " + url + " \\(\\d+ms, 0-byte body\\)")
+        .assertNoMoreLogs();
+
+    networkLogs
+        .assertLogEqual("--> GET " + url + " h2")
+        .assertLogMatch("<-- 200 " + url + " \\(\\d+ms, 0-byte body\\)")
+        .assertNoMoreLogs();
+  }
+
   private Request.Builder request() {
     return new Request.Builder().url(url);
   }
diff --git a/okhttp-sse/README.md b/okhttp-sse/README.md
new file mode 100644
index 0000000000..2b1bc42830
--- /dev/null
+++ b/okhttp-sse/README.md
@@ -0,0 +1,5 @@
+OkHttp Server-Sent Events
+=========================
+
+Experimental support for server-sent events.
+API is not considered stable and may change at any time.
diff --git a/okhttp-sse/pom.xml b/okhttp-sse/pom.xml
new file mode 100644
index 0000000000..b46d96f098
--- /dev/null
+++ b/okhttp-sse/pom.xml
@@ -0,0 +1,72 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.12.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-sse</artifactId>
+  <name>OkHttp Server-Sent Events</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
+        <configuration>
+          <links>
+            <link>http://square.github.io/okhttp/javadoc/</link>
+          </links>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>okhttp3.sse</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.java b/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.java
new file mode 100644
index 0000000000..be60122fa1
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/internal/sse/RealEventSource.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse;
+
+import java.io.IOException;
+import javax.annotation.Nullable;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.EventListener;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+import okhttp3.internal.Util;
+import okhttp3.sse.EventSource;
+import okhttp3.sse.EventSourceListener;
+
+public final class RealEventSource
+    implements EventSource, ServerSentEventReader.Callback, Callback {
+
+  private final Request request;
+  private final EventSourceListener listener;
+
+  private Call call;
+
+  public RealEventSource(Request request, EventSourceListener listener) {
+    this.request = request;
+    this.listener = listener;
+  }
+
+  public void connect(OkHttpClient client) {
+    client = client.newBuilder()
+        .eventListener(EventListener.NONE)
+        .build();
+    call = client.newCall(request);
+    call.enqueue(this);
+  }
+
+  @Override public void onResponse(Call call, Response response) {
+    processResponse(response);
+  }
+
+  public void processResponse(Response response) {
+    try {
+      if (!response.isSuccessful()) {
+        listener.onFailure(this, null, response);
+        return;
+      }
+
+      ResponseBody body = response.body();
+
+      //noinspection ConstantConditions main body is never null
+      MediaType contentType = body.contentType();
+      if (!isEventStream(contentType)) {
+        listener.onFailure(this,
+            new IllegalStateException("Invalid content-type: " + contentType), response);
+        return;
+      }
+
+      // Replace the body with an empty one so the callbacks can't see real data.
+      response = response.newBuilder().body(Util.EMPTY_RESPONSE).build();
+
+      ServerSentEventReader reader = new ServerSentEventReader(body.source(), this);
+      try {
+        listener.onOpen(this, response);
+        while (reader.processNextEvent()) {
+        }
+      } catch (Exception e) {
+        listener.onFailure(this, e, response);
+        return;
+      }
+
+      listener.onClosed(this);
+    } finally {
+      response.close();
+    }
+  }
+
+  private static boolean isEventStream(@Nullable MediaType contentType) {
+    return contentType != null && contentType.type().equals("text") && contentType.subtype()
+        .equals("event-stream");
+  }
+
+  @Override public void onFailure(Call call, IOException e) {
+    listener.onFailure(this, e, null);
+  }
+
+  @Override public Request request() {
+    return request;
+  }
+
+  @Override public void cancel() {
+    call.cancel();
+  }
+
+  @Override public void onEvent(@Nullable String id, @Nullable String type, String data) {
+    listener.onEvent(this, id, type, data);
+  }
+
+  @Override public void onRetryChange(long timeMs) {
+    // Ignored. We do not auto-retry.
+  }
+}
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.java b/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.java
new file mode 100644
index 0000000000..0e0e775fb6
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/internal/sse/ServerSentEventReader.java
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse;
+
+import java.io.IOException;
+import javax.annotation.Nullable;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ByteString;
+
+public final class ServerSentEventReader {
+  private static final ByteString CRLF = ByteString.encodeUtf8("\r\n");
+  private static final ByteString DATA = ByteString.encodeUtf8("data");
+  private static final ByteString ID = ByteString.encodeUtf8("id");
+  private static final ByteString EVENT = ByteString.encodeUtf8("event");
+  private static final ByteString RETRY = ByteString.encodeUtf8("retry");
+
+  public interface Callback {
+    void onEvent(@Nullable String id, @Nullable String type, String data);
+    void onRetryChange(long timeMs);
+  }
+
+  private final BufferedSource source;
+  private final Callback callback;
+
+  private String lastId = null;
+
+  public ServerSentEventReader(BufferedSource source, Callback callback) {
+    if (source == null) throw new NullPointerException("source == null");
+    if (callback == null) throw new NullPointerException("callback == null");
+    this.source = source;
+    this.callback = callback;
+  }
+
+  /**
+   * Process the next event. This will result in a single call to {@link Callback#onEvent}
+   * <em>unless</em> the data section was empty. Any number of calls to
+   * {@link Callback#onRetryChange} may occur while processing an event.
+   *
+   * @return false when EOF is reached
+   */
+  boolean processNextEvent() throws IOException {
+    String id = lastId;
+    String type = null;
+    Buffer data = new Buffer();
+
+    while (true) {
+      long lineEnd = source.indexOfElement(CRLF);
+      if (lineEnd == -1L) {
+        return false;
+      }
+
+      switch (source.buffer().getByte(0)) {
+        case '\r':
+        case '\n':
+          completeEvent(id, type, data);
+          return true;
+
+        case 'd':
+          if (isKey(DATA)) {
+            parseData(data, lineEnd);
+            continue;
+          }
+          break;
+
+        case 'e':
+          if (isKey(EVENT)) {
+            type = parseEvent(lineEnd);
+            continue;
+          }
+          break;
+
+        case 'i':
+          if (isKey(ID)) {
+            id = parseId(lineEnd);
+            continue;
+          }
+          break;
+
+        case 'r':
+          if (isKey(RETRY)) {
+            parseRetry(lineEnd);
+            continue;
+          }
+          break;
+      }
+
+      source.skip(lineEnd);
+      skipCrAndOrLf();
+    }
+  }
+
+  private void completeEvent(String id, String type, Buffer data) throws IOException {
+    skipCrAndOrLf();
+
+    if (data.size() != 0L) {
+      lastId = id;
+      data.skip(1L); // Leading newline.
+      callback.onEvent(id, type, data.readUtf8());
+    }
+  }
+
+  private void parseData(Buffer data, long end) throws IOException {
+    data.writeByte('\n');
+    end -= skipNameAndDivider(4L);
+    source.readFully(data, end);
+    skipCrAndOrLf();
+  }
+
+  private String parseEvent(long end) throws IOException {
+    String type = null;
+    end -= skipNameAndDivider(5L);
+    if (end != 0L) {
+      type = source.readUtf8(end);
+    }
+    skipCrAndOrLf();
+    return type;
+  }
+
+  private String parseId(long end) throws IOException {
+    String id;
+    end -= skipNameAndDivider(2L);
+    if (end != 0L) {
+      id = source.readUtf8(end);
+    } else {
+      id = null;
+    }
+    skipCrAndOrLf();
+    return id;
+  }
+
+  private void parseRetry(long end) throws IOException {
+    end -= skipNameAndDivider(5L);
+    String retryString = source.readUtf8(end);
+    long retryMs = -1L;
+    try {
+      retryMs = Long.parseLong(retryString);
+    } catch (NumberFormatException ignored) {
+    }
+    if (retryMs != -1L) {
+      callback.onRetryChange(retryMs);
+    }
+    skipCrAndOrLf();
+  }
+
+  /**
+   * Returns true if the first bytes of {@link #source} are {@code key} followed by a colon or
+   * a newline.
+   */
+  private boolean isKey(ByteString key) throws IOException {
+    if (source.rangeEquals(0, key)) {
+      byte nextByte = source.buffer().getByte(key.size());
+      return nextByte == ':'
+          || nextByte == '\r'
+          || nextByte == '\n';
+    }
+    return false;
+  }
+
+  /** Consumes {@code \r}, {@code \r\n}, or {@code \n} from {@link #source}. */
+  private void skipCrAndOrLf() throws IOException {
+    if ((source.readByte() & 0xff) == '\r'
+        && source.request(1)
+        && source.buffer().getByte(0) == '\n') {
+      source.skip(1);
+    }
+  }
+
+  /**
+   * Consumes the field name of the specified length and the optional colon and its optional
+   * trailing space. Returns the number of bytes skipped.
+   */
+  private long skipNameAndDivider(long length) throws IOException {
+    source.skip(length);
+
+    if (source.buffer().getByte(0) == ':') {
+      source.skip(1L);
+      length++;
+
+      if (source.buffer().getByte(0) == ' ') {
+        source.skip(1);
+        length++;
+      }
+    }
+
+    return length;
+  }
+}
diff --git a/okhttp-sse/src/main/java/okhttp3/internal/sse/package-info.java b/okhttp-sse/src/main/java/okhttp3/internal/sse/package-info.java
new file mode 100644
index 0000000000..5993b09cdc
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/internal/sse/package-info.java
@@ -0,0 +1,3 @@
+/** Private support classes for server-sent events. */
+@javax.annotation.ParametersAreNonnullByDefault
+package okhttp3.internal.sse;
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/EventSource.java b/okhttp-sse/src/main/java/okhttp3/sse/EventSource.java
new file mode 100644
index 0000000000..fe703dc8c0
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/sse/EventSource.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.sse;
+
+import okhttp3.Request;
+
+public interface EventSource {
+  /** Returns the original request that initiated this event source. */
+  Request request();
+
+  /**
+   * Immediately and violently release resources held by this event source. This does nothing if
+   * the event source has already been closed or canceled.
+   */
+  void cancel();
+
+  interface Factory {
+    /**
+     * Creates a new event source and immediately returns it. Creating an event source initiates an
+     * asynchronous process to connect the socket. Once that succeeds or fails, {@code listener}
+     * will be notified. The caller must cancel the returned event source when it is no longer
+     * in use.
+     */
+    EventSource newEventSource(Request request, EventSourceListener listener);
+  }
+}
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/EventSourceListener.java b/okhttp-sse/src/main/java/okhttp3/sse/EventSourceListener.java
new file mode 100644
index 0000000000..4246625eca
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/sse/EventSourceListener.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.sse;
+
+import javax.annotation.Nullable;
+import okhttp3.Response;
+
+public abstract class EventSourceListener {
+  /**
+   * Invoked when an event source has been accepted by the remote peer and may begin transmitting
+   * events.
+   */
+  public void onOpen(EventSource eventSource, Response response) {
+  }
+
+  /**
+   * TODO description.
+   */
+  public void onEvent(EventSource eventSource, @Nullable String id, @Nullable String type,
+      String data) {
+  }
+
+  /**
+   * TODO description.
+   * No further calls to this listener will be made.
+   */
+  public void onClosed(EventSource eventSource) {
+  }
+
+  /**
+   * Invoked when an event source has been closed due to an error reading from or writing to the
+   * network. Incoming events may have been lost. No further calls to this listener will be made.
+   */
+  public void onFailure(EventSource eventSource, @Nullable Throwable t,
+      @Nullable Response response) {
+  }
+}
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/EventSources.java b/okhttp-sse/src/main/java/okhttp3/sse/EventSources.java
new file mode 100644
index 0000000000..77f596c5f2
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/sse/EventSources.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.sse;
+
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.internal.sse.RealEventSource;
+
+public final class EventSources {
+  public static EventSource.Factory createFactory(final OkHttpClient client) {
+    return new EventSource.Factory() {
+      @Override public EventSource newEventSource(Request request, EventSourceListener listener) {
+        RealEventSource eventSource = new RealEventSource(request, listener);
+        eventSource.connect(client);
+        return eventSource;
+      }
+    };
+  }
+
+  public static void processResponse(Response response, EventSourceListener listener) {
+    RealEventSource eventSource = new RealEventSource(response.request(), listener);
+    eventSource.processResponse(response);
+  }
+
+  private EventSources() {
+    throw new AssertionError();
+  }
+}
diff --git a/okhttp-sse/src/main/java/okhttp3/sse/package-info.java b/okhttp-sse/src/main/java/okhttp3/sse/package-info.java
new file mode 100644
index 0000000000..6777492c9c
--- /dev/null
+++ b/okhttp-sse/src/main/java/okhttp3/sse/package-info.java
@@ -0,0 +1,3 @@
+/** Support for server-sent events. */
+@javax.annotation.ParametersAreNonnullByDefault
+package okhttp3.sse;
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java
new file mode 100644
index 0000000000..149be0014c
--- /dev/null
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/Event.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse;
+
+import javax.annotation.Nullable;
+
+final class Event {
+  final @Nullable String id;
+  final @Nullable String type;
+  final String data;
+
+  Event(@Nullable String id, @Nullable String type, String data) {
+    if (data == null) throw new NullPointerException("data == null");
+    this.id = id;
+    this.type = type;
+    this.data = data;
+  }
+
+  @Override public String toString() {
+    return "Event{id='" + id + "', type='" + type + "', data='" + data + "'}";
+  }
+
+  @Override public boolean equals(Object o) {
+    if (this == o) return true;
+    if (!(o instanceof Event)) return false;
+    Event other = (Event) o;
+    return (id != null ? id.equals(other.id) : other.id == null)
+        && (type != null ? type.equals(other.type) : other.type == null)
+        && data.equals(other.data);
+  }
+
+  @Override public int hashCode() {
+    int result = (id != null ? id.hashCode() : 0);
+    result = 31 * result + (type != null ? type.hashCode() : 0);
+    result = 31 * result + data.hashCode();
+    return result;
+  }
+}
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
new file mode 100644
index 0000000000..ffdabbcd14
--- /dev/null
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceHttpTest.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse;
+
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.sse.EventSource;
+import okhttp3.sse.EventSources;
+import org.junit.After;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public final class EventSourceHttpTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private final EventSourceRecorder listener = new EventSourceRecorder();
+  private final EventSource.Factory factory = EventSources.createFactory(new OkHttpClient());
+
+  @After public void after() {
+    listener.assertExhausted();
+  }
+
+  @Test public void event() {
+    server.enqueue(new MockResponse().setBody(""
+        + "data: hey\n"
+        + "\n").setHeader("content-type", "text/event-stream"));
+
+    EventSource source = newEventSource();
+
+    assertEquals("/", source.request().url().encodedPath());
+
+    listener.assertOpen();
+    listener.assertEvent(null, null, "hey");
+    listener.assertClose();
+  }
+
+  @Test public void badContentType() {
+    server.enqueue(new MockResponse().setBody(""
+        + "data: hey\n"
+        + "\n").setHeader("content-type", "text/plain"));
+
+    EventSource source = newEventSource();
+    listener.assertFailure("Invalid content-type: text/plain");
+  }
+
+  @Test public void badResponseCode() {
+    server.enqueue(new MockResponse().setBody(""
+        + "data: hey\n"
+        + "\n").setHeader("content-type", "text/event-stream").setResponseCode(401));
+
+    EventSource source = newEventSource();
+    listener.assertFailure(null);
+  }
+
+  private EventSource newEventSource() {
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    return factory.newEventSource(request, listener);
+  }
+}
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java
new file mode 100644
index 0000000000..2d2c8afce1
--- /dev/null
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/EventSourceRecorder.java
@@ -0,0 +1,150 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse;
+
+import java.io.IOException;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingDeque;
+import javax.annotation.Nullable;
+import okhttp3.sse.EventSource;
+import okhttp3.sse.EventSourceListener;
+import okhttp3.Response;
+import okhttp3.internal.platform.Platform;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+public final class EventSourceRecorder extends EventSourceListener {
+  private final BlockingQueue<Object> events = new LinkedBlockingDeque<>();
+
+  @Override public void onOpen(EventSource eventSource, Response response) {
+    Platform.get().log(Platform.INFO, "[ES] onOpen", null);
+    events.add(new Open(eventSource, response));
+  }
+
+  @Override public void onEvent(EventSource eventSource, @Nullable String id, @Nullable String type,
+      String data) {
+    Platform.get().log(Platform.INFO, "[ES] onEvent", null);
+    events.add(new Event(id, type, data));
+  }
+
+  @Override public void onClosed(EventSource eventSource) {
+    Platform.get().log(Platform.INFO, "[ES] onClosed", null);
+    events.add(new Closed());
+  }
+
+  @Override
+  public void onFailure(EventSource eventSource, Throwable t, @Nullable Response response) {
+    Platform.get().log(Platform.INFO, "[ES] onFailure", t);
+    events.add(new Failure(t, response));
+  }
+
+  private Object nextEvent() {
+    try {
+      Object event = events.poll(10, SECONDS);
+      if (event == null) {
+        throw new AssertionError("Timed out waiting for event.");
+      }
+      return event;
+    } catch (InterruptedException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  public void assertExhausted() {
+    assertTrue("Remaining events: " + events, events.isEmpty());
+  }
+
+  public void assertEvent(@Nullable String id, @Nullable String type, String data) {
+    Object actual = nextEvent();
+    assertEquals(new Event(id, type, data), actual);
+  }
+
+  public EventSource assertOpen() {
+    Object event = nextEvent();
+    if (!(event instanceof Open)) {
+      throw new AssertionError("Expected Open but was " + event);
+    }
+    return ((Open) event).eventSource;
+  }
+
+  public void assertClose() {
+    Object event = nextEvent();
+    if (!(event instanceof Closed)) {
+      throw new AssertionError("Expected Open but was " + event);
+    }
+  }
+
+  public void assertFailure(@Nullable String message) {
+    Object event = nextEvent();
+    if (!(event instanceof Failure)) {
+      throw new AssertionError("Expected Failure but was " + event);
+    }
+    if (message != null) {
+      assertEquals(message, ((Failure) event).t.getMessage());
+    } else {
+      assertNull(((Failure) event).t);
+    }
+  }
+
+  static final class Open {
+    final EventSource eventSource;
+    final Response response;
+
+    Open(EventSource eventSource, Response response) {
+      this.eventSource = eventSource;
+      this.response = response;
+    }
+
+    @Override public String toString() {
+      return "Open[" + response + ']';
+    }
+  }
+
+  static final class Failure {
+    final Throwable t;
+    final Response response;
+    final String responseBody;
+
+    Failure(Throwable t, Response response) {
+      this.t = t;
+      this.response = response;
+      String responseBody = null;
+      if (response != null) {
+        try {
+          responseBody = response.body().string();
+        } catch (IOException ignored) {
+        }
+      }
+      this.responseBody = responseBody;
+    }
+
+    @Override public String toString() {
+      if (response == null) {
+        return "Failure[" + t + "]";
+      }
+      return "Failure[" + response + "]";
+    }
+  }
+
+  static final class Closed {
+    @Override public String toString() {
+      return "Closed[]";
+    }
+  }
+}
diff --git a/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java b/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java
new file mode 100644
index 0000000000..697a2d2019
--- /dev/null
+++ b/okhttp-sse/src/test/java/okhttp3/internal/sse/ServerSentEventIteratorTest.java
@@ -0,0 +1,196 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.sse;
+
+import java.io.IOException;
+import java.util.ArrayDeque;
+import java.util.Deque;
+import javax.annotation.Nullable;
+import okio.Buffer;
+import org.junit.After;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+public final class ServerSentEventIteratorTest {
+  /** Either {@link Event} or {@link Long} items for events and retry changes, respectively. */
+  private final Deque<Object> callbacks = new ArrayDeque<>();
+
+  @After public void after() {
+    assertTrue("Unconsumed events: " + callbacks, callbacks.isEmpty());
+  }
+  
+  @Test public void multiline() throws IOException {
+    consumeEvents(""
+        + "data: YHOO\n"
+        + "data: +2\n"
+        + "data: 10\n"
+        + "\n");
+    assertEquals(new Event(null, null, "YHOO\n+2\n10"), callbacks.remove());
+  }
+
+  @Test public void multilineCr() throws IOException {
+    consumeEvents(""
+        + "data: YHOO\r"
+        + "data: +2\r"
+        + "data: 10\r"
+        + "\r");
+    assertEquals(new Event(null, null, "YHOO\n+2\n10"), callbacks.remove());
+  }
+
+  @Test public void multilineCrLf() throws IOException {
+    consumeEvents(""
+        + "data: YHOO\r\n"
+        + "data: +2\r\n"
+        + "data: 10\r\n"
+        + "\r\n");
+    assertEquals(new Event(null, null, "YHOO\n+2\n10"), callbacks.remove());
+  }
+
+  @Test public void eventType() throws IOException {
+    consumeEvents(""
+        + "event: add\n"
+        + "data: 73857293\n"
+        + "\n"
+        + "event: remove\n"
+        + "data: 2153\n"
+        + "\n"
+        + "event: add\n"
+        + "data: 113411\n"
+        + "\n");
+    assertEquals(new Event(null, "add", "73857293"), callbacks.remove());
+    assertEquals(new Event(null, "remove", "2153"), callbacks.remove());
+    assertEquals(new Event(null, "add", "113411"), callbacks.remove());
+  }
+
+  @Test public void commentsIgnored() throws IOException {
+    consumeEvents(""
+        + ": test stream\n"
+        + "\n"
+        + "data: first event\n"
+        + "id: 1\n"
+        + "\n");
+    assertEquals(new Event("1", null, "first event"), callbacks.remove());
+  }
+
+  @Test public void idCleared() throws IOException {
+    consumeEvents(""
+        + "data: first event\n"
+        + "id: 1\n"
+        + "\n"
+        + "data: second event\n"
+        + "id\n"
+        + "\n"
+        + "data: third event\n"
+        + "\n");
+    assertEquals(new Event("1", null, "first event"), callbacks.remove());
+    assertEquals(new Event(null, null, "second event"), callbacks.remove());
+    assertEquals(new Event(null, null, "third event"), callbacks.remove());
+  }
+
+  @Test public void nakedFieldNames() throws IOException {
+    consumeEvents(""
+        + "data\n"
+        + "\n"
+        + "data\n"
+        + "data\n"
+        + "\n"
+        + "data:\n");
+    assertEquals(new Event(null, null, ""), callbacks.remove());
+    assertEquals(new Event(null, null, "\n"), callbacks.remove());
+  }
+
+  @Test public void colonSpaceOptional() throws IOException {
+    consumeEvents(""
+        + "data:test\n"
+        + "\n"
+        + "data: test\n"
+        + "\n");
+    assertEquals(new Event(null, null, "test"), callbacks.remove());
+    assertEquals(new Event(null, null, "test"), callbacks.remove());
+  }
+
+  @Test public void leadingWhitespace() throws IOException {
+    consumeEvents(""
+        + "data:  test\n"
+        + "\n");
+    assertEquals(new Event(null, null, " test"), callbacks.remove());
+  }
+
+  @Test public void idReusedAcrossEvents() throws IOException {
+    consumeEvents(""
+        + "data: first event\n"
+        + "id: 1\n"
+        + "\n"
+        + "data: second event\n"
+        + "\n"
+        + "id: 2\n"
+        + "data: third event\n"
+        + "\n");
+    assertEquals(new Event("1", null, "first event"), callbacks.remove());
+    assertEquals(new Event("1", null, "second event"), callbacks.remove());
+    assertEquals(new Event("2", null, "third event"), callbacks.remove());
+  }
+
+  @Test public void idIgnoredFromEmptyEvent() throws IOException {
+    consumeEvents(""
+        + "data: first event\n"
+        + "id: 1\n"
+        + "\n"
+        + "id: 2\n"
+        + "\n"
+        + "data: second event\n"
+        + "\n");
+    assertEquals(new Event("1", null, "first event"), callbacks.remove());
+    assertEquals(new Event("1", null, "second event"), callbacks.remove());
+  }
+
+  @Test public void retry() throws IOException {
+    consumeEvents(""
+        + "retry: 22\n"
+        + "\n"
+        + "data: first event\n"
+        + "id: 1\n"
+        + "\n");
+    assertEquals(22L, callbacks.remove());
+    assertEquals(new Event("1", null, "first event"), callbacks.remove());
+  }
+
+  @Test public void retryInvalidFormatIgnored() throws IOException {
+    consumeEvents(""
+        + "retry: 22\n"
+        + "\n"
+        + "retry: hey"
+        + "\n");
+    assertEquals(22L, callbacks.remove());
+  }
+  
+  private void consumeEvents(String source) throws IOException {
+    ServerSentEventReader.Callback callback = new ServerSentEventReader.Callback() {
+      @Override public void onEvent(@Nullable String id, @Nullable String type, String data) {
+        callbacks.add(new Event(id, type, data));
+      }
+      @Override public void onRetryChange(long timeMs) {
+        callbacks.add(timeMs);
+      }
+    };
+    Buffer buffer = new Buffer().writeUtf8(source);
+    ServerSentEventReader reader = new ServerSentEventReader(buffer, callback);
+    while (reader.processNextEvent());
+    assertEquals("Unconsumed buffer: " + buffer.readUtf8(), 0, buffer.size());
+  }
+}
diff --git a/okhttp-testing-support/pom.xml b/okhttp-testing-support/pom.xml
index a7e166bb13..e8cb9aee54 100644
--- a/okhttp-testing-support/pom.xml
+++ b/okhttp-testing-support/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.6.0-SNAPSHOT</version>
+    <version>3.12.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-testing-support</artifactId>
@@ -23,5 +23,27 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
   </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>okhttp3.testing</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
 </project>
diff --git a/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java b/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
index f2edc75d66..e12ea9c622 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/FakeDns.java
@@ -19,39 +19,61 @@
 import java.net.UnknownHostException;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
 
 import static org.junit.Assert.assertEquals;
 
 public final class FakeDns implements Dns {
-  private List<String> requestedHosts = new ArrayList<>();
-  private List<InetAddress> addresses = Collections.emptyList();
+  private final Map<String, List<InetAddress>> hostAddresses = new LinkedHashMap<>();
+  private final List<String> requestedHosts = new ArrayList<>();
+  private int nextAddress = 100;
 
-  /** Sets the addresses to be returned by this fake DNS service. */
-  public FakeDns addresses(List<InetAddress> addresses) {
-    this.addresses = new ArrayList<>(addresses);
+  /** Sets the results for {@code hostname}. */
+  public FakeDns set(String hostname, List<InetAddress> addresses) {
+    hostAddresses.put(hostname, addresses);
     return this;
   }
 
-  /** Sets the service to throw when a hostname is requested. */
-  public FakeDns unknownHost() {
-    this.addresses = Collections.emptyList();
+  /** Clears the results for {@code hostname}. */
+  public FakeDns clear(String hostname) {
+    hostAddresses.remove(hostname);
     return this;
   }
 
-  public InetAddress address(int index) {
-    return addresses.get(index);
+  public InetAddress lookup(String hostname, int index) throws UnknownHostException {
+    return hostAddresses.get(hostname).get(index);
   }
 
   @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
     requestedHosts.add(hostname);
-    if (addresses.isEmpty()) throw new UnknownHostException();
-    return addresses;
+
+    List<InetAddress> result = hostAddresses.get(hostname);
+    if (result != null) return result;
+
+    throw new UnknownHostException();
   }
 
   public void assertRequests(String... expectedHosts) {
     assertEquals(Arrays.asList(expectedHosts), requestedHosts);
     requestedHosts.clear();
   }
+
+  /** Allocates and returns {@code count} fake addresses like [255.0.0.100, 255.0.0.101]. */
+  public List<InetAddress> allocate(int count) {
+    try {
+      List<InetAddress> result = new ArrayList<>();
+      for (int i = 0; i < count; i++) {
+        if (nextAddress > 255) {
+          throw new AssertionError("too many addresses allocated");
+        }
+        result.add(InetAddress.getByAddress(
+            new byte[] {(byte) 255, (byte) 0, (byte) 0, (byte) nextAddress++}));
+      }
+      return result;
+    } catch (UnknownHostException e) {
+      throw new AssertionError();
+    }
+  }
 }
diff --git a/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java b/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
index 38652c07de..ae034cd9a6 100644
--- a/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
+++ b/okhttp-testing-support/src/main/java/okhttp3/testing/InstallUncaughtExceptionHandlerListener.java
@@ -17,6 +17,9 @@
 
 import java.io.PrintWriter;
 import java.io.StringWriter;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import org.junit.internal.Throwables;
 import org.junit.runner.Description;
 import org.junit.runner.Result;
 import org.junit.runner.notification.RunListener;
@@ -30,8 +33,9 @@
 
   private Thread.UncaughtExceptionHandler oldDefaultUncaughtExceptionHandler;
   private Description lastTestStarted;
+  private final Map<Throwable, String> exceptions = new LinkedHashMap<>();
 
-  @Override public void testRunStarted(Description description) throws Exception {
+  @Override public void testRunStarted(Description description) {
     System.err.println("Installing aggressive uncaught exception handler");
     oldDefaultUncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler();
     Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
@@ -48,17 +52,26 @@
           errorText.append("\n");
         }
         System.err.print(errorText.toString());
-        System.exit(-1);
+
+        synchronized (exceptions) {
+          exceptions.put(throwable, lastTestStarted.getDisplayName());
+        }
       }
     });
   }
 
-  @Override public void testStarted(Description description) throws Exception {
+  @Override public void testStarted(Description description) {
     lastTestStarted = description;
   }
 
   @Override public void testRunFinished(Result result) throws Exception {
     Thread.setDefaultUncaughtExceptionHandler(oldDefaultUncaughtExceptionHandler);
     System.err.println("Uninstalled aggressive uncaught exception handler");
+
+    synchronized (exceptions) {
+      if (!exceptions.isEmpty()) {
+        throw Throwables.rethrowAsException(exceptions.keySet().iterator().next());
+      }
+    }
   }
 }
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
index 215eb4c07d..024714f310 100644
--- a/okhttp-tests/pom.xml
+++ b/okhttp-tests/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.6.0-SNAPSHOT</version>
+    <version>3.12.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-tests</artifactId>
@@ -17,6 +17,11 @@
       <groupId>com.squareup.okio</groupId>
       <artifactId>okio</artifactId>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>okhttp</artifactId>
@@ -28,11 +33,21 @@
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-tls</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>okhttp-urlconnection</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>org.conscrypt</groupId>
+      <artifactId>conscrypt-openjdk-uber</artifactId>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -45,6 +60,12 @@
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>logging-interceptor</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
 
   <build>
@@ -52,6 +73,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-assembly-plugin</artifactId>
+        <version>3.1.0</version>
         <configuration>
           <descriptorRefs>
             <descriptorRef>jar-with-dependencies</descriptorRef>
@@ -75,6 +97,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-deploy-plugin</artifactId>
+        <version>2.7</version>
         <configuration>
           <skip>true</skip>
         </configuration>
diff --git a/okhttp-tests/src/main/java/okhttp3/TestTls13Request.java b/okhttp-tests/src/main/java/okhttp3/TestTls13Request.java
new file mode 100644
index 0000000000..d288cad0a1
--- /dev/null
+++ b/okhttp-tests/src/main/java/okhttp3/TestTls13Request.java
@@ -0,0 +1,110 @@
+package okhttp3;
+
+import java.io.IOException;
+import java.security.Security;
+import java.util.Arrays;
+import java.util.List;
+import okhttp3.internal.platform.Platform;
+import org.conscrypt.Conscrypt;
+import org.conscrypt.OpenSSLProvider;
+
+public class TestTls13Request {
+  private TestTls13Request() {
+  }
+
+  public static void main(String[] args) {
+    String spec28 = Integer.toString(0x7f00 | 28, 16);
+    System.setProperty("jdk.tls13.version", spec28);
+
+    //System.setProperty("javax.net.debug", "ssl:handshake:verbose");
+
+    System.out.println("Running tests using "
+        + Platform.get().getClass().getSimpleName()
+        + " "
+        + System.getProperty("java.vm.version"));
+
+    // Allow for TLS_CHACHA20_POLY1305_SHA256 cipher suite
+    if (Conscrypt.isAvailable()) {
+      Security.addProvider(new OpenSSLProvider());
+    }
+
+    // https://github.com/tlswg/tls13-spec/wiki/Implementations
+    List<String> urls =
+        Arrays.asList("https://enabled.tls13.com", "https://www.howsmyssl.com/a/check",
+            "https://tls13.cloudflare.com", "https://www.allizom.org/robots.txt",
+            "https://tls13.crypto.mozilla.org/", "https://tls.ctf.network/",
+            "https://rustls.jbp.io/", "https://h2o.examp1e.net", "https://mew.org/",
+            "https://tls13.baishancloud.com/", "https://tls13.akamai.io/", "https://swifttls.org/");
+
+    System.out.println("TLS1.3 only");
+    testClient(urls, buildClient(ConnectionSpec.TLS_13));
+
+    System.out.println("TLS1.3 then fallback");
+    testClient(urls, buildClient(ConnectionSpec.TLS_13, ConnectionSpec.RESTRICTED_TLS));
+
+    System.out.println("TLS1.3+TLS1.2");
+    testClient(urls, buildClient(merge(ConnectionSpec.TLS_13, ConnectionSpec.RESTRICTED_TLS)));
+  }
+
+  private static ConnectionSpec merge(ConnectionSpec first, ConnectionSpec second) {
+    String[] versions = concat(first.tlsVersions, second.tlsVersions);
+    String[] cipherSuites = concat(first.cipherSuites, second.cipherSuites);
+
+    return new ConnectionSpec.Builder(true).tlsVersions(versions)
+        .cipherSuites(cipherSuites)
+        .supportsTlsExtensions(true)
+        .build();
+  }
+
+  private static String[] concat(String[] first, String[] second) {
+    String[] result = new String[first.length + second.length];
+    System.arraycopy(first, 0, result, 0, first.length);
+    System.arraycopy(second, 0, result, first.length, second.length);
+    return result;
+  }
+
+  private static void testClient(List<String> urls, OkHttpClient client) {
+    try {
+      for (String url : urls) {
+        sendRequest(client, url);
+      }
+    } finally {
+      client.dispatcher.executorService().shutdownNow();
+      client.connectionPool.evictAll();
+    }
+  }
+
+  private static OkHttpClient buildClient(ConnectionSpec... specs) {
+    return new OkHttpClient.Builder().connectionSpecs(Arrays.asList(specs)).build();
+  }
+
+  private static void sendRequest(OkHttpClient client, String url) {
+    System.out.printf("%-40s ", url);
+    System.out.flush();
+
+    Request request = new Request.Builder().url(url).build();
+
+    Response response = null;
+    try {
+      response = client.newCall(request).execute();
+
+      Handshake handshake = response.handshake();
+      System.out.println(handshake.tlsVersion()
+          + " "
+          + handshake.cipherSuite()
+          + " "
+          + response.protocol()
+          + " "
+          + response.code
+          + " "
+          + response.body.bytes().length
+          + "b");
+    } catch (IOException ioe) {
+      System.out.println(ioe.toString());
+    } finally {
+      if (response != null) {
+        response.close();
+      }
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java b/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java
index ef15052a93..356f96ab46 100644
--- a/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CacheControlTest.java
@@ -51,15 +51,18 @@
         .minFresh(3, TimeUnit.SECONDS)
         .onlyIfCached()
         .noTransform()
+        .immutable()
         .build();
     assertEquals("no-cache, no-store, max-age=1, max-stale=2, min-fresh=3, only-if-cached, "
-        + "no-transform", cacheControl.toString());
+        + "no-transform, immutable", cacheControl.toString());
     assertTrue(cacheControl.noCache());
     assertTrue(cacheControl.noStore());
     assertEquals(1, cacheControl.maxAgeSeconds());
     assertEquals(2, cacheControl.maxStaleSeconds());
     assertEquals(3, cacheControl.minFreshSeconds());
     assertTrue(cacheControl.onlyIfCached());
+    assertTrue(cacheControl.noTransform());
+    assertTrue(cacheControl.immutable());
 
     // These members are accessible to response headers only.
     assertEquals(-1, cacheControl.sMaxAgeSeconds());
@@ -121,6 +124,7 @@
     assertEquals(-1, cacheControl.minFreshSeconds());
     assertFalse(cacheControl.onlyIfCached());
     assertFalse(cacheControl.noTransform());
+    assertFalse(cacheControl.immutable());
     assertEquals(header, cacheControl.toString());
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/CacheTest.java b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
index 8f6bbbd628..8673ffa031 100644
--- a/okhttp-tests/src/test/java/okhttp3/CacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CacheTest.java
@@ -38,10 +38,10 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.io.InMemoryFileSystem;
 import okhttp3.internal.platform.Platform;
-import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -54,6 +54,7 @@
 
 import static okhttp3.TestUtil.defaultClient;
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -72,7 +73,7 @@
   @Rule public MockWebServer server2 = new MockWebServer();
   @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
 
-  private final SslClient sslClient = SslClient.localhost();
+  private final HandshakeCertificates handshakeCertificates = localhost();
   private OkHttpClient client;
   private Cache cache;
   private final CookieManager cookieManager = new CookieManager();
@@ -253,14 +254,15 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   }
 
   @Test public void secureResponseCaching() throws IOException {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build();
 
@@ -349,7 +351,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   }
 
   @Test public void secureResponseCachingAndRedirects() throws IOException {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
@@ -363,7 +365,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .setBody("DEF"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build();
 
@@ -389,7 +392,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
    * https://github.com/square/okhttp/issues/214
    */
   @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
-    server2.useHttps(sslClient.socketFactory, false);
+    server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server2.enqueue(new MockResponse()
         .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
@@ -404,7 +407,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Location: " + server2.url("/")));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build();
 
@@ -745,8 +749,8 @@ private void testClientPrematureDisconnect(TransferKind transferKind) throws IOE
   }
 
   private void testRequestMethod(String requestMethod, boolean expectCached) throws Exception {
-    // 1. seed the cache (potentially)
-    // 2. expect a cache hit or miss
+    // 1. Seed the cache (potentially).
+    // 2. Expect a cache hit or miss.
     server.enqueue(new MockResponse()
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .addHeader("X-Response-ID: 1"));
@@ -774,7 +778,7 @@ private void testRequestMethod(String requestMethod, boolean expectCached) throw
 
   private RequestBody requestBodyOrNull(String requestMethod) {
     return (requestMethod.equals("POST") || requestMethod.equals("PUT"))
-        ? RequestBody.create(MediaType.parse("text/plain"), "foo")
+        ? RequestBody.create(MediaType.get("text/plain"), "foo")
         : null;
   }
 
@@ -791,9 +795,9 @@ private RequestBody requestBodyOrNull(String requestMethod) {
   }
 
   private void testMethodInvalidates(String requestMethod) throws Exception {
-    // 1. seed the cache
-    // 2. invalidate it
-    // 3. expect a cache miss
+    // 1. Seed the cache.
+    // 2. Invalidate it.
+    // 3. Expect a cache miss.
     server.enqueue(new MockResponse()
         .setBody("A")
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
@@ -817,9 +821,9 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
   }
 
   @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
-    // 1. seed the cache
-    // 2. invalidate it with uncacheable response
-    // 3. expect a cache miss
+    // 1. Seed the cache.
+    // 2. Invalidate it with an uncacheable response.
+    // 3. Expect a cache miss.
     server.enqueue(new MockResponse()
         .setBody("A")
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
@@ -843,6 +847,33 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
     assertEquals("C", get(url).body().string());
   }
 
+  @Test public void putInvalidatesWithNoContentResponse() throws Exception {
+    // 1. Seed the cache.
+    // 2. Invalidate it.
+    // 3. Expect a cache miss.
+    server.enqueue(new MockResponse()
+        .setBody("A")
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NO_CONTENT));
+    server.enqueue(new MockResponse()
+        .setBody("C"));
+
+    HttpUrl url = server.url("/");
+
+    assertEquals("A", get(url).body().string());
+
+    Request request = new Request.Builder()
+        .url(url)
+        .put(RequestBody.create(MediaType.get("text/plain"), "foo"))
+        .build();
+    Response invalidate = client.newCall(request).execute();
+    assertEquals("", invalidate.body().string());
+
+    assertEquals("C", get(url).body().string());
+  }
+
   @Test public void etag() throws Exception {
     RecordedRequest conditionalRequest = assertConditionallyCached(new MockResponse()
         .addHeader("ETag: v1"));
@@ -908,8 +939,8 @@ private void testMethodInvalidates(String requestMethod) throws Exception {
   }
 
   @Test public void partialRangeResponsesDoNotCorruptCache() throws Exception {
-    // 1. request a range
-    // 2. request a full document, expecting a cache miss
+    // 1. Request a range.
+    // 2. Request a full document, expecting a cache miss.
     server.enqueue(new MockResponse()
         .setBody("AA")
         .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
@@ -1006,6 +1037,43 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     assertEquals("ABCABCABC", get(server.url("/")).body().string());
   }
 
+  @Test public void previouslyNotGzippedContentIsNotModifiedAndSpecifiesGzipEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+            .setBody("ABCABCABC")
+            .addHeader("Content-Type: text/plain")
+            .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+            .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
+            .addHeader("Content-Type: text/plain")
+            .addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse()
+            .setBody("DEFDEFDEF"));
+
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("DEFDEFDEF", get(server.url("/")).body().string());
+  }
+
+  @Test public void changedGzippedContentIsNotModifiedAndSpecifiesNewEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+            .setBody(gzip("ABCABCABC"))
+            .addHeader("Content-Type: text/plain")
+            .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS))
+            .addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse()
+            .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
+            .addHeader("Content-Type: text/plain")
+            .addHeader("Content-Encoding: identity"));
+    server.enqueue(new MockResponse()
+            .setBody("DEFDEFDEF"));
+
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("ABCABCABC", get(server.url("/")).body().string());
+    assertEquals("DEFDEFDEF", get(server.url("/")).body().string());
+  }
+
   @Test public void notModifiedSpecifiesEncoding() throws Exception {
     server.enqueue(new MockResponse()
         .setBody(gzip("ABCABCABC"))
@@ -1314,7 +1382,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
     Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
     DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
-    dateFormat.setTimeZone(TimeZone.getTimeZone("EDT"));
+    dateFormat.setTimeZone(TimeZone.getTimeZone("America/New_York"));
     String lastModifiedString = dateFormat.format(lastModifiedDate);
     String servedString = dateFormat.format(servedDate);
 
@@ -1692,7 +1760,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   }
 
   @Test public void varyAndHttps() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()
         .addHeader("Cache-Control: max-age=60")
         .addHeader("Vary: Accept-Language")
@@ -1701,7 +1769,8 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
         .setBody("B"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build();
 
@@ -2453,6 +2522,33 @@ private RecordedRequest assertConditionallyCached(MockResponse response) throws
     return server.takeRequest(); // conditional get
   }
 
+  @Test public void immutableIsCached() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control", "immutable")
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setBody("B"));
+
+    HttpUrl url = server.url("/");
+    assertEquals("A", get(url).body().string());
+    assertEquals("A", get(url).body().string());
+  }
+
+  @Test public void immutableIsCachedAfterMultipleCalls() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control", "immutable")
+        .setBody("B"));
+    server.enqueue(new MockResponse()
+        .setBody("C"));
+
+    HttpUrl url = server.url("/");
+    assertEquals("A", get(url).body().string());
+    assertEquals("B", get(url).body().string());
+    assertEquals("B", get(url).body().string());
+  }
+
   private void assertFullyCached(MockResponse response) throws Exception {
     server.enqueue(response.setBody("A"));
     server.enqueue(response.setBody("B"));
diff --git a/okhttp-tests/src/test/java/okhttp3/CallTest.java b/okhttp-tests/src/test/java/okhttp3/CallTest.java
index 6ecdcb421a..9bbcce07de 100644
--- a/okhttp-tests/src/test/java/okhttp3/CallTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CallTest.java
@@ -16,6 +16,7 @@
 package okhttp3;
 
 import java.io.File;
+import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InterruptedIOException;
@@ -23,10 +24,8 @@
 import java.net.HttpCookie;
 import java.net.HttpURLConnection;
 import java.net.InetAddress;
-import java.net.InetSocketAddress;
 import java.net.ProtocolException;
 import java.net.Proxy;
-import java.net.ServerSocket;
 import java.net.SocketTimeoutException;
 import java.net.UnknownHostException;
 import java.net.UnknownServiceException;
@@ -46,11 +45,13 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import java.util.logging.SimpleFormatter;
-import javax.net.ServerSocketFactory;
+import javax.annotation.Nullable;
+import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLProtocolException;
@@ -63,13 +64,13 @@
 import okhttp3.internal.Version;
 import okhttp3.internal.http.RecordingProxySelector;
 import okhttp3.internal.io.InMemoryFileSystem;
-import okhttp3.internal.tls.HeldCertificate;
-import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
+import okhttp3.tls.HeldCertificate;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.BufferedSource;
@@ -86,8 +87,11 @@
 import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
 import static okhttp3.TestUtil.awaitGarbageCollection;
 import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
@@ -99,12 +103,11 @@
   @Rule public final MockWebServer server2 = new MockWebServer();
   @Rule public final InMemoryFileSystem fileSystem = new InMemoryFileSystem();
 
-  private SslClient sslClient = SslClient.localhost();
+  private HandshakeCertificates handshakeCertificates = localhost();
   private OkHttpClient client = defaultClient();
   private RecordingCallback callback = new RecordingCallback();
   private TestLogHandler logHandler = new TestLogHandler();
   private Cache cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
-  private ServerSocket nullServer;
   private Logger logger = Logger.getLogger(OkHttpClient.class.getName());
 
   @Before public void setUp() throws Exception {
@@ -113,7 +116,6 @@
 
   @After public void tearDown() throws Exception {
     cache.delete();
-    Util.closeQuietly(nullServer);
     logger.removeHandler(logHandler);
   }
 
@@ -156,7 +158,7 @@
       requestBuilder.url("ftp://hostname/path");
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals(expected.getMessage(), "unexpected url: ftp://hostname/path");
+      assertEquals("Expected URL scheme 'http' or 'https' but was 'ftp'", expected.getMessage());
     }
   }
 
@@ -166,7 +168,7 @@
       requestBuilder.url("http://localhost:65536/");
       fail();
     } catch (IllegalArgumentException expected) {
-      assertEquals(expected.getMessage(), "unexpected url: http://localhost:65536/");
+      assertEquals("Invalid URL port: \"65536\"", expected.getMessage());
     }
   }
 
@@ -209,7 +211,7 @@
     server.enqueue(new MockResponse());
 
     try {
-      new Request.Builder().method("GET", RequestBody.create(MediaType.parse("text/plain"), "abc"));
+      new Request.Builder().method("GET", RequestBody.create(MediaType.get("text/plain"), "abc"));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -246,10 +248,9 @@
         .url(server.url("/"))
         .head()
         .build();
-    executeSynchronously(headRequest)
-        .assertCode(200)
-        .assertHeader("Content-Length", "100")
-        .assertBody("");
+    Response response = client.newCall(headRequest).execute();
+    assertEquals(200, response.code());
+    assertArrayEquals(new byte[0], response.body().bytes());
 
     Request getRequest = new Request.Builder()
         .url(server.url("/"))
@@ -304,7 +305,7 @@
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "def"))
         .build();
 
     executeSynchronously(request)
@@ -449,6 +450,28 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     }
   }
 
+  /**
+   * We had a bug where we were passing a null route to the authenticator.
+   * https://github.com/square/okhttp/issues/3809
+   */
+  @Test public void authenticateWithNoConnection() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Connection: close")
+        .setResponseCode(401)
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+
+    RecordingOkAuthenticator authenticator = new RecordingOkAuthenticator(null);
+
+    client = client.newBuilder()
+        .authenticator(authenticator)
+        .build();
+
+    executeSynchronously("/")
+        .assertCode(401);
+
+    assertNotNull(authenticator.onlyRoute());
+  }
+
   @Test public void delete() throws Exception {
     server.enqueue(new MockResponse().setBody("abc"));
 
@@ -483,7 +506,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .method("DELETE", RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .method("DELETE", RequestBody.create(MediaType.get("text/plain"), "def"))
         .build();
 
     executeSynchronously(request)
@@ -500,7 +523,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .put(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .put(RequestBody.create(MediaType.get("text/plain"), "def"))
         .build();
 
     executeSynchronously(request)
@@ -529,7 +552,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .patch(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .patch(RequestBody.create(MediaType.get("text/plain"), "def"))
         .build();
 
     executeSynchronously(request)
@@ -553,6 +576,25 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     patch();
   }
 
+  @Test public void customMethodWithBody() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .method("CUSTOM", RequestBody.create(MediaType.get("text/plain"), "def"))
+        .build();
+
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("CUSTOM", recordedRequest.getMethod());
+    assertEquals("def", recordedRequest.getBody().readUtf8());
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+  }
+
   @Test public void unspecifiedRequestBodyContentTypeDoesNotGetDefault() throws Exception {
     server.enqueue(new MockResponse());
 
@@ -832,10 +874,8 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
    * special address that never connects. The automatic retry will succeed.
    */
   @Test public void connectTimeoutsAttemptsAlternateRoute() throws Exception {
-    InetSocketAddress unreachableAddress = new InetSocketAddress("10.255.255.1", 8080);
-
     RecordingProxySelector proxySelector = new RecordingProxySelector();
-    proxySelector.proxies.add(new Proxy(Proxy.Type.HTTP, unreachableAddress));
+    proxySelector.proxies.add(new Proxy(Proxy.Type.HTTP, TestUtil.UNREACHABLE_ADDRESS));
     proxySelector.proxies.add(server.toProxyAddress());
 
     server.enqueue(new MockResponse()
@@ -858,14 +898,14 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
    * never responds. The manual retry will succeed.
    */
   @Test public void readTimeoutFails() throws Exception {
-    InetSocketAddress nullServerAddress = startNullServer();
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.STALL_SOCKET_AT_START));
+    server2.enqueue(new MockResponse()
+        .setBody("success!"));
 
     RecordingProxySelector proxySelector = new RecordingProxySelector();
-    proxySelector.proxies.add(new Proxy(Proxy.Type.HTTP, nullServerAddress));
     proxySelector.proxies.add(server.toProxyAddress());
-
-    server.enqueue(new MockResponse()
-        .setBody("success!"));
+    proxySelector.proxies.add(server2.toProxyAddress());
 
     client = client.newBuilder()
         .proxySelector(proxySelector)
@@ -902,7 +942,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     // Call 1: set a deadline on the request body.
     RequestBody requestBody1 = new RequestBody() {
       @Override public MediaType contentType() {
-        return MediaType.parse("text/plain");
+        return MediaType.get("text/plain");
       }
 
       @Override public void writeTo(BufferedSink sink) throws IOException {
@@ -920,7 +960,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     // Call 2: check for the absence of a deadline on the request body.
     RequestBody requestBody2 = new RequestBody() {
       @Override public MediaType contentType() {
-        return MediaType.parse("text/plain");
+        return MediaType.get("text/plain");
       }
 
       @Override public void writeTo(BufferedSink sink) throws IOException {
@@ -1030,15 +1070,31 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     noRecoverWhenRetryOnConnectionFailureIsFalse();
   }
 
+  @Test public void tlsHandshakeFailure_noFallbackByDefault() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setBody("response that will never be received"));
+    RecordedResponse response = executeSynchronously("/");
+    response.assertFailure(
+            SSLException.class, // JDK 11 response to the FAIL_HANDSHAKE
+            SSLProtocolException.class, // RI response to the FAIL_HANDSHAKE
+            SSLHandshakeException.class // Android's response to the FAIL_HANDSHAKE
+    );
+    assertFalse(client.connectionSpecs().contains(ConnectionSpec.COMPATIBLE_TLS));
+  }
+
   @Test public void recoverFromTlsHandshakeFailure() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("abc"));
 
     client = client.newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
         .dns(new SingleInetAddressDns())
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
+        .connectionSpecs(Arrays.asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
         .build();
 
     executeSynchronously("/").assertBody("abc");
@@ -1047,19 +1103,21 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   @Test public void recoverFromTlsHandshakeFailure_tlsFallbackScsvEnabled() throws Exception {
     final String tlsFallbackScsv = "TLS_FALLBACK_SCSV";
     List<String> supportedCiphers =
-        Arrays.asList(sslClient.socketFactory.getSupportedCipherSuites());
+        Arrays.asList(handshakeCertificates.sslSocketFactory().getSupportedCipherSuites());
     if (!supportedCiphers.contains(tlsFallbackScsv)) {
       // This only works if the client socket supports TLS_FALLBACK_SCSV.
       return;
     }
 
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
 
     RecordingSSLSocketFactory clientSocketFactory =
-        new RecordingSSLSocketFactory(sslClient.socketFactory);
+        new RecordingSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     client = client.newBuilder()
-        .sslSocketFactory(clientSocketFactory, sslClient.trustManager)
+        .sslSocketFactory(clientSocketFactory, handshakeCertificates.trustManager())
+        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
+        .connectionSpecs(Arrays.asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .dns(new SingleInetAddressDns())
         .build();
@@ -1079,13 +1137,16 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   @Test public void recoverFromTlsHandshakeFailure_Async() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("abc"));
 
     client = client.newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
+        .connectionSpecs(Arrays.asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
         .build();
 
     Request request = new Request.Builder()
@@ -1101,10 +1162,11 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
         .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .dns(new SingleInetAddressDns())
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
         .build();
 
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
 
     Request request = new Request.Builder().url(server.url("/")).build();
@@ -1115,6 +1177,10 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
       // RI response to the FAIL_HANDSHAKE
     } catch (SSLHandshakeException expected) {
       // Android's response to the FAIL_HANDSHAKE
+    } catch (SSLException expected) {
+      // JDK 11 response to the FAIL_HANDSHAKE
+      String jvmVersion = System.getProperty("java.specification.version");
+      assertEquals("11", jvmVersion);
     }
   }
 
@@ -1135,6 +1201,25 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     }
   }
 
+  @Test public void httpsCallsFailWhenProtocolIsH2PriorKnowledge() throws Exception {
+    client = client.newBuilder()
+        .protocols(Collections.singletonList(Protocol.H2_PRIOR_KNOWLEDGE))
+        .build();
+
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (UnknownServiceException expected) {
+      assertEquals("H2_PRIOR_KNOWLEDGE cannot be used with HTTPS", expected.getMessage());
+    }
+  }
+
   @Test public void setFollowSslRedirectsFalse() throws Exception {
     enableTls();
     server.enqueue(new MockResponse()
@@ -1201,7 +1286,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "def"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "def"))
         .build();
     client.newCall(request).enqueue(callback);
 
@@ -1227,7 +1312,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Request request2 = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "body!"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "body!"))
         .build();
     Response response2 = client.newCall(request2).execute();
     assertEquals("def", response2.body().string());
@@ -1501,7 +1586,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
     // Attempt conditional cache validation and a DNS miss.
     client.connectionPool().evictAll();
     client = client.newBuilder()
-        .dns(new FakeDns().unknownHost())
+        .dns(new FakeDns())
         .build();
     executeSynchronously("/").assertFailure(UnknownHostException.class);
   }
@@ -1543,7 +1628,7 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
 
     Response response = client.newCall(new Request.Builder()
         .url(server.url("/page1"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "Request Body"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "Request Body"))
         .build()).execute();
     assertEquals("Page 2", response.body().string());
 
@@ -1556,30 +1641,50 @@ private void postBodyRetransmittedAfterAuthorizationFail(String body) throws Exc
   }
 
   @Test public void getClientRequestTimeout() throws Exception {
-    enqueueRequestTimeoutResponses();
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(408)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+    server.enqueue(new MockResponse().setBody("Body"));
 
-    Response response = client.newCall(new Request.Builder()
-        .url(server.url("/")).build()).execute();
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
 
     assertEquals("Body", response.body().string());
   }
 
-  private void enqueueRequestTimeoutResponses() {
+  @Test public void getClientRequestTimeoutWithBackPressure() throws Exception {
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
-        .setResponseCode(HttpURLConnection.HTTP_CLIENT_TIMEOUT)
+        .setResponseCode(408)
         .setHeader("Connection", "Close")
+        .setHeader("Retry-After", "1")
         .setBody("You took too long!"));
-    server.enqueue(new MockResponse().setBody("Body"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
+
+    assertEquals("You took too long!", response.body().string());
   }
 
   @Test public void requestBodyRetransmittedOnClientRequestTimeout() throws Exception {
-    enqueueRequestTimeoutResponses();
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(408)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+    server.enqueue(new MockResponse().setBody("Body"));
 
-    Response response = client.newCall(new Request.Builder()
+    Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "Hello"))
-        .build()).execute();
+        .post(RequestBody.create(MediaType.get("text/plain"), "Hello"))
+        .build();
+    Response response = client.newCall(request).execute();
 
     assertEquals("Body", response.body().string());
 
@@ -1590,6 +1695,91 @@ private void enqueueRequestTimeoutResponses() {
     assertEquals("Hello", request2.getBody().readUtf8());
   }
 
+  @Test public void disableClientRequestTimeoutRetry() throws IOException {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(408)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+
+    client = client.newBuilder()
+        .retryOnConnectionFailure(false)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
+
+    assertEquals(408, response.code());
+    assertEquals("You took too long!", response.body().string());
+  }
+
+  @Test public void maxClientRequestTimeoutRetries() throws IOException {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(408)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(408)
+        .setHeader("Connection", "Close")
+        .setBody("You took too long!"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
+
+    assertEquals(408, response.code());
+    assertEquals("You took too long!", response.body().string());
+
+    assertEquals(2, server.getRequestCount());
+  }
+
+  @Test public void maxUnavailableTimeoutRetries() throws IOException {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(503)
+        .setHeader("Connection", "Close")
+        .setHeader("Retry-After", "0")
+        .setBody("You took too long!"));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(503)
+        .setHeader("Connection", "Close")
+        .setHeader("Retry-After", "0")
+        .setBody("You took too long!"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
+
+    assertEquals(503, response.code());
+    assertEquals("You took too long!", response.body().string());
+
+    assertEquals(2, server.getRequestCount());
+  }
+
+  @Test public void retryOnUnavailableWith0RetryAfter() throws IOException {
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setResponseCode(503)
+        .setHeader("Connection", "Close")
+        .setHeader("Retry-After", "0")
+        .setBody("You took too long!"));
+    server.enqueue(new MockResponse().setBody("Body"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Response response = client.newCall(request).execute();
+
+    assertEquals("Body", response.body().string());
+  }
+
   @Test public void propfindRedirectsToPropfindAndMaintainsRequestBody() throws Exception {
     // given
     server.enqueue(new MockResponse()
@@ -1601,7 +1791,7 @@ private void enqueueRequestTimeoutResponses() {
     // when
     Response response = client.newCall(new Request.Builder()
         .url(server.url("/page1"))
-        .method("PROPFIND", RequestBody.create(MediaType.parse("text/plain"), "Request Body"))
+        .method("PROPFIND", RequestBody.create(MediaType.get("text/plain"), "Request Body"))
         .build()).execute();
 
     // then
@@ -1812,6 +2002,25 @@ private void enqueueRequestTimeoutResponses() {
         .assertFailure("HTTP 205 had non-zero Content-Length: 39");
   }
 
+  @Test public void httpWithExcessiveHeaders() throws IOException {
+    String longLine = "HTTP/1.1 200 " + stringFill('O', 256 * 1024) + "K";
+
+    server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
+
+    server.enqueue(new MockResponse()
+        .setStatus(longLine)
+        .setBody("I'm not even supposed to be here today."));
+
+    executeSynchronously("/")
+        .assertFailureMatches(".*unexpected end of stream on Connection.*");
+  }
+
+  private String stringFill(char fillChar, int length) {
+    char[] value = new char[length];
+    Arrays.fill(value, fillChar);
+    return new String(value);
+  }
+
   @Test public void canceledBeforeExecute() throws Exception {
     Call call = client.newCall(new Request.Builder().url(server.url("/a")).build());
     call.cancel();
@@ -1834,16 +2043,13 @@ private void enqueueRequestTimeoutResponses() {
 
   /** Cancel a call that's waiting for connect to complete. */
   private void cancelDuringConnect(String scheme) throws Exception {
-    InetSocketAddress socketAddress = startNullServer();
-
-    HttpUrl url = new HttpUrl.Builder()
-        .scheme(scheme)
-        .host(socketAddress.getHostName())
-        .port(socketAddress.getPort())
-        .build();
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.STALL_SOCKET_AT_START));
 
     long cancelDelayMillis = 300L;
-    Call call = client.newCall(new Request.Builder().url(url).build());
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/").newBuilder().scheme(scheme).build())
+        .build());
     cancelLater(call, cancelDelayMillis);
 
     long startNanos = System.nanoTime();
@@ -1856,20 +2062,29 @@ private void cancelDuringConnect(String scheme) throws Exception {
     assertEquals(cancelDelayMillis, TimeUnit.NANOSECONDS.toMillis(elapsedNanos), 100f);
   }
 
-  private InetSocketAddress startNullServer() throws IOException {
-    InetSocketAddress address = new InetSocketAddress(InetAddress.getByName("localhost"), 0);
-    nullServer = ServerSocketFactory.getDefault().createServerSocket();
-    nullServer.bind(address);
-    return new InetSocketAddress(address.getAddress(), nullServer.getLocalPort());
-  }
-
   @Test public void cancelImmediatelyAfterEnqueue() throws Exception {
     server.enqueue(new MockResponse());
+    final CountDownLatch latch = new CountDownLatch(1);
+    client = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            try {
+              latch.await();
+            } catch (InterruptedException e) {
+              throw new AssertionError(e);
+            }
+            return chain.proceed(chain.request());
+          }
+        })
+        .build();
+
     Call call = client.newCall(new Request.Builder()
         .url(server.url("/a"))
         .build());
     call.enqueue(callback);
     call.cancel();
+    latch.countDown();
+
     callback.await(server.url("/a")).assertFailure("Canceled", "Socket closed");
   }
 
@@ -2207,7 +2422,7 @@ private InetSocketAddress startNullServer() throws IOException {
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build();
 
     executeSynchronously(request)
@@ -2223,7 +2438,7 @@ private InetSocketAddress startNullServer() throws IOException {
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.parse("text/plain"), ""))
+        .post(RequestBody.create(MediaType.get("text/plain"), ""))
         .build();
 
     executeSynchronously(request)
@@ -2247,7 +2462,7 @@ private InetSocketAddress startNullServer() throws IOException {
     Request request = new Request.Builder()
         .url(server.url("/"))
         .header("Expect", "100-continue")
-        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build();
 
     Call call = client.newCall(request);
@@ -2268,18 +2483,16 @@ private InetSocketAddress startNullServer() throws IOException {
 
   @Test public void serverRespondsWithUnsolicited100Continue() throws Exception {
     server.enqueue(new MockResponse()
-        .setStatus("HTTP/1.1 100 Continue"));
+        .setSocketPolicy(SocketPolicy.CONTINUE_ALWAYS));
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build();
 
-    Call call = client.newCall(request);
-    Response response = call.execute();
-    assertEquals(100, response.code());
-    assertEquals("Continue", response.message());
-    assertEquals("", response.body().string());
+    executeSynchronously(request)
+        .assertCode(200)
+        .assertSuccessful();
 
     RecordedRequest recordedRequest = server.takeRequest();
     assertEquals("abc", recordedRequest.getBody().readUtf8());
@@ -2290,24 +2503,89 @@ private InetSocketAddress startNullServer() throws IOException {
     serverRespondsWithUnsolicited100Continue();
   }
 
-  @Test public void successfulExpectContinueAndConnectionReuse() throws Exception {
+  @Test public void serverRespondsWith100ContinueOnly() throws Exception {
+    client = client.newBuilder()
+        .readTimeout(1, TimeUnit.SECONDS)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .setStatus("HTTP/1.1 100 Continue"));
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
+        .build();
+
+    Call call = client.newCall(request);
+    try {
+      call.execute();
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("abc", recordedRequest.getBody().readUtf8());
+  }
+
+  @Test public void serverRespondsWith100ContinueOnly_HTTP2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    serverRespondsWith100ContinueOnly();
+  }
+
+  @Test public void successfulExpectContinuePermitsConnectionReuse() throws Exception {
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.EXPECT_CONTINUE));
     server.enqueue(new MockResponse());
 
-    executeSynchronously("/", "Expect", "100-continue");
-    executeSynchronously("/");
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .header("Expect", "100-continue")
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
+        .build());
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .build());
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(1, server.takeRequest().getSequenceNumber());
   }
 
-  @Test public void unsuccessfulExpectContinueAndConnectionReuse() throws Exception {
+  @Test public void successfulExpectContinuePermitsConnectionReuseWithHttp2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+    successfulExpectContinuePermitsConnectionReuse();
+  }
+
+  @Test public void unsuccessfulExpectContinuePreventsConnectionReuse() throws Exception {
     server.enqueue(new MockResponse());
     server.enqueue(new MockResponse());
 
-    executeSynchronously("/", "Expect", "100-continue");
-    executeSynchronously("/");
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .header("Expect", "100-continue")
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
+        .build());
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void unsuccessfulExpectContinuePermitsConnectionReuseWithHttp2() throws Exception {
+    enableProtocol(Protocol.HTTP_2);
+
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .header("Expect", "100-continue")
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
+        .build());
+    executeSynchronously(new Request.Builder()
+        .url(server.url("/"))
+        .build());
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(1, server.takeRequest().getSequenceNumber());
@@ -2330,9 +2608,9 @@ private InetSocketAddress startNullServer() throws IOException {
   }
 
   @Test public void customDns() throws Exception {
-    // Configure a DNS that returns our MockWebServer for every hostname.
+    // Configure a DNS that returns our local MockWebServer for android.com.
     FakeDns dns = new FakeDns();
-    dns.addresses(Dns.SYSTEM.lookup(server.url("/").host()));
+    dns.set("android.com", Dns.SYSTEM.lookup(server.url("/").host()));
     client = client.newBuilder()
         .dns(dns)
         .build();
@@ -2345,6 +2623,23 @@ private InetSocketAddress startNullServer() throws IOException {
 
     dns.assertRequests("android.com");
   }
+  @Test public void dnsReturnsZeroIpAddresses() throws Exception {
+    // Configure a DNS that returns our local MockWebServer for android.com.
+    FakeDns dns = new FakeDns();
+    List<InetAddress> ipAddresses = new ArrayList<>();
+    dns.set("android.com", ipAddresses);
+    client = client.newBuilder()
+        .dns(dns)
+        .build();
+
+    server.enqueue(new MockResponse());
+    Request request = new Request.Builder()
+        .url(server.url("/").newBuilder().host("android.com").build())
+        .build();
+    executeSynchronously(request).assertFailure(dns + " returned no addresses for android.com");
+
+    dns.assertRequests("android.com");
+  }
 
   /** We had a bug where failed HTTP/2 calls could break the entire connection. */
   @Test public void failingCallsDoNotInterfereWithConnection() throws Exception {
@@ -2377,7 +2672,7 @@ private InetSocketAddress startNullServer() throws IOException {
 
   /** Test which headers are sent unencrypted to the HTTP proxy. */
   @Test public void proxyConnectOmitsApplicationHeaders() throws Exception {
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
         .clearHeaders());
@@ -2386,7 +2681,8 @@ private InetSocketAddress startNullServer() throws IOException {
 
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .proxy(server.toProxyAddress())
         .hostnameVerifier(hostnameVerifier)
         .build();
@@ -2414,7 +2710,7 @@ private InetSocketAddress startNullServer() throws IOException {
 
   /** Respond to a proxy authorization challenge. */
   @Test public void proxyAuthenticateOnConnect() throws Exception {
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.enqueue(new MockResponse()
         .setResponseCode(407)
         .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
@@ -2425,7 +2721,8 @@ private InetSocketAddress startNullServer() throws IOException {
         .setBody("response body"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .proxy(server.toProxyAddress())
         .proxyAuthenticator(new RecordingOkAuthenticator("password"))
         .hostnameVerifier(new RecordingHostnameVerifier())
@@ -2483,7 +2780,7 @@ private InetSocketAddress startNullServer() throws IOException {
    * TLS tunnel. https://github.com/square/okhttp/issues/2426
    */
   @Test public void proxyAuthenticateOnConnectWithConnectionClose() throws Exception {
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
     server.enqueue(new MockResponse()
         .setResponseCode(407)
@@ -2496,7 +2793,8 @@ private InetSocketAddress startNullServer() throws IOException {
         .setBody("response body"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .proxy(server.toProxyAddress())
         .proxyAuthenticator(new RecordingOkAuthenticator("password"))
         .hostnameVerifier(new RecordingHostnameVerifier())
@@ -2519,7 +2817,7 @@ private InetSocketAddress startNullServer() throws IOException {
   }
 
   @Test public void tooManyProxyAuthFailuresWithConnectionClose() throws IOException {
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
     for (int i = 0; i < 21; i++) {
       server.enqueue(new MockResponse()
@@ -2529,7 +2827,8 @@ private InetSocketAddress startNullServer() throws IOException {
     }
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .proxy(server.toProxyAddress())
         .proxyAuthenticator(new RecordingOkAuthenticator("password"))
         .hostnameVerifier(new RecordingHostnameVerifier())
@@ -2551,7 +2850,7 @@ private InetSocketAddress startNullServer() throws IOException {
    * credentials. Worse, that approach leaks proxy credentials to the origin server.
    */
   @Test public void noProactiveProxyAuthorization() throws Exception {
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
         .clearHeaders());
@@ -2559,7 +2858,8 @@ private InetSocketAddress startNullServer() throws IOException {
         .setBody("response body"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .proxy(server.toProxyAddress())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
@@ -2578,7 +2878,7 @@ private InetSocketAddress startNullServer() throws IOException {
     assertEquals("password", get.getHeader("Proxy-Authorization"));
   }
 
-  @Test public void interceptorGetsFramedProtocol() throws Exception {
+  @Test public void interceptorGetsHttp2() throws Exception {
     enableProtocol(Protocol.HTTP_2);
 
     // Capture the protocol as it is observed by the interceptor.
@@ -2691,7 +2991,7 @@ private InetSocketAddress startNullServer() throws IOException {
 
     Request request = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build();
 
     executeSynchronously(request);
@@ -2701,7 +3001,7 @@ private InetSocketAddress startNullServer() throws IOException {
   @Ignore // This may fail in DNS lookup, which we don't have timeouts for.
   @Test public void invalidHost() throws Exception {
     Request request = new Request.Builder()
-        .url(HttpUrl.parse("http://1234.1.1.1/"))
+        .url(HttpUrl.get("http://1234.1.1.1/"))
         .build();
 
     executeSynchronously(request)
@@ -2748,7 +3048,7 @@ private void upload(
   /** https://github.com/square/okhttp/issues/2344 */
   @Test public void ipv6HostHasSquareBraces() throws Exception {
     // Use a proxy to fake IPv6 connectivity, even if localhost doesn't have IPv6.
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.setProtocols(Collections.singletonList(Protocol.HTTP_1_1));
     server.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END)
@@ -2757,7 +3057,8 @@ private void upload(
         .setBody("response body"));
 
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .proxy(server.toProxyAddress())
         .build();
@@ -2783,7 +3084,7 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
 
     return new RequestBody() {
       @Override public MediaType contentType() {
-        return MediaType.parse("text/plain; charset=utf-8");
+        return MediaType.get("text/plain; charset=utf-8");
       }
 
       @Override public long contentLength() throws IOException {
@@ -2827,7 +3128,7 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
       awaitGarbageCollection();
 
       String message = logHandler.take();
-      assertTrue(message.contains("WARNING: A connection to " + server.url("/") + " was leaked."
+      assertTrue(message.contains("A connection to " + server.url("/") + " was leaked."
           + " Did you forget to close a response body?"));
       assertTrue(message.contains("okhttp3.RealCall.execute("));
       assertTrue(message.contains("okhttp3.CallTest.leakedResponseBodyLogsStackTrace("));
@@ -2870,7 +3171,7 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
       awaitGarbageCollection();
 
       String message = logHandler.take();
-      assertTrue(message.contains("WARNING: A connection to " + server.url("/") + " was leaked."
+      assertTrue(message.contains("A connection to " + server.url("/") + " was leaked."
           + " Did you forget to close a response body?"));
       assertTrue(message.contains("okhttp3.RealCall.enqueue("));
       assertTrue(message.contains("okhttp3.CallTest.asyncLeakedResponseBodyLogsStackTrace("));
@@ -2879,23 +3180,70 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
     }
   }
 
+  @Test public void failedAuthenticatorReleasesConnection() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(401));
+
+    client.connectionPool().evictAll();
+    client = client.newBuilder()
+        .authenticator(new Authenticator() {
+          @Override public Request authenticate(Route route, Response response) throws IOException {
+            throw new IOException("IOException!");
+          }
+        })
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    executeSynchronously(request)
+        .assertFailure(IOException.class);
+
+    assertEquals(1, client.connectionPool().idleConnectionCount());
+  }
+
+  @Test public void failedProxyAuthenticatorReleasesConnection() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(407));
+
+    client.connectionPool().evictAll();
+    client = client.newBuilder()
+        .proxyAuthenticator(new Authenticator() {
+          @Override public Request authenticate(Route route, Response response) throws IOException {
+            throw new IOException("IOException!");
+          }
+        })
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+
+    executeSynchronously(request)
+        .assertFailure(IOException.class);
+
+    assertEquals(1, client.connectionPool().idleConnectionCount());
+  }
+
   @Test public void httpsWithIpAddress() throws Exception {
     String localIpAddress = InetAddress.getLoopbackAddress().getHostAddress();
 
     // Create a certificate with an IP address in the subject alt name.
     HeldCertificate heldCertificate = new HeldCertificate.Builder()
         .commonName("example.com")
-        .subjectAlternativeName(localIpAddress)
+        .addSubjectAlternativeName(localIpAddress)
         .build();
-    SslClient sslClient = new SslClient.Builder()
-        .certificateChain(heldCertificate.keyPair, heldCertificate.certificate)
-        .addTrustedCertificate(heldCertificate.certificate)
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .heldCertificate(heldCertificate)
+        .addTrustedCertificate(heldCertificate.certificate())
         .build();
 
     // Use that certificate on the server and trust it on the client.
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .protocols(Collections.singletonList(Protocol.HTTP_1_1))
         .build();
@@ -2916,6 +3264,31 @@ private RequestBody requestBody(final boolean chunked, final long size, final in
     assertEquals(localIpAddress + ":" + server.getPort(), recordedRequest.getHeader("Host"));
   }
 
+  @Test public void postWithFileNotFound() throws Exception {
+    final AtomicInteger called = new AtomicInteger(0);
+
+    RequestBody body = new RequestBody() {
+      @Nullable @Override public MediaType contentType() {
+        return MediaType.get("application/octet-stream");
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        called.incrementAndGet();
+        throw new FileNotFoundException();
+      }
+    };
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .post(body)
+        .build();
+
+    executeSynchronously(request)
+        .assertFailure(FileNotFoundException.class);
+
+    assertEquals(1L, called.get());
+  }
+
   private void makeFailingCall() {
     RequestBody requestBody = new RequestBody() {
       @Override public MediaType contentType() {
@@ -2979,10 +3352,11 @@ private void enableProtocol(Protocol protocol) {
 
   private void enableTls() {
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
   }
 
   private Buffer gzip(String data) throws IOException {
@@ -3031,6 +3405,6 @@ protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
    * for details.
    */
   private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
-    return new FallbackTestClientSocketFactory(sslClient.socketFactory);
+    return new FallbackTestClientSocketFactory(handshakeCertificates.sslSocketFactory());
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
index 3c5267bcc9..e61cb9f294 100644
--- a/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CertificateChainCleanerTest.java
@@ -15,39 +15,36 @@
  */
 package okhttp3;
 
-import java.security.GeneralSecurityException;
 import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
 import java.util.ArrayList;
 import java.util.List;
 import javax.net.ssl.SSLPeerUnverifiedException;
-import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.X509TrustManager;
-import okhttp3.internal.platform.Platform;
 import okhttp3.internal.tls.CertificateChainCleaner;
-import okhttp3.internal.tls.HeldCertificate;
-import okhttp3.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
+import okhttp3.tls.HeldCertificate;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 public final class CertificateChainCleanerTest {
-  @Test public void equalsFromCertificate() throws Exception {
+  @Test public void equalsFromCertificate() {
     HeldCertificate rootA = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate rootB = new HeldCertificate.Builder()
-        .serialNumber("2")
+        .serialNumber(2L)
         .build();
     assertEquals(
-        CertificateChainCleaner.get(rootA.certificate, rootB.certificate),
-        CertificateChainCleaner.get(rootB.certificate, rootA.certificate));
+        CertificateChainCleaner.get(rootA.certificate(), rootB.certificate()),
+        CertificateChainCleaner.get(rootB.certificate(), rootA.certificate()));
   }
 
-  @Test public void equalsFromTrustManager() throws Exception {
-    SslClient client = new SslClient.Builder().build();
-    X509TrustManager x509TrustManager = client.trustManager;
+  @Test public void equalsFromTrustManager() {
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder().build();
+    X509TrustManager x509TrustManager = handshakeCertificates.trustManager();
     assertEquals(
         CertificateChainCleaner.get(x509TrustManager),
         CertificateChainCleaner.get(x509TrustManager));
@@ -55,15 +52,15 @@
 
   @Test public void normalizeSingleSelfSignedCertificate() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
     assertEquals(list(root), cleaner.clean(list(root), "hostname"));
   }
 
-  @Test public void normalizeUnknownSelfSignedCertificate() throws Exception {
+  @Test public void normalizeUnknownSelfSignedCertificate() {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     CertificateChainCleaner cleaner = CertificateChainCleaner.get();
 
@@ -76,123 +73,123 @@
 
   @Test public void orderedChainOfCertificatesWithRoot() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .issuedBy(root)
+        .serialNumber(2L)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber("3")
-        .issuedBy(certA)
+        .serialNumber(3L)
+        .signedBy(certA)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
     assertEquals(list(certB, certA, root), cleaner.clean(list(certB, certA, root), "hostname"));
   }
 
   @Test public void orderedChainOfCertificatesWithoutRoot() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .issuedBy(root)
+        .serialNumber(2L)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber("3")
-        .issuedBy(certA)
+        .serialNumber(3L)
+        .signedBy(certA)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
     assertEquals(list(certB, certA, root),
         cleaner.clean(list(certB, certA), "hostname")); // Root is added!
   }
 
   @Test public void unorderedChainOfCertificatesWithRoot() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .issuedBy(root)
+        .serialNumber(2L)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber("3")
-        .issuedBy(certA)
+        .serialNumber(3L)
+        .signedBy(certA)
         .build();
     HeldCertificate certC = new HeldCertificate.Builder()
-        .serialNumber("4")
-        .issuedBy(certB)
+        .serialNumber(4L)
+        .signedBy(certB)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
     assertEquals(list(certC, certB, certA, root),
         cleaner.clean(list(certC, certA, root, certB), "hostname"));
   }
 
   @Test public void unorderedChainOfCertificatesWithoutRoot() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .issuedBy(root)
+        .serialNumber(2L)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber("3")
-        .issuedBy(certA)
+        .serialNumber(3L)
+        .signedBy(certA)
         .build();
     HeldCertificate certC = new HeldCertificate.Builder()
-        .serialNumber("4")
-        .issuedBy(certB)
+        .serialNumber(4L)
+        .signedBy(certB)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
     assertEquals(list(certC, certB, certA, root),
         cleaner.clean(list(certC, certA, certB), "hostname"));
   }
 
   @Test public void unrelatedCertificatesAreOmitted() throws Exception {
     HeldCertificate root = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .issuedBy(root)
+        .serialNumber(2L)
+        .signedBy(root)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber("3")
-        .issuedBy(certA)
+        .serialNumber(3L)
+        .signedBy(certA)
         .build();
     HeldCertificate certUnnecessary = new HeldCertificate.Builder()
-        .serialNumber("4")
+        .serialNumber(4L)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate);
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(root.certificate());
     assertEquals(list(certB, certA, root),
         cleaner.clean(list(certB, certUnnecessary, certA, root), "hostname"));
   }
 
   @Test public void chainGoesAllTheWayToSelfSignedRoot() throws Exception {
     HeldCertificate selfSigned = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate trusted = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .issuedBy(selfSigned)
+        .serialNumber(2L)
+        .signedBy(selfSigned)
         .build();
     HeldCertificate certA = new HeldCertificate.Builder()
-        .serialNumber("3")
-        .issuedBy(trusted)
+        .serialNumber(3L)
+        .signedBy(trusted)
         .build();
     HeldCertificate certB = new HeldCertificate.Builder()
-        .serialNumber("4")
-        .issuedBy(certA)
+        .serialNumber(4L)
+        .signedBy(certA)
         .build();
 
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(
-        selfSigned.certificate, trusted.certificate);
+        selfSigned.certificate(), trusted.certificate());
     assertEquals(list(certB, certA, trusted, selfSigned),
         cleaner.clean(list(certB, certA), "hostname"));
     assertEquals(list(certB, certA, trusted, selfSigned),
@@ -203,22 +200,22 @@
 
   @Test public void trustedRootNotSelfSigned() throws Exception {
     HeldCertificate unknownSigner = new HeldCertificate.Builder()
-        .serialNumber("1")
+        .serialNumber(1L)
         .build();
     HeldCertificate trusted = new HeldCertificate.Builder()
-        .issuedBy(unknownSigner)
-        .serialNumber("2")
+        .signedBy(unknownSigner)
+        .serialNumber(2L)
         .build();
     HeldCertificate intermediateCa = new HeldCertificate.Builder()
-        .issuedBy(trusted)
-        .serialNumber("3")
+        .signedBy(trusted)
+        .serialNumber(3L)
         .build();
     HeldCertificate certificate = new HeldCertificate.Builder()
-        .issuedBy(intermediateCa)
-        .serialNumber("4")
+        .signedBy(intermediateCa)
+        .serialNumber(4L)
         .build();
 
-    CertificateChainCleaner cleaner = CertificateChainCleaner.get(trusted.certificate);
+    CertificateChainCleaner cleaner = CertificateChainCleaner.get(trusted.certificate());
     assertEquals(list(certificate, intermediateCa, trusted),
         cleaner.clean(list(certificate, intermediateCa), "hostname"));
     assertEquals(list(certificate, intermediateCa, trusted),
@@ -229,23 +226,23 @@
     List<HeldCertificate> heldCertificates = chainOfLength(10);
     List<Certificate> certificates = new ArrayList<>();
     for (HeldCertificate heldCertificate : heldCertificates) {
-      certificates.add(heldCertificate.certificate);
+      certificates.add(heldCertificate.certificate());
     }
 
-    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate;
+    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate();
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(root);
     assertEquals(certificates, cleaner.clean(certificates, "hostname"));
     assertEquals(certificates, cleaner.clean(certificates.subList(0, 9), "hostname"));
   }
 
-  @Test public void chainTooLong() throws Exception {
+  @Test public void chainTooLong() {
     List<HeldCertificate> heldCertificates = chainOfLength(11);
     List<Certificate> certificates = new ArrayList<>();
     for (HeldCertificate heldCertificate : heldCertificates) {
-      certificates.add(heldCertificate.certificate);
+      certificates.add(heldCertificate.certificate());
     }
 
-    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate;
+    X509Certificate root = heldCertificates.get(heldCertificates.size() - 1).certificate();
     CertificateChainCleaner cleaner = CertificateChainCleaner.get(root);
     try {
       cleaner.clean(certificates, "hostname");
@@ -255,12 +252,12 @@
   }
 
   /** Returns a chain starting at the leaf certificate and progressing to the root. */
-  private List<HeldCertificate> chainOfLength(int length) throws GeneralSecurityException {
+  private List<HeldCertificate> chainOfLength(int length) {
     List<HeldCertificate> result = new ArrayList<>();
     for (int i = 1; i <= length; i++) {
       result.add(0, new HeldCertificate.Builder()
-          .issuedBy(!result.isEmpty() ? result.get(0) : null)
-          .serialNumber(Integer.toString(i))
+          .signedBy(!result.isEmpty() ? result.get(0) : null)
+          .serialNumber(i)
           .build());
     }
     return result;
@@ -269,7 +266,7 @@
   private List<Certificate> list(HeldCertificate... heldCertificates) {
     List<Certificate> result = new ArrayList<>();
     for (HeldCertificate heldCertificate : heldCertificates) {
-      result.add(heldCertificate.certificate);
+      result.add(heldCertificate.certificate());
     }
     return result;
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
index 26207c5980..28e2af8423 100644
--- a/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CertificatePinnerTest.java
@@ -15,13 +15,12 @@
  */
 package okhttp3;
 
-import java.security.GeneralSecurityException;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import okhttp3.CertificatePinner.Pin;
-import okhttp3.internal.tls.HeldCertificate;
+import okhttp3.tls.HeldCertificate;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -40,24 +39,20 @@
   static String certC1Sha256Pin;
 
   static {
-    try {
-      certA1 = new HeldCertificate.Builder()
-          .serialNumber("100")
-          .build();
-      certA1Sha256Pin = "sha256/" + CertificatePinner.sha256(certA1.certificate).base64();
-
-      certB1 = new HeldCertificate.Builder()
-          .serialNumber("200")
-          .build();
-      certB1Sha256Pin = "sha256/" + CertificatePinner.sha256(certB1.certificate).base64();
-
-      certC1 = new HeldCertificate.Builder()
-          .serialNumber("300")
-          .build();
-      certC1Sha256Pin = "sha256/" + CertificatePinner.sha256(certC1.certificate).base64();
-    } catch (GeneralSecurityException e) {
-      throw new AssertionError(e);
-    }
+    certA1 = new HeldCertificate.Builder()
+        .serialNumber(100L)
+        .build();
+    certA1Sha256Pin = "sha256/" + CertificatePinner.sha256(certA1.certificate()).base64();
+
+    certB1 = new HeldCertificate.Builder()
+        .serialNumber(200L)
+        .build();
+    certB1Sha256Pin = "sha256/" + CertificatePinner.sha256(certB1.certificate()).base64();
+
+    certC1 = new HeldCertificate.Builder()
+        .serialNumber(300L)
+        .build();
+    certC1Sha256Pin = "sha256/" + CertificatePinner.sha256(certC1.certificate()).base64();
   }
 
   @Test public void malformedPin() throws Exception {
@@ -81,16 +76,16 @@
   /** Multiple certificates generated from the same keypair have the same pin. */
   @Test public void sameKeypairSamePin() throws Exception {
     HeldCertificate heldCertificateA2 = new HeldCertificate.Builder()
-        .keyPair(certA1.keyPair)
-        .serialNumber("101")
+        .keyPair(certA1.keyPair())
+        .serialNumber(101L)
         .build();
-    String keypairACertificate2Pin = CertificatePinner.pin(heldCertificateA2.certificate);
+    String keypairACertificate2Pin = CertificatePinner.pin(heldCertificateA2.certificate());
 
     HeldCertificate heldCertificateB2 = new HeldCertificate.Builder()
-        .keyPair(certB1.keyPair)
-        .serialNumber("201")
+        .keyPair(certB1.keyPair())
+        .serialNumber(201L)
         .build();
-    String keypairBCertificate2Pin = CertificatePinner.pin(heldCertificateB2.certificate);
+    String keypairBCertificate2Pin = CertificatePinner.pin(heldCertificateB2.certificate());
 
     assertTrue(certA1Sha256Pin.equals(keypairACertificate2Pin));
     assertTrue(certB1Sha256Pin.equals(keypairBCertificate2Pin));
@@ -102,15 +97,15 @@
         .add("example.com", certA1Sha256Pin)
         .build();
 
-    certificatePinner.check("example.com", certA1.certificate);
+    certificatePinner.check("example.com", certA1.certificate());
   }
 
   @Test public void successfulCheckSha1Pin() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add("example.com", "sha1/" + CertificatePinner.sha1(certA1.certificate).base64())
+        .add("example.com", "sha1/" + CertificatePinner.sha1(certA1.certificate()).base64())
         .build();
 
-    certificatePinner.check("example.com", certA1.certificate);
+    certificatePinner.check("example.com", certA1.certificate());
   }
 
   @Test public void successfulMatchAcceptsAnyMatchingCertificate() throws Exception {
@@ -118,7 +113,7 @@
         .add("example.com", certB1Sha256Pin)
         .build();
 
-    certificatePinner.check("example.com", certA1.certificate, certB1.certificate);
+    certificatePinner.check("example.com", certA1.certificate(), certB1.certificate());
   }
 
   @Test public void unsuccessfulCheck() throws Exception {
@@ -127,7 +122,7 @@
         .build();
 
     try {
-      certificatePinner.check("example.com", certB1.certificate);
+      certificatePinner.check("example.com", certB1.certificate());
       fail();
     } catch (SSLPeerUnverifiedException expected) {
     }
@@ -138,8 +133,8 @@
         .add("example.com", certA1Sha256Pin, certB1Sha256Pin)
         .build();
 
-    certificatePinner.check("example.com", certA1.certificate);
-    certificatePinner.check("example.com", certB1.certificate);
+    certificatePinner.check("example.com", certA1.certificate());
+    certificatePinner.check("example.com", certB1.certificate());
   }
 
   @Test public void multipleHostnamesForOneCertificate() throws Exception {
@@ -148,13 +143,13 @@
         .add("www.example.com", certA1Sha256Pin)
         .build();
 
-    certificatePinner.check("example.com", certA1.certificate);
-    certificatePinner.check("www.example.com", certA1.certificate);
+    certificatePinner.check("example.com", certA1.certificate());
+    certificatePinner.check("www.example.com", certA1.certificate());
   }
 
   @Test public void absentHostnameMatches() throws Exception {
     CertificatePinner certificatePinner = new CertificatePinner.Builder().build();
-    certificatePinner.check("example.com", certA1.certificate);
+    certificatePinner.check("example.com", certA1.certificate());
   }
 
   @Test public void successfulCheckForWildcardHostname() throws Exception {
@@ -162,7 +157,7 @@
         .add("*.example.com", certA1Sha256Pin)
         .build();
 
-    certificatePinner.check("a.example.com", certA1.certificate);
+    certificatePinner.check("a.example.com", certA1.certificate());
   }
 
   @Test public void successfulMatchAcceptsAnyMatchingCertificateForWildcardHostname()
@@ -171,7 +166,7 @@
         .add("*.example.com", certB1Sha256Pin)
         .build();
 
-    certificatePinner.check("a.example.com", certA1.certificate, certB1.certificate);
+    certificatePinner.check("a.example.com", certA1.certificate(), certB1.certificate());
   }
 
   @Test public void unsuccessfulCheckForWildcardHostname() throws Exception {
@@ -180,7 +175,7 @@
         .build();
 
     try {
-      certificatePinner.check("a.example.com", certB1.certificate);
+      certificatePinner.check("a.example.com", certB1.certificate());
       fail();
     } catch (SSLPeerUnverifiedException expected) {
     }
@@ -191,8 +186,8 @@
         .add("*.example.com", certA1Sha256Pin, certB1Sha256Pin)
         .build();
 
-    certificatePinner.check("a.example.com", certA1.certificate);
-    certificatePinner.check("a.example.com", certB1.certificate);
+    certificatePinner.check("a.example.com", certA1.certificate());
+    certificatePinner.check("a.example.com", certB1.certificate());
   }
 
   @Test public void successfulCheckForOneHostnameWithWildcardAndDirectCertificate()
@@ -202,8 +197,8 @@
         .add("a.example.com", certB1Sha256Pin)
         .build();
 
-    certificatePinner.check("a.example.com", certA1.certificate);
-    certificatePinner.check("a.example.com", certB1.certificate);
+    certificatePinner.check("a.example.com", certA1.certificate());
+    certificatePinner.check("a.example.com", certB1.certificate());
   }
 
   @Test public void unsuccessfulCheckForOneHostnameWithWildcardAndDirectCertificate()
@@ -214,7 +209,7 @@
         .build();
 
     try {
-      certificatePinner.check("a.example.com", certC1.certificate);
+      certificatePinner.check("a.example.com", certC1.certificate());
       fail();
     } catch (SSLPeerUnverifiedException expected) {
     }
@@ -275,4 +270,32 @@
     List<Pin> expectedPin = Arrays.asList(new Pin("Ïƒkhttp.com", certA1Sha256Pin));
     assertEquals(expectedPin, certificatePinner.findMatchingPins("xn--khttp-fde.com"));
   }
+
+  /** https://github.com/square/okhttp/issues/3324 */
+  @Test public void checkSubstringMatch() throws Exception {
+    CertificatePinner certificatePinner = new CertificatePinner.Builder()
+        .add("*.example.com", certA1Sha256Pin)
+        .build();
+
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("a.example.com.notexample.com"));
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("example.com.notexample.com"));
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("notexample.com"));
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("example.com"));
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("a.b.example.com"));
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("ple.com"));
+    assertEquals(Collections.emptyList(),
+        certificatePinner.findMatchingPins("com"));
+
+    Pin expectedPin = new Pin("*.example.com", certA1Sha256Pin);
+    assertEquals(Collections.singletonList(expectedPin),
+        certificatePinner.findMatchingPins("a.example.com"));
+    assertEquals(Collections.singletonList(expectedPin),
+        certificatePinner.findMatchingPins("example.example.com"));
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java b/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java
index 683ef9be25..64754ad5c0 100644
--- a/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CipherSuiteTest.java
@@ -21,6 +21,7 @@
 import static okhttp3.CipherSuite.TLS_RSA_EXPORT_WITH_RC4_40_MD5;
 import static okhttp3.CipherSuite.TLS_RSA_WITH_AES_128_CBC_SHA256;
 import static okhttp3.CipherSuite.forJavaName;
+import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotEquals;
 import static org.junit.Assert.assertSame;
@@ -47,7 +48,7 @@
 
   @Test public void instancesAreInterned() {
     assertSame(forJavaName("TestCipherSuite"), forJavaName("TestCipherSuite"));
-    assertSame(CipherSuite.TLS_KRB5_WITH_DES_CBC_MD5,
+    assertSame(TLS_KRB5_WITH_DES_CBC_MD5,
         forJavaName(TLS_KRB5_WITH_DES_CBC_MD5.javaName()));
   }
 
@@ -89,24 +90,131 @@
   }
 
   /**
-   * Legacy ciphers (whose javaName starts with "SSL_") are now considered different from the
-   * corresponding "TLS_" ciphers. In OkHttp 3.3.1, only 19 of those would have been valid; those 19
-   * would have been considered equal to the corresponding "TLS_" ciphers.
+   * On the Oracle JVM some older cipher suites have the "SSL_" prefix and others have the "TLS_"
+   * prefix. On the IBM JVM all cipher suites have the "SSL_" prefix.
+   *
+   * <p>Prior to OkHttp 3.3.1 we accepted either form and consider them equivalent. And since OkHttp
+   * 3.7.0 this is also true. But OkHttp 3.3.1 through 3.6.0 treated these as different.
    */
   @Test public void forJavaName_fromLegacyEnumName() {
     // These would have been considered equal in OkHttp 3.3.1, but now aren't.
-    assertNotEquals(
+    assertEquals(
         forJavaName("TLS_RSA_EXPORT_WITH_RC4_40_MD5"),
         forJavaName("SSL_RSA_EXPORT_WITH_RC4_40_MD5"));
-
-    // The SSL_ one of these would have been invalid in OkHttp 3.3.1; it now is valid and not equal.
-    assertNotEquals(
+    assertEquals(
         forJavaName("TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"),
         forJavaName("SSL_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"));
-
-    // These would have not been valid in OkHttp 3.3.1, and now aren't equal.
-    assertNotEquals(
+    assertEquals(
         forJavaName("TLS_FAKE_NEW_CIPHER"),
         forJavaName("SSL_FAKE_NEW_CIPHER"));
   }
+
+  @Test public void applyIntersectionRetainsSslPrefixes() throws Exception {
+    FakeSslSocket socket = new FakeSslSocket();
+    socket.setEnabledProtocols(new String[] { "TLSv1" });
+    socket.setSupportedCipherSuites(new String[] { "SSL_A", "SSL_B", "SSL_C", "SSL_D", "SSL_E" });
+    socket.setEnabledCipherSuites(new String[] { "SSL_A", "SSL_B", "SSL_C" });
+
+    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_0)
+        .cipherSuites("TLS_A", "TLS_C", "TLS_E")
+        .build();
+    connectionSpec.apply(socket, false);
+
+    assertArrayEquals(new String[] { "SSL_A", "SSL_C" }, socket.enabledCipherSuites);
+  }
+
+  @Test public void applyIntersectionRetainsTlsPrefixes() throws Exception {
+    FakeSslSocket socket = new FakeSslSocket();
+    socket.setEnabledProtocols(new String[] { "TLSv1" });
+    socket.setSupportedCipherSuites(new String[] { "TLS_A", "TLS_B", "TLS_C", "TLS_D", "TLS_E" });
+    socket.setEnabledCipherSuites(new String[] { "TLS_A", "TLS_B", "TLS_C" });
+
+    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_0)
+        .cipherSuites("SSL_A", "SSL_C", "SSL_E")
+        .build();
+    connectionSpec.apply(socket, false);
+
+    assertArrayEquals(new String[] { "TLS_A", "TLS_C" }, socket.enabledCipherSuites);
+  }
+
+  @Test public void applyIntersectionAddsSslScsvForFallback() throws Exception {
+    FakeSslSocket socket = new FakeSslSocket();
+    socket.setEnabledProtocols(new String[] { "TLSv1" });
+    socket.setSupportedCipherSuites(new String[] { "SSL_A", "SSL_FALLBACK_SCSV" });
+    socket.setEnabledCipherSuites(new String[] { "SSL_A" });
+
+    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_0)
+        .cipherSuites("SSL_A")
+        .build();
+    connectionSpec.apply(socket, true);
+
+    assertArrayEquals(new String[] { "SSL_A", "SSL_FALLBACK_SCSV" }, socket.enabledCipherSuites);
+  }
+
+  @Test public void applyIntersectionAddsTlsScsvForFallback() throws Exception {
+    FakeSslSocket socket = new FakeSslSocket();
+    socket.setEnabledProtocols(new String[] { "TLSv1" });
+    socket.setSupportedCipherSuites(new String[] { "TLS_A", "TLS_FALLBACK_SCSV" });
+    socket.setEnabledCipherSuites(new String[] { "TLS_A" });
+
+    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_0)
+        .cipherSuites("TLS_A")
+        .build();
+    connectionSpec.apply(socket, true);
+
+    assertArrayEquals(new String[] { "TLS_A", "TLS_FALLBACK_SCSV" }, socket.enabledCipherSuites);
+  }
+
+  @Test public void applyIntersectionToProtocolVersion() throws Exception {
+    FakeSslSocket socket = new FakeSslSocket();
+    socket.setEnabledProtocols(new String[] { "TLSv1", "TLSv1.1", "TLSv1.2" });
+    socket.setSupportedCipherSuites(new String[] { "TLS_A" });
+    socket.setEnabledCipherSuites(new String[] { "TLS_A" });
+
+    ConnectionSpec connectionSpec = new ConnectionSpec.Builder(true)
+        .tlsVersions(TlsVersion.TLS_1_1, TlsVersion.TLS_1_2, TlsVersion.TLS_1_3)
+        .cipherSuites("TLS_A")
+        .build();
+    connectionSpec.apply(socket, false);
+
+    assertArrayEquals(new String[] { "TLSv1.1", "TLSv1.2" }, socket.enabledProtocols);
+  }
+
+  static final class FakeSslSocket extends DelegatingSSLSocket {
+    private String[] enabledProtocols;
+    private String[] supportedCipherSuites;
+    private String[] enabledCipherSuites;
+
+    FakeSslSocket() {
+      super(null);
+    }
+
+    @Override public String[] getEnabledProtocols() {
+      return enabledProtocols;
+    }
+
+    @Override public void setEnabledProtocols(String[] enabledProtocols) {
+      this.enabledProtocols = enabledProtocols;
+    }
+
+    @Override public String[] getSupportedCipherSuites() {
+      return supportedCipherSuites;
+    }
+
+    public void setSupportedCipherSuites(String[] supportedCipherSuites) {
+      this.supportedCipherSuites = supportedCipherSuites;
+    }
+
+    @Override public String[] getEnabledCipherSuites() {
+      return enabledCipherSuites;
+    }
+
+    @Override public void setEnabledCipherSuites(String[] enabledCipherSuites) {
+      this.enabledCipherSuites = enabledCipherSuites;
+    }
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java
new file mode 100644
index 0000000000..be741a0b53
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionCoalescingTest.java
@@ -0,0 +1,336 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLSession;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.tls.HeldCertificate;
+import okhttp3.tls.HandshakeCertificates;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class ConnectionCoalescingTest {
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private OkHttpClient client;
+
+  private HeldCertificate rootCa;
+  private HeldCertificate certificate;
+  private FakeDns dns = new FakeDns();
+  private HttpUrl url;
+  private List<InetAddress> serverIps;
+
+  @Before public void setUp() throws Exception {
+    rootCa = new HeldCertificate.Builder()
+        .serialNumber(1L)
+        .certificateAuthority(0)
+        .commonName("root")
+        .build();
+    certificate = new HeldCertificate.Builder()
+        .signedBy(rootCa)
+        .serialNumber(2L)
+        .commonName(server.getHostName())
+        .addSubjectAlternativeName(server.getHostName())
+        .addSubjectAlternativeName("san.com")
+        .addSubjectAlternativeName("*.wildcard.com")
+        .addSubjectAlternativeName("differentdns.com")
+        .build();
+
+    serverIps = Dns.SYSTEM.lookup(server.getHostName());
+
+    dns.set(server.getHostName(), serverIps);
+    dns.set("san.com", serverIps);
+    dns.set("nonsan.com", serverIps);
+    dns.set("www.wildcard.com", serverIps);
+    dns.set("differentdns.com", Collections.<InetAddress>emptyList());
+
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(rootCa.certificate())
+        .build();
+
+    client = new OkHttpClient.Builder().dns(dns)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .build();
+
+    HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
+        .heldCertificate(certificate)
+        .build();
+    server.useHttps(serverHandshakeCertificates.sslSocketFactory(), false);
+
+    url = server.url("/robots.txt");
+  }
+
+  /**
+   * Test connecting to the main host then an alternative, although only subject alternative names
+   * are used if present no special consideration of common name.
+   */
+  @Test public void commonThenAlternative() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /**
+   * Test connecting to an alternative host then common name, although only subject alternative
+   * names are used if present no special consideration of common name.
+   */
+  @Test public void alternativeThenCommon() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /** Test a previously coalesced connection that's no longer healthy. */
+  @Test public void staleCoalescedConnection() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    final AtomicReference<Connection> connection = new AtomicReference<>();
+    client = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            connection.set(chain.connection());
+            return chain.proceed(chain.request());
+          }
+        })
+        .build();
+    dns.set("san.com", Dns.SYSTEM.lookup(server.getHostName()).subList(0, 1));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    // Simulate a stale connection in the pool.
+    connection.get().socket().close();
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /** If the existing connection matches a SAN but not a match for DNS then skip. */
+  @Test public void skipsWhenDnsDontMatch() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl differentDnsUrl = url.newBuilder().host("differentdns.com").build();
+    try {
+      execute(differentDnsUrl);
+      fail("expected a failed attempt to connect");
+    } catch (IOException expected) {
+    }
+  }
+
+  /** Not in the certificate SAN. */
+  @Test public void skipsWhenNotSubjectAltName() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl nonsanUrl = url.newBuilder().host("nonsan.com").build();
+
+    try {
+      execute(nonsanUrl);
+      fail("expected a failed attempt to connect");
+    } catch (IOException expected) {
+    }
+  }
+
+  /** Can still coalesce when pinning is used if pins match. */
+  @Test public void coalescesWhenCertificatePinsMatch() throws Exception {
+    CertificatePinner pinner = new CertificatePinner.Builder()
+        .add("san.com", "sha1/" + CertificatePinner.sha1(certificate.certificate()).base64())
+        .build();
+    client = client.newBuilder().certificatePinner(pinner).build();
+
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /** Certificate pinning used and not a match will avoid coalescing and try to connect. */
+  @Test public void skipsWhenCertificatePinningFails() throws Exception {
+    CertificatePinner pinner = new CertificatePinner.Builder()
+        .add("san.com", "sha1/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=")
+        .build();
+    client = client.newBuilder().certificatePinner(pinner).build();
+
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+
+    try {
+      execute(sanUrl);
+      fail("expected a failed attempt to connect");
+    } catch (IOException expected) {
+    }
+  }
+
+  /**
+   * Skips coalescing when hostname verifier is overridden since the intention of the hostname
+   * verification is a black box.
+   */
+  @Test public void skipsWhenHostnameVerifierUsed() throws Exception {
+    HostnameVerifier verifier = new HostnameVerifier() {
+      @Override public boolean verify(String s, SSLSession sslSession) {
+        return true;
+      }
+    };
+    client = client.newBuilder().hostnameVerifier(verifier).build();
+
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assertEquals(2, client.connectionPool().connectionCount());
+  }
+
+  /**
+   * Check we would use an existing connection to a later DNS result instead of connecting to the
+   * first DNS result for the first time.
+   */
+  @Test public void prefersExistingCompatible() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    final AtomicInteger connectCount = new AtomicInteger();
+    EventListener listener = new EventListener() {
+      @Override public void connectStart(Call call, InetSocketAddress inetSocketAddress,
+          Proxy proxy) {
+        connectCount.getAndIncrement();
+      }
+    };
+    client = client.newBuilder()
+        .eventListener(listener)
+        .build();
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+    dns.set("san.com",
+        Arrays.asList(InetAddress.getByAddress("san.com", new byte[] {0, 0, 0, 0}),
+            serverIps.get(0)));
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assertEquals(1, client.connectionPool().connectionCount());
+    assertEquals(1, connectCount.get());
+  }
+
+  /** Check that wildcard SANs are supported. */
+  @Test public void commonThenWildcard() throws Exception {
+
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("www.wildcard.com").build();
+    assert200Http2Response(execute(sanUrl), "www.wildcard.com");
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /** Network interceptors check for changes to target. */
+  @Test public void worksWithNetworkInterceptors() throws Exception {
+    client = client.newBuilder().addNetworkInterceptor(new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        return chain.proceed(chain.request());
+      }
+    }).build();
+
+    server.enqueue(new MockResponse().setResponseCode(200));
+    server.enqueue(new MockResponse().setResponseCode(200));
+
+    assert200Http2Response(execute(url), server.getHostName());
+
+    HttpUrl sanUrl = url.newBuilder().host("san.com").build();
+    assert200Http2Response(execute(sanUrl), "san.com");
+
+    assertEquals(1, client.connectionPool().connectionCount());
+  }
+
+  /** Run against public external sites, doesn't run by default. */
+  @Ignore
+  @Test public void coalescesConnectionsToRealSites() throws IOException {
+    client = new OkHttpClient();
+
+    assert200Http2Response(execute("https://graph.facebook.com/robots.txt"), "graph.facebook.com");
+    assert200Http2Response(execute("https://www.facebook.com/robots.txt"), "m.facebook.com");
+    assert200Http2Response(execute("https://fb.com/robots.txt"), "m.facebook.com");
+    assert200Http2Response(execute("https://messenger.com/robots.txt"), "messenger.com");
+    assert200Http2Response(execute("https://m.facebook.com/robots.txt"), "m.facebook.com");
+
+    assertEquals(3, client.connectionPool().connectionCount());
+  }
+
+  private Response execute(String url) throws IOException {
+    return execute(HttpUrl.get(url));
+  }
+
+  private Response execute(HttpUrl url) throws IOException {
+    return client.newCall(new Request.Builder().url(url).build()).execute();
+  }
+
+  private void assert200Http2Response(Response response, String expectedHost) {
+    assertEquals(200, response.code());
+    assertEquals(expectedHost, response.request().url().host());
+    assertEquals(Protocol.HTTP_2, response.protocol());
+    response.body().close();
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
index 0d07c26b2d..ae8b0a2f6c 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionPoolTest.java
@@ -83,8 +83,9 @@
 
     RealConnection c1 = newConnection(pool, routeA1, 50L);
     synchronized (pool) {
-      StreamAllocation streamAllocation = new StreamAllocation(pool, addressA, null);
-      streamAllocation.acquire(c1);
+      StreamAllocation streamAllocation = new StreamAllocation(pool, addressA, null,
+          EventListener.NONE, null);
+      streamAllocation.acquire(c1, true);
     }
 
     // Running at time 50, the pool returns that nothing can be evicted until time 150.
@@ -176,8 +177,9 @@
   /** Use a helper method so there's no hidden reference remaining on the stack. */
   private void allocateAndLeakAllocation(ConnectionPool pool, RealConnection connection) {
     synchronized (pool) {
-      StreamAllocation leak = new StreamAllocation(pool, connection.route().address(), null);
-      leak.acquire(connection);
+      StreamAllocation leak = new StreamAllocation(pool, connection.route().address(), null,
+          EventListener.NONE, null);
+      leak.acquire(connection, true);
     }
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java b/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
index 533d8ab352..f5c8e75c85 100644
--- a/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ConnectionReuseTest.java
@@ -15,22 +15,21 @@
  */
 package okhttp3;
 
-import java.io.Closeable;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicReference;
 import javax.net.ssl.SSLException;
-import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
 import org.junit.rules.Timeout;
 
 import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -39,7 +38,7 @@
   @Rule public final TestRule timeout = new Timeout(30_000);
   @Rule public final MockWebServer server = new MockWebServer();
 
-  private SslClient sslClient = SslClient.localhost();
+  private HandshakeCertificates handshakeCertificates = localhost();
   private OkHttpClient client = defaultClient();
 
   @Test public void connectionsAreReused() throws Exception {
@@ -193,7 +192,7 @@
 
     Request requestB = new Request.Builder()
         .url(server.url("/"))
-        .post(RequestBody.create(MediaType.parse("text/plain"), "b"))
+        .post(RequestBody.create(MediaType.get("text/plain"), "b"))
         .build();
     Response responseB = client.newCall(requestB).execute();
     assertEquals("b", responseB.body().string());
@@ -253,9 +252,10 @@
     response.body().close();
 
     // This client shares a connection pool but has a different SSL socket factory.
-    SslClient sslClient2 = new SslClient.Builder().build();
+    HandshakeCertificates handshakeCertificates2 = new HandshakeCertificates.Builder().build();
     OkHttpClient anotherClient = client.newBuilder()
-        .sslSocketFactory(sslClient2.socketFactory, sslClient2.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates2.sslSocketFactory(), handshakeCertificates2.trustManager())
         .build();
 
     // This client fails to connect because the new SSL socket factory refuses.
@@ -339,11 +339,12 @@ private void enableHttp2() {
 
   private void enableHttpsAndAlpn(Protocol... protocols) {
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .protocols(Arrays.asList(protocols))
         .build();
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.setProtocols(client.protocols());
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/ConscryptTest.java b/okhttp-tests/src/test/java/okhttp3/ConscryptTest.java
new file mode 100644
index 0000000000..2add4201e3
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ConscryptTest.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.security.Security;
+import java.util.Arrays;
+import okhttp3.internal.platform.ConscryptPlatform;
+import okhttp3.internal.platform.Platform;
+import org.conscrypt.OpenSSLProvider;
+import org.junit.Assume;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+
+public class ConscryptTest {
+  public static final CipherSuite[] MANDATORY_CIPHER_SUITES = new CipherSuite[] {
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
+      CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
+  };
+
+  private OkHttpClient client = buildClient();
+
+  private OkHttpClient buildClient() {
+    ConnectionSpec spec = new ConnectionSpec.Builder(true)
+        .cipherSuites(MANDATORY_CIPHER_SUITES) // Check we are using strong ciphers
+        .tlsVersions(TlsVersion.TLS_1_2) // and modern TLS
+        .supportsTlsExtensions(true)
+        .build();
+
+    return new OkHttpClient.Builder().connectionSpecs(Arrays.asList(spec)).build();
+  }
+
+  private static void assumeConscrypt() {
+    Assume.assumeTrue("conscrypt".equals(System.getProperty("okhttp.platform")));
+  }
+
+  private static void assumeNetwork() {
+    try {
+      InetAddress.getByName("www.google.com");
+    } catch (UnknownHostException uhe) {
+      Assume.assumeNoException(uhe);
+    }
+  }
+
+  @Test
+  public void testMozilla() throws IOException {
+    assumeNetwork();
+    assumeConscrypt();
+
+    Request request = new Request.Builder().url("https://mozilla.org/robots.txt").build();
+
+    Response response = client.newCall(request).execute();
+
+    assertEquals(Protocol.HTTP_2, response.protocol());
+  }
+
+  @Test
+  public void testGoogle() throws IOException {
+    assumeNetwork();
+    assumeConscrypt();
+
+    Request request = new Request.Builder().url("https://google.com/robots.txt").build();
+
+    Response response = client.newCall(request).execute();
+
+    assertEquals(Protocol.HTTP_2, response.protocol());
+  }
+
+  @Test
+  public void testBuild() {
+    assertNotNull(ConscryptPlatform.buildIfSupported());
+  }
+
+  @Test
+  public void testPreferred() {
+    Assume.assumeFalse(Platform.isConscryptPreferred());
+
+    try {
+      Security.insertProviderAt(new OpenSSLProvider(), 1);
+      assertTrue(Platform.isConscryptPreferred());
+    } finally {
+      Security.removeProvider("Conscrypt");
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/CookieTest.java b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
index e36fc0c820..b38dd3dd9a 100644
--- a/okhttp-tests/src/test/java/okhttp3/CookieTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CookieTest.java
@@ -27,12 +27,13 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class CookieTest {
-  HttpUrl url = HttpUrl.parse("https://example.com/");
+  HttpUrl url = HttpUrl.get("https://example.com/");
 
   @Test public void simpleCookie() throws Exception {
     Cookie cookie = Cookie.parse(url, "SID=31d4d96e407aad42");
@@ -215,80 +216,129 @@
 
   @Test public void domainMatches() throws Exception {
     Cookie cookie = Cookie.parse(url, "a=b; domain=example.com");
-    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://www.example.com")));
-    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+    assertTrue(cookie.matches(HttpUrl.get("http://example.com")));
+    assertTrue(cookie.matches(HttpUrl.get("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.get("http://square.com")));
   }
 
   /** If no domain is present, match only the origin domain. */
   @Test public void domainMatchesNoDomain() throws Exception {
     Cookie cookie = Cookie.parse(url, "a=b");
-    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
-    assertFalse(cookie.matches(HttpUrl.parse("http://www.example.com")));
-    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+    assertTrue(cookie.matches(HttpUrl.get("http://example.com")));
+    assertFalse(cookie.matches(HttpUrl.get("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.get("http://square.com")));
   }
 
   /** Ignore an optional leading `.` in the domain. */
   @Test public void domainMatchesIgnoresLeadingDot() throws Exception {
     Cookie cookie = Cookie.parse(url, "a=b; domain=.example.com");
-    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://www.example.com")));
-    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+    assertTrue(cookie.matches(HttpUrl.get("http://example.com")));
+    assertTrue(cookie.matches(HttpUrl.get("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.get("http://square.com")));
   }
 
   /** Ignore the entire attribute if the domain ends with `.`. */
   @Test public void domainIgnoredWithTrailingDot() throws Exception {
     Cookie cookie = Cookie.parse(url, "a=b; domain=example.com.");
-    assertTrue(cookie.matches(HttpUrl.parse("http://example.com")));
-    assertFalse(cookie.matches(HttpUrl.parse("http://www.example.com")));
-    assertFalse(cookie.matches(HttpUrl.parse("http://square.com")));
+    assertTrue(cookie.matches(HttpUrl.get("http://example.com")));
+    assertFalse(cookie.matches(HttpUrl.get("http://www.example.com")));
+    assertFalse(cookie.matches(HttpUrl.get("http://square.com")));
   }
 
   @Test public void idnDomainMatches() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.parse("http://â˜ƒ.net/"), "a=b; domain=â˜ƒ.net");
-    assertTrue(cookie.matches(HttpUrl.parse("http://â˜ƒ.net/")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://xn--n3h.net/")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://www.â˜ƒ.net/")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://www.xn--n3h.net/")));
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://â˜ƒ.net/"), "a=b; domain=â˜ƒ.net");
+    assertTrue(cookie.matches(HttpUrl.get("http://â˜ƒ.net/")));
+    assertTrue(cookie.matches(HttpUrl.get("http://xn--n3h.net/")));
+    assertTrue(cookie.matches(HttpUrl.get("http://www.â˜ƒ.net/")));
+    assertTrue(cookie.matches(HttpUrl.get("http://www.xn--n3h.net/")));
   }
 
   @Test public void punycodeDomainMatches() throws Exception {
-    Cookie cookie = Cookie.parse(HttpUrl.parse("http://xn--n3h.net/"), "a=b; domain=xn--n3h.net");
-    assertTrue(cookie.matches(HttpUrl.parse("http://â˜ƒ.net/")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://xn--n3h.net/")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://www.â˜ƒ.net/")));
-    assertTrue(cookie.matches(HttpUrl.parse("http://www.xn--n3h.net/")));
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://xn--n3h.net/"), "a=b; domain=xn--n3h.net");
+    assertTrue(cookie.matches(HttpUrl.get("http://â˜ƒ.net/")));
+    assertTrue(cookie.matches(HttpUrl.get("http://xn--n3h.net/")));
+    assertTrue(cookie.matches(HttpUrl.get("http://www.â˜ƒ.net/")));
+    assertTrue(cookie.matches(HttpUrl.get("http://www.xn--n3h.net/")));
   }
 
   @Test public void domainMatchesIpAddress() throws Exception {
-    HttpUrl urlWithIp = HttpUrl.parse("http://123.45.234.56/");
+    HttpUrl urlWithIp = HttpUrl.get("http://123.45.234.56/");
     assertNull(Cookie.parse(urlWithIp, "a=b; domain=234.56"));
     assertEquals("123.45.234.56", Cookie.parse(urlWithIp, "a=b; domain=123.45.234.56").domain());
   }
 
+  @Test public void domainMatchesIpv6Address() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://[::1]/"), "a=b; domain=::1");
+    assertEquals("::1", cookie.domain());
+    assertTrue(cookie.matches(HttpUrl.get("http://[::1]/")));
+  }
+
+  @Test public void domainMatchesIpv6AddressWithCompression() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://[0001:0000::]/"), "a=b; domain=0001:0000::");
+    assertEquals("1::", cookie.domain());
+    assertTrue(cookie.matches(HttpUrl.get("http://[1::]/")));
+  }
+
+  @Test public void domainMatchesIpv6AddressWithIpv4Suffix() throws Exception {
+    Cookie cookie = Cookie.parse(
+        HttpUrl.get("http://[::1:ffff:ffff]/"), "a=b; domain=::1:255.255.255.255");
+    assertEquals("::1:ffff:ffff", cookie.domain());
+    assertTrue(cookie.matches(HttpUrl.get("http://[::1:ffff:ffff]/")));
+  }
+
+  @Test public void ipv6AddressDoesntMatch() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://[::1]/"), "a=b; domain=::2");
+    assertNull(cookie);
+  }
+
+  @Test public void ipv6AddressMalformed() throws Exception {
+    Cookie cookie = Cookie.parse(HttpUrl.get("http://[::1]/"), "a=b; domain=::2::2");
+    assertEquals("::1", cookie.domain());
+  }
+
+  /**
+   * These public suffixes were selected by inspecting the publicsuffix.org list. It's possible they
+   * may change in the future. If this test begins to fail, please double check they are still
+   * present in the public suffix list.
+   */
+  @Test public void domainIsPublicSuffix() {
+    HttpUrl ascii = HttpUrl.get("https://foo1.foo.bar.elb.amazonaws.com");
+    assertNotNull(Cookie.parse(ascii, "a=b; domain=foo.bar.elb.amazonaws.com"));
+    assertNull(Cookie.parse(ascii, "a=b; domain=bar.elb.amazonaws.com"));
+    assertNull(Cookie.parse(ascii, "a=b; domain=com"));
+
+    HttpUrl unicode = HttpUrl.get("https://é•·.é•·.é•·å´Ž.jp");
+    assertNotNull(Cookie.parse(unicode, "a=b; domain=é•·.é•·å´Ž.jp"));
+    assertNull(Cookie.parse(unicode, "a=b; domain=é•·å´Ž.jp"));
+
+    HttpUrl punycode = HttpUrl.get("https://xn--ue5a.xn--ue5a.xn--8ltr62k.jp");
+    assertNotNull(Cookie.parse(punycode, "a=b; domain=xn--ue5a.xn--8ltr62k.jp"));
+    assertNull(Cookie.parse(punycode, "a=b; domain=xn--8ltr62k.jp"));
+  }
+
   @Test public void hostOnly() throws Exception {
     assertTrue(Cookie.parse(url, "a=b").hostOnly());
     assertFalse(Cookie.parse(url, "a=b; domain=example.com").hostOnly());
   }
 
   @Test public void defaultPath() throws Exception {
-    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"), "a=b").path());
-    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/"), "a=b").path());
-    assertEquals("/", Cookie.parse(HttpUrl.parse("http://example.com/foo"), "a=b").path());
-    assertEquals("/", Cookie.parse(HttpUrl.parse("http://example.com/"), "a=b").path());
+    assertEquals("/foo", Cookie.parse(HttpUrl.get("http://example.com/foo/bar"), "a=b").path());
+    assertEquals("/foo", Cookie.parse(HttpUrl.get("http://example.com/foo/"), "a=b").path());
+    assertEquals("/", Cookie.parse(HttpUrl.get("http://example.com/foo"), "a=b").path());
+    assertEquals("/", Cookie.parse(HttpUrl.get("http://example.com/"), "a=b").path());
   }
 
   @Test public void defaultPathIsUsedIfPathDoesntHaveLeadingSlash() throws Exception {
-    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"),
+    assertEquals("/foo", Cookie.parse(HttpUrl.get("http://example.com/foo/bar"),
         "a=b; path=quux").path());
-    assertEquals("/foo", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"),
+    assertEquals("/foo", Cookie.parse(HttpUrl.get("http://example.com/foo/bar"),
         "a=b; path=").path());
   }
 
   @Test public void pathAttributeDoesntNeedToMatch() throws Exception {
-    assertEquals("/quux", Cookie.parse(HttpUrl.parse("http://example.com/"),
+    assertEquals("/quux", Cookie.parse(HttpUrl.get("http://example.com/"),
         "a=b; path=/quux").path());
-    assertEquals("/quux", Cookie.parse(HttpUrl.parse("http://example.com/foo/bar"),
+    assertEquals("/quux", Cookie.parse(HttpUrl.get("http://example.com/foo/bar"),
         "a=b; path=/quux").path());
   }
 
@@ -486,6 +536,15 @@
     assertEquals(true, cookie.httpOnly());
   }
 
+  @Test public void builderIpv6() throws Exception {
+    Cookie cookie = new Cookie.Builder()
+        .name("a")
+        .value("b")
+        .domain("0:0:0:0:0:0:0:1")
+        .build();
+    assertEquals("::1", cookie.domain());
+  }
+
   @Test public void equalsAndHashCode() throws Exception {
     List<String> cookieStrings = Arrays.asList(
         "a=b; Path=/c; Domain=example.com; Max-Age=5; Secure; HttpOnly",
diff --git a/okhttp-tests/src/test/java/okhttp3/CookiesTest.java b/okhttp-tests/src/test/java/okhttp3/CookiesTest.java
index ab2a955273..17489b045d 100644
--- a/okhttp-tests/src/test/java/okhttp3/CookiesTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/CookiesTest.java
@@ -276,7 +276,7 @@ public void testNetscapeResponse() throws Exception {
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
 
-    HttpUrl url = HttpUrl.parse("https://www.squareup.com/");
+    HttpUrl url = HttpUrl.get("https://www.squareup.com/");
     cookieJar.saveFromResponse(url, Arrays.asList(
         Cookie.parse(url, "a=android; Domain=squareup.com")));
     List<Cookie> actualCookies = cookieJar.loadForRequest(url);
@@ -289,7 +289,7 @@ public void testNetscapeResponse() throws Exception {
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
 
-    HttpUrl url = HttpUrl.parse("https://www.squareup.com/");
+    HttpUrl url = HttpUrl.get("https://www.squareup.com/");
     cookieJar.saveFromResponse(url, Arrays.asList(
         Cookie.parse(url, "a=android; Domain=.squareup.com")));
     List<Cookie> actualCookies = cookieJar.loadForRequest(url);
@@ -302,7 +302,7 @@ public void testNetscapeResponse() throws Exception {
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
 
-    HttpUrl url = HttpUrl.parse("https://squareup.com/");
+    HttpUrl url = HttpUrl.get("https://squareup.com/");
     cookieJar.saveFromResponse(url, Arrays.asList(
         Cookie.parse(url, "a=android; Domain=squareup.com")));
     List<Cookie> actualCookies = cookieJar.loadForRequest(url);
@@ -315,11 +315,11 @@ public void testNetscapeResponse() throws Exception {
     CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
     JavaNetCookieJar cookieJar = new JavaNetCookieJar(cookieManager);
 
-    HttpUrl url1 = HttpUrl.parse("https://api.squareup.com/");
+    HttpUrl url1 = HttpUrl.get("https://api.squareup.com/");
     cookieJar.saveFromResponse(url1, Arrays.asList(
         Cookie.parse(url1, "a=android; Domain=api.squareup.com")));
 
-    HttpUrl url2 = HttpUrl.parse("https://www.squareup.com/");
+    HttpUrl url2 = HttpUrl.get("https://www.squareup.com/");
     List<Cookie> actualCookies = cookieJar.loadForRequest(url2);
     assertEquals(Collections.<Cookie>emptyList(), actualCookies);
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
index e4896a94d1..cba980294c 100644
--- a/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/DispatcherTest.java
@@ -26,6 +26,7 @@
 public final class DispatcherTest {
   RecordingExecutor executor = new RecordingExecutor();
   RecordingCallback callback = new RecordingCallback();
+  RecordingWebSocketListener webSocketListener = new RecordingWebSocketListener();
   Dispatcher dispatcher = new Dispatcher(executor);
   OkHttpClient client = defaultClient().newBuilder()
       .dispatcher(dispatcher)
@@ -74,6 +75,14 @@
     executor.assertJobs("http://a/1", "http://a/2");
   }
 
+  @Test public void maxPerHostNotEnforcedForWebSockets() {
+    dispatcher.setMaxRequestsPerHost(2);
+    client.newWebSocket(newRequest("http://a/1"), webSocketListener);
+    client.newWebSocket(newRequest("http://a/2"), webSocketListener);
+    client.newWebSocket(newRequest("http://a/3"), webSocketListener);
+    executor.assertJobs("http://a/1", "http://a/2", "http://a/3");
+  }
+
   @Test public void increasingMaxRequestsPromotesJobsImmediately() throws Exception {
     dispatcher.setMaxRequests(2);
     client.newCall(newRequest("http://a/1")).enqueue(callback);
@@ -216,7 +225,7 @@
     assertFalse(a4.isCanceled());
   }
 
-  @Test public void idleCallbackInvokedWhenIdle() throws InterruptedException {
+  @Test public void idleCallbackInvokedWhenIdle() throws Exception {
     final AtomicBoolean idle = new AtomicBoolean();
     dispatcher.setIdleCallback(new Runnable() {
       @Override public void run() {
@@ -320,8 +329,7 @@ public void finishJob(String url) {
       throw new UnsupportedOperationException();
     }
 
-    @Override public boolean awaitTermination(long timeout, TimeUnit unit)
-        throws InterruptedException {
+    @Override public boolean awaitTermination(long timeout, TimeUnit unit) {
       throw new UnsupportedOperationException();
     }
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
new file mode 100644
index 0000000000..cfc22ce7f3
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/EventListenerTest.java
@@ -0,0 +1,1089 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.net.UnknownHostException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
+import okhttp3.RecordingEventListener.CallEnd;
+import okhttp3.RecordingEventListener.CallFailed;
+import okhttp3.RecordingEventListener.ConnectEnd;
+import okhttp3.RecordingEventListener.ConnectFailed;
+import okhttp3.RecordingEventListener.ConnectStart;
+import okhttp3.RecordingEventListener.ConnectionAcquired;
+import okhttp3.RecordingEventListener.DnsEnd;
+import okhttp3.RecordingEventListener.DnsStart;
+import okhttp3.RecordingEventListener.RequestBodyEnd;
+import okhttp3.RecordingEventListener.RequestHeadersEnd;
+import okhttp3.RecordingEventListener.ResponseBodyEnd;
+import okhttp3.RecordingEventListener.ResponseHeadersEnd;
+import okhttp3.RecordingEventListener.SecureConnectEnd;
+import okhttp3.RecordingEventListener.SecureConnectStart;
+import okhttp3.internal.DoubleInetAddressDns;
+import okhttp3.internal.RecordingOkAuthenticator;
+import okhttp3.internal.SingleInetAddressDns;
+import okhttp3.logging.HttpLoggingInterceptor;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
+import okio.Buffer;
+import okio.BufferedSink;
+import org.hamcrest.BaseMatcher;
+import org.hamcrest.CoreMatchers;
+import org.hamcrest.Description;
+import org.hamcrest.Matcher;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Rule;
+import org.junit.Test;
+
+import static java.util.Arrays.asList;
+import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.hamcrest.CoreMatchers.any;
+import static org.hamcrest.CoreMatchers.either;
+import static org.hamcrest.CoreMatchers.equalTo;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeThat;
+
+public final class EventListenerTest {
+  public static final Matcher<Response> anyResponse = CoreMatchers.any(Response.class);
+  @Rule public final MockWebServer server = new MockWebServer();
+
+  private final SingleInetAddressDns singleDns = new SingleInetAddressDns();
+  private final RecordingEventListener listener = new RecordingEventListener();
+  private final HandshakeCertificates handshakeCertificates = localhost();
+
+  private OkHttpClient client;
+  private SocksProxy socksProxy;
+
+  @Before public void setUp() {
+    client = defaultClient().newBuilder()
+        .dns(singleDns)
+        .eventListener(listener)
+        .build();
+
+    listener.forbidLock(client.connectionPool());
+    listener.forbidLock(client.dispatcher());
+  }
+
+  @After public void tearDown() throws Exception {
+    if (socksProxy != null) {
+      socksProxy.shutdown();
+    }
+  }
+
+  @Test public void successfulCallEventSequence() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    assertEquals("abc", response.body().string());
+    response.body().close();
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Test public void successfulCallEventSequenceForEnqueue() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    final CountDownLatch completionLatch = new CountDownLatch(1);
+    Callback callback = new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        completionLatch.countDown();
+      }
+
+      @Override public void onResponse(Call call, Response response) {
+        response.close();
+        completionLatch.countDown();
+      }
+    };
+
+    call.enqueue(callback);
+
+    completionLatch.await();
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Test public void failedCallEventSequence() {
+    server.enqueue(new MockResponse().setHeadersDelay(2, TimeUnit.SECONDS));
+
+    client = client.newBuilder().readTimeout(250, TimeUnit.MILLISECONDS).build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+      assertThat(expected.getMessage(), either(equalTo("timeout")).or(equalTo("Read timed out")));
+    }
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ConnectionReleased", "CallFailed");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Test public void failedDribbledCallEventSequence() throws IOException {
+    server.enqueue(new MockResponse().setBody("0123456789")
+        .throttleBody(2, 100, TimeUnit.MILLISECONDS)
+        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
+
+    client = client.newBuilder()
+        .protocols(Collections.singletonList(Protocol.HTTP_1_1))
+        .readTimeout(250, TimeUnit.MILLISECONDS)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    Response response = call.execute();
+    try {
+      response.body.string();
+      fail();
+    } catch (IOException expected) {
+      assertThat(expected.getMessage(), equalTo("unexpected end of stream"));
+    }
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallFailed");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+    ResponseBodyEnd bodyEnd = listener.removeUpToEvent(ResponseBodyEnd.class);
+    assertEquals(5, bodyEnd.bytesRead);
+  }
+
+  @Test public void canceledCallEventSequence() {
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    call.cancel();
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("Canceled", expected.getMessage());
+    }
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "CallFailed");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  private void assertSuccessfulEventOrder(Matcher<Response> responseMatcher) throws IOException {
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().string();
+    response.body().close();
+
+    assumeThat(response, responseMatcher);
+
+    List<String> expectedEvents = asList("CallStart", "DnsStart", "DnsEnd", "ConnectStart",
+        "SecureConnectStart", "SecureConnectEnd", "ConnectEnd", "ConnectionAcquired",
+        "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd",
+        "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Test public void secondCallEventSequence() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build()).execute().close();
+
+    listener.removeUpToEvent(CallEnd.class);
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    response.close();
+
+    List<String> expectedEvents = asList("CallStart", "ConnectionAcquired",
+        "RequestHeadersStart", "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd",
+        "ResponseBodyStart", "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  private void assertBytesReadWritten(RecordingEventListener listener,
+      @Nullable Matcher<Long> requestHeaderLength, @Nullable Matcher<Long> requestBodyBytes,
+      @Nullable Matcher<Long> responseHeaderLength, @Nullable Matcher<Long> responseBodyBytes) {
+
+    if (requestHeaderLength != null) {
+      RequestHeadersEnd responseHeadersEnd = listener.removeUpToEvent(RequestHeadersEnd.class);
+      assertThat("request header length", responseHeadersEnd.headerLength, requestHeaderLength);
+    } else {
+      assertFalse("Found RequestHeadersEnd",
+          listener.recordedEventTypes().contains("RequestHeadersEnd"));
+    }
+
+    if (requestBodyBytes != null) {
+      RequestBodyEnd responseBodyEnd = listener.removeUpToEvent(RequestBodyEnd.class);
+      assertThat("request body bytes", responseBodyEnd.bytesWritten, requestBodyBytes);
+    } else {
+      assertFalse("Found RequestBodyEnd", listener.recordedEventTypes().contains("RequestBodyEnd"));
+    }
+
+    if (responseHeaderLength != null) {
+      ResponseHeadersEnd responseHeadersEnd = listener.removeUpToEvent(ResponseHeadersEnd.class);
+      assertThat("response header length", responseHeadersEnd.headerLength, responseHeaderLength);
+    } else {
+      assertFalse("Found ResponseHeadersEnd",
+          listener.recordedEventTypes().contains("ResponseHeadersEnd"));
+    }
+
+    if (responseBodyBytes != null) {
+      ResponseBodyEnd responseBodyEnd = listener.removeUpToEvent(ResponseBodyEnd.class);
+      assertThat("response body bytes", responseBodyEnd.bytesRead, responseBodyBytes);
+    } else {
+      assertFalse("Found ResponseBodyEnd",
+          listener.recordedEventTypes().contains("ResponseBodyEnd"));
+    }
+  }
+
+  private Matcher<Long> greaterThan(final long value) {
+    return new BaseMatcher<Long>() {
+      @Override public void describeTo(Description description) {
+        description.appendText("> " + value);
+      }
+
+      @Override public boolean matches(Object o) {
+        return ((Long)o) > value;
+      }
+    };
+  }
+
+  private Matcher<Long> lessThan(final long value) {
+    return new BaseMatcher<Long>() {
+      @Override public void describeTo(Description description) {
+        description.appendText("< " + value);
+      }
+
+      @Override public boolean matches(Object o) {
+        return ((Long)o) < value;
+      }
+    };
+  }
+
+  private Matcher<Response> matchesProtocol(final Protocol protocol) {
+    return new BaseMatcher<Response>() {
+      @Override public void describeTo(Description description) {
+        description.appendText("is HTTP/2");
+      }
+
+      @Override public boolean matches(Object o) {
+        return ((Response)o).protocol == protocol;
+      }
+    };
+  }
+
+  @Test public void successfulEmptyH2CallEventSequence() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    server.enqueue(new MockResponse());
+
+    assertSuccessfulEventOrder(matchesProtocol(Protocol.HTTP_2));
+
+    assertBytesReadWritten(listener, any(Long.class), null, greaterThan(0L),
+        equalTo(0L));
+  }
+
+  @Test public void successfulEmptyHttpsCallEventSequence() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    assertSuccessfulEventOrder(anyResponse);
+
+    assertBytesReadWritten(listener, any(Long.class), null, greaterThan(0L),
+        equalTo(3L));
+  }
+
+  @Test public void successfulChunkedHttpsCallEventSequence() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    server.enqueue(
+        new MockResponse().setBodyDelay(100, TimeUnit.MILLISECONDS).setChunkedBody("Hello!", 2));
+
+    assertSuccessfulEventOrder(anyResponse);
+
+    assertBytesReadWritten(listener, any(Long.class), null, greaterThan(0L),
+        equalTo(6L));
+  }
+
+  @Test public void successfulChunkedH2CallEventSequence() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    server.enqueue(
+        new MockResponse().setBodyDelay(100, TimeUnit.MILLISECONDS).setChunkedBody("Hello!", 2));
+
+    assertSuccessfulEventOrder(matchesProtocol(Protocol.HTTP_2));
+
+    assertBytesReadWritten(listener, any(Long.class), null, equalTo(0L),
+        greaterThan(6L));
+  }
+
+  @Test public void successfulDnsLookup() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    DnsStart dnsStart = listener.removeUpToEvent(DnsStart.class);
+    assertSame(call, dnsStart.call);
+    assertEquals(server.getHostName(), dnsStart.domainName);
+
+    DnsEnd dnsEnd = listener.removeUpToEvent(DnsEnd.class);
+    assertSame(call, dnsEnd.call);
+    assertEquals(server.getHostName(), dnsEnd.domainName);
+    assertEquals(1, dnsEnd.inetAddressList.size());
+  }
+
+  @Test public void noDnsLookupOnPooledConnection() throws IOException {
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    // Seed the pool.
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals(200, response1.code());
+    response1.body().close();
+
+    listener.clearAllEvents();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals(200, response2.code());
+    response2.body().close();
+
+    List<String> recordedEvents = listener.recordedEventTypes();
+    assertFalse(recordedEvents.contains("DnsStart"));
+    assertFalse(recordedEvents.contains("DnsEnd"));
+  }
+
+  @Test public void multipleDnsLookupsForSingleCall() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .setHeader("Location", "http://www.fakeurl:" + server.getPort()));
+    server.enqueue(new MockResponse());
+
+    FakeDns dns = new FakeDns();
+    dns.set("fakeurl", singleDns.lookup(server.getHostName()));
+    dns.set("www.fakeurl", singleDns.lookup(server.getHostName()));
+
+    client = client.newBuilder()
+        .dns(dns)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url("http://fakeurl:" + server.getPort())
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    listener.removeUpToEvent(DnsStart.class);
+    listener.removeUpToEvent(DnsEnd.class);
+    listener.removeUpToEvent(DnsStart.class);
+    listener.removeUpToEvent(DnsEnd.class);
+  }
+
+  @Test public void failedDnsLookup() {
+    client = client.newBuilder()
+        .dns(new FakeDns())
+        .build();
+    Call call = client.newCall(new Request.Builder()
+        .url("http://fakeurl/")
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    listener.removeUpToEvent(DnsStart.class);
+
+    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
+    assertSame(call, callFailed.call);
+    assertTrue(callFailed.ioe instanceof UnknownHostException);
+  }
+
+  @Test public void emptyDnsLookup() {
+    Dns emptyDns = new Dns() {
+      @Override public List<InetAddress> lookup(String hostname) {
+        return Collections.emptyList();
+      }
+    };
+
+    client = client.newBuilder()
+        .dns(emptyDns)
+        .build();
+    Call call = client.newCall(new Request.Builder()
+        .url("http://fakeurl/")
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    listener.removeUpToEvent(DnsStart.class);
+
+    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
+    assertSame(call, callFailed.call);
+    assertTrue(callFailed.ioe instanceof UnknownHostException);
+  }
+
+  @Test public void successfulConnect() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    InetAddress address = singleDns.lookup(server.getHostName()).get(0);
+    InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
+
+    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
+    assertSame(call, connectStart.call);
+    assertEquals(expectedAddress, connectStart.inetSocketAddress);
+    assertEquals(Proxy.NO_PROXY, connectStart.proxy);
+
+    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
+    assertSame(call, connectEnd.call);
+    assertEquals(expectedAddress, connectEnd.inetSocketAddress);
+    assertEquals(Protocol.HTTP_1_1, connectEnd.protocol);
+  }
+
+  @Test public void failedConnect() throws UnknownHostException {
+    enableTlsWithTunnel(false);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    InetAddress address = singleDns.lookup(server.getHostName()).get(0);
+    InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
+
+    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
+    assertSame(call, connectStart.call);
+    assertEquals(expectedAddress, connectStart.inetSocketAddress);
+    assertEquals(Proxy.NO_PROXY, connectStart.proxy);
+
+    ConnectFailed connectFailed = listener.removeUpToEvent(ConnectFailed.class);
+    assertSame(call, connectFailed.call);
+    assertEquals(expectedAddress, connectFailed.inetSocketAddress);
+    assertNull(connectFailed.protocol);
+    assertNotNull(connectFailed.ioe);
+  }
+
+  @Test public void multipleConnectsForSingleCall() throws IOException {
+    enableTlsWithTunnel(false);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    listener.removeUpToEvent(ConnectStart.class);
+    listener.removeUpToEvent(ConnectFailed.class);
+    listener.removeUpToEvent(ConnectStart.class);
+    listener.removeUpToEvent(ConnectEnd.class);
+  }
+
+  @Test public void successfulHttpProxyConnect() throws IOException {
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url("http://www.fakeurl")
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    InetAddress address = singleDns.lookup(server.getHostName()).get(0);
+    InetSocketAddress expectedAddress = new InetSocketAddress(address, server.getPort());
+
+    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
+    assertSame(call, connectStart.call);
+    assertEquals(expectedAddress, connectStart.inetSocketAddress);
+    assertEquals(server.toProxyAddress(), connectStart.proxy);
+
+    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
+    assertSame(call, connectEnd.call);
+    assertEquals(expectedAddress, connectEnd.inetSocketAddress);
+    assertEquals(Protocol.HTTP_1_1, connectEnd.protocol);
+  }
+
+  @Test public void successfulSocksProxyConnect() throws Exception {
+    server.enqueue(new MockResponse());
+
+    socksProxy = new SocksProxy();
+    socksProxy.play();
+    Proxy proxy = socksProxy.proxy();
+
+    client = client.newBuilder()
+        .proxy(proxy)
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url("http://" + SocksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS + ":" + server.getPort())
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    InetSocketAddress expectedAddress = InetSocketAddress.createUnresolved(
+        SocksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS, server.getPort());
+
+    ConnectStart connectStart = listener.removeUpToEvent(ConnectStart.class);
+    assertSame(call, connectStart.call);
+    assertEquals(expectedAddress, connectStart.inetSocketAddress);
+    assertEquals(proxy, connectStart.proxy);
+
+    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
+    assertSame(call, connectEnd.call);
+    assertEquals(expectedAddress, connectEnd.inetSocketAddress);
+    assertEquals(Protocol.HTTP_1_1, connectEnd.protocol);
+  }
+
+  @Test public void authenticatingTunnelProxyConnect() throws IOException {
+    enableTlsWithTunnel(true);
+    server.enqueue(new MockResponse()
+        .setResponseCode(407)
+        .addHeader("Proxy-Authenticate: Basic realm=\"localhost\"")
+        .addHeader("Connection: close"));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END));
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .proxyAuthenticator(new RecordingOkAuthenticator("password"))
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    listener.removeUpToEvent(ConnectStart.class);
+
+    ConnectEnd connectEnd = listener.removeUpToEvent(ConnectEnd.class);
+    assertNull(connectEnd.protocol);
+
+    listener.removeUpToEvent(ConnectStart.class);
+    listener.removeUpToEvent(ConnectEnd.class);
+  }
+
+  @Test public void successfulSecureConnect() throws IOException {
+    enableTlsWithTunnel(false);
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
+    assertSame(call, secureStart.call);
+
+    SecureConnectEnd secureEnd = listener.removeUpToEvent(SecureConnectEnd.class);
+    assertSame(call, secureEnd.call);
+    assertNotNull(secureEnd.handshake);
+  }
+
+  @Test public void failedSecureConnect() {
+    enableTlsWithTunnel(false);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
+    assertSame(call, secureStart.call);
+
+    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
+    assertSame(call, callFailed.call);
+    assertNotNull(callFailed.ioe);
+  }
+
+  @Test public void secureConnectWithTunnel() throws IOException {
+    enableTlsWithTunnel(true);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.UPGRADE_TO_SSL_AT_END));
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .proxy(server.toProxyAddress())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    SecureConnectStart secureStart = listener.removeUpToEvent(SecureConnectStart.class);
+    assertSame(call, secureStart.call);
+
+    SecureConnectEnd secureEnd = listener.removeUpToEvent(SecureConnectEnd.class);
+    assertSame(call, secureEnd.call);
+    assertNotNull(secureEnd.handshake);
+  }
+
+  @Test public void multipleSecureConnectsForSingleCall() throws IOException {
+    enableTlsWithTunnel(false);
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    listener.removeUpToEvent(SecureConnectStart.class);
+    listener.removeUpToEvent(ConnectFailed.class);
+
+    listener.removeUpToEvent(SecureConnectStart.class);
+    listener.removeUpToEvent(SecureConnectEnd.class);
+  }
+
+  @Test public void noSecureConnectsOnPooledConnection() throws IOException {
+    enableTlsWithTunnel(false);
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    // Seed the pool.
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals(200, response1.code());
+    response1.body().close();
+
+    listener.clearAllEvents();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals(200, response2.code());
+    response2.body().close();
+
+    List<String> recordedEvents = listener.recordedEventTypes();
+    assertFalse(recordedEvents.contains("SecureConnectStart"));
+    assertFalse(recordedEvents.contains("SecureConnectEnd"));
+  }
+
+  @Test public void successfulConnectionFound() throws IOException {
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    response.body().close();
+
+    ConnectionAcquired connectionAcquired = listener.removeUpToEvent(ConnectionAcquired.class);
+    assertSame(call, connectionAcquired.call);
+    assertNotNull(connectionAcquired.connection);
+  }
+
+  @Test public void noConnectionFoundOnFollowUp() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location", "/foo"));
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("ABC", response.body().string());
+
+    listener.removeUpToEvent(ConnectionAcquired.class);
+
+    List<String> remainingEvents = listener.recordedEventTypes();
+    assertFalse(remainingEvents.contains("ConnectionAcquired"));
+  }
+
+  @Test public void pooledConnectionFound() throws IOException {
+    server.enqueue(new MockResponse());
+    server.enqueue(new MockResponse());
+
+    // Seed the pool.
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+    assertEquals(200, response1.code());
+    response1.body().close();
+
+    ConnectionAcquired connectionAcquired1 = listener.removeUpToEvent(ConnectionAcquired.class);
+    listener.clearAllEvents();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals(200, response2.code());
+    response2.body().close();
+
+    ConnectionAcquired connectionAcquired2 = listener.removeUpToEvent(ConnectionAcquired.class);
+    assertSame(connectionAcquired1.connection, connectionAcquired2.connection);
+  }
+
+  @Test public void multipleConnectionsFoundForSingleCall() throws IOException {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location", "/foo")
+        .addHeader("Connection", "Close"));
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("ABC", response.body().string());
+
+    listener.removeUpToEvent(ConnectionAcquired.class);
+    listener.removeUpToEvent(ConnectionAcquired.class);
+  }
+
+  @Test public void responseBodyFailHttp1OverHttps() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    responseBodyFail(Protocol.HTTP_1_1);
+  }
+
+  @Test public void responseBodyFailHttp2OverHttps() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    responseBodyFail(Protocol.HTTP_2);
+  }
+
+  @Test public void responseBodyFailHttp() throws IOException {
+    responseBodyFail(Protocol.HTTP_1_1);
+  }
+
+  private void responseBodyFail(Protocol expectedProtocol) throws IOException {
+    // Use a 2 MiB body so the disconnect won't happen until the client has read some data.
+    int responseBodySize = 2 * 1024 * 1024; // 2 MiB
+    server.enqueue(new MockResponse()
+        .setBody(new Buffer().write(new byte[responseBodySize]))
+        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    if (expectedProtocol == Protocol.HTTP_2) {
+      // soft failure since client may not support depending on Platform
+      assumeThat(response, matchesProtocol(Protocol.HTTP_2));
+    }
+    assertEquals(expectedProtocol, response.protocol());
+    try {
+      response.body.string();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
+    assertNotNull(callFailed.ioe);
+  }
+
+  @Ignore("the CallEnd event is omitted")
+  @Test public void emptyResponseBody() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("")
+        .setBodyDelay(1, TimeUnit.SECONDS)
+        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    response.body().close();
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Ignore("this reports CallFailed not CallEnd")
+  @Test public void responseBodyClosedClosedWithoutReadingAllData() throws IOException {
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .setBodyDelay(1, TimeUnit.SECONDS)
+        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_RESPONSE_BODY));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    response.body().close();
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  @Test public void requestBodyFailHttp1OverHttps() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    requestBodyFail();
+  }
+
+  @Test public void requestBodyFailHttp2OverHttps() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    requestBodyFail();
+  }
+
+  @Test public void requestBodyFailHttp() throws IOException {
+    requestBodyFail();
+  }
+
+  private void requestBodyFail() {
+    // Stream a 8 MiB body so the disconnect will happen before the server has read everything.
+    RequestBody requestBody = new RequestBody() {
+      @Override public MediaType contentType() {
+        return MediaType.get("text/plain");
+      }
+
+      @Override public long contentLength() {
+        return 1024 * 8192;
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        for (int i = 0; i < 1024; i++) {
+          sink.write(new byte[8192]);
+          sink.flush();
+        }
+      }
+    };
+
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_DURING_REQUEST_BODY));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(requestBody)
+        .build());
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    CallFailed callFailed = listener.removeUpToEvent(CallFailed.class);
+    assertNotNull(callFailed.ioe);
+  }
+
+  @Test public void requestBodySuccessHttp1OverHttps() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_1_1));
+    requestBodySuccess(RequestBody.create(MediaType.get("text/plain"), "Hello"), equalTo(5L),
+        equalTo(19L));
+  }
+
+  @Test public void requestBodySuccessHttp2OverHttps() throws IOException {
+    enableTlsWithTunnel(false);
+    server.setProtocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1));
+    requestBodySuccess(RequestBody.create(MediaType.get("text/plain"), "Hello"), equalTo(5L),
+        equalTo(19L));
+  }
+
+  @Test public void requestBodySuccessHttp() throws IOException {
+    requestBodySuccess(RequestBody.create(MediaType.get("text/plain"), "Hello"), equalTo(5L),
+        equalTo(19L));
+  }
+
+  @Test public void requestBodySuccessStreaming() throws IOException {
+    RequestBody requestBody = new RequestBody() {
+      @Override public MediaType contentType() {
+        return MediaType.get("text/plain");
+      }
+
+      @Override public void writeTo(BufferedSink sink) throws IOException {
+        sink.write(new byte[8192]);
+        sink.flush();
+      }
+    };
+
+    requestBodySuccess(requestBody, equalTo(8192L), equalTo(19L));
+  }
+
+  @Test public void requestBodySuccessEmpty() throws IOException {
+    requestBodySuccess(RequestBody.create(MediaType.get("text/plain"), ""), equalTo(0L),
+        equalTo(19L));
+  }
+
+  @Test public void successfulCallEventSequenceWithListener() throws IOException {
+    server.enqueue(new MockResponse().setBody("abc"));
+
+    client = client.newBuilder().addNetworkInterceptor(new HttpLoggingInterceptor().setLevel(
+        HttpLoggingInterceptor.Level.BODY)).build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals(200, response.code());
+    assertEquals("abc", response.body().string());
+    response.body().close();
+
+    List<String> expectedEvents = Arrays.asList("CallStart", "DnsStart", "DnsEnd",
+        "ConnectStart", "ConnectEnd", "ConnectionAcquired", "RequestHeadersStart",
+        "RequestHeadersEnd", "ResponseHeadersStart", "ResponseHeadersEnd", "ResponseBodyStart",
+        "ResponseBodyEnd", "ConnectionReleased", "CallEnd");
+    assertEquals(expectedEvents, listener.recordedEventTypes());
+  }
+
+  private void requestBodySuccess(RequestBody body, Matcher<Long> requestBodyBytes,
+      Matcher<Long> responseHeaderLength) throws IOException {
+    server.enqueue(new MockResponse().setResponseCode(200).setBody("World!"));
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .post(body)
+        .build());
+    Response response = call.execute();
+    assertEquals("World!", response.body().string());
+
+    assertBytesReadWritten(listener, any(Long.class), requestBodyBytes, responseHeaderLength,
+        equalTo(6L));
+  }
+
+  private void enableTlsWithTunnel(boolean tunnelProxy) {
+    client = client.newBuilder()
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
+        .build();
+    server.useHttps(handshakeCertificates.sslSocketFactory(), tunnelProxy);
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java b/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java
index 34e40b96f7..b0cb8a6d0f 100644
--- a/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/FormBodyTest.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import okio.Buffer;
 import org.junit.Test;
+import java.nio.charset.Charset;
 
 import static org.junit.Assert.assertEquals;
 
@@ -196,4 +197,17 @@ private String formEncode(int codePoint) throws IOException {
     buffer.skip(3); // Skip "a=b" prefix.
     return buffer.readUtf8(buffer.size() - 1); // Skip the "c" suffix.
   }
+
+  @Test public void manualCharset() throws Exception {
+    FormBody body = new FormBody.Builder(Charset.forName("ISO-8859-1"))
+        .add("name", "NicolÃ¡s")
+        .build();
+
+    String expected = "name=Nicol%E1s";
+    assertEquals(expected.length(), body.contentLength());
+
+    Buffer out = new Buffer();
+    body.writeTo(out);
+    assertEquals(expected, out.readUtf8());
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
index 535dfcadd5..8480bac638 100644
--- a/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HeadersTest.java
@@ -22,6 +22,7 @@
 import java.util.List;
 import java.util.Map;
 import okhttp3.internal.Internal;
+import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpHeaders;
 import okhttp3.internal.http2.Header;
 import okhttp3.internal.http2.Http2Codec;
@@ -44,7 +45,7 @@
         ":version", "HTTP/1.1",
         "connection", "close");
     Request request = new Request.Builder().url("http://square.com/").build();
-    Response response = Http2Codec.readHttp2HeadersList(headerBlock).request(request).build();
+    Response response = Http2Codec.readHttp2HeadersList(headerBlock, Protocol.HTTP_2).request(request).build();
     Headers headers = response.headers();
     assertEquals(1, headers.size());
     assertEquals(":version", headers.name(0));
@@ -56,6 +57,7 @@
         .url("http://square.com/")
         .header("Connection", "upgrade")
         .header("Upgrade", "websocket")
+        .header("Host", "square.com")
         .build();
     List<Header> expected = headerEntries(
         ":method", "GET",
@@ -154,7 +156,7 @@
     assertEquals("OkHttp", headers.value(0));
   }
 
-  @Test public void ofRejectsNulChar() {
+  @Test public void ofRejectsNullChar() {
     try {
       Headers.of("User-Agent", "Square\u0000OkHttp");
       fail();
@@ -210,17 +212,17 @@
     assertEquals("OkHttp", headers.value(0));
   }
 
-  @Test public void ofMapRejectsNulCharInName() {
+  @Test public void ofMapRejectsNullCharInName() {
     try {
-      Headers.of(Collections.singletonMap("User-Agent", "Square\u0000OkHttp"));
+      Headers.of(Collections.singletonMap("User-\u0000Agent", "OkHttp"));
       fail();
     } catch (IllegalArgumentException expected) {
     }
   }
 
-  @Test public void ofMapRejectsNulCharInValue() {
+  @Test public void ofMapRejectsNullCharInValue() {
     try {
-      Headers.of(Collections.singletonMap("User-\u0000Agent", "OkHttp"));
+      Headers.of(Collections.singletonMap("User-Agent", "Square\u0000OkHttp"));
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -248,8 +250,8 @@
 
   @Test public void toMultimapAllowsCaseInsensitiveGet() {
     Headers headers = Headers.of(
-            "cache-control", "no-store",
-            "Cache-Control", "no-cache");
+        "cache-control", "no-store",
+        "Cache-Control", "no-cache");
     Map<String, List<String>> headerMap = headers.toMultimap();
     assertEquals(2, headerMap.get("cache-control").size());
     assertEquals(2, headerMap.get("Cache-Control").size());
@@ -341,6 +343,20 @@
     assertEquals("A: a\nB: bb\n", headers.toString());
   }
 
+  @Test public void headersAddAll() {
+    Headers sourceHeaders = new Headers.Builder()
+        .add("A", "aa")
+        .add("a", "aa")
+        .add("B", "bb")
+        .build();
+    Headers headers = new Headers.Builder()
+        .add("A", "a")
+        .addAll(sourceHeaders)
+        .add("C", "c")
+        .build();
+    assertEquals("A: a\nA: aa\na: aa\nB: bb\nC: c\n", headers.toString());
+  }
+
   /** See https://github.com/square/okhttp/issues/2780. */
   @Test public void testDigestChallenges() {
     // Strict RFC 2617 header.
@@ -433,4 +449,40 @@
     challenges = HttpHeaders.parseChallenges(headers, "WWW-Authenticate");
     assertEquals(0, challenges.size());
   }
+
+  @Test public void basicChallenge() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate: Basic realm=\"protected area\"")
+        .build();
+    assertEquals(Arrays.asList(new Challenge("Basic", "protected area")),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void basicChallengeWithCharset() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate: Basic realm=\"protected area\", charset=\"UTF-8\"")
+        .build();
+    assertEquals(Arrays.asList(new Challenge("Basic", "protected area").withCharset(Util.UTF_8)),
+        HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void basicChallengeWithUnexpectedCharset() {
+    Headers headers = new Headers.Builder()
+        .add("WWW-Authenticate: Basic realm=\"protected area\", charset=\"US-ASCII\"")
+        .build();
+    assertEquals(Collections.emptyList(), HttpHeaders.parseChallenges(headers, "WWW-Authenticate"));
+  }
+
+  @Test public void byteCount() {
+    assertEquals(0L, new Headers.Builder().build().byteCount());
+    assertEquals(10L, new Headers.Builder()
+        .add("abc", "def")
+        .build()
+        .byteCount());
+    assertEquals(20L, new Headers.Builder()
+        .add("abc", "def")
+        .add("ghi", "jkl")
+        .build()
+        .byteCount());
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
index e068e4df52..1682765e7e 100644
--- a/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/HttpUrlTest.java
@@ -20,104 +20,126 @@
 import java.net.URL;
 import java.net.UnknownHostException;
 import java.util.Arrays;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import okhttp3.UrlComponentEncodingTester.Component;
 import okhttp3.UrlComponentEncodingTester.Encoding;
 import org.junit.Ignore;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
 
 import static java.util.Collections.singletonList;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 
+@RunWith(Parameterized.class)
 public final class HttpUrlTest {
+  @Parameterized.Parameters(name = "Use get = {0}")
+  public static Collection<Object[]> parameters() {
+    return Arrays.asList(
+        new Object[] { true },
+        new Object[] { false }
+    );
+  }
+  
+  @Parameterized.Parameter
+  public boolean useGet;
+  
+  HttpUrl parse(String url) {
+    return useGet
+        ? HttpUrl.get(url)
+        : HttpUrl.parse(url);
+  }
+  
   @Test public void parseTrimsAsciiWhitespace() throws Exception {
-    HttpUrl expected = HttpUrl.parse("http://host/");
-    assertEquals(expected, HttpUrl.parse("http://host/\f\n\t \r")); // Leading.
-    assertEquals(expected, HttpUrl.parse("\r\n\f \thttp://host/")); // Trailing.
-    assertEquals(expected, HttpUrl.parse(" http://host/ ")); // Both.
-    assertEquals(expected, HttpUrl.parse("    http://host/    ")); // Both.
-    assertEquals(expected, HttpUrl.parse("http://host/").resolve("   "));
-    assertEquals(expected, HttpUrl.parse("http://host/").resolve("  .  "));
+    HttpUrl expected = parse("http://host/");
+    assertEquals(expected, parse("http://host/\f\n\t \r")); // Leading.
+    assertEquals(expected, parse("\r\n\f \thttp://host/")); // Trailing.
+    assertEquals(expected, parse(" http://host/ ")); // Both.
+    assertEquals(expected, parse("    http://host/    ")); // Both.
+    assertEquals(expected, parse("http://host/").resolve("   "));
+    assertEquals(expected, parse("http://host/").resolve("  .  "));
   }
 
   @Test public void parseHostAsciiNonPrintable() throws Exception {
     String host = "host\u0001";
-    assertNull(HttpUrl.parse("http://" + host + "/"));
+    assertInvalid("http://" + host + "/", "Invalid URL host: \"host\u0001\"");
+    // TODO make exception message escape non-printable characters
   }
 
   @Test public void parseDoesNotTrimOtherWhitespaceCharacters() throws Exception {
     // Whitespace characters list from Google's Guava team: http://goo.gl/IcR9RD
-    assertEquals("/%0B", HttpUrl.parse("http://h/\u000b").encodedPath()); // line tabulation
-    assertEquals("/%1C", HttpUrl.parse("http://h/\u001c").encodedPath()); // information separator 4
-    assertEquals("/%1D", HttpUrl.parse("http://h/\u001d").encodedPath()); // information separator 3
-    assertEquals("/%1E", HttpUrl.parse("http://h/\u001e").encodedPath()); // information separator 2
-    assertEquals("/%1F", HttpUrl.parse("http://h/\u001f").encodedPath()); // information separator 1
-    assertEquals("/%C2%85", HttpUrl.parse("http://h/\u0085").encodedPath()); // next line
-    assertEquals("/%C2%A0", HttpUrl.parse("http://h/\u00a0").encodedPath()); // non-breaking space
-    assertEquals("/%E1%9A%80", HttpUrl.parse("http://h/\u1680").encodedPath()); // ogham space mark
-    assertEquals("/%E1%A0%8E", HttpUrl.parse("http://h/\u180e").encodedPath()); // mongolian vowel separator
-    assertEquals("/%E2%80%80", HttpUrl.parse("http://h/\u2000").encodedPath()); // en quad
-    assertEquals("/%E2%80%81", HttpUrl.parse("http://h/\u2001").encodedPath()); // em quad
-    assertEquals("/%E2%80%82", HttpUrl.parse("http://h/\u2002").encodedPath()); // en space
-    assertEquals("/%E2%80%83", HttpUrl.parse("http://h/\u2003").encodedPath()); // em space
-    assertEquals("/%E2%80%84", HttpUrl.parse("http://h/\u2004").encodedPath()); // three-per-em space
-    assertEquals("/%E2%80%85", HttpUrl.parse("http://h/\u2005").encodedPath()); // four-per-em space
-    assertEquals("/%E2%80%86", HttpUrl.parse("http://h/\u2006").encodedPath()); // six-per-em space
-    assertEquals("/%E2%80%87", HttpUrl.parse("http://h/\u2007").encodedPath()); // figure space
-    assertEquals("/%E2%80%88", HttpUrl.parse("http://h/\u2008").encodedPath()); // punctuation space
-    assertEquals("/%E2%80%89", HttpUrl.parse("http://h/\u2009").encodedPath()); // thin space
-    assertEquals("/%E2%80%8A", HttpUrl.parse("http://h/\u200a").encodedPath()); // hair space
-    assertEquals("/%E2%80%8B", HttpUrl.parse("http://h/\u200b").encodedPath()); // zero-width space
-    assertEquals("/%E2%80%8C", HttpUrl.parse("http://h/\u200c").encodedPath()); // zero-width non-joiner
-    assertEquals("/%E2%80%8D", HttpUrl.parse("http://h/\u200d").encodedPath()); // zero-width joiner
-    assertEquals("/%E2%80%8E", HttpUrl.parse("http://h/\u200e").encodedPath()); // left-to-right mark
-    assertEquals("/%E2%80%8F", HttpUrl.parse("http://h/\u200f").encodedPath()); // right-to-left mark
-    assertEquals("/%E2%80%A8", HttpUrl.parse("http://h/\u2028").encodedPath()); // line separator
-    assertEquals("/%E2%80%A9", HttpUrl.parse("http://h/\u2029").encodedPath()); // paragraph separator
-    assertEquals("/%E2%80%AF", HttpUrl.parse("http://h/\u202f").encodedPath()); // narrow non-breaking space
-    assertEquals("/%E2%81%9F", HttpUrl.parse("http://h/\u205f").encodedPath()); // medium mathematical space
-    assertEquals("/%E3%80%80", HttpUrl.parse("http://h/\u3000").encodedPath()); // ideographic space
+    assertEquals("/%0B", parse("http://h/\u000b").encodedPath()); // line tabulation
+    assertEquals("/%1C", parse("http://h/\u001c").encodedPath()); // information separator 4
+    assertEquals("/%1D", parse("http://h/\u001d").encodedPath()); // information separator 3
+    assertEquals("/%1E", parse("http://h/\u001e").encodedPath()); // information separator 2
+    assertEquals("/%1F", parse("http://h/\u001f").encodedPath()); // information separator 1
+    assertEquals("/%C2%85", parse("http://h/\u0085").encodedPath()); // next line
+    assertEquals("/%C2%A0", parse("http://h/\u00a0").encodedPath()); // non-breaking space
+    assertEquals("/%E1%9A%80", parse("http://h/\u1680").encodedPath()); // ogham space mark
+    assertEquals("/%E1%A0%8E", parse("http://h/\u180e").encodedPath()); // mongolian vowel separator
+    assertEquals("/%E2%80%80", parse("http://h/\u2000").encodedPath()); // en quad
+    assertEquals("/%E2%80%81", parse("http://h/\u2001").encodedPath()); // em quad
+    assertEquals("/%E2%80%82", parse("http://h/\u2002").encodedPath()); // en space
+    assertEquals("/%E2%80%83", parse("http://h/\u2003").encodedPath()); // em space
+    assertEquals("/%E2%80%84", parse("http://h/\u2004").encodedPath()); // three-per-em space
+    assertEquals("/%E2%80%85", parse("http://h/\u2005").encodedPath()); // four-per-em space
+    assertEquals("/%E2%80%86", parse("http://h/\u2006").encodedPath()); // six-per-em space
+    assertEquals("/%E2%80%87", parse("http://h/\u2007").encodedPath()); // figure space
+    assertEquals("/%E2%80%88", parse("http://h/\u2008").encodedPath()); // punctuation space
+    assertEquals("/%E2%80%89", parse("http://h/\u2009").encodedPath()); // thin space
+    assertEquals("/%E2%80%8A", parse("http://h/\u200a").encodedPath()); // hair space
+    assertEquals("/%E2%80%8B", parse("http://h/\u200b").encodedPath()); // zero-width space
+    assertEquals("/%E2%80%8C", parse("http://h/\u200c").encodedPath()); // zero-width non-joiner
+    assertEquals("/%E2%80%8D", parse("http://h/\u200d").encodedPath()); // zero-width joiner
+    assertEquals("/%E2%80%8E", parse("http://h/\u200e").encodedPath()); // left-to-right mark
+    assertEquals("/%E2%80%8F", parse("http://h/\u200f").encodedPath()); // right-to-left mark
+    assertEquals("/%E2%80%A8", parse("http://h/\u2028").encodedPath()); // line separator
+    assertEquals("/%E2%80%A9", parse("http://h/\u2029").encodedPath()); // paragraph separator
+    assertEquals("/%E2%80%AF", parse("http://h/\u202f").encodedPath()); // narrow non-breaking space
+    assertEquals("/%E2%81%9F", parse("http://h/\u205f").encodedPath()); // medium mathematical space
+    assertEquals("/%E3%80%80", parse("http://h/\u3000").encodedPath()); // ideographic space
   }
 
   @Test public void scheme() throws Exception {
-    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host/"));
-    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("Http://host/"));
-    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host/"));
-    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("HTTP://host/"));
-    assertEquals(HttpUrl.parse("https://host/"), HttpUrl.parse("https://host/"));
-    assertEquals(HttpUrl.parse("https://host/"), HttpUrl.parse("HTTPS://host/"));
-    assertEquals(HttpUrl.Builder.ParseResult.UNSUPPORTED_SCHEME,
-        new HttpUrl.Builder().parse(null, "image640://480.png"));
-    assertEquals(null, HttpUrl.parse("httpp://host/"));
-    assertEquals(null, HttpUrl.parse("0ttp://host/"));
-    assertEquals(null, HttpUrl.parse("ht+tp://host/"));
-    assertEquals(null, HttpUrl.parse("ht.tp://host/"));
-    assertEquals(null, HttpUrl.parse("ht-tp://host/"));
-    assertEquals(null, HttpUrl.parse("ht1tp://host/"));
-    assertEquals(null, HttpUrl.parse("httpss://host/"));
+    assertEquals(parse("http://host/"), parse("http://host/"));
+    assertEquals(parse("http://host/"), parse("Http://host/"));
+    assertEquals(parse("http://host/"), parse("http://host/"));
+    assertEquals(parse("http://host/"), parse("HTTP://host/"));
+    assertEquals(parse("https://host/"), parse("https://host/"));
+    assertEquals(parse("https://host/"), parse("HTTPS://host/"));
+
+    assertInvalid("image640://480.png", "Expected URL scheme 'http' or 'https' but was 'image640'");
+    assertInvalid("httpp://host/", "Expected URL scheme 'http' or 'https' but was 'httpp'");
+    assertInvalid("0ttp://host/", "Expected URL scheme 'http' or 'https' but no colon was found");
+    assertInvalid("ht+tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht+tp'");
+    assertInvalid("ht.tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht.tp'");
+    assertInvalid("ht-tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht-tp'");
+    assertInvalid("ht1tp://host/", "Expected URL scheme 'http' or 'https' but was 'ht1tp'");
+    assertInvalid("httpss://host/", "Expected URL scheme 'http' or 'https' but was 'httpss'");
   }
 
   @Test public void parseNoScheme() throws Exception {
-    assertEquals(null, HttpUrl.parse("//host"));
-    assertEquals(null, HttpUrl.parse("/path"));
-    assertEquals(null, HttpUrl.parse("path"));
-    assertEquals(null, HttpUrl.parse("?query"));
-    assertEquals(null, HttpUrl.parse("#fragment"));
+    assertInvalid("//host", "Expected URL scheme 'http' or 'https' but no colon was found");
+    assertInvalid("/path", "Expected URL scheme 'http' or 'https' but no colon was found");
+    assertInvalid("path", "Expected URL scheme 'http' or 'https' but no colon was found");
+    assertInvalid("?query", "Expected URL scheme 'http' or 'https' but no colon was found");
+    assertInvalid("#fragment", "Expected URL scheme 'http' or 'https' but no colon was found");
   }
 
   @Test public void newBuilderResolve() throws Exception {
     // Non-exhaustive tests because implementation is the same as resolve.
-    HttpUrl base = HttpUrl.parse("http://host/a/b");
-    assertEquals(HttpUrl.parse("https://host2/"), base.newBuilder("https://host2").build());
-    assertEquals(HttpUrl.parse("http://host2/"), base.newBuilder("//host2").build());
-    assertEquals(HttpUrl.parse("http://host/path"), base.newBuilder("/path").build());
-    assertEquals(HttpUrl.parse("http://host/a/path"), base.newBuilder("path").build());
-    assertEquals(HttpUrl.parse("http://host/a/b?query"), base.newBuilder("?query").build());
-    assertEquals(HttpUrl.parse("http://host/a/b#fragment"), base.newBuilder("#fragment").build());
-    assertEquals(HttpUrl.parse("http://host/a/b"), base.newBuilder("").build());
+    HttpUrl base = parse("http://host/a/b");
+    assertEquals(parse("https://host2/"), base.newBuilder("https://host2").build());
+    assertEquals(parse("http://host2/"), base.newBuilder("//host2").build());
+    assertEquals(parse("http://host/path"), base.newBuilder("/path").build());
+    assertEquals(parse("http://host/a/path"), base.newBuilder("path").build());
+    assertEquals(parse("http://host/a/b?query"), base.newBuilder("?query").build());
+    assertEquals(parse("http://host/a/b#fragment"), base.newBuilder("#fragment").build());
+    assertEquals(parse("http://host/a/b"), base.newBuilder("").build());
     assertEquals(null, base.newBuilder("ftp://b"));
     assertEquals(null, base.newBuilder("ht+tp://b"));
     assertEquals(null, base.newBuilder("ht-tp://b"));
@@ -125,27 +147,27 @@
   }
 
   @Test public void redactedUrl() {
-    HttpUrl baseWithPasswordAndUsername = HttpUrl.parse("http://username:password@host/a/b#fragment");
-    HttpUrl baseWithUsernameOnly = HttpUrl.parse("http://username@host/a/b#fragment");
-    HttpUrl baseWithPasswordOnly = HttpUrl.parse("http://password@host/a/b#fragment");
+    HttpUrl baseWithPasswordAndUsername = parse("http://username:password@host/a/b#fragment");
+    HttpUrl baseWithUsernameOnly = parse("http://username@host/a/b#fragment");
+    HttpUrl baseWithPasswordOnly = parse("http://password@host/a/b#fragment");
     assertEquals("http://host/...", baseWithPasswordAndUsername.redact());
     assertEquals("http://host/...", baseWithUsernameOnly.redact());
     assertEquals("http://host/...", baseWithPasswordOnly.redact());
   }
 
   @Test public void resolveNoScheme() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b");
-    assertEquals(HttpUrl.parse("http://host2/"), base.resolve("//host2"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("/path"));
-    assertEquals(HttpUrl.parse("http://host/a/path"), base.resolve("path"));
-    assertEquals(HttpUrl.parse("http://host/a/b?query"), base.resolve("?query"));
-    assertEquals(HttpUrl.parse("http://host/a/b#fragment"), base.resolve("#fragment"));
-    assertEquals(HttpUrl.parse("http://host/a/b"), base.resolve(""));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("\\path"));
+    HttpUrl base = parse("http://host/a/b");
+    assertEquals(parse("http://host2/"), base.resolve("//host2"));
+    assertEquals(parse("http://host/path"), base.resolve("/path"));
+    assertEquals(parse("http://host/a/path"), base.resolve("path"));
+    assertEquals(parse("http://host/a/b?query"), base.resolve("?query"));
+    assertEquals(parse("http://host/a/b#fragment"), base.resolve("#fragment"));
+    assertEquals(parse("http://host/a/b"), base.resolve(""));
+    assertEquals(parse("http://host/path"), base.resolve("\\path"));
   }
 
   @Test public void resolveUnsupportedScheme() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://a/");
+    HttpUrl base = parse("http://a/");
     assertEquals(null, base.resolve("ftp://b"));
     assertEquals(null, base.resolve("ht+tp://b"));
     assertEquals(null, base.resolve("ht-tp://b"));
@@ -153,159 +175,159 @@
   }
 
   @Test public void resolveSchemeLikePath() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://a/");
-    assertEquals(HttpUrl.parse("http://a/http//b/"), base.resolve("http//b/"));
-    assertEquals(HttpUrl.parse("http://a/ht+tp//b/"), base.resolve("ht+tp//b/"));
-    assertEquals(HttpUrl.parse("http://a/ht-tp//b/"), base.resolve("ht-tp//b/"));
-    assertEquals(HttpUrl.parse("http://a/ht.tp//b/"), base.resolve("ht.tp//b/"));
+    HttpUrl base = parse("http://a/");
+    assertEquals(parse("http://a/http//b/"), base.resolve("http//b/"));
+    assertEquals(parse("http://a/ht+tp//b/"), base.resolve("ht+tp//b/"));
+    assertEquals(parse("http://a/ht-tp//b/"), base.resolve("ht-tp//b/"));
+    assertEquals(parse("http://a/ht.tp//b/"), base.resolve("ht.tp//b/"));
   }
 
   /** https://tools.ietf.org/html/rfc3986#section-5.4.1 */
   @Test public void rfc3886NormalExamples() {
-    HttpUrl url = HttpUrl.parse("http://a/b/c/d;p?q");
+    HttpUrl url = parse("http://a/b/c/d;p?q");
     assertEquals(null, url.resolve("g:h")); // No 'g:' scheme in HttpUrl.
-    assertEquals(HttpUrl.parse("http://a/b/c/g"), url.resolve("g"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g"), url.resolve("./g"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g/"), url.resolve("g/"));
-    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("/g"));
-    assertEquals(HttpUrl.parse("http://g"), url.resolve("//g"));
-    assertEquals(HttpUrl.parse("http://a/b/c/d;p?y"), url.resolve("?y"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g?y"), url.resolve("g?y"));
-    assertEquals(HttpUrl.parse("http://a/b/c/d;p?q#s"), url.resolve("#s"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g#s"), url.resolve("g#s"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g?y#s"), url.resolve("g?y#s"));
-    assertEquals(HttpUrl.parse("http://a/b/c/;x"), url.resolve(";x"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g;x"), url.resolve("g;x"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g;x?y#s"), url.resolve("g;x?y#s"));
-    assertEquals(HttpUrl.parse("http://a/b/c/d;p?q"), url.resolve(""));
-    assertEquals(HttpUrl.parse("http://a/b/c/"), url.resolve("."));
-    assertEquals(HttpUrl.parse("http://a/b/c/"), url.resolve("./"));
-    assertEquals(HttpUrl.parse("http://a/b/"), url.resolve(".."));
-    assertEquals(HttpUrl.parse("http://a/b/"), url.resolve("../"));
-    assertEquals(HttpUrl.parse("http://a/b/g"), url.resolve("../g"));
-    assertEquals(HttpUrl.parse("http://a/"), url.resolve("../.."));
-    assertEquals(HttpUrl.parse("http://a/"), url.resolve("../../"));
-    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("../../g"));
+    assertEquals(parse("http://a/b/c/g"), url.resolve("g"));
+    assertEquals(parse("http://a/b/c/g"), url.resolve("./g"));
+    assertEquals(parse("http://a/b/c/g/"), url.resolve("g/"));
+    assertEquals(parse("http://a/g"), url.resolve("/g"));
+    assertEquals(parse("http://g"), url.resolve("//g"));
+    assertEquals(parse("http://a/b/c/d;p?y"), url.resolve("?y"));
+    assertEquals(parse("http://a/b/c/g?y"), url.resolve("g?y"));
+    assertEquals(parse("http://a/b/c/d;p?q#s"), url.resolve("#s"));
+    assertEquals(parse("http://a/b/c/g#s"), url.resolve("g#s"));
+    assertEquals(parse("http://a/b/c/g?y#s"), url.resolve("g?y#s"));
+    assertEquals(parse("http://a/b/c/;x"), url.resolve(";x"));
+    assertEquals(parse("http://a/b/c/g;x"), url.resolve("g;x"));
+    assertEquals(parse("http://a/b/c/g;x?y#s"), url.resolve("g;x?y#s"));
+    assertEquals(parse("http://a/b/c/d;p?q"), url.resolve(""));
+    assertEquals(parse("http://a/b/c/"), url.resolve("."));
+    assertEquals(parse("http://a/b/c/"), url.resolve("./"));
+    assertEquals(parse("http://a/b/"), url.resolve(".."));
+    assertEquals(parse("http://a/b/"), url.resolve("../"));
+    assertEquals(parse("http://a/b/g"), url.resolve("../g"));
+    assertEquals(parse("http://a/"), url.resolve("../.."));
+    assertEquals(parse("http://a/"), url.resolve("../../"));
+    assertEquals(parse("http://a/g"), url.resolve("../../g"));
   }
 
   /** https://tools.ietf.org/html/rfc3986#section-5.4.2 */
   @Test public void rfc3886AbnormalExamples() {
-    HttpUrl url = HttpUrl.parse("http://a/b/c/d;p?q");
-    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("../../../g"));
-    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("../../../../g"));
-    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("/./g"));
-    assertEquals(HttpUrl.parse("http://a/g"), url.resolve("/../g"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g."), url.resolve("g."));
-    assertEquals(HttpUrl.parse("http://a/b/c/.g"), url.resolve(".g"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g.."), url.resolve("g.."));
-    assertEquals(HttpUrl.parse("http://a/b/c/..g"), url.resolve("..g"));
-    assertEquals(HttpUrl.parse("http://a/b/g"), url.resolve("./../g"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g/"), url.resolve("./g/."));
-    assertEquals(HttpUrl.parse("http://a/b/c/g/h"), url.resolve("g/./h"));
-    assertEquals(HttpUrl.parse("http://a/b/c/h"), url.resolve("g/../h"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g;x=1/y"), url.resolve("g;x=1/./y"));
-    assertEquals(HttpUrl.parse("http://a/b/c/y"), url.resolve("g;x=1/../y"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g?y/./x"), url.resolve("g?y/./x"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g?y/../x"), url.resolve("g?y/../x"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g#s/./x"), url.resolve("g#s/./x"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g#s/../x"), url.resolve("g#s/../x"));
-    assertEquals(HttpUrl.parse("http://a/b/c/g"), url.resolve("http:g")); // "http:g" also okay.
+    HttpUrl url = parse("http://a/b/c/d;p?q");
+    assertEquals(parse("http://a/g"), url.resolve("../../../g"));
+    assertEquals(parse("http://a/g"), url.resolve("../../../../g"));
+    assertEquals(parse("http://a/g"), url.resolve("/./g"));
+    assertEquals(parse("http://a/g"), url.resolve("/../g"));
+    assertEquals(parse("http://a/b/c/g."), url.resolve("g."));
+    assertEquals(parse("http://a/b/c/.g"), url.resolve(".g"));
+    assertEquals(parse("http://a/b/c/g.."), url.resolve("g.."));
+    assertEquals(parse("http://a/b/c/..g"), url.resolve("..g"));
+    assertEquals(parse("http://a/b/g"), url.resolve("./../g"));
+    assertEquals(parse("http://a/b/c/g/"), url.resolve("./g/."));
+    assertEquals(parse("http://a/b/c/g/h"), url.resolve("g/./h"));
+    assertEquals(parse("http://a/b/c/h"), url.resolve("g/../h"));
+    assertEquals(parse("http://a/b/c/g;x=1/y"), url.resolve("g;x=1/./y"));
+    assertEquals(parse("http://a/b/c/y"), url.resolve("g;x=1/../y"));
+    assertEquals(parse("http://a/b/c/g?y/./x"), url.resolve("g?y/./x"));
+    assertEquals(parse("http://a/b/c/g?y/../x"), url.resolve("g?y/../x"));
+    assertEquals(parse("http://a/b/c/g#s/./x"), url.resolve("g#s/./x"));
+    assertEquals(parse("http://a/b/c/g#s/../x"), url.resolve("g#s/../x"));
+    assertEquals(parse("http://a/b/c/g"), url.resolve("http:g")); // "http:g" also okay.
   }
 
   @Test public void parseAuthoritySlashCountDoesntMatter() throws Exception {
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:///host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\//host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:/\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:\\\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http:////host/path"));
+    assertEquals(parse("http://host/path"), parse("http:host/path"));
+    assertEquals(parse("http://host/path"), parse("http:/host/path"));
+    assertEquals(parse("http://host/path"), parse("http:\\host/path"));
+    assertEquals(parse("http://host/path"), parse("http://host/path"));
+    assertEquals(parse("http://host/path"), parse("http:\\/host/path"));
+    assertEquals(parse("http://host/path"), parse("http:/\\host/path"));
+    assertEquals(parse("http://host/path"), parse("http:\\\\host/path"));
+    assertEquals(parse("http://host/path"), parse("http:///host/path"));
+    assertEquals(parse("http://host/path"), parse("http:\\//host/path"));
+    assertEquals(parse("http://host/path"), parse("http:/\\/host/path"));
+    assertEquals(parse("http://host/path"), parse("http://\\host/path"));
+    assertEquals(parse("http://host/path"), parse("http:\\\\/host/path"));
+    assertEquals(parse("http://host/path"), parse("http:/\\\\host/path"));
+    assertEquals(parse("http://host/path"), parse("http:\\\\\\host/path"));
+    assertEquals(parse("http://host/path"), parse("http:////host/path"));
   }
 
   @Test public void resolveAuthoritySlashCountDoesntMatterWithDifferentScheme() throws Exception {
-    HttpUrl base = HttpUrl.parse("https://a/b/c");
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:///host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\//host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:////host/path"));
+    HttpUrl base = parse("https://a/b/c");
+    assertEquals(parse("http://host/path"), base.resolve("http:host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:/host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http://host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\/host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:/\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:///host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\//host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:/\\/host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http://\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\\\/host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:/\\\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\\\\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:////host/path"));
   }
 
   @Test public void resolveAuthoritySlashCountMattersWithSameScheme() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://a/b/c");
-    assertEquals(HttpUrl.parse("http://a/b/host/path"), base.resolve("http:host/path"));
-    assertEquals(HttpUrl.parse("http://a/host/path"), base.resolve("http:/host/path"));
-    assertEquals(HttpUrl.parse("http://a/host/path"), base.resolve("http:\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:///host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\//host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http://\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\/host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:/\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:\\\\\\host/path"));
-    assertEquals(HttpUrl.parse("http://host/path"), base.resolve("http:////host/path"));
+    HttpUrl base = parse("http://a/b/c");
+    assertEquals(parse("http://a/b/host/path"), base.resolve("http:host/path"));
+    assertEquals(parse("http://a/host/path"), base.resolve("http:/host/path"));
+    assertEquals(parse("http://a/host/path"), base.resolve("http:\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http://host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\/host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:/\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:///host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\//host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:/\\/host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http://\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\\\/host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:/\\\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:\\\\\\host/path"));
+    assertEquals(parse("http://host/path"), base.resolve("http:////host/path"));
   }
 
   @Test public void username() throws Exception {
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://@host/path"));
-    assertEquals(HttpUrl.parse("http://user@host/path"), HttpUrl.parse("http://user@host/path"));
+    assertEquals(parse("http://host/path"), parse("http://@host/path"));
+    assertEquals(parse("http://user@host/path"), parse("http://user@host/path"));
   }
 
   /** Given multiple '@' characters, the last one is the delimiter. */
   @Test public void authorityWithMultipleAtSigns() throws Exception {
-    HttpUrl httpUrl = HttpUrl.parse("http://foo@bar@baz/path");
+    HttpUrl httpUrl = parse("http://foo@bar@baz/path");
     assertEquals("foo@bar", httpUrl.username());
     assertEquals("", httpUrl.password());
-    assertEquals(HttpUrl.parse("http://foo%40bar@baz/path"), httpUrl);
+    assertEquals(parse("http://foo%40bar@baz/path"), httpUrl);
   }
 
   /** Given multiple ':' characters, the first one is the delimiter. */
   @Test public void authorityWithMultipleColons() throws Exception {
-    HttpUrl httpUrl = HttpUrl.parse("http://foo:pass1@bar:pass2@baz/path");
+    HttpUrl httpUrl = parse("http://foo:pass1@bar:pass2@baz/path");
     assertEquals("foo", httpUrl.username());
     assertEquals("pass1@bar:pass2", httpUrl.password());
-    assertEquals(HttpUrl.parse("http://foo:pass1%40bar%3Apass2@baz/path"), httpUrl);
+    assertEquals(parse("http://foo:pass1%40bar%3Apass2@baz/path"), httpUrl);
   }
 
   @Test public void usernameAndPassword() throws Exception {
-    assertEquals(HttpUrl.parse("http://username:password@host/path"),
-        HttpUrl.parse("http://username:password@host/path"));
-    assertEquals(HttpUrl.parse("http://username@host/path"),
-        HttpUrl.parse("http://username:@host/path"));
+    assertEquals(parse("http://username:password@host/path"),
+        parse("http://username:password@host/path"));
+    assertEquals(parse("http://username@host/path"),
+        parse("http://username:@host/path"));
   }
 
   @Test public void passwordWithEmptyUsername() throws Exception {
     // Chrome doesn't mind, but Firefox rejects URLs with empty usernames and non-empty passwords.
-    assertEquals(HttpUrl.parse("http://host/path"), HttpUrl.parse("http://:@host/path"));
-    assertEquals("password%40", HttpUrl.parse("http://:password@@host/path").encodedPassword());
+    assertEquals(parse("http://host/path"), parse("http://:@host/path"));
+    assertEquals("password%40", parse("http://:password@@host/path").encodedPassword());
   }
 
   @Test public void unprintableCharactersArePercentEncoded() throws Exception {
-    assertEquals("/%00", HttpUrl.parse("http://host/\u0000").encodedPath());
-    assertEquals("/%08", HttpUrl.parse("http://host/\u0008").encodedPath());
-    assertEquals("/%EF%BF%BD", HttpUrl.parse("http://host/\ufffd").encodedPath());
+    assertEquals("/%00", parse("http://host/\u0000").encodedPath());
+    assertEquals("/%08", parse("http://host/\u0008").encodedPath());
+    assertEquals("/%EF%BF%BD", parse("http://host/\ufffd").encodedPath());
   }
 
   @Test public void usernameCharacters() throws Exception {
@@ -325,183 +347,220 @@
   }
 
   @Test public void hostContainsIllegalCharacter() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://\n/"));
-    assertEquals(null, HttpUrl.parse("http:// /"));
-    assertEquals(null, HttpUrl.parse("http://%20/"));
+    assertInvalid("http://\n/", "Invalid URL host: \"\n\"");
+    assertInvalid("http:// /", "Invalid URL host: \" \"");
+    assertInvalid("http://%20/", "Invalid URL host: \"%20\"");
   }
 
   @Test public void hostnameLowercaseCharactersMappedDirectly() throws Exception {
-    assertEquals("abcd", HttpUrl.parse("http://abcd").host());
-    assertEquals("xn--4xa", HttpUrl.parse("http://Ïƒ").host());
+    assertEquals("abcd", parse("http://abcd").host());
+    assertEquals("xn--4xa", parse("http://Ïƒ").host());
   }
 
   @Test public void hostnameUppercaseCharactersConvertedToLowercase() throws Exception {
-    assertEquals("abcd", HttpUrl.parse("http://ABCD").host());
-    assertEquals("xn--4xa", HttpUrl.parse("http://Î£").host());
+    assertEquals("abcd", parse("http://ABCD").host());
+    assertEquals("xn--4xa", parse("http://Î£").host());
   }
 
   @Test public void hostnameIgnoredCharacters() throws Exception {
     // The soft hyphen (Â­) should be ignored.
-    assertEquals("abcd", HttpUrl.parse("http://AB\u00adCD").host());
+    assertEquals("abcd", parse("http://AB\u00adCD").host());
   }
 
   @Test public void hostnameMultipleCharacterMapping() throws Exception {
     // Map the single character telephone symbol (â„¡) to the string "tel".
-    assertEquals("tel", HttpUrl.parse("http://\u2121").host());
+    assertEquals("tel", parse("http://\u2121").host());
   }
 
   @Test public void hostnameMappingLastMappedCodePoint() throws Exception {
-    assertEquals("xn--pu5l", HttpUrl.parse("http://\uD87E\uDE1D").host());
+    assertEquals("xn--pu5l", parse("http://\uD87E\uDE1D").host());
   }
 
   @Ignore("The java.net.IDN implementation doesn't ignore characters that it should.")
   @Test public void hostnameMappingLastIgnoredCodePoint() throws Exception {
-    assertEquals("abcd", HttpUrl.parse("http://ab\uDB40\uDDEFcd").host());
+    assertEquals("abcd", parse("http://ab\uDB40\uDDEFcd").host());
   }
 
   @Test public void hostnameMappingLastDisallowedCodePoint() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://\uDBFF\uDFFF"));
+    assertInvalid("http://\uDBFF\uDFFF", "Invalid URL host: \"\uDBFF\uDFFF\"");
   }
 
   @Test public void hostIpv6() throws Exception {
     // Square braces are absent from host()...
-    assertEquals("::1", HttpUrl.parse("http://[::1]/").host());
+    assertEquals("::1", parse("http://[::1]/").host());
 
     // ... but they're included in toString().
-    assertEquals("http://[::1]/", HttpUrl.parse("http://[::1]/").toString());
+    assertEquals("http://[::1]/", parse("http://[::1]/").toString());
 
     // IPv6 colons don't interfere with port numbers or passwords.
-    assertEquals(8080, HttpUrl.parse("http://[::1]:8080/").port());
-    assertEquals("password", HttpUrl.parse("http://user:password@[::1]/").password());
-    assertEquals("::1", HttpUrl.parse("http://user:password@[::1]:8080/").host());
+    assertEquals(8080, parse("http://[::1]:8080/").port());
+    assertEquals("password", parse("http://user:password@[::1]/").password());
+    assertEquals("::1", parse("http://user:password@[::1]:8080/").host());
 
     // Permit the contents of IPv6 addresses to be percent-encoded...
-    assertEquals("::1", HttpUrl.parse("http://[%3A%3A%31]/").host());
+    assertEquals("::1", parse("http://[%3A%3A%31]/").host());
 
     // Including the Square braces themselves! (This is what Chrome does.)
-    assertEquals("::1", HttpUrl.parse("http://%5B%3A%3A1%5D/").host());
+    assertEquals("::1", parse("http://%5B%3A%3A1%5D/").host());
   }
 
   @Test public void hostIpv6AddressDifferentFormats() throws Exception {
     // Multiple representations of the same address; see http://tools.ietf.org/html/rfc5952.
     String a3 = "2001:db8::1:0:0:1";
-    assertEquals(a3, HttpUrl.parse("http://[2001:db8:0:0:1:0:0:1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:0db8:0:0:1:0:0:1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:db8::1:0:0:1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:db8::0:1:0:0:1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:0db8::1:0:0:1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:db8:0:0:1::1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:db8:0000:0:1::1]").host());
-    assertEquals(a3, HttpUrl.parse("http://[2001:DB8:0:0:1::1]").host());
+    assertEquals(a3, parse("http://[2001:db8:0:0:1:0:0:1]").host());
+    assertEquals(a3, parse("http://[2001:0db8:0:0:1:0:0:1]").host());
+    assertEquals(a3, parse("http://[2001:db8::1:0:0:1]").host());
+    assertEquals(a3, parse("http://[2001:db8::0:1:0:0:1]").host());
+    assertEquals(a3, parse("http://[2001:0db8::1:0:0:1]").host());
+    assertEquals(a3, parse("http://[2001:db8:0:0:1::1]").host());
+    assertEquals(a3, parse("http://[2001:db8:0000:0:1::1]").host());
+    assertEquals(a3, parse("http://[2001:DB8:0:0:1::1]").host());
   }
 
   @Test public void hostIpv6AddressLeadingCompression() throws Exception {
-    assertEquals("::1", HttpUrl.parse("http://[::0001]").host());
-    assertEquals("::1", HttpUrl.parse("http://[0000::0001]").host());
-    assertEquals("::1", HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001]").host());
-    assertEquals("::1", HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000::0001]").host());
+    assertEquals("::1", parse("http://[::0001]").host());
+    assertEquals("::1", parse("http://[0000::0001]").host());
+    assertEquals("::1", parse("http://[0000:0000:0000:0000:0000:0000:0000:0001]").host());
+    assertEquals("::1", parse("http://[0000:0000:0000:0000:0000:0000::0001]").host());
   }
 
   @Test public void hostIpv6AddressTrailingCompression() throws Exception {
-    assertEquals("1::", HttpUrl.parse("http://[0001:0000::]").host());
-    assertEquals("1::", HttpUrl.parse("http://[0001::0000]").host());
-    assertEquals("1::", HttpUrl.parse("http://[0001::]").host());
-    assertEquals("1::", HttpUrl.parse("http://[1::]").host());
+    assertEquals("1::", parse("http://[0001:0000::]").host());
+    assertEquals("1::", parse("http://[0001::0000]").host());
+    assertEquals("1::", parse("http://[0001::]").host());
+    assertEquals("1::", parse("http://[1::]").host());
   }
 
   @Test public void hostIpv6AddressTooManyDigitsInGroup() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://[00000:0000:0000:0000:0000:0000:0000:0001]"));
-    assertEquals(null, HttpUrl.parse("http://[::00001]"));
+    assertInvalid("http://[00000:0000:0000:0000:0000:0000:0000:0001]",
+        "Invalid URL host: \"[00000:0000:0000:0000:0000:0000:0000:0001]\"");
+    assertInvalid("http://[::00001]", "Invalid URL host: \"[::00001]\"");
   }
 
   @Test public void hostIpv6AddressMisplacedColons() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://[:0000:0000:0000:0000:0000:0000:0000:0001]"));
-    assertEquals(null, HttpUrl.parse("http://[:::0000:0000:0000:0000:0000:0000:0000:0001]"));
-    assertEquals(null, HttpUrl.parse("http://[:1]"));
-    assertEquals(null, HttpUrl.parse("http://[:::1]"));
-    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0001:]"));
-    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001:]"));
-    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001::]"));
-    assertEquals(null, HttpUrl.parse("http://[0000:0000:0000:0000:0000:0000:0000:0001:::]"));
-    assertEquals(null, HttpUrl.parse("http://[1:]"));
-    assertEquals(null, HttpUrl.parse("http://[1:::]"));
-    assertEquals(null, HttpUrl.parse("http://[1:::1]"));
-    assertEquals(null, HttpUrl.parse("http://[00000:0000:0000:0000::0000:0000:0000:0001]"));
+    assertInvalid("http://[:0000:0000:0000:0000:0000:0000:0000:0001]",
+        "Invalid URL host: \"[:0000:0000:0000:0000:0000:0000:0000:0001]\"");
+    assertInvalid("http://[:::0000:0000:0000:0000:0000:0000:0000:0001]",
+        "Invalid URL host: \"[:::0000:0000:0000:0000:0000:0000:0000:0001]\"");
+    assertInvalid("http://[:1]", "Invalid URL host: \"[:1]\"");
+    assertInvalid("http://[:::1]", "Invalid URL host: \"[:::1]\"");
+    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0001:]",
+        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0001:]\"");
+    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0001:]",
+        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0001:]\"");
+    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0001::]",
+        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0001::]\"");
+    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0001:::]",
+        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0001:::]\"");
+    assertInvalid("http://[1:]", "Invalid URL host: \"[1:]\"");
+    assertInvalid("http://[1:::]", "Invalid URL host: \"[1:::]\"");
+    assertInvalid("http://[1:::1]", "Invalid URL host: \"[1:::1]\"");
+    assertInvalid("http://[0000:0000:0000:0000::0000:0000:0000:0001]",
+        "Invalid URL host: \"[0000:0000:0000:0000::0000:0000:0000:0001]\"");
   }
 
   @Test public void hostIpv6AddressTooManyGroups() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://[00000:0000:0000:0000:0000:0000:0000:0000:0001]"));
+    assertInvalid("http://[0000:0000:0000:0000:0000:0000:0000:0000:0001]",
+        "Invalid URL host: \"[0000:0000:0000:0000:0000:0000:0000:0000:0001]\"");
   }
 
   @Test public void hostIpv6AddressTooMuchCompression() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://[0000::0000:0000:0000:0000::0001]"));
-    assertEquals(null, HttpUrl.parse("http://[::0000:0000:0000:0000::0001]"));
+    assertInvalid("http://[0000::0000:0000:0000:0000::0001]",
+        "Invalid URL host: \"[0000::0000:0000:0000:0000::0001]\"");
+    assertInvalid("http://[::0000:0000:0000:0000::0001]",
+        "Invalid URL host: \"[::0000:0000:0000:0000::0001]\"");
   }
 
   @Test public void hostIpv6ScopedAddress() throws Exception {
     // java.net.InetAddress parses scoped addresses. These aren't valid in URLs.
-    assertEquals(null, HttpUrl.parse("http://[::1%2544]"));
+    assertInvalid("http://[::1%2544]", "Invalid URL host: \"[::1%2544]\"");
+  }
+
+  @Test public void hostIpv6AddressTooManyLeadingZeros() throws Exception {
+    // Guava's been buggy on this case. https://github.com/google/guava/issues/3116
+    assertInvalid("http://[2001:db8:0:0:1:0:0:00001]",
+        "Invalid URL host: \"[2001:db8:0:0:1:0:0:00001]\"");
   }
 
   @Test public void hostIpv6WithIpv4Suffix() throws Exception {
-    assertEquals("::1:ffff:ffff", HttpUrl.parse("http://[::1:255.255.255.255]/").host());
-    assertEquals("::1:0:0", HttpUrl.parse("http://[0:0:0:0:0:1:0.0.0.0]/").host());
+    assertEquals("::1:ffff:ffff", parse("http://[::1:255.255.255.255]/").host());
+    assertEquals("::1:0:0", parse("http://[0:0:0:0:0:1:0.0.0.0]/").host());
   }
 
   @Test public void hostIpv6WithIpv4SuffixWithOctalPrefix() throws Exception {
     // Chrome interprets a leading '0' as octal; Firefox rejects them. (We reject them.)
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0.0.000000]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.010.0.010]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0.0.000001]/"));
+    assertInvalid("http://[0:0:0:0:0:1:0.0.0.000000]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:0.0.0.000000]\"");
+    assertInvalid("http://[0:0:0:0:0:1:0.010.0.010]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:0.010.0.010]\"");
+    assertInvalid("http://[0:0:0:0:0:1:0.0.0.000001]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:0.0.0.000001]\"");
   }
 
   @Test public void hostIpv6WithIpv4SuffixWithHexadecimalPrefix() throws Exception {
     // Chrome interprets a leading '0x' as hexadecimal; Firefox rejects them. (We reject them.)
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0x10.0.0x10]/"));
+    assertInvalid("http://[0:0:0:0:0:1:0.0x10.0.0x10]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:0.0x10.0.0x10]\"");
   }
 
   @Test public void hostIpv6WithMalformedIpv4Suffix() throws Exception {
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0:0.0]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:0.0-0.0]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:.255.255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255..255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255.255..255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:0:1:255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:256.255.255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:ff.255.255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:0:1:255.255.255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:1:255.255.255.255]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:1:0.0.0.0:1]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0.0.0.0:1:0:0:0:0:1]/"));
-    assertEquals(null, HttpUrl.parse("http://[0.0.0.0:0:0:0:0:0:1]/"));
+    assertInvalid("http://[0:0:0:0:0:1:0.0:0.0]/", "Invalid URL host: \"[0:0:0:0:0:1:0.0:0.0]\"");
+    assertInvalid("http://[0:0:0:0:0:1:0.0-0.0]/", "Invalid URL host: \"[0:0:0:0:0:1:0.0-0.0]\"");
+    assertInvalid("http://[0:0:0:0:0:1:.255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:.255.255.255]\"");
+    assertInvalid("http://[0:0:0:0:0:1:255..255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:255..255.255]\"");
+    assertInvalid("http://[0:0:0:0:0:1:255.255..255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:255.255..255]\"");
+    assertInvalid("http://[0:0:0:0:0:0:1:255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:0:1:255.255]\"");
+    assertInvalid("http://[0:0:0:0:0:1:256.255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:256.255.255.255]\"");
+    assertInvalid("http://[0:0:0:0:0:1:ff.255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:ff.255.255.255]\"");
+    assertInvalid("http://[0:0:0:0:0:0:1:255.255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:0:1:255.255.255.255]\"");
+    assertInvalid("http://[0:0:0:0:1:255.255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:1:255.255.255.255]\"");
+    assertInvalid("http://[0:0:0:0:1:0.0.0.0:1]/", "Invalid URL host: \"[0:0:0:0:1:0.0.0.0:1]\"");
+    assertInvalid("http://[0:0.0.0.0:1:0:0:0:0:1]/",
+        "Invalid URL host: \"[0:0.0.0.0:1:0:0:0:0:1]\"");
+    assertInvalid("http://[0.0.0.0:0:0:0:0:0:1]/", "Invalid URL host: \"[0.0.0.0:0:0:0:0:0:1]\"");
   }
 
   @Test public void hostIpv6WithIncompleteIpv4Suffix() throws Exception {
     // To Chrome & Safari these are well-formed; Firefox disagrees. (We're consistent with Firefox).
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255.255.255.]/"));
-    assertEquals(null, HttpUrl.parse("http://[0:0:0:0:0:1:255.255.255]/"));
+    assertInvalid("http://[0:0:0:0:0:1:255.255.255.]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:255.255.255.]\"");
+    assertInvalid("http://[0:0:0:0:0:1:255.255.255]/",
+        "Invalid URL host: \"[0:0:0:0:0:1:255.255.255]\"");
   }
 
   @Test public void hostIpv6CanonicalForm() throws Exception {
     assertEquals("abcd:ef01:2345:6789:abcd:ef01:2345:6789",
-        HttpUrl.parse("http://[abcd:ef01:2345:6789:abcd:ef01:2345:6789]/").host());
-    assertEquals("a::b:0:0:0", HttpUrl.parse("http://[a:0:0:0:b:0:0:0]/").host());
-    assertEquals("a:b:0:0:c::", HttpUrl.parse("http://[a:b:0:0:c:0:0:0]/").host());
-    assertEquals("a:b::c:0:0", HttpUrl.parse("http://[a:b:0:0:0:c:0:0]/").host());
-    assertEquals("a::b:0:0:0", HttpUrl.parse("http://[a:0:0:0:b:0:0:0]/").host());
-    assertEquals("::a:b:0:0:0", HttpUrl.parse("http://[0:0:0:a:b:0:0:0]/").host());
-    assertEquals("::a:0:0:0:b", HttpUrl.parse("http://[0:0:0:a:0:0:0:b]/").host());
-    assertEquals("::a:b:c:d:e:f:1", HttpUrl.parse("http://[0:a:b:c:d:e:f:1]/").host());
-    assertEquals("a:b:c:d:e:f:1::", HttpUrl.parse("http://[a:b:c:d:e:f:1:0]/").host());
-    assertEquals("ff01::101", HttpUrl.parse("http://[FF01:0:0:0:0:0:0:101]/").host());
-    assertEquals("1::", HttpUrl.parse("http://[1:0:0:0:0:0:0:0]/").host());
-    assertEquals("::1", HttpUrl.parse("http://[0:0:0:0:0:0:0:1]/").host());
-    assertEquals("::", HttpUrl.parse("http://[0:0:0:0:0:0:0:0]/").host());
+        parse("http://[abcd:ef01:2345:6789:abcd:ef01:2345:6789]/").host());
+    assertEquals("a::b:0:0:0", parse("http://[a:0:0:0:b:0:0:0]/").host());
+    assertEquals("a:b:0:0:c::", parse("http://[a:b:0:0:c:0:0:0]/").host());
+    assertEquals("a:b::c:0:0", parse("http://[a:b:0:0:0:c:0:0]/").host());
+    assertEquals("a::b:0:0:0", parse("http://[a:0:0:0:b:0:0:0]/").host());
+    assertEquals("::a:b:0:0:0", parse("http://[0:0:0:a:b:0:0:0]/").host());
+    assertEquals("::a:0:0:0:b", parse("http://[0:0:0:a:0:0:0:b]/").host());
+    assertEquals("0:a:b:c:d:e:f:1", parse("http://[0:a:b:c:d:e:f:1]/").host());
+    assertEquals("a:b:c:d:e:f:1:0", parse("http://[a:b:c:d:e:f:1:0]/").host());
+    assertEquals("ff01::101", parse("http://[FF01:0:0:0:0:0:0:101]/").host());
+    assertEquals("2001:db8::1", parse("http://[2001:db8::1]/").host());
+    assertEquals("2001:db8::2:1", parse("http://[2001:db8:0:0:0:0:2:1]/").host());
+    assertEquals("2001:db8:0:1:1:1:1:1", parse("http://[2001:db8:0:1:1:1:1:1]/").host());
+    assertEquals("2001:db8::1:0:0:1", parse("http://[2001:db8:0:0:1:0:0:1]/").host());
+    assertEquals("2001:0:0:1::1", parse("http://[2001:0:0:1:0:0:0:1]/").host());
+    assertEquals("1::", parse("http://[1:0:0:0:0:0:0:0]/").host());
+    assertEquals("::1", parse("http://[0:0:0:0:0:0:0:1]/").host());
+    assertEquals("::", parse("http://[0:0:0:0:0:0:0:0]/").host());
   }
 
   /** The builder permits square braces but does not require them. */
   @Test public void hostIPv6Builder() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://example.com/");
+    HttpUrl base = parse("http://example.com/");
     assertEquals("http://[::1]/", base.newBuilder().host("[::1]").build().toString());
     assertEquals("http://[::1]/", base.newBuilder().host("[::0001]").build().toString());
     assertEquals("http://[::1]/", base.newBuilder().host("::1").build().toString());
@@ -509,26 +568,26 @@
   }
 
   @Test public void hostIpv4CanonicalForm() throws Exception {
-    assertEquals("255.255.255.255", HttpUrl.parse("http://255.255.255.255/").host());
-    assertEquals("1.2.3.4", HttpUrl.parse("http://1.2.3.4/").host());
-    assertEquals("0.0.0.0", HttpUrl.parse("http://0.0.0.0/").host());
+    assertEquals("255.255.255.255", parse("http://255.255.255.255/").host());
+    assertEquals("1.2.3.4", parse("http://1.2.3.4/").host());
+    assertEquals("0.0.0.0", parse("http://0.0.0.0/").host());
   }
 
   @Ignore("java.net.IDN strips trailing trailing dots on Java 7, but not on Java 8.")
   @Test public void hostWithTrailingDot() throws Exception {
-    assertEquals("host.", HttpUrl.parse("http://host./").host());
+    assertEquals("host.", parse("http://host./").host());
   }
 
   @Test public void port() throws Exception {
-    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host:80/"));
-    assertEquals(HttpUrl.parse("http://host:99/"), HttpUrl.parse("http://host:99/"));
-    assertEquals(HttpUrl.parse("http://host/"), HttpUrl.parse("http://host:/"));
-    assertEquals(65535, HttpUrl.parse("http://host:65535/").port());
-    assertEquals(null, HttpUrl.parse("http://host:0/"));
-    assertEquals(null, HttpUrl.parse("http://host:65536/"));
-    assertEquals(null, HttpUrl.parse("http://host:-1/"));
-    assertEquals(null, HttpUrl.parse("http://host:a/"));
-    assertEquals(null, HttpUrl.parse("http://host:%39%39/"));
+    assertEquals(parse("http://host/"), parse("http://host:80/"));
+    assertEquals(parse("http://host:99/"), parse("http://host:99/"));
+    assertEquals(parse("http://host/"), parse("http://host:/"));
+    assertEquals(65535, parse("http://host:65535/").port());
+    assertInvalid("http://host:0/", "Invalid URL port: \"0\"");
+    assertInvalid("http://host:65536/", "Invalid URL port: \"65536\"");
+    assertInvalid("http://host:-1/", "Invalid URL port: \"-1\"");
+    assertInvalid("http://host:a/", "Invalid URL port: \"a\"");
+    assertInvalid("http://host:%39%39/", "Invalid URL port: \"%39%39\"");
   }
 
   @Test public void pathCharacters() throws Exception {
@@ -548,6 +607,15 @@
         .test(Component.QUERY);
   }
 
+  @Test public void queryValueCharacters() throws Exception {
+    new UrlComponentEncodingTester()
+        .override(Encoding.IDENTITY, '?', '`')
+        .override(Encoding.PERCENT, '\'')
+        .override(Encoding.SKIP, '#', '+')
+        .skipForUri('%', '\\', '^', '`', '{', '|', '}')
+        .test(Component.QUERY_VALUE);
+  }
+
   @Test public void fragmentCharacters() throws Exception {
     new UrlComponentEncodingTester()
         .override(Encoding.IDENTITY, ' ', '"', '#', '<', '>', '?', '`')
@@ -557,7 +625,7 @@
   }
 
   @Test public void fragmentNonAscii() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/#Î£");
+    HttpUrl url = parse("http://host/#Î£");
     assertEquals("http://host/#Î£", url.toString());
     assertEquals("Î£", url.fragment());
     assertEquals("Î£", url.encodedFragment());
@@ -565,7 +633,7 @@
   }
 
   @Test public void fragmentNonAsciiThatOffendsJavaNetUri() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/#\u0080");
+    HttpUrl url = parse("http://host/#\u0080");
     assertEquals("http://host/#\u0080", url.toString());
     assertEquals("\u0080", url.fragment());
     assertEquals("\u0080", url.encodedFragment());
@@ -573,7 +641,7 @@
   }
 
   @Test public void fragmentPercentEncodedNonAscii() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/#%C2%80");
+    HttpUrl url = parse("http://host/#%C2%80");
     assertEquals("http://host/#%C2%80", url.toString());
     assertEquals("\u0080", url.fragment());
     assertEquals("%C2%80", url.encodedFragment());
@@ -581,7 +649,7 @@
   }
 
   @Test public void fragmentPercentEncodedPartialCodePoint() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/#%80");
+    HttpUrl url = parse("http://host/#%80");
     assertEquals("http://host/#%80", url.toString());
     assertEquals("\ufffd", url.fragment()); // Unicode replacement character.
     assertEquals("%80", url.encodedFragment());
@@ -589,106 +657,106 @@
   }
 
   @Test public void relativePath() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    assertEquals(HttpUrl.parse("http://host/a/b/d/e/f"), base.resolve("d/e/f"));
-    assertEquals(HttpUrl.parse("http://host/d/e/f"), base.resolve("../../d/e/f"));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve(".."));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../.."));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../.."));
-    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("."));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("././.."));
-    assertEquals(HttpUrl.parse("http://host/a/b/c/"), base.resolve("c/d/../e/../"));
-    assertEquals(HttpUrl.parse("http://host/a/b/..e/"), base.resolve("..e/"));
-    assertEquals(HttpUrl.parse("http://host/a/b/e/f../"), base.resolve("e/f../"));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2E."));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve(".%2E"));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2E%2E"));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2e."));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve(".%2e"));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("%2e%2e"));
-    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("%2E"));
-    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("%2e"));
+    HttpUrl base = parse("http://host/a/b/c");
+    assertEquals(parse("http://host/a/b/d/e/f"), base.resolve("d/e/f"));
+    assertEquals(parse("http://host/d/e/f"), base.resolve("../../d/e/f"));
+    assertEquals(parse("http://host/a/"), base.resolve(".."));
+    assertEquals(parse("http://host/"), base.resolve("../.."));
+    assertEquals(parse("http://host/"), base.resolve("../../.."));
+    assertEquals(parse("http://host/a/b/"), base.resolve("."));
+    assertEquals(parse("http://host/a/"), base.resolve("././.."));
+    assertEquals(parse("http://host/a/b/c/"), base.resolve("c/d/../e/../"));
+    assertEquals(parse("http://host/a/b/..e/"), base.resolve("..e/"));
+    assertEquals(parse("http://host/a/b/e/f../"), base.resolve("e/f../"));
+    assertEquals(parse("http://host/a/"), base.resolve("%2E."));
+    assertEquals(parse("http://host/a/"), base.resolve(".%2E"));
+    assertEquals(parse("http://host/a/"), base.resolve("%2E%2E"));
+    assertEquals(parse("http://host/a/"), base.resolve("%2e."));
+    assertEquals(parse("http://host/a/"), base.resolve(".%2e"));
+    assertEquals(parse("http://host/a/"), base.resolve("%2e%2e"));
+    assertEquals(parse("http://host/a/b/"), base.resolve("%2E"));
+    assertEquals(parse("http://host/a/b/"), base.resolve("%2e"));
   }
 
   @Test public void relativePathWithTrailingSlash() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c/");
-    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve(".."));
-    assertEquals(HttpUrl.parse("http://host/a/b/"), base.resolve("../"));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("../.."));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("../../"));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../.."));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../"));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../.."));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../../"));
-    assertEquals(HttpUrl.parse("http://host/a"), base.resolve("../../../../a"));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("../../../../a/.."));
-    assertEquals(HttpUrl.parse("http://host/a/"), base.resolve("../../../../a/b/.."));
+    HttpUrl base = parse("http://host/a/b/c/");
+    assertEquals(parse("http://host/a/b/"), base.resolve(".."));
+    assertEquals(parse("http://host/a/b/"), base.resolve("../"));
+    assertEquals(parse("http://host/a/"), base.resolve("../.."));
+    assertEquals(parse("http://host/a/"), base.resolve("../../"));
+    assertEquals(parse("http://host/"), base.resolve("../../.."));
+    assertEquals(parse("http://host/"), base.resolve("../../../"));
+    assertEquals(parse("http://host/"), base.resolve("../../../.."));
+    assertEquals(parse("http://host/"), base.resolve("../../../../"));
+    assertEquals(parse("http://host/a"), base.resolve("../../../../a"));
+    assertEquals(parse("http://host/"), base.resolve("../../../../a/.."));
+    assertEquals(parse("http://host/a/"), base.resolve("../../../../a/b/.."));
   }
 
   @Test public void pathWithBackslash() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    assertEquals(HttpUrl.parse("http://host/a/b/d/e/f"), base.resolve("d\\e\\f"));
-    assertEquals(HttpUrl.parse("http://host/d/e/f"), base.resolve("../..\\d\\e\\f"));
-    assertEquals(HttpUrl.parse("http://host/"), base.resolve("..\\.."));
+    HttpUrl base = parse("http://host/a/b/c");
+    assertEquals(parse("http://host/a/b/d/e/f"), base.resolve("d\\e\\f"));
+    assertEquals(parse("http://host/d/e/f"), base.resolve("../..\\d\\e\\f"));
+    assertEquals(parse("http://host/"), base.resolve("..\\.."));
   }
 
   @Test public void relativePathWithSameScheme() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
-    assertEquals(HttpUrl.parse("http://host/a/b/d/e/f"), base.resolve("http:d/e/f"));
-    assertEquals(HttpUrl.parse("http://host/d/e/f"), base.resolve("http:../../d/e/f"));
+    HttpUrl base = parse("http://host/a/b/c");
+    assertEquals(parse("http://host/a/b/d/e/f"), base.resolve("http:d/e/f"));
+    assertEquals(parse("http://host/d/e/f"), base.resolve("http:../../d/e/f"));
   }
 
   @Test public void decodeUsername() {
-    assertEquals("user", HttpUrl.parse("http://user@host/").username());
-    assertEquals("\uD83C\uDF69", HttpUrl.parse("http://%F0%9F%8D%A9@host/").username());
+    assertEquals("user", parse("http://user@host/").username());
+    assertEquals("\uD83C\uDF69", parse("http://%F0%9F%8D%A9@host/").username());
   }
 
   @Test public void decodePassword() {
-    assertEquals("password", HttpUrl.parse("http://user:password@host/").password());
-    assertEquals("", HttpUrl.parse("http://user:@host/").password());
-    assertEquals("\uD83C\uDF69", HttpUrl.parse("http://user:%F0%9F%8D%A9@host/").password());
+    assertEquals("password", parse("http://user:password@host/").password());
+    assertEquals("", parse("http://user:@host/").password());
+    assertEquals("\uD83C\uDF69", parse("http://user:%F0%9F%8D%A9@host/").password());
   }
 
   @Test public void decodeSlashCharacterInDecodedPathSegment() {
     assertEquals(Arrays.asList("a/b/c"),
-        HttpUrl.parse("http://host/a%2Fb%2Fc").pathSegments());
+        parse("http://host/a%2Fb%2Fc").pathSegments());
   }
 
   @Test public void decodeEmptyPathSegments() {
     assertEquals(Arrays.asList(""),
-        HttpUrl.parse("http://host/").pathSegments());
+        parse("http://host/").pathSegments());
   }
 
   @Test public void percentDecode() throws Exception {
     assertEquals(Arrays.asList("\u0000"),
-        HttpUrl.parse("http://host/%00").pathSegments());
+        parse("http://host/%00").pathSegments());
     assertEquals(Arrays.asList("a", "\u2603", "c"),
-        HttpUrl.parse("http://host/a/%E2%98%83/c").pathSegments());
+        parse("http://host/a/%E2%98%83/c").pathSegments());
     assertEquals(Arrays.asList("a", "\uD83C\uDF69", "c"),
-        HttpUrl.parse("http://host/a/%F0%9F%8D%A9/c").pathSegments());
+        parse("http://host/a/%F0%9F%8D%A9/c").pathSegments());
     assertEquals(Arrays.asList("a", "b", "c"),
-        HttpUrl.parse("http://host/a/%62/c").pathSegments());
+        parse("http://host/a/%62/c").pathSegments());
     assertEquals(Arrays.asList("a", "z", "c"),
-        HttpUrl.parse("http://host/a/%7A/c").pathSegments());
+        parse("http://host/a/%7A/c").pathSegments());
     assertEquals(Arrays.asList("a", "z", "c"),
-        HttpUrl.parse("http://host/a/%7a/c").pathSegments());
+        parse("http://host/a/%7a/c").pathSegments());
   }
 
   @Test public void malformedPercentEncoding() {
     assertEquals(Arrays.asList("a%f", "b"),
-        HttpUrl.parse("http://host/a%f/b").pathSegments());
+        parse("http://host/a%f/b").pathSegments());
     assertEquals(Arrays.asList("%", "b"),
-        HttpUrl.parse("http://host/%/b").pathSegments());
+        parse("http://host/%/b").pathSegments());
     assertEquals(Arrays.asList("%"),
-        HttpUrl.parse("http://host/%").pathSegments());
+        parse("http://host/%").pathSegments());
     assertEquals(Arrays.asList("%00"),
-        HttpUrl.parse("http://github.com/%%30%30").pathSegments());
+        parse("http://github.com/%%30%30").pathSegments());
   }
 
   @Test public void malformedUtf8Encoding() {
     // Replace a partial UTF-8 sequence with the Unicode replacement character.
     assertEquals(Arrays.asList("a", "\ufffdx", "c"),
-        HttpUrl.parse("http://host/a/%E2%98x/c").pathSegments());
+        parse("http://host/a/%E2%98x/c").pathSegments());
   }
 
   @Test public void incompleteUrlComposition() throws Exception {
@@ -742,17 +810,17 @@
   }
 
   @Test public void changingSchemeChangesDefaultPort() throws Exception {
-    assertEquals(443, HttpUrl.parse("http://example.com")
+    assertEquals(443, parse("http://example.com")
         .newBuilder()
         .scheme("https")
         .build().port());
 
-    assertEquals(80, HttpUrl.parse("https://example.com")
+    assertEquals(80, parse("https://example.com")
         .newBuilder()
         .scheme("http")
         .build().port());
 
-    assertEquals(1234, HttpUrl.parse("https://example.com:1234")
+    assertEquals(1234, parse("https://example.com:1234")
         .newBuilder()
         .scheme("http")
         .build().port());
@@ -855,7 +923,7 @@
   }
 
   @Test public void composeWithAddSegment() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/c/", base.newBuilder().addPathSegment("").build().encodedPath());
     assertEquals("/a/b/c/d",
         base.newBuilder().addPathSegment("").addPathSegment("d").build().encodedPath());
@@ -867,12 +935,12 @@
   }
 
   @Test public void pathSize() throws Exception {
-    assertEquals(1, HttpUrl.parse("http://host/").pathSize());
-    assertEquals(3, HttpUrl.parse("http://host/a/b/c").pathSize());
+    assertEquals(1, parse("http://host/").pathSize());
+    assertEquals(3, parse("http://host/a/b/c").pathSize());
   }
 
   @Test public void addPathSegments() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
 
     // Add a string with zero slashes: resulting URL gains one slash.
     assertEquals("/a/b/c/", base.newBuilder().addPathSegments("").build().encodedPath());
@@ -892,7 +960,7 @@
   }
 
   @Test public void addPathSegmentsOntoTrailingSlash() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c/");
+    HttpUrl base = parse("http://host/a/b/c/");
 
     // Add a string with zero slashes: resulting URL gains zero slashes.
     assertEquals("/a/b/c/", base.newBuilder().addPathSegments("").build().encodedPath());
@@ -912,30 +980,30 @@
   }
 
   @Test public void addPathSegmentsWithBackslash() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/");
+    HttpUrl base = parse("http://host/");
     assertEquals("/d/e", base.newBuilder().addPathSegments("d\\e").build().encodedPath());
     assertEquals("/d/e", base.newBuilder().addEncodedPathSegments("d\\e").build().encodedPath());
   }
 
   @Test public void addPathSegmentsWithEmptyPaths() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/c//d/e///f",
         base.newBuilder().addPathSegments("/d/e///f").build().encodedPath());
   }
 
   @Test public void addEncodedPathSegments() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/c/d/e/%20/",
         base.newBuilder().addEncodedPathSegments("d/e/%20/\n").build().encodedPath());
   }
 
   @Test public void addPathSegmentDotDoesNothing() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/c", base.newBuilder().addPathSegment(".").build().encodedPath());
   }
 
   @Test public void addPathSegmentEncodes() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/c/%252e",
         base.newBuilder().addPathSegment("%2e").build().encodedPath());
     assertEquals("/a/b/c/%252e%252e",
@@ -943,47 +1011,47 @@
   }
 
   @Test public void addPathSegmentDotDotPopsDirectory() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/", base.newBuilder().addPathSegment("..").build().encodedPath());
   }
 
   @Test public void addPathSegmentDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/c/.%0A", base.newBuilder().addPathSegment(".\n").build().encodedPath());
   }
 
   @Test public void addEncodedPathSegmentDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/c", base.newBuilder().addEncodedPathSegment(".\n").build().encodedPath());
   }
 
   @Test public void addEncodedPathSegmentDotDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/a/b/", base.newBuilder().addEncodedPathSegment("..\n").build().encodedPath());
   }
 
   @Test public void setPathSegment() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/d/b/c", base.newBuilder().setPathSegment(0, "d").build().encodedPath());
     assertEquals("/a/d/c", base.newBuilder().setPathSegment(1, "d").build().encodedPath());
     assertEquals("/a/b/d", base.newBuilder().setPathSegment(2, "d").build().encodedPath());
   }
 
   @Test public void setPathSegmentEncodes() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/%2525/b/c", base.newBuilder().setPathSegment(0, "%25").build().encodedPath());
     assertEquals("/.%0A/b/c", base.newBuilder().setPathSegment(0, ".\n").build().encodedPath());
     assertEquals("/%252e/b/c", base.newBuilder().setPathSegment(0, "%2e").build().encodedPath());
   }
 
   @Test public void setPathSegmentAcceptsEmpty() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("//b/c", base.newBuilder().setPathSegment(0, "").build().encodedPath());
     assertEquals("/a/b/", base.newBuilder().setPathSegment(2, "").build().encodedPath());
   }
 
   @Test public void setPathSegmentRejectsDot() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     try {
       base.newBuilder().setPathSegment(0, ".");
       fail();
@@ -992,7 +1060,7 @@
   }
 
   @Test public void setPathSegmentRejectsDotDot() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     try {
       base.newBuilder().setPathSegment(0, "..");
       fail();
@@ -1001,7 +1069,7 @@
   }
 
   @Test public void setPathSegmentWithSlash() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     HttpUrl url = base.newBuilder().setPathSegment(1, "/").build();
     assertEquals("/a/%2F/c", url.encodedPath());
   }
@@ -1015,13 +1083,13 @@
   }
 
   @Test public void setEncodedPathSegmentEncodes() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     assertEquals("/%25/b/c",
         base.newBuilder().setEncodedPathSegment(0, "%25").build().encodedPath());
   }
 
   @Test public void setEncodedPathSegmentRejectsDot() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     try {
       base.newBuilder().setEncodedPathSegment(0, ".");
       fail();
@@ -1030,7 +1098,7 @@
   }
 
   @Test public void setEncodedPathSegmentRejectsDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     try {
       base.newBuilder().setEncodedPathSegment(0, ".\n");
       fail();
@@ -1039,7 +1107,7 @@
   }
 
   @Test public void setEncodedPathSegmentRejectsDotDot() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     try {
       base.newBuilder().setEncodedPathSegment(0, "..");
       fail();
@@ -1048,7 +1116,7 @@
   }
 
   @Test public void setEncodedPathSegmentRejectsDotDotAndIgnoredCharacter() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     try {
       base.newBuilder().setEncodedPathSegment(0, "..\n");
       fail();
@@ -1057,7 +1125,7 @@
   }
 
   @Test public void setEncodedPathSegmentWithSlash() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     HttpUrl url = base.newBuilder().setEncodedPathSegment(1, "/").build();
     assertEquals("/a/%2F/c", url.encodedPath());
   }
@@ -1071,7 +1139,7 @@
   }
 
   @Test public void removePathSegment() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     HttpUrl url = base.newBuilder()
         .removePathSegment(0)
         .build();
@@ -1079,7 +1147,7 @@
   }
 
   @Test public void removePathSegmentDoesntRemovePath() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/a/b/c");
+    HttpUrl base = parse("http://host/a/b/c");
     HttpUrl url = base.newBuilder()
         .removePathSegment(0)
         .removePathSegment(0)
@@ -1098,19 +1166,19 @@
   }
 
   @Test public void toJavaNetUrl() throws Exception {
-    HttpUrl httpUrl = HttpUrl.parse("http://username:password@host/path?query#fragment");
+    HttpUrl httpUrl = parse("http://username:password@host/path?query#fragment");
     URL javaNetUrl = httpUrl.url();
     assertEquals("http://username:password@host/path?query#fragment", javaNetUrl.toString());
   }
 
   @Test public void toUri() throws Exception {
-    HttpUrl httpUrl = HttpUrl.parse("http://username:password@host/path?query#fragment");
+    HttpUrl httpUrl = parse("http://username:password@host/path?query#fragment");
     URI uri = httpUrl.uri();
     assertEquals("http://username:password@host/path?query#fragment", uri.toString());
   }
 
   @Test public void toUriSpecialQueryCharacters() throws Exception {
-    HttpUrl httpUrl = HttpUrl.parse("http://host/?d=abc!@[]^`{}|\\");
+    HttpUrl httpUrl = parse("http://host/?d=abc!@[]^`{}|\\");
     URI uri = httpUrl.uri();
     assertEquals("http://host/?d=abc!@[]%5E%60%7B%7D%7C%5C", uri.toString());
   }
@@ -1163,8 +1231,11 @@
         .host("host")
         .addQueryParameter("=[]:;\"~|?#@^/$%*", "a")
         .build();
-    assertEquals("http://host/?%3D[]:;%22~|?%23@^/$%25*=a", url.toString());
-    assertEquals("http://host/?%3D[]:;%22~%7C?%23@%5E/$%25*=a", url.uri().toString());
+    assertEquals("http://host/?%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*=a",
+        url.toString());
+    assertEquals("http://host/?%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*=a",
+        url.uri().toString());
+    assertEquals("a", url.queryParameter("=[]:;\"~|?#@^/$%*"));
   }
 
   @Test public void toUriQueryParameterValueSpecialCharacters() throws Exception {
@@ -1173,8 +1244,11 @@
         .host("host")
         .addQueryParameter("a", "=[]:;\"~|?#@^/$%*")
         .build();
-    assertEquals("http://host/?a=%3D[]:;%22~|?%23@^/$%25*", url.toString());
-    assertEquals("http://host/?a=%3D[]:;%22~%7C?%23@%5E/$%25*", url.uri().toString());
+    assertEquals("http://host/?a=%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*",
+        url.toString());
+    assertEquals("http://host/?a=%3D%5B%5D%3A%3B%22%7E%7C%3F%23%40%5E%2F%24%25*",
+        url.uri().toString());
+    assertEquals("=[]:;\"~|?#@^/$%*", url.queryParameter("a"));
   }
 
   @Test public void toUriQueryValueSpecialCharacters() throws Exception {
@@ -1187,6 +1261,42 @@
     assertEquals("http://host/?=[]:;%22~%7C?%23@%5E/$%25*", url.uri().toString());
   }
 
+  @Test public void queryCharactersEncodedWhenComposed() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .addQueryParameter("a", "!$(),/:;?@[]\\^`{|}~")
+        .build();
+    assertEquals("http://host/?a=%21%24%28%29%2C%2F%3A%3B%3F%40%5B%5D%5C%5E%60%7B%7C%7D%7E",
+        url.toString());
+    assertEquals("!$(),/:;?@[]\\^`{|}~", url.queryParameter("a"));
+  }
+
+  /**
+   * When callers use {@code addEncodedQueryParameter()} we only encode what's strictly required.
+   * We retain the encoded (or non-encoded) state of the input.
+   */
+  @Test public void queryCharactersNotReencodedWhenComposedWithAddEncoded() throws Exception {
+    HttpUrl url = new HttpUrl.Builder()
+        .scheme("http")
+        .host("host")
+        .addEncodedQueryParameter("a", "!$(),/:;?@[]\\^`{|}~")
+        .build();
+    assertEquals("http://host/?a=!$(),/:;?@[]\\^`{|}~",
+        url.toString());
+    assertEquals("!$(),/:;?@[]\\^`{|}~", url.queryParameter("a"));
+  }
+
+  /**
+   * When callers parse a URL with query components that aren't encoded, we shouldn't convert them
+   * into a canonical form because doing so could be semantically different.
+   */
+  @Test public void queryCharactersNotReencodedWhenParsed() throws Exception {
+    HttpUrl url = parse("http://host/?a=!$(),/:;?@[]\\^`{|}~");
+    assertEquals("http://host/?a=!$(),/:;?@[]\\^`{|}~", url.toString());
+    assertEquals("!$(),/:;?@[]\\^`{|}~", url.queryParameter("a"));
+  }
+
   @Test public void toUriFragmentSpecialCharacters() throws Exception {
     HttpUrl url = new HttpUrl.Builder()
         .scheme("http")
@@ -1199,44 +1309,44 @@
 
   @Test public void toUriWithControlCharacters() throws Exception {
     // Percent-encoded in the path.
-    assertEquals(new URI("http://host/a%00b"), HttpUrl.parse("http://host/a\u0000b").uri());
-    assertEquals(new URI("http://host/a%C2%80b"), HttpUrl.parse("http://host/a\u0080b").uri());
-    assertEquals(new URI("http://host/a%C2%9Fb"), HttpUrl.parse("http://host/a\u009fb").uri());
+    assertEquals(new URI("http://host/a%00b"), parse("http://host/a\u0000b").uri());
+    assertEquals(new URI("http://host/a%C2%80b"), parse("http://host/a\u0080b").uri());
+    assertEquals(new URI("http://host/a%C2%9Fb"), parse("http://host/a\u009fb").uri());
     // Percent-encoded in the query.
-    assertEquals(new URI("http://host/?a%00b"), HttpUrl.parse("http://host/?a\u0000b").uri());
-    assertEquals(new URI("http://host/?a%C2%80b"), HttpUrl.parse("http://host/?a\u0080b").uri());
-    assertEquals(new URI("http://host/?a%C2%9Fb"), HttpUrl.parse("http://host/?a\u009fb").uri());
+    assertEquals(new URI("http://host/?a%00b"), parse("http://host/?a\u0000b").uri());
+    assertEquals(new URI("http://host/?a%C2%80b"), parse("http://host/?a\u0080b").uri());
+    assertEquals(new URI("http://host/?a%C2%9Fb"), parse("http://host/?a\u009fb").uri());
     // Stripped from the fragment.
-    assertEquals(new URI("http://host/#a%00b"), HttpUrl.parse("http://host/#a\u0000b").uri());
-    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u0080b").uri());
-    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u009fb").uri());
+    assertEquals(new URI("http://host/#a%00b"), parse("http://host/#a\u0000b").uri());
+    assertEquals(new URI("http://host/#ab"), parse("http://host/#a\u0080b").uri());
+    assertEquals(new URI("http://host/#ab"), parse("http://host/#a\u009fb").uri());
   }
 
   @Test public void toUriWithSpaceCharacters() throws Exception {
     // Percent-encoded in the path.
-    assertEquals(new URI("http://host/a%0Bb"), HttpUrl.parse("http://host/a\u000bb").uri());
-    assertEquals(new URI("http://host/a%20b"), HttpUrl.parse("http://host/a b").uri());
-    assertEquals(new URI("http://host/a%E2%80%89b"), HttpUrl.parse("http://host/a\u2009b").uri());
-    assertEquals(new URI("http://host/a%E3%80%80b"), HttpUrl.parse("http://host/a\u3000b").uri());
+    assertEquals(new URI("http://host/a%0Bb"), parse("http://host/a\u000bb").uri());
+    assertEquals(new URI("http://host/a%20b"), parse("http://host/a b").uri());
+    assertEquals(new URI("http://host/a%E2%80%89b"), parse("http://host/a\u2009b").uri());
+    assertEquals(new URI("http://host/a%E3%80%80b"), parse("http://host/a\u3000b").uri());
     // Percent-encoded in the query.
-    assertEquals(new URI("http://host/?a%0Bb"), HttpUrl.parse("http://host/?a\u000bb").uri());
-    assertEquals(new URI("http://host/?a%20b"), HttpUrl.parse("http://host/?a b").uri());
-    assertEquals(new URI("http://host/?a%E2%80%89b"), HttpUrl.parse("http://host/?a\u2009b").uri());
-    assertEquals(new URI("http://host/?a%E3%80%80b"), HttpUrl.parse("http://host/?a\u3000b").uri());
+    assertEquals(new URI("http://host/?a%0Bb"), parse("http://host/?a\u000bb").uri());
+    assertEquals(new URI("http://host/?a%20b"), parse("http://host/?a b").uri());
+    assertEquals(new URI("http://host/?a%E2%80%89b"), parse("http://host/?a\u2009b").uri());
+    assertEquals(new URI("http://host/?a%E3%80%80b"), parse("http://host/?a\u3000b").uri());
     // Stripped from the fragment.
-    assertEquals(new URI("http://host/#a%0Bb"), HttpUrl.parse("http://host/#a\u000bb").uri());
-    assertEquals(new URI("http://host/#a%20b"), HttpUrl.parse("http://host/#a b").uri());
-    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u2009b").uri());
-    assertEquals(new URI("http://host/#ab"), HttpUrl.parse("http://host/#a\u3000b").uri());
+    assertEquals(new URI("http://host/#a%0Bb"), parse("http://host/#a\u000bb").uri());
+    assertEquals(new URI("http://host/#a%20b"), parse("http://host/#a b").uri());
+    assertEquals(new URI("http://host/#ab"), parse("http://host/#a\u2009b").uri());
+    assertEquals(new URI("http://host/#ab"), parse("http://host/#a\u3000b").uri());
   }
 
   @Test public void toUriWithNonHexPercentEscape() throws Exception {
-    assertEquals(new URI("http://host/%25xx"), HttpUrl.parse("http://host/%xx").uri());
+    assertEquals(new URI("http://host/%25xx"), parse("http://host/%xx").uri());
   }
 
   @Test public void toUriWithTruncatedPercentEscape() throws Exception {
-    assertEquals(new URI("http://host/%25a"), HttpUrl.parse("http://host/%a").uri());
-    assertEquals(new URI("http://host/%25"), HttpUrl.parse("http://host/%").uri());
+    assertEquals(new URI("http://host/%25a"), parse("http://host/%a").uri());
+    assertEquals(new URI("http://host/%25"), parse("http://host/%").uri());
   }
 
   @Test public void fromJavaNetUrl() throws Exception {
@@ -1266,29 +1376,8 @@
     assertEquals(null, HttpUrl.get(uri));
   }
 
-  @Test public void fromJavaNetUrl_checked() throws Exception {
-    HttpUrl httpUrl = HttpUrl.getChecked("http://username:password@host/path?query#fragment");
-    assertEquals("http://username:password@host/path?query#fragment", httpUrl.toString());
-  }
-
-  @Test public void fromJavaNetUrlUnsupportedScheme_checked() throws Exception {
-    try {
-      HttpUrl.getChecked("mailto:user@example.com");
-      fail();
-    } catch (MalformedURLException e) {
-    }
-  }
-
-  @Test public void fromJavaNetUrlBadHost_checked() throws Exception {
-    try {
-      HttpUrl.getChecked("http://hostw ithspace/");
-      fail();
-    } catch (UnknownHostException expected) {
-    }
-  }
-
   @Test public void composeQueryWithComponents() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/");
+    HttpUrl base = parse("http://host/");
     HttpUrl url = base.newBuilder().addQueryParameter("a+=& b", "c+=& d").build();
     assertEquals("http://host/?a%2B%3D%26%20b=c%2B%3D%26%20d", url.toString());
     assertEquals("c+=& d", url.queryParameterValue(0));
@@ -1302,14 +1391,14 @@
   }
 
   @Test public void composeQueryWithEncodedComponents() throws Exception {
-    HttpUrl base = HttpUrl.parse("http://host/");
+    HttpUrl base = parse("http://host/");
     HttpUrl url = base.newBuilder().addEncodedQueryParameter("a+=& b", "c+=& d").build();
     assertEquals("http://host/?a+%3D%26%20b=c+%3D%26%20d", url.toString());
     assertEquals("c =& d", url.queryParameter("a =& b"));
   }
 
   @Test public void composeQueryRemoveQueryParameter() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .addQueryParameter("a+=& b", "c+=& d")
         .removeAllQueryParameters("a+=& b")
         .build();
@@ -1318,7 +1407,7 @@
   }
 
   @Test public void composeQueryRemoveEncodedQueryParameter() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .addEncodedQueryParameter("a+=& b", "c+=& d")
         .removeAllEncodedQueryParameters("a+=& b")
         .build();
@@ -1327,7 +1416,7 @@
   }
 
   @Test public void composeQuerySetQueryParameter() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .addQueryParameter("a+=& b", "c+=& d")
         .setQueryParameter("a+=& b", "ef")
         .build();
@@ -1336,7 +1425,7 @@
   }
 
   @Test public void composeQuerySetEncodedQueryParameter() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .addEncodedQueryParameter("a+=& b", "c+=& d")
         .setEncodedQueryParameter("a+=& b", "ef")
         .build();
@@ -1345,7 +1434,7 @@
   }
 
   @Test public void composeQueryMultipleEncodedValuesForParameter() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .addQueryParameter("a+=& b", "c+=& d")
         .addQueryParameter("a+=& b", "e+=& f")
         .build();
@@ -1357,14 +1446,14 @@
   }
 
   @Test public void absentQueryIsZeroNameValuePairs() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .query(null)
         .build();
     assertEquals(0, url.querySize());
   }
 
   @Test public void emptyQueryIsSingleNameValuePairWithEmptyKey() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .query("")
         .build();
     assertEquals(1, url.querySize());
@@ -1373,7 +1462,7 @@
   }
 
   @Test public void ampersandQueryIsTwoNameValuePairsWithEmptyKeys() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .query("&")
         .build();
     assertEquals(2, url.querySize());
@@ -1384,7 +1473,7 @@
   }
 
   @Test public void removeAllDoesNotRemoveQueryIfNoParametersWereRemoved() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/").newBuilder()
+    HttpUrl url = parse("http://host/").newBuilder()
         .query("")
         .removeAllQueryParameters("a")
         .build();
@@ -1392,7 +1481,7 @@
   }
 
   @Test public void queryParametersWithoutValues() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/?foo&bar&baz");
+    HttpUrl url = parse("http://host/?foo&bar&baz");
     assertEquals(3, url.querySize());
     assertEquals(new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")),
         url.queryParameterNames());
@@ -1405,7 +1494,7 @@
   }
 
   @Test public void queryParametersWithEmptyValues() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/?foo=&bar=&baz=");
+    HttpUrl url = parse("http://host/?foo=&bar=&baz=");
     assertEquals(3, url.querySize());
     assertEquals(new LinkedHashSet<>(Arrays.asList("foo", "bar", "baz")),
         url.queryParameterNames());
@@ -1418,7 +1507,7 @@
   }
 
   @Test public void queryParametersWithRepeatedName() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/?foo[]=1&foo[]=2&foo[]=3");
+    HttpUrl url = parse("http://host/?foo[]=1&foo[]=2&foo[]=3");
     assertEquals(3, url.querySize());
     assertEquals(Collections.singleton("foo[]"), url.queryParameterNames());
     assertEquals("1", url.queryParameterValue(0));
@@ -1428,13 +1517,20 @@
   }
 
   @Test public void queryParameterLookupWithNonCanonicalEncoding() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/?%6d=m&+=%20");
+    HttpUrl url = parse("http://host/?%6d=m&+=%20");
     assertEquals("m", url.queryParameterName(0));
     assertEquals(" ", url.queryParameterName(1));
     assertEquals("m", url.queryParameter("m"));
     assertEquals(" ", url.queryParameter(" "));
   }
 
+  @Test public void parsedQueryDoesntIncludeFragment() {
+    HttpUrl url = parse("http://host/?#fragment");
+    assertEquals("fragment", url.fragment());
+    assertEquals("", url.query());
+    assertEquals("", url.encodedQuery());
+  }
+
   @Test public void roundTripBuilder() throws Exception {
     HttpUrl url = new HttpUrl.Builder()
         .scheme("http")
@@ -1456,7 +1552,7 @@
    */
   @Test public void rawEncodingRetained() throws Exception {
     String urlString = "http://%6d%6D:%6d%6D@host/%6d%6D?%6d%6D#%6d%6D";
-    HttpUrl url = HttpUrl.parse(urlString);
+    HttpUrl url = parse(urlString);
     assertEquals("%6d%6D", url.encodedUsername());
     assertEquals("%6d%6D", url.encodedPassword());
     assertEquals("/%6d%6D", url.encodedPath());
@@ -1469,7 +1565,7 @@
   }
 
   @Test public void clearFragment() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/#fragment")
+    HttpUrl url = parse("http://host/#fragment")
         .newBuilder()
         .fragment(null)
         .build();
@@ -1479,7 +1575,7 @@
   }
 
   @Test public void clearEncodedFragment() throws Exception {
-    HttpUrl url = HttpUrl.parse("http://host/#fragment")
+    HttpUrl url = parse("http://host/#fragment")
         .newBuilder()
         .encodedFragment(null)
         .build();
@@ -1487,4 +1583,32 @@
     assertEquals(null, url.fragment());
     assertEquals(null, url.encodedFragment());
   }
+
+  @Test public void topPrivateDomain() {
+    assertEquals("google.com", parse("https://google.com").topPrivateDomain());
+    assertEquals("google.co.uk", parse("https://adwords.google.co.uk").topPrivateDomain());
+    assertEquals("xn--ewv.xn--4pvxs.jp", parse("https://æ ƒ.æ ƒæœ¨.jp").topPrivateDomain());
+    assertEquals("xn--ewv.xn--4pvxs.jp",
+        parse("https://xn--ewv.xn--4pvxs.jp").topPrivateDomain());
+
+    assertNull(parse("https://co.uk").topPrivateDomain());
+    assertNull(parse("https://square").topPrivateDomain());
+    assertNull(parse("https://æ ƒæœ¨.jp").topPrivateDomain());
+    assertNull(parse("https://xn--4pvxs.jp").topPrivateDomain());
+    assertNull(parse("https://localhost").topPrivateDomain());
+    assertNull(parse("https://127.0.0.1").topPrivateDomain());
+  }
+
+  private void assertInvalid(String string, String exceptionMessage) {
+    if (useGet) {
+      try {
+        parse(string);
+        fail("Expected get of \"" + string + "\" to throw with: " + exceptionMessage);
+      } catch (IllegalArgumentException e) {
+        assertEquals(exceptionMessage, e.getMessage());
+      }
+    } else {
+      assertNull(string, parse(string));
+    }
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
index dd72d07f74..a1ad679f34 100644
--- a/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/InterceptorTest.java
@@ -16,6 +16,7 @@
 package okhttp3;
 
 import java.io.IOException;
+import java.net.SocketTimeoutException;
 import java.util.Arrays;
 import java.util.Locale;
 import java.util.concurrent.BlockingQueue;
@@ -23,6 +24,7 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
@@ -40,9 +42,11 @@
 
 import static okhttp3.TestUtil.defaultClient;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class InterceptorTest {
@@ -63,7 +67,7 @@
         .protocol(Protocol.HTTP_1_1)
         .code(200)
         .message("Intercepted!")
-        .body(ResponseBody.create(MediaType.parse("text/plain; charset=utf-8"), "abc"))
+        .body(ResponseBody.create(MediaType.get("text/plain; charset=utf-8"), "abc"))
         .build();
 
     client = client.newBuilder()
@@ -87,7 +91,7 @@
             .protocol(Protocol.HTTP_1_1)
             .code(200)
             .message("Intercepted!")
-            .body(ResponseBody.create(MediaType.parse("text/plain; charset=utf-8"), "abc"))
+            .body(ResponseBody.create(MediaType.get("text/plain; charset=utf-8"), "abc"))
             .build();
       }
     };
@@ -144,7 +148,7 @@
         String sameHost = address.url().host();
         int differentPort = address.url().port() + 1;
         return chain.proceed(chain.request().newBuilder()
-            .url(HttpUrl.parse("http://" + sameHost + ":" + differentPort + "/"))
+            .url("http://" + sameHost + ":" + differentPort + "/")
             .build());
       }
     };
@@ -230,7 +234,7 @@
     Interceptor interceptor = new Interceptor() {
       @Override public Response intercept(Chain chain) throws IOException {
         Request originalRequest = chain.request();
-        MediaType mediaType = MediaType.parse("text/plain");
+        MediaType mediaType = MediaType.get("text/plain");
         RequestBody body = RequestBody.create(mediaType, "abc");
         return chain.proceed(originalRequest.newBuilder()
             .method("POST", body)
@@ -279,7 +283,7 @@ private void rewriteRequestToServer(boolean network) throws Exception {
     Request request = new Request.Builder()
         .url(server.url("/"))
         .addHeader("Original-Header", "foo")
-        .method("PUT", RequestBody.create(MediaType.parse("text/plain"), "abc"))
+        .method("PUT", RequestBody.create(MediaType.get("text/plain"), "abc"))
         .build();
 
     client.newCall(request).execute();
@@ -655,6 +659,210 @@ private void interceptorThrowsRuntimeExceptionAsynchronous(boolean network) thro
     response.body().close();
   }
 
+  @Test public void applicationInterceptorResponseMustHaveBody() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        return chain.proceed(chain.request()).newBuilder().body(null).build();
+      }
+    };
+    client = client.newBuilder()
+        .addInterceptor(interceptor)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("interceptor " + interceptor + " returned a response with no body",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void networkInterceptorResponseMustHaveBody() throws Exception {
+    server.enqueue(new MockResponse());
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        return chain.proceed(chain.request()).newBuilder().body(null).build();
+      }
+    };
+    client = client.newBuilder()
+        .addNetworkInterceptor(interceptor)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    try {
+      client.newCall(request).execute();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("interceptor " + interceptor + " returned a response with no body",
+          expected.getMessage());
+    }
+  }
+
+  @Test public void connectTimeout() throws Exception {
+    Interceptor interceptor1 = new Interceptor() {
+      @Override public Response intercept(Chain chainA) throws IOException {
+        assertEquals(5000, chainA.connectTimeoutMillis());
+
+        Chain chainB = chainA.withConnectTimeout(100, TimeUnit.MILLISECONDS);
+        assertEquals(100, chainB.connectTimeoutMillis());
+
+        return chainB.proceed(chainA.request());
+      }
+    };
+
+    Interceptor interceptor2 = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        assertEquals(100, chain.connectTimeoutMillis());
+        return chain.proceed(chain.request());
+      }
+    };
+
+    client = client.newBuilder()
+        .connectTimeout(5, TimeUnit.SECONDS)
+        .addInterceptor(interceptor1)
+        .addInterceptor(interceptor2)
+        .build();
+
+    Request request1 = new Request.Builder()
+        .url("http://" + TestUtil.UNREACHABLE_ADDRESS)
+        .build();
+    Call call = client.newCall(request1);
+
+    try {
+      call.execute();
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+  }
+
+  @Test public void chainWithReadTimeout() throws Exception {
+    Interceptor interceptor1 = new Interceptor() {
+      @Override public Response intercept(Chain chainA) throws IOException {
+        assertEquals(5000, chainA.readTimeoutMillis());
+
+        Chain chainB = chainA.withReadTimeout(100, TimeUnit.MILLISECONDS);
+        assertEquals(100, chainB.readTimeoutMillis());
+
+        return chainB.proceed(chainA.request());
+      }
+    };
+
+    Interceptor interceptor2 = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        assertEquals(100, chain.readTimeoutMillis());
+        return chain.proceed(chain.request());
+      }
+    };
+
+    client = client.newBuilder()
+        .readTimeout(5, TimeUnit.SECONDS)
+        .addInterceptor(interceptor1)
+        .addInterceptor(interceptor2)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .throttleBody(1, 1, TimeUnit.SECONDS));
+
+    Request request1 = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Call call = client.newCall(request1);
+    Response response = call.execute();
+    ResponseBody body = response.body();
+    try {
+      body.string();
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+  }
+
+  @Test public void chainWithWriteTimeout() throws Exception {
+    Interceptor interceptor1 = new Interceptor() {
+      @Override public Response intercept(Chain chainA) throws IOException {
+        assertEquals(5000, chainA.writeTimeoutMillis());
+
+        Chain chainB = chainA.withWriteTimeout(100, TimeUnit.MILLISECONDS);
+        assertEquals(100, chainB.writeTimeoutMillis());
+
+        return chainB.proceed(chainA.request());
+      }
+    };
+
+    Interceptor interceptor2 = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        assertEquals(100, chain.writeTimeoutMillis());
+        return chain.proceed(chain.request());
+      }
+    };
+
+    client = client.newBuilder()
+        .writeTimeout(5, TimeUnit.SECONDS)
+        .addInterceptor(interceptor1)
+        .addInterceptor(interceptor2)
+        .build();
+
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .throttleBody(1, 1, TimeUnit.SECONDS));
+
+    byte[] data = new byte[2 * 1024 * 1024]; // 2 MiB.
+    Request request1 = new Request.Builder()
+        .url(server.url("/"))
+        .post(RequestBody.create(MediaType.get("text/plain"), data))
+        .build();
+    Call call = client.newCall(request1);
+
+    try {
+      call.execute(); // we want this call to throw a SocketTimeoutException
+      fail();
+    } catch (SocketTimeoutException expected) {
+    }
+  }
+
+  @Test public void chainCanCancelCall() throws Exception {
+    final AtomicReference<Call> callRef = new AtomicReference<>();
+
+    Interceptor interceptor = new Interceptor() {
+      @Override public Response intercept(Chain chain) throws IOException {
+        Call call = chain.call();
+        callRef.set(call);
+
+        assertFalse(call.isCanceled());
+        call.cancel();
+        assertTrue(call.isCanceled());
+
+        return chain.proceed(chain.request());
+      }
+    };
+
+    client = client.newBuilder()
+        .addInterceptor(interceptor)
+        .build();
+
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    Call call = client.newCall(request);
+
+    try {
+      call.execute();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    assertSame(call, callRef.get());
+  }
+
   private RequestBody uppercase(final RequestBody original) {
     return new RequestBody() {
       @Override public MediaType contentType() {
@@ -736,7 +944,7 @@ public ExceptionCatchingExecutor() {
       });
     }
 
-    public Exception takeException() throws InterruptedException {
+    public Exception takeException() throws Exception {
       return exceptions.take();
     }
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java b/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
index 5e4a14f484..f0b194713d 100644
--- a/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/MediaTypeTest.java
@@ -17,10 +17,12 @@
 package okhttp3;
 
 import java.nio.charset.Charset;
-import java.nio.charset.IllegalCharsetNameException;
-import java.nio.charset.UnsupportedCharsetException;
+import java.util.Arrays;
+import java.util.Collection;
 import okhttp3.internal.Util;
 import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
@@ -33,16 +35,34 @@
  * <p>This test includes tests from <a href="https://code.google.com/p/guava-libraries/">Guava's</a>
  * MediaTypeTest.
  */
+@RunWith(Parameterized.class)
 public class MediaTypeTest {
+  @Parameterized.Parameters(name = "Use get = {0}")
+  public static Collection<Object[]> parameters() {
+    return Arrays.asList(
+        new Object[] { true },
+        new Object[] { false }
+    );
+  }
+
+  @Parameterized.Parameter
+  public boolean useGet;
+
+  private MediaType parse(String string) {
+    return useGet
+        ? MediaType.get(string)
+        : MediaType.parse(string);
+  }
+
   @Test public void testParse() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;boundary=foo;charset=utf-8");
+    MediaType mediaType = parse("text/plain;boundary=foo;charset=utf-8");
     assertEquals("text", mediaType.type());
     assertEquals("plain", mediaType.subtype());
     assertEquals("UTF-8", mediaType.charset().name());
     assertEquals("text/plain;boundary=foo;charset=utf-8", mediaType.toString());
-    assertTrue(mediaType.equals(MediaType.parse("text/plain;boundary=foo;charset=utf-8")));
+    assertTrue(mediaType.equals(parse("text/plain;boundary=foo;charset=utf-8")));
     assertEquals(mediaType.hashCode(),
-        MediaType.parse("text/plain;boundary=foo;charset=utf-8").hashCode());
+        parse("text/plain;boundary=foo;charset=utf-8").hashCode());
   }
 
   @Test public void testValidParse() throws Exception {
@@ -64,88 +84,87 @@
   }
 
   @Test public void testInvalidParse() throws Exception {
-    assertInvalid("");
-    assertInvalid("/");
-    assertInvalid("/");
-    assertInvalid("text");
-    assertInvalid("text/");
-    assertInvalid("te<t/plain");
-    assertInvalid("text/pl@in");
-    assertInvalid("text/plain; a");
-    assertInvalid("text/plain; a=");
-    assertInvalid("text/plain; a=@");
-    assertInvalid("text/plain; a=\"@");
-    assertInvalid("text/plain; a=1; b");
-    assertInvalid("text/plain; a=1; b=");
-    assertInvalid("text/plain; a=\u2025");
-    assertInvalid(" text/plain");
-    assertInvalid("te xt/plain");
-    assertInvalid("text /plain");
-    assertInvalid("text/ plain");
-    assertInvalid("text/pl ain");
-    assertInvalid("text/plain ");
-    assertInvalid("text/plain ; a=1");
+    assertInvalid("", "No subtype found for: \"\"");
+    assertInvalid("/", "No subtype found for: \"/\"");
+    assertInvalid("text", "No subtype found for: \"text\"");
+    assertInvalid("text/", "No subtype found for: \"text/\"");
+    assertInvalid("te<t/plain", "No subtype found for: \"te<t/plain\"");
+    assertInvalid(" text/plain", "No subtype found for: \" text/plain\"");
+    assertInvalid("te xt/plain", "No subtype found for: \"te xt/plain\"");
+    assertInvalid("text /plain", "No subtype found for: \"text /plain\"");
+    assertInvalid("text/ plain", "No subtype found for: \"text/ plain\"");
+
+    assertInvalid("text/pl@in",
+        "Parameter is not formatted correctly: \"@in\" for: \"text/pl@in\"");
+    assertInvalid("text/plain; a",
+        "Parameter is not formatted correctly: \"a\" for: \"text/plain; a\"");
+    assertInvalid("text/plain; a=",
+        "Parameter is not formatted correctly: \"a=\" for: \"text/plain; a=\"");
+    assertInvalid("text/plain; a=@",
+        "Parameter is not formatted correctly: \"a=@\" for: \"text/plain; a=@\"");
+    assertInvalid("text/plain; a=\"@",
+        "Parameter is not formatted correctly: \"a=\"@\" for: \"text/plain; a=\"@\"");
+    assertInvalid("text/plain; a=1; b",
+        "Parameter is not formatted correctly: \"b\" for: \"text/plain; a=1; b\"");
+    assertInvalid("text/plain; a=1; b=",
+        "Parameter is not formatted correctly: \"b=\" for: \"text/plain; a=1; b=\"");
+    assertInvalid("text/plain; a=\u2025",
+        "Parameter is not formatted correctly: \"a=â€¥\" for: \"text/plain; a=â€¥\"");
+    assertInvalid("text/pl ain",
+        "Parameter is not formatted correctly: \" ain\" for: \"text/pl ain\"");
+    assertInvalid("text/plain ",
+        "Parameter is not formatted correctly: \" \" for: \"text/plain \"");
+    assertInvalid("text/plain ; a=1",
+        "Parameter is not formatted correctly: \" ; a=1\" for: \"text/plain ; a=1\"");
   }
 
   @Test public void testDoubleQuotesAreSpecial() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;a=\";charset=utf-8;b=\"");
+    MediaType mediaType = parse("text/plain;a=\";charset=utf-8;b=\"");
     assertNull(mediaType.charset());
   }
 
   @Test public void testSingleQuotesAreNotSpecial() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;a=';charset=utf-8;b='");
+    MediaType mediaType = parse("text/plain;a=';charset=utf-8;b='");
     assertEquals("UTF-8", mediaType.charset().name());
   }
 
   @Test public void testParseWithSpecialCharacters() throws Exception {
-    MediaType mediaType = MediaType.parse(
-        "!#$%&'*+-.{|}~/!#$%&'*+-.{|}~; !#$%&'*+-.{|}~=!#$%&'*+-.{|}~");
+    MediaType mediaType = parse("!#$%&'*+-.{|}~/!#$%&'*+-.{|}~; !#$%&'*+-.{|}~=!#$%&'*+-.{|}~");
     assertEquals("!#$%&'*+-.{|}~", mediaType.type());
     assertEquals("!#$%&'*+-.{|}~", mediaType.subtype());
   }
 
   @Test public void testCharsetIsOneOfManyParameters() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;a=1;b=2;charset=utf-8;c=3");
+    MediaType mediaType = parse("text/plain;a=1;b=2;charset=utf-8;c=3");
     assertEquals("text", mediaType.type());
     assertEquals("plain", mediaType.subtype());
     assertEquals("UTF-8", mediaType.charset().name());
   }
 
   @Test public void testCharsetAndQuoting() throws Exception {
-    MediaType mediaType = MediaType.parse(
+    MediaType mediaType = parse(
         "text/plain;a=\";charset=us-ascii\";charset=\"utf-8\";b=\"iso-8859-1\"");
     assertEquals("UTF-8", mediaType.charset().name());
   }
 
   @Test public void testDuplicatedCharsets() {
-    MediaType mediaType = MediaType.parse("text/plain; charset=utf-8; charset=UTF-8");
+    MediaType mediaType = parse("text/plain; charset=utf-8; charset=UTF-8");
     assertEquals("UTF-8", mediaType.charset().name());
   }
 
   @Test public void testMultipleCharsets() {
-    try {
-      MediaType.parse("text/plain; charset=utf-8; charset=utf-16");
-      fail();
-    } catch (IllegalArgumentException expected) {
-    }
+    assertInvalid("text/plain; charset=utf-8; charset=utf-16",
+        "Multiple charsets defined: \"utf-8\" and: \"utf-16\" for: \"text/plain; charset=utf-8; charset=utf-16\"");
   }
 
   @Test public void testIllegalCharsetName() {
-    MediaType mediaType = MediaType.parse("text/plain; charset=\"!@#$%^&*()\"");
-    try {
-      mediaType.charset();
-      fail();
-    } catch (IllegalCharsetNameException expected) {
-    }
+    MediaType mediaType = parse("text/plain; charset=\"!@#$%^&*()\"");
+    assertNull(mediaType.charset());
   }
 
   @Test public void testUnsupportedCharset() {
-    MediaType mediaType = MediaType.parse("text/plain; charset=utf-wtf");
-    try {
-      mediaType.charset();
-      fail();
-    } catch (UnsupportedCharsetException expected) {
-    }
+    MediaType mediaType = parse("text/plain; charset=utf-wtf");
+    assertNull(mediaType.charset());
   }
 
   /**
@@ -153,52 +172,52 @@
    * unpleasant IllegalCharsetNameException.
    */
   @Test public void testCharsetNameIsSingleQuoted() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;charset='utf-8'");
+    MediaType mediaType = parse("text/plain;charset='utf-8'");
     assertEquals("UTF-8", mediaType.charset().name());
   }
 
   @Test public void testCharsetNameIsDoubleQuotedAndSingleQuoted() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;charset=\"'utf-8'\"");
-    try {
-      mediaType.charset();
-      fail();
-    } catch (IllegalCharsetNameException expected) {
-    }
+    MediaType mediaType = parse("text/plain;charset=\"'utf-8'\"");
+    assertNull(mediaType.charset());
   }
 
   @Test public void testCharsetNameIsDoubleQuotedSingleQuote() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;charset=\"'\"");
-    try {
-      mediaType.charset();
-      fail();
-    } catch (IllegalCharsetNameException expected) {
-    }
+    MediaType mediaType = parse("text/plain;charset=\"'\"");
+    assertNull(mediaType.charset());
   }
 
   @Test public void testDefaultCharset() throws Exception {
-    MediaType noCharset = MediaType.parse("text/plain");
+    MediaType noCharset = parse("text/plain");
     assertEquals("UTF-8", noCharset.charset(Util.UTF_8).name());
     assertEquals("US-ASCII", noCharset.charset(Charset.forName("US-ASCII")).name());
 
-    MediaType charset = MediaType.parse("text/plain; charset=iso-8859-1");
+    MediaType charset = parse("text/plain; charset=iso-8859-1");
     assertEquals("ISO-8859-1", charset.charset(Util.UTF_8).name());
     assertEquals("ISO-8859-1", charset.charset(Charset.forName("US-ASCII")).name());
   }
 
   @Test public void testParseDanglingSemicolon() throws Exception {
-    MediaType mediaType = MediaType.parse("text/plain;");
+    MediaType mediaType = parse("text/plain;");
     assertEquals("text", mediaType.type());
     assertEquals("plain", mediaType.subtype());
-    assertEquals(null, mediaType.charset());
+    assertNull(mediaType.charset());
     assertEquals("text/plain;", mediaType.toString());
   }
 
   private void assertMediaType(String string) {
-    MediaType mediaType = MediaType.parse(string);
-    assertEquals(string, mediaType.toString());
-  }
-
-  private void assertInvalid(String string) {
-    assertNull(string, MediaType.parse(string));
+    assertEquals(string, parse(string).toString());
+  }
+
+  private void assertInvalid(String string, String exceptionMessage) {
+    if (useGet) {
+      try {
+        parse(string);
+        fail("Expected get of \"" + string + "\" to throw with: " + exceptionMessage);
+      } catch (IllegalArgumentException e) {
+        assertEquals(exceptionMessage, e.getMessage());
+      }
+    } else {
+      assertNull(string, parse(string));
+    }
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java b/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
index 35d2f67906..a65d850368 100644
--- a/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/MultipartBodyTest.java
@@ -129,13 +129,13 @@
                 .addPart(
                     Headers.of("Content-Disposition", "file; filename=\"file1.txt\""),
                     RequestBody.create(
-                        MediaType.parse("text/plain"), "... contents of file1.txt ..."))
+                        MediaType.get("text/plain"), "... contents of file1.txt ..."))
                 .addPart(
                     Headers.of(
                         "Content-Disposition", "file; filename=\"file2.gif\"",
                         "Content-Transfer-Encoding", "binary"),
                     RequestBody.create(
-                        MediaType.parse("image/gif"),
+                        MediaType.get("image/gif"),
                         "... contents of file2.gif ...".getBytes(UTF_8)))
                 .build())
         .build();
@@ -180,7 +180,7 @@
     MultipartBody body = new MultipartBody.Builder("AaB03x")
         .setType(MultipartBody.FORM)
         .addFormDataPart("field with spaces", "filename with spaces.txt",
-            RequestBody.create(MediaType.parse("text/plain; charset=utf-8"), "okay"))
+            RequestBody.create(MediaType.get("text/plain; charset=utf-8"), "okay"))
         .addFormDataPart("field with \"", "\"")
         .addFormDataPart("field with %22", "%22")
         .addFormDataPart("field with \u0391", "Alpha")
diff --git a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
index 5c13119e46..ebffe84f68 100644
--- a/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/OkHttpClientTest.java
@@ -127,4 +127,76 @@
     OkHttpClient clientB = TestUtil.defaultClient();
     assertEquals(clientA.certificatePinner(), clientB.certificatePinner());
   }
+
+  @Test public void nullInterceptor() {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    try {
+      builder.addInterceptor(null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("interceptor == null", expected.getMessage());
+    }
+  }
+
+  @Test public void nullNetworkInterceptor() {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    try {
+      builder.addNetworkInterceptor(null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("interceptor == null", expected.getMessage());
+    }
+  }
+
+  @Test public void nullInterceptorInList() {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    builder.interceptors().add(null);
+    try {
+      builder.build();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("Null interceptor: [null]", expected.getMessage());
+    }
+  }
+
+  @Test public void nullNetworkInterceptorInList() {
+    OkHttpClient.Builder builder = new OkHttpClient.Builder();
+    builder.networkInterceptors().add(null);
+    try {
+      builder.build();
+      fail();
+    } catch (IllegalStateException expected) {
+      assertEquals("Null network interceptor: [null]", expected.getMessage());
+    }
+  }
+
+  @Test public void testH2PriorKnowledgeOkHttpClientConstructionFallback() {
+    try {
+      new OkHttpClient.Builder()
+          .protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_1_1));
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("protocols containing h2_prior_knowledge cannot use other protocols: "
+          + "[h2_prior_knowledge, http/1.1]", expected.getMessage());
+    }
+  }
+
+  @Test public void testH2PriorKnowledgeOkHttpClientConstructionDuplicates() {
+    try {
+      new OkHttpClient.Builder()
+          .protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.H2_PRIOR_KNOWLEDGE));
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals("protocols containing h2_prior_knowledge cannot use other protocols: "
+          + "[h2_prior_knowledge, h2_prior_knowledge]", expected.getMessage());
+    }
+  }
+
+  @Test public void testH2PriorKnowledgeOkHttpClientConstructionSuccess() {
+    OkHttpClient okHttpClient = new OkHttpClient.Builder()
+        .protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE))
+        .build();
+    assertEquals(1, okHttpClient.protocols().size());
+    assertEquals(Protocol.H2_PRIOR_KNOWLEDGE, okHttpClient.protocols().get(0));
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/ProtocolTest.java b/okhttp-tests/src/test/java/okhttp3/ProtocolTest.java
new file mode 100644
index 0000000000..78b408093d
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/ProtocolTest.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class ProtocolTest {
+  @Test
+  public void testGetKnown() throws IOException {
+    assertEquals(Protocol.HTTP_1_0, Protocol.get("http/1.0"));
+    assertEquals(Protocol.HTTP_1_1, Protocol.get("http/1.1"));
+    assertEquals(Protocol.SPDY_3, Protocol.get("spdy/3.1"));
+    assertEquals(Protocol.HTTP_2, Protocol.get("h2"));
+    assertEquals(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.get("h2_prior_knowledge"));
+    assertEquals(Protocol.QUIC, Protocol.get("quic"));
+  }
+
+  @Test(expected = IOException.class)
+  public void testGetUnknown() throws IOException {
+    Protocol.get("tcp");
+  }
+
+  @Test
+  public void testToString() throws IOException {
+    assertEquals("http/1.0", Protocol.HTTP_1_0.toString());
+    assertEquals("http/1.1", Protocol.HTTP_1_1.toString());
+    assertEquals("spdy/3.1", Protocol.SPDY_3.toString());
+    assertEquals("h2", Protocol.HTTP_2.toString());
+    assertEquals("h2_prior_knowledge", Protocol.H2_PRIOR_KNOWLEDGE.toString());
+    assertEquals("quic", Protocol.QUIC.toString());
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
index b11854a277..d34380cc4f 100644
--- a/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
+++ b/okhttp-tests/src/test/java/okhttp3/RecordedResponse.java
@@ -143,13 +143,21 @@ public RecordedResponse cacheResponse() {
     return new RecordedResponse(cacheResponse.request(), cacheResponse, null, null, null);
   }
 
-  public RecordedResponse assertFailure(Class<?> exceptionClass) {
-    assertTrue(exceptionClass.isInstance(failure));
+  public RecordedResponse assertFailure(Class<?>... allowedExceptionTypes) {
+    boolean found = false;
+    for (Class expectedClass : allowedExceptionTypes) {
+      if (expectedClass.isInstance(failure)) {
+        found = true;
+        break;
+      }
+    }
+    assertTrue("Expected exception type among " + Arrays.toString(allowedExceptionTypes)
+            + ", got " + failure, found);
     return this;
   }
 
   public RecordedResponse assertFailure(String... messages) {
-    assertNotNull(failure);
+    assertNotNull("No failure found", failure);
     assertTrue(failure.getMessage(), Arrays.asList(messages).contains(failure.getMessage()));
     return this;
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java b/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java
new file mode 100644
index 0000000000..6799300cdf
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/RecordingEventListener.java
@@ -0,0 +1,414 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Deque;
+import java.util.List;
+import javax.annotation.Nullable;
+
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+public final class RecordingEventListener extends EventListener {
+  final Deque<CallEvent> eventSequence = new ArrayDeque<>();
+
+  final List<Object> forbiddenLocks = new ArrayList<>();
+
+  /** Confirm that the thread does not hold a lock on {@code lock} during the callback. */
+  public void forbidLock(Object lock) {
+    forbiddenLocks.add(lock);
+  }
+
+  /**
+   * Removes recorded events up to (and including) an event is found whose class equals
+   * {@code eventClass} and returns it.
+   */
+  public <T> T removeUpToEvent(Class<T> eventClass) {
+    Object event = eventSequence.poll();
+    while (event != null && !eventClass.isInstance(event)) {
+      event = eventSequence.poll();
+    }
+    if (event == null) throw new AssertionError();
+    return eventClass.cast(event);
+  }
+
+  public List<String> recordedEventTypes() {
+    List<String> eventTypes = new ArrayList<>();
+    for (CallEvent event : eventSequence) {
+      eventTypes.add(event.getName());
+    }
+    return eventTypes;
+  }
+
+  public void clearAllEvents() {
+    eventSequence.clear();
+  }
+
+  private void logEvent(CallEvent e) {
+    for (Object lock : forbiddenLocks) {
+      assertFalse(lock.toString(), Thread.holdsLock(lock));
+    }
+
+    CallEvent startEvent = e.closes();
+
+    if (startEvent != null) {
+      assertTrue(e.getName() + " without matching " + startEvent.getName(),
+          eventSequence.contains(startEvent));
+    }
+
+    eventSequence.offer(e);
+  }
+
+  @Override public void dnsStart(Call call, String domainName) {
+    logEvent(new DnsStart(call, domainName));
+  }
+
+  @Override public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
+    logEvent(new DnsEnd(call, domainName, inetAddressList));
+  }
+
+  @Override public void connectStart(Call call, InetSocketAddress inetSocketAddress,
+      Proxy proxy) {
+    logEvent(new ConnectStart(call, inetSocketAddress, proxy));
+  }
+
+  @Override public void secureConnectStart(Call call) {
+    logEvent(new SecureConnectStart(call));
+  }
+
+  @Override public void secureConnectEnd(Call call, Handshake handshake) {
+    logEvent(new SecureConnectEnd(call, handshake));
+  }
+
+  @Override public void connectEnd(Call call, InetSocketAddress inetSocketAddress,
+      @Nullable Proxy proxy, Protocol protocol) {
+    logEvent(new ConnectEnd(call, inetSocketAddress, proxy, protocol));
+  }
+
+  @Override public void connectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,
+      @Nullable Protocol protocol, IOException ioe) {
+    logEvent(new ConnectFailed(call, inetSocketAddress, proxy, protocol, ioe));
+  }
+
+  @Override public void connectionAcquired(Call call, Connection connection) {
+    logEvent(new ConnectionAcquired(call, connection));
+  }
+
+  @Override public void connectionReleased(Call call, Connection connection) {
+    logEvent(new ConnectionReleased(call, connection));
+  }
+
+  @Override public void callStart(Call call) {
+    logEvent(new CallStart(call));
+  }
+
+  @Override public void requestHeadersStart(Call call) {
+    logEvent(new RequestHeadersStart(call));
+  }
+
+  @Override public void requestHeadersEnd(Call call, Request request) {
+    logEvent(new RequestHeadersEnd(call, request.headers.byteCount()));
+  }
+
+  @Override public void requestBodyStart(Call call) {
+    logEvent(new RequestBodyStart(call));
+  }
+
+  @Override public void requestBodyEnd(Call call, long byteCount) {
+    logEvent(new RequestBodyEnd(call, byteCount));
+  }
+
+  @Override public void responseHeadersStart(Call call) {
+    logEvent(new ResponseHeadersStart(call));
+  }
+
+  @Override public void responseHeadersEnd(Call call, Response response) {
+    logEvent(new ResponseHeadersEnd(call, response.headers.byteCount()));
+  }
+
+  @Override public void responseBodyStart(Call call) {
+    logEvent(new ResponseBodyStart(call));
+  }
+
+  @Override public void responseBodyEnd(Call call, long byteCount) {
+    logEvent(new ResponseBodyEnd(call, byteCount));
+  }
+
+  @Override public void callEnd(Call call) {
+    logEvent(new CallEnd(call));
+  }
+
+  @Override public void callFailed(Call call, IOException ioe) {
+    logEvent(new CallFailed(call, ioe));
+  }
+
+  static class CallEvent {
+    final Call call;
+    final List<Object> params;
+
+    CallEvent(Call call, Object... params) {
+      this.call = call;
+      this.params = Arrays.asList(params);
+    }
+
+    public String getName() {
+      return getClass().getSimpleName();
+    }
+
+    @Override public boolean equals(Object o) {
+      if (this == o) return true;
+      if (!(o instanceof CallEvent)) return false;
+
+      CallEvent callEvent = (CallEvent) o;
+
+      if (!getName().equals(callEvent.getName())) return false;
+      if (!call.equals(callEvent.call)) return false;
+      return params.equals(callEvent.params);
+    }
+
+    @Override public int hashCode() {
+      int result = call.hashCode();
+      result = 31 * result + getName().hashCode();
+      result = 31 * result + params.hashCode();
+      return result;
+    }
+
+    public @Nullable CallEvent closes() {
+      return null;
+    }
+  }
+
+  static final class DnsStart extends CallEvent {
+    final String domainName;
+
+    DnsStart(Call call, String domainName) {
+      super(call, domainName);
+      this.domainName = domainName;
+    }
+  }
+
+  static final class DnsEnd extends CallEvent {
+    final String domainName;
+    final List<InetAddress> inetAddressList;
+
+    DnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
+      super(call, domainName, inetAddressList);
+      this.domainName = domainName;
+      this.inetAddressList = inetAddressList;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new DnsStart(call, domainName);
+    }
+  }
+
+  static final class ConnectStart extends CallEvent {
+    final InetSocketAddress inetSocketAddress;
+    final Proxy proxy;
+
+    ConnectStart(Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
+      super(call, inetSocketAddress, proxy);
+      this.inetSocketAddress = inetSocketAddress;
+      this.proxy = proxy;
+    }
+  }
+
+  static final class ConnectEnd extends CallEvent {
+    final InetSocketAddress inetSocketAddress;
+    final Protocol protocol;
+    final Proxy proxy;
+
+    ConnectEnd(Call call, InetSocketAddress inetSocketAddress, Proxy proxy, Protocol protocol) {
+      super(call, inetSocketAddress, proxy, protocol);
+      this.inetSocketAddress = inetSocketAddress;
+      this.proxy = proxy;
+      this.protocol = protocol;
+    }
+
+    @Override public CallEvent closes() {
+      return new ConnectStart(call, inetSocketAddress, proxy);
+    }
+  }
+
+  static final class ConnectFailed extends CallEvent {
+    final InetSocketAddress inetSocketAddress;
+    final Protocol protocol;
+    final Proxy proxy;
+    final IOException ioe;
+
+    ConnectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy, Protocol protocol,
+        IOException ioe) {
+      super(call, inetSocketAddress, proxy, protocol, ioe);
+      this.inetSocketAddress = inetSocketAddress;
+      this.proxy = proxy;
+      this.protocol = protocol;
+      this.ioe = ioe;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new ConnectStart(call, inetSocketAddress, proxy);
+    }
+  }
+
+  static final class SecureConnectStart extends CallEvent {
+    SecureConnectStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class SecureConnectEnd extends CallEvent {
+    final Handshake handshake;
+
+    SecureConnectEnd(Call call, Handshake handshake) {
+      super(call, handshake);
+      this.handshake = handshake;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new SecureConnectStart(call);
+    }
+  }
+
+  static final class ConnectionAcquired extends CallEvent {
+    final Connection connection;
+
+    ConnectionAcquired(Call call, Connection connection) {
+      super(call, connection);
+      this.connection = connection;
+    }
+  }
+
+  static final class ConnectionReleased extends CallEvent {
+    final Connection connection;
+
+    ConnectionReleased(Call call, Connection connection) {
+      super(call, connection);
+      this.connection = connection;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new ConnectionAcquired(call, connection);
+    }
+  }
+
+  static final class CallStart extends CallEvent {
+    CallStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class CallEnd extends CallEvent {
+    CallEnd(Call call) {
+      super(call);
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new CallStart(call);
+    }
+  }
+
+  static final class CallFailed extends CallEvent {
+    final IOException ioe;
+
+    CallFailed(Call call, IOException ioe) {
+      super(call, ioe);
+      this.ioe = ioe;
+    }
+  }
+
+  static final class RequestHeadersStart extends CallEvent {
+    RequestHeadersStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class RequestHeadersEnd extends CallEvent {
+    final long headerLength;
+
+    RequestHeadersEnd(Call call, long headerLength) {
+      super(call, headerLength);
+      this.headerLength = headerLength;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new RequestHeadersStart(call);
+    }
+  }
+
+  static final class RequestBodyStart extends CallEvent {
+    RequestBodyStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class RequestBodyEnd extends CallEvent {
+    final long bytesWritten;
+
+    RequestBodyEnd(Call call, long bytesWritten) {
+      super(call, bytesWritten);
+      this.bytesWritten = bytesWritten;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new RequestBodyStart(call);
+    }
+  }
+
+  static final class ResponseHeadersStart extends CallEvent {
+    ResponseHeadersStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class ResponseHeadersEnd extends CallEvent {
+    final long headerLength;
+
+    ResponseHeadersEnd(Call call, long headerLength) {
+      super(call, headerLength);
+      this.headerLength = headerLength;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new RequestHeadersStart(call);
+    }
+  }
+
+  static final class ResponseBodyStart extends CallEvent {
+    ResponseBodyStart(Call call) {
+      super(call);
+    }
+  }
+
+  static final class ResponseBodyEnd extends CallEvent {
+    final long bytesRead;
+
+    ResponseBodyEnd(Call call, long bytesRead) {
+      super(call, bytesRead);
+      this.bytesRead = bytesRead;
+    }
+
+    @Nullable @Override public CallEvent closes() {
+      return new ResponseBodyStart(call);
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/RecordingWebSocketListener.java b/okhttp-tests/src/test/java/okhttp3/RecordingWebSocketListener.java
new file mode 100644
index 0000000000..45a13c4786
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/RecordingWebSocketListener.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import javax.annotation.Nullable;
+import okio.ByteString;
+
+public final class RecordingWebSocketListener extends WebSocketListener {
+  @Override public void onOpen(WebSocket webSocket, Response response) {
+    // TODO
+  }
+
+  @Override public void onMessage(WebSocket webSocket, String text) {
+    // TODO
+  }
+
+  @Override public void onMessage(WebSocket webSocket, ByteString bytes) {
+    // TODO
+  }
+
+  @Override public void onClosing(WebSocket webSocket, int code, String reason) {
+    // TODO
+  }
+
+  @Override public void onClosed(WebSocket webSocket, int code, String reason) {
+    // TODO
+  }
+
+  @Override public void onFailure(WebSocket webSocket, Throwable t, @Nullable Response response) {
+    // TODO
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/RequestTest.java b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
index 5c205d7031..50b7bcb53d 100644
--- a/okhttp-tests/src/test/java/okhttp3/RequestTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/RequestTest.java
@@ -21,17 +21,19 @@
 import java.net.URI;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.UUID;
 import okhttp3.internal.Util;
 import okio.Buffer;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.fail;
 
 public final class RequestTest {
   @Test public void string() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain; charset=utf-8");
+    MediaType contentType = MediaType.get("text/plain; charset=utf-8");
     RequestBody body = RequestBody.create(contentType, "abc".getBytes(Util.UTF_8));
     assertEquals(contentType, body.contentType());
     assertEquals(3, body.contentLength());
@@ -40,15 +42,15 @@
   }
 
   @Test public void stringWithDefaultCharsetAdded() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain");
+    MediaType contentType = MediaType.get("text/plain");
     RequestBody body = RequestBody.create(contentType, "\u0800");
-    assertEquals(MediaType.parse("text/plain; charset=utf-8"), body.contentType());
+    assertEquals(MediaType.get("text/plain; charset=utf-8"), body.contentType());
     assertEquals(3, body.contentLength());
     assertEquals("e0a080", bodyToHex(body));
   }
 
   @Test public void stringWithNonDefaultCharsetSpecified() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain; charset=utf-16be");
+    MediaType contentType = MediaType.get("text/plain; charset=utf-16be");
     RequestBody body = RequestBody.create(contentType, "\u0800");
     assertEquals(contentType, body.contentType());
     assertEquals(2, body.contentLength());
@@ -56,7 +58,7 @@
   }
 
   @Test public void byteArray() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain");
+    MediaType contentType = MediaType.get("text/plain");
     RequestBody body = RequestBody.create(contentType, "abc".getBytes(Util.UTF_8));
     assertEquals(contentType, body.contentType());
     assertEquals(3, body.contentLength());
@@ -65,7 +67,7 @@
   }
 
   @Test public void byteArrayRange() throws Exception {
-    MediaType contentType = MediaType.parse("text/plain");
+    MediaType contentType = MediaType.get("text/plain");
     RequestBody body = RequestBody.create(contentType, ".abcd".getBytes(Util.UTF_8), 1, 3);
     assertEquals(contentType, body.contentType());
     assertEquals(3, body.contentLength());
@@ -79,7 +81,7 @@
     writer.write("abc");
     writer.close();
 
-    MediaType contentType = MediaType.parse("text/plain");
+    MediaType contentType = MediaType.get("text/plain");
     RequestBody body = RequestBody.create(contentType, file);
     assertEquals(contentType, body.contentType());
     assertEquals(3, body.contentLength());
@@ -89,7 +91,7 @@
 
   /** Common verbs used for apis such as GitHub, AWS, and Google Cloud. */
   @Test public void crudVerbs() throws IOException {
-    MediaType contentType = MediaType.parse("application/json");
+    MediaType contentType = MediaType.get("application/json");
     RequestBody body = RequestBody.create(contentType, "{}");
 
     Request get = new Request.Builder().url("http://localhost/api").get().build();
@@ -120,24 +122,24 @@
   @Test public void uninitializedURI() throws Exception {
     Request request = new Request.Builder().url("http://localhost/api").build();
     assertEquals(new URI("http://localhost/api"), request.url().uri());
-    assertEquals(HttpUrl.parse("http://localhost/api"), request.url());
+    assertEquals(HttpUrl.get("http://localhost/api"), request.url());
   }
 
-  @Test public void newBuilderUrlResetsUrl() throws Exception {
+  @Test public void newBuilderUrlResetsUrl() {
     Request requestWithoutCache = new Request.Builder().url("http://localhost/api").build();
     Request builtRequestWithoutCache =
         requestWithoutCache.newBuilder().url("http://localhost/api/foo").build();
-    assertEquals(HttpUrl.parse("http://localhost/api/foo"), builtRequestWithoutCache.url());
+    assertEquals(HttpUrl.get("http://localhost/api/foo"), builtRequestWithoutCache.url());
 
     Request requestWithCache = new Request.Builder().url("http://localhost/api").build();
     // cache url object
     requestWithCache.url();
     Request builtRequestWithCache = requestWithCache.newBuilder().url(
         "http://localhost/api/foo").build();
-    assertEquals(HttpUrl.parse("http://localhost/api/foo"), builtRequestWithCache.url());
+    assertEquals(HttpUrl.get("http://localhost/api/foo"), builtRequestWithCache.url());
   }
 
-  @Test public void cacheControl() throws Exception {
+  @Test public void cacheControl() {
     Request request = new Request.Builder()
         .cacheControl(new CacheControl.Builder().noCache().build())
         .url("https://square.com")
@@ -145,7 +147,7 @@
     assertEquals(Arrays.asList("no-cache"), request.headers("Cache-Control"));
   }
 
-  @Test public void emptyCacheControlClearsAllCacheControlHeaders() throws Exception {
+  @Test public void emptyCacheControlClearsAllCacheControlHeaders() {
     Request request = new Request.Builder()
         .header("Cache-Control", "foo")
         .cacheControl(new CacheControl.Builder().build())
@@ -154,13 +156,13 @@
     assertEquals(Collections.<String>emptyList(), request.headers("Cache-Control"));
   }
 
-  @Test public void headerAcceptsPermittedCharacters() throws Exception {
+  @Test public void headerAcceptsPermittedCharacters() {
     Request.Builder builder = new Request.Builder();
     builder.header("AZab09~", "AZab09 ~");
     builder.addHeader("AZab09~", "AZab09 ~");
   }
 
-  @Test public void emptyNameForbidden() throws Exception {
+  @Test public void emptyNameForbidden() {
     Request.Builder builder = new Request.Builder();
     try {
       builder.header("", "Value");
@@ -174,7 +176,7 @@
     }
   }
 
-  @Test public void headerForbidsNullArguments() throws Exception {
+  @Test public void headerForbidsNullArguments() {
     Request.Builder builder = new Request.Builder();
     try {
       builder.header(null, "Value");
@@ -198,7 +200,7 @@
     }
   }
 
-  @Test public void headerAllowsTabOnlyInValues() throws Exception {
+  @Test public void headerAllowsTabOnlyInValues() {
     Request.Builder builder = new Request.Builder();
     builder.header("key", "sample\tvalue");
     try {
@@ -208,7 +210,7 @@
     }
   }
 
-  @Test public void headerForbidsControlCharacters() throws Exception {
+  @Test public void headerForbidsControlCharacters() {
     assertForbiddenHeader("\u0000");
     assertForbiddenHeader("\r");
     assertForbiddenHeader("\n");
@@ -242,6 +244,111 @@ private void assertForbiddenHeader(String s) {
     }
   }
 
+  @Test public void noTag() {
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .build();
+    assertNull(request.tag());
+    assertNull(request.tag(Object.class));
+    assertNull(request.tag(UUID.class));
+    assertNull(request.tag(String.class));
+  }
+
+  @Test public void defaultTag() {
+    UUID tag = UUID.randomUUID();
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag(tag)
+        .build();
+    assertSame(tag, request.tag());
+    assertSame(tag, request.tag(Object.class));
+    assertNull(request.tag(UUID.class));
+    assertNull(request.tag(String.class));
+  }
+
+  @Test public void nullRemovesTag() {
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag("a")
+        .tag(null)
+        .build();
+    assertNull(request.tag());
+  }
+
+  @Test public void removeAbsentTag() {
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag(null)
+        .build();
+    assertNull(request.tag());
+  }
+
+  @Test public void objectTag() {
+    UUID tag = UUID.randomUUID();
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag(Object.class, tag)
+        .build();
+    assertSame(tag, request.tag());
+    assertSame(tag, request.tag(Object.class));
+    assertNull(request.tag(UUID.class));
+    assertNull(request.tag(String.class));
+  }
+
+  @Test public void typedTag() {
+    UUID uuidTag = UUID.randomUUID();
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag(UUID.class, uuidTag)
+        .build();
+    assertNull(request.tag());
+    assertNull(request.tag(Object.class));
+    assertSame(uuidTag, request.tag(UUID.class));
+    assertNull(request.tag(String.class));
+  }
+
+  @Test public void replaceOnlyTag() {
+    UUID uuidTag1 = UUID.randomUUID();
+    UUID uuidTag2 = UUID.randomUUID();
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag(UUID.class, uuidTag1)
+        .tag(UUID.class, uuidTag2)
+        .build();
+    assertSame(uuidTag2, request.tag(UUID.class));
+  }
+
+  @Test public void multipleTags() {
+    UUID uuidTag = UUID.randomUUID();
+    String stringTag = "dilophosaurus";
+    Long longTag = 20170815L;
+    Object objectTag = new Object();
+    Request request = new Request.Builder()
+        .url("https://square.com")
+        .tag(Object.class, objectTag)
+        .tag(UUID.class, uuidTag)
+        .tag(String.class, stringTag)
+        .tag(Long.class, longTag)
+        .build();
+    assertSame(objectTag, request.tag());
+    assertSame(objectTag, request.tag(Object.class));
+    assertSame(uuidTag, request.tag(UUID.class));
+    assertSame(stringTag, request.tag(String.class));
+    assertSame(longTag, request.tag(Long.class));
+  }
+
+  /** Confirm that we don't accidentally share the backing map between objects. */
+  @Test public void tagsAreImmutable() {
+    Request.Builder builder = new Request.Builder()
+        .url("https://square.com");
+    Request requestA = builder.tag(String.class, "a").build();
+    Request requestB = builder.tag(String.class, "b").build();
+    Request requestC = requestA.newBuilder().tag(String.class, "c").build();
+    assertSame("a", requestA.tag(String.class));
+    assertSame("b", requestB.tag(String.class));
+    assertSame("c", requestC.tag(String.class));
+  }
+
   private String bodyToHex(RequestBody body) throws IOException {
     Buffer buffer = new Buffer();
     body.writeTo(buffer);
diff --git a/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java b/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
index 47feecacb6..40f994c526 100644
--- a/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ResponseBodyTest.java
@@ -396,8 +396,8 @@ static ResponseBody body(String hex) {
   }
 
   static ResponseBody body(String hex, String charset) {
-    MediaType mediaType = charset == null ? null : MediaType.parse("any/thing; charset=" + charset);
-    return ResponseBody.create(mediaType, ByteString.decodeHex(hex).toByteArray());
+    MediaType mediaType = charset == null ? null : MediaType.get("any/thing; charset=" + charset);
+    return ResponseBody.create(mediaType, ByteString.decodeHex(hex));
   }
 
   static String exhaust(Reader reader) throws IOException {
diff --git a/okhttp-tests/src/test/java/okhttp3/ResponseTest.java b/okhttp-tests/src/test/java/okhttp3/ResponseTest.java
index 8977fdf441..5d77a02a26 100644
--- a/okhttp-tests/src/test/java/okhttp3/ResponseTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/ResponseTest.java
@@ -95,6 +95,7 @@ private Response newResponse(ResponseBody responseBody) {
             .build())
         .protocol(Protocol.HTTP_1_1)
         .code(200)
+        .message("OK")
         .body(responseBody)
         .build();
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/SocksProxy.java b/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
index 69ce1fab8c..d56241ac91 100644
--- a/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
+++ b/okhttp-tests/src/test/java/okhttp3/SocksProxy.java
@@ -23,6 +23,9 @@
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.SocketException;
+import java.util.Collections;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.TimeUnit;
@@ -41,7 +44,7 @@
  * See <a href="https://www.ietf.org/rfc/rfc1928.txt">RFC 1928</a>.
  */
 public final class SocksProxy {
-  public final String HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS = "onlyProxyCanResolveMe.org";
+  public static final String HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS = "onlyProxyCanResolveMe.org";
 
   private static final int VERSION_5 = 5;
   private static final int METHOD_NONE = 0xff;
@@ -58,6 +61,8 @@
 
   private ServerSocket serverSocket;
   private AtomicInteger connectionCount = new AtomicInteger();
+  private final Set<Socket> openSockets =
+      Collections.newSetFromMap(new ConcurrentHashMap<Socket, Boolean>());
 
   public void play() throws IOException {
     serverSocket = new ServerSocket(0);
@@ -73,6 +78,10 @@ public void play() throws IOException {
           logger.info(name + " done accepting connections: " + e.getMessage());
         } catch (IOException e) {
           logger.log(Level.WARNING, name + " failed unexpectedly", e);
+        } finally {
+          for (Socket socket : openSockets) {
+            Util.closeQuietly(socket);
+          }
         }
       }
     });
@@ -103,6 +112,7 @@ private void service(final Socket from) {
           BufferedSink fromSink = Okio.buffer(Okio.sink(from));
           hello(fromSource, fromSink);
           acceptCommand(from.getInetAddress(), fromSource, fromSink);
+          openSockets.add(from);
         } catch (IOException e) {
           logger.log(Level.WARNING, name + " failed", e);
           Util.closeQuietly(from);
@@ -192,6 +202,8 @@ private void acceptCommand(InetAddress fromAddress, BufferedSource fromSource,
         // Copy sources to sinks in both directions.
         BufferedSource toSource = Okio.buffer(Okio.source(toSocket));
         BufferedSink toSink = Okio.buffer(Okio.sink(toSocket));
+        openSockets.add(toSocket);
+
         transfer(fromAddress, toAddress, fromSource, toSink);
         transfer(fromAddress, toAddress, toSource, fromSink);
         break;
diff --git a/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java b/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java
index f0d63f17aa..83a6617b90 100644
--- a/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/SocksProxyTest.java
@@ -99,7 +99,7 @@
 
     HttpUrl url = server.url("/")
         .newBuilder()
-        .host(socksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS)
+        .host(SocksProxy.HOSTNAME_THAT_ONLY_THE_PROXY_KNOWS)
         .build();
 
     Request request = new Request.Builder().url(url).build();
diff --git a/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java b/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
index 0ec9bc34fb..055b25e226 100644
--- a/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
+++ b/okhttp-tests/src/test/java/okhttp3/TestLogHandler.java
@@ -15,6 +15,8 @@
  */
 package okhttp3;
 
+import java.util.ArrayList;
+import java.util.List;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
@@ -42,7 +44,13 @@
   @Override public void close() {
   }
 
-  public String take() throws InterruptedException {
+  public List<String> takeAll() {
+    List<String> list = new ArrayList<>();
+    logs.drainTo(list);
+    return list;
+  }
+
+  public String take() throws Exception {
     String message = logs.poll(10, TimeUnit.SECONDS);
     if (message == null) {
       throw new AssertionError("Timed out waiting for log message.");
diff --git a/okhttp-tests/src/test/java/okhttp3/TestUtil.java b/okhttp-tests/src/test/java/okhttp3/TestUtil.java
index 6f44cc5ba5..4957087cf7 100644
--- a/okhttp-tests/src/test/java/okhttp3/TestUtil.java
+++ b/okhttp-tests/src/test/java/okhttp3/TestUtil.java
@@ -1,5 +1,6 @@
 package okhttp3;
 
+import java.net.InetSocketAddress;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
@@ -7,6 +8,9 @@
 import okhttp3.internal.http2.Header;
 
 public final class TestUtil {
+  public static final InetSocketAddress UNREACHABLE_ADDRESS
+      = new InetSocketAddress("198.51.100.1", 8080);
+
   private TestUtil() {
   }
 
@@ -49,7 +53,7 @@ public static String repeat(char c, int count) {
    * https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
    * java/lang/ref/FinalizationTester.java
    */
-  public static void awaitGarbageCollection() throws InterruptedException {
+  public static void awaitGarbageCollection() throws Exception {
     Runtime.getRuntime().gc();
     Thread.sleep(100);
     System.runFinalization();
diff --git a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
index adbf091782..4306fb21d9 100644
--- a/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/URLConnectionTest.java
@@ -24,12 +24,14 @@
 import java.net.HttpRetryException;
 import java.net.HttpURLConnection;
 import java.net.InetAddress;
+import java.net.PasswordAuthentication;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.ProxySelector;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.net.SocketAddress;
+import java.net.SocketException;
 import java.net.SocketTimeoutException;
 import java.net.URI;
 import java.net.URL;
@@ -48,6 +50,7 @@
 import java.util.Random;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.zip.GZIPInputStream;
 import javax.net.ServerSocketFactory;
 import javax.net.SocketFactory;
@@ -55,6 +58,7 @@
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLProtocolException;
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.TrustManagerFactory;
@@ -66,11 +70,13 @@
 import okhttp3.internal.SingleInetAddressDns;
 import okhttp3.internal.Util;
 import okhttp3.internal.Version;
-import okhttp3.internal.tls.SslClient;
+import okhttp3.internal.huc.OkHttpURLConnection;
+import okhttp3.internal.platform.Platform;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.GzipSink;
@@ -96,6 +102,7 @@
 import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_INPUT_AT_END;
 import static okhttp3.mockwebserver.SocketPolicy.SHUTDOWN_OUTPUT_AT_END;
 import static okhttp3.mockwebserver.SocketPolicy.UPGRADE_TO_SSL_AT_END;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -110,12 +117,12 @@
   @Rule public final MockWebServer server2 = new MockWebServer();
   @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
 
-  private SslClient sslClient = SslClient.localhost();
+  private HandshakeCertificates handshakeCertificates = localhost();
   private OkUrlFactory urlFactory;
   private HttpURLConnection connection;
   private Cache cache;
 
-  @Before public void setUp() throws Exception {
+  @Before public void setUp() {
     server.setProtocolNegotiationEnabled(false);
     urlFactory = new OkUrlFactory(defaultClient());
   }
@@ -134,7 +141,7 @@
     }
   }
 
-  @Test public void requestHeaders() throws IOException, InterruptedException {
+  @Test public void requestHeaders() throws Exception {
     server.enqueue(new MockResponse());
 
     connection = urlFactory.open(server.url("/").url());
@@ -195,14 +202,14 @@
     }
   }
 
-  @Test public void getRequestPropertyReturnsLastValue() throws Exception {
+  @Test public void getRequestPropertyReturnsLastValue() {
     connection = urlFactory.open(server.url("/").url());
     connection.addRequestProperty("A", "value1");
     connection.addRequestProperty("A", "value2");
     assertEquals("value2", connection.getRequestProperty("A"));
   }
 
-  @Test public void responseHeaders() throws IOException, InterruptedException {
+  @Test public void responseHeaders() throws Exception {
     server.enqueue(new MockResponse().setStatus("HTTP/1.0 200 Fantastic")
         .addHeader("A: c")
         .addHeader("B: d")
@@ -236,7 +243,7 @@
     connection.getInputStream().close();
   }
 
-  @Test public void serverSendsInvalidResponseHeaders() throws Exception {
+  @Test public void serverSendsInvalidResponseHeaders() {
     server.enqueue(new MockResponse().setStatus("HTP/1.1 200 OK"));
 
     connection = urlFactory.open(server.url("/").url());
@@ -247,7 +254,7 @@
     }
   }
 
-  @Test public void serverSendsInvalidCodeTooLarge() throws Exception {
+  @Test public void serverSendsInvalidCodeTooLarge() {
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 2147483648 OK"));
 
     connection = urlFactory.open(server.url("/").url());
@@ -258,7 +265,7 @@
     }
   }
 
-  @Test public void serverSendsInvalidCodeNotANumber() throws Exception {
+  @Test public void serverSendsInvalidCodeNotANumber() {
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 00a OK"));
 
     connection = urlFactory.open(server.url("/").url());
@@ -269,7 +276,7 @@
     }
   }
 
-  @Test public void serverSendsUnnecessaryWhitespace() throws Exception {
+  @Test public void serverSendsUnnecessaryWhitespace() {
     server.enqueue(new MockResponse().setStatus(" HTTP/1.1 2147483648 OK"));
 
     connection = urlFactory.open(server.url("/").url());
@@ -380,7 +387,7 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
 
   // Check that we recognize a few basic mime types by extension.
   // http://code.google.com/p/android/issues/detail?id=10100
-  @Test public void bug10100() throws Exception {
+  @Test public void bug10100() {
     assertEquals("image/jpeg", URLConnection.guessContentTypeFromName("someFile.jpg"));
     assertEquals("application/pdf", URLConnection.guessContentTypeFromName("stuff.pdf"));
   }
@@ -548,11 +555,12 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   }
 
   @Test public void connectViaHttps() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
     connection = urlFactory.open(server.url("/foo").url());
@@ -564,11 +572,12 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   }
 
   @Test public void inspectHandshakeThroughoutRequestLifecycle() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse());
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
 
@@ -604,12 +613,12 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
   }
 
   private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
     server.enqueue(new MockResponse().setBody("another response via HTTPS"));
 
     // The pool will only reuse sockets if the SSL socket factories are the same.
-    SSLSocketFactory clientSocketFactory = sslClient.socketFactory;
+    SSLSocketFactory clientSocketFactory = handshakeCertificates.sslSocketFactory();
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
     CookieJar cookieJar = new JavaNetCookieJar(new CookieManager());
@@ -619,7 +628,7 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
         .cache(cache)
         .connectionPool(connectionPool)
         .cookieJar(cookieJar)
-        .sslSocketFactory(clientSocketFactory, sslClient.trustManager)
+        .sslSocketFactory(clientSocketFactory, handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build());
     connection = urlFactory.open(server.url("/").url());
@@ -630,7 +639,7 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
           .cache(cache)
           .connectionPool(connectionPool)
           .cookieJar(cookieJar)
-          .sslSocketFactory(clientSocketFactory, sslClient.trustManager)
+          .sslSocketFactory(clientSocketFactory, handshakeCertificates.trustManager())
           .hostnameVerifier(hostnameVerifier)
           .build());
     }
@@ -643,19 +652,20 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
   }
 
   @Test public void connectViaHttpsReusingConnectionsDifferentFactories() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
     server.enqueue(new MockResponse().setBody("another response via HTTPS"));
 
     // install a custom SSL socket factory so the server can be authorized
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
     HttpURLConnection connection1 = urlFactory.open(server.url("/").url());
     assertContent("this response comes via HTTPS", connection1);
 
-    SSLContext sslContext2 = SSLContext.getInstance("TLS");
+    SSLContext sslContext2 = Platform.get().getSSLContext();
     sslContext2.init(null, null, null);
     SSLSocketFactory sslSocketFactory2 = sslContext2.getSocketFactory();
 
@@ -678,13 +688,16 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
   // TODO(jwilson): tests below this marker need to be migrated to OkHttp's request/response API.
 
   @Test public void connectViaHttpsWithSSLFallback() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setBody("this response comes via SSL"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        // Attempt RESTRICTED_TLS then fall back to MODERN_TLS.
+        .connectionSpecs(Arrays.asList(ConnectionSpec.RESTRICTED_TLS, ConnectionSpec.MODERN_TLS))
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
         .build());
     connection = urlFactory.open(server.url("/foo").url());
 
@@ -695,18 +708,20 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
 
     RecordedRequest fallbackRequest = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", fallbackRequest.getRequestLine());
-    assertEquals(TlsVersion.TLS_1_0, fallbackRequest.getTlsVersion());
+    assertEquals(TlsVersion.TLS_1_2, fallbackRequest.getTlsVersion());
   }
 
-  @Test public void connectViaHttpsWithSSLFallbackFailuresRecorded() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+  @Test public void connectViaHttpsWithSSLFallbackFailuresRecorded() {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
     server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .dns(new SingleInetAddressDns())
+        .connectionSpecs(Arrays.asList(ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS))
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
         .build());
     connection = urlFactory.open(server.url("/foo").url());
 
@@ -725,7 +740,7 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
    * https://github.com/square/okhttp/issues/515
    */
   @Test public void sslFallbackNotUsedWhenRecycledConnectionFails() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()
         .setBody("abc")
         .setSocketPolicy(DISCONNECT_AT_END));
@@ -733,7 +748,8 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .hostnameVerifier(new RecordingHostnameVerifier())
-        .sslSocketFactory(suppressTlsFallbackClientSocketFactory(), sslClient.trustManager)
+        .sslSocketFactory(
+            suppressTlsFallbackClientSocketFactory(), handshakeCertificates.trustManager())
         .build());
 
     assertContent("abc", urlFactory.open(server.url("/").url()));
@@ -758,8 +774,8 @@ private void connectViaHttpsReusingConnections(boolean rebuildClient) throws Exc
    *
    * http://code.google.com/p/android/issues/detail?id=13178
    */
-  @Test public void connectViaHttpsToUntrustedServer() throws IOException, InterruptedException {
-    server.useHttps(sslClient.socketFactory, false);
+  @Test public void connectViaHttpsToUntrustedServer() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse()); // unused
 
     connection = urlFactory.open(server.url("/foo").url());
@@ -816,7 +832,7 @@ private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
     }
   }
 
-  public void testConnectViaSocketFactory(boolean useHttps) throws IOException {
+  private void testConnectViaSocketFactory(boolean useHttps) throws IOException {
     SocketFactory uselessSocketFactory = new SocketFactory() {
       public Socket createSocket() {
         throw new IllegalArgumentException("useless");
@@ -841,9 +857,10 @@ public Socket createSocket(String host, int port, InetAddress localHost, int loc
     };
 
     if (useHttps) {
-      server.useHttps(sslClient.socketFactory, false);
+      server.useHttps(handshakeCertificates.sslSocketFactory(), false);
       urlFactory.setClient(urlFactory.client().newBuilder()
-          .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+          .sslSocketFactory(
+              handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
           .hostnameVerifier(new RecordingHostnameVerifier())
           .build());
     }
@@ -921,12 +938,13 @@ public Socket createSocket(String host, int port, InetAddress localHost, int loc
   }
 
   private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
 
     URL url = server.url("/foo").url();
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
     connection = proxyConfig.connect(server, urlFactory, url);
@@ -960,14 +978,15 @@ private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Ex
   private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exception {
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.enqueue(
         new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("this response comes via a secure proxy"));
 
     URL url = new URL("https://android.com/foo");
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build());
     connection = proxyConfig.connect(server, urlFactory, url);
@@ -989,7 +1008,7 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
   @Test public void connectViaHttpProxyToHttpsUsingBadProxyAndHttpResponseCache() throws Exception {
     initResponseCache();
 
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     // The inclusion of a body in the response to a CONNECT is key to reproducing b/6754912.
     MockResponse badProxyResponse = new MockResponse()
         .setSocketPolicy(UPGRADE_TO_SSL_AT_END)
@@ -1001,7 +1020,8 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
     // failure to fail permanently.
     urlFactory.setClient(urlFactory.client().newBuilder()
         .dns(new SingleInetAddressDns())
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .connectionSpecs(Util.immutableList(ConnectionSpec.MODERN_TLS))
         .hostnameVerifier(new RecordingHostnameVerifier())
         .proxy(server.toProxyAddress())
@@ -1016,7 +1036,7 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
     assertEquals("android.com:443", connect.getHeader("Host"));
   }
 
-  private void initResponseCache() throws IOException {
+  private void initResponseCache() {
     cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
     urlFactory.setClient(urlFactory.client().newBuilder()
         .cache(cache)
@@ -1024,18 +1044,18 @@ private void initResponseCache() throws IOException {
   }
 
   /** Test which headers are sent unencrypted to the HTTP proxy. */
-  @Test public void proxyConnectIncludesProxyHeadersOnly()
-      throws IOException, InterruptedException {
+  @Test public void proxyConnectIncludesProxyHeadersOnly() throws Exception {
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.enqueue(
         new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("encrypted response from the origin server"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .proxy(server.toProxyAddress())
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build());
 
@@ -1060,7 +1080,7 @@ private void initResponseCache() throws IOException {
 
   @Test public void proxyAuthenticateOnConnect() throws Exception {
     Authenticator.setDefault(new RecordingAuthenticator());
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.enqueue(new MockResponse().setResponseCode(407)
         .addHeader("Proxy-Authenticate: Basic realm=\"localhost\""));
     server.enqueue(
@@ -1070,7 +1090,8 @@ private void initResponseCache() throws IOException {
     urlFactory.setClient(urlFactory.client().newBuilder()
         .proxyAuthenticator(new JavaNetAuthenticator())
         .proxy(server.toProxyAddress())
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
 
@@ -1095,14 +1116,15 @@ private void initResponseCache() throws IOException {
   // Don't disconnect after building a tunnel with CONNECT
   // http://code.google.com/p/android/issues/detail?id=37221
   @Test public void proxyWithConnectionClose() throws IOException {
-    server.useHttps(sslClient.socketFactory, true);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
     server.enqueue(
         new MockResponse().setSocketPolicy(UPGRADE_TO_SSL_AT_END).clearHeaders());
     server.enqueue(new MockResponse().setBody("this response comes via a proxy"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .proxy(server.toProxyAddress())
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
 
@@ -1114,7 +1136,7 @@ private void initResponseCache() throws IOException {
   }
 
   @Test public void proxyWithConnectionReuse() throws IOException {
-    SSLSocketFactory socketFactory = sslClient.socketFactory;
+    SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
 
     server.useHttps(socketFactory, true);
@@ -1125,7 +1147,7 @@ private void initResponseCache() throws IOException {
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .proxy(server.toProxyAddress())
-        .sslSocketFactory(socketFactory, sslClient.trustManager)
+        .sslSocketFactory(socketFactory, handshakeCertificates.trustManager())
         .hostnameVerifier(hostnameVerifier)
         .build());
     URL url = new URL("https://android.com/foo");
@@ -1154,6 +1176,33 @@ private void initResponseCache() throws IOException {
     in.close();
   }
 
+  @Test public void disconnectDuringConnect_cookieJar() {
+    final AtomicReference<HttpURLConnection> connectionHolder = new AtomicReference<>();
+    class DisconnectingCookieJar implements CookieJar {
+      @Override public void saveFromResponse(HttpUrl url, List<Cookie> cookies) { }
+      @Override
+      public List<Cookie> loadForRequest(HttpUrl url) {
+        connectionHolder.get().disconnect();
+        return Collections.emptyList();
+      }
+    }
+    OkHttpClient client = new okhttp3.OkHttpClient.Builder()
+            .cookieJar(new DisconnectingCookieJar())
+            .build();
+
+    URL url = server.url("path that should never be accessed").url();
+    HttpURLConnection connection = new OkHttpURLConnection(url, client);
+    connectionHolder.set(connection);
+    try {
+      connection.getInputStream();
+      fail("Connection should not be established");
+    } catch (IOException expected) {
+      assertEquals("Canceled", expected.getMessage());
+    } finally {
+      connection.disconnect();
+    }
+  }
+
   @Test public void disconnectBeforeConnect() throws IOException {
     server.enqueue(new MockResponse().setBody("A"));
 
@@ -1163,7 +1212,7 @@ private void initResponseCache() throws IOException {
     assertEquals(200, connection.getResponseCode());
   }
 
-  @SuppressWarnings("deprecation") @Test public void defaultRequestProperty() throws Exception {
+  @SuppressWarnings("deprecation") @Test public void defaultRequestProperty() {
     URLConnection.setDefaultRequestProperty("X-testSetDefaultRequestProperty", "A");
     assertNull(URLConnection.getDefaultRequestProperty("X-setDefaultRequestProperty"));
   }
@@ -1297,7 +1346,7 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
    * This test checks whether connections are gzipped by default. This behavior in not required by
    * the API, so a failure of this test does not imply a bug in the implementation.
    */
-  @Test public void gzipEncodingEnabledByDefault() throws IOException, InterruptedException {
+  @Test public void gzipEncodingEnabledByDefault() throws Exception {
     server.enqueue(new MockResponse()
         .setBody(gzip("ABCABCABC"))
         .addHeader("Content-Encoding: gzip"));
@@ -1363,11 +1412,11 @@ private void testMarkAndReset(TransferKind transferKind) throws IOException {
   private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferKind transferKind,
       boolean tls) throws Exception {
     if (tls) {
-      SSLSocketFactory socketFactory = sslClient.socketFactory;
+      SSLSocketFactory socketFactory = handshakeCertificates.sslSocketFactory();
       RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
       server.useHttps(socketFactory, false);
       urlFactory.setClient(urlFactory.client().newBuilder()
-          .sslSocketFactory(socketFactory, sslClient.trustManager)
+          .sslSocketFactory(socketFactory, handshakeCertificates.trustManager())
           .hostnameVerifier(hostnameVerifier)
           .build());
     }
@@ -1483,7 +1532,7 @@ private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) thr
     assertEquals(0, server.takeRequest().getSequenceNumber()); // Connection is not pooled.
   }
 
-  @Test public void setChunkedStreamingMode() throws IOException, InterruptedException {
+  @Test public void setChunkedStreamingMode() throws Exception {
     server.enqueue(new MockResponse());
 
     String body = "ABCDEFGHIJKLMNOPQ";
@@ -1683,15 +1732,15 @@ private void assertValidRequestMethod(String requestMethod) throws Exception {
     assertEquals(requestMethod, connection.getRequestMethod());
   }
 
-  @Test public void setInvalidRequestMethodLowercase() throws Exception {
+  @Test public void setInvalidRequestMethodLowercase() {
     assertInvalidRequestMethod("get");
   }
 
-  @Test public void setInvalidRequestMethodConnect() throws Exception {
+  @Test public void setInvalidRequestMethodConnect() {
     assertInvalidRequestMethod("CONNECT");
   }
 
-  private void assertInvalidRequestMethod(String requestMethod) throws Exception {
+  private void assertInvalidRequestMethod(String requestMethod) {
     connection = urlFactory.open(server.url("/").url());
     try {
       connection.setRequestMethod(requestMethod);
@@ -1725,7 +1774,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
     assertContent("mp3 data", connection);
   }
 
-  @Test public void cannotSetNegativeFixedLengthStreamingMode() throws Exception {
+  @Test public void cannotSetNegativeFixedLengthStreamingMode() {
     connection = urlFactory.open(server.url("/").url());
     try {
       connection.setFixedLengthStreamingMode(-2);
@@ -1734,7 +1783,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
     }
   }
 
-  @Test public void canSetNegativeChunkedStreamingMode() throws Exception {
+  @Test public void canSetNegativeChunkedStreamingMode() {
     connection = urlFactory.open(server.url("/").url());
     connection.setChunkedStreamingMode(-2);
   }
@@ -1761,7 +1810,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
     }
   }
 
-  @Test public void cannotSetFixedLengthStreamingModeAfterChunkedStreamingMode() throws Exception {
+  @Test public void cannotSetFixedLengthStreamingModeAfterChunkedStreamingMode() {
     connection = urlFactory.open(server.url("/").url());
     connection.setChunkedStreamingMode(1);
     try {
@@ -1771,7 +1820,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
     }
   }
 
-  @Test public void cannotSetChunkedStreamingModeAfterFixedLengthStreamingMode() throws Exception {
+  @Test public void cannotSetChunkedStreamingModeAfterFixedLengthStreamingMode() {
     connection = urlFactory.open(server.url("/").url());
     connection.setFixedLengthStreamingMode(1);
     try {
@@ -1794,11 +1843,12 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
    * http://code.google.com/p/android/issues/detail?id=12860
    */
   private void testSecureStreamingPost(StreamingMode streamingMode) throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("Success!"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
     connection = urlFactory.open(server.url("/").url());
@@ -1896,6 +1946,37 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     }
   }
 
+  @Test public void authenticateWithCharset() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\", charset=\"UTF-8\"")
+        .setBody("Please authenticate with UTF-8."));
+    server.enqueue(new MockResponse().setResponseCode(401)
+        .addHeader("WWW-Authenticate: Basic realm=\"protected area\"")
+        .setBody("Please authenticate with ISO-8859-1."));
+    server.enqueue(new MockResponse()
+        .setBody("Successful auth!"));
+
+    Authenticator.setDefault(new RecordingAuthenticator(
+        new PasswordAuthentication("username", "mÃ¶torhead".toCharArray())));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
+    assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
+
+    // No authorization header for the first request...
+    RecordedRequest request1 = server.takeRequest();
+    assertNull(request1.getHeader("Authorization"));
+
+    // UTF-8 encoding for the first credential.
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("Basic dXNlcm5hbWU6bcO2dG9yaGVhZA==", request2.getHeader("Authorization"));
+
+    // ISO-8859-1 encoding for the second credential.
+    RecordedRequest request3 = server.takeRequest();
+    assertEquals("Basic dXNlcm5hbWU6bfZ0b3JoZWFk", request3.getHeader("Authorization"));
+  }
+
   /** https://code.google.com/p/android/issues/detail?id=74026 */
   @Test public void authenticateWithGetAndTransparentGzip() throws Exception {
     MockResponse pleaseAuthenticate = new MockResponse().setResponseCode(401)
@@ -1978,15 +2059,16 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
     }
   }
 
-  @Test public void redirectedOnHttps() throws IOException, InterruptedException {
-    server.useHttps(sslClient.socketFactory, false);
+  @Test public void redirectedOnHttps() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: /foo")
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("This is the new location!"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
     connection = urlFactory.open(server.url("/").url());
@@ -2000,22 +2082,23 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
     assertEquals("Expected connection reuse", 1, retry.getSequenceNumber());
   }
 
-  @Test public void notRedirectedFromHttpsToHttp() throws IOException, InterruptedException {
-    server.useHttps(sslClient.socketFactory, false);
+  @Test public void notRedirectedFromHttpsToHttp() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: http://anyhost/foo")
         .setBody("This page has moved!"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .followSslRedirects(false)
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build());
     connection = urlFactory.open(server.url("/").url());
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
 
-  @Test public void notRedirectedFromHttpToHttps() throws IOException, InterruptedException {
+  @Test public void notRedirectedFromHttpToHttps() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: https://anyhost/foo")
         .setBody("This page has moved!"));
@@ -2030,13 +2113,14 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
   @Test public void redirectedFromHttpsToHttpFollowingProtocolRedirects() throws Exception {
     server2.enqueue(new MockResponse().setBody("This is insecure HTTP!"));
 
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: " + server2.url("/").url())
         .setBody("This page has moved!"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .followSslRedirects(true)
         .build());
@@ -2050,7 +2134,7 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
   }
 
   @Test public void redirectedFromHttpToHttpsFollowingProtocolRedirects() throws Exception {
-    server2.useHttps(sslClient.socketFactory, false);
+    server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server2.enqueue(new MockResponse().setBody("This is secure HTTPS!"));
 
     server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
@@ -2058,7 +2142,8 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
         .setBody("This page has moved!"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .followSslRedirects(true)
         .build());
@@ -2077,11 +2162,12 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
 
   private void redirectToAnotherOriginServer(boolean https) throws Exception {
     if (https) {
-      server.useHttps(sslClient.socketFactory, false);
-      server2.useHttps(sslClient.socketFactory, false);
+      server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+      server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
       server2.setProtocolNegotiationEnabled(false);
       urlFactory.setClient(urlFactory.client().newBuilder()
-          .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+          .sslSocketFactory(
+              handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
           .hostnameVerifier(new RecordingHostnameVerifier())
           .build());
     }
@@ -2358,15 +2444,15 @@ private void testRedirect(boolean temporary, String method) throws Exception {
 
   @Test public void httpsWithCustomTrustManager() throws Exception {
     RecordingHostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
-    RecordingTrustManager trustManager = new RecordingTrustManager(sslClient.trustManager);
-    SSLContext sslContext = SSLContext.getInstance("TLS");
+    RecordingTrustManager trustManager = new RecordingTrustManager(handshakeCertificates.trustManager());
+    SSLContext sslContext = Platform.get().getSSLContext();
     sslContext.init(null, new TrustManager[] { trustManager }, null);
 
     urlFactory.setClient(urlFactory.client().newBuilder()
         .hostnameVerifier(hostnameVerifier)
         .sslSocketFactory(sslContext.getSocketFactory(), trustManager)
         .build());
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("ABC"));
     server.enqueue(new MockResponse().setBody("DEF"));
     server.enqueue(new MockResponse().setBody("GHI"));
@@ -2377,8 +2463,7 @@ private void testRedirect(boolean temporary, String method) throws Exception {
     assertContent("GHI", urlFactory.open(url));
 
     assertEquals(Arrays.asList("verify " + server.getHostName()), hostnameVerifier.calls);
-    assertEquals(Arrays.asList("checkServerTrusted [CN=" + server.getHostName() + " 1]"),
-        trustManager.calls);
+    assertEquals(Arrays.asList("checkServerTrusted [CN=localhost 1]"), trustManager.calls);
   }
 
   @Test public void getClientRequestTimeout() throws Exception {
@@ -2494,7 +2579,7 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
     }
   }
 
-  @Test public void setChunkedEncodingAsRequestProperty() throws IOException, InterruptedException {
+  @Test public void setChunkedEncodingAsRequestProperty() throws Exception {
     server.enqueue(new MockResponse());
 
     connection = urlFactory.open(server.url("/").url());
@@ -2507,7 +2592,7 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
     assertEquals("ABC", request.getBody().readUtf8());
   }
 
-  @Test public void connectionCloseInRequest() throws IOException, InterruptedException {
+  @Test public void connectionCloseInRequest() throws Exception {
     server.enqueue(new MockResponse()); // server doesn't honor the connection: close header!
     server.enqueue(new MockResponse());
 
@@ -2523,7 +2608,7 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
         server.takeRequest().getSequenceNumber());
   }
 
-  @Test public void connectionCloseInResponse() throws IOException, InterruptedException {
+  @Test public void connectionCloseInResponse() throws Exception {
     server.enqueue(new MockResponse().addHeader("Connection: close"));
     server.enqueue(new MockResponse());
 
@@ -2538,7 +2623,7 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
         server.takeRequest().getSequenceNumber());
   }
 
-  @Test public void connectionCloseWithRedirect() throws IOException, InterruptedException {
+  @Test public void connectionCloseWithRedirect() throws Exception {
     MockResponse response = new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
         .addHeader("Location: /foo")
@@ -2577,7 +2662,7 @@ protected ServerSocket configureServerSocket(ServerSocket serverSocket)
     assertEquals(0, server.takeRequest().getSequenceNumber());
   }
 
-  @Test public void responseCodeDisagreesWithHeaders() throws IOException, InterruptedException {
+  @Test public void responseCodeDisagreesWithHeaders() {
     server.enqueue(new MockResponse()
         .setResponseCode(HttpURLConnection.HTTP_NO_CONTENT)
         .setBody("This body is not allowed!"));
@@ -2643,7 +2728,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
     }
   }
 
-  @Test public void getHeadersThrows() throws IOException {
+  @Test public void getHeadersThrows() {
     server.enqueue(new MockResponse().setSocketPolicy(DISCONNECT_AT_START));
 
     connection = urlFactory.open(server.url("/").url());
@@ -3014,7 +3099,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     assertEquals("", connection.getHeaderField("A"));
   }
 
-  @Test public void emptyRequestHeaderNameIsStrict() throws Exception {
+  @Test public void emptyRequestHeaderNameIsStrict() {
     server.enqueue(new MockResponse().setBody("body"));
     connection = urlFactory.open(server.url("/").url());
     try {
@@ -3034,7 +3119,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     connection.getInputStream().close();
   }
 
-  @Test public void requestHeaderValidationIsStrict() throws Exception {
+  @Test public void requestHeaderValidationIsStrict() {
     connection = urlFactory.open(server.url("/").url());
     try {
       connection.addRequestProperty("a\tb", "Value");
@@ -3108,7 +3193,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     assertNull(server.takeRequest().getHeader("Authorization"));
     assertEquals(credential, server.takeRequest().getHeader("Authorization"));
 
-    assertEquals(Proxy.NO_PROXY, authenticator.onlyProxy());
+    assertEquals(Proxy.NO_PROXY, authenticator.onlyRoute().proxy());
     Response response = authenticator.onlyResponse();
     assertEquals("/private", response.request().url().url().getPath());
     assertEquals(Arrays.asList(new Challenge("Basic", "protected area")), response.challenges());
@@ -3209,14 +3294,14 @@ private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException
     assertContent("A", connection);
   }
 
-  @Test public void http10SelectedProtocol() throws Exception {
+  @Test public void http10SelectedProtocol() {
     server.enqueue(new MockResponse().setStatus("HTTP/1.0 200 OK"));
     connection = urlFactory.open(server.url("/").url());
     List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
     assertEquals(Arrays.asList("http/1.0"), protocolValues);
   }
 
-  @Test public void http11SelectedProtocol() throws Exception {
+  @Test public void http11SelectedProtocol() {
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 OK"));
     connection = urlFactory.open(server.url("/").url());
     List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
@@ -3224,7 +3309,7 @@ private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException
   }
 
   /** For example, empty Protobuf RPC messages end up as a zero-length POST. */
-  @Test public void zeroLengthPost() throws IOException, InterruptedException {
+  @Test public void zeroLengthPost() throws Exception {
     zeroLengthPayload("POST");
   }
 
@@ -3234,7 +3319,7 @@ private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException
   }
 
   /** For example, creating an Amazon S3 bucket ends up as a zero-length POST. */
-  @Test public void zeroLengthPut() throws IOException, InterruptedException {
+  @Test public void zeroLengthPut() throws Exception {
     zeroLengthPayload("PUT");
   }
 
@@ -3243,8 +3328,7 @@ private void setsNegotiatedProtocolHeader(Protocol protocol) throws IOException
     zeroLengthPut();
   }
 
-  private void zeroLengthPayload(String method)
-      throws IOException, InterruptedException {
+  private void zeroLengthPayload(String method) throws Exception {
     server.enqueue(new MockResponse());
     connection = urlFactory.open(server.url("/").url());
     connection.setRequestProperty("Content-Length", "0");
@@ -3280,7 +3364,7 @@ private void zeroLengthPayload(String method)
     assertContent("A", urlFactory.open(server.url("/").url()));
   }
 
-  @Test public void setProtocolsWithoutHttp11() throws Exception {
+  @Test public void setProtocolsWithoutHttp11() {
     try {
       new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.HTTP_2));
       fail();
@@ -3288,7 +3372,7 @@ private void zeroLengthPayload(String method)
     }
   }
 
-  @Test public void setProtocolsWithNull() throws Exception {
+  @Test public void setProtocolsWithNull() {
     try {
       new OkHttpClient.Builder().protocols(Arrays.asList(Protocol.HTTP_1_1, null));
       fail();
@@ -3317,6 +3401,28 @@ private void zeroLengthPayload(String method)
     assertEquals(Long.toString(contentLength), request.getHeader("Content-Length"));
   }
 
+  @Test public void testNoSslFallback() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false /* tunnelProxy */);
+    server.enqueue(new MockResponse().setSocketPolicy(FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setBody("Response that would have needed fallbacks"));
+
+    HttpsURLConnection connection = (HttpsURLConnection) server.url("/").url().openConnection();
+    connection.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (SSLProtocolException expected) {
+      // RI response to the FAIL_HANDSHAKE
+    } catch (SSLHandshakeException expected) {
+      // Android's response to the FAIL_HANDSHAKE
+    } catch (SSLException expected) {
+      // JDK 1.9 response to the FAIL_HANDSHAKE
+      // javax.net.ssl.SSLException: Unexpected handshake message: client_hello
+    } catch (SocketException expected) {
+      // Conscrypt's response to the FAIL_HANDSHAKE
+    }
+  }
+
   /**
    * We had a bug where we attempted to gunzip responses that didn't have a body. This only came up
    * with 304s since that response code can include headers (like "Content-Encoding") without any
@@ -3344,6 +3450,16 @@ private void zeroLengthPayload(String method)
     assertEquals(1, requestB.getSequenceNumber());
   }
 
+  @Test public void nullSSLSocketFactory_throws() throws Exception {
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false /* tunnelProxy */);
+    HttpsURLConnection connection = (HttpsURLConnection) server.url("/").url().openConnection();
+    try {
+      connection.setSSLSocketFactory(null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
   /**
    * We had a bug where we weren't closing Gzip streams on redirects.
    * https://github.com/square/okhttp/issues/441
@@ -3416,7 +3532,7 @@ private void zeroLengthPayload(String method)
 
   @Test public void interceptorsNotInvoked() throws Exception {
     Interceptor interceptor = new Interceptor() {
-      @Override public Response intercept(Chain chain) throws IOException {
+      @Override public Response intercept(Chain chain) {
         throw new AssertionError();
       }
     };
@@ -3484,14 +3600,14 @@ private void zeroLengthPayload(String method)
     testInstanceFollowsRedirects("https://www.google.com/");
   }
 
-  @Test public void setSslSocketFactoryFailsOnJdk9() throws Exception {
+  @Test public void setSslSocketFactoryFailsOnJdk9() {
     assumeTrue(getPlatform().equals("jdk9"));
 
     enableProtocol(Protocol.HTTP_2);
     URL url = server.url("/").url();
     HttpsURLConnection connection = (HttpsURLConnection) urlFactory.open(url);
     try {
-      connection.setSSLSocketFactory(sslClient.socketFactory);
+      connection.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
       fail();
     } catch (UnsupportedOperationException expected) {
     }
@@ -3589,6 +3705,20 @@ private void zeroLengthPayload(String method)
     assertEquals(0, request2.getSequenceNumber());
   }
 
+  @Test public void authenticateNoConnection() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Connection: close")
+        .setResponseCode(401)
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+
+    Authenticator.setDefault(new RecordingAuthenticator(null));
+    urlFactory.setClient(urlFactory.client().newBuilder()
+        .authenticator(new JavaNetAuthenticator())
+        .build());
+    connection = urlFactory.open(server.url("/").url());
+    assertEquals(401, connection.getResponseCode());
+  }
+
   private void testInstanceFollowsRedirects(String spec) throws Exception {
     URL url = new URL(spec);
     HttpURLConnection urlConnection = urlFactory.open(url);
@@ -3627,8 +3757,7 @@ private void assertContent(String expected, HttpURLConnection connection) throws
 
   enum TransferKind {
     CHUNKED() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
-          throws IOException {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setChunkedBody(content, chunkSize);
       }
 
@@ -3668,8 +3797,7 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
   enum ProxyConfig {
     NO_PROXY() {
       @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url) {
         streamHandlerFactory.setClient(streamHandlerFactory.client().newBuilder()
             .proxy(Proxy.NO_PROXY)
             .build());
@@ -3679,8 +3807,7 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
 
     CREATE_ARG() {
       @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url) {
         streamHandlerFactory.setClient(streamHandlerFactory.client().newBuilder()
             .proxy(server.toProxyAddress())
             .build());
@@ -3690,8 +3817,7 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
 
     PROXY_SYSTEM_PROPERTY() {
       @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url) {
         System.setProperty("proxyHost", server.getHostName());
         System.setProperty("proxyPort", Integer.toString(server.getPort()));
         return streamHandlerFactory.open(url);
@@ -3700,8 +3826,7 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
 
     HTTP_PROXY_SYSTEM_PROPERTY() {
       @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url) {
         System.setProperty("http.proxyHost", server.getHostName());
         System.setProperty("http.proxyPort", Integer.toString(server.getPort()));
         return streamHandlerFactory.open(url);
@@ -3710,8 +3835,7 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
 
     HTTPS_PROXY_SYSTEM_PROPERTY() {
       @Override public HttpURLConnection connect(
-          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url)
-          throws IOException {
+          MockWebServer server, OkUrlFactory streamHandlerFactory, URL url) {
         System.setProperty("https.proxyHost", server.getHostName());
         System.setProperty("https.proxyPort", Integer.toString(server.getPort()));
         return streamHandlerFactory.open(url);
@@ -3727,7 +3851,7 @@ public abstract HttpURLConnection connect(
     private final List<String> calls = new ArrayList<>();
     private final X509TrustManager delegate;
 
-    public RecordingTrustManager(X509TrustManager delegate) {
+    RecordingTrustManager(X509TrustManager delegate) {
       this.delegate = delegate;
     }
 
@@ -3735,13 +3859,11 @@ public RecordingTrustManager(X509TrustManager delegate) {
       return delegate.getAcceptedIssuers();
     }
 
-    public void checkClientTrusted(X509Certificate[] chain, String authType)
-        throws CertificateException {
+    public void checkClientTrusted(X509Certificate[] chain, String authType) {
       calls.add("checkClientTrusted " + certificatesToString(chain));
     }
 
-    public void checkServerTrusted(X509Certificate[] chain, String authType)
-        throws CertificateException {
+    public void checkServerTrusted(X509Certificate[] chain, String authType) {
       calls.add("checkServerTrusted " + certificatesToString(chain));
     }
 
@@ -3760,11 +3882,12 @@ private String certificatesToString(X509Certificate[] certificates) {
    */
   private void enableProtocol(Protocol protocol) {
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .protocols(Arrays.asList(protocol, Protocol.HTTP_1_1))
         .build());
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.setProtocolNegotiationEnabled(true);
     server.setProtocols(urlFactory.client().protocols());
   }
@@ -3775,7 +3898,7 @@ private void enableProtocol(Protocol protocol) {
    * for details.
    */
   private FallbackTestClientSocketFactory suppressTlsFallbackClientSocketFactory() {
-    return new FallbackTestClientSocketFactory(sslClient.socketFactory);
+    return new FallbackTestClientSocketFactory(handshakeCertificates.sslSocketFactory());
   }
 
   private String getPlatform() {
diff --git a/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java b/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
index 56611be40a..5875bc3970 100644
--- a/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
+++ b/okhttp-tests/src/test/java/okhttp3/UrlComponentEncodingTester.java
@@ -230,7 +230,7 @@ public UrlComponentEncodingTester test(Component component) {
   private void testParseAlreadyEncoded(int codePoint, Encoding encoding, Component component) {
     String encoded = encoding.encode(codePoint);
     String urlString = component.urlString(encoded);
-    HttpUrl url = HttpUrl.parse(urlString);
+    HttpUrl url = HttpUrl.get(urlString);
     if (!component.encodedValue(url).equals(encoded)) {
       fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
     }
@@ -238,7 +238,7 @@ private void testParseAlreadyEncoded(int codePoint, Encoding encoding, Component
 
   private void testEncodeAndDecode(int codePoint, Component component) {
     String expected = Encoding.IDENTITY.encode(codePoint);
-    HttpUrl.Builder builder = HttpUrl.parse("http://host/").newBuilder();
+    HttpUrl.Builder builder = HttpUrl.get("http://host/").newBuilder();
     component.set(builder, expected);
     HttpUrl url = builder.build();
     String actual = component.get(url);
@@ -252,7 +252,7 @@ private void testParseOriginal(int codePoint, Encoding encoding, Component compo
     if (encoding != Encoding.PERCENT) return;
     String identity = Encoding.IDENTITY.encode(codePoint);
     String urlString = component.urlString(identity);
-    HttpUrl url = HttpUrl.parse(urlString);
+    HttpUrl url = HttpUrl.get(urlString);
 
     String s = component.encodedValue(url);
     if (!s.equals(encoded)) {
@@ -262,7 +262,7 @@ private void testParseOriginal(int codePoint, Encoding encoding, Component compo
 
   private void testToUrl(int codePoint, Encoding encoding, Component component) {
     String encoded = encoding.encode(codePoint);
-    HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
+    HttpUrl httpUrl = HttpUrl.get(component.urlString(encoded));
     URL javaNetUrl = httpUrl.url();
     if (!javaNetUrl.toString().equals(javaNetUrl.toString())) {
       fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
@@ -271,7 +271,7 @@ private void testToUrl(int codePoint, Encoding encoding, Component component) {
 
   private void testFromUrl(int codePoint, Encoding encoding, Component component) {
     String encoded = encoding.encode(codePoint);
-    HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
+    HttpUrl httpUrl = HttpUrl.get(component.urlString(encoded));
     HttpUrl toAndFromJavaNetUrl = HttpUrl.get(httpUrl.url());
     if (!toAndFromJavaNetUrl.equals(httpUrl)) {
       fail(Util.format("Encoding %s %#x using %s", component, codePoint, encoding));
@@ -282,7 +282,7 @@ private void testUri(
       int codePoint, Encoding encoding, Component component, boolean uriEscaped) {
     String string = new String(new int[] {codePoint}, 0, 1);
     String encoded = encoding.encode(codePoint);
-    HttpUrl httpUrl = HttpUrl.parse(component.urlString(encoded));
+    HttpUrl httpUrl = HttpUrl.get(component.urlString(encoded));
     URI uri = httpUrl.uri();
     HttpUrl toAndFromUri = HttpUrl.get(uri);
     if (uriEscaped) {
@@ -402,6 +402,25 @@ public String encode(int codePoint) {
         return query.substring(1, query.length() - 1);
       }
     },
+    QUERY_VALUE {
+      @Override public String urlString(String value) {
+        return "http://example.com/?q=a" + value + "z";
+      }
+
+      @Override public String encodedValue(HttpUrl url) {
+        String query = url.encodedQuery();
+        return query.substring(3, query.length() - 1);
+      }
+
+      @Override public void set(HttpUrl.Builder builder, String value) {
+        builder.addQueryParameter("q", "a" + value + "z");
+      }
+
+      @Override public String get(HttpUrl url) {
+        String value = url.queryParameter("q");
+        return value.substring(1, value.length() - 1);
+      }
+    },
     FRAGMENT {
       @Override public String urlString(String value) {
         return "http://example.com/#a" + value + "z";
diff --git a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
index a15c57ea35..605d606fb0 100644
--- a/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/WebPlatformUrlTest.java
@@ -98,7 +98,7 @@ private void testHttpUrl() {
     if (testData.base.equals("about:blank")) {
       url = HttpUrl.parse(testData.input);
     } else {
-      HttpUrl baseUrl = HttpUrl.parse(testData.base);
+      HttpUrl baseUrl = HttpUrl.get(testData.base);
       url = baseUrl.resolve(testData.input);
     }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java b/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
index 7d9d2bfe6a..2464a910b4 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/RecordingOkAuthenticator.java
@@ -16,7 +16,6 @@
 package okhttp3.internal;
 
 import java.io.IOException;
-import java.net.Proxy;
 import java.util.ArrayList;
 import java.util.List;
 import okhttp3.Authenticator;
@@ -26,7 +25,7 @@
 
 public final class RecordingOkAuthenticator implements Authenticator {
   public final List<Response> responses = new ArrayList<>();
-  public final List<Proxy> proxies = new ArrayList<>();
+  public final List<Route> routes = new ArrayList<>();
   public final String credential;
 
   public RecordingOkAuthenticator(String credential) {
@@ -38,14 +37,19 @@ public Response onlyResponse() {
     return responses.get(0);
   }
 
-  public Proxy onlyProxy() {
-    if (proxies.size() != 1) throw new IllegalStateException();
-    return proxies.get(0);
+  public Route onlyRoute() {
+    if (routes.size() != 1) throw new IllegalStateException();
+    return routes.get(0);
   }
 
   @Override public Request authenticate(Route route, Response response) throws IOException {
+    if (route == null) throw new NullPointerException("route == null");
+    if (response == null) throw new NullPointerException("response == null");
+
     responses.add(response);
-    proxies.add(route.proxy());
+    routes.add(route);
+
+    if (credential == null) return null;
     String header = response.code() == 407 ? "Proxy-Authorization" : "Authorization";
     return response.request().newBuilder()
         .addHeader(header, credential)
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/UtilTest.java b/okhttp-tests/src/test/java/okhttp3/internal/UtilTest.java
new file mode 100644
index 0000000000..af92f5eb84
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/UtilTest.java
@@ -0,0 +1,48 @@
+ /*
+  * Copyright (C) 2012 The Android Open Source Project
+  *
+  * Licensed under the Apache License, Version 2.0 (the "License");
+  * you may not use this file except in compliance with the License.
+  * You may obtain a copy of the License at
+  *
+  *      http://www.apache.org/licenses/LICENSE-2.0
+  *
+  * Unless required by applicable law or agreed to in writing, software
+  * distributed under the License is distributed on an "AS IS" BASIS,
+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  * See the License for the specific language governing permissions and
+  * limitations under the License.
+  */
+package okhttp3.internal;
+
+import java.util.Collections;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.fail;
+
+ public class UtilTest {
+  @Test public void testAssertionError() {
+    NullPointerException nullPointerException = new NullPointerException();
+    AssertionError ae = Util.assertionError("npe", nullPointerException);
+    assertSame(nullPointerException, ae.getCause());
+    assertEquals("npe", ae.getMessage());
+  }
+
+  @Test public void immutableMap() {
+    Map<String, String> map = new LinkedHashMap<>();
+    map.put("a", "A");
+    Map<String, String> immutableCopy = Util.immutableMap(map);
+    assertEquals(immutableCopy, Collections.singletonMap("a", "A"));
+    map.clear();
+    assertEquals(immutableCopy, Collections.singletonMap("a", "A"));
+    try {
+      immutableCopy.clear();
+      fail();
+    } catch (UnsupportedOperationException expected) {
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java b/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
index d4ae88b84a..04ba57126b 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/cache/DiskLruCacheTest.java
@@ -33,6 +33,7 @@
 import okio.Source;
 import org.junit.After;
 import org.junit.Before;
+import org.junit.Ignore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
@@ -93,6 +94,36 @@ private void createNewCacheWithSize(int maxSize) throws IOException {
     assertJournalEquals();
   }
 
+  @Test public void recoverFromInitializationFailure() throws IOException {
+    // Add an uncommitted entry. This will get detected on initialization, and the cache will
+    // attempt to delete the file. Do not explicitly close the cache here so the entry is left as
+    // incomplete.
+    DiskLruCache.Editor creator = cache.edit("k1");
+    BufferedSink sink = Okio.buffer(creator.newSink(0));
+    sink.writeUtf8("Hello");
+    sink.close();
+
+    // Simulate a severe filesystem failure on the first initialization.
+    fileSystem.setFaultyDelete(new File(cacheDir, "k1.0.tmp"), true);
+    fileSystem.setFaultyDelete(cacheDir, true);
+
+    cache = new DiskLruCache(fileSystem, cacheDir, appVersion, 2, Integer.MAX_VALUE, executor);
+    toClose.add(cache);
+
+    try {
+      cache.get("k1");
+      fail();
+    } catch (IOException expected) {
+    }
+
+    // Now let it operate normally.
+    fileSystem.setFaultyDelete(new File(cacheDir, "k1.0.tmp"), false);
+    fileSystem.setFaultyDelete(cacheDir, false);
+
+    DiskLruCache.Snapshot snapshot = cache.get("k1");
+    assertNull(snapshot);
+  }
+
   @Test public void validateKey() throws Exception {
     String key = null;
     try {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
index b0b06e9f87..e366e4081b 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/ConnectionSpecSelectorTest.java
@@ -25,9 +25,10 @@
 import okhttp3.ConnectionSpec;
 import okhttp3.TlsVersion;
 import okhttp3.internal.Internal;
-import okhttp3.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
 import org.junit.Test;
 
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -40,7 +41,7 @@
   public static final SSLHandshakeException RETRYABLE_EXCEPTION = new SSLHandshakeException(
       "Simulated handshake exception");
 
-  private SslClient sslClient = SslClient.localhost();
+  private HandshakeCertificates handshakeCertificates = localhost();
 
   @Test
   public void nonRetryableIOException() throws Exception {
@@ -121,7 +122,7 @@ private static ConnectionSpecSelector createConnectionSpecSelector(
   }
 
   private SSLSocket createSocketWithEnabledProtocols(TlsVersion... tlsVersions) throws IOException {
-    SSLSocket socket = (SSLSocket) sslClient.socketFactory.createSocket();
+    SSLSocket socket = (SSLSocket) handshakeCertificates.sslSocketFactory().createSocket();
     socket.setEnabledProtocols(javaNames(tlsVersions));
     return socket;
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
index 209d79d5c5..44e939aaea 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteExceptionTest.java
@@ -18,6 +18,7 @@
 import java.io.IOException;
 import org.junit.Test;
 
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertSame;
 
 public class RouteExceptionTest {
@@ -25,6 +26,7 @@
   @Test public void getConnectionIOException_single() {
     IOException firstException = new IOException();
     RouteException re = new RouteException(firstException);
+    assertSame(firstException, re.getFirstConnectException());
     assertSame(firstException, re.getLastConnectException());
   }
 
@@ -36,12 +38,13 @@
     re.addConnectException(secondException);
     re.addConnectException(thirdException);
 
-    IOException connectionIOException = re.getLastConnectException();
-    assertSame(thirdException, connectionIOException);
-    Throwable[] thirdSuppressedExceptions = thirdException.getSuppressed();
-    assertSame(secondException, thirdSuppressedExceptions[0]);
+    IOException connectionIOException = re.getFirstConnectException();
+    assertSame(firstException, connectionIOException);
+    Throwable[] suppressedExceptions = connectionIOException.getSuppressed();
+    assertEquals(2, suppressedExceptions.length);
+    assertSame(secondException, suppressedExceptions[0]);
+    assertSame(thirdException, suppressedExceptions[1]);
 
-    Throwable[] secondSuppressedException = secondException.getSuppressed();
-    assertSame(firstException, secondSuppressedException[0]);
+    assertSame(thirdException, re.getLastConnectException());
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
index cecd9daa8f..6c4a0d2d9a 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/connection/RouteSelectorTest.java
@@ -23,7 +23,6 @@
 import java.net.SocketAddress;
 import java.net.URI;
 import java.net.UnknownHostException;
-import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.NoSuchElementException;
@@ -34,18 +33,21 @@
 import okhttp3.Address;
 import okhttp3.Authenticator;
 import okhttp3.ConnectionSpec;
+import okhttp3.EventListener;
 import okhttp3.FakeDns;
 import okhttp3.Protocol;
 import okhttp3.Route;
 import okhttp3.internal.Util;
 import okhttp3.internal.http.RecordingProxySelector;
-import okhttp3.internal.tls.SslClient;
+import okhttp3.tls.HandshakeCertificates;
 import org.junit.Before;
 import org.junit.Test;
 
 import static java.net.Proxy.NO_PROXY;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
@@ -67,8 +69,8 @@
   private int uriPort = 1003;
 
   private SocketFactory socketFactory;
-  private final SslClient sslClient = SslClient.localhost();
-  private final SSLSocketFactory sslSocketFactory = sslClient.socketFactory;
+  private final HandshakeCertificates handshakeCertificates = localhost();
+  private final SSLSocketFactory sslSocketFactory = handshakeCertificates.sslSocketFactory();
   private HostnameVerifier hostnameVerifier;
 
   private final Authenticator authenticator = Authenticator.NONE;
@@ -84,12 +86,20 @@
 
   @Test public void singleRoute() throws Exception {
     Address address = httpAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
 
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 1));
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
+    dns.set(uriHost, dns.allocate(1));
+    RouteSelector.Selection selection = routeSelector.next();
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
     dns.assertRequests(uriHost);
+    assertFalse(selection.hasNext());
+    try {
+      selection.next();
+      fail();
+    } catch (NoSuchElementException expected) {
+    }
 
     assertFalse(routeSelector.hasNext());
     try {
@@ -101,14 +111,25 @@
 
   @Test public void singleRouteReturnsFailedRoute() throws Exception {
     Address address = httpAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
 
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 1));
-    Route route = routeSelector.next();
+    dns.set(uriHost, dns.allocate(1));
+    RouteSelector.Selection selection = routeSelector.next();
+    Route route = selection.next();
     routeDatabase.failed(route);
-    routeSelector = new RouteSelector(address, routeDatabase);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
+    routeSelector = new RouteSelector(address, routeDatabase, null, EventListener.NONE);
+    selection = routeSelector.next();
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
+    assertFalse(selection.hasNext());
+
+    try {
+      selection.next();
+      fail();
+    } catch (NoSuchElementException expected) {
+    }
+
     assertFalse(routeSelector.hasNext());
     try {
       routeSelector.next();
@@ -120,13 +141,16 @@
   @Test public void explicitProxyTriesThatProxysAddressesOnly() throws Exception {
     Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
         authenticator, proxyA, protocols, connectionSpecs, proxySelector);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
 
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 2));
-    assertRoute(routeSelector.next(), address, proxyA, dns.address(0), proxyAPort);
-    assertRoute(routeSelector.next(), address, proxyA, dns.address(1), proxyAPort);
+    dns.set(proxyAHost, dns.allocate(2));
+    RouteSelector.Selection selection = routeSelector.next();
+    assertRoute(selection.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
+    assertRoute(selection.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
 
+    assertFalse(selection.hasNext());
     assertFalse(routeSelector.hasNext());
     dns.assertRequests(proxyAHost);
     proxySelector.assertRequests(); // No proxy selector requests!
@@ -135,13 +159,16 @@
   @Test public void explicitDirectProxy() throws Exception {
     Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
         authenticator, NO_PROXY, protocols, connectionSpecs, proxySelector);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
 
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 2));
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(1), uriPort);
+    dns.set(uriHost, dns.allocate(2));
+    RouteSelector.Selection selection = routeSelector.next();
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
 
+    assertFalse(selection.hasNext());
     assertFalse(routeSelector.hasNext());
     dns.assertRequests(uriHost);
     proxySelector.assertRequests(); // No proxy selector requests!
@@ -162,24 +189,30 @@
 
     Address address = new Address(uriHost, uriPort, dns, socketFactory, null, null, null,
         authenticator, null, protocols, connectionSpecs, nullProxySelector);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 1));
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
+    dns.set(uriHost, dns.allocate(1));
+    RouteSelector.Selection selection = routeSelector.next();
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
     dns.assertRequests(uriHost);
 
+    assertFalse(selection.hasNext());
     assertFalse(routeSelector.hasNext());
   }
 
   @Test public void proxySelectorReturnsNoProxies() throws Exception {
     Address address = httpAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
 
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 2));
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(1), uriPort);
+    dns.set(uriHost, dns.allocate(2));
+    RouteSelector.Selection selection = routeSelector.next();
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
 
+    assertFalse(selection.hasNext());
     assertFalse(routeSelector.hasNext());
     dns.assertRequests(uriHost);
     proxySelector.assertRequests(address.url().uri());
@@ -190,21 +223,26 @@
 
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
     proxySelector.assertRequests(address.url().uri());
 
     // First try the IP addresses of the first proxy, in sequence.
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 2));
-    assertRoute(routeSelector.next(), address, proxyA, dns.address(0), proxyAPort);
-    assertRoute(routeSelector.next(), address, proxyA, dns.address(1), proxyAPort);
+    dns.set(proxyAHost, dns.allocate(2));
+    RouteSelector.Selection selection1 = routeSelector.next();
+    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
+    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
     dns.assertRequests(proxyAHost);
+    assertFalse(selection1.hasNext());
 
     // Next try the IP address of the second proxy.
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(254, 1));
-    assertRoute(routeSelector.next(), address, proxyB, dns.address(0), proxyBPort);
+    dns.set(proxyBHost, dns.allocate(1));
+    RouteSelector.Selection selection2 = routeSelector.next();
+    assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
     dns.assertRequests(proxyBHost);
+    assertFalse(selection2.hasNext());
 
     // No more proxies to try.
     assertFalse(routeSelector.hasNext());
@@ -214,15 +252,18 @@
     Address address = httpAddress();
 
     proxySelector.proxies.add(NO_PROXY);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
     proxySelector.assertRequests(address.url().uri());
 
     // Only the origin server will be attempted.
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 1));
-    assertRoute(routeSelector.next(), address, NO_PROXY, dns.address(0), uriPort);
+    dns.set(uriHost, dns.allocate(1));
+    RouteSelector.Selection selection = routeSelector.next();
+    assertRoute(selection.next(), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
     dns.assertRequests(uriHost);
 
+    assertFalse(selection.hasNext());
     assertFalse(routeSelector.hasNext());
   }
 
@@ -232,16 +273,19 @@
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
     proxySelector.proxies.add(proxyA);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
     proxySelector.assertRequests(address.url().uri());
 
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 1));
-    assertRoute(routeSelector.next(), address, proxyA, dns.address(0), proxyAPort);
+    dns.set(proxyAHost, dns.allocate(1));
+    RouteSelector.Selection selection1 = routeSelector.next();
+    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
     dns.assertRequests(proxyAHost);
+    assertFalse(selection1.hasNext());
 
     assertTrue(routeSelector.hasNext());
-    dns.unknownHost();
+    dns.clear(proxyBHost);
     try {
       routeSelector.next();
       fail();
@@ -250,10 +294,12 @@
     dns.assertRequests(proxyBHost);
 
     assertTrue(routeSelector.hasNext());
-    dns.addresses(makeFakeAddresses(255, 1));
-    assertRoute(routeSelector.next(), address, proxyA, dns.address(0), proxyAPort);
+    dns.set(proxyAHost, dns.allocate(1));
+    RouteSelector.Selection selection2 = routeSelector.next();
+    assertRoute(selection2.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
     dns.assertRequests(proxyAHost);
 
+    assertFalse(selection2.hasNext());
     assertFalse(routeSelector.hasNext());
   }
 
@@ -261,52 +307,112 @@
     Address address = httpsAddress();
     proxySelector.proxies.add(proxyA);
     proxySelector.proxies.add(proxyB);
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
 
     // Proxy A
-    dns.addresses(makeFakeAddresses(255, 2));
-    assertRoute(routeSelector.next(), address, proxyA, dns.address(0), proxyAPort);
+    dns.set(proxyAHost, dns.allocate(2));
+    RouteSelector.Selection selection1 = routeSelector.next();
+    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
     dns.assertRequests(proxyAHost);
-    assertRoute(routeSelector.next(), address, proxyA, dns.address(1), proxyAPort);
+    assertRoute(selection1.next(), address, proxyA, dns.lookup(proxyAHost, 1), proxyAPort);
+    assertFalse(selection1.hasNext());
 
     // Proxy B
-    dns.addresses(makeFakeAddresses(254, 2));
-    assertRoute(routeSelector.next(), address, proxyB, dns.address(0), proxyBPort);
+    dns.set(proxyBHost, dns.allocate(2));
+    RouteSelector.Selection selection2 = routeSelector.next();
+    assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
     dns.assertRequests(proxyBHost);
-    assertRoute(routeSelector.next(), address, proxyB, dns.address(1), proxyBPort);
+    assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 1), proxyBPort);
+    assertFalse(selection2.hasNext());
 
     // No more proxies to attempt.
     assertFalse(routeSelector.hasNext());
   }
 
-  @Test public void failedRoutesAreLast() throws Exception {
+  @Test public void failedRouteWithSingleProxy() throws Exception {
     Address address = httpsAddress();
-    RouteSelector routeSelector = new RouteSelector(address, routeDatabase);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
 
     final int numberOfAddresses = 2;
-    dns.addresses(makeFakeAddresses(255, numberOfAddresses));
+    dns.set(uriHost, dns.allocate(numberOfAddresses));
 
     // Extract the regular sequence of routes from selector.
-    List<Route> regularRoutes = new ArrayList<>();
-    while (routeSelector.hasNext()) {
-      regularRoutes.add(routeSelector.next());
-    }
+    RouteSelector.Selection selection1 = routeSelector.next();
+    List<Route> regularRoutes = selection1.getAll();
 
     // Check that we do indeed have more than one route.
     assertEquals(numberOfAddresses, regularRoutes.size());
     // Add first regular route as failed.
     routeDatabase.failed(regularRoutes.get(0));
     // Reset selector
-    routeSelector = new RouteSelector(address, routeDatabase);
+    routeSelector = new RouteSelector(address, routeDatabase, null, EventListener.NONE);
 
-    List<Route> routesWithFailedRoute = new ArrayList<>();
-    while (routeSelector.hasNext()) {
-      routesWithFailedRoute.add(routeSelector.next());
-    }
+    // The first selection prioritizes the non-failed routes.
+    RouteSelector.Selection selection2 = routeSelector.next();
+    assertEquals(regularRoutes.get(1), selection2.next());
+    assertFalse(selection2.hasNext());
+
+    // The second selection will contain all failed routes.
+    RouteSelector.Selection selection3 = routeSelector.next();
+    assertEquals(regularRoutes.get(0), selection3.next());
+    assertFalse(selection3.hasNext());
 
-    assertEquals(regularRoutes.get(0),
-        routesWithFailedRoute.get(routesWithFailedRoute.size() - 1));
-    assertEquals(regularRoutes.size(), routesWithFailedRoute.size());
+    assertFalse(routeSelector.hasNext());
+  }
+
+  @Test public void failedRouteWithMultipleProxies() throws IOException {
+    Address address = httpsAddress();
+    proxySelector.proxies.add(proxyA);
+    proxySelector.proxies.add(proxyB);
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
+
+    dns.set(proxyAHost, dns.allocate(1));
+    dns.set(proxyBHost, dns.allocate(1));
+
+    // Mark the ProxyA route as failed.
+    RouteSelector.Selection selection = routeSelector.next();
+    dns.assertRequests(proxyAHost);
+    Route route = selection.next();
+    assertRoute(route, address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
+    routeDatabase.failed(route);
+
+    routeSelector = new RouteSelector(address, routeDatabase, null, EventListener.NONE);
+
+    // Confirm we enumerate both proxies, giving preference to the route from ProxyB.
+    RouteSelector.Selection selection2 = routeSelector.next();
+    dns.assertRequests(proxyAHost, proxyBHost);
+    assertRoute(selection2.next(), address, proxyB, dns.lookup(proxyBHost, 0), proxyBPort);
+    assertFalse(selection2.hasNext());
+
+    // Confirm the last selection contains the postponed route from ProxyA.
+    RouteSelector.Selection selection3 = routeSelector.next();
+    dns.assertRequests();
+    assertRoute(selection3.next(), address, proxyA, dns.lookup(proxyAHost, 0), proxyAPort);
+    assertFalse(selection3.hasNext());
+
+    assertFalse(routeSelector.hasNext());
+  }
+
+  @Test public void queryForAllSelectedRoutes() throws IOException {
+    Address address = httpAddress();
+    RouteSelector routeSelector = new RouteSelector(address, routeDatabase, null,
+        EventListener.NONE);
+
+    dns.set(uriHost, dns.allocate(2));
+    RouteSelector.Selection selection = routeSelector.next();
+    dns.assertRequests(uriHost);
+
+    List<Route> routes = selection.getAll();
+    assertRoute(routes.get(0), address, NO_PROXY, dns.lookup(uriHost, 0), uriPort);
+    assertRoute(routes.get(1), address, NO_PROXY, dns.lookup(uriHost, 1), uriPort);
+
+    assertSame(routes.get(0), selection.next());
+    assertSame(routes.get(1), selection.next());
+    assertFalse(selection.hasNext());
+    assertFalse(routeSelector.hasNext());
   }
 
   @Test public void getHostString() throws Exception {
@@ -351,17 +457,4 @@ private Address httpsAddress() {
     return new Address(uriHost, uriPort, dns, socketFactory, sslSocketFactory,
         hostnameVerifier, null, authenticator, null, protocols, connectionSpecs, proxySelector);
   }
-
-  private static List<InetAddress> makeFakeAddresses(int prefix, int count) {
-    try {
-      List<InetAddress> result = new ArrayList<>();
-      for (int i = 0; i < count; i++) {
-        result.add(InetAddress.getByAddress(
-            new byte[] {(byte) prefix, (byte) 0, (byte) 0, (byte) i}));
-      }
-      return result;
-    } catch (UnknownHostException e) {
-      throw new AssertionError();
-    }
-  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java b/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
index bd4038d4a1..fb37e7e491 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/RecordingProxySelector.java
@@ -45,9 +45,8 @@ public void assertRequests(URI... expectedUris) {
 
   @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
     InetSocketAddress socketAddress = (InetSocketAddress) sa;
-    failures.add(
-        Util.format("%s %s:%d %s", uri, socketAddress.getHostName(), socketAddress.getPort(),
-            ioe.getMessage()));
+    failures.add(Util.format("%s %s:%d %s",
+        uri, socketAddress, socketAddress.getPort(), ioe.getMessage()));
   }
 
   @Override public String toString() {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
index 9ac3b93ecc..e162633f74 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http/ThreadInterruptTest.java
@@ -36,6 +36,7 @@
 import org.junit.Test;
 
 import static okhttp3.TestUtil.defaultClient;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class ThreadInterruptTest {
@@ -92,6 +93,9 @@ protected Socket configureSocket(Socket socket) throws IOException {
       }
       fail("Expected thread to be interrupted");
     } catch (InterruptedIOException expected) {
+      // TODO(jwilson): test that we're interrupted once Okio retains interrupted state.
+      //     https://github.com/square/okhttp/issues/3107
+      if (false) assertTrue(Thread.interrupted());
     }
 
     connection.disconnect();
@@ -115,6 +119,9 @@ protected Socket configureSocket(Socket socket) throws IOException {
       }
       fail("Expected thread to be interrupted");
     } catch (InterruptedIOException expected) {
+      // TODO(jwilson): test that we're interrupted once Okio retains interrupted state.
+      //     https://github.com/square/okhttp/issues/3107
+      if (false) assertTrue(Thread.interrupted());
     }
 
     responseBody.close();
@@ -128,7 +135,7 @@ private void interruptLater(final int delayMillis) {
           sleep(delayMillis);
           toInterrupt.interrupt();
         } catch (InterruptedException e) {
-          throw new RuntimeException(e);
+          throw new AssertionError(e);
         }
       }
     };
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java
index 6a90ac0458..454f5eec99 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HpackTest.java
@@ -484,6 +484,35 @@
     assertEquals(headerEntries(":method", "GET"), hpackReader.getAndResetHeaderList());
   }
 
+  @Test public void readLiteralHeaderWithIncrementalIndexingStaticName() throws IOException {
+    bytesIn.writeByte(0x7d); // == Literal indexed ==
+    // Indexed name (idx = 60) -> "www-authenticate"
+    bytesIn.writeByte(0x05); // Literal value (len = 5)
+    bytesIn.writeUtf8("Basic");
+
+    hpackReader.readHeaders();
+
+    assertEquals(Arrays.asList(new Header("www-authenticate", "Basic")), hpackReader.getAndResetHeaderList());
+  }
+
+  @Test public void readLiteralHeaderWithIncrementalIndexingDynamicName() throws IOException {
+    bytesIn.writeByte(0x40);
+    bytesIn.writeByte(0x0a); // Literal name (len = 10)
+    bytesIn.writeUtf8("custom-foo");
+    bytesIn.writeByte(0x05); // Literal value (len = 5)
+    bytesIn.writeUtf8("Basic");
+
+    bytesIn.writeByte(0x7e);
+    bytesIn.writeByte(0x06); // Literal value (len = 6)
+    bytesIn.writeUtf8("Basic2");
+
+    hpackReader.readHeaders();
+
+    assertEquals(
+        Arrays.asList(new Header("custom-foo", "Basic"), new Header("custom-foo", "Basic2")),
+        hpackReader.getAndResetHeaderList());
+  }
+
   /**
    * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-12#appendix-C.2
    */
@@ -501,6 +530,27 @@
     checkReadThirdRequestWithoutHuffman();
   }
 
+  @Test public void readFailingRequestExample() throws IOException {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+    // idx = 2 -> :method: GET
+    bytesIn.writeByte(0x86); // == Indexed - Add ==
+    // idx = 7 -> :scheme: http
+    bytesIn.writeByte(0x84); // == Indexed - Add ==
+
+    bytesIn.writeByte(0x7f); // == Bad index! ==
+
+    // Indexed name (idx = 4) -> :authority
+    bytesIn.writeByte(0x0f); // Literal value (len = 15)
+    bytesIn.writeUtf8("www.example.com");
+
+    try {
+      hpackReader.readHeaders();
+      fail();
+    } catch (IOException e) {
+      assertEquals("Header index too large 78", e.getMessage());
+    }
+  }
+
   private void firstRequestWithoutHuffman() {
     bytesIn.writeByte(0x82); // == Indexed - Add ==
                              // idx = 2 -> :method: GET
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
index 18fcab5a12..2f18ab591b 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2ConnectionTest.java
@@ -83,28 +83,6 @@
     assertTrue(ping.ack);
   }
 
-  @Test public void clientPingsServerHttp2() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // PING
-    peer.sendFrame().ping(true, 1, 5);
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Ping ping = connection.ping();
-    assertTrue(ping.roundTripTime() > 0);
-    assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
-
-    // verify the peer received what was expected
-    InFrame pingFrame = peer.takeFrame();
-    assertEquals(0, pingFrame.streamId);
-    assertEquals(1, pingFrame.payload1);
-    assertEquals(0x4f4b6f6b, pingFrame.payload2); // connection.ping() sets this.
-    assertFalse(pingFrame.ack);
-  }
-
   @Test public void peerHttp2ServerLowersInitialWindowSize() throws Exception {
     Settings initial = new Settings();
     initial.set(INITIAL_WINDOW_SIZE, 1684);
@@ -130,7 +108,6 @@
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
 
     assertEquals(3368, connection.peerSettings.getInitialWindowSize());
-    assertEquals(1684, connection.bytesLeftInWriteWindow); // initial wasn't affected.
     // New Stream is has the most recent initial window size.
     assertEquals(3368, stream.bytesLeftInWriteWindow);
   }
@@ -195,7 +172,7 @@
 
     // Play it back.
     Http2Connection connection = connect(peer);
-    connection.ping().roundTripTime(); // Ensure the SETTINGS have been received.
+    connection.writePingAndAwaitPong(); // Ensure the SETTINGS have been received.
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
     BufferedSink sink = Okio.buffer(stream.getSink());
     sink.writeUtf8("abcdefghi");
@@ -215,6 +192,39 @@
     assertTrue(Arrays.equals("fghi".getBytes("UTF-8"), data2.data));
   }
 
+  /**
+   * Confirm that we account for discarded data frames. It's possible that data frames are in-flight
+   * just prior to us canceling a stream.
+   */
+  @Test public void discardedDataFramesAreCounted() throws Exception {
+    // Write the mocking script.
+    peer.sendFrame().settings(new Settings());
+    peer.acceptFrame(); // ACK
+    peer.acceptFrame(); // SYN_STREAM 3
+    peer.sendFrame().headers(3, headerEntries("a", "apple"));
+    peer.sendFrame().data(false, 3, data(1024), 1024);
+    peer.acceptFrame(); // RST_STREAM
+    peer.sendFrame().data(true, 3, data(1024), 1024);
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    Http2Connection connection = connect(peer);
+    Http2Stream stream1 = connection.newStream(headerEntries("b", "bark"), false);
+    Source source = stream1.getSource();
+    Buffer buffer = new Buffer();
+    while (buffer.size() != 1024) source.read(buffer, 1024);
+    stream1.close(ErrorCode.CANCEL);
+
+    InFrame frame1 = peer.takeFrame();
+    assertEquals(Http2.TYPE_HEADERS, frame1.type);
+    InFrame frame2 = peer.takeFrame();
+    assertEquals(Http2.TYPE_RST_STREAM, frame2.type);
+    InFrame frame3 = peer.takeFrame();
+    assertEquals(Http2.TYPE_RST_STREAM, frame3.type);
+
+    assertEquals(2048, connection.unacknowledgedBytesRead);
+  }
+
   @Test public void receiveGoAwayHttp2() throws Exception {
     // write the mocking script
     peer.sendFrame().settings(new Settings());
@@ -231,7 +241,7 @@
     Http2Connection connection = connect(peer);
     Http2Stream stream1 = connection.newStream(headerEntries("a", "android"), true);
     Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
-    connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
+    connection.writePingAndAwaitPong(); // Ensure the GO_AWAY that resets stream2 has been received.
     BufferedSink sink1 = Okio.buffer(stream1.getSink());
     BufferedSink sink2 = Okio.buffer(stream2.getSink());
     sink1.writeUtf8("abc");
@@ -515,7 +525,7 @@
     out.close();
     assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
     assertStreamData("robot", stream.getSource());
-    connection.ping().roundTripTime();
+    connection.writePingAndAwaitPong();
     assertEquals(0, connection.openStreamCount());
 
     // verify the peer received what was expected
@@ -543,7 +553,7 @@
     Http2Connection connection = connect(peer);
     connection.newStream(headerEntries("b", "banana"), false);
     assertEquals(1, connection.openStreamCount());
-    connection.ping().roundTripTime(); // Ensure that the SYN_REPLY has been received.
+    connection.writePingAndAwaitPong(); // Ensure that the SYN_REPLY has been received.
     assertEquals(0, connection.openStreamCount());
 
     // verify the peer received what was expected
@@ -582,15 +592,18 @@
 
     // play it back
     Http2Connection connection = connect(peer);
-    Ping ping = connection.ping();
-    assertTrue(ping.roundTripTime() > 0);
-    assertTrue(ping.roundTripTime() < TimeUnit.SECONDS.toNanos(1));
+    long pingAtNanos = System.nanoTime();
+    connection.writePingAndAwaitPong();
+    long elapsedNanos = System.nanoTime() - pingAtNanos;
+    assertTrue(elapsedNanos > 0);
+    assertTrue(elapsedNanos < TimeUnit.SECONDS.toNanos(1));
 
     // verify the peer received what was expected
     InFrame pingFrame = peer.takeFrame();
     assertEquals(Http2.TYPE_PING, pingFrame.type);
-    assertEquals(1, pingFrame.payload1);
-    assertEquals(new Buffer().writeUtf8("OKok").readInt(), pingFrame.payload2);
+    assertEquals(0, pingFrame.streamId);
+    assertEquals(0x4f4b6f6b, pingFrame.payload1); // OkOk
+    assertEquals(0xf09f8da9, pingFrame.payload2); // donut
     assertFalse(pingFrame.ack);
   }
 
@@ -759,7 +772,7 @@
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), true);
     BufferedSink out = Okio.buffer(stream.getSink());
-    connection.ping().roundTripTime(); // Ensure that the RST_CANCEL has been received.
+    connection.writePingAndAwaitPong(); // Ensure that the RST_CANCEL has been received.
     try {
       out.writeUtf8("square");
       out.flush();
@@ -782,7 +795,6 @@
     assertFalse(synStream.outFinished);
     InFrame ping = peer.takeFrame();
     assertEquals(Http2.TYPE_PING, ping.type);
-    assertEquals(1, ping.payload1);
   }
 
   /**
@@ -890,7 +902,7 @@
     Http2Stream stream = connection.newStream(headerEntries("a", "android"), false);
     Source source = stream.getSource();
     assertStreamData("square", source);
-    connection.ping().roundTripTime(); // Ensure that inFinished has been received.
+    connection.writePingAndAwaitPong(); // Ensure that inFinished has been received.
     assertEquals(0, connection.openStreamCount());
 
     // verify the peer received what was expected
@@ -915,7 +927,7 @@
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("c", "cola"), false);
     assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
-    connection.ping().roundTripTime(); // Ensure that the 2nd SYN REPLY has been received.
+    connection.writePingAndAwaitPong(); // Ensure that the 2nd SYN REPLY has been received.
 
     // verify the peer received what was expected
     InFrame synStream = peer.takeFrame();
@@ -1028,7 +1040,7 @@
     Http2Connection connection = connect(peer);
     Http2Stream stream1 = connection.newStream(headerEntries("a", "android"), true);
     Http2Stream stream2 = connection.newStream(headerEntries("b", "banana"), true);
-    connection.ping().roundTripTime(); // Ensure the GO_AWAY that resets stream2 has been received.
+    connection.writePingAndAwaitPong(); // Ensure the GO_AWAY that resets stream2 has been received.
     BufferedSink sink1 = Okio.buffer(stream1.getSink());
     BufferedSink sink2 = Okio.buffer(stream2.getSink());
     sink1.writeUtf8("abc");
@@ -1077,10 +1089,15 @@
     // play it back
     Http2Connection connection = connect(peer);
     connection.newStream(headerEntries("a", "android"), false);
-    Ping ping = connection.ping();
+    synchronized (connection) {
+      if (connection.shutdown) {
+        throw new ConnectionShutdownException();
+      }
+    }
+    connection.writePing(false, 0x01, 0x02);
     connection.shutdown(ErrorCode.PROTOCOL_ERROR);
     assertEquals(1, connection.openStreamCount());
-    ping.roundTripTime(); // Prevent the peer from exiting prematurely.
+    connection.awaitPong(); // Prevent the peer from exiting prematurely.
 
     // verify the peer received what was expected
     InFrame synStream1 = peer.takeFrame();
@@ -1093,28 +1110,6 @@
     assertEquals(ErrorCode.PROTOCOL_ERROR, goaway.errorCode);
   }
 
-  @Test public void noPingsAfterShutdown() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // GOAWAY
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    connection.shutdown(ErrorCode.INTERNAL_ERROR);
-    try {
-      connection.ping();
-      fail();
-    } catch (ConnectionShutdownException expected) {
-    }
-
-    // verify the peer received what was expected
-    InFrame goaway = peer.takeFrame();
-    assertEquals(Http2.TYPE_GOAWAY, goaway.type);
-    assertEquals(ErrorCode.INTERNAL_ERROR, goaway.errorCode);
-  }
-
   @Test public void close() throws Exception {
     // write the mocking script
     peer.sendFrame().settings(new Settings());
@@ -1160,21 +1155,6 @@
     assertEquals(3, rstStream.streamId);
   }
 
-  @Test public void closeCancelsPings() throws Exception {
-    // write the mocking script
-    peer.sendFrame().settings(new Settings());
-    peer.acceptFrame(); // ACK
-    peer.acceptFrame(); // PING
-    peer.acceptFrame(); // GOAWAY
-    peer.play();
-
-    // play it back
-    Http2Connection connection = connect(peer);
-    Ping ping = connection.ping();
-    connection.close();
-    assertEquals(-1, ping.roundTripTime());
-  }
-
   @Test public void getResponseHeadersTimesOut() throws Exception {
     // write the mocking script
     peer.sendFrame().settings(new Settings());
@@ -1250,7 +1230,7 @@
 
     // play it back
     Http2Connection connection = connect(peer);
-    connection.ping().roundTripTime(); // Make sure settings have been received.
+    connection.writePingAndAwaitPong(); // Make sure settings have been received.
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
     Sink sink = stream.getSink();
     sink.write(new Buffer().writeUtf8("abcde"), 5);
@@ -1286,7 +1266,6 @@
     peer.sendFrame().ping(true, 1, 0);
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 3, headerEntries("a", "android"));
-    peer.sendFrame().windowUpdate(3, 5);
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 3, 0);
     peer.acceptFrame(); // DATA
@@ -1295,9 +1274,9 @@
 
     // play it back
     Http2Connection connection = connect(peer);
-    connection.ping().roundTripTime(); // Make sure settings have been acked.
+    connection.writePingAndAwaitPong(); // Make sure settings have been acked.
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
-    connection.ping().roundTripTime(); // Make sure the window update has been received.
+    connection.writePingAndAwaitPong(); // Make sure the window update has been received.
     Sink sink = stream.getSink();
     stream.writeTimeout().timeout(500, TimeUnit.MILLISECONDS);
     sink.write(new Buffer().writeUtf8("abcdef"), 6);
@@ -1361,7 +1340,7 @@
     // play it back
     Http2Connection connection = connect(peer);
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
-    connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
+    connection.writePingAndAwaitPong(); // Ensure that the HEADERS has been received.
     assertEquals(Arrays.asList(new Header("a", "android"), null, new Header("c", "c3po")),
         stream.takeResponseHeaders());
 
@@ -1388,7 +1367,7 @@
     Http2Stream stream = connection.newStream(headerEntries("b", "banana"), true);
     stream.getConnection().flush();
     assertEquals(headerEntries("a", "android"), stream.takeResponseHeaders());
-    connection.ping().roundTripTime();
+    connection.writePingAndAwaitPong();
     assertEquals(headerEntries("c", "cola"), stream.takeResponseHeaders());
 
     // verify the peer received what was expected
@@ -1534,7 +1513,7 @@
     assertEquals(0, connection.bytesLeftInWriteWindow);
     assertEquals(0, connection.getStream(3).bytesLeftInWriteWindow);
 
-    // receiving a window update on the the connection will unblock new streams.
+    // receiving a window update on the connection will unblock new streams.
     connection.readerRunnable.windowUpdate(0, 3);
 
     assertEquals(3, connection.bytesLeftInWriteWindow);
@@ -1593,7 +1572,7 @@ private void assertStreamData(String expected, Source source) throws IOException
    * creates more work for the watchdog and waits for that work to be executed. When it is, we know
    * work that preceded this call is complete.
    */
-  private void awaitWatchdogIdle() throws InterruptedException {
+  private void awaitWatchdogIdle() throws Exception {
     final CountDownLatch latch = new CountDownLatch(1);
     AsyncTimeout watchdogJob = new AsyncTimeout() {
       @Override protected void timedOut() {
@@ -1663,7 +1642,7 @@ private Http2Connection connect(MockHttp2Peer peer, PushObserver pushObserver,
   private static class RecordingPushObserver implements PushObserver {
     final List<Object> events = new ArrayList<>();
 
-    public synchronized Object takeEvent() throws InterruptedException {
+    public synchronized Object takeEvent() throws Exception {
       while (events.isEmpty()) {
         wait();
       }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
index e435a09e5b..24ec759c2d 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/Http2Test.java
@@ -278,6 +278,21 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     assertEquals(settingValue.intValue(), 1);
   }
 
+  @Test public void readSettingsFrameExperimentalId() throws IOException {
+    writeMedium(frame, 6); // 2 for the code and 4 for the value
+    frame.writeByte(Http2.TYPE_SETTINGS);
+    frame.writeByte(Http2.FLAG_NONE);
+    frame.writeInt(0); // Settings are always on the connection stream 0.
+    frame.write(ByteString.decodeHex("f000")); // Id reserved for experimental use.
+    frame.writeInt(1);
+
+    reader.nextFrame(false, new BaseTestHandler() {
+      @Override public void settings(boolean clearPrevious, Settings settings) {
+        // no-op
+      }
+    });
+  }
+
   @Test public void readSettingsFrameNegativeWindowSize() throws IOException {
     writeMedium(frame, 6); // 2 for the code and 4 for the value
     frame.writeByte(Http2.TYPE_SETTINGS);
@@ -392,6 +407,23 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     });
   }
 
+  @Test public void dataFrameNotAssociateWithStream() throws IOException {
+    byte[] payload = new byte[] {0x01, 0x02};
+
+    writeMedium(frame, payload.length);
+    frame.writeByte(Http2.TYPE_DATA);
+    frame.writeByte(Http2.FLAG_NONE);
+    frame.writeInt(0);
+    frame.write(payload);
+
+    try {
+      reader.nextFrame(false, new BaseTestHandler());
+      fail();
+    } catch (IOException e) {
+      assertEquals("PROTOCOL_ERROR: TYPE_DATA streamId == 0", e.getMessage());
+    }
+  }
+
   /** We do not send SETTINGS_COMPRESS_DATA = 1, nor want to. Let's make sure we error. */
   @Test public void compressedDataFrameWhenSettingDisabled() throws IOException {
     byte[] expectedData = new byte[Http2.INITIAL_MAX_FRAME_SIZE];
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
index 894524ca79..05e6419318 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/HttpOverHttp2Test.java
@@ -20,16 +20,20 @@
 import java.net.Authenticator;
 import java.net.HttpURLConnection;
 import java.net.SocketTimeoutException;
-import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
+import java.util.Collection;
 import java.util.List;
+import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
-import javax.net.ssl.HostnameVerifier;
+import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.TimeUnit;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 import okhttp3.Cache;
 import okhttp3.Call;
+import okhttp3.Callback;
 import okhttp3.Cookie;
 import okhttp3.Credentials;
 import okhttp3.Headers;
@@ -42,14 +46,14 @@
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
+import okhttp3.Route;
+import okhttp3.TestLogHandler;
 import okhttp3.TestUtil;
 import okhttp3.internal.DoubleInetAddressDns;
 import okhttp3.internal.RecordingOkAuthenticator;
 import okhttp3.internal.SingleInetAddressDns;
-import okhttp3.internal.SocketRecorder;
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.RealConnection;
-import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
@@ -57,9 +61,9 @@
 import okhttp3.mockwebserver.QueueDispatcher;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
-import okio.BufferedSource;
 import okio.GzipSink;
 import okio.Okio;
 import org.junit.After;
@@ -68,39 +72,86 @@
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TemporaryFolder;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
 
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.tls.internal.TlsUtil.localhost;
+import static org.hamcrest.CoreMatchers.containsString;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.fail;
+import static org.junit.Assume.assumeTrue;
 
 /** Test how SPDY interacts with HTTP/2 features. */
+@RunWith(Parameterized.class)
 public final class HttpOverHttp2Test {
+  private static final Logger http2Logger = Logger.getLogger(Http2.class.getName());
+  private static final HandshakeCertificates handshakeCertificates = localhost();
+
+  @Parameters(name = "{0}")
+  public static Collection<Protocol> data() {
+    return Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE, Protocol.HTTP_2);
+  }
+
   @Rule public final TemporaryFolder tempDir = new TemporaryFolder();
   @Rule public final MockWebServer server = new MockWebServer();
 
-  private SslClient sslClient = SslClient.localhost();
-  private HostnameVerifier hostnameVerifier = new RecordingHostnameVerifier();
   private OkHttpClient client;
   private Cache cache;
+  private TestLogHandler http2Handler = new TestLogHandler();
+  private Level previousLevel;
+  private String scheme;
+  private Protocol protocol;
+
+  public HttpOverHttp2Test(Protocol protocol) {
+    this.client = protocol == Protocol.HTTP_2 ? buildHttp2Client() : buildH2PriorKnowledgeClient();
+    this.scheme = protocol == Protocol.HTTP_2 ? "https" : "http";
+    this.protocol = protocol;
+  }
 
-  @Before public void setUp() throws Exception {
-    server.useHttps(sslClient.socketFactory, false);
-    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
-    client = defaultClient().newBuilder()
+  private static OkHttpClient buildH2PriorKnowledgeClient() {
+    return defaultClient().newBuilder()
+        .protocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE))
+        .build();
+  }
+
+  private static OkHttpClient buildHttp2Client() {
+    return defaultClient().newBuilder()
         .protocols(Arrays.asList(Protocol.HTTP_2, Protocol.HTTP_1_1))
         .dns(new SingleInetAddressDns())
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
-        .hostnameVerifier(hostnameVerifier)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
+        .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
   }
 
-  @After public void tearDown() throws Exception {
+  @Before public void setUp() {
+    if (protocol == Protocol.H2_PRIOR_KNOWLEDGE) {
+      server.setProtocols(Arrays.asList(Protocol.H2_PRIOR_KNOWLEDGE));
+    } else {
+      server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    }
+
+    cache = new Cache(tempDir.getRoot(), Integer.MAX_VALUE);
+
+    http2Logger.addHandler(http2Handler);
+    previousLevel = http2Logger.getLevel();
+    http2Logger.setLevel(Level.FINE);
+  }
+
+  @After public void tearDown() {
     Authenticator.setDefault(null);
+    http2Logger.removeHandler(http2Handler);
+    http2Logger.setLevel(previousLevel);
+
+    client.connectionPool().evictAll();
   }
 
   @Test public void get() throws Exception {
@@ -115,11 +166,12 @@
 
     assertEquals("ABCDE", response.body().string());
     assertEquals(200, response.code());
-    assertEquals("Sweet", response.message());
+    assertEquals("", response.message());
+    assertEquals(protocol, response.protocol());
 
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals("https", request.getHeader(":scheme"));
+    assertEquals(scheme, request.getHeader(":scheme"));
     assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
   }
 
@@ -144,7 +196,7 @@
         .url(server.url("/foo"))
         .post(new RequestBody() {
           @Override public MediaType contentType() {
-            return MediaType.parse("text/plain; charset=utf-8");
+            return MediaType.get("text/plain; charset=utf-8");
           }
 
           @Override public void writeTo(BufferedSink sink) throws IOException {
@@ -171,10 +223,10 @@
         .url(server.url("/foo"))
         .post(new RequestBody() {
           @Override public MediaType contentType() {
-            return MediaType.parse("text/plain; charset=utf-8");
+            return MediaType.get("text/plain; charset=utf-8");
           }
 
-          @Override public long contentLength() throws IOException {
+          @Override public long contentLength() {
             return postBytes.length;
           }
 
@@ -202,17 +254,17 @@
         .url(server.url("/foo"))
         .post(new RequestBody() {
           @Override public MediaType contentType() {
-            return MediaType.parse("text/plain; charset=utf-8");
+            return MediaType.get("text/plain; charset=utf-8");
           }
 
-          @Override public long contentLength() throws IOException {
+          @Override public long contentLength() {
             return postBytes.length;
           }
 
           @Override public void writeTo(BufferedSink sink) throws IOException {
             sink.write(postBytes);  // push bytes into the stream's buffer
-            sink.flush(); // FramedConnection.writeData subject to write window
-            sink.close(); // FramedConnection.writeData empty frame
+            sink.flush(); // Http2Connection.writeData subject to write window
+            sink.close(); // Http2Connection.writeData empty frame
           }
         })
         .build());
@@ -250,6 +302,101 @@
     response2.close();
   }
 
+  @Test public void connectionWindowUpdateAfterCanceling() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(new Buffer().write(new byte[Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE + 1])));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+
+    waitForDataFrames(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
+
+    // Cancel the call and discard what we've buffered for the response body. This should free up
+    // the connection flow-control window so new requests can proceed.
+    call1.cancel();
+    assertFalse("Call should not have completed successfully.",
+        Util.discard(response1.body().source(), 1, TimeUnit.SECONDS));
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("abc", response2.body().string());
+  }
+
+  /** Wait for the client to receive {@code dataLength} DATA frames. */
+  private void waitForDataFrames(int dataLength) throws Exception {
+    int expectedFrameCount = dataLength / 16384;
+    int dataFrameCount = 0;
+    while (dataFrameCount < expectedFrameCount) {
+      String log = http2Handler.take();
+      if (log.equals("FINE: << 0x00000003 16384 DATA          ")) {
+        dataFrameCount++;
+      }
+    }
+  }
+
+  @Test public void connectionWindowUpdateOnClose() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(new Buffer().write(new byte[Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE + 1])));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+
+    waitForDataFrames(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
+
+    // Cancel the call and close the response body. This should discard the buffered data and update
+    // the connnection flow-control window.
+    call1.cancel();
+    response1.close();
+
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals("abc", response2.body().string());
+  }
+
+  @Test public void concurrentRequestWithEmptyFlowControlWindow() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(new Buffer().write(new byte[Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE])));
+    server.enqueue(new MockResponse()
+        .setBody("abc"));
+
+    Call call1 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response1 = call1.execute();
+
+    waitForDataFrames(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE);
+
+    assertEquals(Http2Connection.OKHTTP_CLIENT_WINDOW_SIZE, response1.body().contentLength());
+    int read = response1.body().source().read(new byte[8192]);
+    assertEquals(8192, read);
+
+    // Make a second call that should transmit the response headers. The response body won't be
+    // transmitted until the flow-control window is updated from the first request.
+    Call call2 = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response2 = call2.execute();
+    assertEquals(200, response2.code());
+
+    // Close the response body. This should discard the buffered data and update the connection
+    // flow-control window.
+    response1.close();
+
+    assertEquals("abc", response2.body().string());
+  }
+
   /** https://github.com/square/okhttp/issues/373 */
   @Test @Ignore public void synchronousRequest() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
@@ -702,6 +849,70 @@
     assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
   }
 
+  @Test public void recoverFromCancelReusesConnection() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBodyDelay(10, TimeUnit.SECONDS)
+        .setBody("abc"));
+    server.enqueue(new MockResponse()
+        .setBody("def"));
+
+    client = client.newBuilder()
+        .dns(new DoubleInetAddressDns())
+        .build();
+
+    callAndCancel(0);
+
+    // Make a second request to ensure the connection is reused.
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    assertEquals("def", response.body().string());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void recoverFromMultipleCancelReusesConnection() throws Exception {
+    server.enqueue(new MockResponse()
+            .setBodyDelay(10, TimeUnit.SECONDS)
+            .setBody("abc"));
+    server.enqueue(new MockResponse()
+            .setBodyDelay(10, TimeUnit.SECONDS)
+            .setBody("def"));
+    server.enqueue(new MockResponse()
+            .setBody("ghi"));
+
+    client = client.newBuilder()
+            .dns(new DoubleInetAddressDns())
+            .build();
+
+    callAndCancel(0);
+    callAndCancel(1);
+
+    // Make a third request to ensure the connection is reused.
+    Call call = client.newCall(new Request.Builder()
+            .url(server.url("/"))
+            .build());
+    Response response = call.execute();
+    assertEquals("ghi", response.body().string());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
+  /** Make a call and canceling it as soon as it's accepted by the server. */
+  private void callAndCancel(int expectedSequenceNumber) throws Exception {
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    call.enqueue(new Callback() {
+      @Override public void onFailure(Call call1, IOException e) {
+      }
+
+      @Override public void onResponse(Call call1, Response response) {
+      }
+    });
+    assertEquals(expectedSequenceNumber, server.takeRequest().getSequenceNumber());
+    call.cancel();
+  }
+
   @Test public void noRecoveryFromRefusedStreamWithRetryDisabled() throws Exception {
     noRecoveryFromErrorWithRetryDisabled(ErrorCode.REFUSED_STREAM);
   }
@@ -732,6 +943,74 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     }
   }
 
+  @Test public void recoverFromConnectionNoNewStreamsOnFollowUp() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(401));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.RESET_STREAM_AT_START)
+        .setHttp2ErrorCode(ErrorCode.INTERNAL_ERROR.httpCode));
+    server.enqueue(new MockResponse()
+        .setBody("DEF"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location", "/foo"));
+    server.enqueue(new MockResponse()
+        .setBody("ABC"));
+
+    final CountDownLatch latch = new CountDownLatch(1);
+    final BlockingQueue<String> responses = new SynchronousQueue<>();
+    okhttp3.Authenticator authenticator = new okhttp3.Authenticator() {
+      @Override public Request authenticate(Route route, Response response) throws IOException {
+        responses.offer(response.body().string());
+        try {
+          latch.await();
+        } catch (InterruptedException e) {
+          throw new AssertionError();
+        }
+        return response.request();
+      }
+    };
+
+    OkHttpClient blockingAuthClient = client.newBuilder()
+        .authenticator(authenticator)
+        .build();
+
+    Callback callback = new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+        fail();
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        responses.offer(response.body().string());
+      }
+    };
+
+    // Make the first request waiting until we get our auth challenge.
+    Request request = new Request.Builder()
+        .url(server.url("/"))
+        .build();
+    blockingAuthClient.newCall(request).enqueue(callback);
+    String response1 = responses.take();
+    assertEquals("", response1);
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    // Now make the second request which will restrict the first HTTP/2 connection from creating new
+    // streams.
+    client.newCall(request).enqueue(callback);
+    String response2 = responses.take();
+    assertEquals("DEF", response2);
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+
+    // Let the first request proceed. It should discard the the held HTTP/2 connection and get a new
+    // one.
+    latch.countDown();
+    String response3 = responses.take();
+    assertEquals("ABC", response3);
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
   @Test public void nonAsciiResponseHeader() throws Exception {
     server.enqueue(new MockResponse()
         .addHeaderLenient("Alpha", "Î±")
@@ -762,11 +1041,11 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
 
     assertEquals("ABCDE", response.body().string());
     assertEquals(200, response.code());
-    assertEquals("Sweet", response.message());
+    assertEquals("", response.message());
 
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals("https", request.getHeader(":scheme"));
+    assertEquals(scheme, request.getHeader(":scheme"));
     assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
 
     RecordedRequest pushedRequest = server.takeRequest();
@@ -788,11 +1067,11 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     Response response = call.execute();
     assertEquals("ABCDE", response.body().string());
     assertEquals(200, response.code());
-    assertEquals("Sweet", response.message());
+    assertEquals("", response.message());
 
     RecordedRequest request = server.takeRequest();
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
-    assertEquals("https", request.getHeader(":scheme"));
+    assertEquals(scheme, request.getHeader(":scheme"));
     assertEquals(server.getHostName() + ":" + server.getPort(), request.getHeader(":authority"));
 
     RecordedRequest pushedRequest = server.takeRequest();
@@ -804,12 +1083,6 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     server.enqueue(new MockResponse()
         .setBody("ABC"));
 
-    SocketRecorder socketRecorder = new SocketRecorder();
-    client = client.newBuilder()
-        .sslSocketFactory(socketRecorder.sslSocketFactory(sslClient.socketFactory),
-            sslClient.trustManager)
-        .build();
-
     Call call = client.newCall(new Request.Builder()
         .url(server.url("/"))
         .method("DELETE", null)
@@ -817,51 +1090,108 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     Response response = call.execute();
     assertEquals("ABC", response.body().string());
 
-    // Replay the bytes written by the client to confirm no data frames were sent.
-    SocketRecorder.RecordedSocket recordedSocket = socketRecorder.takeSocket();
-    Buffer buffer = new Buffer();
-    buffer.write(recordedSocket.bytesWritten());
+    assertEquals(protocol, response.protocol());
 
-    RecordingHandler handler = new RecordingHandler();
-    Http2Reader reader = new Http2Reader(buffer, false);
-    reader.readConnectionPreface(null);
-    while (reader.nextFrame(false, handler)) {
-    }
+    List<String> logs = http2Handler.takeAll();
 
-    assertEquals(1, handler.headerFrameCount);
-    assertTrue(handler.dataFrames.isEmpty());
+    assertThat("header logged", firstFrame(logs, "HEADERS"), containsString("HEADERS       END_STREAM|END_HEADERS"));
   }
 
   @Test public void emptyDataFrameSentWithEmptyBody() throws Exception {
     server.enqueue(new MockResponse()
         .setBody("ABC"));
 
-    SocketRecorder socketRecorder = new SocketRecorder();
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .method("DELETE", Util.EMPTY_REQUEST)
+        .build());
+    Response response = call.execute();
+    assertEquals("ABC", response.body().string());
+
+    assertEquals(protocol, response.protocol());
+
+    List<String> logs = http2Handler.takeAll();
+
+    assertThat("header logged", firstFrame(logs, "HEADERS"), containsString("HEADERS       END_HEADERS"));
+    assertThat("data logged", firstFrame(logs, "DATA"), containsString("0 DATA          END_STREAM"));
+  }
+
+  @Test public void pingsTransmitted() throws Exception {
+    // Ping every 500 ms, starting at 500 ms.
     client = client.newBuilder()
-        .sslSocketFactory(socketRecorder.sslSocketFactory(sslClient.socketFactory),
-            sslClient.trustManager)
+        .pingInterval(500, TimeUnit.MILLISECONDS)
         .build();
 
+    // Delay the response to give 1 ping enough time to be sent and replied to.
+    server.enqueue(new MockResponse()
+        .setBodyDelay(750, TimeUnit.MILLISECONDS)
+        .setBody("ABC"));
+
     Call call = client.newCall(new Request.Builder()
         .url(server.url("/"))
-        .method("DELETE", Util.EMPTY_REQUEST)
         .build());
     Response response = call.execute();
     assertEquals("ABC", response.body().string());
 
-    // Replay the bytes written by the client to confirm an empty data frame was sent.
-    SocketRecorder.RecordedSocket recordedSocket = socketRecorder.takeSocket();
-    Buffer buffer = new Buffer();
-    buffer.write(recordedSocket.bytesWritten());
+    assertEquals(protocol, response.protocol());
+
+    // Confirm a single ping was sent and received, and its reply was sent and received.
+    List<String> logs = http2Handler.takeAll();
+    assertEquals(1, countFrames(logs, "FINE: >> 0x00000000     8 PING          "));
+    assertEquals(1, countFrames(logs, "FINE: << 0x00000000     8 PING          "));
+    assertEquals(1, countFrames(logs, "FINE: >> 0x00000000     8 PING          ACK"));
+    assertEquals(1, countFrames(logs, "FINE: << 0x00000000     8 PING          ACK"));
+  }
+
+  @Test public void missingPongsFailsConnection() throws Exception {
+    // Ping every 500 ms, starting at 500 ms.
+    client = client.newBuilder()
+        .readTimeout(10, TimeUnit.SECONDS) // Confirm we fail before the read timeout.
+        .pingInterval(500, TimeUnit.MILLISECONDS)
+        .build();
+
+    // Set up the server to ignore the socket. It won't respond to pings!
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.STALL_SOCKET_AT_START));
+
+    // Make a call. It'll fail as soon as our pings detect a problem.
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    long executeAtNanos = System.nanoTime();
+    try {
+      call.execute();
+      fail();
+    } catch (StreamResetException expected) {
+      assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
+    }
 
-    RecordingHandler handler = new RecordingHandler();
-    Http2Reader reader = new Http2Reader(buffer, false);
-    reader.readConnectionPreface(null);
-    while (reader.nextFrame(false, handler)) {
+    long elapsedUntilFailure = System.nanoTime() - executeAtNanos;
+    assertEquals(1000, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
+
+    // Confirm a single ping was sent but not acknowledged.
+    List<String> logs = http2Handler.takeAll();
+    assertEquals(1, countFrames(logs, "FINE: >> 0x00000000     8 PING          "));
+    assertEquals(0, countFrames(logs, "FINE: << 0x00000000     8 PING          ACK"));
+  }
+
+  private String firstFrame(List<String> logs, String type) {
+    for (String log: logs) {
+      if (log.contains(type)) {
+        return log;
+      }
     }
+    return null;
+  }
 
-    assertEquals(1, handler.headerFrameCount);
-    assertEquals(Collections.singletonList(0), handler.dataFrames);
+  private int countFrames(List<String> logs, String message) {
+    int result = 0;
+    for (String log: logs) {
+      if (log.equals(message)) {
+        result++;
+      }
+    }
+    return result;
   }
 
   /**
@@ -978,6 +1308,31 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     assertEquals(0, server.takeRequest().getSequenceNumber());
   }
 
+  @Test public void responseHeadersAfterGoaway() throws Exception {
+    server.enqueue(new MockResponse()
+        .setHeadersDelay(1, SECONDS)
+        .setBody("ABC"));
+    server.enqueue(new MockResponse()
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END)
+        .setBody("DEF"));
+
+    final BlockingQueue<String> bodies = new SynchronousQueue<>();
+    Callback callback = new Callback() {
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        bodies.add(response.body().string());
+      }
+      @Override public void onFailure(Call call, IOException e) {
+        System.out.println(e);
+      }
+    };
+    client.newCall(new Request.Builder().url(server.url("/")).build()).enqueue(callback);
+    client.newCall(new Request.Builder().url(server.url("/")).build()).enqueue(callback);
+
+    assertEquals("DEF", bodies.poll(2, SECONDS));
+    assertEquals("ABC", bodies.poll(2, SECONDS));
+    assertEquals(2, server.getRequestCount());
+  }
+
   /**
    * We don't know if the connection will support HTTP/2 until after we've connected. When multiple
    * connections are requested concurrently OkHttp will pessimistically connect multiple times, then
@@ -986,7 +1341,9 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
    * <p>This test uses proxy tunnels to get a hook while a connection is being established.
    */
   @Test public void concurrentHttp2ConnectionsDeduplicated() throws Exception {
-    server.useHttps(sslClient.socketFactory, true);
+    assumeTrue(protocol == Protocol.HTTP_2);
+
+    server.useHttps(handshakeCertificates.sslSocketFactory(), true);
 
     // Force a fresh connection pool for the test.
     client.connectionPool().evictAll();
@@ -1067,7 +1424,33 @@ private void noRecoveryFromErrorWithRetryDisabled(ErrorCode errorCode) throws Ex
     assertEquals(1, client.connectionPool().connectionCount());
   }
 
-  public Buffer gzip(String bytes) throws IOException {
+  /** https://github.com/square/okhttp/issues/3103 */
+  @Test public void domainFronting() throws Exception {
+    client = client.newBuilder()
+        .addNetworkInterceptor(new Interceptor() {
+          @Override public Response intercept(Chain chain) throws IOException {
+            Request request = chain.request().newBuilder()
+                .header("Host", "privateobject.com")
+                .build();
+            return chain.proceed(request);
+          }
+        })
+        .build();
+
+    server.enqueue(new MockResponse());
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+
+    Response response = call.execute();
+    assertEquals("", response.body().string());
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("privateobject.com", recordedRequest.getHeader(":authority"));
+  }
+
+  private Buffer gzip(String bytes) throws IOException {
     Buffer bytesOut = new Buffer();
     BufferedSink sink = Okio.buffer(new GzipSink(bytesOut));
     sink.writeUtf8(bytes);
@@ -1079,7 +1462,7 @@ public Buffer gzip(String bytes) throws IOException {
     String path;
     CountDownLatch countDownLatch;
 
-    public AsyncRequest(String path, CountDownLatch countDownLatch) {
+    AsyncRequest(String path, CountDownLatch countDownLatch) {
       this.path = path;
       this.countDownLatch = countDownLatch;
     }
@@ -1097,28 +1480,4 @@ public AsyncRequest(String path, CountDownLatch countDownLatch) {
       }
     }
   }
-
-  static final class RecordingHandler extends BaseTestHandler {
-    int headerFrameCount;
-    final List<Integer> dataFrames = new ArrayList<>();
-
-    @Override public void settings(boolean clearPrevious, Settings settings) {
-    }
-
-    @Override public void ackSettings() {
-    }
-
-    @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
-    }
-
-    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
-        throws IOException {
-      dataFrames.add(length);
-    }
-
-    @Override public void headers(boolean inFinished, int streamId, int associatedStreamId,
-        List<Header> headerBlock) {
-      headerFrameCount++;
-    }
-  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java b/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
index fe5f82fd4a..376c46d1f3 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/http2/MockHttp2Peer.java
@@ -100,7 +100,7 @@ public Http2Writer truncateLastFrame(int length) {
     return writer;
   }
 
-  public InFrame takeFrame() throws InterruptedException {
+  public InFrame takeFrame() throws Exception {
     return inFrames.take();
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java b/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
index 40aca93adb..bc0263d830 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/io/FaultyFileSystem.java
@@ -90,6 +90,7 @@ public void setFaultyRename(File file, boolean faulty) {
   }
 
   @Override public void deleteContents(File directory) throws IOException {
+    if (deleteFaults.contains(directory)) throw new IOException("boom!");
     delegate.deleteContents(directory);
   }
 
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java b/okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java
index 82ac18fc14..7e249bd61f 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/platform/OptionalMethodTest.java
@@ -19,6 +19,7 @@
 
 import java.io.IOException;
 import java.lang.reflect.InvocationTargetException;
+import org.junit.Ignore;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -299,6 +300,7 @@ public void invokeOptionalWithException() throws Exception {
   }
 
   @Test
+  @Ignore("Despite returning false for isSupported, invocation actually succeeds.")
   public void invokeOptionalNonPublic() throws Exception {
     SubClass2 subClass2 = new SubClass2();
     assertFalse(NON_PUBLIC.isSupported(subClass2));
@@ -309,9 +311,10 @@ public void invokeOptionalNonPublic() throws Exception {
       OptionalMethod<T> optionalMethod, T base, Object... args) throws Exception {
     try {
       optionalMethod.invoke(base, args);
-      fail();
     } catch (Error expected) {
+      return;
     }
+    fail();
   }
 
   private static <T> void assertIllegalArgumentExceptionOnInvoke(
@@ -327,9 +330,10 @@ public void invokeOptionalNonPublic() throws Exception {
       OptionalMethod<T> optionalMethod, T base, Object... args) throws Exception {
     try {
       optionalMethod.invokeOptional(base, args);
-      fail();
     } catch (Error expected) {
+      return;
     }
+    fail();
   }
 
   private static <T> void assertIllegalArgumentExceptionOnInvokeOptional(
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java b/okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
new file mode 100644
index 0000000000..e999890991
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixDatabaseTest.java
@@ -0,0 +1,284 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.publicsuffix;
+
+import java.io.IOException;
+import java.io.InputStream;
+import okhttp3.internal.Util;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.GzipSource;
+import okio.Okio;
+import org.junit.Test;
+
+import static okhttp3.internal.publicsuffix.PublicSuffixDatabase.PUBLIC_SUFFIX_RESOURCE;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class PublicSuffixDatabaseTest {
+  private final PublicSuffixDatabase publicSuffixDatabase = new PublicSuffixDatabase();
+
+  @Test public void longestMatchWins() {
+    Buffer buffer = new Buffer()
+        .writeUtf8("com\n")
+        .writeUtf8("my.square.com\n")
+        .writeUtf8("square.com\n");
+    publicSuffixDatabase.setListBytes(buffer.readByteArray(), new byte[]{});
+
+    assertEquals("example.com", publicSuffixDatabase.getEffectiveTldPlusOne("example.com"));
+    assertEquals("example.com", publicSuffixDatabase.getEffectiveTldPlusOne("foo.example.com"));
+    assertEquals("bar.square.com",
+        publicSuffixDatabase.getEffectiveTldPlusOne("foo.bar.square.com"));
+    assertEquals("foo.my.square.com",
+        publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.com"));
+  }
+
+  @Test public void wildcardMatch() {
+    Buffer buffer = new Buffer()
+        .writeUtf8("*.square.com\n")
+        .writeUtf8("com\n")
+        .writeUtf8("example.com\n");
+    publicSuffixDatabase.setListBytes(buffer.readByteArray(), new byte[]{});
+
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("my.square.com"));
+    assertEquals("foo.my.square.com",
+        publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.com"));
+    assertEquals("foo.my.square.com",
+        publicSuffixDatabase.getEffectiveTldPlusOne("bar.foo.my.square.com"));
+  }
+
+  @Test public void boundarySearches() {
+    Buffer buffer = new Buffer()
+        .writeUtf8("bbb\n")
+        .writeUtf8("ddd\n")
+        .writeUtf8("fff\n");
+    publicSuffixDatabase.setListBytes(buffer.readByteArray(), new byte[]{});
+
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("aaa"));
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("ggg"));
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("ccc"));
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("eee"));
+  }
+
+  @Test public void exceptionRule() {
+    Buffer exception = new Buffer()
+        .writeUtf8("my.square.jp\n");
+    Buffer buffer = new Buffer()
+        .writeUtf8("*.jp\n")
+        .writeUtf8("*.square.jp\n")
+        .writeUtf8("example.com\n")
+        .writeUtf8("square.com\n");
+    publicSuffixDatabase.setListBytes(buffer.readByteArray(), exception.readByteArray());
+
+    assertEquals("my.square.jp", publicSuffixDatabase.getEffectiveTldPlusOne("my.square.jp"));
+    assertEquals("my.square.jp", publicSuffixDatabase.getEffectiveTldPlusOne("foo.my.square.jp"));
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("my1.square.jp"));
+  }
+
+  @Test public void noEffectiveTldPlusOne() {
+    Buffer exception = new Buffer()
+        .writeUtf8("my.square.jp\n");
+    Buffer buffer = new Buffer()
+        .writeUtf8("*.jp\n")
+        .writeUtf8("*.square.jp\n")
+        .writeUtf8("example.com\n")
+        .writeUtf8("square.com\n");
+    publicSuffixDatabase.setListBytes(buffer.readByteArray(), exception.readByteArray());
+
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("example.com"));
+    assertNull(publicSuffixDatabase.getEffectiveTldPlusOne("foo.square.jp"));
+  }
+
+  @Test public void allPublicSuffixes() throws IOException {
+    InputStream resource = PublicSuffixDatabaseTest.class
+        .getResourceAsStream(PUBLIC_SUFFIX_RESOURCE);
+    BufferedSource source = Okio.buffer(new GzipSource(Okio.source(resource)));
+    int length = source.readInt();
+    Buffer buffer = new Buffer();
+    buffer.write(source, length);
+    resource.close();
+
+    while (!buffer.exhausted()) {
+      String publicSuffix = buffer.readUtf8LineStrict();
+      if (publicSuffix.contains("*")) {
+        // A wildcard rule, let's replace the wildcard with a value.
+        publicSuffix = publicSuffix.replaceAll("\\*", "square");
+      }
+      assertNull(publicSuffixDatabase.getEffectiveTldPlusOne(publicSuffix));
+
+      String test = "foobar." + publicSuffix;
+      assertEquals(test, publicSuffixDatabase.getEffectiveTldPlusOne(test));
+    }
+  }
+
+  @Test public void publicSuffixExceptions() throws IOException {
+    InputStream resource = PublicSuffixDatabaseTest.class
+        .getResourceAsStream(PUBLIC_SUFFIX_RESOURCE);
+    BufferedSource source = Okio.buffer(new GzipSource(Okio.source(resource)));
+    int length = source.readInt();
+    source.skip(length);
+
+    length = source.readInt();
+    Buffer buffer = new Buffer();
+    buffer.write(source, length);
+    resource.close();
+
+    while (!buffer.exhausted()) {
+      String exception = buffer.readUtf8LineStrict();
+      assertEquals(exception, publicSuffixDatabase.getEffectiveTldPlusOne(exception));
+
+      String test = "foobar." + exception;
+      assertEquals(exception, publicSuffixDatabase.getEffectiveTldPlusOne(test));
+    }
+  }
+
+  @Test public void threadIsInterruptedOnFirstRead() {
+    Thread.currentThread().interrupt();
+    try {
+      String result = publicSuffixDatabase.getEffectiveTldPlusOne("squareup.com");
+      assertEquals("squareup.com", result);
+    } finally {
+      assertTrue(Thread.interrupted());
+    }
+  }
+
+  /**
+   * These tests are provided by <a href="https://publicsuffix.org/list/">publicsuffix.org</a>.
+   */
+  @Test public void publicSuffixDotOrgTestCases() {
+    // Any copyright is dedicated to the Public Domain.
+    // https://creativecommons.org/publicdomain/zero/1.0/
+
+    // null input.
+    checkPublicSuffix(null, null);
+    // Mixed case.
+    checkPublicSuffix("COM", null);
+    checkPublicSuffix("example.COM", "example.com");
+    checkPublicSuffix("WwW.example.COM", "example.com");
+    // Leading dot.
+    checkPublicSuffix(".com", null);
+    checkPublicSuffix(".example", null);
+    checkPublicSuffix(".example.com", null);
+    checkPublicSuffix(".example.example", null);
+    // Unlisted TLD.
+    checkPublicSuffix("example", null);
+    checkPublicSuffix("example.example", "example.example");
+    checkPublicSuffix("b.example.example", "example.example");
+    checkPublicSuffix("a.b.example.example", "example.example");
+    // Listed, but non-Internet, TLD.
+    //checkPublicSuffix("local", null);
+    //checkPublicSuffix("example.local", null);
+    //checkPublicSuffix("b.example.local", null);
+    //checkPublicSuffix("a.b.example.local", null);
+    // TLD with only 1 rule.
+    checkPublicSuffix("biz", null);
+    checkPublicSuffix("domain.biz", "domain.biz");
+    checkPublicSuffix("b.domain.biz", "domain.biz");
+    checkPublicSuffix("a.b.domain.biz", "domain.biz");
+    // TLD with some 2-level rules.
+    checkPublicSuffix("com", null);
+    checkPublicSuffix("example.com", "example.com");
+    checkPublicSuffix("b.example.com", "example.com");
+    checkPublicSuffix("a.b.example.com", "example.com");
+    checkPublicSuffix("uk.com", null);
+    checkPublicSuffix("example.uk.com", "example.uk.com");
+    checkPublicSuffix("b.example.uk.com", "example.uk.com");
+    checkPublicSuffix("a.b.example.uk.com", "example.uk.com");
+    checkPublicSuffix("test.ac", "test.ac");
+    // TLD with only 1 (wildcard) rule.
+    checkPublicSuffix("mm", null);
+    checkPublicSuffix("c.mm", null);
+    checkPublicSuffix("b.c.mm", "b.c.mm");
+    checkPublicSuffix("a.b.c.mm", "b.c.mm");
+    // More complex TLD.
+    checkPublicSuffix("jp", null);
+    checkPublicSuffix("test.jp", "test.jp");
+    checkPublicSuffix("www.test.jp", "test.jp");
+    checkPublicSuffix("ac.jp", null);
+    checkPublicSuffix("test.ac.jp", "test.ac.jp");
+    checkPublicSuffix("www.test.ac.jp", "test.ac.jp");
+    checkPublicSuffix("kyoto.jp", null);
+    checkPublicSuffix("test.kyoto.jp", "test.kyoto.jp");
+    checkPublicSuffix("ide.kyoto.jp", null);
+    checkPublicSuffix("b.ide.kyoto.jp", "b.ide.kyoto.jp");
+    checkPublicSuffix("a.b.ide.kyoto.jp", "b.ide.kyoto.jp");
+    checkPublicSuffix("c.kobe.jp", null);
+    checkPublicSuffix("b.c.kobe.jp", "b.c.kobe.jp");
+    checkPublicSuffix("a.b.c.kobe.jp", "b.c.kobe.jp");
+    checkPublicSuffix("city.kobe.jp", "city.kobe.jp");
+    checkPublicSuffix("www.city.kobe.jp", "city.kobe.jp");
+    // TLD with a wildcard rule and exceptions.
+    checkPublicSuffix("ck", null);
+    checkPublicSuffix("test.ck", null);
+    checkPublicSuffix("b.test.ck", "b.test.ck");
+    checkPublicSuffix("a.b.test.ck", "b.test.ck");
+    checkPublicSuffix("www.ck", "www.ck");
+    checkPublicSuffix("www.www.ck", "www.ck");
+    // US K12.
+    checkPublicSuffix("us", null);
+    checkPublicSuffix("test.us", "test.us");
+    checkPublicSuffix("www.test.us", "test.us");
+    checkPublicSuffix("ak.us", null);
+    checkPublicSuffix("test.ak.us", "test.ak.us");
+    checkPublicSuffix("www.test.ak.us", "test.ak.us");
+    checkPublicSuffix("k12.ak.us", null);
+    checkPublicSuffix("test.k12.ak.us", "test.k12.ak.us");
+    checkPublicSuffix("www.test.k12.ak.us", "test.k12.ak.us");
+    // IDN labels.
+    checkPublicSuffix("é£Ÿç‹®.com.cn", "é£Ÿç‹®.com.cn");
+    checkPublicSuffix("é£Ÿç‹®.å…¬å¸.cn", "é£Ÿç‹®.å…¬å¸.cn");
+    checkPublicSuffix("www.é£Ÿç‹®.å…¬å¸.cn", "é£Ÿç‹®.å…¬å¸.cn");
+    checkPublicSuffix("shishi.å…¬å¸.cn", "shishi.å…¬å¸.cn");
+    checkPublicSuffix("å…¬å¸.cn", null);
+    checkPublicSuffix("é£Ÿç‹®.ä¸­å›½", "é£Ÿç‹®.ä¸­å›½");
+    checkPublicSuffix("www.é£Ÿç‹®.ä¸­å›½", "é£Ÿç‹®.ä¸­å›½");
+    checkPublicSuffix("shishi.ä¸­å›½", "shishi.ä¸­å›½");
+    checkPublicSuffix("ä¸­å›½", null);
+    // Same as above, but punycoded.
+    checkPublicSuffix("xn--85x722f.com.cn", "xn--85x722f.com.cn");
+    checkPublicSuffix("xn--85x722f.xn--55qx5d.cn", "xn--85x722f.xn--55qx5d.cn");
+    checkPublicSuffix("www.xn--85x722f.xn--55qx5d.cn", "xn--85x722f.xn--55qx5d.cn");
+    checkPublicSuffix("shishi.xn--55qx5d.cn", "shishi.xn--55qx5d.cn");
+    checkPublicSuffix("xn--55qx5d.cn", null);
+    checkPublicSuffix("xn--85x722f.xn--fiqs8s", "xn--85x722f.xn--fiqs8s");
+    checkPublicSuffix("www.xn--85x722f.xn--fiqs8s", "xn--85x722f.xn--fiqs8s");
+    checkPublicSuffix("shishi.xn--fiqs8s", "shishi.xn--fiqs8s");
+    checkPublicSuffix("xn--fiqs8s", null);
+  }
+
+  private void checkPublicSuffix(String domain, String registrablePart) {
+    if (domain == null) {
+      try {
+        publicSuffixDatabase.getEffectiveTldPlusOne(null);
+        fail();
+      } catch (NullPointerException expected) {
+      }
+      return;
+    }
+
+    String canonicalDomain = Util.canonicalizeHost(domain);
+    if (canonicalDomain == null) return;
+
+    String result = publicSuffixDatabase.getEffectiveTldPlusOne(canonicalDomain);
+    if (registrablePart == null) {
+      assertNull(result);
+    } else {
+      assertEquals(Util.canonicalizeHost(registrablePart), result);
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
index 27b1c7783f..ffb116eea7 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/CertificatePinnerChainValidationTest.java
@@ -15,22 +15,37 @@
  */
 package okhttp3.internal.tls;
 
+import java.security.GeneralSecurityException;
+import java.security.SecureRandom;
+import java.security.cert.X509Certificate;
+import java.util.Collections;
+import javax.net.ssl.KeyManager;
+import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509KeyManager;
+import javax.net.ssl.X509TrustManager;
 import okhttp3.Call;
 import okhttp3.CertificatePinner;
 import okhttp3.OkHttpClient;
 import okhttp3.RecordingHostnameVerifier;
 import okhttp3.Request;
 import okhttp3.Response;
+import okhttp3.internal.platform.Platform;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HeldCertificate;
+import okhttp3.tls.HandshakeCertificates;
 import org.junit.Rule;
 import org.junit.Test;
 
 import static okhttp3.TestUtil.defaultClient;
 import static okhttp3.internal.platform.PlatformTest.getPlatform;
+import static okhttp3.tls.internal.TlsUtil.newKeyManager;
+import static okhttp3.tls.internal.TlsUtil.newTrustManager;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -41,37 +56,38 @@
   /** The pinner should pull the root certificate from the trust manager. */
   @Test public void pinRootNotPresentInChain() throws Exception {
     HeldCertificate rootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(3)
+        .serialNumber(1L)
+        .certificateAuthority(1)
         .commonName("root")
         .build();
     HeldCertificate intermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
-        .ca(2)
-        .serialNumber("2")
+        .signedBy(rootCa)
+        .certificateAuthority(0)
+        .serialNumber(2L)
         .commonName("intermediate_ca")
         .build();
     HeldCertificate certificate = new HeldCertificate.Builder()
-        .issuedBy(intermediateCa)
-        .serialNumber("3")
+        .signedBy(intermediateCa)
+        .serialNumber(3L)
         .commonName(server.getHostName())
         .build();
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(server.getHostName(), CertificatePinner.pin(rootCa.certificate))
+        .add(server.getHostName(), CertificatePinner.pin(rootCa.certificate()))
         .build();
-    SslClient sslClient = new SslClient.Builder()
-        .addTrustedCertificate(rootCa.certificate)
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(rootCa.certificate())
         .build();
     OkHttpClient client = defaultClient().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .certificatePinner(certificatePinner)
         .build();
 
-    SslClient serverSslClient = new SslClient.Builder()
-        .certificateChain(certificate, intermediateCa)
+    HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
+        .heldCertificate(certificate, intermediateCa.certificate())
         .build();
-    server.useHttps(serverSslClient.socketFactory, false);
+    server.useHttps(serverHandshakeCertificates.sslSocketFactory(), false);
 
     // The request should complete successfully.
     server.enqueue(new MockResponse()
@@ -97,37 +113,38 @@
   /** The pinner should accept an intermediate from the server's chain. */
   @Test public void pinIntermediatePresentInChain() throws Exception {
     HeldCertificate rootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(3)
+        .serialNumber(1L)
+        .certificateAuthority(1)
         .commonName("root")
         .build();
     HeldCertificate intermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
-        .ca(2)
-        .serialNumber("2")
+        .signedBy(rootCa)
+        .certificateAuthority(0)
+        .serialNumber(2L)
         .commonName("intermediate_ca")
         .build();
     HeldCertificate certificate = new HeldCertificate.Builder()
-        .issuedBy(intermediateCa)
-        .serialNumber("3")
+        .signedBy(intermediateCa)
+        .serialNumber(3L)
         .commonName(server.getHostName())
         .build();
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(server.getHostName(), CertificatePinner.pin(intermediateCa.certificate))
+        .add(server.getHostName(), CertificatePinner.pin(intermediateCa.certificate()))
         .build();
-    SslClient contextBuilder = new SslClient.Builder()
-        .addTrustedCertificate(rootCa.certificate)
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(rootCa.certificate())
         .build();
     OkHttpClient client = defaultClient().newBuilder()
-        .sslSocketFactory(contextBuilder.socketFactory, contextBuilder.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .certificatePinner(certificatePinner)
         .build();
 
-    SslClient serverSslContext = new SslClient.Builder()
-        .certificateChain(certificate.keyPair, certificate.certificate, intermediateCa.certificate)
+    HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
+        .heldCertificate(certificate, intermediateCa.certificate())
         .build();
-    server.useHttps(serverSslContext.socketFactory, false);
+    server.useHttps(serverHandshakeCertificates.sslSocketFactory(), false);
 
     // The request should complete successfully.
     server.enqueue(new MockResponse()
@@ -158,8 +175,8 @@
   @Test public void unrelatedPinnedLeafCertificateInChain() throws Exception {
     // Start with a trusted root CA certificate.
     HeldCertificate rootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(3)
+        .serialNumber(1L)
+        .certificateAuthority(1)
         .commonName("root")
         .build();
 
@@ -167,24 +184,25 @@
     // SSL context for an HTTP client under attack. It includes the trusted CA and a pinned
     // certificate.
     HeldCertificate goodIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
-        .ca(2)
-        .serialNumber("2")
+        .signedBy(rootCa)
+        .certificateAuthority(0)
+        .serialNumber(2L)
         .commonName("good_intermediate_ca")
         .build();
     HeldCertificate goodCertificate = new HeldCertificate.Builder()
-        .issuedBy(goodIntermediateCa)
-        .serialNumber("3")
+        .signedBy(goodIntermediateCa)
+        .serialNumber(3L)
         .commonName(server.getHostName())
         .build();
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(server.getHostName(), CertificatePinner.pin(goodCertificate.certificate))
+        .add(server.getHostName(), CertificatePinner.pin(goodCertificate.certificate()))
         .build();
-    SslClient clientContextBuilder = new SslClient.Builder()
-        .addTrustedCertificate(rootCa.certificate)
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(rootCa.certificate())
         .build();
     OkHttpClient client = defaultClient().newBuilder()
-        .sslSocketFactory(clientContextBuilder.socketFactory, clientContextBuilder.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .certificatePinner(certificatePinner)
         .build();
@@ -194,32 +212,21 @@
     // trusted good certificate above. The attack is that by including the good certificate in the
     // chain, we may trick the certificate pinner into accepting the rouge certificate.
     HeldCertificate compromisedIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
-        .ca(2)
-        .serialNumber("4")
+        .signedBy(rootCa)
+        .certificateAuthority(0)
+        .serialNumber(4L)
         .commonName("bad_intermediate_ca")
         .build();
     HeldCertificate rogueCertificate = new HeldCertificate.Builder()
-        .serialNumber("5")
-        .issuedBy(compromisedIntermediateCa)
+        .serialNumber(5L)
+        .signedBy(compromisedIntermediateCa)
         .commonName(server.getHostName())
         .build();
 
-    SslClient.Builder sslBuilder = new SslClient.Builder();
+    SSLSocketFactory socketFactory = newServerSocketFactory(rogueCertificate,
+        compromisedIntermediateCa.certificate(), goodCertificate.certificate());
 
-    // Test setup fails on JDK9
-    // java.security.KeyStoreException: Certificate chain is not valid
-    // at sun.security.pkcs12.PKCS12KeyStore.setKeyEntry
-    // http://openjdk.java.net/jeps/229
-    // http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/2c1c21d11e58/src/share/classes/sun/security/pkcs12/PKCS12KeyStore.java#l596
-    if (getPlatform().equals("jdk9")) {
-      sslBuilder.keyStoreType("JKS");
-    }
-
-    SslClient serverSslContext = sslBuilder.certificateChain(
-        rogueCertificate.keyPair, rogueCertificate.certificate, compromisedIntermediateCa.certificate, goodCertificate.certificate, rootCa.certificate)
-        .build();
-    server.useHttps(serverSslContext.socketFactory, false);
+    server.useHttps(socketFactory, false);
     server.enqueue(new MockResponse()
         .setBody("abc")
         .addHeader("Content-Type: text/plain"));
@@ -243,13 +250,13 @@
   @Test public void unrelatedPinnedIntermediateCertificateInChain() throws Exception {
     // Start with two root CA certificates, one is good and the other is compromised.
     HeldCertificate rootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(3)
+        .serialNumber(1L)
+        .certificateAuthority(1)
         .commonName("root")
         .build();
     HeldCertificate compromisedRootCa = new HeldCertificate.Builder()
-        .serialNumber("2")
-        .ca(3)
+        .serialNumber(2L)
+        .certificateAuthority(1)
         .commonName("compromised_root")
         .build();
 
@@ -257,20 +264,21 @@
     // SSL context for an HTTP client under attack. It includes the trusted CA and a pinned
     // certificate.
     HeldCertificate goodIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(rootCa)
-        .ca(2)
-        .serialNumber("3")
+        .signedBy(rootCa)
+        .certificateAuthority(0)
+        .serialNumber(3L)
         .commonName("intermediate_ca")
         .build();
     CertificatePinner certificatePinner = new CertificatePinner.Builder()
-        .add(server.getHostName(), CertificatePinner.pin(goodIntermediateCa.certificate))
+        .add(server.getHostName(), CertificatePinner.pin(goodIntermediateCa.certificate()))
         .build();
-    SslClient clientContextBuilder = new SslClient.Builder()
-        .addTrustedCertificate(rootCa.certificate)
-        .addTrustedCertificate(compromisedRootCa.certificate)
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(rootCa.certificate())
+        .addTrustedCertificate(compromisedRootCa.certificate())
         .build();
     OkHttpClient client = defaultClient().newBuilder()
-        .sslSocketFactory(clientContextBuilder.socketFactory, clientContextBuilder.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .certificatePinner(certificatePinner)
         .build();
@@ -280,32 +288,20 @@
     // serves the good CAs certificate in the chain, which means the certificate pinner sees a
     // different set of certificates than the SSL verifier.
     HeldCertificate compromisedIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(compromisedRootCa)
-        .ca(2)
-        .serialNumber("4")
+        .signedBy(compromisedRootCa)
+        .certificateAuthority(0)
+        .serialNumber(4L)
         .commonName("intermediate_ca")
         .build();
     HeldCertificate rogueCertificate = new HeldCertificate.Builder()
-        .serialNumber("5")
-        .issuedBy(compromisedIntermediateCa)
+        .serialNumber(5L)
+        .signedBy(compromisedIntermediateCa)
         .commonName(server.getHostName())
         .build();
 
-    SslClient.Builder sslBuilder = new SslClient.Builder();
-
-    // Test setup fails on JDK9
-    // java.security.KeyStoreException: Certificate chain is not valid
-    // at sun.security.pkcs12.PKCS12KeyStore.setKeyEntry
-    // http://openjdk.java.net/jeps/229
-    // http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/2c1c21d11e58/src/share/classes/sun/security/pkcs12/PKCS12KeyStore.java#l596
-    if (getPlatform().equals("jdk9")) {
-      sslBuilder.keyStoreType("JKS");
-    }
-
-    SslClient serverSslContext = sslBuilder.certificateChain(
-            rogueCertificate.keyPair, rogueCertificate.certificate, goodIntermediateCa.certificate, compromisedIntermediateCa.certificate, compromisedRootCa.certificate)
-        .build();
-    server.useHttps(serverSslContext.socketFactory, false);
+    SSLSocketFactory socketFactory = newServerSocketFactory(rogueCertificate,
+        goodIntermediateCa.certificate(), compromisedIntermediateCa.certificate());
+    server.useHttps(socketFactory, false);
     server.enqueue(new MockResponse()
         .setBody("abc")
         .addHeader("Content-Type: text/plain"));
@@ -329,4 +325,21 @@
       assertTrue(message, message.startsWith("Certificate pinning failure!"));
     }
   }
+
+  private SSLSocketFactory newServerSocketFactory(HeldCertificate heldCertificate,
+      X509Certificate... intermediates) throws GeneralSecurityException {
+    // Test setup fails on JDK9
+    // java.security.KeyStoreException: Certificate chain is not valid
+    // at sun.security.pkcs12.PKCS12KeyStore.setKeyEntry
+    // http://openjdk.java.net/jeps/229
+    // http://hg.openjdk.java.net/jdk9/jdk9/jdk/file/2c1c21d11e58/src/share/classes/sun/security/pkcs12/PKCS12KeyStore.java#l596
+    String keystoreType = getPlatform().equals("jdk9") ? "JKS" : null;
+    X509KeyManager x509KeyManager = newKeyManager(keystoreType, heldCertificate, intermediates);
+    X509TrustManager trustManager = newTrustManager(
+        keystoreType, Collections.<X509Certificate>emptyList());
+    SSLContext sslContext = Platform.get().getSSLContext();
+    sslContext.init(new KeyManager[] { x509KeyManager }, new TrustManager[] { trustManager },
+        new SecureRandom());
+    return sslContext.getSocketFactory();
+  }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
index 2ec0d6494d..ff3fb12270 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/ClientAuthTest.java
@@ -15,35 +15,44 @@
  */
 package okhttp3.internal.tls;
 
-import java.io.IOException;
 import java.net.SocketException;
 import java.security.GeneralSecurityException;
+import java.security.SecureRandom;
+import java.security.cert.X509Certificate;
+import java.util.Arrays;
+import javax.net.ssl.KeyManager;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLHandshakeException;
-import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509KeyManager;
+import javax.net.ssl.X509TrustManager;
 import javax.security.auth.x500.X500Principal;
 import okhttp3.Call;
-import okhttp3.DelegatingSSLSocketFactory;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.tls.HeldCertificate;
+import okhttp3.tls.HandshakeCertificates;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 
 import static okhttp3.TestUtil.defaultClient;
+import static okhttp3.internal.platform.PlatformTest.getPlatform;
+import static okhttp3.tls.internal.TlsUtil.newKeyManager;
+import static okhttp3.tls.internal.TlsUtil.newTrustManager;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public final class ClientAuthTest {
   @Rule public final MockWebServer server = new MockWebServer();
 
-  public enum ClientAuth {
-    NONE, WANTS, NEEDS
-  }
-
   private HeldCertificate serverRootCa;
   private HeldCertificate serverIntermediateCa;
   private HeldCertificate serverCert;
@@ -52,110 +61,121 @@
   private HeldCertificate clientCert;
 
   @Before
-  public void setUp() throws GeneralSecurityException {
+  public void setUp() {
     serverRootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(3)
+        .serialNumber(1L)
+        .certificateAuthority(1)
         .commonName("root")
+        .addSubjectAlternativeName("root_ca.com")
         .build();
     serverIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(serverRootCa)
-        .ca(2)
-        .serialNumber("2")
+        .signedBy(serverRootCa)
+        .certificateAuthority(0)
+        .serialNumber(2L)
         .commonName("intermediate_ca")
+        .addSubjectAlternativeName("intermediate_ca.com")
         .build();
 
     serverCert = new HeldCertificate.Builder()
-        .issuedBy(serverIntermediateCa)
-        .serialNumber("3")
-        .commonName(server.getHostName())
+        .signedBy(serverIntermediateCa)
+        .serialNumber(3L)
+        .commonName("Local Host")
+        .addSubjectAlternativeName(server.getHostName())
         .build();
 
     clientRootCa = new HeldCertificate.Builder()
-        .serialNumber("1")
-        .ca(13)
+        .serialNumber(1L)
+        .certificateAuthority(1)
         .commonName("root")
+        .addSubjectAlternativeName("root_ca.com")
         .build();
     clientIntermediateCa = new HeldCertificate.Builder()
-        .issuedBy(serverRootCa)
-        .ca(12)
-        .serialNumber("2")
+        .signedBy(serverRootCa)
+        .certificateAuthority(0)
+        .serialNumber(2L)
         .commonName("intermediate_ca")
+        .addSubjectAlternativeName("intermediate_ca.com")
         .build();
 
     clientCert = new HeldCertificate.Builder()
-        .issuedBy(clientIntermediateCa)
-        .serialNumber("4")
+        .signedBy(clientIntermediateCa)
+        .serialNumber(4L)
         .commonName("Jethro Willis")
+        .addSubjectAlternativeName("jethrowillis.com")
         .build();
   }
 
   @Test public void clientAuthForWants() throws Exception {
-    OkHttpClient client = buildClient(clientCert, clientIntermediateCa);
+    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
 
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.WANTS);
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
 
     server.useHttps(socketFactory, false);
+    server.requestClientAuth();
     server.enqueue(new MockResponse().setBody("abc"));
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
     Response response = call.execute();
-    assertEquals(new X500Principal("CN=localhost"), response.handshake().peerPrincipal());
+    assertEquals(new X500Principal("CN=Local Host"), response.handshake().peerPrincipal());
     assertEquals(new X500Principal("CN=Jethro Willis"), response.handshake().localPrincipal());
     assertEquals("abc", response.body().string());
   }
 
   @Test public void clientAuthForNeeds() throws Exception {
-    OkHttpClient client = buildClient(clientCert, clientIntermediateCa);
+    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
 
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NEEDS);
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
 
     server.useHttps(socketFactory, false);
+    server.requireClientAuth();
     server.enqueue(new MockResponse().setBody("abc"));
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
     Response response = call.execute();
-    assertEquals(new X500Principal("CN=localhost"), response.handshake().peerPrincipal());
+    assertEquals(new X500Principal("CN=Local Host"), response.handshake().peerPrincipal());
     assertEquals(new X500Principal("CN=Jethro Willis"), response.handshake().localPrincipal());
     assertEquals("abc", response.body().string());
   }
 
   @Test public void clientAuthSkippedForNone() throws Exception {
-    OkHttpClient client = buildClient(clientCert, clientIntermediateCa);
+    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
 
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NONE);
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
 
     server.useHttps(socketFactory, false);
+    server.noClientAuth();
     server.enqueue(new MockResponse().setBody("abc"));
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
     Response response = call.execute();
-    assertEquals(new X500Principal("CN=localhost"), response.handshake().peerPrincipal());
+    assertEquals(new X500Principal("CN=Local Host"), response.handshake().peerPrincipal());
     assertEquals(null, response.handshake().localPrincipal());
     assertEquals("abc", response.body().string());
   }
 
   @Test public void missingClientAuthSkippedForWantsOnly() throws Exception {
-    OkHttpClient client = buildClient(null, clientIntermediateCa);
+    OkHttpClient client = buildClient(null, clientIntermediateCa.certificate());
 
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.WANTS);
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
 
     server.useHttps(socketFactory, false);
+    server.requestClientAuth();
     server.enqueue(new MockResponse().setBody("abc"));
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
     Response response = call.execute();
-    assertEquals(new X500Principal("CN=localhost"), response.handshake().peerPrincipal());
+    assertEquals(new X500Principal("CN=Local Host"), response.handshake().peerPrincipal());
     assertEquals(null, response.handshake().localPrincipal());
     assertEquals("abc", response.body().string());
   }
 
   @Test public void missingClientAuthFailsForNeeds() throws Exception {
-    OkHttpClient client = buildClient(null, clientIntermediateCa);
+    OkHttpClient client = buildClient(null, clientIntermediateCa.certificate());
 
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NEEDS);
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
 
     server.useHttps(socketFactory, false);
+    server.requireClientAuth();
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
 
@@ -163,22 +183,50 @@ public void setUp() throws GeneralSecurityException {
       call.execute();
       fail();
     } catch (SSLHandshakeException expected) {
+    } catch (SSLException expected) {
+      String jvmVersion = System.getProperty("java.specification.version");
+      assertEquals("11", jvmVersion);
     } catch (SocketException expected) {
-      // JDK 9
+      assertEquals("jdk9", getPlatform());
+    }
+  }
+
+  @Test public void commonNameIsNotTrusted() throws Exception {
+    serverCert = new HeldCertificate.Builder()
+        .signedBy(serverIntermediateCa)
+        .serialNumber(3L)
+        .commonName(server.getHostName())
+        .addSubjectAlternativeName("different-host.com")
+        .build();
+
+    OkHttpClient client = buildClient(clientCert, clientIntermediateCa.certificate());
+
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
+
+    server.useHttps(socketFactory, false);
+    server.requireClientAuth();
+
+    Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
+
+    try {
+      call.execute();
+      fail();
+    } catch (SSLPeerUnverifiedException expected) {
     }
   }
 
   @Test public void invalidClientAuthFails() throws Throwable {
     HeldCertificate clientCert2 = new HeldCertificate.Builder()
-        .serialNumber("4")
+        .serialNumber(4L)
         .commonName("Jethro Willis")
         .build();
 
     OkHttpClient client = buildClient(clientCert2);
 
-    SSLSocketFactory socketFactory = buildServerSslSocketFactory(ClientAuth.NEEDS);
+    SSLSocketFactory socketFactory = buildServerSslSocketFactory();
 
     server.useHttps(socketFactory, false);
+    server.requireClientAuth();
 
     Call call = client.newCall(new Request.Builder().url(server.url("/")).build());
 
@@ -186,42 +234,45 @@ public void setUp() throws GeneralSecurityException {
       call.execute();
       fail();
     } catch (SSLHandshakeException expected) {
+    } catch (SSLException expected) {
+      // javax.net.ssl.SSLException: readRecord
+      String jvmVersion = System.getProperty("java.specification.version");
+      assertEquals("11", jvmVersion);
     } catch (SocketException expected) {
-      // JDK 9
+      assertEquals("jdk9", getPlatform());
     }
   }
 
-  public OkHttpClient buildClient(HeldCertificate cert, HeldCertificate... chain) {
-    SslClient.Builder sslClientBuilder = new SslClient.Builder()
-        .addTrustedCertificate(serverRootCa.certificate);
+  private OkHttpClient buildClient(
+      HeldCertificate heldCertificate, X509Certificate... intermediates) {
+    HandshakeCertificates.Builder builder = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(serverRootCa.certificate());
 
-    if (cert != null) {
-      sslClientBuilder.certificateChain(cert, chain);
+    if (heldCertificate != null) {
+      builder.heldCertificate(heldCertificate, intermediates);
     }
 
-    SslClient sslClient = sslClientBuilder.build();
+    HandshakeCertificates handshakeCertificates = builder.build();
     return defaultClient().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .build();
   }
 
-  public SSLSocketFactory buildServerSslSocketFactory(final ClientAuth clientAuth) {
-    SslClient serverSslClient = new SslClient.Builder()
-        .addTrustedCertificate(serverRootCa.certificate)
-        .addTrustedCertificate(clientRootCa.certificate)
-        .certificateChain(serverCert, serverIntermediateCa)
-        .build();
-
-    return new DelegatingSSLSocketFactory(serverSslClient.socketFactory) {
-      @Override protected SSLSocket configureSocket(SSLSocket sslSocket) throws IOException {
-        if (clientAuth == ClientAuth.NEEDS) {
-          sslSocket.setNeedClientAuth(true);
-        } else if (clientAuth == ClientAuth.WANTS) {
-          sslSocket.setWantClientAuth(true);
-        }
-
-        return super.configureSocket(sslSocket);
-      }
-    };
+  private SSLSocketFactory buildServerSslSocketFactory() {
+    // The test uses JDK default SSL Context instead of the Platform provided one
+    // as Conscrypt seems to have some differences, we only want to test client side here.
+    try {
+      X509KeyManager keyManager = newKeyManager(
+          null, serverCert, serverIntermediateCa.certificate());
+      X509TrustManager trustManager = newTrustManager(
+          null, Arrays.asList(serverRootCa.certificate(), clientRootCa.certificate()));
+      SSLContext sslContext = SSLContext.getInstance("TLS");
+      sslContext.init(new KeyManager[] {keyManager}, new TrustManager[] {trustManager},
+          new SecureRandom());
+      return sslContext.getSocketFactory();
+    } catch (GeneralSecurityException e) {
+      throw new AssertionError(e);
+    }
   }
 }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java
new file mode 100644
index 0000000000..09c22b8594
--- /dev/null
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/DistinguishedNameParserTest.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+
+import javax.security.auth.x500.X500Principal;
+
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class DistinguishedNameParserTest {
+  @Test public void regularCases() {
+    assertCn("xxx", "ou=xxx,cn=xxx");
+    assertCn("yyy", "ou=xxx+cn=yyy,cn=zzz+cn=abc");
+    assertCn("a", "cn=a,cn=b");
+    assertCn("a   c", "cn=a   c,cn=b");
+    assertCn("Cc", "cn=Cc,cn=Bb,cn=Aa");
+    assertCn("imap.gmail.com", "cn=imap.gmail.com");
+    assertCn("c", "l=\"abcn=a,b\", cn=c");
+    assertCn("c", "l=\"abcn=a,b\", cn=c");
+    assertCn("c", "l=\"abcn=a,b\", cn= c");
+    assertCn("a b", "cn=a b");
+    assertCn("a b", "cn   =a b");
+    assertCn("a b", "Cn=a b");
+    assertCn("a b", "cN=a b");
+    assertCn("a b", "CN=a b");
+    assertCn("a#b", "cn=a#b");
+    assertCn("a", "cn=#130161");
+    assertCn("p", "l=q\t+cn=p");
+    assertCn("p", "l=q\n+cn=p");
+    assertCn("p", "l=q\n,cn=p");
+    assertCn("p", "l=,cn=p");
+    assertCn("\tp", "l=\tq\n,cn=\tp");
+  }
+
+  @Test public void emptyValues() {
+    assertCn(null, "");
+    assertCn(null, "ou=xxx");
+    assertCn("", "l=,cn=+cn=q");
+    assertCn("", "l=,cn=,cn=q");
+    assertCn(null, "l=,cn=");
+    assertCn("q", "l=,cn=q,cn=   ");
+    assertCn("q", "l=,cn=q  ,cn=   ");
+    assertCn(null, "l=,cn=\"\"");
+    assertCn("", "l=,cn=  ,cn=  ");
+    assertCn("", "l=,cn=,cn=  ,cn=  ");
+  }
+
+  @Test public void escapedChars() {
+    assertCn(",", "cn=\\,");
+    assertCn("#", "cn=\\#");
+    assertCn("+", "cn=\\+");
+    assertCn("\"", "cn=\\\"");
+    assertCn("\\", "cn=\\\\");
+    assertCn("<", "cn=\\<");
+    assertCn(">", "cn=\\>");
+    assertCn(";", "cn=\\;");
+    assertCn("+", "cn=\\+");
+    assertCn("+", "cn=\"\\+\"");
+    assertCn(",", "cn=\"\\,\"");
+    assertCn("a =", "cn= a =");
+    assertCn("=", "cn==");
+  }
+
+  @Test public void whitespace() {
+    assertCn("p", "cn= p");
+    assertCn("p", "cn=\np");
+    assertCn("\tp", "cn=\tp");
+  }
+
+  @Test public void withOid() {
+    assertCn("a", "2.5.4.3=a,ou=xxx");
+    assertCn("a", "2.5.4.3=\" a \",ou=xxx");
+    assertCn("b", "2.5.5.3=a,ou=xxx,cn=b");
+  }
+
+  @Test public void quotedStrings() {
+    assertCn("\" a ,=<>#;", "cn=\"\\\" a ,=<>#;\"");
+    assertCn("abc,def", "cn=abc\\,def");
+    assertCn("\" a ,=<>#;", "cn=\"\\\" a ,\\=<>\\#;\"");
+  }
+
+  @Test public void utf8() {
+    assertCn("\u004c\u0075\u010d\u0069\u0107", "cn=\"Lu\\C4\\8Di\\C4\\87\"");
+    assertCn("\u004c\u0075\u010d\u0069\u0107", "cn=Lu\\C4\\8Di\\C4\\87");
+    assertCn("\u004c\u0075\u010d\u0069\u0107", "cn=Lu\\C4\\8di\\c4\\87");
+    assertCn("\u004c\u0075\u010d\u0069\u0107", "cn=\"Lu\\C4\\8di\\c4\\87\"");
+    assertCn("\u004c\u0075\u010d\u0069\u0107", "cn=\u004c\u0075\u010d\u0069\u0107");
+    // \63=c
+    expectExceptionInPrincipal("\\63n=ab");
+    expectExceptionInPrincipal("cn=\\a");
+  }
+
+  @Test public void trailingWhitespace() {
+    assertCn("a  b", "ou=a, cn=  a  b  ,o=x");
+    assertCn("a  b", "cn=\"  a  b  \" ,o=x");
+    assertCn("a", "cn=a   ,cn=b");
+    assertCn("", "l=,cn=\"  \",cn=\"  \"");
+  }
+
+  /**
+   * @param expected the value of the first "cn=" argument in {@code dn},
+   *                 or null if none is expected
+   */
+  private void assertCn(String expected, String dn) {
+    X500Principal principal = new X500Principal(dn);
+    DistinguishedNameParser parser = new DistinguishedNameParser(principal);
+    assertEquals(dn, expected, parser.findMostSpecific("cn"));
+  }
+
+  private void expectExceptionInPrincipal(String dn) {
+    try {
+      new X500Principal(dn);
+      fail("Expected " + IllegalArgumentException.class.getName()
+          + " because of incorrect input name");
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+}
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java b/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
index f03f197d94..6dd5bbbd7c 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/tls/HostnameVerifierTest.java
@@ -72,7 +72,7 @@
         + "HwlNrAu8jlZ2UqSgskSWlhYdMTAP9CPHiUv9N7FcT58Itv/I4fKREINQYjDpvQcx\n"
         + "SaTYb9dr5sB4WLNglk7zxDtM80H518VvihTcP7FHL+Gn6g4j5fkI98+S\n"
         + "-----END CERTIFICATE-----\n");
-    assertTrue(verifier.verify("foo.com", session));
+    assertFalse(verifier.verify("foo.com", session));
     assertFalse(verifier.verify("a.foo.com", session));
     assertFalse(verifier.verify("bar.com", session));
   }
@@ -105,7 +105,7 @@
         + "9BsO7qe46hidgn39hKh1WjKK2VcL/3YRsC4wUi0PBtFW6ScMCuMhgIRXSPU55Rae\n"
         + "UIlOdPjjr1SUNWGId1rD7W16Scpwnknn310FNxFMHVI0GTGFkNdkilNCFJcIoRA=\n"
         + "-----END CERTIFICATE-----\n");
-    assertTrue(verifier.verify("\u82b1\u5b50.co.jp", session));
+    assertFalse(verifier.verify("\u82b1\u5b50.co.jp", session));
     assertFalse(verifier.verify("a.\u82b1\u5b50.co.jp", session));
   }
 
@@ -258,7 +258,7 @@
     assertFalse(verifier.verify("a.foo.com", session));
     assertFalse(verifier.verify("bar.com", session));
     assertFalse(verifier.verify("a.bar.com", session));
-    assertTrue(verifier.verify("\u82b1\u5b50.co.jp", session));
+    assertFalse(verifier.verify("\u82b1\u5b50.co.jp", session));
     assertFalse(verifier.verify("a.\u82b1\u5b50.co.jp", session));
   }
 
@@ -291,8 +291,8 @@
         + "l3Q/RK95bnA6cuRClGusLad0e6bjkBzx/VQ3VarDEpAkTLUGVAa0CLXtnyc=\n"
         + "-----END CERTIFICATE-----\n");
     assertFalse(verifier.verify("foo.com", session));
-    assertTrue(verifier.verify("www.foo.com", session));
-    assertTrue(verifier.verify("\u82b1\u5b50.foo.com", session));
+    assertFalse(verifier.verify("www.foo.com", session));
+    assertFalse(verifier.verify("\u82b1\u5b50.foo.com", session));
     assertFalse(verifier.verify("a.b.foo.com", session));
   }
 
@@ -325,8 +325,8 @@
         + "UGPLEUDzRHMPHLnSqT1n5UU5UDRytbjJPXzF+l/+WZIsanefWLsxnkgAuZe/oMMF\n"
         + "EJMryEzOjg4Tfuc5qM0EXoPcQ/JlheaxZ40p2IyHqbsWV4MRYuFH4bkM\n"
         + "-----END CERTIFICATE-----\n");
-    assertTrue(verifier.verify("foo.co.jp", session));
-    assertTrue(verifier.verify("\u82b1\u5b50.co.jp", session));
+    assertFalse(verifier.verify("foo.co.jp", session));
+    assertFalse(verifier.verify("\u82b1\u5b50.co.jp", session));
   }
 
   /**
@@ -451,7 +451,7 @@
         + "U6LFxmZr31lFyis2/T68PpjAppc0DpNQuA2m/Y7oTHBDi55Fw6HVHCw3lucuWZ5d\n"
         + "qUYo4ES548JdpQtcLrW2sA==\n"
         + "-----END CERTIFICATE-----");
-    assertTrue(verifier.verify("google.com", session));
+    assertFalse(verifier.verify("google.com", session));
   }
 
   @Test public void subjectAltName() throws Exception {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
index f91fafd63b..38b2762e6a 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/RealWebSocketTest.java
@@ -18,6 +18,7 @@
 import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
+import java.net.SocketTimeoutException;
 import java.util.Random;
 import java.util.concurrent.TimeUnit;
 import okhttp3.Protocol;
@@ -34,6 +35,7 @@
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 public final class RealWebSocketTest {
   // NOTE: Fields are named 'client' and 'server' for cognitive simplicity. This differentiation has
@@ -52,9 +54,13 @@
     server.initWebSocket(random, 0);
   }
 
-  @After public void tearDown() {
+  @After public void tearDown() throws Exception {
     client.listener.assertExhausted();
     server.listener.assertExhausted();
+    server.source.close();
+    client.source.close();
+    server.webSocket.tearDown();
+    client.webSocket.tearDown();
   }
 
   @Test public void close() throws IOException {
@@ -75,6 +81,15 @@
     assertFalse(client.webSocket.send("Hello!"));
   }
 
+  @Test public void clientCloseWith0Fails() throws IOException {
+    try {
+      client.webSocket.close(0, null);
+      fail();
+    } catch (IllegalArgumentException expected) {
+      assertEquals(expected.getMessage(), "Code must be in range [1000,5000): 0");
+    }
+  }
+
   @Test public void afterSocketClosedPingFailsWebSocket() throws IOException {
     client2Server.source().close();
     client.webSocket.pong(ByteString.encodeUtf8("Ping!"));
@@ -199,7 +214,7 @@
     client.listener.assertFailure(ProtocolException.class, "Control frames must be final.");
 
     server.processNextFrame();
-    server.listener.assertFailure(EOFException.class, null);
+    server.listener.assertFailure(EOFException.class);
   }
 
   @Test public void protocolErrorInCloseResponseClosesConnection() throws IOException {
@@ -238,7 +253,7 @@
   @Test public void networkErrorReportedAsFailure() throws IOException {
     server.sink.close();
     client.processNextFrame();
-    client.listener.assertFailure(EOFException.class, null);
+    client.listener.assertFailure(EOFException.class);
   }
 
   @Test public void closeThrowingFailsConnection() throws IOException {
@@ -290,6 +305,43 @@
     assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing3), 250d);
   }
 
+  @Test public void unacknowledgedPingFailsConnection() throws IOException {
+    long startNanos = System.nanoTime();
+    client.initWebSocket(random, 500);
+
+    // Don't process the ping and pong frames!
+    client.listener.assertFailure(SocketTimeoutException.class,
+        "sent ping but didn't receive pong within 500ms (after 0 successful ping/pongs)");
+    long elapsedUntilFailure = System.nanoTime() - startNanos;
+    assertEquals(1000, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
+  }
+
+  @Test public void unexpectedPongsDoNotInterfereWithFailureDetection() throws IOException {
+    long startNanos = System.nanoTime();
+    client.initWebSocket(random, 500);
+
+    // At 0ms the server sends 3 unexpected pongs. The client accepts 'em and ignores em.
+    server.webSocket.pong(ByteString.encodeUtf8("pong 1"));
+    client.processNextFrame();
+    server.webSocket.pong(ByteString.encodeUtf8("pong 2"));
+    client.processNextFrame();
+    server.webSocket.pong(ByteString.encodeUtf8("pong 3"));
+    client.processNextFrame();
+
+    // After 500ms the client automatically pings and the server pongs back.
+    server.processNextFrame(); // Ping.
+    client.processNextFrame(); // Pong.
+    long elapsedUntilPing = System.nanoTime() - startNanos;
+    assertEquals(500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPing), 250d);
+
+    // After 1000ms the client will attempt a ping 2, but we don't process it. That'll cause the
+    // client to fail at 1500ms when it's time to send ping 3 because pong 2 hasn't been received.
+    client.listener.assertFailure(SocketTimeoutException.class,
+        "sent ping but didn't receive pong within 500ms (after 1 successful ping/pongs)");
+    long elapsedUntilFailure = System.nanoTime() - startNanos;
+    assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
+  }
+
   /** One peer's streams, listener, and web socket in the test. */
   private static class TestStreams extends RealWebSocket.Streams {
     private final String name;
@@ -308,11 +360,12 @@ public void initWebSocket(Random random, int pingIntervalMillis) throws IOExcept
       String url = "http://example.com/websocket";
       Response response = new Response.Builder()
           .code(101)
+          .message("OK")
           .request(new Request.Builder().url(url).build())
           .protocol(Protocol.HTTP_1_1)
           .build();
-      webSocket = new RealWebSocket(response.request(), listener, random);
-      webSocket.initReaderAndWriter(name, pingIntervalMillis, this);
+      webSocket = new RealWebSocket(response.request(), listener, random, pingIntervalMillis);
+      webSocket.initReaderAndWriter(name, this);
     }
 
     public boolean processNextFrame() throws IOException {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
index eaff205fd8..565ffdac58 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketHttpTest.java
@@ -15,27 +15,31 @@
  */
 package okhttp3.internal.ws;
 
+import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.net.SocketTimeoutException;
+import java.util.Collections;
 import java.util.Random;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.logging.Logger;
 import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
+import okhttp3.RecordingEventListener;
 import okhttp3.RecordingHostnameVerifier;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.TestLogHandler;
 import okhttp3.WebSocket;
 import okhttp3.WebSocketListener;
-import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.Dispatcher;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
 import okhttp3.mockwebserver.SocketPolicy;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.ByteString;
 import org.junit.After;
@@ -45,6 +49,7 @@
 
 import static okhttp3.TestUtil.defaultClient;
 import static okhttp3.TestUtil.repeat;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -55,7 +60,7 @@
 public final class WebSocketHttpTest {
   @Rule public final MockWebServer webServer = new MockWebServer();
 
-  private final SslClient sslClient = SslClient.localhost();
+  private final HandshakeCertificates handshakeCertificates = localhost();
   private final WebSocketRecorder clientListener = new WebSocketRecorder("client");
   private final WebSocketRecorder serverListener = new WebSocketRecorder("server");
   private final Random random = new Random(0);
@@ -75,7 +80,7 @@
     clientListener.assertExhausted();
   }
 
-  @Test public void textMessage() throws IOException {
+  @Test public void textMessage() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     WebSocket webSocket = newWebSocket();
 
@@ -86,7 +91,7 @@
     serverListener.assertTextMessage("Hello, WebSockets!");
   }
 
-  @Test public void binaryMessage() throws IOException {
+  @Test public void binaryMessage() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     WebSocket webSocket = newWebSocket();
 
@@ -97,7 +102,7 @@
     serverListener.assertBinaryMessage(ByteString.of(new byte[] {'H', 'e', 'l', 'l', 'o', '!'}));
   }
 
-  @Test public void nullStringThrows() throws IOException {
+  @Test public void nullStringThrows() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     WebSocket webSocket = newWebSocket();
 
@@ -110,7 +115,7 @@
     }
   }
 
-  @Test public void nullByteStringThrows() throws IOException {
+  @Test public void nullByteStringThrows() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     WebSocket webSocket = newWebSocket();
 
@@ -123,7 +128,7 @@
     }
   }
 
-  @Test public void serverMessage() throws IOException {
+  @Test public void serverMessage() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     newWebSocket();
 
@@ -151,7 +156,7 @@
   }
 
   @Ignore("AsyncCall currently lets runtime exceptions propagate.")
-  @Test public void throwingOnFailLogs() throws InterruptedException {
+  @Test public void throwingOnFailLogs() throws Exception {
     TestLogHandler logs = new TestLogHandler();
     Logger logger = Logger.getLogger(OkHttpClient.class.getName());
     logger.addHandler(logs);
@@ -171,7 +176,7 @@
     logger.removeHandler(logs);
   }
 
-  @Test public void throwingOnMessageClosesImmediatelyAndFails() throws IOException {
+  @Test public void throwingOnMessageClosesImmediatelyAndFails() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     newWebSocket();
 
@@ -187,10 +192,11 @@
 
     server.send("Hello, WebSockets!");
     clientListener.assertFailure(e);
+    serverListener.assertFailure(EOFException.class);
     serverListener.assertExhausted();
   }
 
-  @Test public void throwingOnClosingClosesImmediatelyAndFails() throws IOException {
+  @Test public void throwingOnClosingClosesImmediatelyAndFails() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     newWebSocket();
 
@@ -206,6 +212,40 @@
 
     server.close(1000, "bye");
     clientListener.assertFailure(e);
+    serverListener.assertFailure();
+    serverListener.assertExhausted();
+  }
+
+  @Test public void unplannedCloseHandledByCloseWithoutFailure() {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+    clientListener.setNextEventDelegate(new WebSocketListener() {
+      @Override public void onClosing(WebSocket webSocket, int code, String reason) {
+        webSocket.close(1000, null);
+      }
+    });
+
+    server.close(1001, "bye");
+    clientListener.assertClosed(1001, "bye");
+    clientListener.assertExhausted();
+    serverListener.assertClosing(1000,  "");
+    serverListener.assertClosed(1000,  "");
+    serverListener.assertExhausted();
+  }
+
+  @Test public void unplannedCloseHandledWithoutFailure() {
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    server.close(1001, "bye");
+    clientListener.assertClosing(1001, "bye");
+    clientListener.assertExhausted();
     serverListener.assertExhausted();
   }
 
@@ -225,7 +265,7 @@
         "Expected HTTP 101 response but was '404 Not Found'");
   }
 
-  @Test public void clientTimeoutClosesBody() throws IOException {
+  @Test public void clientTimeoutClosesBody() {
     webServer.enqueue(new MockResponse().setResponseCode(408));
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     WebSocket webSocket = newWebSocket();
@@ -309,7 +349,7 @@
         "Expected 'Sec-WebSocket-Accept' header value 'ujmZX4KXZqjwy6vi1aQFH5p4Ygk=' but was 'magic'");
   }
 
-  @Test public void webSocketAndApplicationInterceptors() throws IOException {
+  @Test public void webSocketAndApplicationInterceptors() {
     final AtomicInteger interceptedCount = new AtomicInteger();
 
     client = client.newBuilder()
@@ -318,7 +358,7 @@
             assertNull(chain.request().body());
             Response response = chain.proceed(chain.request());
             assertEquals("Upgrade", response.header("Connection"));
-            assertTrue("", response.body().source().exhausted());
+            assertTrue(response.body().source().exhausted());
             interceptedCount.incrementAndGet();
             return response;
           }
@@ -335,10 +375,10 @@
     server.close(1000, null);
   }
 
-  @Test public void webSocketAndNetworkInterceptors() throws IOException {
+  @Test public void webSocketAndNetworkInterceptors() {
     client = client.newBuilder()
         .addNetworkInterceptor(new Interceptor() {
-          @Override public Response intercept(Chain chain) throws IOException {
+          @Override public Response intercept(Chain chain) {
             throw new AssertionError(); // Network interceptors don't execute.
           }
         }).build();
@@ -353,7 +393,7 @@
     server.close(1000, null);
   }
 
-  @Test public void overflowOutgoingQueue() throws IOException {
+  @Test public void overflowOutgoingQueue() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
     WebSocket webSocket = newWebSocket();
@@ -386,7 +426,7 @@
     serverListener.assertClosed(1001, "");
   }
 
-  @Test public void closeReasonMaximumLength() throws IOException {
+  @Test public void closeReasonMaximumLength() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
     String clientReason = repeat('C', 123);
@@ -406,7 +446,7 @@
     serverListener.assertClosed(1000, clientReason);
   }
 
-  @Test public void closeReasonTooLong() throws IOException {
+  @Test public void closeReasonTooLong() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
     WebSocket webSocket = newWebSocket();
@@ -431,41 +471,43 @@
     serverListener.assertClosed(1000, "");
   }
 
-  @Test public void wsScheme() throws IOException {
+  @Test public void wsScheme() {
     websocketScheme("ws");
   }
 
-  @Test public void wsUppercaseScheme() throws IOException {
+  @Test public void wsUppercaseScheme() {
     websocketScheme("WS");
   }
 
-  @Test public void wssScheme() throws IOException {
-    webServer.useHttps(sslClient.socketFactory, false);
+  @Test public void wssScheme() {
+    webServer.useHttps(handshakeCertificates.sslSocketFactory(), false);
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
 
     websocketScheme("wss");
   }
 
-  @Test public void httpsScheme() throws IOException {
-    webServer.useHttps(sslClient.socketFactory, false);
+  @Test public void httpsScheme() {
+    webServer.useHttps(handshakeCertificates.sslSocketFactory(), false);
     client = client.newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(new RecordingHostnameVerifier())
         .build();
 
     websocketScheme("https");
   }
 
-  @Test public void readTimeoutAppliesToHttpRequest() throws IOException {
+  @Test public void readTimeoutAppliesToHttpRequest() {
     webServer.enqueue(new MockResponse()
         .setSocketPolicy(SocketPolicy.NO_RESPONSE));
 
     WebSocket webSocket = newWebSocket();
 
-    clientListener.assertFailure(SocketTimeoutException.class, "timeout");
+    clientListener.assertFailure(SocketTimeoutException.class, "timeout", "Read timed out");
     assertFalse(webSocket.close(1000, null));
   }
 
@@ -474,9 +516,9 @@
    * reading a frame we enable the read timeout. In this test we have the server returning the first
    * byte of a frame but no more frames.
    */
-  @Test public void readTimeoutAppliesWithinFrames() throws IOException {
+  @Test public void readTimeoutAppliesWithinFrames() {
     webServer.setDispatcher(new Dispatcher() {
-      @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+      @Override public MockResponse dispatch(RecordedRequest request) {
         return upgradeResponse(request)
             .setBody(new Buffer().write(ByteString.decodeHex("81"))) // Truncated frame.
             .removeHeader("Content-Length")
@@ -487,7 +529,7 @@
     WebSocket webSocket = newWebSocket();
     clientListener.assertOpen();
 
-    clientListener.assertFailure(SocketTimeoutException.class, "timeout");
+    clientListener.assertFailure(SocketTimeoutException.class, "timeout", "Read timed out");
     assertFalse(webSocket.close(1000, null));
   }
 
@@ -517,7 +559,7 @@
     RealWebSocket server = (RealWebSocket) serverListener.assertOpen();
 
     long startNanos = System.nanoTime();
-    while (webSocket.pongCount() < 3) {
+    while (webSocket.receivedPongCount() < 3) {
       Thread.sleep(50);
     }
 
@@ -525,12 +567,13 @@
     assertEquals(1500, TimeUnit.NANOSECONDS.toMillis(elapsedUntilPong3), 250d);
 
     // The client pinged the server 3 times, and it has ponged back 3 times.
-    assertEquals(3, server.pingCount());
-    assertEquals(3, webSocket.pongCount());
+    assertEquals(3, webSocket.sentPingCount());
+    assertEquals(3, server.receivedPingCount());
+    assertEquals(3, webSocket.receivedPongCount());
 
     // The server has never pinged the client.
-    assertEquals(0, server.pongCount());
-    assertEquals(0, webSocket.pingCount());
+    assertEquals(0, server.receivedPongCount());
+    assertEquals(0, webSocket.receivedPingCount());
   }
 
   @Test public void clientDoesNotPingServerByDefault() throws Exception {
@@ -543,14 +586,49 @@
     Thread.sleep(1000);
 
     // No pings and no pongs.
-    assertEquals(0, server.pingCount());
-    assertEquals(0, webSocket.pongCount());
-    assertEquals(0, server.pongCount());
-    assertEquals(0, webSocket.pingCount());
+    assertEquals(0, webSocket.sentPingCount());
+    assertEquals(0, webSocket.receivedPingCount());
+    assertEquals(0, webSocket.receivedPongCount());
+    assertEquals(0, server.sentPingCount());
+    assertEquals(0, server.receivedPingCount());
+    assertEquals(0, server.receivedPongCount());
+  }
+
+  /**
+   * Configure the websocket to send pings every 500 ms. Artificially prevent the server from
+   * responding to pings. The client should give up when attempting to send its 2nd ping, at about
+   * 1000 ms.
+   */
+  @Test public void unacknowledgedPingFailsConnection() {
+    client = client.newBuilder()
+        .pingInterval(500, TimeUnit.MILLISECONDS)
+        .build();
+
+    // Stall in onOpen to prevent pongs from being sent.
+    final CountDownLatch latch = new CountDownLatch(1);
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(new WebSocketListener() {
+      @Override public void onOpen(WebSocket webSocket, Response response) {
+        try {
+          latch.await(); // The server can't respond to pings!
+        } catch (InterruptedException e) {
+          throw new AssertionError(e);
+        }
+      }
+    }));
+
+    long openAtNanos = System.nanoTime();
+    newWebSocket();
+    clientListener.assertOpen();
+    clientListener.assertFailure(SocketTimeoutException.class,
+        "sent ping but didn't receive pong within 500ms (after 0 successful ping/pongs)");
+    latch.countDown();
+
+    long elapsedUntilFailure = System.nanoTime() - openAtNanos;
+    assertEquals(1000, TimeUnit.NANOSECONDS.toMillis(elapsedUntilFailure), 250d);
   }
 
   /** https://github.com/square/okhttp/issues/2788 */
-  @Test public void clientCancelsIfCloseIsNotAcknowledged() throws Exception {
+  @Test public void clientCancelsIfCloseIsNotAcknowledged() {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
     RealWebSocket webSocket = newWebSocket();
 
@@ -572,6 +650,33 @@
     serverListener.assertClosed(1000, "goodbye");
   }
 
+  @Test public void webSocketsDontTriggerEventListener() {
+    RecordingEventListener listener = new RecordingEventListener();
+
+    client = client.newBuilder()
+        .eventListener(listener)
+        .build();
+
+    webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
+    WebSocket webSocket = newWebSocket();
+
+    clientListener.assertOpen();
+    WebSocket server = serverListener.assertOpen();
+
+    webSocket.send("Web Sockets and Events?!");
+    serverListener.assertTextMessage("Web Sockets and Events?!");
+
+    webSocket.close(1000, "");
+    serverListener.assertClosing(1000, "");
+
+    server.close(1000, "");
+    clientListener.assertClosing(1000, "");
+    clientListener.assertClosed(1000, "");
+    serverListener.assertClosed(1000, "");
+
+    assertEquals(Collections.emptyList(), listener.recordedEventTypes());
+  }
+
   private MockResponse upgradeResponse(RecordedRequest request) {
     String key = request.getHeader("Sec-WebSocket-Key");
     return new MockResponse()
@@ -581,7 +686,7 @@ private MockResponse upgradeResponse(RecordedRequest request) {
         .setHeader("Sec-WebSocket-Accept", WebSocketProtocol.acceptHeader(key));
   }
 
-  private void websocketScheme(String scheme) throws IOException {
+  private void websocketScheme(String scheme) {
     webServer.enqueue(new MockResponse().withWebSocketUpgrade(serverListener));
 
     Request request = new Request.Builder()
@@ -601,7 +706,8 @@ private RealWebSocket newWebSocket() {
   }
 
   private RealWebSocket newWebSocket(Request request) {
-    RealWebSocket webSocket = new RealWebSocket(request, clientListener, random);
+    RealWebSocket webSocket = new RealWebSocket(
+        request, clientListener, random, client.pingIntervalMillis());
     webSocket.connect(client);
     return webSocket;
   }
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
index 21cf06df5d..9fa5d1d9dc 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketReaderTest.java
@@ -271,6 +271,13 @@
     callback.assertClosing(1000, "Hello");
   }
 
+  @Test public void closeIncompleteCallsCallback() throws IOException {
+    data.write(ByteString.decodeHex("880703e948656c6c6f")); // Close with code and reason
+    data.close();
+    clientReader.processNextFrame();
+    callback.assertClosing(1001, "Hello");
+  }
+
   @Test public void closeOutOfRangeThrows() throws IOException {
     data.write(ByteString.decodeHex("88020001")); // Close with code 1
     try {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
index ac5626ce57..f6256ac42f 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketRecorder.java
@@ -16,9 +16,11 @@
 package okhttp3.internal.ws;
 
 import java.io.IOException;
+import java.util.Arrays;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 import okhttp3.Response;
 import okhttp3.WebSocket;
 import okhttp3.WebSocketListener;
@@ -107,7 +109,7 @@ public void setNextEventDelegate(WebSocketListener delegate) {
     }
   }
 
-  @Override public void onFailure(WebSocket webSocket, Throwable t, Response response)  {
+  @Override public void onFailure(WebSocket webSocket, Throwable t, @Nullable Response response)  {
     Platform.get().log(Platform.INFO, "[WS " + name + "] onFailure", t);
 
     WebSocketListener delegate = this.delegate;
@@ -183,7 +185,7 @@ public void assertFailure(Throwable t) {
     assertSame(t, failure.t);
   }
 
-  public void assertFailure(Class<? extends IOException> cls, String message) {
+  public void assertFailure(Class<? extends IOException> cls, String... messages) {
     Object event = nextEvent();
     if (!(event instanceof Failure)) {
       throw new AssertionError("Expected Failure but was " + event);
@@ -191,7 +193,9 @@ public void assertFailure(Class<? extends IOException> cls, String message) {
     Failure failure = (Failure) event;
     assertNull(failure.response);
     assertEquals(cls, failure.t.getClass());
-    assertEquals(message, failure.t.getMessage());
+    if (messages.length > 0) {
+      assertTrue(failure.t.getMessage(), Arrays.asList(messages).contains(failure.t.getMessage()));
+    }
   }
 
   public void assertFailure() {
diff --git a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
index a303cc1052..e183d0e2a8 100644
--- a/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
+++ b/okhttp-tests/src/test/java/okhttp3/internal/ws/WebSocketWriterTest.java
@@ -174,15 +174,19 @@
   }
 
   @Test public void serverBinaryMessage() throws IOException {
+    ByteString data = ByteString.decodeHex(""
+        + "60b420bb3851d9d47acb933dbe70399bf6c92da33af01d4fb7"
+        + "70e98c0325f41d3ebaf8986da712c82bcd4d554bf0b54023c2");
+
     BufferedSink sink = Okio.buffer(serverWriter.newMessageSink(OPCODE_BINARY, -1));
 
-    sink.write(binaryData(50)).flush();
+    sink.write(data).flush();
     assertData("0232");
-    assertData(binaryData(50));
+    assertData(data);
 
-    sink.write(binaryData(50)).flush();
+    sink.write(data).flush();
     assertData("0032");
-    assertData(binaryData(50));
+    assertData(data);
 
     sink.close();
     assertData("8000");
@@ -229,28 +233,25 @@
   }
 
   @Test public void clientBinary() throws IOException {
-    byte[] maskKey1 = new byte[4];
-    random.nextBytes(maskKey1);
-    byte[] maskKey2 = new byte[4];
-    random.nextBytes(maskKey2);
-
-    random.setSeed(0); // Reset the seed so real data matches.
+    ByteString data = ByteString.decodeHex(""
+        + "60b420bb3851d9d47acb933dbe70399bf6c92da33af01d4fb7"
+        + "70e98c0325f41d3ebaf8986da712c82bcd4d554bf0b54023c2");
 
     BufferedSink sink = Okio.buffer(clientWriter.newMessageSink(OPCODE_BINARY, -1));
 
-    byte[] part1 = binaryData(50);
-    sink.write(part1).flush();
-    toggleMask(part1, 50, maskKey1, 0);
+    sink.write(data).flush();
     assertData("02b2");
-    assertData(maskKey1);
-    assertData(part1);
+    assertData("60b420bb");
+    assertData(""
+        + "0000000058e5f96f1a7fb386dec41920967d0d185a443df4d7"
+        + "c4c9376391d4a65e0ed8230d1332734b796dee2b4495fb4376");
 
-    byte[] part2 = binaryData(50);
-    sink.write(part2).close();
-    toggleMask(part2, 50, maskKey2, 0);
+    sink.write(data).close();
     assertData("80b2");
-    assertData(maskKey2);
-    assertData(part2);
+    assertData("3851d9d4");
+    assertData(""
+        + "58e5f96f00000000429a4ae98621e04fce98f47702a1c49b8f"
+        + "2130583b742dc906eb214c55f6cb1c139c948173a16c941b93");
   }
 
   @Test public void serverEmptyClose() throws IOException {
@@ -385,7 +386,10 @@
   }
 
   private void assertData(String hex) throws EOFException {
-    ByteString expected = ByteString.decodeHex(hex);
+    assertData(ByteString.decodeHex(hex));
+  }
+
+  private void assertData(ByteString expected) throws EOFException {
     ByteString actual = data.readByteString(expected.size());
     assertEquals(expected, actual);
   }
diff --git a/okhttp-tls/README.md b/okhttp-tls/README.md
new file mode 100644
index 0000000000..2ecaa5c3bf
--- /dev/null
+++ b/okhttp-tls/README.md
@@ -0,0 +1,246 @@
+OkHttp TLS
+==========
+
+Approachable APIs for using TLS.
+
+A [`HeldCertificate`][held_certificate] is a certificate and its private key. Use the
+[builder][held_certificate_builder] to create a self-signed certificate that a test server can use
+for HTTPS:
+
+```java
+String localhost = InetAddress.getByName("localhost").getCanonicalHostName();
+HeldCertificate localhostCertificate = new HeldCertificate.Builder()
+    .addSubjectAlternativeName(localhost)
+    .build();
+```
+
+[`HandshakeCertificates`][handshake_certificates] keeps the certificates for a TLS handshake.
+Use its [builder][handshake_certificates_builder] to define which certificates the HTTPS server
+returns to its clients. The returned instance can create an `SSLSocketFactory` that implements this
+policy:
+
+```java
+HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
+    .heldCertificate(localhostCertificate)
+    .build();
+MockWebServer server = new MockWebServer();
+server.useHttps(serverCertificates.sslSocketFactory(), false);
+```
+
+`HandshakeCertificates` also works for clients where its job is to define which root certificates
+to trust. In this simplified example we trust the server's self-signed certificate:
+
+```java
+HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
+    .addTrustedCertificate(localhostCertificate.certificate())
+    .build();
+OkHttpClient client = new OkHttpClient.Builder()
+    .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
+    .build();
+```
+
+With a server that holds a certificate and a client that trusts it we have enough for an HTTPS
+handshake. The best part of this example is that we don't need to make our test code insecure with a
+a fake `HostnameVerifier` or `X509TrustManager`.
+
+Certificate Authorities
+-----------------------
+
+The above example uses a self-signed certificate. This is convenient for testing but not
+representative of real-world HTTPS deployment. To get closer to that we can use `HeldCertificate`
+to generate a trusted root certificate, an intermediate certificate, and a server certificate.
+We use `certificateAuthority(int)` to create certificates that can sign other certificates. The
+int specifies how many intermediate certificates are allowed beneath it in the chain.
+
+```java
+HeldCertificate rootCertificate = new HeldCertificate.Builder()
+    .certificateAuthority(1)
+    .build();
+
+HeldCertificate intermediateCertificate = new HeldCertificate.Builder()
+    .certificateAuthority(0)
+    .signedBy(rootCertificate)
+    .build();
+
+String localhost = InetAddress.getByName("localhost").getCanonicalHostName();
+HeldCertificate serverCertificate = new HeldCertificate.Builder()
+    .addSubjectAlternativeName(localhost)
+    .signedBy(intermediateCertificate)
+    .build();
+```
+
+To serve this configuration the server needs to provide its clients with a chain of certificates
+starting with its own and including everything up-to but not including the root. We don't need to
+include root certificates because the client already has them.
+
+```java
+HandshakeCertificates serverHandshakeCertificates = new HandshakeCertificates.Builder()
+    .heldCertificate(serverCertificate, intermediateCertificate.certificate())
+    .build();
+```
+
+The client only needs to know the trusted root certificate. It checks the server's certificate by
+validating the signatures within the chain.
+
+```java
+HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
+    .addTrustedCertificate(rootCertificate.certificate())
+    .build();
+OkHttpClient client = new OkHttpClient.Builder()
+    .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
+    .build();
+```
+
+Client Authentication
+---------------------
+
+The above scenario is representative of most TLS set ups: the client uses certificates to validate
+the identity of a server. The converse is also possible. Here we create a server that authenticates
+a client and a client that authenticates a server.
+
+```java
+// Create the root for client and server to trust. We could also use different roots for each!
+HeldCertificate rootCertificate = new HeldCertificate.Builder()
+    .certificateAuthority(0)
+    .build();
+
+// Create a server certificate and a server that uses it.
+HeldCertificate serverCertificate = new HeldCertificate.Builder()
+    .commonName("ingen")
+    .addSubjectAlternativeName(server.getHostName())
+    .signedBy(rootCertificate)
+    .build();
+HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
+    .addTrustedCertificate(rootCertificate.certificate())
+    .heldCertificate(serverCertificate)
+    .build();
+MockWebServer server = new MockWebServer();
+server.useHttps(serverCertificates.sslSocketFactory(), false);
+server.requestClientAuth();
+server.enqueue(new MockResponse());
+
+// Create a client certificate and a client that uses it.
+HeldCertificate clientCertificate = new HeldCertificate.Builder()
+    .commonName("ianmalcolm")
+    .signedBy(rootCertificate)
+    .build();
+HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
+    .addTrustedCertificate(rootCertificate.certificate())
+    .heldCertificate(clientCertificate)
+    .build();
+OkHttpClient client = new OkHttpClient.Builder()
+    .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
+    .build();
+
+// Connect 'em all together. Certificates are exchanged in the handshake.
+Call call = client.newCall(new Request.Builder()
+    .url(server.url("/"))
+    .build());
+Response response = call.execute();
+System.out.println(response.handshake().peerPrincipal());
+RecordedRequest recordedRequest = server.takeRequest();
+System.out.println(recordedRequest.getHandshake().peerPrincipal());
+```
+
+This handshake is successful because each party has prearranged to trust the root certificate that
+signs the other party's chain.
+
+Well-Known Certificate Authorities
+----------------------------------
+
+In these examples we've prearranged which root certificates to trust. But for regular HTTPS on the
+Internet this set of trusted root certificates is usually provided by default by the host platform.
+Such a set typically includes many root certificates from well-known certificate authorities like
+Entrust and Verisign.
+
+This is the behavior you'll get with your OkHttpClient if you don't specifically configure
+`HandshakeCertificates`. Or you can do it explicitly with `addPlatformTrustedCertificates()`:
+
+```java
+HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
+    .addPlatformTrustedCertificates()
+    .build();
+OkHttpClient client = new OkHttpClient.Builder()
+    .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
+    .build();
+```
+
+PEM files
+---------
+
+You can encode a `HeldCertificate` in PEM format:
+
+```java
+HeldCertificate heldCertificate = ...
+System.out.println(heldCertificate.certificatePem())
+```
+
+```
+-----BEGIN CERTIFICATE-----
+MIIBSjCB8aADAgECAgEBMAoGCCqGSM49BAMCMC8xLTArBgNVBAMTJDJiYWY3NzVl
+LWE4MzUtNDM5ZS1hYWE2LTgzNmNiNDlmMGM3MTAeFw0xODA3MTMxMjA0MzJaFw0x
+ODA3MTQxMjA0MzJaMC8xLTArBgNVBAMTJDJiYWY3NzVlLWE4MzUtNDM5ZS1hYWE2
+LTgzNmNiNDlmMGM3MTBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABDmlOiZ3dxA2
+zw1KwqGNsKVUZbkUVj5cxV1jDbSTvTlOjSj6LR0Ovys9RFdrjcbbMLWvSvMQgHch
+k8Q50c6Kb34wCgYIKoZIzj0EAwIDSAAwRQIhAJkXiCbIR3zxuH5SQR5PEAPJ+ntg
+msOSMaAKwAePESf+AiBlxbEu6YpHt1ZJoAhMAv6raYnwSp/A94eJGlJynQ0igQ==
+-----END CERTIFICATE-----
+```
+
+You can also do so with the private key. Be careful with these!
+
+```java
+HeldCertificate heldCertificate = ...
+System.out.println(heldCertificate.privateKeyPkcs8Pem())
+```
+
+```
+-----BEGIN PRIVATE KEY-----
+MIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQgQbYDQiewSnregm9e
+IjXEHQgc6w3ELHdnH1houEUom9CgCgYIKoZIzj0DAQehRANCAAQ5pTomd3cQNs8N
+SsKhjbClVGW5FFY+XMVdYw20k705To0o+i0dDr8rPURXa43G2zC1r0rzEIB3IZPE
+OdHOim9+
+-----END PRIVATE KEY-----
+```
+
+Recommendations
+---------------
+
+Typically servers need a held certificate plus a chain of intermediates. Servers only need the
+private key for their own certificate. The chain served by a server doesn't need the root
+certificate.
+
+The trusted roots don't need to be the same for client and server when using client authentication.
+Clients might rely on the platform certificates and servers might use a private
+organization-specific certificate authority.
+
+By default `HeldCertificate` instances expire after 24 hours. Use `duration()` to adjust.
+
+By default server certificates need to identify which hostnames they're trusted for. You may add as
+many as necessary with `addSubjectAlternativeName()`. This mechanism also supports a very limited
+form of wildcards `*.example.com` where the `*` must be first and doesn't match nested subdomains.
+
+By default certificates use fast and secure 256-bit ECDSA keys. For interoperability with very old
+clients use `HeldCertificate.Builder.rsa2048()`.
+
+Download
+--------
+
+Get via Maven:
+```xml
+<dependency>
+  <groupId>com.squareup.okhttp3</groupId>
+  <artifactId>okhttp-tls</artifactId>
+  <version>(insert latest version)</version>
+</dependency>
+```
+
+or via Gradle
+```groovy
+implementation 'com.squareup.okhttp3:okhttp-tls:(insert latest version)'
+```
+
+ [held_certificate]: http://square.github.io/okhttp/3.x/okhttp-tls/okhttp3/tls/HeldCertificate.html
+ [held_certificate_builder]: http://square.github.io/okhttp/3.x/okhttp-tls/okhttp3/tls/HeldCertificate.Builder.html
+ [handshake_certificates]: http://square.github.io/okhttp/3.x/okhttp-tls/okhttp3/tls/HandshakeCertificates.html
+ [handshake_certificates_builder]: http://square.github.io/okhttp/3.x/okhttp-tls/okhttp3/tls/HandshakeCertificates.Builder.html
diff --git a/okhttp-tls/pom.xml b/okhttp-tls/pom.xml
new file mode 100644
index 0000000000..3b40e6e714
--- /dev/null
+++ b/okhttp-tls/pom.xml
@@ -0,0 +1,70 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3</groupId>
+    <artifactId>parent</artifactId>
+    <version>3.12.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-tls</artifactId>
+  <name>OkHttp Transport Layer Security (TLS)</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.bouncycastle</groupId>
+      <artifactId>bcprov-jdk15on</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-testing-support</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
+        <configuration>
+          <links>
+            <link>http://square.github.io/okhttp/javadoc/</link>
+          </links>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>okhttp3.tls</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.java b/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.java
new file mode 100644
index 0000000000..015eb81ed9
--- /dev/null
+++ b/okhttp-tls/src/main/java/okhttp3/tls/HandshakeCertificates.java
@@ -0,0 +1,171 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.tls;
+
+import java.security.GeneralSecurityException;
+import java.security.KeyManagementException;
+import java.security.SecureRandom;
+import java.security.cert.X509Certificate;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import javax.net.ssl.KeyManager;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509KeyManager;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.CertificatePinner;
+import okhttp3.internal.Util;
+import okhttp3.internal.platform.Platform;
+
+import static okhttp3.tls.internal.TlsUtil.newKeyManager;
+import static okhttp3.tls.internal.TlsUtil.newTrustManager;
+
+/**
+ * Certificates to identify which peers to trust and also to earn the trust of those peers in kind.
+ * Client and server exchange these certificates during the handshake phase of a TLS connection.
+ *
+ * <h3>Server Authentication</h3>
+ *
+ * <p>This is the most common form of TLS authentication: clients verify that servers are trusted
+ * and that they own the hostnames that they represent. Server authentication is required.
+ *
+ * <p>To perform server authentication:
+ *
+ * <ul>
+ *   <li>The server's handshake certificates must have a {@linkplain HeldCertificate held
+ *       certificate} (a certificate and its private key). The certificate's subject alternative
+ *       names must match the server's hostname. The server must also have is a (possibly-empty)
+ *       chain of intermediate certificates to establish trust from a root certificate to the
+ *       server's certificate. The root certificate is not included in this chain.
+ *   <li>The client's handshake certificates must include a set of trusted root certificates. They
+ *       will be used to authenticate the server's certificate chain. Typically this is a set of
+ *       well-known root certificates that is distributed with the HTTP client or its platform. It
+ *       may be augmented by certificates private to an organization or service.
+ * </ul>
+ *
+ * <h3>Client Authentication</h3>
+ *
+ * <p>This is authentication of the client by the server during the TLS handshake. Client
+ * authentication is optional.
+ *
+ * <p>To perform client authentication:
+ *
+ * <ul>
+ *   <li>The client's handshake certificates must have a {@linkplain HeldCertificate held
+ *       certificate} (a certificate and its private key). The client must also have a
+ *       (possibly-empty) chain of intermediate certificates to establish trust from a root
+ *       certificate to the client's certificate. The root certificate is not included in this
+ *       chain.
+ *   <li>The server's handshake certificates must include a set of trusted root certificates. They
+ *       will be used to authenticate the client's certificate chain. Typically this is not the same
+ *       set of root certificates used in server authentication. Instead it will be a small set of
+ *       roots private to an organization or service.
+ * </ul>
+ */
+public final class HandshakeCertificates {
+  private final X509KeyManager keyManager;
+  private final X509TrustManager trustManager;
+
+  private HandshakeCertificates(X509KeyManager keyManager, X509TrustManager trustManager) {
+    this.keyManager = keyManager;
+    this.trustManager = trustManager;
+  }
+
+  public X509KeyManager keyManager() {
+    return keyManager;
+  }
+
+  public X509TrustManager trustManager() {
+    return trustManager;
+  }
+
+  public SSLSocketFactory sslSocketFactory() {
+    return sslContext().getSocketFactory();
+  }
+
+  public SSLContext sslContext() {
+    try {
+      SSLContext sslContext = Platform.get().getSSLContext();
+      sslContext.init(new KeyManager[] { keyManager }, new TrustManager[] { trustManager },
+          new SecureRandom());
+      return sslContext;
+    } catch (KeyManagementException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  public static final class Builder {
+    private HeldCertificate heldCertificate;
+    private X509Certificate[] intermediates;
+
+    private final List<X509Certificate> trustedCertificates = new ArrayList<>();
+
+    /**
+     * Configure the certificate chain to use when being authenticated. The first certificate is
+     * the held certificate, further certificates are included in the handshake so the peer can
+     * build a trusted path to a trusted root certificate.
+     *
+     * <p>The chain should include all intermediate certificates but does not need the root
+     * certificate that we expect to be known by the remote peer. The peer already has that
+     * certificate so transmitting it is unnecessary.
+     */
+    public Builder heldCertificate(HeldCertificate heldCertificate,
+        X509Certificate... intermediates) {
+      this.heldCertificate = heldCertificate;
+      this.intermediates = intermediates.clone(); // Defensive copy.
+      return this;
+    }
+
+    /**
+     * Add a trusted root certificate to use when authenticating a peer. Peers must provide
+     * a chain of certificates whose root is one of these.
+     */
+    public Builder addTrustedCertificate(X509Certificate certificate) {
+      this.trustedCertificates.add(certificate);
+      return this;
+    }
+
+    /**
+     * Add all of the host platform's trusted root certificates. This set varies by platform
+     * (Android vs. Java), by platform release (Android 4.4 vs. Android 9), and with user
+     * customizations.
+     *
+     * <p>Most TLS clients that connect to hosts on the public Internet should call this method.
+     * Otherwise it is necessary to manually prepare a comprehensive set of trusted roots.
+     *
+     * <p>If the host platform is compromised or misconfigured this may contain untrustworthy root
+     * certificates. Applications that connect to a known set of servers may be able to mitigate
+     * this problem with {@linkplain CertificatePinner certificate pinning}.
+     */
+    public Builder addPlatformTrustedCertificates() {
+      X509TrustManager platformTrustManager = Util.platformTrustManager();
+      Collections.addAll(trustedCertificates, platformTrustManager.getAcceptedIssuers());
+      return this;
+    }
+
+    public HandshakeCertificates build() {
+      try {
+        X509KeyManager keyManager = newKeyManager(null, heldCertificate, intermediates);
+        X509TrustManager trustManager = newTrustManager(null, trustedCertificates);
+        return new HandshakeCertificates(keyManager, trustManager);
+      } catch (GeneralSecurityException gse) {
+        throw new AssertionError(gse);
+      }
+    }
+  }
+}
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.java b/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.java
new file mode 100644
index 0000000000..68f16db23d
--- /dev/null
+++ b/okhttp-tls/src/main/java/okhttp3/tls/HeldCertificate.java
@@ -0,0 +1,433 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.tls;
+
+import java.io.IOException;
+import java.math.BigInteger;
+import java.security.GeneralSecurityException;
+import java.security.KeyPair;
+import java.security.KeyPairGenerator;
+import java.security.PrivateKey;
+import java.security.PublicKey;
+import java.security.SecureRandom;
+import java.security.Security;
+import java.security.cert.CertificateEncodingException;
+import java.security.cert.X509Certificate;
+import java.security.interfaces.RSAPrivateKey;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.List;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+import javax.security.auth.x500.X500Principal;
+import okio.ByteString;
+import org.bouncycastle.asn1.ASN1Encodable;
+import org.bouncycastle.asn1.DERSequence;
+import org.bouncycastle.asn1.pkcs.PrivateKeyInfo;
+import org.bouncycastle.asn1.x509.BasicConstraints;
+import org.bouncycastle.asn1.x509.GeneralName;
+import org.bouncycastle.asn1.x509.X509Extensions;
+import org.bouncycastle.jce.provider.BouncyCastleProvider;
+import org.bouncycastle.x509.X509V3CertificateGenerator;
+
+import static okhttp3.internal.Util.verifyAsIpAddress;
+
+/**
+ * A certificate and its private key. These are some properties of certificates that are used with
+ * TLS:
+ *
+ * <ul>
+ *   <li><strong>A common name.</strong> This is a string identifier for the certificate. It usually
+ *       describes the purpose of the certificate like "Entrust Root Certification Authority - G2"
+ *       or "www.squareup.com".
+ *   <li><strong>A set of hostnames.</strong> These are in the certificate's subject alternative
+ *       name (SAN) extension. A subject alternative name is either a literal hostname ({@code
+ *       squareup.com}), a literal IP address ({@code 74.122.190.80}), or a hostname pattern ({@code
+ *       *.api.squareup.com}).
+ *   <li><strong>A validity interval.</strong> A certificate should not be used before its validity
+ *       interval starts or after it ends.
+ *   <li><strong>A public key.</strong> This cryptographic key is used for asymmetric encryption
+ *       digital signatures. Note that the private key is not a part of the certificate!
+ *   <li><strong>A signature issued by another certificate's private key.</strong> This mechanism
+ *       allows a trusted third-party to endorse a certificate. Third parties should only endorse
+ *       certificates once they've confirmed that the owner of the private key is also the owner of
+ *       the certificate's other properties.
+ * </ul>
+ *
+ * <p>Certificates are signed by other certificates and a sequence of them is called a certificate
+ * chain. The chain terminates in a self-signed "root" certificate. Signing certificates in the
+ * middle of the chain are called "intermediates". Organizations that offer certificate signing are
+ * called certificate authorities (CAs).
+ *
+ * <p>Browsers and other HTTP clients need a set of trusted root certificates to authenticate their
+ * peers. Sets of root certificates are managed by either the HTTP client (like Firefox), or the
+ * host platform (like Android). In July 2018 Android had 134 trusted root certificates for its HTTP
+ * clients to trust.
+ *
+ * <p>For example, in order to establish a secure connection to {@code https://www.squareup.com/},
+ * these three certificates are used. <pre>{@code
+ *
+ * www.squareup.com certificate:
+ *
+ *   Common Name: www.squareup.com
+ *   Subject Alternative Names: www.squareup.com, squareup.com, account.squareup.com...
+ *   Validity: 2018-07-03T20:18:17Z â€“ 2019-08-01T20:48:15Z
+ *   Public Key: d107beecc17325f55da976bcbab207ba4df68bd3f8fce7c3b5850311128264fd53e1baa342f58d93...
+ *   Signature: 1fb0e66fac05322721fe3a3917f7c98dee1729af39c99eab415f22d8347b508acdf0bab91781c3720...
+ *
+ * signed by intermediate certificate:
+ *
+ *   Common Name: Entrust Certification Authority - L1M
+ *   Subject Alternative Names: none
+ *   Validity: 2014-12-15T15:25:03Z â€“ 2030-10-15T15:55:03Z
+ *   Public Key: d081c13923c2b1d1ecf757dd55243691202248f7fcca520ab0ab3f33b5b08407f6df4e7ab0fb9822...
+ *   Signature: b487c784221a29c0a478ecf54f1bb484976f77eed4cf59afa843962f1d58dea6f3155b2ed9439c4c4...
+ *
+ * signed by root certificate:
+ *
+ *   Common Name: Entrust Root Certification Authority - G2
+ *   Subject Alternative Names: none
+ *   Validity: 2009-07-07T17:25:54Z â€“ 2030-12-07T17:55:54Z
+ *   Public Key: ba84b672db9e0c6be299e93001a776ea32b895411ac9da614e5872cffef68279bf7361060aa527d8...
+ *   Self-signed Signature: 799f1d96c6b6793f228d87d3870304606a6b9a2e59897311ac43d1f513ff8d392bc0f...
+ *
+ * }</pre>
+ *
+ * <p>In this example the HTTP client already knows and trusts the last certificate, "Entrust Root
+ * Certification Authority - G2". That certificate is used to verify the signature of the
+ * intermediate certificate, "Entrust Certification Authority - L1M". The intermediate certificate
+ * is used to verify the signature of the "www.squareup.com" certificate.
+ *
+ * <p>This roles are reversed for client authentication. In that case the client has a private key
+ * and a chain of certificates. The server uses a set of trusted root certificates to authenticate
+ * the client. Subject alternative names are not used for client authentication.
+ */
+public final class HeldCertificate {
+  private final X509Certificate certificate;
+  private final KeyPair keyPair;
+
+  public HeldCertificate(KeyPair keyPair, X509Certificate certificate) {
+    if (keyPair == null) throw new NullPointerException("keyPair == null");
+    if (certificate == null) throw new NullPointerException("certificate == null");
+    this.certificate = certificate;
+    this.keyPair = keyPair;
+  }
+
+  public X509Certificate certificate() {
+    return certificate;
+  }
+
+  public KeyPair keyPair() {
+    return keyPair;
+  }
+
+  /**
+   * Returns the certificate encoded in <a href="https://tools.ietf.org/html/rfc7468">PEM
+   * format</a>.
+   */
+  public String certificatePem() {
+    try {
+      StringBuilder result = new StringBuilder();
+      result.append("-----BEGIN CERTIFICATE-----\n");
+      encodeBase64Lines(result, ByteString.of(certificate.getEncoded()));
+      result.append("-----END CERTIFICATE-----\n");
+      return result.toString();
+    } catch (CertificateEncodingException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  /**
+   * Returns the RSA private key encoded in <a href="https://tools.ietf.org/html/rfc5208">PKCS
+   * #8</a> <a href="https://tools.ietf.org/html/rfc7468">PEM format</a>.
+   */
+  public String privateKeyPkcs8Pem() {
+    StringBuilder result = new StringBuilder();
+    result.append("-----BEGIN PRIVATE KEY-----\n");
+    encodeBase64Lines(result, ByteString.of(keyPair.getPrivate().getEncoded()));
+    result.append("-----END PRIVATE KEY-----\n");
+    return result.toString();
+  }
+
+  /**
+   * Returns the RSA private key encoded in <a href="https://tools.ietf.org/html/rfc8017">PKCS
+   * #1</a> <a href="https://tools.ietf.org/html/rfc7468">PEM format</a>.
+   */
+  public String privateKeyPkcs1Pem() {
+    if (!(keyPair.getPrivate() instanceof RSAPrivateKey)) {
+      throw new IllegalStateException("PKCS1 only supports RSA keys");
+    }
+    StringBuilder result = new StringBuilder();
+    result.append("-----BEGIN RSA PRIVATE KEY-----\n");
+    encodeBase64Lines(result, pkcs1Bytes());
+    result.append("-----END RSA PRIVATE KEY-----\n");
+    return result.toString();
+  }
+
+  private ByteString pkcs1Bytes() {
+    try {
+      PrivateKeyInfo privateKeyInfo = PrivateKeyInfo.getInstance(keyPair.getPrivate().getEncoded());
+      return ByteString.of(privateKeyInfo.parsePrivateKey().toASN1Primitive().getEncoded());
+    } catch (IOException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  private void encodeBase64Lines(StringBuilder out, ByteString data) {
+    String base64 = data.base64();
+    for (int i = 0; i < base64.length(); i += 64) {
+      out.append(base64, i, Math.min(i + 64, base64.length())).append('\n');
+    }
+  }
+
+  /** Build a held certificate with reasonable defaults. */
+  public static final class Builder {
+    private static final long DEFAULT_DURATION_MILLIS = 1000L * 60 * 60 * 24; // 24 hours.
+
+    static {
+      Security.addProvider(new BouncyCastleProvider());
+    }
+
+    private long notBefore = -1L;
+    private long notAfter = -1L;
+    private String cn;
+    private String ou;
+    private final List<String> altNames = new ArrayList<>();
+    private BigInteger serialNumber;
+    private KeyPair keyPair;
+    private HeldCertificate signedBy;
+    private int maxIntermediateCas = -1;
+    private String keyAlgorithm;
+    private int keySize;
+
+    public Builder() {
+      ecdsa256();
+    }
+
+    /**
+     * Sets the certificate to be valid in {@code [notBefore..notAfter]}. Both endpoints are
+     * specified in the format of {@link System#currentTimeMillis()}. Specify -1L for both values
+     * to use the default interval, 24 hours starting when the certificate is created.
+     */
+    public Builder validityInterval(long notBefore, long notAfter) {
+      if (notBefore > notAfter || (notBefore == -1L) != (notAfter == -1L)) {
+        throw new IllegalArgumentException("invalid interval: " + notBefore + ".." + notAfter);
+      }
+      this.notBefore = notBefore;
+      this.notAfter = notAfter;
+      return this;
+    }
+
+    /**
+     * Sets the certificate to be valid immediately and until the specified duration has elapsed.
+     * The precision of this field is seconds; further precision will be truncated.
+     */
+    public Builder duration(long duration, TimeUnit unit) {
+      long now = System.currentTimeMillis();
+      return validityInterval(now, now + unit.toMillis(duration));
+    }
+
+    /**
+     * Adds a subject alternative name (SAN) to the certificate. This is usually a literal hostname,
+     * a literal IP address, or a hostname pattern. If no subject alternative names are added that
+     * extension will be omitted.
+     */
+    public Builder addSubjectAlternativeName(String altName) {
+      if (altName == null) throw new NullPointerException("altName == null");
+      altNames.add(altName);
+      return this;
+    }
+
+    /**
+     * Set this certificate's common name (CN). Historically this held the hostname of TLS
+     * certificate, but that practice was deprecated by <a
+     * href="https://tools.ietf.org/html/rfc2818">RFC 2818</a> and replaced with {@link
+     * #addSubjectAlternativeName(String) subject alternative names}. If unset a random string will
+     * be used.
+     */
+    public Builder commonName(String cn) {
+      this.cn = cn;
+      return this;
+    }
+
+    /** Sets the certificate's organizational unit (OU). If unset this field will be omitted. */
+    public Builder organizationalUnit(String ou) {
+      this.ou = ou;
+      return this;
+    }
+
+    /** Sets this certificate's serial number. If unset the serial number will be 1. */
+    public Builder serialNumber(BigInteger serialNumber) {
+      this.serialNumber = serialNumber;
+      return this;
+    }
+
+    /** Sets this certificate's serial number. If unset the serial number will be 1. */
+    public Builder serialNumber(long serialNumber) {
+      return serialNumber(BigInteger.valueOf(serialNumber));
+    }
+
+    /**
+     * Sets the public/private key pair used for this certificate. If unset a key pair will be
+     * generated.
+     */
+    public Builder keyPair(KeyPair keyPair) {
+      this.keyPair = keyPair;
+      return this;
+    }
+
+    /**
+     * Sets the public/private key pair used for this certificate. If unset a key pair will be
+     * generated.
+     */
+    public Builder keyPair(PublicKey publicKey, PrivateKey privateKey) {
+      return keyPair(new KeyPair(publicKey, privateKey));
+    }
+
+    /**
+     * Set the certificate that will issue this certificate. If unset the certificate will be
+     * self-signed.
+     */
+    public Builder signedBy(HeldCertificate signedBy) {
+      this.signedBy = signedBy;
+      return this;
+    }
+
+    /**
+     * Set this certificate to be a signing certificate, with up to {@code maxIntermediateCas}
+     * intermediate signing certificates beneath it.
+     *
+     * <p>By default this certificate cannot not sign other certificates. Set this to 0 so this
+     * certificate can sign other certificates (but those certificates cannot themselves sign
+     * certificates). Set this to 1 so this certificate can sign intermediate certificates that can
+     * themselves sign certificates. Add one for each additional layer of intermediates to permit.
+     */
+    public Builder certificateAuthority(int maxIntermediateCas) {
+      if (maxIntermediateCas < 0) {
+        throw new IllegalArgumentException("maxIntermediateCas < 0: " + maxIntermediateCas);
+      }
+      this.maxIntermediateCas = maxIntermediateCas;
+      return this;
+    }
+
+    /**
+     * Configure the certificate to generate a 256-bit ECDSA key, which provides about 128 bits of
+     * security. ECDSA keys are noticeably faster than RSA keys.
+     *
+     * <p>This is the default configuration and has been since this API was introduced in OkHttp
+     * 3.11.0. Note that the default may change in future releases.
+     */
+    public Builder ecdsa256() {
+      keyAlgorithm = "ECDSA";
+      keySize = 256;
+      return this;
+    }
+
+    /**
+     * Configure the certificate to generate a 2048-bit RSA key, which provides about 112 bits of
+     * security. RSA keys are interoperable with very old clients that don't support ECDSA.
+     */
+    public Builder rsa2048() {
+      keyAlgorithm = "RSA";
+      keySize = 2048;
+      return this;
+    }
+
+    public HeldCertificate build() {
+      // Subject, public & private keys for this certificate.
+      KeyPair heldKeyPair = keyPair != null
+          ? keyPair
+          : generateKeyPair();
+
+      X500Principal subject = buildSubject();
+
+      // Subject, public & private keys for this certificate's signer. It may be self signed!
+      KeyPair signedByKeyPair;
+      X500Principal signedByPrincipal;
+      if (signedBy != null) {
+        signedByKeyPair = signedBy.keyPair;
+        signedByPrincipal = signedBy.certificate.getSubjectX500Principal();
+      } else {
+        signedByKeyPair = heldKeyPair;
+        signedByPrincipal = subject;
+      }
+
+      // Generate & sign the certificate.
+      long notBefore = this.notBefore != -1L ? this.notBefore : System.currentTimeMillis();
+      long notAfter = this.notAfter != -1L ? this.notAfter : notBefore + DEFAULT_DURATION_MILLIS;
+      BigInteger serialNumber = this.serialNumber != null ? this.serialNumber : BigInteger.ONE;
+      X509V3CertificateGenerator generator = new X509V3CertificateGenerator();
+      generator.setSerialNumber(serialNumber);
+      generator.setIssuerDN(signedByPrincipal);
+      generator.setNotBefore(new Date(notBefore));
+      generator.setNotAfter(new Date(notAfter));
+      generator.setSubjectDN(subject);
+      generator.setPublicKey(heldKeyPair.getPublic());
+      generator.setSignatureAlgorithm(signedByKeyPair.getPrivate() instanceof RSAPrivateKey
+          ? "SHA256WithRSAEncryption"
+          : "SHA256withECDSA");
+
+      if (maxIntermediateCas != -1) {
+        generator.addExtension(X509Extensions.BasicConstraints, true,
+            new BasicConstraints(maxIntermediateCas));
+      }
+
+      if (!altNames.isEmpty()) {
+        ASN1Encodable[] encodableAltNames = new ASN1Encodable[altNames.size()];
+        for (int i = 0, size = altNames.size(); i < size; i++) {
+          String altName = altNames.get(i);
+          int tag = verifyAsIpAddress(altName)
+              ? GeneralName.iPAddress
+              : GeneralName.dNSName;
+          encodableAltNames[i] = new GeneralName(tag, altName);
+        }
+        generator.addExtension(X509Extensions.SubjectAlternativeName, true,
+            new DERSequence(encodableAltNames));
+      }
+
+      try {
+        X509Certificate certificate = generator.generateX509Certificate(
+            signedByKeyPair.getPrivate(), "BC");
+        return new HeldCertificate(heldKeyPair, certificate);
+      } catch (GeneralSecurityException e) {
+        throw new AssertionError(e);
+      }
+    }
+
+    private X500Principal buildSubject() {
+      StringBuilder nameBuilder = new StringBuilder();
+      if (cn != null) {
+        nameBuilder.append("CN=").append(cn);
+      } else {
+        nameBuilder.append("CN=").append(UUID.randomUUID());
+      }
+      if (ou != null) {
+        nameBuilder.append(", OU=").append(ou);
+      }
+      return new X500Principal(nameBuilder.toString());
+    }
+
+    private KeyPair generateKeyPair() {
+      try {
+        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(keyAlgorithm, "BC");
+        keyPairGenerator.initialize(keySize, new SecureRandom());
+        return keyPairGenerator.generateKeyPair();
+      } catch (GeneralSecurityException e) {
+        throw new AssertionError(e);
+      }
+    }
+  }
+}
diff --git a/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.java b/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.java
new file mode 100644
index 0000000000..b127b36861
--- /dev/null
+++ b/okhttp-tls/src/main/java/okhttp3/tls/internal/TlsUtil.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2012 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.tls.internal;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
+import java.security.cert.Certificate;
+import java.security.cert.X509Certificate;
+import java.util.Arrays;
+import java.util.List;
+import javax.net.ssl.KeyManager;
+import javax.net.ssl.KeyManagerFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509KeyManager;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.tls.HeldCertificate;
+import okhttp3.tls.HandshakeCertificates;
+
+public final class TlsUtil {
+  public static final char[] password = "password".toCharArray();
+  private static HandshakeCertificates localhost; // Lazily initialized.
+
+  private TlsUtil() {
+  }
+
+  /** Returns an SSL client for this host's localhost address. */
+  public static synchronized HandshakeCertificates localhost() {
+    if (localhost != null) return localhost;
+
+    try {
+      // Generate a self-signed cert for the server to serve and the client to trust.
+      HeldCertificate heldCertificate = new HeldCertificate.Builder()
+          .commonName("localhost")
+          .addSubjectAlternativeName(InetAddress.getByName("localhost").getCanonicalHostName())
+          .build();
+
+      localhost = new HandshakeCertificates.Builder()
+          .heldCertificate(heldCertificate)
+          .addTrustedCertificate(heldCertificate.certificate())
+          .build();
+
+      return localhost;
+    } catch (UnknownHostException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  /** Returns a trust manager that trusts {@code trustedCertificates}. */
+  public static X509TrustManager newTrustManager(String keyStoreType,
+      List<X509Certificate> trustedCertificates) throws GeneralSecurityException {
+    KeyStore trustStore = newEmptyKeyStore(keyStoreType);
+    for (int i = 0; i < trustedCertificates.size(); i++) {
+      trustStore.setCertificateEntry("cert_" + i, trustedCertificates.get(i));
+    }
+    TrustManagerFactory factory = TrustManagerFactory.getInstance(
+        TrustManagerFactory.getDefaultAlgorithm());
+    factory.init(trustStore);
+    TrustManager[] result = factory.getTrustManagers();
+    if (result.length != 1 || !(result[0] instanceof X509TrustManager)) {
+      throw new IllegalStateException("Unexpected trust managers:" + Arrays.toString(result));
+    }
+    return (X509TrustManager) result[0];
+  }
+
+  /**
+   * Returns a key manager for the held certificate and its chain. Returns an empty key manager if
+   * {@code heldCertificate} is null.
+   */
+  public static X509KeyManager newKeyManager(String keyStoreType, HeldCertificate heldCertificate,
+      X509Certificate... intermediates) throws GeneralSecurityException {
+    KeyStore keyStore = newEmptyKeyStore(keyStoreType);
+
+    if (heldCertificate != null) {
+      Certificate[] chain = new Certificate[1 + intermediates.length];
+      chain[0] = heldCertificate.certificate();
+      System.arraycopy(intermediates, 0, chain, 1, intermediates.length);
+      keyStore.setKeyEntry("private", heldCertificate.keyPair().getPrivate(), password, chain);
+    }
+
+    KeyManagerFactory factory = KeyManagerFactory.getInstance(
+        KeyManagerFactory.getDefaultAlgorithm());
+    factory.init(keyStore, password);
+    KeyManager[] result = factory.getKeyManagers();
+    if (result.length != 1 || !(result[0] instanceof X509KeyManager)) {
+      throw new IllegalStateException("Unexpected key managers:" + Arrays.toString(result));
+    }
+    return (X509KeyManager) result[0];
+  }
+
+  private static KeyStore newEmptyKeyStore(String keyStoreType) throws GeneralSecurityException {
+    if (keyStoreType == null) {
+      keyStoreType = KeyStore.getDefaultType();
+    }
+
+    try {
+      KeyStore keyStore = KeyStore.getInstance(keyStoreType);
+      InputStream in = null; // By convention, 'null' creates an empty key store.
+      keyStore.load(in, password);
+      return keyStore;
+    } catch (IOException e) {
+      throw new AssertionError(e);
+    }
+  }
+}
diff --git a/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java b/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java
new file mode 100644
index 0000000000..c2e4f3a45f
--- /dev/null
+++ b/okhttp-tls/src/test/java/okhttp3/tls/HandshakeCertificatesTest.java
@@ -0,0 +1,198 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.tls;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.security.PrivateKey;
+import java.security.cert.X509Certificate;
+import java.util.Arrays;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import javax.net.ServerSocketFactory;
+import javax.net.SocketFactory;
+import javax.net.ssl.SSLSocket;
+import okhttp3.Handshake;
+import okhttp3.internal.Util;
+import okio.ByteString;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+public final class HandshakeCertificatesTest {
+  private ExecutorService executorService;
+  private ServerSocket serverSocket;
+
+  @Before public void setUp() {
+    executorService = Executors.newCachedThreadPool();
+  }
+
+  @After public void tearDown() {
+    executorService.shutdown();
+    Util.closeQuietly(serverSocket);
+  }
+
+  @Test public void clientAndServer() throws Exception {
+    HeldCertificate clientRoot = new HeldCertificate.Builder()
+        .certificateAuthority(1)
+        .build();
+    HeldCertificate clientIntermediate = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .signedBy(clientRoot)
+        .build();
+    HeldCertificate clientCertificate = new HeldCertificate.Builder()
+        .signedBy(clientIntermediate)
+        .build();
+
+    HeldCertificate serverRoot = new HeldCertificate.Builder()
+        .certificateAuthority(1)
+        .build();
+    HeldCertificate serverIntermediate = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .signedBy(serverRoot)
+        .build();
+    HeldCertificate serverCertificate = new HeldCertificate.Builder()
+        .signedBy(serverIntermediate)
+        .build();
+
+    HandshakeCertificates server = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(clientRoot.certificate())
+        .heldCertificate(serverCertificate, serverIntermediate.certificate())
+        .build();
+
+    HandshakeCertificates client = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(serverRoot.certificate())
+        .heldCertificate(clientCertificate, clientIntermediate.certificate())
+        .build();
+
+    InetSocketAddress serverAddress = startTlsServer();
+    Future<Handshake> serverHandshakeFuture = doServerHandshake(server);
+    Future<Handshake> clientHandshakeFuture = doClientHandshake(client, serverAddress);
+
+    Handshake serverHandshake = serverHandshakeFuture.get();
+    assertEquals(serverHandshake.peerCertificates(),
+        Arrays.asList(clientCertificate.certificate(), clientIntermediate.certificate()));
+    assertEquals(serverHandshake.localCertificates(),
+        Arrays.asList(serverCertificate.certificate(), serverIntermediate.certificate()));
+
+    Handshake clientHandshake = clientHandshakeFuture.get();
+    assertEquals(clientHandshake.peerCertificates(),
+        Arrays.asList(serverCertificate.certificate(), serverIntermediate.certificate()));
+    assertEquals(clientHandshake.localCertificates(),
+        Arrays.asList(clientCertificate.certificate(), clientIntermediate.certificate()));
+
+  }
+
+  @Test public void keyManager() {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .certificateAuthority(1)
+        .build();
+    HeldCertificate intermediate = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .signedBy(root)
+        .build();
+    HeldCertificate certificate = new HeldCertificate.Builder()
+        .signedBy(intermediate)
+        .build();
+
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .heldCertificate(certificate, intermediate.certificate())
+        .build();
+    assertPrivateKeysEquals(certificate.keyPair().getPrivate(),
+        handshakeCertificates.keyManager().getPrivateKey("private"));
+    assertEquals(Arrays.asList(certificate.certificate(), intermediate.certificate()),
+        Arrays.asList(handshakeCertificates.keyManager().getCertificateChain("private")));
+  }
+
+  @Test public void platformTrustedCertificates() {
+    HandshakeCertificates handshakeCertificates = new HandshakeCertificates.Builder()
+        .addPlatformTrustedCertificates()
+        .build();
+    Set<String> names = new LinkedHashSet<>();
+    for (X509Certificate certificate : handshakeCertificates.trustManager().getAcceptedIssuers()) {
+      // Abbreviate a long name like "CN=Entrust Root Certification Authority - G2, OU=..."
+      String name = certificate.getSubjectDN().getName();
+      names.add(name.substring(0, name.indexOf(" ")));
+    }
+    // It's safe to assume all platforms will have a major Internet certificate issuer.
+    assertTrue(names.toString(), names.contains("CN=Entrust"));
+  }
+
+  private InetSocketAddress startTlsServer() throws IOException {
+    ServerSocketFactory serverSocketFactory = ServerSocketFactory.getDefault();
+    serverSocket = serverSocketFactory.createServerSocket();
+    InetAddress serverAddress = InetAddress.getByName("localhost");
+    serverSocket.bind(new InetSocketAddress(serverAddress, 0), 50);
+    return new InetSocketAddress(serverAddress, serverSocket.getLocalPort());
+  }
+
+  private Future<Handshake> doServerHandshake(final HandshakeCertificates server) {
+    return executorService.submit(new Callable<Handshake>() {
+      @Override public Handshake call() throws Exception {
+        Socket rawSocket = null;
+        SSLSocket sslSocket = null;
+        try {
+          rawSocket = serverSocket.accept();
+          sslSocket = (SSLSocket) server.sslSocketFactory().createSocket(rawSocket,
+              rawSocket.getInetAddress().getHostAddress(), rawSocket.getPort(),
+              true /* autoClose */);
+          sslSocket.setUseClientMode(false);
+          sslSocket.setWantClientAuth(true);
+          sslSocket.startHandshake();
+          return Handshake.get(sslSocket.getSession());
+        } finally {
+          Util.closeQuietly(rawSocket);
+          Util.closeQuietly(sslSocket);
+        }
+      }
+    });
+  }
+
+  private Future<Handshake> doClientHandshake(
+      final HandshakeCertificates client, final InetSocketAddress serverAddress) {
+    return executorService.submit(new Callable<Handshake>() {
+      @Override public Handshake call() throws Exception {
+        Socket rawSocket = SocketFactory.getDefault().createSocket();
+        rawSocket.connect(serverAddress);
+        SSLSocket sslSocket = null;
+        try {
+          sslSocket = (SSLSocket) client.sslSocketFactory().createSocket(rawSocket,
+              rawSocket.getInetAddress().getHostAddress(), rawSocket.getPort(),
+              true /* autoClose */);
+          sslSocket.startHandshake();
+          return Handshake.get(sslSocket.getSession());
+        } finally {
+          Util.closeQuietly(rawSocket);
+          Util.closeQuietly(sslSocket);
+        }
+      }
+    });
+  }
+
+  private void assertPrivateKeysEquals(PrivateKey expected, PrivateKey actual) {
+    assertEquals(ByteString.of(expected.getEncoded()), ByteString.of(actual.getEncoded()));
+  }
+}
diff --git a/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java b/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java
new file mode 100644
index 0000000000..96c8601b24
--- /dev/null
+++ b/okhttp-tls/src/test/java/okhttp3/tls/HeldCertificateTest.java
@@ -0,0 +1,226 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.tls;
+
+import java.math.BigInteger;
+import java.security.KeyFactory;
+import java.security.PrivateKey;
+import java.security.PublicKey;
+import java.security.cert.CertificateParsingException;
+import java.security.cert.X509Certificate;
+import java.security.spec.PKCS8EncodedKeySpec;
+import java.security.spec.X509EncodedKeySpec;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import okio.ByteString;
+import org.bouncycastle.asn1.x509.GeneralName;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
+public final class HeldCertificateTest {
+  @Test public void defaultCertificate() throws CertificateParsingException {
+    long now = System.currentTimeMillis();
+    HeldCertificate heldCertificate = new HeldCertificate.Builder().build();
+
+    X509Certificate certificate = heldCertificate.certificate();
+    assertEquals("self-signed",
+        certificate.getIssuerX500Principal().getName(),
+        certificate.getSubjectX500Principal().getName());
+    assertTrue(certificate.getIssuerX500Principal().getName().matches("CN=[0-9a-f-]{36}"));
+    assertEquals(BigInteger.ONE, certificate.getSerialNumber());
+    assertNull(certificate.getSubjectAlternativeNames());
+
+    double deltaMillis = 1000.0;
+    long durationMillis = TimeUnit.MINUTES.toMillis(60 * 24);
+    assertEquals((double) now, certificate.getNotBefore().getTime(), deltaMillis);
+    assertEquals((double) now + durationMillis, certificate.getNotAfter().getTime(), deltaMillis);
+
+    System.out.println(ByteString.of(heldCertificate.keyPair().getPublic().getEncoded()).base64());
+    System.out.println(ByteString.of(heldCertificate.keyPair().getPrivate().getEncoded()).base64());
+  }
+
+  @Test public void customInterval() {
+    // 5 seconds starting on 1970-01-01.
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .validityInterval(5_000L, 10_000L)
+        .build();
+    X509Certificate certificate = heldCertificate.certificate();
+    assertEquals(5_000L, certificate.getNotBefore().getTime());
+    assertEquals(10_000L, certificate.getNotAfter().getTime());
+  }
+
+  @Test public void customDuration() {
+    long now = System.currentTimeMillis();
+
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .duration(5, TimeUnit.SECONDS)
+        .build();
+    X509Certificate certificate = heldCertificate.certificate();
+
+    double deltaMillis = 1000.0;
+    long durationMillis = 5_000L;
+    assertEquals((double) now, certificate.getNotBefore().getTime(), deltaMillis);
+    assertEquals((double) now + durationMillis, certificate.getNotAfter().getTime(), deltaMillis);
+  }
+
+  @Test public void subjectAlternativeNames() throws CertificateParsingException {
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .addSubjectAlternativeName("1.1.1.1")
+        .addSubjectAlternativeName("cash.app")
+        .build();
+
+    X509Certificate certificate = heldCertificate.certificate();
+    List<List<?>> subjectAlternativeNames = new ArrayList<>(
+        certificate.getSubjectAlternativeNames());
+    assertEquals(subjectAlternativeNames, Arrays.asList(
+        Arrays.asList(GeneralName.iPAddress, "1.1.1.1"),
+        Arrays.asList(GeneralName.dNSName, "cash.app")));
+  }
+
+  @Test public void commonName() {
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .commonName("cash.app")
+        .build();
+
+    X509Certificate certificate = heldCertificate.certificate();
+    assertEquals("CN=cash.app", certificate.getSubjectX500Principal().getName());
+  }
+
+  @Test public void organizationalUnit() {
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .commonName("cash.app")
+        .organizationalUnit("cash")
+        .build();
+
+    X509Certificate certificate = heldCertificate.certificate();
+    assertEquals("CN=cash.app,OU=cash", certificate.getSubjectX500Principal().getName());
+  }
+
+  /** Confirm golden values of encoded PEMs. */
+  @Test public void pems() throws Exception {
+    KeyFactory keyFactory = KeyFactory.getInstance("RSA");
+
+    ByteString publicKeyBytes = ByteString.decodeBase64("MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCApF"
+        + "HhtrLan28q+oMolZuaTfWBA0V5aMIvq32BsloQu6LlvX1wJ4YEoUCjDlPOtpht7XLbUmBnbIzN89XK4UJVM6Sqp3"
+        + "K88Km8z7gMrdrfTom/274wL25fICR+yDEQ5fUVYBmJAKXZF1aoI0mIoEx0xFsQhIJ637v2MxJDupd61wIDAQAB");
+    PublicKey publicKey = keyFactory.generatePublic(
+        new X509EncodedKeySpec(publicKeyBytes.toByteArray()));
+
+    ByteString privateKeyBytes = ByteString.decodeBase64("MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbA"
+        + "gEAAoGBAICkUeG2stqfbyr6gyiVm5pN9YEDRXlowi+rfYGyWhC7ouW9fXAnhgShQKMOU862mG3tcttSYGdsjM3z1"
+        + "crhQlUzpKqncrzwqbzPuAyt2t9Oib/bvjAvbl8gJH7IMRDl9RVgGYkApdkXVqgjSYigTHTEWxCEgnrfu/YzEkO6l"
+        + "3rXAgMBAAECgYB99mhnB6piADOuddXv626NzUBTr4xbsYRTgSxHzwf50oFTTBSDuW+1IOBVyTWu94SSPyt0LllPb"
+        + "C8Di3sQSTnVGpSqAvEXknBMzIc0UO74Rn9p3gZjEenPt1l77fIBa2nK06/rdsJCoE/1P1JSfM9w7LU1RsTmseYML"
+        + "eJl5F79gQJBAO/BbAKqg1yzK7VijygvBoUrr+rt2lbmKgcUQ/rxu8IIQk0M/xgJqSkXDXuOnboGM7sQSKfJAZUtT"
+        + "7xozvLzV7ECQQCJW59w7NIM0qZ/gIX2gcNZr1B/V3zcGlolTDciRm+fnKGNt2EEDKnVL3swzbEfTCa48IT0QKgZJ"
+        + "qpXZERa26UHAkBLXmiP5f5pk8F3wcXzAeVw06z3k1IB41Tu6MX+CyPU+TeudRlz+wV8b0zDvK+EnRKCCbptVFj1B"
+        + "kt8lQ4JfcnhAkAk2Y3Gz+HySrkcT7Cg12M/NkdUQnZe3jr88pt/+IGNwomc6Wt/mJ4fcWONTkGMcfOZff1NQeNXD"
+        + "AZ6941XCsIVAkASOg02PlVHLidU7mIE65swMM5/RNhS4aFjez/MwxFNOHaxc9VgCwYPXCLOtdf7AVovdyG0XWgbU"
+        + "XH+NyxKwboE");
+    PrivateKey privateKey = keyFactory.generatePrivate(
+        new PKCS8EncodedKeySpec(privateKeyBytes.toByteArray()));
+
+    HeldCertificate heldCertificate = new HeldCertificate.Builder()
+        .keyPair(publicKey, privateKey)
+        .commonName("cash.app")
+        .validityInterval(0L, 1_000L)
+        .rsa2048()
+        .build();
+
+    assertEquals(heldCertificate.certificatePem(), ""
+        + "-----BEGIN CERTIFICATE-----\n"
+        + "MIIBmjCCAQOgAwIBAgIBATANBgkqhkiG9w0BAQsFADATMREwDwYDVQQDEwhjYXNo\n"
+        + "LmFwcDAeFw03MDAxMDEwMDAwMDBaFw03MDAxMDEwMDAwMDFaMBMxETAPBgNVBAMT\n"
+        + "CGNhc2guYXBwMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCApFHhtrLan28q\n"
+        + "+oMolZuaTfWBA0V5aMIvq32BsloQu6LlvX1wJ4YEoUCjDlPOtpht7XLbUmBnbIzN\n"
+        + "89XK4UJVM6Sqp3K88Km8z7gMrdrfTom/274wL25fICR+yDEQ5fUVYBmJAKXZF1ao\n"
+        + "I0mIoEx0xFsQhIJ637v2MxJDupd61wIDAQABMA0GCSqGSIb3DQEBCwUAA4GBADam\n"
+        + "UVwKh5Ry7es3OxtY3IgQunPUoLc0Gw71gl9Z+7t2FJ5VkcI5gWfutmdxZ2bDXCI8\n"
+        + "8V0vxo1pHXnbBrnxhS/Z3TBerw8RyQqcaWOdp+pBXyIWmR+jHk9cHZCqQveTIBsY\n"
+        + "jaA9VEhgdaVhxBsT2qzUNDsXlOzGsliznDfoqETb\n"
+        + "-----END CERTIFICATE-----\n");
+
+    assertEquals(heldCertificate.privateKeyPkcs1Pem(), ""
+        + "-----BEGIN RSA PRIVATE KEY-----\n"
+        + "MIICWwIBAAKBgQCApFHhtrLan28q+oMolZuaTfWBA0V5aMIvq32BsloQu6LlvX1w\n"
+        + "J4YEoUCjDlPOtpht7XLbUmBnbIzN89XK4UJVM6Sqp3K88Km8z7gMrdrfTom/274w\n"
+        + "L25fICR+yDEQ5fUVYBmJAKXZF1aoI0mIoEx0xFsQhIJ637v2MxJDupd61wIDAQAB\n"
+        + "AoGAffZoZweqYgAzrnXV7+tujc1AU6+MW7GEU4EsR88H+dKBU0wUg7lvtSDgVck1\n"
+        + "rveEkj8rdC5ZT2wvA4t7EEk51RqUqgLxF5JwTMyHNFDu+EZ/ad4GYxHpz7dZe+3y\n"
+        + "AWtpytOv63bCQqBP9T9SUnzPcOy1NUbE5rHmDC3iZeRe/YECQQDvwWwCqoNcsyu1\n"
+        + "Yo8oLwaFK6/q7dpW5ioHFEP68bvCCEJNDP8YCakpFw17jp26BjO7EEinyQGVLU+8\n"
+        + "aM7y81exAkEAiVufcOzSDNKmf4CF9oHDWa9Qf1d83BpaJUw3IkZvn5yhjbdhBAyp\n"
+        + "1S97MM2xH0wmuPCE9ECoGSaqV2REWtulBwJAS15oj+X+aZPBd8HF8wHlcNOs95NS\n"
+        + "AeNU7ujF/gsj1Pk3rnUZc/sFfG9Mw7yvhJ0Sggm6bVRY9QZLfJUOCX3J4QJAJNmN\n"
+        + "xs/h8kq5HE+woNdjPzZHVEJ2Xt46/PKbf/iBjcKJnOlrf5ieH3FjjU5BjHHzmX39\n"
+        + "TUHjVwwGeveNVwrCFQJAEjoNNj5VRy4nVO5iBOubMDDOf0TYUuGhY3s/zMMRTTh2\n"
+        + "sXPVYAsGD1wizrXX+wFaL3chtF1oG1Fx/jcsSsG6BA==\n"
+        + "-----END RSA PRIVATE KEY-----\n");
+
+    assertEquals(heldCertificate.privateKeyPkcs8Pem(), ""
+        + "-----BEGIN PRIVATE KEY-----\n"
+        + "MIICdQIBADANBgkqhkiG9w0BAQEFAASCAl8wggJbAgEAAoGBAICkUeG2stqfbyr6\n"
+        + "gyiVm5pN9YEDRXlowi+rfYGyWhC7ouW9fXAnhgShQKMOU862mG3tcttSYGdsjM3z\n"
+        + "1crhQlUzpKqncrzwqbzPuAyt2t9Oib/bvjAvbl8gJH7IMRDl9RVgGYkApdkXVqgj\n"
+        + "SYigTHTEWxCEgnrfu/YzEkO6l3rXAgMBAAECgYB99mhnB6piADOuddXv626NzUBT\n"
+        + "r4xbsYRTgSxHzwf50oFTTBSDuW+1IOBVyTWu94SSPyt0LllPbC8Di3sQSTnVGpSq\n"
+        + "AvEXknBMzIc0UO74Rn9p3gZjEenPt1l77fIBa2nK06/rdsJCoE/1P1JSfM9w7LU1\n"
+        + "RsTmseYMLeJl5F79gQJBAO/BbAKqg1yzK7VijygvBoUrr+rt2lbmKgcUQ/rxu8II\n"
+        + "Qk0M/xgJqSkXDXuOnboGM7sQSKfJAZUtT7xozvLzV7ECQQCJW59w7NIM0qZ/gIX2\n"
+        + "gcNZr1B/V3zcGlolTDciRm+fnKGNt2EEDKnVL3swzbEfTCa48IT0QKgZJqpXZERa\n"
+        + "26UHAkBLXmiP5f5pk8F3wcXzAeVw06z3k1IB41Tu6MX+CyPU+TeudRlz+wV8b0zD\n"
+        + "vK+EnRKCCbptVFj1Bkt8lQ4JfcnhAkAk2Y3Gz+HySrkcT7Cg12M/NkdUQnZe3jr8\n"
+        + "8pt/+IGNwomc6Wt/mJ4fcWONTkGMcfOZff1NQeNXDAZ6941XCsIVAkASOg02PlVH\n"
+        + "LidU7mIE65swMM5/RNhS4aFjez/MwxFNOHaxc9VgCwYPXCLOtdf7AVovdyG0XWgb\n"
+        + "UXH+NyxKwboE\n"
+        + "-----END PRIVATE KEY-----\n");
+  }
+
+  @Test public void ecdsaSignedByRsa() {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .rsa2048()
+        .build();
+    HeldCertificate leaf = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .ecdsa256()
+        .signedBy(root)
+        .build();
+
+    assertEquals("SHA256WITHRSA", root.certificate().getSigAlgName());
+    assertEquals("SHA256WITHRSA", leaf.certificate().getSigAlgName());
+  }
+
+  @Test public void rsaSignedByEcdsa() {
+    HeldCertificate root = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .ecdsa256()
+        .build();
+    HeldCertificate leaf = new HeldCertificate.Builder()
+        .certificateAuthority(0)
+        .rsa2048()
+        .signedBy(root)
+        .build();
+
+    assertEquals("SHA256WITHECDSA", root.certificate().getSigAlgName());
+    assertEquals("SHA256WITHECDSA", leaf.certificate().getSigAlgName());
+  }
+}
diff --git a/okhttp-urlconnection/pom.xml b/okhttp-urlconnection/pom.xml
index 34c265c24c..249a90de04 100644
--- a/okhttp-urlconnection/pom.xml
+++ b/okhttp-urlconnection/pom.xml
@@ -6,13 +6,18 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.6.0-SNAPSHOT</version>
+    <version>3.12.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp-urlconnection</artifactId>
   <name>OkHttp URLConnection</name>
 
   <dependencies>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
     <dependency>
       <groupId>org.codehaus.mojo</groupId>
       <artifactId>animal-sniffer-annotations</artifactId>
@@ -30,6 +35,12 @@
       <version>${project.version}</version>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>okhttp-tls</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
 
     <dependency>
       <groupId>junit</groupId>
@@ -49,6 +60,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
         <configuration>
           <excludePackageNames>okhttp3.internal:okhttp3.internal.*</excludePackageNames>
           <links>
@@ -56,6 +68,18 @@
           </links>
         </configuration>
       </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>okhttp3.urlconnection</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
index b5440a4d02..2649510d35 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/JavaNetAuthenticator.java
@@ -54,7 +54,8 @@
       }
 
       if (auth != null) {
-        String credential = Credentials.basic(auth.getUserName(), new String(auth.getPassword()));
+        String credential = Credentials.basic(
+            auth.getUserName(), new String(auth.getPassword()), challenge.charset());
         return request.newBuilder()
             .header(proxyAuthorization ? "Proxy-Authorization" : "Authorization", credential)
             .build();
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
index 9dd7cfd0b1..a051bf2198 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/DelegatingHttpsURLConnection.java
@@ -41,7 +41,7 @@
 abstract class DelegatingHttpsURLConnection extends HttpsURLConnection {
   private final HttpURLConnection delegate;
 
-  public DelegatingHttpsURLConnection(HttpURLConnection delegate) {
+  DelegatingHttpsURLConnection(HttpURLConnection delegate) {
     super(delegate.getURL());
     this.delegate = delegate;
   }
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
index 461b1f1c48..31e532d0ad 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpURLConnection.java
@@ -23,10 +23,12 @@
 import java.io.OutputStream;
 import java.net.HttpURLConnection;
 import java.net.InetSocketAddress;
+import java.net.MalformedURLException;
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.SocketPermission;
 import java.net.URL;
+import java.net.UnknownHostException;
 import java.security.Permission;
 import java.util.Arrays;
 import java.util.Collections;
@@ -50,13 +52,13 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.JavaNetHeaders;
 import okhttp3.internal.URLFilter;
-import okhttp3.internal.Util;
 import okhttp3.internal.Version;
 import okhttp3.internal.http.HttpDate;
 import okhttp3.internal.http.HttpHeaders;
 import okhttp3.internal.http.HttpMethod;
 import okhttp3.internal.http.StatusLine;
 import okhttp3.internal.platform.Platform;
+import okio.Buffer;
 
 import static okhttp3.internal.platform.Platform.WARN;
 
@@ -132,6 +134,7 @@ public OkHttpURLConnection(URL url, OkHttpClient client, URLFilter urlFilter) {
           throw propagate(callFailure);
         }
       } catch (InterruptedException e) {
+        Thread.currentThread().interrupt(); // Retain interrupted status.
         throw new InterruptedIOException();
       }
     }
@@ -369,8 +372,22 @@ private Call buildCall() throws IOException {
       requestBody.timeout().timeout(client.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
     }
 
+    HttpUrl url;
+    try {
+      url = HttpUrl.get(getURL().toString());
+    } catch (IllegalArgumentException e) {
+      if (Internal.instance.isInvalidHttpUrlHost(e)) {
+        UnknownHostException unknownHost = new UnknownHostException();
+        unknownHost.initCause(e);
+        throw unknownHost;
+      }
+      MalformedURLException malformedUrl = new MalformedURLException();
+      malformedUrl.initCause(e);
+      throw malformedUrl;
+    }
+
     Request request = new Request.Builder()
-        .url(Internal.instance.getHttpUrlChecked(getURL().toString()))
+        .url(url)
         .headers(requestHeaders.build())
         .method(method, requestBody)
         .build();
@@ -398,7 +415,25 @@ private Call buildCall() throws IOException {
 
   private String defaultUserAgent() {
     String agent = System.getProperty("http.agent");
-    return agent != null ? Util.toHumanReadableAscii(agent) : Version.userAgent();
+    return agent != null ? toHumanReadableAscii(agent) : Version.userAgent();
+  }
+
+  /** Returns {@code s} with control characters and non-ASCII characters replaced with '?'. */
+  private static String toHumanReadableAscii(String s) {
+    for (int i = 0, length = s.length(), c; i < length; i += Character.charCount(c)) {
+      c = s.codePointAt(i);
+      if (c > '\u001f' && c < '\u007f') continue;
+
+      Buffer buffer = new Buffer();
+      buffer.writeUtf8(s, 0, i);
+      buffer.writeUtf8CodePoint('?');
+      for (int j = i + Character.charCount(c); j < length; j += Character.charCount(c)) {
+        c = s.codePointAt(j);
+        buffer.writeUtf8CodePoint(c > '\u001f' && c < '\u007f' ? c : '?');
+      }
+      return buffer.readUtf8();
+    }
+    return s;
   }
 
   /**
@@ -427,6 +462,7 @@ private Response getResponse(boolean networkResponseOnError) throws IOException
             lock.wait(); // Wait until the response is returned or the call fails.
           }
         } catch (InterruptedException e) {
+          Thread.currentThread().interrupt(); // Retain interrupted status.
           throw new InterruptedIOException();
         }
       }
@@ -568,7 +604,7 @@ private Response getResponse(boolean networkResponseOnError) throws IOException
       }
     };
 
-    public UnexpectedException(Throwable cause) {
+    UnexpectedException(Throwable cause) {
       super(cause);
     }
   }
@@ -616,6 +652,7 @@ public void proceed() {
             lock.wait(); // Wait until proceed() is called.
           }
         } catch (InterruptedException e) {
+          Thread.currentThread().interrupt(); // Retain interrupted status.
           throw new InterruptedIOException();
         }
       }
diff --git a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java
index 0057174226..9dc40b80a2 100644
--- a/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java
+++ b/okhttp-urlconnection/src/main/java/okhttp3/internal/huc/OkHttpsURLConnection.java
@@ -58,6 +58,9 @@ public OkHttpsURLConnection(OkHttpURLConnection delegate) {
   }
 
   @Override public void setSSLSocketFactory(SSLSocketFactory sslSocketFactory) {
+    if (sslSocketFactory == null) {
+      throw new IllegalArgumentException("sslSocketFactory == null");
+    }
     // This fails in JDK 9 because OkHttp is unable to extract the trust manager.
     delegate.client = delegate.client.newBuilder()
         .sslSocketFactory(sslSocketFactory)
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java b/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
index d0f706f0d0..914725fb84 100644
--- a/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/OkUrlFactoryTest.java
@@ -2,8 +2,11 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.io.InputStream;
 import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
 import java.net.URL;
+import java.net.UnknownHostException;
 import java.text.DateFormat;
 import java.text.SimpleDateFormat;
 import java.util.Date;
@@ -14,9 +17,10 @@
 import okhttp3.internal.URLFilter;
 import okhttp3.internal.huc.OkHttpURLConnection;
 import okhttp3.internal.io.InMemoryFileSystem;
-import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.tls.HandshakeCertificates;
 import okio.BufferedSource;
 import org.junit.After;
 import org.junit.Before;
@@ -24,6 +28,7 @@
 import org.junit.Test;
 
 import static java.nio.charset.StandardCharsets.US_ASCII;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static okio.Okio.buffer;
 import static okio.Okio.source;
 import static org.junit.Assert.assertEquals;
@@ -36,7 +41,7 @@
   private OkUrlFactory factory;
   private Cache cache;
 
-  @Before public void setUp() throws IOException {
+  @Before public void setUp() {
     cache = new Cache(new File("/cache/"), 10 * 1024 * 1024, fileSystem);
     OkHttpClient client = new OkHttpClient.Builder()
         .cache(cache)
@@ -52,7 +57,7 @@
    * Response code 407 should only come from proxy servers. Android's client throws if it is sent by
    * an origin server.
    */
-  @Test public void originServerSends407() throws Exception {
+  @Test public void originServerSends407() {
     server.enqueue(new MockResponse().setResponseCode(407));
 
     HttpURLConnection conn = factory.open(server.url("/").url());
@@ -177,16 +182,17 @@ public void checkURLPermitted(URL url) throws IOException {
   }
 
   @Test
-  public void testURLFilterRedirect() throws Exception {
+  public void testURLFilterRedirect() {
     MockWebServer cleartextServer = new MockWebServer();
     cleartextServer.enqueue(new MockResponse()
         .setBody("Blocked!"));
     final URL blockedURL = cleartextServer.url("/").url();
 
-    SslClient contextBuilder = SslClient.localhost();
-    server.useHttps(contextBuilder.socketFactory, false);
+    HandshakeCertificates handshakeCertificates = localhost();
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     factory.setClient(factory.client().newBuilder()
-        .sslSocketFactory(contextBuilder.socketFactory, contextBuilder.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .followSslRedirects(true)
         .build());
     factory.setUrlFilter(new URLFilter() {
@@ -211,6 +217,71 @@ public void checkURLPermitted(URL url) throws IOException {
     }
   }
 
+  @Test public void usesValidHeaderValueForDefaultUserAgent() throws Exception {
+    String userAgent =  "ðŸ© " + "\u001F" + ('\u001f' + 1) + ('\u007f' - 1)+ '\u007f' + " ðŸ©";
+    String expected = "? ?" + ('\u001f' + 1) + ('\u007f' - 1) + "? ?";
+
+    System.setProperty("http.agent", userAgent);
+    server.enqueue(new MockResponse().setResponseCode(200));
+    InputStream inputStream = factory.open(server.url("/").url()).getInputStream();
+    long skipped;
+    do {
+      skipped = inputStream.skip(Long.MAX_VALUE);
+    } while (skipped != 0);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(expected, recordedRequest.getHeader("User-Agent"));
+  }
+
+  @Test public void usesSimpleDefaultUserAgentWithoutModification() throws Exception {
+    String userAgent = "OkHttp";
+    String expected = "OkHttp";
+
+    System.setProperty("http.agent", userAgent);
+    server.enqueue(new MockResponse().setResponseCode(200));
+    InputStream inputStream = factory.open(server.url("/").url()).getInputStream();
+    long skipped;
+    do {
+      skipped = inputStream.skip(Long.MAX_VALUE);
+    } while (skipped != 0);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(expected, recordedRequest.getHeader("User-Agent"));
+  }
+
+  @Test public void handlesBadUnicodeStringsInDefaultUserAgent() throws Exception {
+    String userAgent =  "ðŸ”Š".substring(0, 1);
+    String expected = "?";
+
+    System.setProperty("http.agent", userAgent);
+    server.enqueue(new MockResponse().setResponseCode(200));
+    InputStream inputStream = factory.open(server.url("/").url()).getInputStream();
+    long skipped;
+    do {
+      skipped = inputStream.skip(Long.MAX_VALUE);
+    } while (skipped != 0);
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals(expected, recordedRequest.getHeader("User-Agent"));
+  }
+
+  @Test public void javaNetUrlMalformedUrl() throws Exception {
+    server.enqueue(new MockResponse());
+    HttpURLConnection connection = factory.open(new URL("http://example.com:-1"));
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (MalformedURLException expected) {
+    }
+  }
+
+  @Test public void javaNetUrlBadHost() throws Exception {
+    server.enqueue(new MockResponse());
+    HttpURLConnection connection = factory.open(new URL("http://hostw ithspace/"));
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
   private void assertResponseBody(HttpURLConnection connection, String expected) throws Exception {
     BufferedSource source = buffer(source(connection.getInputStream()));
     String actual = source.readString(US_ASCII);
diff --git a/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java b/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
index ab4af9a350..23ff40c89e 100644
--- a/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
+++ b/okhttp-urlconnection/src/test/java/okhttp3/UrlConnectionCacheTest.java
@@ -44,10 +44,10 @@
 import okhttp3.internal.Internal;
 import okhttp3.internal.io.InMemoryFileSystem;
 import okhttp3.internal.platform.Platform;
-import okhttp3.internal.tls.SslClient;
 import okhttp3.mockwebserver.MockResponse;
 import okhttp3.mockwebserver.MockWebServer;
 import okhttp3.mockwebserver.RecordedRequest;
+import okhttp3.tls.HandshakeCertificates;
 import okio.Buffer;
 import okio.BufferedSink;
 import okio.GzipSink;
@@ -58,6 +58,7 @@
 import org.junit.Test;
 
 import static okhttp3.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static okhttp3.tls.internal.TlsUtil.localhost;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
@@ -79,12 +80,12 @@
   @Rule public MockWebServer server2 = new MockWebServer();
   @Rule public InMemoryFileSystem fileSystem = new InMemoryFileSystem();
 
-  private final SslClient sslClient = SslClient.localhost();
+  private final HandshakeCertificates handshakeCertificates = localhost();
   private OkUrlFactory urlFactory = new OkUrlFactory(new OkHttpClient());
   private Cache cache;
   private final CookieManager cookieManager = new CookieManager();
 
-  @Before public void setUp() throws Exception {
+  @Before public void setUp() {
     server.setProtocolNegotiationEnabled(false);
     cache = new Cache(new File("/cache/"), Integer.MAX_VALUE, fileSystem);
     urlFactory = new OkUrlFactory(new OkHttpClient.Builder()
@@ -98,7 +99,7 @@
     cache.delete();
   }
 
-  @Test public void responseCacheAccessWithOkHttpMember() throws IOException {
+  @Test public void responseCacheAccessWithOkHttpMember() {
     assertSame(cache, urlFactory.client().cache());
   }
 
@@ -262,13 +263,14 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   @Test public void secureResponseCaching() throws IOException {
     assumeFalse(getPlatform().equals("jdk9"));
 
-    server.useHttps(sslClient.socketFactory, false);
-    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
 
     HttpsURLConnection c1 = (HttpsURLConnection) urlFactory.open(server.url("/").url());
-    c1.setSSLSocketFactory(sslClient.socketFactory);
+    c1.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     c1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     assertEquals("ABC", readAscii(c1));
 
@@ -280,7 +282,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     Principal localPrincipal = c1.getLocalPrincipal();
 
     HttpsURLConnection c2 = (HttpsURLConnection) urlFactory.open(server.url("/").url()); // cached!
-    c2.setSSLSocketFactory(sslClient.socketFactory);
+    c2.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     c2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     assertEquals("ABC", readAscii(c2));
 
@@ -340,7 +342,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
   }
 
   @Test public void secureResponseCachingAndRedirects() throws IOException {
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
@@ -351,7 +353,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     server.enqueue(new MockResponse().setBody("DEF"));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build());
 
@@ -377,7 +380,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
    * https://github.com/square/okhttp/issues/214
    */
   @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
-    server2.useHttps(sslClient.socketFactory, false);
+    server2.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server2.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
         .setBody("ABC"));
@@ -389,7 +392,8 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
         .addHeader("Location: " + server2.url("/").url()));
 
     urlFactory.setClient(urlFactory.client().newBuilder()
-        .sslSocketFactory(sslClient.socketFactory, sslClient.trustManager)
+        .sslSocketFactory(
+            handshakeCertificates.sslSocketFactory(), handshakeCertificates.trustManager())
         .hostnameVerifier(NULL_HOSTNAME_VERIFIER)
         .build());
 
@@ -412,7 +416,7 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     testServerPrematureDisconnect(TransferKind.CHUNKED);
   }
 
-  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() throws IOException {
+  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() {
     // Intentionally empty. This case doesn't make sense because there's no
     // such thing as a premature disconnect when the disconnect itself
     // indicates the end of the data stream.
@@ -1079,7 +1083,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
     Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
     DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
-    dateFormat.setTimeZone(TimeZone.getTimeZone("EDT"));
+    dateFormat.setTimeZone(TimeZone.getTimeZone("America/New_York"));
     String lastModifiedString = dateFormat.format(lastModifiedDate);
     String servedString = dateFormat.format(servedDate);
 
@@ -1407,7 +1411,7 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
   @Test public void varyAndHttps() throws Exception {
     assumeFalse(getPlatform().equals("jdk9"));
 
-    server.useHttps(sslClient.socketFactory, false);
+    server.useHttps(handshakeCertificates.sslSocketFactory(), false);
     server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
         .addHeader("Vary: Accept-Language")
         .setBody("A"));
@@ -1415,13 +1419,13 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
 
     URL url = server.url("/").url();
     HttpsURLConnection connection1 = (HttpsURLConnection) urlFactory.open(url);
-    connection1.setSSLSocketFactory(sslClient.socketFactory);
+    connection1.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     connection1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     connection1.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection1));
 
     HttpsURLConnection connection2 = (HttpsURLConnection) urlFactory.open(url);
-    connection2.setSSLSocketFactory(sslClient.socketFactory);
+    connection2.setSSLSocketFactory(handshakeCertificates.sslSocketFactory());
     connection2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
     connection2.addRequestProperty("Accept-Language", "en-US");
     assertEquals("A", readAscii(connection2));
@@ -1805,8 +1809,7 @@ private void assertGatewayTimeout(HttpURLConnection connection) throws IOExcepti
 
   enum TransferKind {
     CHUNKED() {
-      @Override void setBody(MockResponse response, Buffer content, int chunkSize)
-          throws IOException {
+      @Override void setBody(MockResponse response, Buffer content, int chunkSize) {
         response.setChunkedBody(content, chunkSize);
       }
     },
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index a3e5aaa134..0bd07c596c 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.6.0-SNAPSHOT</version>
+    <version>3.12.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>okhttp</artifactId>
@@ -17,11 +17,21 @@
       <groupId>com.squareup.okio</groupId>
       <artifactId>okio</artifactId>
     </dependency>
+    <dependency>
+      <groupId>org.conscrypt</groupId>
+      <artifactId>conscrypt-openjdk-uber</artifactId>
+      <scope>provided</scope>
+    </dependency>
     <dependency>
       <groupId>com.google.android</groupId>
       <artifactId>android</artifactId>
       <scope>provided</scope>
     </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <scope>provided</scope>
+    </dependency>
   </dependencies>
 
   <build>
@@ -41,6 +51,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-javadoc-plugin</artifactId>
+        <version>2.10.4</version>
         <configuration>
           <excludePackageNames>okhttp3.internal:okhttp3.internal.*</excludePackageNames>
           <links>
@@ -48,6 +59,18 @@
           </links>
         </configuration>
       </plugin>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-jar-plugin</artifactId>
+        <version>3.0.2</version>
+        <configuration>
+          <archive>
+            <manifestEntries>
+              <Automatic-Module-Name>okhttp3</Automatic-Module-Name>
+            </manifestEntries>
+          </archive>
+        </configuration>
+      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/okhttp/src/main/java/okhttp3/Address.java b/okhttp/src/main/java/okhttp3/Address.java
index 8aef1932a5..9df666ad78 100644
--- a/okhttp/src/main/java/okhttp3/Address.java
+++ b/okhttp/src/main/java/okhttp3/Address.java
@@ -18,6 +18,7 @@
 import java.net.Proxy;
 import java.net.ProxySelector;
 import java.util.List;
+import javax.annotation.Nullable;
 import javax.net.SocketFactory;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLSocketFactory;
@@ -42,15 +43,16 @@
   final List<Protocol> protocols;
   final List<ConnectionSpec> connectionSpecs;
   final ProxySelector proxySelector;
-  final Proxy proxy;
-  final SSLSocketFactory sslSocketFactory;
-  final HostnameVerifier hostnameVerifier;
-  final CertificatePinner certificatePinner;
+  final @Nullable Proxy proxy;
+  final @Nullable SSLSocketFactory sslSocketFactory;
+  final @Nullable HostnameVerifier hostnameVerifier;
+  final @Nullable CertificatePinner certificatePinner;
 
   public Address(String uriHost, int uriPort, Dns dns, SocketFactory socketFactory,
-      SSLSocketFactory sslSocketFactory, HostnameVerifier hostnameVerifier,
-      CertificatePinner certificatePinner, Authenticator proxyAuthenticator, Proxy proxy,
-      List<Protocol> protocols, List<ConnectionSpec> connectionSpecs, ProxySelector proxySelector) {
+      @Nullable SSLSocketFactory sslSocketFactory, @Nullable HostnameVerifier hostnameVerifier,
+      @Nullable CertificatePinner certificatePinner, Authenticator proxyAuthenticator,
+      @Nullable Proxy proxy, List<Protocol> protocols, List<ConnectionSpec> connectionSpecs,
+      ProxySelector proxySelector) {
     this.url = new HttpUrl.Builder()
         .scheme(sslSocketFactory != null ? "https" : "http")
         .host(uriHost)
@@ -130,40 +132,29 @@ public ProxySelector proxySelector() {
    * Returns this address's explicitly-specified HTTP proxy, or null to delegate to the {@linkplain
    * #proxySelector proxy selector}.
    */
-  public Proxy proxy() {
+  public @Nullable Proxy proxy() {
     return proxy;
   }
 
   /** Returns the SSL socket factory, or null if this is not an HTTPS address. */
-  public SSLSocketFactory sslSocketFactory() {
+  public @Nullable SSLSocketFactory sslSocketFactory() {
     return sslSocketFactory;
   }
 
   /** Returns the hostname verifier, or null if this is not an HTTPS address. */
-  public HostnameVerifier hostnameVerifier() {
+  public @Nullable HostnameVerifier hostnameVerifier() {
     return hostnameVerifier;
   }
 
   /** Returns this address's certificate pinner, or null if this is not an HTTPS address. */
-  public CertificatePinner certificatePinner() {
+  public @Nullable CertificatePinner certificatePinner() {
     return certificatePinner;
   }
 
-  @Override public boolean equals(Object other) {
-    if (other instanceof Address) {
-      Address that = (Address) other;
-      return this.url.equals(that.url)
-          && this.dns.equals(that.dns)
-          && this.proxyAuthenticator.equals(that.proxyAuthenticator)
-          && this.protocols.equals(that.protocols)
-          && this.connectionSpecs.equals(that.connectionSpecs)
-          && this.proxySelector.equals(that.proxySelector)
-          && equal(this.proxy, that.proxy)
-          && equal(this.sslSocketFactory, that.sslSocketFactory)
-          && equal(this.hostnameVerifier, that.hostnameVerifier)
-          && equal(this.certificatePinner, that.certificatePinner);
-    }
-    return false;
+  @Override public boolean equals(@Nullable Object other) {
+    return other instanceof Address
+        && url.equals(((Address) other).url)
+        && equalsNonHost((Address) other);
   }
 
   @Override public int hashCode() {
@@ -181,6 +172,19 @@ public CertificatePinner certificatePinner() {
     return result;
   }
 
+  boolean equalsNonHost(Address that) {
+    return this.dns.equals(that.dns)
+        && this.proxyAuthenticator.equals(that.proxyAuthenticator)
+        && this.protocols.equals(that.protocols)
+        && this.connectionSpecs.equals(that.connectionSpecs)
+        && this.proxySelector.equals(that.proxySelector)
+        && equal(this.proxy, that.proxy)
+        && equal(this.sslSocketFactory, that.sslSocketFactory)
+        && equal(this.hostnameVerifier, that.hostnameVerifier)
+        && equal(this.certificatePinner, that.certificatePinner)
+        && this.url().port() == that.url().port();
+  }
+
   @Override public String toString() {
     StringBuilder result = new StringBuilder()
         .append("Address{")
diff --git a/okhttp/src/main/java/okhttp3/Authenticator.java b/okhttp/src/main/java/okhttp3/Authenticator.java
index 6b0c4fe72b..9e34bc9706 100644
--- a/okhttp/src/main/java/okhttp3/Authenticator.java
+++ b/okhttp/src/main/java/okhttp3/Authenticator.java
@@ -16,6 +16,7 @@
 package okhttp3;
 
 import java.io.IOException;
+import javax.annotation.Nullable;
 
 /**
  * Responds to an authentication challenge from either a remote web server or a proxy server.
@@ -70,5 +71,5 @@
    * Returns a request that includes a credential to satisfy an authentication challenge in {@code
    * response}. Returns null if the challenge cannot be satisfied.
    */
-  Request authenticate(Route route, Response response) throws IOException;
+  @Nullable Request authenticate(Route route, Response response) throws IOException;
 }
diff --git a/okhttp/src/main/java/okhttp3/Cache.java b/okhttp/src/main/java/okhttp3/Cache.java
index 6ed941b8f2..d43d91d257 100644
--- a/okhttp/src/main/java/okhttp3/Cache.java
+++ b/okhttp/src/main/java/okhttp3/Cache.java
@@ -28,6 +28,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.NoSuchElementException;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okhttp3.internal.cache.CacheRequest;
 import okhttp3.internal.cache.CacheStrategy;
@@ -186,7 +187,7 @@ public static String key(HttpUrl url) {
     return ByteString.encodeUtf8(url.toString()).md5().hex();
   }
 
-  Response get(Request request) {
+  @Nullable Response get(Request request) {
     String key = key(request.url());
     DiskLruCache.Snapshot snapshot;
     Entry entry;
@@ -217,7 +218,7 @@ Response get(Request request) {
     return response;
   }
 
-  CacheRequest put(Response response) {
+  @Nullable CacheRequest put(Response response) {
     String requestMethod = response.request().method();
 
     if (HttpMethod.invalidatesCache(response.request().method())) {
@@ -273,7 +274,7 @@ void update(Response cached, Response network) {
     }
   }
 
-  private void abortQuietly(DiskLruCache.Editor editor) {
+  private void abortQuietly(@Nullable DiskLruCache.Editor editor) {
     // Give up because the cache cannot be written.
     try {
       if (editor != null) {
@@ -327,7 +328,7 @@ public void evictAll() throws IOException {
     return new Iterator<String>() {
       final Iterator<DiskLruCache.Snapshot> delegate = cache.snapshots();
 
-      String nextUrl;
+      @Nullable String nextUrl;
       boolean canRemove;
 
       @Override public boolean hasNext() {
@@ -432,7 +433,7 @@ public synchronized int requestCount() {
     private Sink body;
     boolean done;
 
-    public CacheRequestImpl(final DiskLruCache.Editor editor) {
+    CacheRequestImpl(final DiskLruCache.Editor editor) {
       this.editor = editor;
       this.cacheOut = editor.newSink(ENTRY_BODY);
       this.body = new ForwardingSink(cacheOut) {
@@ -484,7 +485,7 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) {
     private final int code;
     private final String message;
     private final Headers responseHeaders;
-    private final Handshake handshake;
+    private final @Nullable Handshake handshake;
     private final long sentRequestMillis;
     private final long receivedResponseMillis;
 
@@ -536,7 +537,7 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) {
      * base64-encoded and appear each on their own line. A length of -1 is used to encode a null
      * array. The last line is optional. If present, it contains the TLS version.
      */
-    public Entry(Source in) throws IOException {
+    Entry(Source in) throws IOException {
       try {
         BufferedSource source = Okio.buffer(in);
         url = source.readUtf8LineStrict();
@@ -580,7 +581,7 @@ public Entry(Source in) throws IOException {
           List<Certificate> localCertificates = readCertificateList(source);
           TlsVersion tlsVersion = !source.exhausted()
               ? TlsVersion.forJavaName(source.readUtf8LineStrict())
-              : null;
+              : TlsVersion.SSL_3_0;
           handshake = Handshake.get(tlsVersion, cipherSuite, peerCertificates, localCertificates);
         } else {
           handshake = null;
@@ -590,7 +591,7 @@ public Entry(Source in) throws IOException {
       }
     }
 
-    public Entry(Response response) {
+    Entry(Response response) {
       this.url = response.request().url().toString();
       this.varyHeaders = HttpHeaders.varyHeaders(response);
       this.requestMethod = response.request().method();
@@ -644,11 +645,7 @@ public void writeTo(DiskLruCache.Editor editor) throws IOException {
             .writeByte('\n');
         writeCertList(sink, handshake.peerCertificates());
         writeCertList(sink, handshake.localCertificates());
-        // The handshakeâ€™s TLS version is null on HttpsURLConnection and on older cached responses.
-        if (handshake.tlsVersion() != null) {
-          sink.writeUtf8(handshake.tlsVersion().javaName())
-              .writeByte('\n');
-        }
+        sink.writeUtf8(handshake.tlsVersion().javaName()).writeByte('\n');
       }
       sink.close();
     }
@@ -736,10 +733,10 @@ static int readInt(BufferedSource source) throws IOException {
   private static class CacheResponseBody extends ResponseBody {
     final DiskLruCache.Snapshot snapshot;
     private final BufferedSource bodySource;
-    private final String contentType;
-    private final String contentLength;
+    private final @Nullable String contentType;
+    private final @Nullable String contentLength;
 
-    public CacheResponseBody(final DiskLruCache.Snapshot snapshot,
+    CacheResponseBody(final DiskLruCache.Snapshot snapshot,
         String contentType, String contentLength) {
       this.snapshot = snapshot;
       this.contentType = contentType;
diff --git a/okhttp/src/main/java/okhttp3/CacheControl.java b/okhttp/src/main/java/okhttp3/CacheControl.java
index 39972c4bfb..a32add5f97 100644
--- a/okhttp/src/main/java/okhttp3/CacheControl.java
+++ b/okhttp/src/main/java/okhttp3/CacheControl.java
@@ -1,14 +1,14 @@
 package okhttp3;
 
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 import okhttp3.internal.http.HttpHeaders;
 
 /**
  * A Cache-Control header with cache directives from a server or client. These directives set policy
  * on what responses can be stored, and which requests can be satisfied by those stored responses.
  *
- * <p>See <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9">RFC 2616,
- * 14.9</a>.
+ * <p>See <a href="https://tools.ietf.org/html/rfc7234#section-5.2">RFC 7234, 5.2</a>.
  */
 public final class CacheControl {
   /**
@@ -38,12 +38,14 @@
   private final int minFreshSeconds;
   private final boolean onlyIfCached;
   private final boolean noTransform;
+  private final boolean immutable;
 
-  String headerValue; // Lazily computed, null if absent.
+  @Nullable String headerValue; // Lazily computed, null if absent.
 
   private CacheControl(boolean noCache, boolean noStore, int maxAgeSeconds, int sMaxAgeSeconds,
       boolean isPrivate, boolean isPublic, boolean mustRevalidate, int maxStaleSeconds,
-      int minFreshSeconds, boolean onlyIfCached, boolean noTransform, String headerValue) {
+      int minFreshSeconds, boolean onlyIfCached, boolean noTransform, boolean immutable,
+      @Nullable String headerValue) {
     this.noCache = noCache;
     this.noStore = noStore;
     this.maxAgeSeconds = maxAgeSeconds;
@@ -55,6 +57,7 @@ private CacheControl(boolean noCache, boolean noStore, int maxAgeSeconds, int sM
     this.minFreshSeconds = minFreshSeconds;
     this.onlyIfCached = onlyIfCached;
     this.noTransform = noTransform;
+    this.immutable = immutable;
     this.headerValue = headerValue;
   }
 
@@ -70,6 +73,7 @@ private CacheControl(boolean noCache, boolean noStore, int maxAgeSeconds, int sM
     this.minFreshSeconds = builder.minFreshSeconds;
     this.onlyIfCached = builder.onlyIfCached;
     this.noTransform = builder.noTransform;
+    this.immutable = builder.immutable;
   }
 
   /**
@@ -137,6 +141,10 @@ public boolean noTransform() {
     return noTransform;
   }
 
+  public boolean immutable() {
+    return immutable;
+  }
+
   /**
    * Returns the cache directives of {@code headers}. This honors both Cache-Control and Pragma
    * headers if they are present.
@@ -153,6 +161,7 @@ public static CacheControl parse(Headers headers) {
     int minFreshSeconds = -1;
     boolean onlyIfCached = false;
     boolean noTransform = false;
+    boolean immutable = false;
 
     boolean canUseHeaderValue = true;
     String headerValue = null;
@@ -227,6 +236,8 @@ public static CacheControl parse(Headers headers) {
           onlyIfCached = true;
         } else if ("no-transform".equalsIgnoreCase(directive)) {
           noTransform = true;
+        } else if ("immutable".equalsIgnoreCase(directive)) {
+          immutable = true;
         }
       }
     }
@@ -235,7 +246,8 @@ public static CacheControl parse(Headers headers) {
       headerValue = null;
     }
     return new CacheControl(noCache, noStore, maxAgeSeconds, sMaxAgeSeconds, isPrivate, isPublic,
-        mustRevalidate, maxStaleSeconds, minFreshSeconds, onlyIfCached, noTransform, headerValue);
+        mustRevalidate, maxStaleSeconds, minFreshSeconds, onlyIfCached, noTransform, immutable,
+        headerValue);
   }
 
   @Override public String toString() {
@@ -256,6 +268,7 @@ private String headerValue() {
     if (minFreshSeconds != -1) result.append("min-fresh=").append(minFreshSeconds).append(", ");
     if (onlyIfCached) result.append("only-if-cached, ");
     if (noTransform) result.append("no-transform, ");
+    if (immutable) result.append("immutable, ");
     if (result.length() == 0) return "";
     result.delete(result.length() - 2, result.length());
     return result.toString();
@@ -270,6 +283,7 @@ private String headerValue() {
     int minFreshSeconds = -1;
     boolean onlyIfCached;
     boolean noTransform;
+    boolean immutable;
 
     /** Don't accept an unvalidated cached response. */
     public Builder noCache() {
@@ -347,6 +361,11 @@ public Builder noTransform() {
       return this;
     }
 
+    public Builder immutable() {
+      this.immutable = true;
+      return this;
+    }
+
     public CacheControl build() {
       return new CacheControl(this);
     }
diff --git a/okhttp/src/main/java/okhttp3/Call.java b/okhttp/src/main/java/okhttp3/Call.java
index 5b4669ad21..cb9ac837f7 100644
--- a/okhttp/src/main/java/okhttp3/Call.java
+++ b/okhttp/src/main/java/okhttp3/Call.java
@@ -32,7 +32,7 @@
    * <p>To avoid leaking resources callers should close the {@link Response} which in turn will
    * close the underlying {@link ResponseBody}.
    *
-   * <pre>@{code
+   * <pre>{@code
    *
    *   // ensure the response (and underlying response body) is closed
    *   try (Response response = client.newCall(request).execute()) {
diff --git a/okhttp/src/main/java/okhttp3/CertificatePinner.java b/okhttp/src/main/java/okhttp3/CertificatePinner.java
index 722521a70c..d509364544 100644
--- a/okhttp/src/main/java/okhttp3/CertificatePinner.java
+++ b/okhttp/src/main/java/okhttp3/CertificatePinner.java
@@ -23,6 +23,7 @@
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import okhttp3.internal.tls.CertificateChainCleaner;
 import okio.ByteString;
@@ -128,14 +129,14 @@
   public static final CertificatePinner DEFAULT = new Builder().build();
 
   private final Set<Pin> pins;
-  private final CertificateChainCleaner certificateChainCleaner;
+  private final @Nullable CertificateChainCleaner certificateChainCleaner;
 
-  CertificatePinner(Set<Pin> pins, CertificateChainCleaner certificateChainCleaner) {
+  CertificatePinner(Set<Pin> pins, @Nullable CertificateChainCleaner certificateChainCleaner) {
     this.pins = pins;
     this.certificateChainCleaner = certificateChainCleaner;
   }
 
-  @Override public boolean equals(Object other) {
+  @Override public boolean equals(@Nullable Object other) {
     if (other == this) return true;
     return other instanceof CertificatePinner
         && (equal(certificateChainCleaner, ((CertificatePinner) other).certificateChainCleaner)
@@ -181,7 +182,7 @@ public void check(String hostname, List<Certificate> peerCertificates)
           if (sha1 == null) sha1 = sha1(x509Certificate);
           if (pin.hash.equals(sha1)) return; // Success!
         } else {
-          throw new AssertionError();
+          throw new AssertionError("unsupported hashAlgorithm: " + pin.hashAlgorithm);
         }
       }
     }
@@ -225,7 +226,8 @@ public void check(String hostname, Certificate... peerCertificates)
   }
 
   /** Returns a certificate pinner that uses {@code certificateChainCleaner}. */
-  CertificatePinner withCertificateChainCleaner(CertificateChainCleaner certificateChainCleaner) {
+  CertificatePinner withCertificateChainCleaner(
+      @Nullable CertificateChainCleaner certificateChainCleaner) {
     return equal(this.certificateChainCleaner, certificateChainCleaner)
         ? this
         : new CertificatePinner(pins, certificateChainCleaner);
@@ -266,8 +268,8 @@ static ByteString sha256(X509Certificate x509Certificate) {
     Pin(String pattern, String pin) {
       this.pattern = pattern;
       this.canonicalHostname = pattern.startsWith(WILDCARD)
-          ? HttpUrl.parse("http://" + pattern.substring(WILDCARD.length())).host()
-          : HttpUrl.parse("http://" + pattern).host();
+          ? HttpUrl.get("http://" + pattern.substring(WILDCARD.length())).host()
+          : HttpUrl.get("http://" + pattern).host();
       if (pin.startsWith("sha1/")) {
         this.hashAlgorithm = "sha1/";
         this.hash = ByteString.decodeBase64(pin.substring("sha1/".length()));
@@ -286,7 +288,8 @@ static ByteString sha256(X509Certificate x509Certificate) {
     boolean matches(String hostname) {
       if (pattern.startsWith(WILDCARD)) {
         int firstDot = hostname.indexOf('.');
-        return hostname.regionMatches(false, firstDot + 1, canonicalHostname, 0,
+        return (hostname.length() - firstDot - 1) == canonicalHostname.length()
+            && hostname.regionMatches(false, firstDot + 1, canonicalHostname, 0,
             canonicalHostname.length());
       }
 
diff --git a/okhttp/src/main/java/okhttp3/Challenge.java b/okhttp/src/main/java/okhttp3/Challenge.java
index f4bb369c45..4b000eceda 100644
--- a/okhttp/src/main/java/okhttp3/Challenge.java
+++ b/okhttp/src/main/java/okhttp3/Challenge.java
@@ -15,16 +15,33 @@
  */
 package okhttp3;
 
-import okhttp3.internal.Util;
+import java.nio.charset.Charset;
+import javax.annotation.Nullable;
 
-/** An RFC 2617 challenge. */
+import static okhttp3.internal.Util.ISO_8859_1;
+
+/** An RFC 7617 challenge. */
 public final class Challenge {
   private final String scheme;
   private final String realm;
+  private final Charset charset;
 
   public Challenge(String scheme, String realm) {
+    this(scheme, realm, ISO_8859_1);
+  }
+
+  private Challenge(String scheme, String realm, Charset charset) {
+    if (scheme == null) throw new NullPointerException("scheme == null");
+    if (realm == null) throw new NullPointerException("realm == null");
+    if (charset == null) throw new NullPointerException("charset == null");
     this.scheme = scheme;
     this.realm = realm;
+    this.charset = charset;
+  }
+
+  /** Returns a copy of this charset that expects a credential encoded with {@code charset}. */
+  public Challenge withCharset(Charset charset) {
+    return new Challenge(scheme, realm, charset);
   }
 
   /** Returns the authentication scheme, like {@code Basic}. */
@@ -37,20 +54,29 @@ public String realm() {
     return realm;
   }
 
-  @Override public boolean equals(Object o) {
-    return o instanceof Challenge
-        && Util.equal(scheme, ((Challenge) o).scheme)
-        && Util.equal(realm, ((Challenge) o).realm);
+  /** Returns the charset that should be used to encode the credential. */
+  public Charset charset() {
+    return charset;
+  }
+
+  @Override public boolean equals(@Nullable Object other) {
+    return other instanceof Challenge
+        && ((Challenge) other).scheme.equals(scheme)
+        && ((Challenge) other).realm.equals(realm)
+        && ((Challenge) other).charset.equals(charset);
   }
 
   @Override public int hashCode() {
     int result = 29;
-    result = 31 * result + (realm != null ? realm.hashCode() : 0);
-    result = 31 * result + (scheme != null ? scheme.hashCode() : 0);
+    result = 31 * result + realm.hashCode();
+    result = 31 * result + scheme.hashCode();
+    result = 31 * result + charset.hashCode();
     return result;
   }
 
   @Override public String toString() {
-    return scheme + " realm=\"" + realm + "\"";
+    return scheme
+        + " realm=\"" + realm + "\""
+        + " charset=\"" + charset + "\"";
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/CipherSuite.java b/okhttp/src/main/java/okhttp3/CipherSuite.java
index a3acd52e2f..80a41afbbb 100644
--- a/okhttp/src/main/java/okhttp3/CipherSuite.java
+++ b/okhttp/src/main/java/okhttp3/CipherSuite.java
@@ -15,8 +15,12 @@
  */
 package okhttp3;
 
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentMap;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Map;
+import java.util.TreeMap;
 
 /**
  * <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml">TLS cipher
@@ -25,17 +29,42 @@
  * <p><strong>Not all cipher suites are supported on all platforms.</strong> As newer cipher suites
  * are created (for stronger privacy, better performance, etc.) they will be adopted by the platform
  * and then exposed here. Cipher suites that are not available on either Android (through API level
- * 20) or Java (through JDK 8) are omitted for brevity.
+ * 24) or Java (through JDK 9) are omitted for brevity.
  *
- * <p>See also <a href="https://android.googlesource.com/platform/external/conscrypt/+/master/src/main/java/org/conscrypt/NativeCrypto.java">NativeCrypto.java</a>
- * from conscrypt, which lists the cipher suites supported by Android.
+ * <p>See <a href="https://developer.android.com/reference/javax/net/ssl/SSLEngine.html">Android SSLEngine</a>
+ * which lists the cipher suites supported by Android.
+ *
+ * <p>See <a href="https://docs.oracle.com/javase/10/security/oracle-providers.htm">JDK 10 Providers</a>
+ * which lists the cipher suites supported by Oracle.
+ *
+ * <p>See <a href="https://github.com/google/conscrypt/blob/master/common/src/main/java/org/conscrypt/NativeCrypto.java">NativeCrypto.java</a>
+ * from conscrypt, which lists the cipher suites supported by Conscrypt.
  */
 public final class CipherSuite {
+  /**
+   * Compares cipher suites names like "TLS_RSA_WITH_NULL_MD5" and "SSL_RSA_WITH_NULL_MD5", ignoring
+   * the "TLS_" or "SSL_" prefix which is not consistent across platforms. In particular some IBM
+   * JVMs use the "SSL_" prefix everywhere whereas Oracle JVMs mix "TLS_" and "SSL_".
+   */
+  static final Comparator<String> ORDER_BY_NAME = new Comparator<String>() {
+    @Override public int compare(String a, String b) {
+      for (int i = 4, limit = Math.min(a.length(), b.length()); i < limit; i++) {
+        char charA = a.charAt(i);
+        char charB = b.charAt(i);
+        if (charA != charB) return charA < charB ? -1 : 1;
+      }
+      int lengthA = a.length();
+      int lengthB = b.length();
+      if (lengthA != lengthB) return lengthA < lengthB ? -1 : 1;
+      return 0;
+    }
+  };
+
   /**
    * Holds interned instances. This needs to be above the of() calls below so that it's
-   * initialized by the time those parts of {@code <clinit>()} run.
+   * initialized by the time those parts of {@code <clinit>()} run. Guarded by CipherSuite.class.
    */
-  private static final ConcurrentMap<String, CipherSuite> INSTANCES = new ConcurrentHashMap<>();
+  private static final Map<String, CipherSuite> INSTANCES = new TreeMap<>(ORDER_BY_NAME);
 
   // Last updated 2016-07-03 using cipher suites from Android 24 and Java 9.
 
@@ -360,28 +389,43 @@
   // public static final CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 = of("TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8", 0xc0af);
   public static final CipherSuite TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca8);
   public static final CipherSuite TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256", 0xcca9);
-  // public static final CipherSuite TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xccaa);
+  public static final CipherSuite TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256", 0xccaa);
   // public static final CipherSuite TLS_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccab);
-  // public static final CipherSuite TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccac);
+  public static final CipherSuite TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccac);
   // public static final CipherSuite TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccad);
   // public static final CipherSuite TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256 = of("TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256", 0xccae);
 
+  // TLS 1.3 https://tools.ietf.org/html/draft-ietf-tls-tls13-28
+  // Documentation only ids will be updated once assigned by IANA.
+  public static final CipherSuite TLS_AES_128_GCM_SHA256 = of("TLS_AES_128_GCM_SHA256", 0x1301);
+  public static final CipherSuite TLS_AES_256_GCM_SHA384 = of("TLS_AES_256_GCM_SHA384", 0x1302);
+  public static final CipherSuite TLS_CHACHA20_POLY1305_SHA256 = of("TLS_CHACHA20_POLY1305_SHA256", 0x1303);
+  public static final CipherSuite TLS_AES_128_CCM_SHA256 = of("TLS_AES_128_CCM_SHA256", 0x1304);
+  public static final CipherSuite TLS_AES_256_CCM_8_SHA256 = of("TLS_AES_256_CCM_8_SHA256", 0x1305);
+
   final String javaName;
 
   /**
    * @param javaName the name used by Java APIs for this cipher suite. Different than the IANA name
-   * for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
+   *     for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
    */
-  public static CipherSuite forJavaName(String javaName) {
+  public static synchronized CipherSuite forJavaName(String javaName) {
     CipherSuite result = INSTANCES.get(javaName);
     if (result == null) {
-      CipherSuite sample = new CipherSuite(javaName);
-      CipherSuite canonical = INSTANCES.putIfAbsent(javaName, sample);
-      result = (canonical == null) ? sample : canonical;
+      result = new CipherSuite(javaName);
+      INSTANCES.put(javaName, result);
     }
     return result;
   }
 
+  static List<CipherSuite> forJavaNames(String... cipherSuites) {
+    List<CipherSuite> result = new ArrayList<>(cipherSuites.length);
+    for (String cipherSuite : cipherSuites) {
+      result.add(forJavaName(cipherSuite));
+    }
+    return Collections.unmodifiableList(result);
+  }
+
   private CipherSuite(String javaName) {
     if (javaName == null) {
       throw new NullPointerException();
@@ -391,7 +435,7 @@ private CipherSuite(String javaName) {
 
   /**
    * @param javaName the name used by Java APIs for this cipher suite. Different than the IANA name
-   * for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
+   *     for older cipher suites because the prefix is {@code SSL_} instead of {@code TLS_}.
    * @param value the integer identifier for this cipher suite. (Documentation only.)
    */
   private static CipherSuite of(String javaName, int value) {
diff --git a/okhttp/src/main/java/okhttp3/Connection.java b/okhttp/src/main/java/okhttp3/Connection.java
index d07e861d8f..cb6d70996d 100644
--- a/okhttp/src/main/java/okhttp3/Connection.java
+++ b/okhttp/src/main/java/okhttp3/Connection.java
@@ -17,6 +17,7 @@
 package okhttp3;
 
 import java.net.Socket;
+import javax.annotation.Nullable;
 
 /**
  * The sockets and streams of an HTTP, HTTPS, or HTTPS+HTTP/2 connection. May be used for multiple
@@ -47,11 +48,11 @@
  *
  * <h3>Connection Reuse</h3>
  *
- * <p>Each connection can carry a varying number streams, depending on the underlying protocol being
- * used. HTTP/1.x connections can carry either zero or one streams. HTTP/2 connections can carry any
- * number of streams, dynamically configured with {@code SETTINGS_MAX_CONCURRENT_STREAMS}. A
- * connection currently carrying zero streams is an idle stream. We keep it alive because reusing an
- * existing connection is typically faster than establishing a new one.
+ * <p>Each connection can carry a varying number of streams, depending on the underlying protocol
+ * being used. HTTP/1.x connections can carry either zero or one streams. HTTP/2 connections can
+ * carry any number of streams, dynamically configured with {@code SETTINGS_MAX_CONCURRENT_STREAMS}.
+ * A connection currently carrying zero streams is an idle stream. We keep it alive because reusing
+ * an existing connection is typically faster than establishing a new one.
  *
  * <p>When a single logical call requires multiple streams due to redirects or authorization
  * challenges, we prefer to use the same physical connection for all streams in the sequence. There
@@ -82,7 +83,7 @@
    * Returns the TLS handshake used to establish this connection, or null if the connection is not
    * HTTPS.
    */
-  Handshake handshake();
+  @Nullable Handshake handshake();
 
   /**
    * Returns the protocol negotiated by this connection, or {@link Protocol#HTTP_1_1} if no protocol
diff --git a/okhttp/src/main/java/okhttp3/ConnectionPool.java b/okhttp/src/main/java/okhttp3/ConnectionPool.java
index f07db53a90..605f275661 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionPool.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionPool.java
@@ -16,8 +16,8 @@
  */
 package okhttp3;
 
-import java.io.Closeable;
 import java.lang.ref.Reference;
+import java.net.Socket;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Deque;
@@ -27,6 +27,7 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.RouteDatabase;
@@ -114,12 +115,15 @@ public synchronized int connectionCount() {
     return connections.size();
   }
 
-  /** Returns a recycled connection to {@code address}, or null if no such connection exists. */
-  RealConnection get(Address address, StreamAllocation streamAllocation) {
+  /**
+   * Returns a recycled connection to {@code address}, or null if no such connection exists. The
+   * route is null if the address has not yet been routed.
+   */
+  @Nullable RealConnection get(Address address, StreamAllocation streamAllocation, Route route) {
     assert (Thread.holdsLock(this));
     for (RealConnection connection : connections) {
-      if (connection.isEligible(address)) {
-        streamAllocation.acquire(connection);
+      if (connection.isEligible(address, route)) {
+        streamAllocation.acquire(connection, true);
         return connection;
       }
     }
@@ -130,10 +134,10 @@ RealConnection get(Address address, StreamAllocation streamAllocation) {
    * Replaces the connection held by {@code streamAllocation} with a shared connection if possible.
    * This recovers when multiple multiplexed connections are created concurrently.
    */
-  Closeable deduplicate(Address address, StreamAllocation streamAllocation) {
+  @Nullable Socket deduplicate(Address address, StreamAllocation streamAllocation) {
     assert (Thread.holdsLock(this));
     for (RealConnection connection : connections) {
-      if (connection.isEligible(address)
+      if (connection.isEligible(address, null)
           && connection.isMultiplexed()
           && connection != streamAllocation.connection()) {
         return streamAllocation.releaseAndAcquire(connection);
diff --git a/okhttp/src/main/java/okhttp3/ConnectionSpec.java b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
index 11fd12c3ea..e5352e4567 100644
--- a/okhttp/src/main/java/okhttp3/ConnectionSpec.java
+++ b/okhttp/src/main/java/okhttp3/ConnectionSpec.java
@@ -15,15 +15,16 @@
  */
 package okhttp3;
 
-import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.List;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLSocket;
+import okhttp3.internal.Util;
 
 import static okhttp3.internal.Util.concat;
 import static okhttp3.internal.Util.indexOf;
 import static okhttp3.internal.Util.intersect;
+import static okhttp3.internal.Util.nonEmptyIntersection;
 
 /**
  * Specifies configuration for the socket connection that HTTP traffic travels through. For {@code
@@ -39,6 +40,25 @@
  */
 public final class ConnectionSpec {
 
+  // Most secure but generally supported list.
+  private static final CipherSuite[] RESTRICTED_CIPHER_SUITES = new CipherSuite[] {
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+      CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+      CipherSuite.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256,
+      CipherSuite.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
+  };
+
+  // TLS 1.3
+  private static final CipherSuite[] TLS13_CIPHER_SUITES = new CipherSuite[] {
+      CipherSuite.TLS_AES_128_GCM_SHA256,
+      CipherSuite.TLS_AES_256_GCM_SHA384,
+      CipherSuite.TLS_CHACHA20_POLY1305_SHA256,
+      CipherSuite.TLS_AES_128_CCM_SHA256,
+      CipherSuite.TLS_AES_256_CCM_8_SHA256
+  };
+
   // This is nearly equal to the cipher suites supported in Chrome 51, current as of 2016-05-25.
   // All of these suites are available on Android 7.0; earlier releases support a subset of these
   // suites. https://github.com/square/okhttp/issues/1972
@@ -53,9 +73,7 @@
       // Note that the following cipher suites are all on HTTP/2's bad cipher suites list. We'll
       // continue to include them until better suites are commonly available. For example, none
       // of the better cipher suites listed above shipped with Android 4.4 or Java 7.
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA,
       CipherSuite.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
-      CipherSuite.TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA,
       CipherSuite.TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,
       CipherSuite.TLS_RSA_WITH_AES_128_GCM_SHA256,
       CipherSuite.TLS_RSA_WITH_AES_256_GCM_SHA384,
@@ -64,10 +82,28 @@
       CipherSuite.TLS_RSA_WITH_3DES_EDE_CBC_SHA,
   };
 
+  /**
+   * A TLS 1.3 only Connection Spec for testing. This will be eventually be exposed
+   * as part of MODERN_TLS or folded into the default OkHttp client once published and
+   * available in JDK11.
+   */
+  static final ConnectionSpec TLS_13 = new Builder(true)
+      .cipherSuites(TLS13_CIPHER_SUITES)
+      .tlsVersions(TlsVersion.TLS_1_3)
+      .supportsTlsExtensions(true)
+      .build();
+
+  /** A secure TLS connection assuming a modern client platform and server. */
+  public static final ConnectionSpec RESTRICTED_TLS = new Builder(true)
+      .cipherSuites(RESTRICTED_CIPHER_SUITES)
+      .tlsVersions(TlsVersion.TLS_1_2)
+      .supportsTlsExtensions(true)
+      .build();
+
   /** A modern TLS connection with extensions like SNI and ALPN available. */
   public static final ConnectionSpec MODERN_TLS = new Builder(true)
       .cipherSuites(APPROVED_CIPHER_SUITES)
-      .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
+      .tlsVersions(TlsVersion.TLS_1_2, TlsVersion.TLS_1_1, TlsVersion.TLS_1_0)
       .supportsTlsExtensions(true)
       .build();
 
@@ -82,8 +118,8 @@
 
   final boolean tls;
   final boolean supportsTlsExtensions;
-  final String[] cipherSuites;
-  final String[] tlsVersions;
+  final @Nullable String[] cipherSuites;
+  final @Nullable String[] tlsVersions;
 
   ConnectionSpec(Builder builder) {
     this.tls = builder.tls;
@@ -97,31 +133,19 @@ public boolean isTls() {
   }
 
   /**
-   * Returns the cipher suites to use for a connection. Returns {@code null} if all of the SSL
-   * socket's enabled cipher suites should be used.
+   * Returns the cipher suites to use for a connection. Returns null if all of the SSL socket's
+   * enabled cipher suites should be used.
    */
-  public List<CipherSuite> cipherSuites() {
-    if (cipherSuites == null) return null;
-
-    List<CipherSuite> result = new ArrayList<>(cipherSuites.length);
-    for (String cipherSuite : cipherSuites) {
-      result.add(CipherSuite.forJavaName(cipherSuite));
-    }
-    return Collections.unmodifiableList(result);
+  public @Nullable List<CipherSuite> cipherSuites() {
+    return cipherSuites != null ? CipherSuite.forJavaNames(cipherSuites) : null;
   }
 
   /**
-   * Returns the TLS versions to use when negotiating a connection. Returns {@code null} if all of
-   * the SSL socket's enabled TLS versions should be used.
+   * Returns the TLS versions to use when negotiating a connection. Returns null if all of the SSL
+   * socket's enabled TLS versions should be used.
    */
-  public List<TlsVersion> tlsVersions() {
-    if (tlsVersions == null) return null;
-
-    List<TlsVersion> result = new ArrayList<>(tlsVersions.length);
-    for (String tlsVersion : tlsVersions) {
-      result.add(TlsVersion.forJavaName(tlsVersion));
-    }
-    return Collections.unmodifiableList(result);
+  public @Nullable List<TlsVersion> tlsVersions() {
+    return tlsVersions != null ? TlsVersion.forJavaNames(tlsVersions) : null;
   }
 
   public boolean supportsTlsExtensions() {
@@ -146,16 +170,20 @@ void apply(SSLSocket sslSocket, boolean isFallback) {
    */
   private ConnectionSpec supportedSpec(SSLSocket sslSocket, boolean isFallback) {
     String[] cipherSuitesIntersection = cipherSuites != null
-        ? intersect(String.class, cipherSuites, sslSocket.getEnabledCipherSuites())
+        ? intersect(CipherSuite.ORDER_BY_NAME, sslSocket.getEnabledCipherSuites(), cipherSuites)
         : sslSocket.getEnabledCipherSuites();
     String[] tlsVersionsIntersection = tlsVersions != null
-        ? intersect(String.class, tlsVersions, sslSocket.getEnabledProtocols())
+        ? intersect(Util.NATURAL_ORDER, sslSocket.getEnabledProtocols(), tlsVersions)
         : sslSocket.getEnabledProtocols();
 
     // In accordance with https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00
     // the SCSV cipher is added to signal that a protocol fallback has taken place.
-    if (isFallback && indexOf(sslSocket.getSupportedCipherSuites(), "TLS_FALLBACK_SCSV") != -1) {
-      cipherSuitesIntersection = concat(cipherSuitesIntersection, "TLS_FALLBACK_SCSV");
+    String[] supportedCipherSuites = sslSocket.getSupportedCipherSuites();
+    int indexOfFallbackScsv = indexOf(
+        CipherSuite.ORDER_BY_NAME, supportedCipherSuites, "TLS_FALLBACK_SCSV");
+    if (isFallback && indexOfFallbackScsv != -1) {
+      cipherSuitesIntersection = concat(
+          cipherSuitesIntersection, supportedCipherSuites[indexOfFallbackScsv]);
     }
 
     return new Builder(this)
@@ -180,37 +208,20 @@ public boolean isCompatible(SSLSocket socket) {
       return false;
     }
 
-    if (tlsVersions != null
-        && !nonEmptyIntersection(tlsVersions, socket.getEnabledProtocols())) {
+    if (tlsVersions != null && !nonEmptyIntersection(
+        Util.NATURAL_ORDER, tlsVersions, socket.getEnabledProtocols())) {
       return false;
     }
 
-    if (cipherSuites != null
-        && !nonEmptyIntersection(cipherSuites, socket.getEnabledCipherSuites())) {
+    if (cipherSuites != null && !nonEmptyIntersection(
+        CipherSuite.ORDER_BY_NAME, cipherSuites, socket.getEnabledCipherSuites())) {
       return false;
     }
 
     return true;
   }
 
-  /**
-   * An N*M intersection that terminates if any intersection is found. The sizes of both arguments
-   * are assumed to be so small, and the likelihood of an intersection so great, that it is not
-   * worth the CPU cost of sorting or the memory cost of hashing.
-   */
-  private static boolean nonEmptyIntersection(String[] a, String[] b) {
-    if (a == null || b == null || a.length == 0 || b.length == 0) {
-      return false;
-    }
-    for (String toFind : a) {
-      if (indexOf(b, toFind) != -1) {
-        return true;
-      }
-    }
-    return false;
-  }
-
-  @Override public boolean equals(Object other) {
+  @Override public boolean equals(@Nullable Object other) {
     if (!(other instanceof ConnectionSpec)) return false;
     if (other == this) return true;
 
@@ -252,8 +263,8 @@ private static boolean nonEmptyIntersection(String[] a, String[] b) {
 
   public static final class Builder {
     boolean tls;
-    String[] cipherSuites;
-    String[] tlsVersions;
+    @Nullable String[] cipherSuites;
+    @Nullable String[] tlsVersions;
     boolean supportsTlsExtensions;
 
     Builder(boolean tls) {
diff --git a/okhttp/src/main/java/okhttp3/Cookie.java b/okhttp/src/main/java/okhttp3/Cookie.java
index 5b760b5191..fbfa99c26d 100644
--- a/okhttp/src/main/java/okhttp3/Cookie.java
+++ b/okhttp/src/main/java/okhttp3/Cookie.java
@@ -24,12 +24,14 @@
 import java.util.Locale;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpDate;
+import okhttp3.internal.publicsuffix.PublicSuffixDatabase;
 
 import static okhttp3.internal.Util.UTC;
+import static okhttp3.internal.Util.canonicalizeHost;
 import static okhttp3.internal.Util.delimiterOffset;
-import static okhttp3.internal.Util.domainToAscii;
 import static okhttp3.internal.Util.indexOfControlOrNonAscii;
 import static okhttp3.internal.Util.trimSubstring;
 import static okhttp3.internal.Util.verifyAsIpAddress;
@@ -170,7 +172,7 @@ public boolean secure() {
   public boolean matches(HttpUrl url) {
     boolean domainMatch = hostOnly
         ? url.host().equals(domain)
-        : domainMatch(url, domain);
+        : domainMatch(url.host(), domain);
     if (!domainMatch) return false;
 
     if (!pathMatch(url, path)) return false;
@@ -180,9 +182,7 @@ public boolean matches(HttpUrl url) {
     return true;
   }
 
-  private static boolean domainMatch(HttpUrl url, String domain) {
-    String urlHost = url.host();
-
+  private static boolean domainMatch(String urlHost, String domain) {
     if (urlHost.equals(domain)) {
       return true; // As in 'example.com' matching 'example.com'.
     }
@@ -215,11 +215,11 @@ private static boolean pathMatch(HttpUrl url, String path) {
    * Attempt to parse a {@code Set-Cookie} HTTP header value {@code setCookie} as a cookie. Returns
    * null if {@code setCookie} is not a well-formed cookie.
    */
-  public static Cookie parse(HttpUrl url, String setCookie) {
+  public static @Nullable Cookie parse(HttpUrl url, String setCookie) {
     return parse(System.currentTimeMillis(), url, setCookie);
   }
 
-  static Cookie parse(long currentTimeMillis, HttpUrl url, String setCookie) {
+  static @Nullable Cookie parse(long currentTimeMillis, HttpUrl url, String setCookie) {
     int pos = 0;
     int limit = setCookie.length();
     int cookiePairEnd = delimiterOffset(setCookie, pos, limit, ';');
@@ -299,12 +299,19 @@ static Cookie parse(long currentTimeMillis, HttpUrl url, String setCookie) {
     }
 
     // If the domain is present, it must domain match. Otherwise we have a host-only cookie.
+    String urlHost = url.host();
     if (domain == null) {
-      domain = url.host();
-    } else if (!domainMatch(url, domain)) {
+      domain = urlHost;
+    } else if (!domainMatch(urlHost, domain)) {
       return null; // No domain match? This is either incompetence or malice!
     }
 
+    // If the domain is a suffix of the url host, it must not be a public suffix.
+    if (urlHost.length() != domain.length()
+        && PublicSuffixDatabase.get().getEffectiveTldPlusOne(domain) == null) {
+      return null;
+    }
+
     // If the path is absent or didn't start with '/', use the default path. It's a string like
     // '/foo/bar' for a URL like 'http://example.com/foo/bar/baz'. It always starts with '/'.
     if (path == null || !path.startsWith("/")) {
@@ -422,7 +429,7 @@ private static String parseDomain(String s) {
     if (s.startsWith(".")) {
       s = s.substring(1);
     }
-    String canonicalDomain = domainToAscii(s);
+    String canonicalDomain = canonicalizeHost(s);
     if (canonicalDomain == null) {
       throw new IllegalArgumentException();
     }
@@ -501,7 +508,7 @@ public Builder hostOnlyDomain(String domain) {
 
     private Builder domain(String domain, boolean hostOnly) {
       if (domain == null) throw new NullPointerException("domain == null");
-      String canonicalDomain = Util.domainToAscii(domain);
+      String canonicalDomain = Util.canonicalizeHost(domain);
       if (canonicalDomain == null) {
         throw new IllegalArgumentException("unexpected domain: " + domain);
       }
@@ -575,7 +582,7 @@ String toString(boolean forObsoleteRfc2965) {
     return result.toString();
   }
 
-  @Override public boolean equals(Object other) {
+  @Override public boolean equals(@Nullable Object other) {
     if (!(other instanceof Cookie)) return false;
     Cookie that = (Cookie) other;
     return that.name.equals(name)
diff --git a/okhttp/src/main/java/okhttp3/CookieJar.java b/okhttp/src/main/java/okhttp3/CookieJar.java
index d2cdfce22a..bdb3cd552e 100644
--- a/okhttp/src/main/java/okhttp3/CookieJar.java
+++ b/okhttp/src/main/java/okhttp3/CookieJar.java
@@ -22,7 +22,7 @@
  * Provides <strong>policy</strong> and <strong>persistence</strong> for HTTP cookies.
  *
  * <p>As policy, implementations of this interface are responsible for selecting which cookies to
- * accept and which to reject. A reasonable policy is to reject all cookies, though that may be
+ * accept and which to reject. A reasonable policy is to reject all cookies, though that may
  * interfere with session-based authentication schemes that require cookies.
  *
  * <p>As persistence, implementations of this interface must also provide storage of cookies. Simple
diff --git a/okhttp/src/main/java/okhttp3/Credentials.java b/okhttp/src/main/java/okhttp3/Credentials.java
index 9be4e6a22f..530863e4a8 100644
--- a/okhttp/src/main/java/okhttp3/Credentials.java
+++ b/okhttp/src/main/java/okhttp3/Credentials.java
@@ -15,23 +15,24 @@
  */
 package okhttp3;
 
-import java.io.UnsupportedEncodingException;
+import java.nio.charset.Charset;
 import okio.ByteString;
 
+import static okhttp3.internal.Util.ISO_8859_1;
+
 /** Factory for HTTP authorization credentials. */
 public final class Credentials {
   private Credentials() {
   }
 
   /** Returns an auth credential for the Basic scheme. */
-  public static String basic(String userName, String password) {
-    try {
-      String usernameAndPassword = userName + ":" + password;
-      byte[] bytes = usernameAndPassword.getBytes("ISO-8859-1");
-      String encoded = ByteString.of(bytes).base64();
-      return "Basic " + encoded;
-    } catch (UnsupportedEncodingException e) {
-      throw new AssertionError();
-    }
+  public static String basic(String username, String password) {
+    return basic(username, password, ISO_8859_1);
+  }
+
+  public static String basic(String username, String password, Charset charset) {
+    String usernameAndPassword = username + ":" + password;
+    String encoded = ByteString.encodeString(usernameAndPassword, charset).base64();
+    return "Basic " + encoded;
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Dispatcher.java b/okhttp/src/main/java/okhttp3/Dispatcher.java
index d6f90bb3ac..21013bda11 100644
--- a/okhttp/src/main/java/okhttp3/Dispatcher.java
+++ b/okhttp/src/main/java/okhttp3/Dispatcher.java
@@ -25,6 +25,7 @@
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 import okhttp3.RealCall.AsyncCall;
 import okhttp3.internal.Util;
 
@@ -38,10 +39,10 @@
 public final class Dispatcher {
   private int maxRequests = 64;
   private int maxRequestsPerHost = 5;
-  private Runnable idleCallback;
+  private @Nullable Runnable idleCallback;
 
   /** Executes calls. Created lazily. */
-  private ExecutorService executorService;
+  private @Nullable ExecutorService executorService;
 
   /** Ready async calls in the order they'll be run. */
   private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();
@@ -94,6 +95,8 @@ public synchronized int getMaxRequests() {
    *
    * <p>If more than {@code maxRequestsPerHost} requests are in flight when this is invoked, those
    * requests will remain in flight.
+   *
+   * <p>WebSocket connections to hosts <b>do not</b> count against this limit.
    */
   public synchronized void setMaxRequestsPerHost(int maxRequestsPerHost) {
     if (maxRequestsPerHost < 1) {
@@ -119,7 +122,7 @@ public synchronized int getMaxRequestsPerHost() {
    * means that if you are doing synchronous calls the network layer will not truly be idle until
    * every returned {@link Response} has been closed.
    */
-  public synchronized void setIdleCallback(Runnable idleCallback) {
+  public synchronized void setIdleCallback(@Nullable Runnable idleCallback) {
     this.idleCallback = idleCallback;
   }
 
@@ -171,6 +174,7 @@ private void promoteCalls() {
   private int runningCallsForHost(AsyncCall call) {
     int result = 0;
     for (AsyncCall c : runningAsyncCalls) {
+      if (c.get().forWebSocket) continue;
       if (c.host().equals(call.host())) result++;
     }
     return result;
diff --git a/okhttp/src/main/java/okhttp3/Dns.java b/okhttp/src/main/java/okhttp3/Dns.java
index a2e6db591c..de3b4cb215 100644
--- a/okhttp/src/main/java/okhttp3/Dns.java
+++ b/okhttp/src/main/java/okhttp3/Dns.java
@@ -36,7 +36,14 @@
   Dns SYSTEM = new Dns() {
     @Override public List<InetAddress> lookup(String hostname) throws UnknownHostException {
       if (hostname == null) throw new UnknownHostException("hostname == null");
-      return Arrays.asList(InetAddress.getAllByName(hostname));
+      try {
+        return Arrays.asList(InetAddress.getAllByName(hostname));
+      } catch (NullPointerException e) {
+        UnknownHostException unknownHostException =
+            new UnknownHostException("Broken system behaviour for dns lookup of " + hostname);
+        unknownHostException.initCause(e);
+        throw unknownHostException;
+      }
     }
   };
 
diff --git a/okhttp/src/main/java/okhttp3/EventListener.java b/okhttp/src/main/java/okhttp3/EventListener.java
new file mode 100644
index 0000000000..fb8d4c7f4a
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/EventListener.java
@@ -0,0 +1,293 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.util.List;
+import javax.annotation.Nullable;
+
+/**
+ * Listener for metrics events. Extend this class to monitor the quantity, size, and duration of
+ * your application's HTTP calls.
+ *
+ * <p>All start/connect/acquire events will eventually receive a matching end/release event,
+ * either successful (non-null parameters), or failed (non-null throwable).  The first common
+ * parameters of each event pair are used to link the event in case of concurrent or repeated
+ * events e.g. dnsStart(call, domainName) -&gt; dnsEnd(call, domainName, inetAddressList).
+ *
+ * <p>Nesting is as follows
+ * <ul>
+ *   <li>call -&gt; (dns -&gt; connect -&gt; secure connect)* -&gt; request events</li>
+ *   <li>call -&gt; (connection acquire/release)*</li>
+ * </ul>
+ *
+ * <p>Request events are ordered:
+ * requestHeaders -&gt; requestBody -&gt; responseHeaders -&gt; responseBody
+ *
+ * <p>Since connections may be reused, the dns and connect events may not be present for a call,
+ * or may be repeated in case of failure retries, even concurrently in case of happy eyeballs type
+ * scenarios. A redirect cross domain, or to use https may cause additional connection and request
+ * events.
+ *
+ * <p>All event methods must execute fast, without external locking, cannot throw exceptions,
+ * attempt to mutate the event parameters, or be reentrant back into the client.
+ * Any IO - writing to files or network should be done asynchronously.
+ */
+public abstract class EventListener {
+  public static final EventListener NONE = new EventListener() {
+  };
+
+  static EventListener.Factory factory(final EventListener listener) {
+    return new EventListener.Factory() {
+      public EventListener create(Call call) {
+        return listener;
+      }
+    };
+  }
+
+  /**
+   * Invoked as soon as a call is enqueued or executed by a client. In case of thread or stream
+   * limits, this call may be executed well before processing the request is able to begin.
+   *
+   * <p>This will be invoked only once for a single {@link Call}. Retries of different routes
+   * or redirects will be handled within the boundaries of a single callStart and {@link
+   * #callEnd}/{@link #callFailed} pair.
+   */
+  public void callStart(Call call) {
+  }
+
+  /**
+   * Invoked just prior to a DNS lookup. See {@link Dns#lookup(String)}.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different host.
+   *
+   * <p>If the {@link Call} is able to reuse an existing pooled connection, this method will not be
+   * invoked. See {@link ConnectionPool}.
+   */
+  public void dnsStart(Call call, String domainName) {
+  }
+
+  /**
+   * Invoked immediately after a DNS lookup.
+   *
+   * <p>This method is invoked after {@link #dnsStart}.
+   */
+  public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
+  }
+
+  /**
+   * Invoked just prior to initiating a socket connection.
+   *
+   * <p>This method will be invoked if no existing connection in the {@link ConnectionPool} can be
+   * reused.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address, or a connection is retried.
+   */
+  public void connectStart(Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
+  }
+
+  /**
+   * Invoked just prior to initiating a TLS connection.
+   *
+   * <p>This method is invoked if the following conditions are met:
+   * <ul>
+   * <li>The {@link Call#request()} requires TLS.</li>
+   * <li>No existing connection from the {@link ConnectionPool} can be reused.</li>
+   * </ul>
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address, or a connection is retried.
+   */
+  public void secureConnectStart(Call call) {
+  }
+
+  /**
+   * Invoked immediately after a TLS connection was attempted.
+   *
+   * <p>This method is invoked after {@link #secureConnectStart}.
+   */
+  public void secureConnectEnd(Call call, @Nullable Handshake handshake) {
+  }
+
+  /**
+   * Invoked immediately after a socket connection was attempted.
+   *
+   * <p>If the {@code call} uses HTTPS, this will be invoked after
+   * {@link #secureConnectEnd(Call, Handshake)}, otherwise it will invoked after
+   * {@link #connectStart(Call, InetSocketAddress, Proxy)}.
+   */
+  public void connectEnd(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,
+      @Nullable Protocol protocol) {
+  }
+
+  /**
+   * Invoked when a connection attempt fails. This failure is not terminal if further routes are
+   * available and failure recovery is enabled.
+   *
+   * <p>If the {@code call} uses HTTPS, this will be invoked after {@link #secureConnectEnd(Call,
+   * Handshake)}, otherwise it will invoked after {@link #connectStart(Call, InetSocketAddress,
+   * Proxy)}.
+   */
+  public void connectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,
+      @Nullable Protocol protocol, IOException ioe) {
+  }
+
+  /**
+   * Invoked after a connection has been acquired for the {@code call}.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address.
+   */
+  public void connectionAcquired(Call call, Connection connection) {
+  }
+
+  /**
+   * Invoked after a connection has been released for the {@code call}.
+   *
+   * <p>This method is always invoked after {@link #connectionAcquired(Call, Connection)}.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address.
+   */
+  public void connectionReleased(Call call, Connection connection) {
+  }
+
+  /**
+   * Invoked just prior to sending request headers.
+   *
+   * <p>The connection is implicit, and will generally relate to the last
+   * {@link #connectionAcquired(Call, Connection)} event.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address.
+   */
+  public void requestHeadersStart(Call call) {
+  }
+
+  /**
+   * Invoked immediately after sending request headers.
+   *
+   * <p>This method is always invoked after {@link #requestHeadersStart(Call)}.
+   *
+   * @param request the request sent over the network. It is an error to access the body of this
+   *     request.
+   */
+  public void requestHeadersEnd(Call call, Request request) {
+  }
+
+  /**
+   * Invoked just prior to sending a request body.  Will only be invoked for request allowing and
+   * having a request body to send.
+   *
+   * <p>The connection is implicit, and will generally relate to the last
+   * {@link #connectionAcquired(Call, Connection)} event.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address.
+   */
+  public void requestBodyStart(Call call) {
+  }
+
+  /**
+   * Invoked immediately after sending a request body.
+   *
+   * <p>This method is always invoked after {@link #requestBodyStart(Call)}.
+   */
+  public void requestBodyEnd(Call call, long byteCount) {
+  }
+
+  /**
+   * Invoked just prior to receiving response headers.
+   *
+   * <p>The connection is implicit, and will generally relate to the last
+   * {@link #connectionAcquired(Call, Connection)} event.
+   *
+   * <p>This can be invoked more than 1 time for a single {@link Call}. For example, if the response
+   * to the {@link Call#request()} is a redirect to a different address.
+   */
+  public void responseHeadersStart(Call call) {
+  }
+
+  /**
+   * Invoked immediately after receiving response headers.
+   *
+   * <p>This method is always invoked after {@link #responseHeadersStart}.
+   *
+   * @param response the response received over the network. It is an error to access the body of
+   *     this response.
+   */
+  public void responseHeadersEnd(Call call, Response response) {
+  }
+
+  /**
+   * Invoked just prior to receiving the response body.
+   *
+   * <p>The connection is implicit, and will generally relate to the last
+   * {@link #connectionAcquired(Call, Connection)} event.
+   *
+   * <p>This will usually be invoked only 1 time for a single {@link Call},
+   * exceptions are a limited set of cases including failure recovery.
+   */
+  public void responseBodyStart(Call call) {
+  }
+
+  /**
+   * Invoked immediately after receiving a response body and completing reading it.
+   *
+   * <p>Will only be invoked for requests having a response body e.g. won't be invoked for a
+   * websocket upgrade.
+   *
+   * <p>This method is always invoked after {@link #requestBodyStart(Call)}.
+   */
+  public void responseBodyEnd(Call call, long byteCount) {
+  }
+
+  /**
+   * Invoked immediately after a call has completely ended.  This includes delayed consumption
+   * of response body by the caller.
+   *
+   * <p>This method is always invoked after {@link #callStart(Call)}.
+   */
+  public void callEnd(Call call) {
+  }
+
+  /**
+   * Invoked when a call fails permanently.
+   *
+   * <p>This method is always invoked after {@link #callStart(Call)}.
+   */
+  public void callFailed(Call call, IOException ioe) {
+  }
+
+  public interface Factory {
+    /**
+     * Creates an instance of the {@link EventListener} for a particular {@link Call}. The returned
+     * {@link EventListener} instance will be used during the lifecycle of the {@code call}.
+     *
+     * <p>This method is invoked after the {@code call} is created. See
+     * {@link OkHttpClient#newCall(Request)}.
+     *
+     * <p><strong>It is an error for implementations to issue any mutating operations on the
+     * {@code call} instance from this method.</strong>
+     */
+    EventListener create(Call call);
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/FormBody.java b/okhttp/src/main/java/okhttp3/FormBody.java
index 87ebb49f81..d3937834c3 100644
--- a/okhttp/src/main/java/okhttp3/FormBody.java
+++ b/okhttp/src/main/java/okhttp3/FormBody.java
@@ -16,8 +16,10 @@
 package okhttp3;
 
 import java.io.IOException;
+import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.List;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSink;
@@ -26,8 +28,7 @@
 import static okhttp3.HttpUrl.percentDecode;
 
 public final class FormBody extends RequestBody {
-  private static final MediaType CONTENT_TYPE =
-      MediaType.parse("application/x-www-form-urlencoded");
+  private static final MediaType CONTENT_TYPE = MediaType.get("application/x-www-form-urlencoded");
 
   private final List<String> encodedNames;
   private final List<String> encodedValues;
@@ -76,7 +77,7 @@ public String value(int index) {
    * to awkward operations like measuring the encoded length of header strings, or the
    * length-in-digits of an encoded integer.
    */
-  private long writeOrCountBytes(BufferedSink sink, boolean countBytes) {
+  private long writeOrCountBytes(@Nullable BufferedSink sink, boolean countBytes) {
     long byteCount = 0L;
 
     Buffer buffer;
@@ -104,16 +105,31 @@ private long writeOrCountBytes(BufferedSink sink, boolean countBytes) {
   public static final class Builder {
     private final List<String> names = new ArrayList<>();
     private final List<String> values = new ArrayList<>();
+    private final Charset charset;
+
+    public Builder() {
+      this(null);
+    }
+
+    public Builder(Charset charset) {
+      this.charset = charset;
+    }
 
     public Builder add(String name, String value) {
-      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, false, false, true, true));
-      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, false, false, true, true));
+      if (name == null) throw new NullPointerException("name == null");
+      if (value == null) throw new NullPointerException("value == null");
+
+      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, false, false, true, true, charset));
+      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, false, false, true, true, charset));
       return this;
     }
 
     public Builder addEncoded(String name, String value) {
-      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, true, false, true, true));
-      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, true, false, true, true));
+      if (name == null) throw new NullPointerException("name == null");
+      if (value == null) throw new NullPointerException("value == null");
+
+      names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, true, false, true, true, charset));
+      values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, true, false, true, true, charset));
       return this;
     }
 
diff --git a/okhttp/src/main/java/okhttp3/Handshake.java b/okhttp/src/main/java/okhttp3/Handshake.java
index d2c08be57e..fefe3a5728 100644
--- a/okhttp/src/main/java/okhttp3/Handshake.java
+++ b/okhttp/src/main/java/okhttp3/Handshake.java
@@ -15,11 +15,13 @@
  */
 package okhttp3;
 
+import java.io.IOException;
 import java.security.Principal;
 import java.security.cert.Certificate;
 import java.security.cert.X509Certificate;
 import java.util.Collections;
 import java.util.List;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSession;
 import okhttp3.internal.Util;
@@ -45,13 +47,17 @@ private Handshake(TlsVersion tlsVersion, CipherSuite cipherSuite,
     this.localCertificates = localCertificates;
   }
 
-  public static Handshake get(SSLSession session) {
+  public static Handshake get(SSLSession session) throws IOException {
     String cipherSuiteString = session.getCipherSuite();
     if (cipherSuiteString == null) throw new IllegalStateException("cipherSuite == null");
+    if ("SSL_NULL_WITH_NULL_NULL".equals(cipherSuiteString)) {
+      throw new IOException("cipherSuite == SSL_NULL_WITH_NULL_NULL");
+    }
     CipherSuite cipherSuite = CipherSuite.forJavaName(cipherSuiteString);
 
     String tlsVersionString = session.getProtocol();
     if (tlsVersionString == null) throw new IllegalStateException("tlsVersion == null");
+    if ("NONE".equals(tlsVersionString)) throw new IOException("tlsVersion == NONE");
     TlsVersion tlsVersion = TlsVersion.forJavaName(tlsVersionString);
 
     Certificate[] peerCertificates;
@@ -74,14 +80,15 @@ public static Handshake get(SSLSession session) {
 
   public static Handshake get(TlsVersion tlsVersion, CipherSuite cipherSuite,
       List<Certificate> peerCertificates, List<Certificate> localCertificates) {
+    if (tlsVersion == null) throw new NullPointerException("tlsVersion == null");
     if (cipherSuite == null) throw new NullPointerException("cipherSuite == null");
     return new Handshake(tlsVersion, cipherSuite, Util.immutableList(peerCertificates),
         Util.immutableList(localCertificates));
   }
 
   /**
-   * Returns the TLS version used for this connection. May return null if the response was cached
-   * with a version of OkHttp prior to 3.0.
+   * Returns the TLS version used for this connection. This value wasn't tracked prior to OkHttp
+   * 3.0. For responses cached by preceding versions this returns {@link TlsVersion#SSL_3_0}.
    */
   public TlsVersion tlsVersion() {
     return tlsVersion;
@@ -98,7 +105,7 @@ public CipherSuite cipherSuite() {
   }
 
   /** Returns the remote peer's principle, or null if that peer is anonymous. */
-  public Principal peerPrincipal() {
+  public @Nullable Principal peerPrincipal() {
     return !peerCertificates.isEmpty()
         ? ((X509Certificate) peerCertificates.get(0)).getSubjectX500Principal()
         : null;
@@ -110,16 +117,16 @@ public Principal peerPrincipal() {
   }
 
   /** Returns the local principle, or null if this peer is anonymous. */
-  public Principal localPrincipal() {
+  public @Nullable Principal localPrincipal() {
     return !localCertificates.isEmpty()
         ? ((X509Certificate) localCertificates.get(0)).getSubjectX500Principal()
         : null;
   }
 
-  @Override public boolean equals(Object other) {
+  @Override public boolean equals(@Nullable Object other) {
     if (!(other instanceof Handshake)) return false;
     Handshake that = (Handshake) other;
-    return Util.equal(cipherSuite, that.cipherSuite)
+    return tlsVersion.equals(that.tlsVersion)
         && cipherSuite.equals(that.cipherSuite)
         && peerCertificates.equals(that.peerCertificates)
         && localCertificates.equals(that.localCertificates);
@@ -127,7 +134,7 @@ public Principal localPrincipal() {
 
   @Override public int hashCode() {
     int result = 17;
-    result = 31 * result + (tlsVersion != null ? tlsVersion.hashCode() : 0);
+    result = 31 * result + tlsVersion.hashCode();
     result = 31 * result + cipherSuite.hashCode();
     result = 31 * result + peerCertificates.hashCode();
     result = 31 * result + localCertificates.hashCode();
diff --git a/okhttp/src/main/java/okhttp3/Headers.java b/okhttp/src/main/java/okhttp3/Headers.java
index fb007a0a19..e8a0def658 100644
--- a/okhttp/src/main/java/okhttp3/Headers.java
+++ b/okhttp/src/main/java/okhttp3/Headers.java
@@ -27,6 +27,7 @@
 import java.util.Set;
 import java.util.TreeMap;
 import java.util.TreeSet;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpDate;
 
@@ -58,7 +59,7 @@ private Headers(String[] namesAndValues) {
   }
 
   /** Returns the last value corresponding to the specified field, or null. */
-  public String get(String name) {
+  public @Nullable String get(String name) {
     return get(namesAndValues, name);
   }
 
@@ -66,7 +67,7 @@ public String get(String name) {
    * Returns the last value corresponding to the specified field parsed as an HTTP date, or null if
    * either the field is absent or cannot be parsed as a date.
    */
-  public Date getDate(String name) {
+  public @Nullable Date getDate(String name) {
     String value = get(name);
     return value != null ? HttpDate.parse(value) : null;
   }
@@ -109,6 +110,23 @@ public String value(int index) {
         : Collections.<String>emptyList();
   }
 
+  /**
+   * Returns the number of bytes required to encode these headers using HTTP/1.1. This is also the
+   * approximate size of HTTP/2 headers before they are compressed with HPACK. This value is
+   * intended to be used as a metric: smaller headers are more efficient to encode and transmit.
+   */
+  public long byteCount() {
+    // Each header name has 2 bytes of overhead for ': ' and every header value has 2 bytes of
+    // overhead for '\r\n'.
+    long result = namesAndValues.length * 2;
+
+    for (int i = 0, size = namesAndValues.length; i < size; i++) {
+      result += namesAndValues[i].length();
+    }
+
+    return result;
+  }
+
   public Builder newBuilder() {
     Builder result = new Builder();
     Collections.addAll(result.namesAndValues, namesAndValues);
@@ -141,7 +159,7 @@ public Builder newBuilder() {
    * Applications that require semantically equal headers should convert them into a canonical form
    * before comparing them for equality.
    */
-  @Override public boolean equals(Object other) {
+  @Override public boolean equals(@Nullable Object other) {
     return other instanceof Headers
         && Arrays.equals(((Headers) other).namesAndValues, namesAndValues);
   }
@@ -265,12 +283,26 @@ public Builder add(String line) {
       return add(line.substring(0, index).trim(), line.substring(index + 1));
     }
 
-    /** Add a field with the specified value. */
+    /**
+     * Add a header with the specified name and value. Does validation of header names and values.
+     */
     public Builder add(String name, String value) {
       checkNameAndValue(name, value);
       return addLenient(name, value);
     }
 
+    /**
+     * Adds all headers from an existing collection.
+     */
+    public Builder addAll(Headers headers) {
+      int size = headers.size();
+      for (int i = 0; i < size; i++) {
+        addLenient(headers.name(i), headers.value(i));
+      }
+
+      return this;
+    }
+
     /**
      * Add a field with the specified value without any validation. Only appropriate for headers
      * from the remote peer or cache.
@@ -313,7 +345,7 @@ private void checkNameAndValue(String name, String value) {
               "Unexpected char %#04x at %d in header name: %s", (int) c, i, name));
         }
       }
-      if (value == null) throw new NullPointerException("value == null");
+      if (value == null) throw new NullPointerException("value for name " + name + " == null");
       for (int i = 0, length = value.length(); i < length; i++) {
         char c = value.charAt(i);
         if ((c <= '\u001f' && c != '\t') || c >= '\u007f') {
diff --git a/okhttp/src/main/java/okhttp3/HttpUrl.java b/okhttp/src/main/java/okhttp3/HttpUrl.java
index 6b37d5630d..f88dfb6eb3 100644
--- a/okhttp/src/main/java/okhttp3/HttpUrl.java
+++ b/okhttp/src/main/java/okhttp3/HttpUrl.java
@@ -20,19 +20,22 @@
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
-import java.net.UnknownHostException;
+import java.nio.charset.Charset;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
+import javax.annotation.Nullable;
+import okhttp3.internal.Util;
+import okhttp3.internal.publicsuffix.PublicSuffixDatabase;
 import okio.Buffer;
 
+import static okhttp3.internal.Util.decodeHexDigit;
 import static okhttp3.internal.Util.delimiterOffset;
-import static okhttp3.internal.Util.domainToAscii;
 import static okhttp3.internal.Util.skipLeadingAsciiWhitespace;
 import static okhttp3.internal.Util.skipTrailingAsciiWhitespace;
+import static okhttp3.internal.Util.verifyAsIpAddress;
 
 /**
  * A uniform resource locator (URL) with a scheme of either {@code http} or {@code https}. Use this
@@ -277,7 +280,8 @@
  * {@code java.net.URL} it's possible to create an awkward URL like {@code http:/} with scheme and
  * path but no hostname. Building APIs that consume such malformed values is difficult!
  *
- * <p>This class has a modern API. It avoids punitive checked exceptions: {@link #parse parse()}
+ * <p>This class has a modern API. It avoids punitive checked exceptions: {@link #get get()}
+ * throws {@link IllegalArgumentException} on invalid input or {@link #parse parse()}
  * returns null if the input is an invalid URL. You can even be explicit about whether each
  * component has been encoded already.
  */
@@ -289,7 +293,8 @@
   static final String PATH_SEGMENT_ENCODE_SET = " \"<>^`{}|/\\?#";
   static final String PATH_SEGMENT_ENCODE_SET_URI = "[]";
   static final String QUERY_ENCODE_SET = " \"'<>#";
-  static final String QUERY_COMPONENT_ENCODE_SET = " \"'<>#&=";
+  static final String QUERY_COMPONENT_REENCODE_SET = " \"'<>#&=";
+  static final String QUERY_COMPONENT_ENCODE_SET = " !\"#$&'(),/:;<=>?@[]\\^`{|}~";
   static final String QUERY_COMPONENT_ENCODE_SET_URI = "\\^`{|}";
   static final String FORM_ENCODE_SET = " \"':;<=>@[]^`{}|/\\?#&!$(),~";
   static final String FRAGMENT_ENCODE_SET = "";
@@ -322,10 +327,10 @@
    * non-empty, but never null. Values are null if the name has no corresponding '=' separator, or
    * empty, or non-empty.
    */
-  private final List<String> queryNamesAndValues;
+  private final @Nullable List<String> queryNamesAndValues;
 
   /** Decoded fragment. */
-  private final String fragment;
+  private final @Nullable String fragment;
 
   /** Canonical URL. */
   private final String url;
@@ -604,10 +609,10 @@ static void pathSegmentsToString(StringBuilder out, List<String> pathSegments) {
    *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "a=apple&b"}</td></tr>
    * </table>
    */
-  public String encodedQuery() {
+  public @Nullable String encodedQuery() {
     if (queryNamesAndValues == null) return null; // No query.
     int queryStart = url.indexOf('?') + 1;
-    int queryEnd = delimiterOffset(url, queryStart + 1, url.length(), '#');
+    int queryEnd = delimiterOffset(url, queryStart, url.length(), '#');
     return url.substring(queryStart, queryEnd);
   }
 
@@ -664,7 +669,7 @@ static void namesAndValuesToQueryString(StringBuilder out, List<String> namesAnd
    *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "a=apple&b"}</td></tr>
    * </table>
    */
-  public String query() {
+  public @Nullable String query() {
     if (queryNamesAndValues == null) return null; // No query.
     StringBuilder result = new StringBuilder();
     namesAndValuesToQueryString(result, queryNamesAndValues);
@@ -702,7 +707,7 @@ public int querySize() {
    *   <tr><td>{@code http://host/?a=apple&b}</td><td>{@code "apple"}</td></tr>
    * </table>
    */
-  public String queryParameter(String name) {
+  public @Nullable String queryParameter(String name) {
     if (queryNamesAndValues == null) return null;
     for (int i = 0, size = queryNamesAndValues.size(); i < size; i += 2) {
       if (name.equals(queryNamesAndValues.get(i))) {
@@ -819,7 +824,7 @@ public String queryParameterValue(int index) {
    *   <tr><td>{@code http://host/#abc|def}</td><td>{@code "abc|def"}</td></tr>
    * </table>
    */
-  public String encodedFragment() {
+  public @Nullable String encodedFragment() {
     if (fragment == null) return null;
     int fragmentStart = url.indexOf('#') + 1;
     return url.substring(fragmentStart);
@@ -837,7 +842,7 @@ public String encodedFragment() {
    *   <tr><td>{@code http://host/#abc|def}</td><td>{@code "abc|def"}</td></tr>
    * </table>
    */
-  public String fragment() {
+  public @Nullable String fragment() {
     return fragment;
   }
 
@@ -858,7 +863,7 @@ public String redact() {
    * Returns the URL that would be retrieved by following {@code link} from this URL, or null if
    * the resulting URL is not well-formed.
    */
-  public HttpUrl resolve(String link) {
+  public @Nullable HttpUrl resolve(String link) {
     Builder builder = newBuilder(link);
     return builder != null ? builder.build() : null;
   }
@@ -882,59 +887,49 @@ public Builder newBuilder() {
    * Returns a builder for the URL that would be retrieved by following {@code link} from this URL,
    * or null if the resulting URL is not well-formed.
    */
-  public Builder newBuilder(String link) {
-    Builder builder = new Builder();
-    Builder.ParseResult result = builder.parse(this, link);
-    return result == Builder.ParseResult.SUCCESS ? builder : null;
+  public @Nullable Builder newBuilder(String link) {
+    try {
+      return new Builder().parse(this, link);
+    } catch (IllegalArgumentException ignored) {
+      return null;
+    }
   }
 
   /**
    * Returns a new {@code HttpUrl} representing {@code url} if it is a well-formed HTTP or HTTPS
    * URL, or null if it isn't.
    */
-  public static HttpUrl parse(String url) {
-    Builder builder = new Builder();
-    Builder.ParseResult result = builder.parse(null, url);
-    return result == Builder.ParseResult.SUCCESS ? builder.build() : null;
+  public static @Nullable HttpUrl parse(String url) {
+    try {
+      return get(url);
+    } catch (IllegalArgumentException ignored) {
+      return null;
+    }
   }
 
   /**
-   * Returns an {@link HttpUrl} for {@code url} if its protocol is {@code http} or {@code https}, or
-   * null if it has any other protocol.
+   * Returns a new {@code HttpUrl} representing {@code url}.
+   *
+   * @throws IllegalArgumentException If {@code url} is not a well-formed HTTP or HTTPS URL.
    */
-  public static HttpUrl get(URL url) {
-    return parse(url.toString());
+  public static HttpUrl get(String url) {
+    return new Builder().parse(null, url).build();
   }
 
   /**
-   * Returns a new {@code HttpUrl} representing {@code url} if it is a well-formed HTTP or HTTPS
-   * URL, or throws an exception if it isn't.
-   *
-   * @throws MalformedURLException if there was a non-host related URL issue
-   * @throws UnknownHostException if the host was invalid
+   * Returns an {@link HttpUrl} for {@code url} if its protocol is {@code http} or {@code https}, or
+   * null if it has any other protocol.
    */
-  static HttpUrl getChecked(String url) throws MalformedURLException, UnknownHostException {
-    Builder builder = new Builder();
-    Builder.ParseResult result = builder.parse(null, url);
-    switch (result) {
-      case SUCCESS:
-        return builder.build();
-      case INVALID_HOST:
-        throw new UnknownHostException("Invalid host: " + url);
-      case UNSUPPORTED_SCHEME:
-      case MISSING_SCHEME:
-      case INVALID_PORT:
-      default:
-        throw new MalformedURLException("Invalid URL: " + result + " for " + url);
-    }
+  public static @Nullable HttpUrl get(URL url) {
+    return parse(url.toString());
   }
 
-  public static HttpUrl get(URI uri) {
+  public static @Nullable HttpUrl get(URI uri) {
     return parse(uri.toString());
   }
 
-  @Override public boolean equals(Object o) {
-    return o instanceof HttpUrl && ((HttpUrl) o).url.equals(url);
+  @Override public boolean equals(@Nullable Object other) {
+    return other instanceof HttpUrl && ((HttpUrl) other).url.equals(url);
   }
 
   @Override public int hashCode() {
@@ -945,15 +940,39 @@ public static HttpUrl get(URI uri) {
     return url;
   }
 
+  /**
+   * Returns the domain name of this URL's {@link #host()} that is one level beneath the public
+   * suffix by consulting the <a href="https://publicsuffix.org">public suffix list</a>. Returns
+   * null if this URL's {@link #host()} is an IP address or is considered a public suffix by the
+   * public suffix list.
+   *
+   * <p>In general this method <strong>should not</strong> be used to test whether a domain is valid
+   * or routable. Instead, DNS is the recommended source for that information.
+   *
+   * <p><table summary="">
+   *   <tr><th>URL</th><th>{@code topPrivateDomain()}</th></tr>
+   *   <tr><td>{@code http://google.com}</td><td>{@code "google.com"}</td></tr>
+   *   <tr><td>{@code http://adwords.google.co.uk}</td><td>{@code "google.co.uk"}</td></tr>
+   *   <tr><td>{@code http://square}</td><td>null</td></tr>
+   *   <tr><td>{@code http://co.uk}</td><td>null</td></tr>
+   *   <tr><td>{@code http://localhost}</td><td>null</td></tr>
+   *   <tr><td>{@code http://127.0.0.1}</td><td>null</td></tr>
+   * </table>
+   */
+  public @Nullable String topPrivateDomain() {
+    if (verifyAsIpAddress(host)) return null;
+    return PublicSuffixDatabase.get().getEffectiveTldPlusOne(host);
+  }
+
   public static final class Builder {
-    String scheme;
+    @Nullable String scheme;
     String encodedUsername = "";
     String encodedPassword = "";
-    String host;
+    @Nullable String host;
     int port = -1;
     final List<String> encodedPathSegments = new ArrayList<>();
-    List<String> encodedQueryNamesAndValues;
-    String encodedFragment;
+    @Nullable List<String> encodedQueryNamesAndValues;
+    @Nullable String encodedFragment;
 
     public Builder() {
       encodedPathSegments.add(""); // The default path is '/' which needs a trailing space.
@@ -1069,7 +1088,8 @@ private Builder addPathSegments(String pathSegments, boolean alreadyEncoded) {
     public Builder setPathSegment(int index, String pathSegment) {
       if (pathSegment == null) throw new NullPointerException("pathSegment == null");
       String canonicalPathSegment = canonicalize(
-          pathSegment, 0, pathSegment.length(), PATH_SEGMENT_ENCODE_SET, false, false, false, true);
+          pathSegment, 0, pathSegment.length(), PATH_SEGMENT_ENCODE_SET, false, false, false, true,
+              null);
       if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
         throw new IllegalArgumentException("unexpected path segment: " + pathSegment);
       }
@@ -1082,7 +1102,8 @@ public Builder setEncodedPathSegment(int index, String encodedPathSegment) {
         throw new NullPointerException("encodedPathSegment == null");
       }
       String canonicalPathSegment = canonicalize(encodedPathSegment,
-          0, encodedPathSegment.length(), PATH_SEGMENT_ENCODE_SET, true, false, false, true);
+          0, encodedPathSegment.length(), PATH_SEGMENT_ENCODE_SET, true, false, false, true,
+          null);
       encodedPathSegments.set(index, canonicalPathSegment);
       if (isDot(canonicalPathSegment) || isDotDot(canonicalPathSegment)) {
         throw new IllegalArgumentException("unexpected path segment: " + encodedPathSegment);
@@ -1107,7 +1128,7 @@ public Builder encodedPath(String encodedPath) {
       return this;
     }
 
-    public Builder query(String query) {
+    public Builder query(@Nullable String query) {
       this.encodedQueryNamesAndValues = query != null
           ? queryStringToNamesAndValues(canonicalize(
           query, QUERY_ENCODE_SET, false, false, true, true))
@@ -1115,7 +1136,7 @@ public Builder query(String query) {
       return this;
     }
 
-    public Builder encodedQuery(String encodedQuery) {
+    public Builder encodedQuery(@Nullable String encodedQuery) {
       this.encodedQueryNamesAndValues = encodedQuery != null
           ? queryStringToNamesAndValues(
           canonicalize(encodedQuery, QUERY_ENCODE_SET, true, false, true, true))
@@ -1124,7 +1145,7 @@ public Builder encodedQuery(String encodedQuery) {
     }
 
     /** Encodes the query parameter using UTF-8 and adds it to this URL's query string. */
-    public Builder addQueryParameter(String name, String value) {
+    public Builder addQueryParameter(String name, @Nullable String value) {
       if (name == null) throw new NullPointerException("name == null");
       if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
       encodedQueryNamesAndValues.add(
@@ -1136,24 +1157,24 @@ public Builder addQueryParameter(String name, String value) {
     }
 
     /** Adds the pre-encoded query parameter to this URL's query string. */
-    public Builder addEncodedQueryParameter(String encodedName, String encodedValue) {
+    public Builder addEncodedQueryParameter(String encodedName, @Nullable String encodedValue) {
       if (encodedName == null) throw new NullPointerException("encodedName == null");
       if (encodedQueryNamesAndValues == null) encodedQueryNamesAndValues = new ArrayList<>();
       encodedQueryNamesAndValues.add(
-          canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, false, true, true));
+          canonicalize(encodedName, QUERY_COMPONENT_REENCODE_SET, true, false, true, true));
       encodedQueryNamesAndValues.add(encodedValue != null
-          ? canonicalize(encodedValue, QUERY_COMPONENT_ENCODE_SET, true, false, true, true)
+          ? canonicalize(encodedValue, QUERY_COMPONENT_REENCODE_SET, true, false, true, true)
           : null);
       return this;
     }
 
-    public Builder setQueryParameter(String name, String value) {
+    public Builder setQueryParameter(String name, @Nullable String value) {
       removeAllQueryParameters(name);
       addQueryParameter(name, value);
       return this;
     }
 
-    public Builder setEncodedQueryParameter(String encodedName, String encodedValue) {
+    public Builder setEncodedQueryParameter(String encodedName, @Nullable String encodedValue) {
       removeAllEncodedQueryParameters(encodedName);
       addEncodedQueryParameter(encodedName, encodedValue);
       return this;
@@ -1172,7 +1193,7 @@ public Builder removeAllEncodedQueryParameters(String encodedName) {
       if (encodedName == null) throw new NullPointerException("encodedName == null");
       if (encodedQueryNamesAndValues == null) return this;
       removeAllCanonicalQueryParameters(
-          canonicalize(encodedName, QUERY_COMPONENT_ENCODE_SET, true, false, true, true));
+          canonicalize(encodedName, QUERY_COMPONENT_REENCODE_SET, true, false, true, true));
       return this;
     }
 
@@ -1189,14 +1210,14 @@ private void removeAllCanonicalQueryParameters(String canonicalName) {
       }
     }
 
-    public Builder fragment(String fragment) {
+    public Builder fragment(@Nullable String fragment) {
       this.encodedFragment = fragment != null
           ? canonicalize(fragment, FRAGMENT_ENCODE_SET, false, false, false, false)
           : null;
       return this;
     }
 
-    public Builder encodedFragment(String encodedFragment) {
+    public Builder encodedFragment(@Nullable String encodedFragment) {
       this.encodedFragment = encodedFragment != null
           ? canonicalize(encodedFragment, FRAGMENT_ENCODE_SET, true, false, false, false)
           : null;
@@ -1279,15 +1300,9 @@ public HttpUrl build() {
       return result.toString();
     }
 
-    enum ParseResult {
-      SUCCESS,
-      MISSING_SCHEME,
-      UNSUPPORTED_SCHEME,
-      INVALID_PORT,
-      INVALID_HOST,
-    }
+    static final String INVALID_HOST = "Invalid URL host";
 
-    ParseResult parse(HttpUrl base, String input) {
+    Builder parse(@Nullable HttpUrl base, String input) {
       int pos = skipLeadingAsciiWhitespace(input, 0, input.length());
       int limit = skipTrailingAsciiWhitespace(input, pos, input.length());
 
@@ -1301,12 +1316,14 @@ ParseResult parse(HttpUrl base, String input) {
           this.scheme = "http";
           pos += "http:".length();
         } else {
-          return ParseResult.UNSUPPORTED_SCHEME; // Not an HTTP scheme.
+          throw new IllegalArgumentException("Expected URL scheme 'http' or 'https' but was '"
+              + input.substring(0, schemeDelimiterOffset) + "'");
         }
       } else if (base != null) {
         this.scheme = base.scheme;
       } else {
-        return ParseResult.MISSING_SCHEME; // No scheme.
+        throw new IllegalArgumentException(
+            "Expected URL scheme 'http' or 'https' but no colon was found");
       }
 
       // Authority.
@@ -1337,19 +1354,22 @@ ParseResult parse(HttpUrl base, String input) {
                 int passwordColonOffset = delimiterOffset(
                     input, pos, componentDelimiterOffset, ':');
                 String canonicalUsername = canonicalize(
-                    input, pos, passwordColonOffset, USERNAME_ENCODE_SET, true, false, false, true);
+                    input, pos, passwordColonOffset, USERNAME_ENCODE_SET, true, false, false, true,
+                    null);
                 this.encodedUsername = hasUsername
                     ? this.encodedUsername + "%40" + canonicalUsername
                     : canonicalUsername;
                 if (passwordColonOffset != componentDelimiterOffset) {
                   hasPassword = true;
                   this.encodedPassword = canonicalize(input, passwordColonOffset + 1,
-                      componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true);
+                      componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true,
+                      null);
                 }
                 hasUsername = true;
               } else {
                 this.encodedPassword = this.encodedPassword + "%40" + canonicalize(input, pos,
-                    componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true);
+                    componentDelimiterOffset, PASSWORD_ENCODE_SET, true, false, false, true,
+                    null);
               }
               pos = componentDelimiterOffset + 1;
               break;
@@ -1362,14 +1382,20 @@ ParseResult parse(HttpUrl base, String input) {
               // Host info precedes.
               int portColonOffset = portColonOffset(input, pos, componentDelimiterOffset);
               if (portColonOffset + 1 < componentDelimiterOffset) {
-                this.host = canonicalizeHost(input, pos, portColonOffset);
-                this.port = parsePort(input, portColonOffset + 1, componentDelimiterOffset);
-                if (this.port == -1) return ParseResult.INVALID_PORT; // Invalid port.
+                host = canonicalizeHost(input, pos, portColonOffset);
+                port = parsePort(input, portColonOffset + 1, componentDelimiterOffset);
+                if (port == -1) {
+                  throw new IllegalArgumentException("Invalid URL port: \""
+                      + input.substring(portColonOffset + 1, componentDelimiterOffset) + '"');
+                }
               } else {
-                this.host = canonicalizeHost(input, pos, portColonOffset);
-                this.port = defaultPort(this.scheme);
+                host = canonicalizeHost(input, pos, portColonOffset);
+                port = defaultPort(scheme);
+              }
+              if (host == null) {
+                throw new IllegalArgumentException(
+                    INVALID_HOST + ": \"" + input.substring(pos, portColonOffset) + '"');
               }
-              if (this.host == null) return ParseResult.INVALID_HOST; // Invalid host.
               pos = componentDelimiterOffset;
               break authority;
           }
@@ -1396,17 +1422,17 @@ ParseResult parse(HttpUrl base, String input) {
       if (pos < limit && input.charAt(pos) == '?') {
         int queryDelimiterOffset = delimiterOffset(input, pos, limit, '#');
         this.encodedQueryNamesAndValues = queryStringToNamesAndValues(canonicalize(
-            input, pos + 1, queryDelimiterOffset, QUERY_ENCODE_SET, true, false, true, true));
+            input, pos + 1, queryDelimiterOffset, QUERY_ENCODE_SET, true, false, true, true, null));
         pos = queryDelimiterOffset;
       }
 
       // Fragment.
       if (pos < limit && input.charAt(pos) == '#') {
         this.encodedFragment = canonicalize(
-            input, pos + 1, limit, FRAGMENT_ENCODE_SET, true, false, false, false);
+            input, pos + 1, limit, FRAGMENT_ENCODE_SET, true, false, false, false, null);
       }
 
-      return ParseResult.SUCCESS;
+      return this;
     }
 
     private void resolvePath(String input, int pos, int limit) {
@@ -1440,7 +1466,7 @@ private void resolvePath(String input, int pos, int limit) {
     private void push(String input, int pos, int limit, boolean addTrailingSlash,
         boolean alreadyEncoded) {
       String segment = canonicalize(
-          input, pos, limit, PATH_SEGMENT_ENCODE_SET, alreadyEncoded, false, false, true);
+          input, pos, limit, PATH_SEGMENT_ENCODE_SET, alreadyEncoded, false, false, true, null);
       if (isDot(segment)) {
         return; // Skip '.' path segments.
       }
@@ -1555,165 +1581,13 @@ private static String canonicalizeHost(String input, int pos, int limit) {
       // Start by percent decoding the host. The WHATWG spec suggests doing this only after we've
       // checked for IPv6 square braces. But Chrome does it first, and that's more lenient.
       String percentDecoded = percentDecode(input, pos, limit, false);
-
-      // If the input contains a :, itâ€™s an IPv6 address.
-      if (percentDecoded.contains(":")) {
-        // If the input is encased in square braces "[...]", drop 'em.
-        InetAddress inetAddress = percentDecoded.startsWith("[") && percentDecoded.endsWith("]")
-            ? decodeIpv6(percentDecoded, 1, percentDecoded.length() - 1)
-            : decodeIpv6(percentDecoded, 0, percentDecoded.length());
-        if (inetAddress == null) return null;
-        byte[] address = inetAddress.getAddress();
-        if (address.length == 16) return inet6AddressToAscii(address);
-        throw new AssertionError();
-      }
-
-      return domainToAscii(percentDecoded);
-    }
-
-    /** Decodes an IPv6 address like 1111:2222:3333:4444:5555:6666:7777:8888 or ::1. */
-    private static InetAddress decodeIpv6(String input, int pos, int limit) {
-      byte[] address = new byte[16];
-      int b = 0;
-      int compress = -1;
-      int groupOffset = -1;
-
-      for (int i = pos; i < limit; ) {
-        if (b == address.length) return null; // Too many groups.
-
-        // Read a delimiter.
-        if (i + 2 <= limit && input.regionMatches(i, "::", 0, 2)) {
-          // Compression "::" delimiter, which is anywhere in the input, including its prefix.
-          if (compress != -1) return null; // Multiple "::" delimiters.
-          i += 2;
-          b += 2;
-          compress = b;
-          if (i == limit) break;
-        } else if (b != 0) {
-          // Group separator ":" delimiter.
-          if (input.regionMatches(i, ":", 0, 1)) {
-            i++;
-          } else if (input.regionMatches(i, ".", 0, 1)) {
-            // If we see a '.', rewind to the beginning of the previous group and parse as IPv4.
-            if (!decodeIpv4Suffix(input, groupOffset, limit, address, b - 2)) return null;
-            b += 2; // We rewound two bytes and then added four.
-            break;
-          } else {
-            return null; // Wrong delimiter.
-          }
-        }
-
-        // Read a group, one to four hex digits.
-        int value = 0;
-        groupOffset = i;
-        for (; i < limit; i++) {
-          char c = input.charAt(i);
-          int hexDigit = decodeHexDigit(c);
-          if (hexDigit == -1) break;
-          value = (value << 4) + hexDigit;
-        }
-        int groupLength = i - groupOffset;
-        if (groupLength == 0 || groupLength > 4) return null; // Group is the wrong size.
-
-        // We've successfully read a group. Assign its value to our byte array.
-        address[b++] = (byte) ((value >>> 8) & 0xff);
-        address[b++] = (byte) (value & 0xff);
-      }
-
-      // All done. If compression happened, we need to move bytes to the right place in the
-      // address. Here's a sample:
-      //
-      //      input: "1111:2222:3333::7777:8888"
-      //     before: { 11, 11, 22, 22, 33, 33, 00, 00, 77, 77, 88, 88, 00, 00, 00, 00  }
-      //   compress: 6
-      //          b: 10
-      //      after: { 11, 11, 22, 22, 33, 33, 00, 00, 00, 00, 00, 00, 77, 77, 88, 88 }
-      //
-      if (b != address.length) {
-        if (compress == -1) return null; // Address didn't have compression or enough groups.
-        System.arraycopy(address, compress, address, address.length - (b - compress), b - compress);
-        Arrays.fill(address, compress, compress + (address.length - b), (byte) 0);
-      }
-
-      try {
-        return InetAddress.getByAddress(address);
-      } catch (UnknownHostException e) {
-        throw new AssertionError();
-      }
-    }
-
-    /** Decodes an IPv4 address suffix of an IPv6 address, like 1111::5555:6666:192.168.0.1. */
-    private static boolean decodeIpv4Suffix(
-        String input, int pos, int limit, byte[] address, int addressOffset) {
-      int b = addressOffset;
-
-      for (int i = pos; i < limit; ) {
-        if (b == address.length) return false; // Too many groups.
-
-        // Read a delimiter.
-        if (b != addressOffset) {
-          if (input.charAt(i) != '.') return false; // Wrong delimiter.
-          i++;
-        }
-
-        // Read 1 or more decimal digits for a value in 0..255.
-        int value = 0;
-        int groupOffset = i;
-        for (; i < limit; i++) {
-          char c = input.charAt(i);
-          if (c < '0' || c > '9') break;
-          if (value == 0 && groupOffset != i) return false; // Reject unnecessary leading '0's.
-          value = (value * 10) + c - '0';
-          if (value > 255) return false; // Value out of range.
-        }
-        int groupLength = i - groupOffset;
-        if (groupLength == 0) return false; // No digits.
-
-        // We've successfully read a byte.
-        address[b++] = (byte) value;
-      }
-
-      if (b != addressOffset + 4) return false; // Too few groups. We wanted exactly four.
-      return true; // Success.
-    }
-
-    private static String inet6AddressToAscii(byte[] address) {
-      // Go through the address looking for the longest run of 0s. Each group is 2-bytes.
-      int longestRunOffset = -1;
-      int longestRunLength = 0;
-      for (int i = 0; i < address.length; i += 2) {
-        int currentRunOffset = i;
-        while (i < 16 && address[i] == 0 && address[i + 1] == 0) {
-          i += 2;
-        }
-        int currentRunLength = i - currentRunOffset;
-        if (currentRunLength > longestRunLength) {
-          longestRunOffset = currentRunOffset;
-          longestRunLength = currentRunLength;
-        }
-      }
-
-      // Emit each 2-byte group in hex, separated by ':'. The longest run of zeroes is "::".
-      Buffer result = new Buffer();
-      for (int i = 0; i < address.length; ) {
-        if (i == longestRunOffset) {
-          result.writeByte(':');
-          i += longestRunLength;
-          if (i == 16) result.writeByte(':');
-        } else {
-          if (i > 0) result.writeByte(':');
-          int group = (address[i] & 0xff) << 8 | address[i + 1] & 0xff;
-          result.writeHexadecimalUnsignedLong(group);
-          i += 2;
-        }
-      }
-      return result.readUtf8();
+      return Util.canonicalizeHost(percentDecoded);
     }
 
     private static int parsePort(String input, int pos, int limit) {
       try {
         // Canonicalize the port string to skip '\n' etc.
-        String portString = canonicalize(input, pos, limit, "", false, false, false, true);
+        String portString = canonicalize(input, pos, limit, "", false, false, false, true, null);
         int i = Integer.parseInt(portString);
         if (i > 0 && i <= 65535) return i;
         return -1;
@@ -1780,13 +1654,6 @@ static boolean percentEncoded(String encoded, int pos, int limit) {
         && decodeHexDigit(encoded.charAt(pos + 2)) != -1;
   }
 
-  static int decodeHexDigit(char c) {
-    if (c >= '0' && c <= '9') return c - '0';
-    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
-    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
-    return -1;
-  }
-
   /**
    * Returns a substring of {@code input} on the range {@code [pos..limit)} with the following
    * transformations:
@@ -1802,9 +1669,11 @@ static int decodeHexDigit(char c) {
    * @param strict true to encode '%' if it is not the prefix of a valid percent encoding.
    * @param plusIsSpace true to encode '+' as "%2B" if it is not already encoded.
    * @param asciiOnly true to encode all non-ASCII codepoints.
+   * @param charset which charset to use, null equals UTF-8.
    */
   static String canonicalize(String input, int pos, int limit, String encodeSet,
-      boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly) {
+      boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly,
+      Charset charset) {
     int codePoint;
     for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
       codePoint = input.codePointAt(i);
@@ -1818,7 +1687,7 @@ static String canonicalize(String input, int pos, int limit, String encodeSet,
         Buffer out = new Buffer();
         out.writeUtf8(input, pos, i);
         canonicalize(out, input, i, limit, encodeSet, alreadyEncoded, strict, plusIsSpace,
-            asciiOnly);
+            asciiOnly, charset);
         return out.readUtf8();
       }
     }
@@ -1828,8 +1697,9 @@ static String canonicalize(String input, int pos, int limit, String encodeSet,
   }
 
   static void canonicalize(Buffer out, String input, int pos, int limit, String encodeSet,
-      boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly) {
-    Buffer utf8Buffer = null; // Lazily allocated.
+      boolean alreadyEncoded, boolean strict, boolean plusIsSpace, boolean asciiOnly,
+      Charset charset) {
+    Buffer encodedCharBuffer = null; // Lazily allocated.
     int codePoint;
     for (int i = pos; i < limit; i += Character.charCount(codePoint)) {
       codePoint = input.codePointAt(i);
@@ -1845,12 +1715,18 @@ static void canonicalize(Buffer out, String input, int pos, int limit, String en
           || encodeSet.indexOf(codePoint) != -1
           || codePoint == '%' && (!alreadyEncoded || strict && !percentEncoded(input, i, limit))) {
         // Percent encode this character.
-        if (utf8Buffer == null) {
-          utf8Buffer = new Buffer();
+        if (encodedCharBuffer == null) {
+          encodedCharBuffer = new Buffer();
         }
-        utf8Buffer.writeUtf8CodePoint(codePoint);
-        while (!utf8Buffer.exhausted()) {
-          int b = utf8Buffer.readByte() & 0xff;
+
+        if (charset == null || charset.equals(Util.UTF_8)) {
+          encodedCharBuffer.writeUtf8CodePoint(codePoint);
+        } else {
+          encodedCharBuffer.writeString(input, i, i + Character.charCount(codePoint), charset);
+        }
+
+        while (!encodedCharBuffer.exhausted()) {
+          int b = encodedCharBuffer.readByte() & 0xff;
           out.writeByte('%');
           out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);
           out.writeByte(HEX_DIGITS[b & 0xf]);
@@ -1863,8 +1739,15 @@ static void canonicalize(Buffer out, String input, int pos, int limit, String en
   }
 
   static String canonicalize(String input, String encodeSet, boolean alreadyEncoded, boolean strict,
-      boolean plusIsSpace, boolean asciiOnly) {
+      boolean plusIsSpace, boolean asciiOnly, Charset charset) {
     return canonicalize(
-        input, 0, input.length(), encodeSet, alreadyEncoded, strict, plusIsSpace, asciiOnly);
+        input, 0, input.length(), encodeSet, alreadyEncoded, strict, plusIsSpace, asciiOnly,
+            charset);
+  }
+
+  static String canonicalize(String input, String encodeSet, boolean alreadyEncoded, boolean strict,
+      boolean plusIsSpace, boolean asciiOnly) {
+   return canonicalize(
+        input, 0, input.length(), encodeSet, alreadyEncoded, strict, plusIsSpace, asciiOnly, null);
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Interceptor.java b/okhttp/src/main/java/okhttp3/Interceptor.java
index c1f8840a3c..1005592697 100644
--- a/okhttp/src/main/java/okhttp3/Interceptor.java
+++ b/okhttp/src/main/java/okhttp3/Interceptor.java
@@ -16,6 +16,8 @@
 package okhttp3;
 
 import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 
 /**
  * Observes, modifies, and potentially short-circuits requests going out and the corresponding
@@ -30,6 +32,24 @@
 
     Response proceed(Request request) throws IOException;
 
-    Connection connection();
+    /**
+     * Returns the connection the request will be executed on. This is only available in the chains
+     * of network interceptors; for application interceptors this is always null.
+     */
+    @Nullable Connection connection();
+
+    Call call();
+
+    int connectTimeoutMillis();
+
+    Chain withConnectTimeout(int timeout, TimeUnit unit);
+
+    int readTimeoutMillis();
+
+    Chain withReadTimeout(int timeout, TimeUnit unit);
+
+    int writeTimeoutMillis();
+
+    Chain withWriteTimeout(int timeout, TimeUnit unit);
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/MediaType.java b/okhttp/src/main/java/okhttp3/MediaType.java
index 77b943e589..ddbd8fcb16 100644
--- a/okhttp/src/main/java/okhttp3/MediaType.java
+++ b/okhttp/src/main/java/okhttp3/MediaType.java
@@ -19,6 +19,7 @@
 import java.util.Locale;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import javax.annotation.Nullable;
 
 /**
  * An <a href="http://tools.ietf.org/html/rfc2045">RFC 2045</a> Media Type, appropriate to describe
@@ -34,9 +35,9 @@
   private final String mediaType;
   private final String type;
   private final String subtype;
-  private final String charset;
+  private final @Nullable String charset;
 
-  private MediaType(String mediaType, String type, String subtype, String charset) {
+  private MediaType(String mediaType, String type, String subtype, @Nullable String charset) {
     this.mediaType = mediaType;
     this.type = type;
     this.subtype = subtype;
@@ -44,12 +45,15 @@ private MediaType(String mediaType, String type, String subtype, String charset)
   }
 
   /**
-   * Returns a media type for {@code string}, or null if {@code string} is not a well-formed media
-   * type.
+   * Returns a media type for {@code string}.
+   *
+   * @throws IllegalArgumentException if {@code string} is not a well-formed media type.
    */
-  public static MediaType parse(String string) {
+  public static MediaType get(String string) {
     Matcher typeSubtype = TYPE_SUBTYPE.matcher(string);
-    if (!typeSubtype.lookingAt()) return null;
+    if (!typeSubtype.lookingAt()) {
+      throw new IllegalArgumentException("No subtype found for: \"" + string + '"');
+    }
     String type = typeSubtype.group(1).toLowerCase(Locale.US);
     String subtype = typeSubtype.group(2).toLowerCase(Locale.US);
 
@@ -57,7 +61,13 @@ public static MediaType parse(String string) {
     Matcher parameter = PARAMETER.matcher(string);
     for (int s = typeSubtype.end(); s < string.length(); s = parameter.end()) {
       parameter.region(s, string.length());
-      if (!parameter.lookingAt()) return null; // This is not a well-formed media type.
+      if (!parameter.lookingAt()) {
+        throw new IllegalArgumentException("Parameter is not formatted correctly: \""
+            + string.substring(s)
+            + "\" for: \""
+            + string
+            + '"');
+      }
 
       String name = parameter.group(1);
       if (name == null || !name.equalsIgnoreCase("charset")) continue;
@@ -73,7 +83,13 @@ public static MediaType parse(String string) {
         charsetParameter = parameter.group(3);
       }
       if (charset != null && !charsetParameter.equalsIgnoreCase(charset)) {
-        throw new IllegalArgumentException("Multiple different charsets: " + string);
+        throw new IllegalArgumentException("Multiple charsets defined: \""
+            + charset
+            + "\" and: \""
+            + charsetParameter
+            + "\" for: \""
+            + string
+            + '"');
       }
       charset = charsetParameter;
     }
@@ -81,6 +97,18 @@ public static MediaType parse(String string) {
     return new MediaType(string, type, subtype, charset);
   }
 
+  /**
+   * Returns a media type for {@code string}, or null if {@code string} is not a well-formed media
+   * type.
+   */
+  public static @Nullable MediaType parse(String string) {
+    try {
+      return get(string);
+    } catch (IllegalArgumentException ignored) {
+      return null;
+    }
+  }
+
   /**
    * Returns the high-level media type, such as "text", "image", "audio", "video", or
    * "application".
@@ -99,16 +127,20 @@ public String subtype() {
   /**
    * Returns the charset of this media type, or null if this media type doesn't specify a charset.
    */
-  public Charset charset() {
-    return charset != null ? Charset.forName(charset) : null;
+  public @Nullable Charset charset() {
+    return charset(null);
   }
 
   /**
-   * Returns the charset of this media type, or {@code defaultValue} if this media type doesn't
-   * specify a charset.
+   * Returns the charset of this media type, or {@code defaultValue} if either this media type
+   * doesn't specify a charset, of it its charset is unsupported by the current runtime.
    */
-  public Charset charset(Charset defaultValue) {
-    return charset != null ? Charset.forName(charset) : defaultValue;
+  public @Nullable Charset charset(@Nullable Charset defaultValue) {
+    try {
+      return charset != null ? Charset.forName(charset) : defaultValue;
+    } catch (IllegalArgumentException e) {
+      return defaultValue; // This charset is invalid or unsupported. Give up.
+    }
   }
 
   /**
@@ -119,8 +151,8 @@ public Charset charset(Charset defaultValue) {
     return mediaType;
   }
 
-  @Override public boolean equals(Object o) {
-    return o instanceof MediaType && ((MediaType) o).mediaType.equals(mediaType);
+  @Override public boolean equals(@Nullable Object other) {
+    return other instanceof MediaType && ((MediaType) other).mediaType.equals(mediaType);
   }
 
   @Override public int hashCode() {
diff --git a/okhttp/src/main/java/okhttp3/MultipartBody.java b/okhttp/src/main/java/okhttp3/MultipartBody.java
index 3aa31f310d..800064cfb5 100644
--- a/okhttp/src/main/java/okhttp3/MultipartBody.java
+++ b/okhttp/src/main/java/okhttp3/MultipartBody.java
@@ -19,6 +19,7 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.UUID;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSink;
@@ -31,34 +32,34 @@
    * need to be bundled in a particular order. Any "multipart" subtypes that an implementation does
    * not recognize must be treated as being of subtype "mixed".
    */
-  public static final MediaType MIXED = MediaType.parse("multipart/mixed");
+  public static final MediaType MIXED = MediaType.get("multipart/mixed");
 
   /**
    * The "multipart/alternative" type is syntactically identical to "multipart/mixed", but the
    * semantics are different. In particular, each of the body parts is an "alternative" version of
    * the same information.
    */
-  public static final MediaType ALTERNATIVE = MediaType.parse("multipart/alternative");
+  public static final MediaType ALTERNATIVE = MediaType.get("multipart/alternative");
 
   /**
    * This type is syntactically identical to "multipart/mixed", but the semantics are different. In
    * particular, in a digest, the default {@code Content-Type} value for a body part is changed from
    * "text/plain" to "message/rfc822".
    */
-  public static final MediaType DIGEST = MediaType.parse("multipart/digest");
+  public static final MediaType DIGEST = MediaType.get("multipart/digest");
 
   /**
    * This type is syntactically identical to "multipart/mixed", but the semantics are different. In
    * particular, in a parallel entity, the order of body parts is not significant.
    */
-  public static final MediaType PARALLEL = MediaType.parse("multipart/parallel");
+  public static final MediaType PARALLEL = MediaType.get("multipart/parallel");
 
   /**
    * The media-type multipart/form-data follows the rules of all multipart MIME data streams as
    * outlined in RFC 2046. In forms, there are a series of fields to be supplied by the user who
    * fills out the form. Each field has a name. Within a given form, the names are unique.
    */
-  public static final MediaType FORM = MediaType.parse("multipart/form-data");
+  public static final MediaType FORM = MediaType.get("multipart/form-data");
 
   private static final byte[] COLONSPACE = {':', ' '};
   private static final byte[] CRLF = {'\r', '\n'};
@@ -73,7 +74,7 @@
   MultipartBody(ByteString boundary, MediaType type, List<Part> parts) {
     this.boundary = boundary;
     this.originalType = type;
-    this.contentType = MediaType.parse(type + "; boundary=" + boundary.utf8());
+    this.contentType = MediaType.get(type + "; boundary=" + boundary.utf8());
     this.parts = Util.immutableList(parts);
   }
 
@@ -119,7 +120,8 @@ public Part part(int index) {
    * to awkward operations like measuring the encoded length of header strings, or the
    * length-in-digits of an encoded integer.
    */
-  private long writeOrCountBytes(BufferedSink sink, boolean countBytes) throws IOException {
+  private long writeOrCountBytes(
+      @Nullable BufferedSink sink, boolean countBytes) throws IOException {
     long byteCount = 0L;
 
     Buffer byteCountBuffer = null;
@@ -225,7 +227,7 @@ public static Part create(RequestBody body) {
       return create(null, body);
     }
 
-    public static Part create(Headers headers, RequestBody body) {
+    public static Part create(@Nullable Headers headers, RequestBody body) {
       if (body == null) {
         throw new NullPointerException("body == null");
       }
@@ -242,7 +244,7 @@ public static Part createFormData(String name, String value) {
       return createFormData(name, null, RequestBody.create(null, value));
     }
 
-    public static Part createFormData(String name, String filename, RequestBody body) {
+    public static Part createFormData(String name, @Nullable String filename, RequestBody body) {
       if (name == null) {
         throw new NullPointerException("name == null");
       }
@@ -257,15 +259,15 @@ public static Part createFormData(String name, String filename, RequestBody body
       return create(Headers.of("Content-Disposition", disposition.toString()), body);
     }
 
-    final Headers headers;
+    final @Nullable Headers headers;
     final RequestBody body;
 
-    private Part(Headers headers, RequestBody body) {
+    private Part(@Nullable Headers headers, RequestBody body) {
       this.headers = headers;
       this.body = body;
     }
 
-    public Headers headers() {
+    public @Nullable Headers headers() {
       return headers;
     }
 
@@ -308,7 +310,7 @@ public Builder addPart(RequestBody body) {
     }
 
     /** Add a part to the body. */
-    public Builder addPart(Headers headers, RequestBody body) {
+    public Builder addPart(@Nullable Headers headers, RequestBody body) {
       return addPart(Part.create(headers, body));
     }
 
@@ -318,7 +320,7 @@ public Builder addFormDataPart(String name, String value) {
     }
 
     /** Add a form data part to the body. */
-    public Builder addFormDataPart(String name, String filename, RequestBody body) {
+    public Builder addFormDataPart(String name, @Nullable String filename, RequestBody body) {
       return addPart(Part.createFormData(name, filename, body));
     }
 
diff --git a/okhttp/src/main/java/okhttp3/OkHttpClient.java b/okhttp/src/main/java/okhttp3/OkHttpClient.java
index 6565b9fcd9..afb388a748 100644
--- a/okhttp/src/main/java/okhttp3/OkHttpClient.java
+++ b/okhttp/src/main/java/okhttp3/OkHttpClient.java
@@ -15,27 +15,23 @@
  */
 package okhttp3;
 
-import java.io.Closeable;
-import java.net.MalformedURLException;
 import java.net.Proxy;
 import java.net.ProxySelector;
-import java.net.UnknownHostException;
+import java.net.Socket;
 import java.security.GeneralSecurityException;
-import java.security.KeyStore;
-import java.security.SecureRandom;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
+import java.util.Random;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 import javax.net.SocketFactory;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
-import javax.net.ssl.TrustManagerFactory;
 import javax.net.ssl.X509TrustManager;
 import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
@@ -47,6 +43,11 @@
 import okhttp3.internal.tls.CertificateChainCleaner;
 import okhttp3.internal.tls.OkHostnameVerifier;
 import okhttp3.internal.ws.RealWebSocket;
+import okio.Sink;
+import okio.Source;
+
+import static okhttp3.internal.Util.assertionError;
+import static okhttp3.internal.Util.checkDuration;
 
 /**
  * Factory for {@linkplain Call calls}, which can be used to send HTTP requests and read their
@@ -123,7 +124,7 @@
       Protocol.HTTP_2, Protocol.HTTP_1_1);
 
   static final List<ConnectionSpec> DEFAULT_CONNECTION_SPECS = Util.immutableList(
-      ConnectionSpec.MODERN_TLS, ConnectionSpec.COMPATIBLE_TLS, ConnectionSpec.CLEARTEXT);
+      ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT);
 
   static {
     Internal.instance = new Internal() {
@@ -144,12 +145,16 @@
         return pool.connectionBecameIdle(connection);
       }
 
-      @Override public RealConnection get(
-          ConnectionPool pool, Address address, StreamAllocation streamAllocation) {
-        return pool.get(address, streamAllocation);
+      @Override public RealConnection get(ConnectionPool pool, Address address,
+          StreamAllocation streamAllocation, Route route) {
+        return pool.get(address, streamAllocation, route);
       }
 
-      @Override public Closeable deduplicate(
+      @Override public boolean equalsNonHost(Address a, Address b) {
+        return a.equalsNonHost(b);
+      }
+
+      @Override public Socket deduplicate(
           ConnectionPool pool, Address address, StreamAllocation streamAllocation) {
         return pool.deduplicate(address, streamAllocation);
       }
@@ -171,9 +176,8 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
         tlsConfiguration.apply(sslSocket, isFallback);
       }
 
-      @Override public HttpUrl getHttpUrlChecked(String url)
-          throws MalformedURLException, UnknownHostException {
-        return HttpUrl.getChecked(url);
+      @Override public boolean isInvalidHttpUrlHost(IllegalArgumentException e) {
+        return e.getMessage().startsWith(HttpUrl.Builder.INVALID_HOST);
       }
 
       @Override public StreamAllocation streamAllocation(Call call) {
@@ -181,21 +185,22 @@ public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean
       }
 
       @Override public Call newWebSocketCall(OkHttpClient client, Request originalRequest) {
-        return new RealCall(client, originalRequest, true);
+        return RealCall.newRealCall(client, originalRequest, true);
       }
     };
   }
 
   final Dispatcher dispatcher;
-  final Proxy proxy;
+  final @Nullable Proxy proxy;
   final List<Protocol> protocols;
   final List<ConnectionSpec> connectionSpecs;
   final List<Interceptor> interceptors;
   final List<Interceptor> networkInterceptors;
+  final EventListener.Factory eventListenerFactory;
   final ProxySelector proxySelector;
   final CookieJar cookieJar;
-  final Cache cache;
-  final InternalCache internalCache;
+  final @Nullable Cache cache;
+  final @Nullable InternalCache internalCache;
   final SocketFactory socketFactory;
   final SSLSocketFactory sslSocketFactory;
   final CertificateChainCleaner certificateChainCleaner;
@@ -224,6 +229,7 @@ public OkHttpClient() {
     this.connectionSpecs = builder.connectionSpecs;
     this.interceptors = Util.immutableList(builder.interceptors);
     this.networkInterceptors = Util.immutableList(builder.networkInterceptors);
+    this.eventListenerFactory = builder.eventListenerFactory;
     this.proxySelector = builder.proxySelector;
     this.cookieJar = builder.cookieJar;
     this.cache = builder.cache;
@@ -239,11 +245,15 @@ public OkHttpClient() {
       this.sslSocketFactory = builder.sslSocketFactory;
       this.certificateChainCleaner = builder.certificateChainCleaner;
     } else {
-      X509TrustManager trustManager = systemDefaultTrustManager();
-      this.sslSocketFactory = systemDefaultSslSocketFactory(trustManager);
+      X509TrustManager trustManager = Util.platformTrustManager();
+      this.sslSocketFactory = newSslSocketFactory(trustManager);
       this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
     }
 
+    if (sslSocketFactory != null) {
+      Platform.get().configureSslSocketFactory(sslSocketFactory);
+    }
+
     this.hostnameVerifier = builder.hostnameVerifier;
     this.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(
         certificateChainCleaner);
@@ -258,31 +268,22 @@ public OkHttpClient() {
     this.readTimeout = builder.readTimeout;
     this.writeTimeout = builder.writeTimeout;
     this.pingInterval = builder.pingInterval;
-  }
 
-  private X509TrustManager systemDefaultTrustManager() {
-    try {
-      TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
-          TrustManagerFactory.getDefaultAlgorithm());
-      trustManagerFactory.init((KeyStore) null);
-      TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
-      if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
-        throw new IllegalStateException("Unexpected default trust managers:"
-            + Arrays.toString(trustManagers));
-      }
-      return (X509TrustManager) trustManagers[0];
-    } catch (GeneralSecurityException e) {
-      throw new AssertionError(); // The system has no TLS. Just give up.
+    if (interceptors.contains(null)) {
+      throw new IllegalStateException("Null interceptor: " + interceptors);
+    }
+    if (networkInterceptors.contains(null)) {
+      throw new IllegalStateException("Null network interceptor: " + networkInterceptors);
     }
   }
 
-  private SSLSocketFactory systemDefaultSslSocketFactory(X509TrustManager trustManager) {
+  private static SSLSocketFactory newSslSocketFactory(X509TrustManager trustManager) {
     try {
-      SSLContext sslContext = SSLContext.getInstance("TLS");
+      SSLContext sslContext = Platform.get().getSSLContext();
       sslContext.init(null, new TrustManager[] { trustManager }, null);
       return sslContext.getSocketFactory();
     } catch (GeneralSecurityException e) {
-      throw new AssertionError(); // The system has no TLS. Just give up.
+      throw assertionError("No System TLS", e); // The system has no TLS. Just give up.
     }
   }
 
@@ -306,7 +307,7 @@ public int pingIntervalMillis() {
     return pingInterval;
   }
 
-  public Proxy proxy() {
+  public @Nullable Proxy proxy() {
     return proxy;
   }
 
@@ -318,7 +319,7 @@ public CookieJar cookieJar() {
     return cookieJar;
   }
 
-  public Cache cache() {
+  public @Nullable Cache cache() {
     return cache;
   }
 
@@ -400,18 +401,22 @@ public Dispatcher dispatcher() {
     return networkInterceptors;
   }
 
+  public EventListener.Factory eventListenerFactory() {
+    return eventListenerFactory;
+  }
+
   /**
    * Prepares the {@code request} to be executed at some point in the future.
    */
   @Override public Call newCall(Request request) {
-    return new RealCall(this, request, false /* for web socket */);
+    return RealCall.newRealCall(this, request, false /* for web socket */);
   }
 
   /**
    * Uses {@code request} to connect a new web socket.
    */
   @Override public WebSocket newWebSocket(Request request, WebSocketListener listener) {
-    RealWebSocket webSocket = new RealWebSocket(request, listener, new SecureRandom());
+    RealWebSocket webSocket = new RealWebSocket(request, listener, new Random(), pingInterval);
     webSocket.connect(this);
     return webSocket;
   }
@@ -422,18 +427,19 @@ public Builder newBuilder() {
 
   public static final class Builder {
     Dispatcher dispatcher;
-    Proxy proxy;
+    @Nullable Proxy proxy;
     List<Protocol> protocols;
     List<ConnectionSpec> connectionSpecs;
     final List<Interceptor> interceptors = new ArrayList<>();
     final List<Interceptor> networkInterceptors = new ArrayList<>();
+    EventListener.Factory eventListenerFactory;
     ProxySelector proxySelector;
     CookieJar cookieJar;
-    Cache cache;
-    InternalCache internalCache;
+    @Nullable Cache cache;
+    @Nullable InternalCache internalCache;
     SocketFactory socketFactory;
-    SSLSocketFactory sslSocketFactory;
-    CertificateChainCleaner certificateChainCleaner;
+    @Nullable SSLSocketFactory sslSocketFactory;
+    @Nullable CertificateChainCleaner certificateChainCleaner;
     HostnameVerifier hostnameVerifier;
     CertificatePinner certificatePinner;
     Authenticator proxyAuthenticator;
@@ -452,6 +458,7 @@ public Builder() {
       dispatcher = new Dispatcher();
       protocols = DEFAULT_PROTOCOLS;
       connectionSpecs = DEFAULT_CONNECTION_SPECS;
+      eventListenerFactory = EventListener.factory(EventListener.NONE);
       proxySelector = ProxySelector.getDefault();
       cookieJar = CookieJar.NO_COOKIES;
       socketFactory = SocketFactory.getDefault();
@@ -477,6 +484,7 @@ public Builder() {
       this.connectionSpecs = okHttpClient.connectionSpecs;
       this.interceptors.addAll(okHttpClient.interceptors);
       this.networkInterceptors.addAll(okHttpClient.networkInterceptors);
+      this.eventListenerFactory = okHttpClient.eventListenerFactory;
       this.proxySelector = okHttpClient.proxySelector;
       this.cookieJar = okHttpClient.cookieJar;
       this.internalCache = okHttpClient.internalCache;
@@ -503,6 +511,9 @@ public Builder() {
      * Sets the default connect timeout for new connections. A value of 0 means no timeout,
      * otherwise values must be between 1 and {@link Integer#MAX_VALUE} when converted to
      * milliseconds.
+     *
+     * <p>The connectTimeout is applied when connecting a TCP socket to the target host.
+     * The default value is 10 seconds.
      */
     public Builder connectTimeout(long timeout, TimeUnit unit) {
       connectTimeout = checkDuration("timeout", timeout, unit);
@@ -512,6 +523,12 @@ public Builder connectTimeout(long timeout, TimeUnit unit) {
     /**
      * Sets the default read timeout for new connections. A value of 0 means no timeout, otherwise
      * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     *
+     * <p>The read timeout is applied to both the TCP socket and for individual read IO operations
+     * including on {@link Source} of the {@link Response}. The default value is 10 seconds.
+     *
+     * @see Socket#setSoTimeout(int)
+     * @see Source#timeout()
      */
     public Builder readTimeout(long timeout, TimeUnit unit) {
       readTimeout = checkDuration("timeout", timeout, unit);
@@ -521,6 +538,11 @@ public Builder readTimeout(long timeout, TimeUnit unit) {
     /**
      * Sets the default write timeout for new connections. A value of 0 means no timeout, otherwise
      * values must be between 1 and {@link Integer#MAX_VALUE} when converted to milliseconds.
+     *
+     * <p>The write timeout is applied for individual write IO operations.
+     * The default value is 10 seconds.
+     *
+     * @see Sink#timeout()
      */
     public Builder writeTimeout(long timeout, TimeUnit unit) {
       writeTimeout = checkDuration("timeout", timeout, unit);
@@ -528,10 +550,15 @@ public Builder writeTimeout(long timeout, TimeUnit unit) {
     }
 
     /**
-     * Sets the interval between web socket pings initiated by this client. Use this to
-     * automatically send web socket ping frames until either the web socket fails or it is closed.
-     * This keeps the connection alive and may detect connectivity failures early. No timeouts are
-     * enforced on the acknowledging pongs.
+     * Sets the interval between HTTP/2 and web socket pings initiated by this client. Use this to
+     * automatically send ping frames until either the connection fails or it is closed. This keeps
+     * the connection alive and may detect connectivity failures.
+     *
+     * <p>If the server does not respond to each ping with a pong within {@code interval}, this
+     * client will assume that connectivity has been lost. When this happens on a web socket the
+     * connection is canceled and its listener is {@linkplain WebSocketListener#onFailure notified
+     * of the failure}. When it happens on an HTTP/2 connection the connection is closed and any
+     * calls it is carrying {@linkplain java.io.IOException will fail with an IOException}.
      *
      * <p>The default value of 0 disables client-initiated pings.
      */
@@ -540,21 +567,12 @@ public Builder pingInterval(long interval, TimeUnit unit) {
       return this;
     }
 
-    private static int checkDuration(String name, long duration, TimeUnit unit) {
-      if (duration < 0) throw new IllegalArgumentException(name + " < 0");
-      if (unit == null) throw new NullPointerException("unit == null");
-      long millis = unit.toMillis(duration);
-      if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException(name + " too large.");
-      if (millis == 0 && duration > 0) throw new IllegalArgumentException(name + " too small.");
-      return (int) millis;
-    }
-
     /**
      * Sets the HTTP proxy that will be used by connections created by this client. This takes
      * precedence over {@link #proxySelector}, which is only honored when this proxy is null (which
-     * it is by default). To disable proxy use completely, call {@code setProxy(Proxy.NO_PROXY)}.
+     * it is by default). To disable proxy use completely, call {@code proxy(Proxy.NO_PROXY)}.
      */
-    public Builder proxy(Proxy proxy) {
+    public Builder proxy(@Nullable Proxy proxy) {
       this.proxy = proxy;
       return this;
     }
@@ -568,6 +586,7 @@ public Builder proxy(Proxy proxy) {
      * be used.
      */
     public Builder proxySelector(ProxySelector proxySelector) {
+      if (proxySelector == null) throw new NullPointerException("proxySelector == null");
       this.proxySelector = proxySelector;
       return this;
     }
@@ -585,13 +604,13 @@ public Builder cookieJar(CookieJar cookieJar) {
     }
 
     /** Sets the response cache to be used to read and write cached responses. */
-    void setInternalCache(InternalCache internalCache) {
+    void setInternalCache(@Nullable InternalCache internalCache) {
       this.internalCache = internalCache;
       this.cache = null;
     }
 
     /** Sets the response cache to be used to read and write cached responses. */
-    public Builder cache(Cache cache) {
+    public Builder cache(@Nullable Cache cache) {
       this.cache = cache;
       this.internalCache = null;
       return this;
@@ -633,13 +652,8 @@ public Builder socketFactory(SocketFactory socketFactory) {
      */
     public Builder sslSocketFactory(SSLSocketFactory sslSocketFactory) {
       if (sslSocketFactory == null) throw new NullPointerException("sslSocketFactory == null");
-      X509TrustManager trustManager = Platform.get().trustManager(sslSocketFactory);
-      if (trustManager == null) {
-        throw new IllegalStateException("Unable to extract the trust manager on " + Platform.get()
-            + ", sslSocketFactory is " + sslSocketFactory.getClass());
-      }
       this.sslSocketFactory = sslSocketFactory;
-      this.certificateChainCleaner = CertificateChainCleaner.get(trustManager);
+      this.certificateChainCleaner = Platform.get().buildCertificateChainCleaner(sslSocketFactory);
       return this;
     }
 
@@ -669,7 +683,7 @@ public Builder sslSocketFactory(SSLSocketFactory sslSocketFactory) {
      *   SSLSocketFactory sslSocketFactory = sslContext.getSocketFactory();
      *
      *   OkHttpClient client = new OkHttpClient.Builder()
-     *       .sslSocketFactory(sslSocketFactory, trustManager);
+     *       .sslSocketFactory(sslSocketFactory, trustManager)
      *       .build();
      * }</pre>
      */
@@ -799,7 +813,9 @@ public Builder dispatcher(Dispatcher dispatcher) {
      *
      * <ul>
      *     <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
-     *     <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-17">h2</a>
+     *     <li><a href="https://tools.ietf.org/html/rfc7540">h2</a>
+     *     <li><a href="https://tools.ietf.org/html/rfc7540#section-3.4">h2 with prior knowledge
+     *         (cleartext only)</a>
      * </ul>
      *
      * <p><strong>This is an evolving set.</strong> Future releases include support for transitional
@@ -807,22 +823,30 @@ public Builder dispatcher(Dispatcher dispatcher) {
      *
      * <p>If multiple protocols are specified, <a
      * href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> will be used to
-     * negotiate a transport.
+     * negotiate a transport. Protocol negotiation is only attempted for HTTPS URLs.
      *
      * <p>{@link Protocol#HTTP_1_0} is not supported in this set. Requests are initiated with {@code
-     * HTTP/1.1} only. If the server responds with {@code HTTP/1.0}, that will be exposed by {@link
+     * HTTP/1.1}. If the server responds with {@code HTTP/1.0}, that will be exposed by {@link
      * Response#protocol()}.
      *
-     * @param protocols the protocols to use, in order of preference. The list must contain {@link
-     * Protocol#HTTP_1_1}. It must not contain null or {@link Protocol#HTTP_1_0}.
+     * @param protocols the protocols to use, in order of preference. If the list contains {@link
+     *     Protocol#H2_PRIOR_KNOWLEDGE} then that must be the only protocol and HTTPS URLs will not
+     *     be supported. Otherwise the list must contain {@link Protocol#HTTP_1_1}. The list must
+     *     not contain null or {@link Protocol#HTTP_1_0}.
      */
     public Builder protocols(List<Protocol> protocols) {
       // Create a private copy of the list.
       protocols = new ArrayList<>(protocols);
 
       // Validate that the list has everything we require and nothing we forbid.
-      if (!protocols.contains(Protocol.HTTP_1_1)) {
-        throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
+      if (!protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE)
+          && !protocols.contains(Protocol.HTTP_1_1)) {
+        throw new IllegalArgumentException(
+            "protocols must contain h2_prior_knowledge or http/1.1: " + protocols);
+      }
+      if (protocols.contains(Protocol.H2_PRIOR_KNOWLEDGE) && protocols.size() > 1) {
+        throw new IllegalArgumentException(
+            "protocols containing h2_prior_knowledge cannot use other protocols: " + protocols);
       }
       if (protocols.contains(Protocol.HTTP_1_0)) {
         throw new IllegalArgumentException("protocols must not contain http/1.0: " + protocols);
@@ -832,9 +856,7 @@ public Builder protocols(List<Protocol> protocols) {
       }
 
       // Remove protocols that we no longer support.
-      if (protocols.contains(Protocol.SPDY_3)) {
-        protocols.remove(Protocol.SPDY_3);
-      }
+      protocols.remove(Protocol.SPDY_3);
 
       // Assign as an unmodifiable list. This is effectively immutable.
       this.protocols = Collections.unmodifiableList(protocols);
@@ -856,6 +878,7 @@ public Builder connectionSpecs(List<ConnectionSpec> connectionSpecs) {
     }
 
     public Builder addInterceptor(Interceptor interceptor) {
+      if (interceptor == null) throw new IllegalArgumentException("interceptor == null");
       interceptors.add(interceptor);
       return this;
     }
@@ -870,10 +893,37 @@ public Builder addInterceptor(Interceptor interceptor) {
     }
 
     public Builder addNetworkInterceptor(Interceptor interceptor) {
+      if (interceptor == null) throw new IllegalArgumentException("interceptor == null");
       networkInterceptors.add(interceptor);
       return this;
     }
 
+    /**
+     * Configure a single client scoped listener that will receive all analytic events
+     * for this client.
+     *
+     * @see EventListener for semantics and restrictions on listener implementations.
+     */
+    public Builder eventListener(EventListener eventListener) {
+      if (eventListener == null) throw new NullPointerException("eventListener == null");
+      this.eventListenerFactory = EventListener.factory(eventListener);
+      return this;
+    }
+
+    /**
+     * Configure a factory to provide per-call scoped listeners that will receive analytic events
+     * for this client.
+     *
+     * @see EventListener for semantics and restrictions on listener implementations.
+     */
+    public Builder eventListenerFactory(EventListener.Factory eventListenerFactory) {
+      if (eventListenerFactory == null) {
+        throw new NullPointerException("eventListenerFactory == null");
+      }
+      this.eventListenerFactory = eventListenerFactory;
+      return this;
+    }
+
     public OkHttpClient build() {
       return new OkHttpClient(this);
     }
diff --git a/okhttp/src/main/java/okhttp3/Protocol.java b/okhttp/src/main/java/okhttp3/Protocol.java
index 88d15b9b6b..a96070ed59 100644
--- a/okhttp/src/main/java/okhttp3/Protocol.java
+++ b/okhttp/src/main/java/okhttp3/Protocol.java
@@ -35,8 +35,8 @@
   /**
    * A plaintext framing that includes persistent connections.
    *
-   * <p>This version of OkHttp implements <a href="http://www.ietf.org/rfc/rfc2616.txt">RFC
-   * 2616</a>, and tracks revisions to that spec.
+   * <p>This version of OkHttp implements <a href="https://tools.ietf.org/html/rfc7230">RFC
+   * 7230</a>, and tracks revisions to that spec.
    */
   HTTP_1_1("http/1.1"),
 
@@ -59,7 +59,26 @@
    * that enforce this may send an exception message including the string {@code
    * INADEQUATE_SECURITY}.
    */
-  HTTP_2("h2");
+  HTTP_2("h2"),
+
+  /**
+   * Cleartext HTTP/2 with no "upgrade" round trip. This option requires the client to have prior
+   * knowledge that the server supports cleartext HTTP/2.
+   *
+   * @see <a href="https://tools.ietf.org/html/rfc7540#section-3.4">Starting HTTP/2 with Prior
+   * Knowledge</a>
+   */
+  H2_PRIOR_KNOWLEDGE("h2_prior_knowledge"),
+
+  /**
+   * QUIC (Quick UDP Internet Connection) is a new multiplexed and secure transport atop UDP,
+   * designed from the ground up and optimized for HTTP/2 semantics.
+   * HTTP/1.1 semantics are layered on HTTP/2.
+   *
+   * <p>QUIC is not natively supported by OkHttp, but provided to allow a theoretical
+   * interceptor that provides support.
+   */
+  QUIC("quic");
 
   private final String protocol;
 
@@ -76,14 +95,19 @@ public static Protocol get(String protocol) throws IOException {
     // Unroll the loop over values() to save an allocation.
     if (protocol.equals(HTTP_1_0.protocol)) return HTTP_1_0;
     if (protocol.equals(HTTP_1_1.protocol)) return HTTP_1_1;
+    if (protocol.equals(H2_PRIOR_KNOWLEDGE.protocol)) return H2_PRIOR_KNOWLEDGE;
     if (protocol.equals(HTTP_2.protocol)) return HTTP_2;
     if (protocol.equals(SPDY_3.protocol)) return SPDY_3;
+    if (protocol.equals(QUIC.protocol)) return QUIC;
     throw new IOException("Unexpected protocol: " + protocol);
   }
 
   /**
    * Returns the string used to identify this protocol for ALPN, like "http/1.1", "spdy/3.1" or
    * "h2".
+   *
+   * @see <a href="https://www.iana.org/assignments/tls-extensiontype-values">IANA
+   * tls-extensiontype-values</a>
    */
   @Override public String toString() {
     return protocol;
diff --git a/okhttp/src/main/java/okhttp3/RealCall.java b/okhttp/src/main/java/okhttp3/RealCall.java
index ab3ddb088f..808b3dc7ba 100644
--- a/okhttp/src/main/java/okhttp3/RealCall.java
+++ b/okhttp/src/main/java/okhttp3/RealCall.java
@@ -34,6 +34,12 @@
   final OkHttpClient client;
   final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
 
+  /**
+   * There is a cycle between the {@link Call} and {@link EventListener} that makes this awkward.
+   * This will be set after we create the call instance then create the event listener instance.
+   */
+  private EventListener eventListener;
+
   /** The application's original request unadulterated by redirects or auth headers. */
   final Request originalRequest;
   final boolean forWebSocket;
@@ -41,13 +47,20 @@
   // Guarded by this.
   private boolean executed;
 
-  RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
+  private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
     this.client = client;
     this.originalRequest = originalRequest;
     this.forWebSocket = forWebSocket;
     this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);
   }
 
+  static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
+    // Safely publish the Call instance to the EventListener.
+    RealCall call = new RealCall(client, originalRequest, forWebSocket);
+    call.eventListener = client.eventListenerFactory().create(call);
+    return call;
+  }
+
   @Override public Request request() {
     return originalRequest;
   }
@@ -58,11 +71,15 @@
       executed = true;
     }
     captureCallStackTrace();
+    eventListener.callStart(this);
     try {
       client.dispatcher().executed(this);
       Response result = getResponseWithInterceptorChain();
       if (result == null) throw new IOException("Canceled");
       return result;
+    } catch (IOException e) {
+      eventListener.callFailed(this, e);
+      throw e;
     } finally {
       client.dispatcher().finished(this);
     }
@@ -79,6 +96,7 @@ private void captureCallStackTrace() {
       executed = true;
     }
     captureCallStackTrace();
+    eventListener.callStart(this);
     client.dispatcher().enqueue(new AsyncCall(responseCallback));
   }
 
@@ -96,7 +114,7 @@ private void captureCallStackTrace() {
 
   @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type & this saves clearing state.
   @Override public RealCall clone() {
-    return new RealCall(client, originalRequest, forWebSocket);
+    return RealCall.newRealCall(client, originalRequest, forWebSocket);
   }
 
   StreamAllocation streamAllocation() {
@@ -139,6 +157,7 @@ RealCall get() {
           // Do not signal the callback twice!
           Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e);
         } else {
+          eventListener.callFailed(RealCall.this, e);
           responseCallback.onFailure(RealCall.this, e);
         }
       } finally {
@@ -174,8 +193,10 @@ Response getResponseWithInterceptorChain() throws IOException {
     }
     interceptors.add(new CallServerInterceptor(forWebSocket));
 
-    Interceptor.Chain chain = new RealInterceptorChain(
-        interceptors, null, null, null, 0, originalRequest);
+    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,
+        originalRequest, this, eventListener, client.connectTimeoutMillis(),
+        client.readTimeoutMillis(), client.writeTimeoutMillis());
+
     return chain.proceed(originalRequest);
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/Request.java b/okhttp/src/main/java/okhttp3/Request.java
index f4b0f6dba4..7ffb00c1a5 100644
--- a/okhttp/src/main/java/okhttp3/Request.java
+++ b/okhttp/src/main/java/okhttp3/Request.java
@@ -16,7 +16,11 @@
 package okhttp3;
 
 import java.net.URL;
+import java.util.Collections;
+import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.Map;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okhttp3.internal.http.HttpMethod;
 
@@ -28,8 +32,8 @@
   final HttpUrl url;
   final String method;
   final Headers headers;
-  final RequestBody body;
-  final Object tag;
+  final @Nullable RequestBody body;
+  final Map<Class<?>, Object> tags;
 
   private volatile CacheControl cacheControl; // Lazily initialized.
 
@@ -38,7 +42,7 @@
     this.method = builder.method;
     this.headers = builder.headers.build();
     this.body = builder.body;
-    this.tag = builder.tag != null ? builder.tag : this;
+    this.tags = Util.immutableMap(builder.tags);
   }
 
   public HttpUrl url() {
@@ -53,7 +57,7 @@ public Headers headers() {
     return headers;
   }
 
-  public String header(String name) {
+  public @Nullable String header(String name) {
     return headers.get(name);
   }
 
@@ -61,12 +65,28 @@ public String header(String name) {
     return headers.values(name);
   }
 
-  public RequestBody body() {
+  public @Nullable RequestBody body() {
     return body;
   }
 
-  public Object tag() {
-    return tag;
+  /**
+   * Returns the tag attached with {@code Object.class} as a key, or null if no tag is attached with
+   * that key.
+   *
+   * <p>Prior to OkHttp 3.11, this method never returned null if no tag was attached. Instead it
+   * returned either this request, or the request upon which this request was derived with {@link
+   * #newBuilder()}.
+   */
+  public @Nullable Object tag() {
+    return tag(Object.class);
+  }
+
+  /**
+   * Returns the tag attached with {@code type} as a key, or null if no tag is attached with that
+   * key.
+   */
+  public @Nullable <T> T tag(Class<? extends T> type) {
+    return type.cast(tags.get(type));
   }
 
   public Builder newBuilder() {
@@ -91,8 +111,8 @@ public boolean isHttps() {
         + method
         + ", url="
         + url
-        + ", tag="
-        + (tag != this ? tag : null)
+        + ", tags="
+        + tags
         + '}';
   }
 
@@ -101,7 +121,9 @@ public boolean isHttps() {
     String method;
     Headers.Builder headers;
     RequestBody body;
-    Object tag;
+
+    /** A mutable map of tags, or an immutable empty map if we don't have any. */
+    Map<Class<?>, Object> tags = Collections.emptyMap();
 
     public Builder() {
       this.method = "GET";
@@ -112,7 +134,9 @@ public Builder() {
       this.url = request.url;
       this.method = request.method;
       this.body = request.body;
-      this.tag = request.tag;
+      this.tags = request.tags.isEmpty()
+          ? Collections.<Class<?>, Object>emptyMap()
+          : new LinkedHashMap<>(request.tags);
       this.headers = request.headers.newBuilder();
     }
 
@@ -138,9 +162,7 @@ public Builder url(String url) {
         url = "https:" + url.substring(4);
       }
 
-      HttpUrl parsed = HttpUrl.parse(url);
-      if (parsed == null) throw new IllegalArgumentException("unexpected url: " + url);
-      return url(parsed);
+      return url(HttpUrl.get(url));
     }
 
     /**
@@ -151,9 +173,7 @@ public Builder url(String url) {
      */
     public Builder url(URL url) {
       if (url == null) throw new NullPointerException("url == null");
-      HttpUrl parsed = HttpUrl.get(url);
-      if (parsed == null) throw new IllegalArgumentException("unexpected url: " + url);
-      return url(parsed);
+      return url(HttpUrl.get(url.toString()));
     }
 
     /**
@@ -177,6 +197,7 @@ public Builder addHeader(String name, String value) {
       return this;
     }
 
+    /** Removes all headers named {@code name} on this builder. */
     public Builder removeHeader(String name) {
       headers.removeAll(name);
       return this;
@@ -211,7 +232,7 @@ public Builder post(RequestBody body) {
       return method("POST", body);
     }
 
-    public Builder delete(RequestBody body) {
+    public Builder delete(@Nullable RequestBody body) {
       return method("DELETE", body);
     }
 
@@ -227,7 +248,7 @@ public Builder patch(RequestBody body) {
       return method("PATCH", body);
     }
 
-    public Builder method(String method, RequestBody body) {
+    public Builder method(String method, @Nullable RequestBody body) {
       if (method == null) throw new NullPointerException("method == null");
       if (method.length() == 0) throw new IllegalArgumentException("method.length() == 0");
       if (body != null && !HttpMethod.permitsRequestBody(method)) {
@@ -241,12 +262,29 @@ public Builder method(String method, RequestBody body) {
       return this;
     }
 
+    /** Attaches {@code tag} to the request using {@code Object.class} as a key. */
+    public Builder tag(@Nullable Object tag) {
+      return tag(Object.class, tag);
+    }
+
     /**
-     * Attaches {@code tag} to the request. It can be used later to cancel the request. If the tag
-     * is unspecified or null, the request is canceled by using the request itself as the tag.
+     * Attaches {@code tag} to the request using {@code type} as a key. Tags can be read from a
+     * request using {@link Request#tag}. Use null to remove any existing tag assigned for {@code
+     * type}.
+     *
+     * <p>Use this API to attach timing, debugging, or other application data to a request so that
+     * you may read it in interceptors, event listeners, or callbacks.
      */
-    public Builder tag(Object tag) {
-      this.tag = tag;
+    public <T> Builder tag(Class<? super T> type, @Nullable T tag) {
+      if (type == null) throw new NullPointerException("type == null");
+
+      if (tag == null) {
+        tags.remove(type);
+      } else {
+        if (tags.isEmpty()) tags = new LinkedHashMap<>();
+        tags.put(type, type.cast(tag));
+      }
+
       return this;
     }
 
diff --git a/okhttp/src/main/java/okhttp3/RequestBody.java b/okhttp/src/main/java/okhttp3/RequestBody.java
index 136cfdc4e3..3cb29477d3 100644
--- a/okhttp/src/main/java/okhttp3/RequestBody.java
+++ b/okhttp/src/main/java/okhttp3/RequestBody.java
@@ -18,6 +18,7 @@
 import java.io.File;
 import java.io.IOException;
 import java.nio.charset.Charset;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okio.BufferedSink;
 import okio.ByteString;
@@ -26,24 +27,24 @@
 
 public abstract class RequestBody {
   /** Returns the Content-Type header for this body. */
-  public abstract MediaType contentType();
+  public abstract @Nullable MediaType contentType();
 
   /**
-   * Returns the number of bytes that will be written to {@code out} in a call to {@link #writeTo},
+   * Returns the number of bytes that will be written to {@code sink} in a call to {@link #writeTo},
    * or -1 if that count is unknown.
    */
   public long contentLength() throws IOException {
     return -1;
   }
 
-  /** Writes the content of this request to {@code out}. */
+  /** Writes the content of this request to {@code sink}. */
   public abstract void writeTo(BufferedSink sink) throws IOException;
 
   /**
    * Returns a new request body that transmits {@code content}. If {@code contentType} is non-null
    * and lacks a charset, this will use UTF-8.
    */
-  public static RequestBody create(MediaType contentType, String content) {
+  public static RequestBody create(@Nullable MediaType contentType, String content) {
     Charset charset = Util.UTF_8;
     if (contentType != null) {
       charset = contentType.charset();
@@ -57,9 +58,10 @@ public static RequestBody create(MediaType contentType, String content) {
   }
 
   /** Returns a new request body that transmits {@code content}. */
-  public static RequestBody create(final MediaType contentType, final ByteString content) {
+  public static RequestBody create(
+      final @Nullable MediaType contentType, final ByteString content) {
     return new RequestBody() {
-      @Override public MediaType contentType() {
+      @Override public @Nullable MediaType contentType() {
         return contentType;
       }
 
@@ -74,17 +76,17 @@ public static RequestBody create(final MediaType contentType, final ByteString c
   }
 
   /** Returns a new request body that transmits {@code content}. */
-  public static RequestBody create(final MediaType contentType, final byte[] content) {
+  public static RequestBody create(final @Nullable MediaType contentType, final byte[] content) {
     return create(contentType, content, 0, content.length);
   }
 
   /** Returns a new request body that transmits {@code content}. */
-  public static RequestBody create(final MediaType contentType, final byte[] content,
+  public static RequestBody create(final @Nullable MediaType contentType, final byte[] content,
       final int offset, final int byteCount) {
     if (content == null) throw new NullPointerException("content == null");
     Util.checkOffsetAndCount(content.length, offset, byteCount);
     return new RequestBody() {
-      @Override public MediaType contentType() {
+      @Override public @Nullable MediaType contentType() {
         return contentType;
       }
 
@@ -99,11 +101,11 @@ public static RequestBody create(final MediaType contentType, final byte[] conte
   }
 
   /** Returns a new request body that transmits the content of {@code file}. */
-  public static RequestBody create(final MediaType contentType, final File file) {
+  public static RequestBody create(final @Nullable MediaType contentType, final File file) {
     if (file == null) throw new NullPointerException("content == null");
 
     return new RequestBody() {
-      @Override public MediaType contentType() {
+      @Override public @Nullable MediaType contentType() {
         return contentType;
       }
 
diff --git a/okhttp/src/main/java/okhttp3/Response.java b/okhttp/src/main/java/okhttp3/Response.java
index 810309b013..b36ea85c6a 100644
--- a/okhttp/src/main/java/okhttp3/Response.java
+++ b/okhttp/src/main/java/okhttp3/Response.java
@@ -19,6 +19,7 @@
 import java.io.IOException;
 import java.util.Collections;
 import java.util.List;
+import javax.annotation.Nullable;
 import okhttp3.internal.http.HttpHeaders;
 import okio.Buffer;
 import okio.BufferedSource;
@@ -44,12 +45,12 @@
   final Protocol protocol;
   final int code;
   final String message;
-  final Handshake handshake;
+  final @Nullable Handshake handshake;
   final Headers headers;
-  final ResponseBody body;
-  final Response networkResponse;
-  final Response cacheResponse;
-  final Response priorResponse;
+  final @Nullable ResponseBody body;
+  final @Nullable Response networkResponse;
+  final @Nullable Response cacheResponse;
+  final @Nullable Response priorResponse;
   final long sentRequestAtMillis;
   final long receivedResponseAtMillis;
 
@@ -105,7 +106,7 @@ public boolean isSuccessful() {
     return code >= 200 && code < 300;
   }
 
-  /** Returns the HTTP status message or null if it is unknown. */
+  /** Returns the HTTP status message. */
   public String message() {
     return message;
   }
@@ -114,7 +115,7 @@ public String message() {
    * Returns the TLS handshake of the connection that carried this response, or null if the response
    * was received without TLS.
    */
-  public Handshake handshake() {
+  public @Nullable Handshake handshake() {
     return handshake;
   }
 
@@ -122,11 +123,11 @@ public Handshake handshake() {
     return headers.values(name);
   }
 
-  public String header(String name) {
+  public @Nullable String header(String name) {
     return header(name, null);
   }
 
-  public String header(String name, String defaultValue) {
+  public @Nullable String header(String name, @Nullable String defaultValue) {
     String result = headers.get(name);
     return result != null ? result : defaultValue;
   }
@@ -172,7 +173,7 @@ public ResponseBody peekBody(long byteCount) throws IOException {
    * <p>This always returns null on responses returned from {@link #cacheResponse}, {@link
    * #networkResponse}, and {@link #priorResponse()}.
    */
-  public ResponseBody body() {
+  public @Nullable ResponseBody body() {
     return body;
   }
 
@@ -200,7 +201,7 @@ public boolean isRedirect() {
    * the network, such as when the response is fully cached. The body of the returned response
    * should not be read.
    */
-  public Response networkResponse() {
+  public @Nullable Response networkResponse() {
     return networkResponse;
   }
 
@@ -209,7 +210,7 @@ public Response networkResponse() {
    * cache. For conditional get requests the cache response and network response may both be
    * non-null. The body of the returned response should not be read.
    */
-  public Response cacheResponse() {
+  public @Nullable Response cacheResponse() {
     return cacheResponse;
   }
 
@@ -219,7 +220,7 @@ public Response cacheResponse() {
    * returned response should not be read because it has already been consumed by the redirecting
    * client.
    */
-  public Response priorResponse() {
+  public @Nullable Response priorResponse() {
     return priorResponse;
   }
 
@@ -268,8 +269,17 @@ public long receivedResponseAtMillis() {
     return receivedResponseAtMillis;
   }
 
-  /** Closes the response body. Equivalent to {@code body().close()}. */
+  /**
+   * Closes the response body. Equivalent to {@code body().close()}.
+   *
+   * <p>It is an error to close a response that is not eligible for a body. This includes the
+   * responses returned from {@link #cacheResponse}, {@link #networkResponse}, and {@link
+   * #priorResponse()}.
+   */
   @Override public void close() {
+    if (body == null) {
+      throw new IllegalStateException("response is not eligible for a body and must not be closed");
+    }
     body.close();
   }
 
@@ -290,7 +300,7 @@ public long receivedResponseAtMillis() {
     Protocol protocol;
     int code = -1;
     String message;
-    Handshake handshake;
+    @Nullable Handshake handshake;
     Headers.Builder headers;
     ResponseBody body;
     Response networkResponse;
@@ -338,7 +348,7 @@ public Builder message(String message) {
       return this;
     }
 
-    public Builder handshake(Handshake handshake) {
+    public Builder handshake(@Nullable Handshake handshake) {
       this.handshake = handshake;
       return this;
     }
@@ -372,18 +382,18 @@ public Builder headers(Headers headers) {
       return this;
     }
 
-    public Builder body(ResponseBody body) {
+    public Builder body(@Nullable ResponseBody body) {
       this.body = body;
       return this;
     }
 
-    public Builder networkResponse(Response networkResponse) {
+    public Builder networkResponse(@Nullable Response networkResponse) {
       if (networkResponse != null) checkSupportResponse("networkResponse", networkResponse);
       this.networkResponse = networkResponse;
       return this;
     }
 
-    public Builder cacheResponse(Response cacheResponse) {
+    public Builder cacheResponse(@Nullable Response cacheResponse) {
       if (cacheResponse != null) checkSupportResponse("cacheResponse", cacheResponse);
       this.cacheResponse = cacheResponse;
       return this;
@@ -401,7 +411,7 @@ private void checkSupportResponse(String name, Response response) {
       }
     }
 
-    public Builder priorResponse(Response priorResponse) {
+    public Builder priorResponse(@Nullable Response priorResponse) {
       if (priorResponse != null) checkPriorResponse(priorResponse);
       this.priorResponse = priorResponse;
       return this;
@@ -427,6 +437,7 @@ public Response build() {
       if (request == null) throw new IllegalStateException("request == null");
       if (protocol == null) throw new IllegalStateException("protocol == null");
       if (code < 0) throw new IllegalStateException("code < 0: " + code);
+      if (message == null) throw new IllegalStateException("message == null");
       return new Response(this);
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/ResponseBody.java b/okhttp/src/main/java/okhttp3/ResponseBody.java
index c00e90f961..73c6b93aac 100644
--- a/okhttp/src/main/java/okhttp3/ResponseBody.java
+++ b/okhttp/src/main/java/okhttp3/ResponseBody.java
@@ -21,9 +21,11 @@
 import java.io.InputStreamReader;
 import java.io.Reader;
 import java.nio.charset.Charset;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okio.Buffer;
 import okio.BufferedSource;
+import okio.ByteString;
 
 import static okhttp3.internal.Util.UTF_8;
 
@@ -47,7 +49,7 @@
  *   <li>Response.body().close()</li>
  *   <li>Response.body().source().close()</li>
  *   <li>Response.body().charStream().close()</li>
- *   <li>Response.body().byteString().close()</li>
+ *   <li>Response.body().byteStream().close()</li>
  *   <li>Response.body().bytes()</li>
  *   <li>Response.body().string()</li>
  * </ul>
@@ -102,7 +104,7 @@
   /** Multiple calls to {@link #charStream()} must return the same instance. */
   private Reader reader;
 
-  public abstract MediaType contentType();
+  public abstract @Nullable MediaType contentType();
 
   /**
    * Returns the number of bytes in that will returned by {@link #bytes}, or {@link #byteStream}, or
@@ -190,7 +192,7 @@ private Charset charset() {
    * Returns a new response body that transmits {@code content}. If {@code contentType} is non-null
    * and lacks a charset, this will use UTF-8.
    */
-  public static ResponseBody create(MediaType contentType, String content) {
+  public static ResponseBody create(@Nullable MediaType contentType, String content) {
     Charset charset = UTF_8;
     if (contentType != null) {
       charset = contentType.charset();
@@ -204,17 +206,23 @@ public static ResponseBody create(MediaType contentType, String content) {
   }
 
   /** Returns a new response body that transmits {@code content}. */
-  public static ResponseBody create(final MediaType contentType, byte[] content) {
+  public static ResponseBody create(final @Nullable MediaType contentType, byte[] content) {
     Buffer buffer = new Buffer().write(content);
     return create(contentType, content.length, buffer);
   }
 
   /** Returns a new response body that transmits {@code content}. */
-  public static ResponseBody create(
-      final MediaType contentType, final long contentLength, final BufferedSource content) {
+  public static ResponseBody create(@Nullable MediaType contentType, ByteString content) {
+    Buffer buffer = new Buffer().write(content);
+    return create(contentType, content.size(), buffer);
+  }
+
+  /** Returns a new response body that transmits {@code content}. */
+  public static ResponseBody create(final @Nullable MediaType contentType,
+      final long contentLength, final BufferedSource content) {
     if (content == null) throw new NullPointerException("source == null");
     return new ResponseBody() {
-      @Override public MediaType contentType() {
+      @Override public @Nullable MediaType contentType() {
         return contentType;
       }
 
diff --git a/okhttp/src/main/java/okhttp3/Route.java b/okhttp/src/main/java/okhttp3/Route.java
index 7c7e9635e8..14158673ca 100644
--- a/okhttp/src/main/java/okhttp3/Route.java
+++ b/okhttp/src/main/java/okhttp3/Route.java
@@ -17,6 +17,7 @@
 
 import java.net.InetSocketAddress;
 import java.net.Proxy;
+import javax.annotation.Nullable;
 
 /**
  * The concrete route used by a connection to reach an abstract origin server. When creating a
@@ -79,14 +80,11 @@ public boolean requiresTunnel() {
     return address.sslSocketFactory != null && proxy.type() == Proxy.Type.HTTP;
   }
 
-  @Override public boolean equals(Object obj) {
-    if (obj instanceof Route) {
-      Route other = (Route) obj;
-      return address.equals(other.address)
-          && proxy.equals(other.proxy)
-          && inetSocketAddress.equals(other.inetSocketAddress);
-    }
-    return false;
+  @Override public boolean equals(@Nullable Object other) {
+    return other instanceof Route
+        && ((Route) other).address.equals(address)
+        && ((Route) other).proxy.equals(proxy)
+        && ((Route) other).inetSocketAddress.equals(inetSocketAddress);
   }
 
   @Override public int hashCode() {
diff --git a/okhttp/src/main/java/okhttp3/TlsVersion.java b/okhttp/src/main/java/okhttp3/TlsVersion.java
index 391af88e3a..02cbeca3d1 100644
--- a/okhttp/src/main/java/okhttp3/TlsVersion.java
+++ b/okhttp/src/main/java/okhttp3/TlsVersion.java
@@ -15,6 +15,10 @@
  */
 package okhttp3;
 
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
 /**
  * Versions of TLS that can be offered when negotiating a secure socket. See {@link
  * javax.net.ssl.SSLSocket#setEnabledProtocols}.
@@ -49,6 +53,14 @@ public static TlsVersion forJavaName(String javaName) {
     throw new IllegalArgumentException("Unexpected TLS version: " + javaName);
   }
 
+  static List<TlsVersion> forJavaNames(String... tlsVersions) {
+    List<TlsVersion> result = new ArrayList<>(tlsVersions.length);
+    for (String tlsVersion : tlsVersions) {
+      result.add(forJavaName(tlsVersion));
+    }
+    return Collections.unmodifiableList(result);
+  }
+
   public String javaName() {
     return javaName;
   }
diff --git a/okhttp/src/main/java/okhttp3/WebSocket.java b/okhttp/src/main/java/okhttp3/WebSocket.java
index 12457e535e..46d95dec3a 100644
--- a/okhttp/src/main/java/okhttp3/WebSocket.java
+++ b/okhttp/src/main/java/okhttp3/WebSocket.java
@@ -15,6 +15,7 @@
  */
 package okhttp3;
 
+import javax.annotation.Nullable;
 import okio.ByteString;
 
 /**
@@ -81,9 +82,9 @@
    * message.
    *
    * <p>This method returns true if the message was enqueued. Messages that would overflow the
-   * outgoing message buffer will be rejected and trigger a {@linkplain #close graceful shutdown} of
-   * this web socket. This method returns false in that case, and in any other case where this
-   * web socket is closing, closed, or canceled.
+   * outgoing message buffer (16 MiB) will be rejected and trigger a
+   * {@linkplain #close graceful shutdown} of this web socket. This method returns false in that
+   * case, and in any other case where this web socket is closing, closed, or canceled.
    *
    * <p>This method returns immediately.
    */
@@ -98,10 +99,11 @@
    * a graceful shutdown was already underway or if the web socket is already closed or canceled.
    *
    * @param code Status code as defined by <a
-   * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a> or {@code 0}.
+   * href="http://tools.ietf.org/html/rfc6455#section-7.4">Section 7.4 of RFC 6455</a>.
    * @param reason Reason for shutting down or {@code null}.
+   * @throws IllegalArgumentException if code is invalid.
    */
-  boolean close(int code, String reason);
+  boolean close(int code, @Nullable String reason);
 
   /**
    * Immediately and violently release resources held by this web socket, discarding any enqueued
@@ -110,6 +112,12 @@
   void cancel();
 
   interface Factory {
+    /**
+     * Creates a new web socket and immediately returns it. Creating a web socket initiates an
+     * asynchronous process to connect the socket. Once that succeeds or fails, {@code listener}
+     * will be notified. The caller must either close or cancel the returned web socket when it is
+     * no longer in use.
+     */
     WebSocket newWebSocket(Request request, WebSocketListener listener);
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/WebSocketListener.java b/okhttp/src/main/java/okhttp3/WebSocketListener.java
index d46e916dd8..69276d933b 100644
--- a/okhttp/src/main/java/okhttp3/WebSocketListener.java
+++ b/okhttp/src/main/java/okhttp3/WebSocketListener.java
@@ -15,6 +15,7 @@
  */
 package okhttp3;
 
+import javax.annotation.Nullable;
 import okio.ByteString;
 
 public abstract class WebSocketListener {
@@ -33,7 +34,10 @@ public void onMessage(WebSocket webSocket, String text) {
   public void onMessage(WebSocket webSocket, ByteString bytes) {
   }
 
-  /** Invoked when the peer has indicated that no more incoming messages will be transmitted. */
+  /**
+   * Invoked when the remote peer has indicated that no more incoming messages will be
+   * transmitted.
+   */
   public void onClosing(WebSocket webSocket, int code, String reason) {
   }
 
@@ -49,6 +53,6 @@ public void onClosed(WebSocket webSocket, int code, String reason) {
    * network. Both outgoing and incoming messages may have been lost. No further calls to this
    * listener will be made.
    */
-  public void onFailure(WebSocket webSocket, Throwable t, Response response) {
+  public void onFailure(WebSocket webSocket, Throwable t, @Nullable Response response) {
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/Internal.java b/okhttp/src/main/java/okhttp3/internal/Internal.java
index 1f0b3daeca..4bb2282756 100644
--- a/okhttp/src/main/java/okhttp3/internal/Internal.java
+++ b/okhttp/src/main/java/okhttp3/internal/Internal.java
@@ -15,19 +15,17 @@
  */
 package okhttp3.internal;
 
-import java.io.Closeable;
-import java.net.MalformedURLException;
-import java.net.UnknownHostException;
+import java.net.Socket;
 import javax.net.ssl.SSLSocket;
 import okhttp3.Address;
 import okhttp3.Call;
 import okhttp3.ConnectionPool;
 import okhttp3.ConnectionSpec;
 import okhttp3.Headers;
-import okhttp3.HttpUrl;
 import okhttp3.OkHttpClient;
 import okhttp3.Request;
 import okhttp3.Response;
+import okhttp3.Route;
 import okhttp3.internal.cache.InternalCache;
 import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.RouteDatabase;
@@ -52,10 +50,12 @@ public static void initializeInstanceForTests() {
 
   public abstract void setCache(OkHttpClient.Builder builder, InternalCache internalCache);
 
-  public abstract RealConnection get(
-      ConnectionPool pool, Address address, StreamAllocation streamAllocation);
+  public abstract RealConnection get(ConnectionPool pool, Address address,
+      StreamAllocation streamAllocation, Route route);
+
+  public abstract boolean equalsNonHost(Address a, Address b);
 
-  public abstract Closeable deduplicate(
+  public abstract Socket deduplicate(
       ConnectionPool pool, Address address, StreamAllocation streamAllocation);
 
   public abstract void put(ConnectionPool pool, RealConnection connection);
@@ -69,8 +69,7 @@ public abstract Closeable deduplicate(
   public abstract void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket,
       boolean isFallback);
 
-  public abstract HttpUrl getHttpUrlChecked(String url)
-      throws MalformedURLException, UnknownHostException;
+  public abstract boolean isInvalidHttpUrlHost(IllegalArgumentException e);
 
   public abstract StreamAllocation streamAllocation(Call call);
 
diff --git a/okhttp/src/main/java/okhttp3/internal/Util.java b/okhttp/src/main/java/okhttp3/internal/Util.java
index 5a88c88998..6f8a4146b1 100644
--- a/okhttp/src/main/java/okhttp3/internal/Util.java
+++ b/okhttp/src/main/java/okhttp3/internal/Util.java
@@ -18,20 +18,32 @@
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InterruptedIOException;
-import java.lang.reflect.Array;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.net.IDN;
+import java.net.InetAddress;
 import java.net.ServerSocket;
 import java.net.Socket;
+import java.net.UnknownHostException;
 import java.nio.charset.Charset;
+import java.security.GeneralSecurityException;
+import java.security.KeyStore;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
+import java.util.Comparator;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Locale;
+import java.util.Map;
 import java.util.TimeZone;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Pattern;
+import javax.annotation.Nullable;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
 import okhttp3.HttpUrl;
 import okhttp3.RequestBody;
 import okhttp3.ResponseBody;
@@ -55,6 +67,7 @@
   private static final ByteString UTF_32_LE_BOM = ByteString.decodeHex("ffff0000");
 
   public static final Charset UTF_8 = Charset.forName("UTF-8");
+  public static final Charset ISO_8859_1 = Charset.forName("ISO-8859-1");
   private static final Charset UTF_16_BE = Charset.forName("UTF-16BE");
   private static final Charset UTF_16_LE = Charset.forName("UTF-16LE");
   private static final Charset UTF_32_BE = Charset.forName("UTF-32BE");
@@ -63,6 +76,33 @@
   /** GMT and UTC are equivalent for our purposes. */
   public static final TimeZone UTC = TimeZone.getTimeZone("GMT");
 
+  public static final Comparator<String> NATURAL_ORDER = new Comparator<String>() {
+    @Override public int compare(String a, String b) {
+      return a.compareTo(b);
+    }
+  };
+
+  private static final Method addSuppressedExceptionMethod;
+
+  static {
+    Method m;
+    try {
+      m = Throwable.class.getDeclaredMethod("addSuppressed", Throwable.class);
+    } catch (Exception e) {
+      m = null;
+    }
+    addSuppressedExceptionMethod = m;
+  }
+
+  public static void addSuppressedIfPossible(Throwable e, Throwable suppressed) {
+    if (addSuppressedExceptionMethod != null) {
+      try {
+        addSuppressedExceptionMethod.invoke(e, suppressed);
+      } catch (InvocationTargetException | IllegalAccessException ignored) {
+      }
+    }
+  }
+
   /**
    * Quick and dirty pattern to differentiate IP addresses from hostnames. This is an approximation
    * of Android's private InetAddress#isNumeric API.
@@ -182,6 +222,13 @@ public static boolean skipAll(Source source, int duration, TimeUnit timeUnit) th
     return Collections.unmodifiableList(new ArrayList<>(list));
   }
 
+  /** Returns an immutable copy of {@code map}. */
+  public static <K, V> Map<K, V> immutableMap(Map<K, V> map) {
+    return map.isEmpty()
+        ? Collections.<K, V>emptyMap()
+        : Collections.unmodifiableMap(new LinkedHashMap<>(map));
+  }
+
   /** Returns an immutable list containing {@code elements}. */
   public static <T> List<T> immutableList(T... elements) {
     return Collections.unmodifiableList(Arrays.asList(elements.clone()));
@@ -198,30 +245,43 @@ public static ThreadFactory threadFactory(final String name, final boolean daemo
   }
 
   /**
-   * Returns an array containing containing only elements found in {@code first}  and also in {@code
+   * Returns an array containing only elements found in {@code first} and also in {@code
    * second}. The returned elements are in the same order as in {@code first}.
    */
   @SuppressWarnings("unchecked")
-  public static <T> T[] intersect(Class<T> arrayType, T[] first, T[] second) {
-    List<T> result = intersect(first, second);
-    return result.toArray((T[]) Array.newInstance(arrayType, result.size()));
+  public static String[] intersect(
+      Comparator<? super String> comparator, String[] first, String[] second) {
+    List<String> result = new ArrayList<>();
+    for (String a : first) {
+      for (String b : second) {
+        if (comparator.compare(a, b) == 0) {
+          result.add(a);
+          break;
+        }
+      }
+    }
+    return result.toArray(new String[result.size()]);
   }
 
   /**
-   * Returns a list containing containing only elements found in {@code first}  and also in {@code
-   * second}. The returned elements are in the same order as in {@code first}.
+   * Returns true if there is an element in {@code first} that is also in {@code second}. This
+   * method terminates if any intersection is found. The sizes of both arguments are assumed to be
+   * so small, and the likelihood of an intersection so great, that it is not worth the CPU cost of
+   * sorting or the memory cost of hashing.
    */
-  private static <T> List<T> intersect(T[] first, T[] second) {
-    List<T> result = new ArrayList<>();
-    for (T a : first) {
-      for (T b : second) {
-        if (a.equals(b)) {
-          result.add(b);
-          break;
+  public static boolean nonEmptyIntersection(
+      Comparator<String> comparator, String[] first, String[] second) {
+    if (first == null || second == null || first.length == 0 || second.length == 0) {
+      return false;
+    }
+    for (String a : first) {
+      for (String b : second) {
+        if (comparator.compare(a, b) == 0) {
+          return true;
         }
       }
     }
-    return result;
+    return false;
   }
 
   public static String hostHeader(HttpUrl url, boolean includeDefaultPort) {
@@ -233,23 +293,6 @@ public static String hostHeader(HttpUrl url, boolean includeDefaultPort) {
         : host;
   }
 
-  /** Returns {@code s} with control characters and non-ASCII characters replaced with '?'. */
-  public static String toHumanReadableAscii(String s) {
-    for (int i = 0, length = s.length(), c; i < length; i += Character.charCount(c)) {
-      c = s.codePointAt(i);
-      if (c > '\u001f' && c < '\u007f') continue;
-
-      Buffer buffer = new Buffer();
-      buffer.writeUtf8(s, 0, i);
-      for (int j = i; j < length; j += Character.charCount(c)) {
-        c = s.codePointAt(j);
-        buffer.writeUtf8CodePoint(c > '\u001f' && c < '\u007f' ? c : '?');
-      }
-      return buffer.readUtf8();
-    }
-    return s;
-  }
-
   /**
    * Returns true if {@code e} is due to a firmware bug fixed after Android 4.2.2.
    * https://code.google.com/p/android/issues/detail?id=54072
@@ -259,9 +302,9 @@ public static boolean isAndroidGetsocknameError(AssertionError e) {
         && e.getMessage().contains("getsockname failed");
   }
 
-  public static <T> int indexOf(T[] array, T value) {
+  public static int indexOf(Comparator<String> comparator, String[] array, String value) {
     for (int i = 0, size = array.length; i < size; i++) {
-      if (equal(array[i], value)) return i;
+      if (comparator.compare(array[i], value) == 0) return i;
     }
     return -1;
   }
@@ -343,14 +386,28 @@ public static int delimiterOffset(String input, int pos, int limit, char delimit
   }
 
   /**
-   * Performs IDN ToASCII encoding and canonicalize the result to lowercase. e.g. This converts
-   * {@code â˜ƒ.net} to {@code xn--n3h.net}, and {@code WwW.GoOgLe.cOm} to {@code www.google.com}.
-   * {@code null} will be returned if the input cannot be ToASCII encoded or if the result
-   * contains unsupported ASCII characters.
+   * If {@code host} is an IP address, this returns the IP address in canonical form.
+   *
+   * <p>Otherwise this performs IDN ToASCII encoding and canonicalize the result to lowercase. For
+   * example this converts {@code â˜ƒ.net} to {@code xn--n3h.net}, and {@code WwW.GoOgLe.cOm} to
+   * {@code www.google.com}. {@code null} will be returned if the host cannot be ToASCII encoded or
+   * if the result contains unsupported ASCII characters.
    */
-  public static String domainToAscii(String input) {
+  public static String canonicalizeHost(String host) {
+    // If the input contains a :, itâ€™s an IPv6 address.
+    if (host.contains(":")) {
+      // If the input is encased in square braces "[...]", drop 'em.
+      InetAddress inetAddress = host.startsWith("[") && host.endsWith("]")
+          ? decodeIpv6(host, 1, host.length() - 1)
+          : decodeIpv6(host, 0, host.length());
+      if (inetAddress == null) return null;
+      byte[] address = inetAddress.getAddress();
+      if (address.length == 16) return inet6AddressToAscii(address);
+      throw new AssertionError("Invalid IPv6 address: '" + host + "'");
+    }
+
     try {
-      String result = IDN.toASCII(input).toLowerCase(Locale.US);
+      String result = IDN.toASCII(host).toLowerCase(Locale.US);
       if (result.isEmpty()) return null;
 
       // Confirm that the IDN ToASCII result doesn't contain any illegal characters.
@@ -431,4 +488,188 @@ public static Charset bomAwareCharset(BufferedSource source, Charset charset) th
     }
     return charset;
   }
+
+  public static int checkDuration(String name, long duration, TimeUnit unit) {
+    if (duration < 0) throw new IllegalArgumentException(name + " < 0");
+    if (unit == null) throw new NullPointerException("unit == null");
+    long millis = unit.toMillis(duration);
+    if (millis > Integer.MAX_VALUE) throw new IllegalArgumentException(name + " too large.");
+    if (millis == 0 && duration > 0) throw new IllegalArgumentException(name + " too small.");
+    return (int) millis;
+  }
+
+  public static AssertionError assertionError(String message, Exception e) {
+    AssertionError assertionError = new AssertionError(message);
+    try {
+      assertionError.initCause(e);
+    } catch (IllegalStateException ise) {
+      // ignored, shouldn't happen
+    }
+    return assertionError;
+  }
+
+  public static int decodeHexDigit(char c) {
+    if (c >= '0' && c <= '9') return c - '0';
+    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
+    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
+    return -1;
+  }
+
+  /** Decodes an IPv6 address like 1111:2222:3333:4444:5555:6666:7777:8888 or ::1. */
+  private static @Nullable InetAddress decodeIpv6(String input, int pos, int limit) {
+    byte[] address = new byte[16];
+    int b = 0;
+    int compress = -1;
+    int groupOffset = -1;
+
+    for (int i = pos; i < limit; ) {
+      if (b == address.length) return null; // Too many groups.
+
+      // Read a delimiter.
+      if (i + 2 <= limit && input.regionMatches(i, "::", 0, 2)) {
+        // Compression "::" delimiter, which is anywhere in the input, including its prefix.
+        if (compress != -1) return null; // Multiple "::" delimiters.
+        i += 2;
+        b += 2;
+        compress = b;
+        if (i == limit) break;
+      } else if (b != 0) {
+        // Group separator ":" delimiter.
+        if (input.regionMatches(i, ":", 0, 1)) {
+          i++;
+        } else if (input.regionMatches(i, ".", 0, 1)) {
+          // If we see a '.', rewind to the beginning of the previous group and parse as IPv4.
+          if (!decodeIpv4Suffix(input, groupOffset, limit, address, b - 2)) return null;
+          b += 2; // We rewound two bytes and then added four.
+          break;
+        } else {
+          return null; // Wrong delimiter.
+        }
+      }
+
+      // Read a group, one to four hex digits.
+      int value = 0;
+      groupOffset = i;
+      for (; i < limit; i++) {
+        char c = input.charAt(i);
+        int hexDigit = decodeHexDigit(c);
+        if (hexDigit == -1) break;
+        value = (value << 4) + hexDigit;
+      }
+      int groupLength = i - groupOffset;
+      if (groupLength == 0 || groupLength > 4) return null; // Group is the wrong size.
+
+      // We've successfully read a group. Assign its value to our byte array.
+      address[b++] = (byte) ((value >>> 8) & 0xff);
+      address[b++] = (byte) (value & 0xff);
+    }
+
+    // All done. If compression happened, we need to move bytes to the right place in the
+    // address. Here's a sample:
+    //
+    //      input: "1111:2222:3333::7777:8888"
+    //     before: { 11, 11, 22, 22, 33, 33, 00, 00, 77, 77, 88, 88, 00, 00, 00, 00  }
+    //   compress: 6
+    //          b: 10
+    //      after: { 11, 11, 22, 22, 33, 33, 00, 00, 00, 00, 00, 00, 77, 77, 88, 88 }
+    //
+    if (b != address.length) {
+      if (compress == -1) return null; // Address didn't have compression or enough groups.
+      System.arraycopy(address, compress, address, address.length - (b - compress), b - compress);
+      Arrays.fill(address, compress, compress + (address.length - b), (byte) 0);
+    }
+
+    try {
+      return InetAddress.getByAddress(address);
+    } catch (UnknownHostException e) {
+      throw new AssertionError();
+    }
+  }
+
+  /** Decodes an IPv4 address suffix of an IPv6 address, like 1111::5555:6666:192.168.0.1. */
+  private static boolean decodeIpv4Suffix(
+      String input, int pos, int limit, byte[] address, int addressOffset) {
+    int b = addressOffset;
+
+    for (int i = pos; i < limit; ) {
+      if (b == address.length) return false; // Too many groups.
+
+      // Read a delimiter.
+      if (b != addressOffset) {
+        if (input.charAt(i) != '.') return false; // Wrong delimiter.
+        i++;
+      }
+
+      // Read 1 or more decimal digits for a value in 0..255.
+      int value = 0;
+      int groupOffset = i;
+      for (; i < limit; i++) {
+        char c = input.charAt(i);
+        if (c < '0' || c > '9') break;
+        if (value == 0 && groupOffset != i) return false; // Reject unnecessary leading '0's.
+        value = (value * 10) + c - '0';
+        if (value > 255) return false; // Value out of range.
+      }
+      int groupLength = i - groupOffset;
+      if (groupLength == 0) return false; // No digits.
+
+      // We've successfully read a byte.
+      address[b++] = (byte) value;
+    }
+
+    if (b != addressOffset + 4) return false; // Too few groups. We wanted exactly four.
+    return true; // Success.
+  }
+
+  /** Encodes an IPv6 address in canonical form according to RFC 5952. */
+  private static String inet6AddressToAscii(byte[] address) {
+    // Go through the address looking for the longest run of 0s. Each group is 2-bytes.
+    // A run must be longer than one group (section 4.2.2).
+    // If there are multiple equal runs, the first one must be used (section 4.2.3).
+    int longestRunOffset = -1;
+    int longestRunLength = 0;
+    for (int i = 0; i < address.length; i += 2) {
+      int currentRunOffset = i;
+      while (i < 16 && address[i] == 0 && address[i + 1] == 0) {
+        i += 2;
+      }
+      int currentRunLength = i - currentRunOffset;
+      if (currentRunLength > longestRunLength && currentRunLength >= 4) {
+        longestRunOffset = currentRunOffset;
+        longestRunLength = currentRunLength;
+      }
+    }
+
+    // Emit each 2-byte group in hex, separated by ':'. The longest run of zeroes is "::".
+    Buffer result = new Buffer();
+    for (int i = 0; i < address.length; ) {
+      if (i == longestRunOffset) {
+        result.writeByte(':');
+        i += longestRunLength;
+        if (i == 16) result.writeByte(':');
+      } else {
+        if (i > 0) result.writeByte(':');
+        int group = (address[i] & 0xff) << 8 | address[i + 1] & 0xff;
+        result.writeHexadecimalUnsignedLong(group);
+        i += 2;
+      }
+    }
+    return result.readUtf8();
+  }
+
+  public static X509TrustManager platformTrustManager() {
+    try {
+      TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
+          TrustManagerFactory.getDefaultAlgorithm());
+      trustManagerFactory.init((KeyStore) null);
+      TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
+      if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
+        throw new IllegalStateException("Unexpected default trust managers:"
+            + Arrays.toString(trustManagers));
+      }
+      return (X509TrustManager) trustManagers[0];
+    } catch (GeneralSecurityException e) {
+      throw assertionError("No System TLS", e); // The system has no TLS. Just give up.
+    }
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
index 18d4fd9813..d46494d95b 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheInterceptor.java
@@ -125,38 +125,29 @@ public CacheInterceptor(InternalCache cache) {
         .networkResponse(stripBody(networkResponse))
         .build();
 
-    if (HttpHeaders.hasBody(response)) {
-      CacheRequest cacheRequest = maybeCache(response, networkResponse.request(), cache);
-      response = cacheWritingResponse(cacheRequest, response);
-    }
-
-    return response;
-  }
-
-  private static Response stripBody(Response response) {
-    return response != null && response.body() != null
-        ? response.newBuilder().body(null).build()
-        : response;
-  }
-
-  private CacheRequest maybeCache(Response userResponse, Request networkRequest,
-      InternalCache responseCache) throws IOException {
-    if (responseCache == null) return null;
+    if (cache != null) {
+      if (HttpHeaders.hasBody(response) && CacheStrategy.isCacheable(response, networkRequest)) {
+        // Offer this request to the cache.
+        CacheRequest cacheRequest = cache.put(response);
+        return cacheWritingResponse(cacheRequest, response);
+      }
 
-    // Should we cache this response for this request?
-    if (!CacheStrategy.isCacheable(userResponse, networkRequest)) {
       if (HttpMethod.invalidatesCache(networkRequest.method())) {
         try {
-          responseCache.remove(networkRequest);
+          cache.remove(networkRequest);
         } catch (IOException ignored) {
           // The cache cannot be written.
         }
       }
-      return null;
     }
 
-    // Offer this request to the cache.
-    return responseCache.put(userResponse);
+    return response;
+  }
+
+  private static Response stripBody(Response response) {
+    return response != null && response.body() != null
+        ? response.newBuilder().body(null).build()
+        : response;
   }
 
   /**
@@ -216,12 +207,14 @@ private Response cacheWritingResponse(final CacheRequest cacheRequest, Response
       }
     };
 
+    String contentType = response.header("Content-Type");
+    long contentLength = response.body().contentLength();
     return response.newBuilder()
-        .body(new RealResponseBody(response.headers(), Okio.buffer(cacheWritingSource)))
+        .body(new RealResponseBody(contentType, contentLength, Okio.buffer(cacheWritingSource)))
         .build();
   }
 
-  /** Combines cached headers with a network headers as defined by RFC 2616, 13.5.3. */
+  /** Combines cached headers with a network headers as defined by RFC 7234, 4.3.4. */
   private static Headers combine(Headers cachedHeaders, Headers networkHeaders) {
     Headers.Builder result = new Headers.Builder();
 
@@ -231,17 +224,15 @@ private static Headers combine(Headers cachedHeaders, Headers networkHeaders) {
       if ("Warning".equalsIgnoreCase(fieldName) && value.startsWith("1")) {
         continue; // Drop 100-level freshness warnings.
       }
-      if (!isEndToEnd(fieldName) || networkHeaders.get(fieldName) == null) {
+      if (isContentSpecificHeader(fieldName) || !isEndToEnd(fieldName)
+              || networkHeaders.get(fieldName) == null) {
         Internal.instance.addLenient(result, fieldName, value);
       }
     }
 
     for (int i = 0, size = networkHeaders.size(); i < size; i++) {
       String fieldName = networkHeaders.name(i);
-      if ("Content-Length".equalsIgnoreCase(fieldName)) {
-        continue; // Ignore content-length headers of validating responses.
-      }
-      if (isEndToEnd(fieldName)) {
+      if (!isContentSpecificHeader(fieldName) && isEndToEnd(fieldName)) {
         Internal.instance.addLenient(result, fieldName, networkHeaders.value(i));
       }
     }
@@ -263,4 +254,14 @@ static boolean isEndToEnd(String fieldName) {
         && !"Transfer-Encoding".equalsIgnoreCase(fieldName)
         && !"Upgrade".equalsIgnoreCase(fieldName);
   }
+
+  /**
+   * Returns true if {@code fieldName} is content specific and therefore should always be used
+   * from cached headers.
+   */
+  static boolean isContentSpecificHeader(String fieldName) {
+    return "Content-Length".equalsIgnoreCase(fieldName)
+        || "Content-Encoding".equalsIgnoreCase(fieldName)
+        || "Content-Type".equalsIgnoreCase(fieldName);
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
index dae556bb98..3ae1926650 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/CacheStrategy.java
@@ -16,6 +16,7 @@
 package okhttp3.internal.cache;
 
 import java.util.Date;
+import javax.annotation.Nullable;
 import okhttp3.CacheControl;
 import okhttp3.Headers;
 import okhttp3.Request;
@@ -48,10 +49,10 @@
  */
 public final class CacheStrategy {
   /** The request to send on the network, or null if this call doesn't use the network. */
-  public final Request networkRequest;
+  public final @Nullable Request networkRequest;
 
   /** The cached response to return or validate; or null if this call doesn't use a cache. */
-  public final Response cacheResponse;
+  public final @Nullable Response cacheResponse;
 
   CacheStrategy(Request networkRequest, Response cacheResponse) {
     this.networkRequest = networkRequest;
@@ -203,6 +204,11 @@ private CacheStrategy getCandidate() {
         return new CacheStrategy(request, null);
       }
 
+      CacheControl responseCaching = cacheResponse.cacheControl();
+      if (responseCaching.immutable()) {
+        return new CacheStrategy(null, cacheResponse);
+      }
+
       long ageMillis = cacheResponseAge();
       long freshMillis = computeFreshnessLifetime();
 
@@ -216,7 +222,6 @@ private CacheStrategy getCandidate() {
       }
 
       long maxStaleMillis = 0;
-      CacheControl responseCaching = cacheResponse.cacheControl();
       if (!responseCaching.mustRevalidate() && requestCaching.maxStaleSeconds() != -1) {
         maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());
       }
@@ -290,7 +295,7 @@ private long computeFreshnessLifetime() {
 
     /**
      * Returns the current age of the response, in milliseconds. The calculation is specified by RFC
-     * 2616, 13.2.3 Age Calculations.
+     * 7234, 4.2.3 Calculating Age.
      */
     private long cacheResponseAge() {
       long apparentReceivedAge = servedDate != null
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
index 19c2321414..c3fb740e28 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/DiskLruCache.java
@@ -32,6 +32,7 @@
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import javax.annotation.Nullable;
 import okhttp3.internal.Util;
 import okhttp3.internal.io.FileSystem;
 import okhttp3.internal.platform.Platform;
@@ -231,7 +232,13 @@ public synchronized void initialize() throws IOException {
       } catch (IOException journalIsCorrupt) {
         Platform.get().log(WARN, "DiskLruCache " + directory + " is corrupt: "
             + journalIsCorrupt.getMessage() + ", removing", journalIsCorrupt);
+      }
+
+      // The cache is corrupted, attempt to delete the contents of the directory. This can throw and
+      // we'll let that propagate out as it likely means there is a severe filesystem problem.
+      try {
         delete();
+      } finally {
         closed = false;
       }
     }
@@ -448,7 +455,7 @@ public synchronized Snapshot get(String key) throws IOException {
   /**
    * Returns an editor for the entry named {@code key}, or null if another edit is in progress.
    */
-  public Editor edit(String key) throws IOException {
+  public @Nullable Editor edit(String key) throws IOException {
     return edit(key, ANY_SEQUENCE_NUMBER);
   }
 
@@ -799,7 +806,7 @@ public String key() {
      * Returns an editor for this snapshot's entry, or null if either the entry has changed since
      * this snapshot was created or if another edit is in progress.
      */
-    public Editor edit() throws IOException {
+    public @Nullable Editor edit() throws IOException {
       return DiskLruCache.this.edit(key, sequenceNumber);
     }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.java b/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.java
index b10fddb956..561a30507e 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache/FaultHidingSink.java
@@ -24,7 +24,7 @@
 class FaultHidingSink extends ForwardingSink {
   private boolean hasErrors;
 
-  public FaultHidingSink(Sink delegate) {
+  FaultHidingSink(Sink delegate) {
     super(delegate);
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java b/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java
index 70914226c3..b4ce63012f 100644
--- a/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java
+++ b/okhttp/src/main/java/okhttp3/internal/cache2/FileOperator.java
@@ -17,7 +17,6 @@
 
 import java.io.EOFException;
 import java.io.IOException;
-import java.nio.ByteBuffer;
 import java.nio.channels.FileChannel;
 import okio.Buffer;
 import okio.Okio;
@@ -35,13 +34,9 @@
  * </ul>
  */
 final class FileOperator {
-  private static final int BUFFER_SIZE = 8192;
-
-  private final byte[] byteArray = new byte[BUFFER_SIZE];
-  private final ByteBuffer byteBuffer = ByteBuffer.wrap(byteArray);
   private final FileChannel fileChannel;
 
-  public FileOperator(FileChannel fileChannel) {
+  FileOperator(FileChannel fileChannel) {
     this.fileChannel = fileChannel;
   }
 
@@ -50,22 +45,9 @@ public void write(long pos, Buffer source, long byteCount) throws IOException {
     if (byteCount < 0 || byteCount > source.size()) throw new IndexOutOfBoundsException();
 
     while (byteCount > 0L) {
-      try {
-        // Write bytes to the byte[], and tell the ByteBuffer wrapper about 'em.
-        int toWrite = (int) Math.min(BUFFER_SIZE, byteCount);
-        source.read(byteArray, 0, toWrite);
-        byteBuffer.limit(toWrite);
-
-        // Copy bytes from the ByteBuffer to the file.
-        do {
-          int bytesWritten = fileChannel.write(byteBuffer, pos);
-          pos += bytesWritten;
-        } while (byteBuffer.hasRemaining());
-
-        byteCount -= toWrite;
-      } finally {
-        byteBuffer.clear();
-      }
+      long bytesWritten = fileChannel.transferFrom(source, pos, byteCount);
+      pos += bytesWritten;
+      byteCount -= bytesWritten;
     }
   }
 
@@ -78,19 +60,9 @@ public void read(long pos, Buffer sink, long byteCount) throws IOException {
     if (byteCount < 0) throw new IndexOutOfBoundsException();
 
     while (byteCount > 0L) {
-      try {
-        // Read up to byteCount bytes.
-        byteBuffer.limit((int) Math.min(BUFFER_SIZE, byteCount));
-        if (fileChannel.read(byteBuffer, pos) == -1) throw new EOFException();
-        int bytesRead = byteBuffer.position();
-
-        // Write those bytes to sink.
-        sink.write(byteArray, 0, bytesRead);
-        pos += bytesRead;
-        byteCount -= bytesRead;
-      } finally {
-        byteBuffer.clear();
-      }
+      long bytesRead = fileChannel.transferTo(pos, byteCount, sink);
+      pos += bytesRead;
+      byteCount -= bytesRead;
     }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java b/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
index cabd065813..b8a346c03a 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/ConnectInterceptor.java
@@ -39,7 +39,7 @@ public ConnectInterceptor(OkHttpClient client) {
 
     // We need the network to satisfy this request. Possibly for validating a conditional GET.
     boolean doExtensiveHealthChecks = !request.method().equals("GET");
-    HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);
+    HttpCodec httpCodec = streamAllocation.newStream(client, chain, doExtensiveHealthChecks);
     RealConnection connection = streamAllocation.connection();
 
     return realChain.proceed(request, streamAllocation, httpCodec, connection);
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java b/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
index 0b438bfa1f..34a116464d 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/ConnectionSpecSelector.java
@@ -22,6 +22,7 @@
 import java.security.cert.CertificateException;
 import java.util.Arrays;
 import java.util.List;
+import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLProtocolException;
@@ -123,7 +124,9 @@ public boolean connectionFailed(IOException e) {
 
     // On Android, SSLProtocolExceptions can be caused by TLS_FALLBACK_SCSV failures, which means we
     // retry those when we probably should not.
-    return (e instanceof SSLHandshakeException || e instanceof SSLProtocolException);
+    return (e instanceof SSLHandshakeException
+        || e instanceof SSLProtocolException
+        || e instanceof SSLException);
   }
 
   /**
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
index 6ed7806c45..ce089d1864 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RealConnection.java
@@ -29,21 +29,27 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSession;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.Address;
+import okhttp3.Call;
 import okhttp3.CertificatePinner;
 import okhttp3.Connection;
 import okhttp3.ConnectionPool;
 import okhttp3.ConnectionSpec;
+import okhttp3.EventListener;
 import okhttp3.Handshake;
 import okhttp3.HttpUrl;
+import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
 import okhttp3.Protocol;
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.Route;
+import okhttp3.internal.Internal;
 import okhttp3.internal.Util;
 import okhttp3.internal.Version;
 import okhttp3.internal.http.HttpCodec;
@@ -67,6 +73,9 @@
 import static okhttp3.internal.Util.closeQuietly;
 
 public final class RealConnection extends Http2Connection.Listener implements Connection {
+  private static final String NPE_THROW_WITH_NULL = "throw with null exception";
+  private static final int MAX_TUNNEL_ATTEMPTS = 21;
+
   private final ConnectionPool connectionPool;
   private final Route route;
 
@@ -118,8 +127,9 @@ public static RealConnection testConnection(
     return result;
   }
 
-  public void connect(
-      int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) {
+  public void connect(int connectTimeout, int readTimeout, int writeTimeout,
+      int pingIntervalMillis, boolean connectionRetryEnabled, Call call,
+      EventListener eventListener) {
     if (protocol != null) throw new IllegalStateException("already connected");
 
     RouteException routeException = null;
@@ -136,16 +146,26 @@ public void connect(
         throw new RouteException(new UnknownServiceException(
             "CLEARTEXT communication to " + host + " not permitted by network security policy"));
       }
+    } else {
+      if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
+        throw new RouteException(new UnknownServiceException(
+            "H2_PRIOR_KNOWLEDGE cannot be used with HTTPS"));
+      }
     }
 
     while (true) {
       try {
         if (route.requiresTunnel()) {
-          connectTunnel(connectTimeout, readTimeout, writeTimeout);
+          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);
+          if (rawSocket == null) {
+            // We were unable to connect the tunnel but properly closed down our resources.
+            break;
+          }
         } else {
-          connectSocket(connectTimeout, readTimeout);
+          connectSocket(connectTimeout, readTimeout, call, eventListener);
         }
-        establishProtocol(connectionSpecSelector);
+        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);
+        eventListener.connectEnd(call, route.socketAddress(), route.proxy(), protocol);
         break;
       } catch (IOException e) {
         closeQuietly(socket);
@@ -158,6 +178,8 @@ public void connect(
         protocol = null;
         http2Connection = null;
 
+        eventListener.connectFailed(call, route.socketAddress(), route.proxy(), null, e);
+
         if (routeException == null) {
           routeException = new RouteException(e);
         } else {
@@ -170,6 +192,12 @@ public void connect(
       }
     }
 
+    if (route.requiresTunnel() && rawSocket == null) {
+      ProtocolException exception = new ProtocolException("Too many tunnel connections attempted: "
+          + MAX_TUNNEL_ATTEMPTS);
+      throw new RouteException(exception);
+    }
+
     if (http2Connection != null) {
       synchronized (connectionPool) {
         allocationLimit = http2Connection.maxConcurrentStreams();
@@ -181,18 +209,12 @@ public void connect(
    * Does all the work to build an HTTPS connection over a proxy tunnel. The catch here is that a
    * proxy server can issue an auth challenge and then close the connection.
    */
-  private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout)
-      throws IOException {
+  private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout, Call call,
+      EventListener eventListener) throws IOException {
     Request tunnelRequest = createTunnelRequest();
     HttpUrl url = tunnelRequest.url();
-    int attemptedConnections = 0;
-    int maxAttempts = 21;
-    while (true) {
-      if (++attemptedConnections > maxAttempts) {
-        throw new ProtocolException("Too many tunnel connections attempted: " + maxAttempts);
-      }
-
-      connectSocket(connectTimeout, readTimeout);
+    for (int i = 0; i < MAX_TUNNEL_ATTEMPTS; i++) {
+      connectSocket(connectTimeout, readTimeout, call, eventListener);
       tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);
 
       if (tunnelRequest == null) break; // Tunnel successfully created.
@@ -203,11 +225,13 @@ private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout
       rawSocket = null;
       sink = null;
       source = null;
+      eventListener.connectEnd(call, route.socketAddress(), route.proxy(), null);
     }
   }
 
   /** Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket. */
-  private void connectSocket(int connectTimeout, int readTimeout) throws IOException {
+  private void connectSocket(int connectTimeout, int readTimeout, Call call,
+      EventListener eventListener) throws IOException {
     Proxy proxy = route.proxy();
     Address address = route.address();
 
@@ -215,6 +239,7 @@ private void connectSocket(int connectTimeout, int readTimeout) throws IOExcepti
         ? address.socketFactory().createSocket()
         : new Socket(proxy);
 
+    eventListener.connectStart(call, route.socketAddress(), proxy);
     rawSocket.setSoTimeout(readTimeout);
     try {
       Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);
@@ -223,29 +248,55 @@ private void connectSocket(int connectTimeout, int readTimeout) throws IOExcepti
       ce.initCause(e);
       throw ce;
     }
-    source = Okio.buffer(Okio.source(rawSocket));
-    sink = Okio.buffer(Okio.sink(rawSocket));
+
+    // The following try/catch block is a pseudo hacky way to get around a crash on Android 7.0
+    // More details:
+    // https://github.com/square/okhttp/issues/3245
+    // https://android-review.googlesource.com/#/c/271775/
+    try {
+      source = Okio.buffer(Okio.source(rawSocket));
+      sink = Okio.buffer(Okio.sink(rawSocket));
+    } catch (NullPointerException npe) {
+      if (NPE_THROW_WITH_NULL.equals(npe.getMessage())) {
+        throw new IOException(npe);
+      }
+    }
   }
 
-  private void establishProtocol(ConnectionSpecSelector connectionSpecSelector) throws IOException {
+  private void establishProtocol(ConnectionSpecSelector connectionSpecSelector,
+      int pingIntervalMillis, Call call, EventListener eventListener) throws IOException {
     if (route.address().sslSocketFactory() == null) {
-      protocol = Protocol.HTTP_1_1;
+      if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) {
+        socket = rawSocket;
+        protocol = Protocol.H2_PRIOR_KNOWLEDGE;
+        startHttp2(pingIntervalMillis);
+        return;
+      }
+
       socket = rawSocket;
+      protocol = Protocol.HTTP_1_1;
       return;
     }
 
+    eventListener.secureConnectStart(call);
     connectTls(connectionSpecSelector);
+    eventListener.secureConnectEnd(call, handshake);
 
     if (protocol == Protocol.HTTP_2) {
-      socket.setSoTimeout(0); // Framed connection timeouts are set per-stream.
-      http2Connection = new Http2Connection.Builder(true)
-          .socket(socket, route.address().url().host(), source, sink)
-          .listener(this)
-          .build();
-      http2Connection.start();
+      startHttp2(pingIntervalMillis);
     }
   }
 
+  private void startHttp2(int pingIntervalMillis) throws IOException {
+    socket.setSoTimeout(0); // HTTP/2 connection timeouts are set per-stream.
+    http2Connection = new Http2Connection.Builder(true)
+        .socket(socket, route.address().url().host(), source, sink)
+        .listener(this)
+        .pingIntervalMillis(pingIntervalMillis)
+        .build();
+    http2Connection.start();
+  }
+
   private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IOException {
     Address address = route.address();
     SSLSocketFactory sslSocketFactory = address.sslSocketFactory();
@@ -265,10 +316,12 @@ private void connectTls(ConnectionSpecSelector connectionSpecSelector) throws IO
 
       // Force handshake. This can throw!
       sslSocket.startHandshake();
-      Handshake unverifiedHandshake = Handshake.get(sslSocket.getSession());
+      // block for session establishment
+      SSLSession sslSocketSession = sslSocket.getSession();
+      Handshake unverifiedHandshake = Handshake.get(sslSocketSession);
 
       // Verify that the socket's certificates are acceptable for the target host.
-      if (!address.hostnameVerifier().verify(address.url().host(), sslSocket.getSession())) {
+      if (!address.hostnameVerifier().verify(address.url().host(), sslSocketSession)) {
         X509Certificate cert = (X509Certificate) unverifiedHandshake.peerCertificates().get(0);
         throw new SSLPeerUnverifiedException("Hostname " + address.url().host() + " not verified:"
             + "\n    certificate: " + CertificatePinner.pin(cert)
@@ -373,21 +426,74 @@ private Request createTunnelRequest() {
         .build();
   }
 
-  /** Returns true if this connection can carry a stream allocation to {@code address}. */
-  public boolean isEligible(Address address) {
-    return allocations.size() < allocationLimit
-        && address.equals(route().address())
-        && !noNewStreams;
+  /**
+   * Returns true if this connection can carry a stream allocation to {@code address}. If non-null
+   * {@code route} is the resolved route for a connection.
+   */
+  public boolean isEligible(Address address, @Nullable Route route) {
+    // If this connection is not accepting new streams, we're done.
+    if (allocations.size() >= allocationLimit || noNewStreams) return false;
+
+    // If the non-host fields of the address don't overlap, we're done.
+    if (!Internal.instance.equalsNonHost(this.route.address(), address)) return false;
+
+    // If the host exactly matches, we're done: this connection can carry the address.
+    if (address.url().host().equals(this.route().address().url().host())) {
+      return true; // This connection is a perfect match.
+    }
+
+    // At this point we don't have a hostname match. But we still be able to carry the request if
+    // our connection coalescing requirements are met. See also:
+    // https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding
+    // https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/
+
+    // 1. This connection must be HTTP/2.
+    if (http2Connection == null) return false;
+
+    // 2. The routes must share an IP address. This requires us to have a DNS address for both
+    // hosts, which only happens after route planning. We can't coalesce connections that use a
+    // proxy, since proxies don't tell us the origin server's IP address.
+    if (route == null) return false;
+    if (route.proxy().type() != Proxy.Type.DIRECT) return false;
+    if (this.route.proxy().type() != Proxy.Type.DIRECT) return false;
+    if (!this.route.socketAddress().equals(route.socketAddress())) return false;
+
+    // 3. This connection's server certificate's must cover the new host.
+    if (route.address().hostnameVerifier() != OkHostnameVerifier.INSTANCE) return false;
+    if (!supportsUrl(address.url())) return false;
+
+    // 4. Certificate pinning must match the host.
+    try {
+      address.certificatePinner().check(address.url().host(), handshake().peerCertificates());
+    } catch (SSLPeerUnverifiedException e) {
+      return false;
+    }
+
+    return true; // The caller's address can be carried by this connection.
+  }
+
+  public boolean supportsUrl(HttpUrl url) {
+    if (url.port() != route.address().url().port()) {
+      return false; // Port mismatch.
+    }
+
+    if (!url.host().equals(route.address().url().host())) {
+      // We have a host mismatch. But if the certificate matches, we're still good.
+      return handshake != null && OkHostnameVerifier.INSTANCE.verify(
+          url.host(), (X509Certificate) handshake.peerCertificates().get(0));
+    }
+
+    return true; // Success. The URL is supported.
   }
 
-  public HttpCodec newCodec(
-      OkHttpClient client, StreamAllocation streamAllocation) throws SocketException {
+  public HttpCodec newCodec(OkHttpClient client, Interceptor.Chain chain,
+      StreamAllocation streamAllocation) throws SocketException {
     if (http2Connection != null) {
-      return new Http2Codec(client, streamAllocation, http2Connection);
+      return new Http2Codec(client, chain, streamAllocation, http2Connection);
     } else {
-      socket.setSoTimeout(client.readTimeoutMillis());
-      source.timeout().timeout(client.readTimeoutMillis(), MILLISECONDS);
-      sink.timeout().timeout(client.writeTimeoutMillis(), MILLISECONDS);
+      socket.setSoTimeout(chain.readTimeoutMillis());
+      source.timeout().timeout(chain.readTimeoutMillis(), MILLISECONDS);
+      sink.timeout().timeout(chain.writeTimeoutMillis(), MILLISECONDS);
       return new Http1Codec(client, streamAllocation, source, sink);
     }
   }
@@ -395,7 +501,7 @@ public HttpCodec newCodec(
   public RealWebSocket.Streams newWebSocketStreams(final StreamAllocation streamAllocation) {
     return new RealWebSocket.Streams(true, source, sink) {
       @Override public void close() throws IOException {
-        streamAllocation.streamFinished(true, streamAllocation.codec());
+        streamAllocation.streamFinished(true, streamAllocation.codec(), -1L, null);
       }
     };
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java
index 1cc3f311b9..d0c1a9d79e 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteDatabase.java
@@ -33,7 +33,7 @@ public synchronized void failed(Route failedRoute) {
     failedRoutes.add(failedRoute);
   }
 
-  /** Records success connecting to {@code failedRoute}. */
+  /** Records success connecting to {@code route}. */
   public synchronized void connected(Route route) {
     failedRoutes.remove(route);
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java
index 5f50576611..4ba0168621 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteException.java
@@ -16,48 +16,33 @@
 package okhttp3.internal.connection;
 
 import java.io.IOException;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
+
+import static okhttp3.internal.Util.addSuppressedIfPossible;
 
 /**
  * An exception thrown to indicate a problem connecting via a single Route. Multiple attempts may
  * have been made with alternative protocols, none of which were successful.
  */
 public final class RouteException extends RuntimeException {
-  private static final Method addSuppressedExceptionMethod;
-
-  static {
-    Method m;
-    try {
-      m = Throwable.class.getDeclaredMethod("addSuppressed", Throwable.class);
-    } catch (Exception e) {
-      m = null;
-    }
-    addSuppressedExceptionMethod = m;
-  }
-
+  private IOException firstException;
   private IOException lastException;
 
   public RouteException(IOException cause) {
     super(cause);
+    firstException = cause;
     lastException = cause;
   }
 
+  public IOException getFirstConnectException() {
+    return firstException;
+  }
+
   public IOException getLastConnectException() {
     return lastException;
   }
 
   public void addConnectException(IOException e) {
-    addSuppressedIfPossible(e, lastException);
+    addSuppressedIfPossible(firstException, e);
     lastException = e;
   }
-
-  private void addSuppressedIfPossible(IOException e, IOException suppressed) {
-    if (addSuppressedExceptionMethod != null) {
-      try {
-        addSuppressedExceptionMethod.invoke(e, suppressed);
-      } catch (InvocationTargetException | IllegalAccessException ignored) {
-      }
-    }
-  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java b/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
index 7e5d08d28b..40752ce23d 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/RouteSelector.java
@@ -21,11 +21,14 @@
 import java.net.Proxy;
 import java.net.SocketAddress;
 import java.net.SocketException;
+import java.net.UnknownHostException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.NoSuchElementException;
 import okhttp3.Address;
+import okhttp3.Call;
+import okhttp3.EventListener;
 import okhttp3.HttpUrl;
 import okhttp3.Route;
 import okhttp3.internal.Util;
@@ -37,10 +40,8 @@
 public final class RouteSelector {
   private final Address address;
   private final RouteDatabase routeDatabase;
-
-  /* The most recently attempted route. */
-  private Proxy lastProxy;
-  private InetSocketAddress lastInetSocketAddress;
+  private final Call call;
+  private final EventListener eventListener;
 
   /* State for negotiating the next proxy to use. */
   private List<Proxy> proxies = Collections.emptyList();
@@ -48,48 +49,60 @@
 
   /* State for negotiating the next socket address to use. */
   private List<InetSocketAddress> inetSocketAddresses = Collections.emptyList();
-  private int nextInetSocketAddressIndex;
 
   /* State for negotiating failed routes */
   private final List<Route> postponedRoutes = new ArrayList<>();
 
-  public RouteSelector(Address address, RouteDatabase routeDatabase) {
+  public RouteSelector(Address address, RouteDatabase routeDatabase, Call call,
+      EventListener eventListener) {
     this.address = address;
     this.routeDatabase = routeDatabase;
+    this.call = call;
+    this.eventListener = eventListener;
 
     resetNextProxy(address.url(), address.proxy());
   }
 
   /**
-   * Returns true if there's another route to attempt. Every address has at least one route.
+   * Returns true if there's another set of routes to attempt. Every address has at least one route.
    */
   public boolean hasNext() {
-    return hasNextInetSocketAddress()
-        || hasNextProxy()
-        || hasNextPostponed();
+    return hasNextProxy() || !postponedRoutes.isEmpty();
   }
 
-  public Route next() throws IOException {
-    // Compute the next route to attempt.
-    if (!hasNextInetSocketAddress()) {
-      if (!hasNextProxy()) {
-        if (!hasNextPostponed()) {
-          throw new NoSuchElementException();
+  public Selection next() throws IOException {
+    if (!hasNext()) {
+      throw new NoSuchElementException();
+    }
+
+    // Compute the next set of routes to attempt.
+    List<Route> routes = new ArrayList<>();
+    while (hasNextProxy()) {
+      // Postponed routes are always tried last. For example, if we have 2 proxies and all the
+      // routes for proxy1 should be postponed, we'll move to proxy2. Only after we've exhausted
+      // all the good routes will we attempt the postponed routes.
+      Proxy proxy = nextProxy();
+      for (int i = 0, size = inetSocketAddresses.size(); i < size; i++) {
+        Route route = new Route(address, proxy, inetSocketAddresses.get(i));
+        if (routeDatabase.shouldPostpone(route)) {
+          postponedRoutes.add(route);
+        } else {
+          routes.add(route);
         }
-        return nextPostponed();
       }
-      lastProxy = nextProxy();
+
+      if (!routes.isEmpty()) {
+        break;
+      }
     }
-    lastInetSocketAddress = nextInetSocketAddress();
 
-    Route route = new Route(address, lastProxy, lastInetSocketAddress);
-    if (routeDatabase.shouldPostpone(route)) {
-      postponedRoutes.add(route);
-      // We will only recurse in order to skip previously failed routes. They will be tried last.
-      return next();
+    if (routes.isEmpty()) {
+      // We've exhausted all Proxies so fallback to the postponed routes.
+      routes.addAll(postponedRoutes);
+      postponedRoutes.clear();
     }
 
-    return route;
+    return new Selection(routes);
   }
 
   /**
@@ -166,15 +179,21 @@ private void resetNextInetSocketAddress(Proxy proxy) throws IOException {
     if (proxy.type() == Proxy.Type.SOCKS) {
       inetSocketAddresses.add(InetSocketAddress.createUnresolved(socketHost, socketPort));
     } else {
+      eventListener.dnsStart(call, socketHost);
+
       // Try each address for best behavior in mixed IPv4/IPv6 environments.
       List<InetAddress> addresses = address.dns().lookup(socketHost);
+      if (addresses.isEmpty()) {
+        throw new UnknownHostException(address.dns() + " returned no addresses for " + socketHost);
+      }
+
+      eventListener.dnsEnd(call, socketHost, addresses);
+
       for (int i = 0, size = addresses.size(); i < size; i++) {
         InetAddress inetAddress = addresses.get(i);
         inetSocketAddresses.add(new InetSocketAddress(inetAddress, socketPort));
       }
     }
-
-    nextInetSocketAddressIndex = 0;
   }
 
   /**
@@ -195,27 +214,28 @@ static String getHostString(InetSocketAddress socketAddress) {
     return address.getHostAddress();
   }
 
-  /** Returns true if there's another socket address to try. */
-  private boolean hasNextInetSocketAddress() {
-    return nextInetSocketAddressIndex < inetSocketAddresses.size();
-  }
+  /** A set of selected Routes. */
+  public static final class Selection {
+    private final List<Route> routes;
+    private int nextRouteIndex = 0;
 
-  /** Returns the next socket address to try. */
-  private InetSocketAddress nextInetSocketAddress() throws IOException {
-    if (!hasNextInetSocketAddress()) {
-      throw new SocketException("No route to " + address.url().host()
-          + "; exhausted inet socket addresses: " + inetSocketAddresses);
+    Selection(List<Route> routes) {
+      this.routes = routes;
     }
-    return inetSocketAddresses.get(nextInetSocketAddressIndex++);
-  }
 
-  /** Returns true if there is another postponed route to try. */
-  private boolean hasNextPostponed() {
-    return !postponedRoutes.isEmpty();
-  }
+    public boolean hasNext() {
+      return nextRouteIndex < routes.size();
+    }
 
-  /** Returns the next postponed route to try. */
-  private Route nextPostponed() {
-    return postponedRoutes.remove(0);
+    public Route next() {
+      if (!hasNext()) {
+        throw new NoSuchElementException();
+      }
+      return routes.get(nextRouteIndex++);
+    }
+
+    public List<Route> getAll() {
+      return new ArrayList<>(routes);
+    }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
index 4b95dff8b0..243a1e82f1 100644
--- a/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
+++ b/okhttp/src/main/java/okhttp3/internal/connection/StreamAllocation.java
@@ -15,12 +15,17 @@
  */
 package okhttp3.internal.connection;
 
-import java.io.Closeable;
 import java.io.IOException;
 import java.lang.ref.Reference;
 import java.lang.ref.WeakReference;
+import java.net.Socket;
+import java.util.List;
 import okhttp3.Address;
+import okhttp3.Call;
+import okhttp3.Connection;
 import okhttp3.ConnectionPool;
+import okhttp3.EventListener;
+import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
 import okhttp3.Route;
 import okhttp3.internal.Internal;
@@ -71,35 +76,44 @@
  */
 public final class StreamAllocation {
   public final Address address;
+  private RouteSelector.Selection routeSelection;
   private Route route;
   private final ConnectionPool connectionPool;
+  public final Call call;
+  public final EventListener eventListener;
   private final Object callStackTrace;
 
   // State guarded by connectionPool.
   private final RouteSelector routeSelector;
   private int refusedStreamCount;
   private RealConnection connection;
+  private boolean reportedAcquired;
   private boolean released;
   private boolean canceled;
   private HttpCodec codec;
 
-  public StreamAllocation(ConnectionPool connectionPool, Address address, Object callStackTrace) {
+  public StreamAllocation(ConnectionPool connectionPool, Address address, Call call,
+      EventListener eventListener, Object callStackTrace) {
     this.connectionPool = connectionPool;
     this.address = address;
-    this.routeSelector = new RouteSelector(address, routeDatabase());
+    this.call = call;
+    this.eventListener = eventListener;
+    this.routeSelector = new RouteSelector(address, routeDatabase(), call, eventListener);
     this.callStackTrace = callStackTrace;
   }
 
-  public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) {
-    int connectTimeout = client.connectTimeoutMillis();
-    int readTimeout = client.readTimeoutMillis();
-    int writeTimeout = client.writeTimeoutMillis();
+  public HttpCodec newStream(
+      OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) {
+    int connectTimeout = chain.connectTimeoutMillis();
+    int readTimeout = chain.readTimeoutMillis();
+    int writeTimeout = chain.writeTimeoutMillis();
+    int pingIntervalMillis = client.pingIntervalMillis();
     boolean connectionRetryEnabled = client.retryOnConnectionFailure();
 
     try {
       RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,
-          writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);
-      HttpCodec resultCodec = resultConnection.newCodec(client, this);
+          writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);
+      HttpCodec resultCodec = resultConnection.newCodec(client, chain, this);
 
       synchronized (connectionPool) {
         codec = resultCodec;
@@ -115,11 +129,11 @@ public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks)
    * until a healthy connection is found.
    */
   private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,
-      int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)
-      throws IOException {
+      int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled,
+      boolean doExtensiveHealthChecks) throws IOException {
     while (true) {
       RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,
-          connectionRetryEnabled);
+          pingIntervalMillis, connectionRetryEnabled);
 
       // If this is a brand new connection, we can skip the extensive health checks.
       synchronized (connectionPool) {
@@ -144,67 +158,147 @@ private RealConnection findHealthyConnection(int connectTimeout, int readTimeout
    * then the pool, finally building a new connection.
    */
   private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,
-      boolean connectionRetryEnabled) throws IOException {
-    Route selectedRoute;
+      int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException {
+    boolean foundPooledConnection = false;
+    RealConnection result = null;
+    Route selectedRoute = null;
+    Connection releasedConnection;
+    Socket toClose;
     synchronized (connectionPool) {
       if (released) throw new IllegalStateException("released");
       if (codec != null) throw new IllegalStateException("codec != null");
       if (canceled) throw new IOException("Canceled");
 
-      // Attempt to use an already-allocated connection.
-      RealConnection allocatedConnection = this.connection;
-      if (allocatedConnection != null && !allocatedConnection.noNewStreams) {
-        return allocatedConnection;
+      // Attempt to use an already-allocated connection. We need to be careful here because our
+      // already-allocated connection may have been restricted from creating new streams.
+      releasedConnection = this.connection;
+      toClose = releaseIfNoNewStreams();
+      if (this.connection != null) {
+        // We had an already-allocated connection and it's good.
+        result = this.connection;
+        releasedConnection = null;
+      }
+      if (!reportedAcquired) {
+        // If the connection was never reported acquired, don't report it as released!
+        releasedConnection = null;
       }
 
-      // Attempt to get a connection from the pool.
-      Internal.instance.get(connectionPool, address, this);
-      if (connection != null) {
-        return connection;
+      if (result == null) {
+        // Attempt to get a connection from the pool.
+        Internal.instance.get(connectionPool, address, this, null);
+        if (connection != null) {
+          foundPooledConnection = true;
+          result = connection;
+        } else {
+          selectedRoute = route;
+        }
       }
+    }
+    closeQuietly(toClose);
 
-      selectedRoute = route;
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
+    }
+    if (foundPooledConnection) {
+      eventListener.connectionAcquired(call, result);
+    }
+    if (result != null) {
+      // If we found an already-allocated or pooled connection, we're done.
+      return result;
     }
 
-    // If we need a route, make one. This is a blocking operation.
-    if (selectedRoute == null) {
-      selectedRoute = routeSelector.next();
+    // If we need a route selection, make one. This is a blocking operation.
+    boolean newRouteSelection = false;
+    if (selectedRoute == null && (routeSelection == null || !routeSelection.hasNext())) {
+      newRouteSelection = true;
+      routeSelection = routeSelector.next();
     }
 
-    // Create a connection and assign it to this allocation immediately. This makes it possible for
-    // an asynchronous cancel() to interrupt the handshake we're about to do.
-    RealConnection result;
     synchronized (connectionPool) {
-      route = selectedRoute;
-      refusedStreamCount = 0;
-      result = new RealConnection(connectionPool, selectedRoute);
-      acquire(result);
       if (canceled) throw new IOException("Canceled");
+
+      if (newRouteSelection) {
+        // Now that we have a set of IP addresses, make another attempt at getting a connection from
+        // the pool. This could match due to connection coalescing.
+        List<Route> routes = routeSelection.getAll();
+        for (int i = 0, size = routes.size(); i < size; i++) {
+          Route route = routes.get(i);
+          Internal.instance.get(connectionPool, address, this, route);
+          if (connection != null) {
+            foundPooledConnection = true;
+            result = connection;
+            this.route = route;
+            break;
+          }
+        }
+      }
+
+      if (!foundPooledConnection) {
+        if (selectedRoute == null) {
+          selectedRoute = routeSelection.next();
+        }
+
+        // Create a connection and assign it to this allocation immediately. This makes it possible
+        // for an asynchronous cancel() to interrupt the handshake we're about to do.
+        route = selectedRoute;
+        refusedStreamCount = 0;
+        result = new RealConnection(connectionPool, selectedRoute);
+        acquire(result, false);
+      }
+    }
+
+    // If we found a pooled connection on the 2nd time around, we're done.
+    if (foundPooledConnection) {
+      eventListener.connectionAcquired(call, result);
+      return result;
     }
 
     // Do TCP + TLS handshakes. This is a blocking operation.
-    result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);
+    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis,
+        connectionRetryEnabled, call, eventListener);
     routeDatabase().connected(result.route());
 
-    Closeable closeable = null;
+    Socket socket = null;
     synchronized (connectionPool) {
+      reportedAcquired = true;
+
       // Pool the connection.
       Internal.instance.put(connectionPool, result);
 
       // If another multiplexed connection to the same address was created concurrently, then
       // release this connection and acquire that one.
       if (result.isMultiplexed()) {
-        closeable = Internal.instance.deduplicate(connectionPool, address, this);
+        socket = Internal.instance.deduplicate(connectionPool, address, this);
         result = connection;
       }
     }
-    closeQuietly(closeable);
+    closeQuietly(socket);
 
+    eventListener.connectionAcquired(call, result);
     return result;
   }
 
-  public void streamFinished(boolean noNewStreams, HttpCodec codec) {
-    Closeable closeable;
+  /**
+   * Releases the currently held connection and returns a socket to close if the held connection
+   * restricts new streams from being created. With HTTP/2 multiple requests share the same
+   * connection so it's possible that our connection is restricted from creating new streams during
+   * a follow-up request.
+   */
+  private Socket releaseIfNoNewStreams() {
+    assert (Thread.holdsLock(connectionPool));
+    RealConnection allocatedConnection = this.connection;
+    if (allocatedConnection != null && allocatedConnection.noNewStreams) {
+      return deallocate(false, false, true);
+    }
+    return null;
+  }
+
+  public void streamFinished(boolean noNewStreams, HttpCodec codec, long bytesRead, IOException e) {
+    eventListener.responseBodyEnd(call, bytesRead);
+
+    Socket socket;
+    Connection releasedConnection;
+    boolean callEnd;
     synchronized (connectionPool) {
       if (codec == null || codec != this.codec) {
         throw new IllegalStateException("expected " + this.codec + " but was " + codec);
@@ -212,9 +306,21 @@ public void streamFinished(boolean noNewStreams, HttpCodec codec) {
       if (!noNewStreams) {
         connection.successCount++;
       }
-      closeable = deallocate(noNewStreams, false, true);
+      releasedConnection = connection;
+      socket = deallocate(noNewStreams, false, true);
+      if (connection != null) releasedConnection = null;
+      callEnd = this.released;
+    }
+    closeQuietly(socket);
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
+    }
+
+    if (e != null) {
+      eventListener.callFailed(call, e);
+    } else if (callEnd) {
+      eventListener.callEnd(call);
     }
-    closeQuietly(closeable);
   }
 
   public HttpCodec codec() {
@@ -227,25 +333,42 @@ private RouteDatabase routeDatabase() {
     return Internal.instance.routeDatabase(connectionPool);
   }
 
+  public Route route() {
+    return route;
+  }
+
   public synchronized RealConnection connection() {
     return connection;
   }
 
   public void release() {
-    Closeable closeable;
+    Socket socket;
+    Connection releasedConnection;
     synchronized (connectionPool) {
-      closeable = deallocate(false, true, false);
+      releasedConnection = connection;
+      socket = deallocate(false, true, false);
+      if (connection != null) releasedConnection = null;
+    }
+    closeQuietly(socket);
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
+      eventListener.callEnd(call);
     }
-    closeQuietly(closeable);
   }
 
   /** Forbid new streams from being created on the connection that hosts this allocation. */
   public void noNewStreams() {
-    Closeable closeable;
+    Socket socket;
+    Connection releasedConnection;
     synchronized (connectionPool) {
-      closeable = deallocate(true, false, false);
+      releasedConnection = connection;
+      socket = deallocate(true, false, false);
+      if (connection != null) releasedConnection = null;
+    }
+    closeQuietly(socket);
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
     }
-    closeQuietly(closeable);
   }
 
   /**
@@ -255,7 +378,7 @@ public void noNewStreams() {
    * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
    * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
    */
-  private Closeable deallocate(boolean noNewStreams, boolean released, boolean streamFinished) {
+  private Socket deallocate(boolean noNewStreams, boolean released, boolean streamFinished) {
     assert (Thread.holdsLock(connectionPool));
 
     if (streamFinished) {
@@ -264,7 +387,7 @@ private Closeable deallocate(boolean noNewStreams, boolean released, boolean str
     if (released) {
       this.released = true;
     }
-    Closeable closeable = null;
+    Socket socket = null;
     if (connection != null) {
       if (noNewStreams) {
         connection.noNewStreams = true;
@@ -274,13 +397,13 @@ private Closeable deallocate(boolean noNewStreams, boolean released, boolean str
         if (connection.allocations.isEmpty()) {
           connection.idleAtNanos = System.nanoTime();
           if (Internal.instance.connectionBecameIdle(connectionPool, connection)) {
-            closeable = connection.socket();
+            socket = connection.socket();
           }
         }
         connection = null;
       }
     }
-    return closeable;
+    return socket;
   }
 
   public void cancel() {
@@ -299,18 +422,22 @@ public void cancel() {
   }
 
   public void streamFailed(IOException e) {
-    Closeable closeable;
+    Socket socket;
+    Connection releasedConnection;
     boolean noNewStreams = false;
 
     synchronized (connectionPool) {
       if (e instanceof StreamResetException) {
-        StreamResetException streamResetException = (StreamResetException) e;
-        if (streamResetException.errorCode == ErrorCode.REFUSED_STREAM) {
+        ErrorCode errorCode = ((StreamResetException) e).errorCode;
+        if (errorCode == ErrorCode.REFUSED_STREAM) {
+          // Retry REFUSED_STREAM errors once on the same connection.
           refusedStreamCount++;
-        }
-        // On HTTP/2 stream errors, retry REFUSED_STREAM errors once on the same connection. All
-        // other errors must be retried on a new connection.
-        if (streamResetException.errorCode != ErrorCode.REFUSED_STREAM || refusedStreamCount > 1) {
+          if (refusedStreamCount > 1) {
+            noNewStreams = true;
+            route = null;
+          }
+        } else if (errorCode != ErrorCode.CANCEL) {
+          // Keep the connection for CANCEL errors. Everything else wants a fresh connection.
           noNewStreams = true;
           route = null;
         }
@@ -326,21 +453,27 @@ public void streamFailed(IOException e) {
           route = null;
         }
       }
-      closeable = deallocate(noNewStreams, false, true);
+      releasedConnection = connection;
+      socket = deallocate(noNewStreams, false, true);
+      if (connection != null || !reportedAcquired) releasedConnection = null;
     }
 
-    closeQuietly(closeable);
+    closeQuietly(socket);
+    if (releasedConnection != null) {
+      eventListener.connectionReleased(call, releasedConnection);
+    }
   }
 
   /**
    * Use this allocation to hold {@code connection}. Each call to this must be paired with a call to
    * {@link #release} on the same connection.
    */
-  public void acquire(RealConnection connection) {
+  public void acquire(RealConnection connection, boolean reportedAcquired) {
     assert (Thread.holdsLock(connectionPool));
     if (this.connection != null) throw new IllegalStateException();
 
     this.connection = connection;
+    this.reportedAcquired = reportedAcquired;
     connection.allocations.add(new StreamAllocationReference(this, callStackTrace));
   }
 
@@ -364,23 +497,25 @@ private void release(RealConnection connection) {
    * <p>Returns a closeable that the caller should pass to {@link Util#closeQuietly} upon completion
    * of the synchronized block. (We don't do I/O while synchronized on the connection pool.)
    */
-  public Closeable releaseAndAcquire(RealConnection newConnection) {
+  public Socket releaseAndAcquire(RealConnection newConnection) {
     assert (Thread.holdsLock(connectionPool));
     if (codec != null || connection.allocations.size() != 1) throw new IllegalStateException();
 
     // Release the old connection.
     Reference<StreamAllocation> onlyAllocation = connection.allocations.get(0);
-    Closeable closeable = deallocate(true, false, false);
+    Socket socket = deallocate(true, false, false);
 
     // Acquire the new connection.
     this.connection = newConnection;
     newConnection.allocations.add(onlyAllocation);
 
-    return closeable;
+    return socket;
   }
 
   public boolean hasMoreRoutes() {
-    return route != null || routeSelector.hasNext();
+    return route != null
+        || (routeSelection != null && routeSelection.hasNext())
+        || routeSelector.hasNext();
   }
 
   @Override public String toString() {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
index 54b561da88..c10dc34cdc 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/BridgeInterceptor.java
@@ -106,7 +106,8 @@ public BridgeInterceptor(CookieJar cookieJar) {
           .removeAll("Content-Length")
           .build();
       responseBuilder.headers(strippedHeaders);
-      responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));
+      String contentType = networkResponse.header("Content-Type");
+      responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody)));
     }
 
     return responseBuilder.build();
diff --git a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
index f7c0e5a561..62531aa514 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/CallServerInterceptor.java
@@ -21,8 +21,11 @@
 import okhttp3.Request;
 import okhttp3.Response;
 import okhttp3.internal.Util;
+import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.StreamAllocation;
+import okio.Buffer;
 import okio.BufferedSink;
+import okio.ForwardingSink;
 import okio.Okio;
 import okio.Sink;
 
@@ -35,35 +38,53 @@ public CallServerInterceptor(boolean forWebSocket) {
   }
 
   @Override public Response intercept(Chain chain) throws IOException {
-    HttpCodec httpCodec = ((RealInterceptorChain) chain).httpStream();
-    StreamAllocation streamAllocation = ((RealInterceptorChain) chain).streamAllocation();
-    Request request = chain.request();
+    RealInterceptorChain realChain = (RealInterceptorChain) chain;
+    HttpCodec httpCodec = realChain.httpStream();
+    StreamAllocation streamAllocation = realChain.streamAllocation();
+    RealConnection connection = (RealConnection) realChain.connection();
+    Request request = realChain.request();
 
     long sentRequestMillis = System.currentTimeMillis();
+
+    realChain.eventListener().requestHeadersStart(realChain.call());
     httpCodec.writeRequestHeaders(request);
+    realChain.eventListener().requestHeadersEnd(realChain.call(), request);
 
     Response.Builder responseBuilder = null;
     if (HttpMethod.permitsRequestBody(request.method()) && request.body() != null) {
       // If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100
-      // Continue" response before transmitting the request body. If we don't get that, return what
-      // we did get (such as a 4xx response) without ever transmitting the request body.
+      // Continue" response before transmitting the request body. If we don't get that, return
+      // what we did get (such as a 4xx response) without ever transmitting the request body.
       if ("100-continue".equalsIgnoreCase(request.header("Expect"))) {
         httpCodec.flushRequest();
+        realChain.eventListener().responseHeadersStart(realChain.call());
         responseBuilder = httpCodec.readResponseHeaders(true);
       }
 
-      // Write the request body, unless an "Expect: 100-continue" expectation failed.
       if (responseBuilder == null) {
-        Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());
+        // Write the request body if the "Expect: 100-continue" expectation was met.
+        realChain.eventListener().requestBodyStart(realChain.call());
+        long contentLength = request.body().contentLength();
+        CountingSink requestBodyOut =
+            new CountingSink(httpCodec.createRequestBody(request, contentLength));
         BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);
+
         request.body().writeTo(bufferedRequestBody);
         bufferedRequestBody.close();
+        realChain.eventListener()
+            .requestBodyEnd(realChain.call(), requestBodyOut.successfulCount);
+      } else if (!connection.isMultiplexed()) {
+        // If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection
+        // from being reused. Otherwise we're still obligated to transmit the request body to
+        // leave the connection in a consistent state.
+        streamAllocation.noNewStreams();
       }
     }
 
     httpCodec.finishRequest();
 
     if (responseBuilder == null) {
+      realChain.eventListener().responseHeadersStart(realChain.call());
       responseBuilder = httpCodec.readResponseHeaders(false);
     }
 
@@ -75,6 +96,24 @@ public CallServerInterceptor(boolean forWebSocket) {
         .build();
 
     int code = response.code();
+    if (code == 100) {
+      // server sent a 100-continue even though we did not request one.
+      // try again to read the actual response
+      responseBuilder = httpCodec.readResponseHeaders(false);
+
+      response = responseBuilder
+              .request(request)
+              .handshake(streamAllocation.connection().handshake())
+              .sentRequestAtMillis(sentRequestMillis)
+              .receivedResponseAtMillis(System.currentTimeMillis())
+              .build();
+
+      code = response.code();
+    }
+
+    realChain.eventListener()
+            .responseHeadersEnd(realChain.call(), response);
+
     if (forWebSocket && code == 101) {
       // Connection is upgrading, but we need to ensure interceptors see a non-null response body.
       response = response.newBuilder()
@@ -98,4 +137,17 @@ public CallServerInterceptor(boolean forWebSocket) {
 
     return response;
   }
+
+  static final class CountingSink extends ForwardingSink {
+    long successfulCount;
+
+    CountingSink(Sink delegate) {
+      super(delegate);
+    }
+
+    @Override public void write(Buffer source, long byteCount) throws IOException {
+      super.write(source, byteCount);
+      successfulCount += byteCount;
+    }
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpDate.java b/okhttp/src/main/java/okhttp3/internal/http/HttpDate.java
index 2991dd7b51..6df2cfd2ec 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpDate.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpDate.java
@@ -37,7 +37,7 @@
   private static final ThreadLocal<DateFormat> STANDARD_DATE_FORMAT =
       new ThreadLocal<DateFormat>() {
         @Override protected DateFormat initialValue() {
-          // RFC 2616 specified: RFC 822, updated by RFC 1123 format with fixed GMT.
+          // Date format specified by RFC 7231 section 7.1.1.1.
           DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss 'GMT'", Locale.US);
           rfc1123.setLenient(false);
           rfc1123.setTimeZone(UTC);
@@ -90,7 +90,7 @@ public static Date parse(String value) {
         if (format == null) {
           format = new SimpleDateFormat(BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS[i], Locale.US);
           // Set the timezone to use when interpreting formats that don't have a timezone. GMT is
-          // specified by RFC 2616.
+          // specified by RFC 7231.
           format.setTimeZone(UTC);
           BROWSER_COMPATIBLE_DATE_FORMATS[i] = format;
         }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
index 0ce0d07858..a1d6712906 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpHeaders.java
@@ -29,6 +29,7 @@
 import okhttp3.HttpUrl;
 import okhttp3.Request;
 import okhttp3.Response;
+import okhttp3.internal.Util;
 
 import static java.net.HttpURLConnection.HTTP_NOT_MODIFIED;
 import static java.net.HttpURLConnection.HTTP_NO_CONTENT;
@@ -143,7 +144,7 @@ public static Headers varyHeaders(Headers requestHeaders, Headers responseHeader
   }
 
   /**
-   * Parse RFC 2617 challenges, also wrong ordered ones.
+   * Parse RFC 7617 challenges, also wrong ordered ones.
    * This API is only interested in the scheme name and realm.
    */
   public static List<Challenge> parseChallenges(Headers responseHeaders, String challengeHeader) {
@@ -158,17 +159,38 @@ public static Headers varyHeaders(Headers requestHeaders, Headers responseHeader
       int index = header.indexOf(' ');
       if (index == -1) continue;
 
+      String scheme = header.substring(0, index);
+      String realm = null;
+      String charset = null;
+
       Matcher matcher = PARAMETER.matcher(header);
       for (int i = index; matcher.find(i); i = matcher.end()) {
         if (header.regionMatches(true, matcher.start(1), "realm", 0, 5)) {
-          String scheme = header.substring(0, index);
-          String realm = matcher.group(3);
-          if (realm != null) {
-            challenges.add(new Challenge(scheme, realm));
-            break;
-          }
+          realm = matcher.group(3);
+        } else if (header.regionMatches(true, matcher.start(1), "charset", 0, 7)) {
+          charset = matcher.group(3);
+        }
+
+        if (realm != null && charset != null) {
+          break;
         }
       }
+
+      // "realm" is required.
+      if (realm == null) continue;
+
+      Challenge challenge = new Challenge(scheme, realm);
+
+      // If a charset is provided, RFC 7617 says it must be "UTF-8".
+      if (charset != null) {
+        if (charset.equalsIgnoreCase("UTF-8")) {
+          challenge = challenge.withCharset(Util.UTF_8);
+        } else {
+          continue;
+        }
+      }
+
+      challenges.add(challenge);
     }
     return challenges;
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java b/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java
index e10fa88a77..da45901512 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/HttpMethod.java
@@ -33,12 +33,7 @@ public static boolean requiresRequestBody(String method) {
   }
 
   public static boolean permitsRequestBody(String method) {
-    return requiresRequestBody(method)
-        || method.equals("OPTIONS")
-        || method.equals("DELETE")    // Permitted as spec is ambiguous.
-        || method.equals("PROPFIND")  // (WebDAV) without body: request <allprop/>
-        || method.equals("MKCOL")     // (WebDAV) may contain a body, but behaviour is unspecified
-        || method.equals("LOCK");     // (WebDAV) body: create lock, without body: refresh lock
+    return !(method.equals("GET") || method.equals("HEAD"));
   }
 
   public static boolean redirectsWithBody(String method) {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
index d5326c64f5..52f9880892 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealInterceptorChain.java
@@ -17,13 +17,18 @@
 
 import java.io.IOException;
 import java.util.List;
+import java.util.concurrent.TimeUnit;
+import okhttp3.Call;
 import okhttp3.Connection;
-import okhttp3.HttpUrl;
+import okhttp3.EventListener;
 import okhttp3.Interceptor;
 import okhttp3.Request;
 import okhttp3.Response;
+import okhttp3.internal.connection.RealConnection;
 import okhttp3.internal.connection.StreamAllocation;
 
+import static okhttp3.internal.Util.checkDuration;
+
 /**
  * A concrete interceptor chain that carries the entire interceptor chain: all application
  * interceptors, the OkHttp core, all network interceptors, and finally the network caller.
@@ -32,25 +37,66 @@
   private final List<Interceptor> interceptors;
   private final StreamAllocation streamAllocation;
   private final HttpCodec httpCodec;
-  private final Connection connection;
+  private final RealConnection connection;
   private final int index;
   private final Request request;
+  private final Call call;
+  private final EventListener eventListener;
+  private final int connectTimeout;
+  private final int readTimeout;
+  private final int writeTimeout;
   private int calls;
 
   public RealInterceptorChain(List<Interceptor> interceptors, StreamAllocation streamAllocation,
-      HttpCodec httpCodec, Connection connection, int index, Request request) {
+      HttpCodec httpCodec, RealConnection connection, int index, Request request, Call call,
+      EventListener eventListener, int connectTimeout, int readTimeout, int writeTimeout) {
     this.interceptors = interceptors;
     this.connection = connection;
     this.streamAllocation = streamAllocation;
     this.httpCodec = httpCodec;
     this.index = index;
     this.request = request;
+    this.call = call;
+    this.eventListener = eventListener;
+    this.connectTimeout = connectTimeout;
+    this.readTimeout = readTimeout;
+    this.writeTimeout = writeTimeout;
   }
 
   @Override public Connection connection() {
     return connection;
   }
 
+  @Override public int connectTimeoutMillis() {
+    return connectTimeout;
+  }
+
+  @Override public Interceptor.Chain withConnectTimeout(int timeout, TimeUnit unit) {
+    int millis = checkDuration("timeout", timeout, unit);
+    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
+        request, call, eventListener, millis, readTimeout, writeTimeout);
+  }
+
+  @Override public int readTimeoutMillis() {
+    return readTimeout;
+  }
+
+  @Override public Interceptor.Chain withReadTimeout(int timeout, TimeUnit unit) {
+    int millis = checkDuration("timeout", timeout, unit);
+    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
+        request, call, eventListener, connectTimeout, millis, writeTimeout);
+  }
+
+  @Override public int writeTimeoutMillis() {
+    return writeTimeout;
+  }
+
+  @Override public Interceptor.Chain withWriteTimeout(int timeout, TimeUnit unit) {
+    int millis = checkDuration("timeout", timeout, unit);
+    return new RealInterceptorChain(interceptors, streamAllocation, httpCodec, connection, index,
+        request, call, eventListener, connectTimeout, readTimeout, millis);
+  }
+
   public StreamAllocation streamAllocation() {
     return streamAllocation;
   }
@@ -59,6 +105,14 @@ public HttpCodec httpStream() {
     return httpCodec;
   }
 
+  @Override public Call call() {
+    return call;
+  }
+
+  public EventListener eventListener() {
+    return eventListener;
+  }
+
   @Override public Request request() {
     return request;
   }
@@ -68,13 +122,13 @@ public HttpCodec httpStream() {
   }
 
   public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,
-      Connection connection) throws IOException {
+      RealConnection connection) throws IOException {
     if (index >= interceptors.size()) throw new AssertionError();
 
     calls++;
 
     // If we already have a stream, confirm that the incoming request will use it.
-    if (this.httpCodec != null && !sameConnection(request.url())) {
+    if (this.httpCodec != null && !this.connection.supportsUrl(request.url())) {
       throw new IllegalStateException("network interceptor " + interceptors.get(index - 1)
           + " must retain the same host and port");
     }
@@ -86,8 +140,9 @@ public Response proceed(Request request, StreamAllocation streamAllocation, Http
     }
 
     // Call the next interceptor in the chain.
-    RealInterceptorChain next = new RealInterceptorChain(
-        interceptors, streamAllocation, httpCodec, connection, index + 1, request);
+    RealInterceptorChain next = new RealInterceptorChain(interceptors, streamAllocation, httpCodec,
+        connection, index + 1, request, call, eventListener, connectTimeout, readTimeout,
+        writeTimeout);
     Interceptor interceptor = interceptors.get(index);
     Response response = interceptor.intercept(next);
 
@@ -102,11 +157,11 @@ public Response proceed(Request request, StreamAllocation streamAllocation, Http
       throw new NullPointerException("interceptor " + interceptor + " returned null");
     }
 
-    return response;
-  }
+    if (response.body() == null) {
+      throw new IllegalStateException(
+          "interceptor " + interceptor + " returned a response with no body");
+    }
 
-  private boolean sameConnection(HttpUrl url) {
-    return url.host().equals(connection.route().address().url().host())
-        && url.port() == connection.route().address().url().port();
+    return response;
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java b/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java
index 673189c299..970d7ca949 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RealResponseBody.java
@@ -15,27 +15,33 @@
  */
 package okhttp3.internal.http;
 
-import okhttp3.Headers;
+import javax.annotation.Nullable;
 import okhttp3.MediaType;
 import okhttp3.ResponseBody;
 import okio.BufferedSource;
 
 public final class RealResponseBody extends ResponseBody {
-  private final Headers headers;
+  /**
+   * Use a string to avoid parsing the content type until needed. This also defers problems caused
+   * by malformed content types.
+   */
+  private final @Nullable String contentTypeString;
+  private final long contentLength;
   private final BufferedSource source;
 
-  public RealResponseBody(Headers headers, BufferedSource source) {
-    this.headers = headers;
+  public RealResponseBody(
+      @Nullable String contentTypeString, long contentLength, BufferedSource source) {
+    this.contentTypeString = contentTypeString;
+    this.contentLength = contentLength;
     this.source = source;
   }
 
   @Override public MediaType contentType() {
-    String contentType = headers.get("Content-Type");
-    return contentType != null ? MediaType.parse(contentType) : null;
+    return contentTypeString != null ? MediaType.parse(contentTypeString) : null;
   }
 
   @Override public long contentLength() {
-    return HttpHeaders.contentLength(headers);
+    return contentLength;
   }
 
   @Override public BufferedSource source() {
diff --git a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
index 792ddc9299..ffb75058aa 100644
--- a/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
+++ b/okhttp/src/main/java/okhttp3/internal/http/RetryAndFollowUpInterceptor.java
@@ -27,8 +27,9 @@
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocketFactory;
 import okhttp3.Address;
+import okhttp3.Call;
 import okhttp3.CertificatePinner;
-import okhttp3.Connection;
+import okhttp3.EventListener;
 import okhttp3.HttpUrl;
 import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
@@ -47,6 +48,7 @@
 import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
 import static java.net.HttpURLConnection.HTTP_SEE_OTHER;
 import static java.net.HttpURLConnection.HTTP_UNAUTHORIZED;
+import static java.net.HttpURLConnection.HTTP_UNAVAILABLE;
 import static okhttp3.internal.Util.closeQuietly;
 import static okhttp3.internal.http.StatusLine.HTTP_PERM_REDIRECT;
 import static okhttp3.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
@@ -64,7 +66,7 @@
 
   private final OkHttpClient client;
   private final boolean forWebSocket;
-  private StreamAllocation streamAllocation;
+  private volatile StreamAllocation streamAllocation;
   private Object callStackTrace;
   private volatile boolean canceled;
 
@@ -102,9 +104,13 @@ public StreamAllocation streamAllocation() {
 
   @Override public Response intercept(Chain chain) throws IOException {
     Request request = chain.request();
+    RealInterceptorChain realChain = (RealInterceptorChain) chain;
+    Call call = realChain.call();
+    EventListener eventListener = realChain.eventListener();
 
-    streamAllocation = new StreamAllocation(
-        client.connectionPool(), createAddress(request.url()), callStackTrace);
+    StreamAllocation streamAllocation = new StreamAllocation(client.connectionPool(),
+        createAddress(request.url()), call, eventListener, callStackTrace);
+    this.streamAllocation = streamAllocation;
 
     int followUpCount = 0;
     Response priorResponse = null;
@@ -114,22 +120,22 @@ public StreamAllocation streamAllocation() {
         throw new IOException("Canceled");
       }
 
-      Response response = null;
+      Response response;
       boolean releaseConnection = true;
       try {
-        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);
+        response = realChain.proceed(request, streamAllocation, null, null);
         releaseConnection = false;
       } catch (RouteException e) {
         // The attempt to connect via a route failed. The request will not have been sent.
-        if (!recover(e.getLastConnectException(), false, request)) {
-          throw e.getLastConnectException();
+        if (!recover(e.getLastConnectException(), streamAllocation, false, request)) {
+          throw e.getFirstConnectException();
         }
         releaseConnection = false;
         continue;
       } catch (IOException e) {
         // An attempt to communicate with a server failed. The request may have been sent.
         boolean requestSendStarted = !(e instanceof ConnectionShutdownException);
-        if (!recover(e, requestSendStarted, request)) throw e;
+        if (!recover(e, streamAllocation, requestSendStarted, request)) throw e;
         releaseConnection = false;
         continue;
       } finally {
@@ -149,7 +155,13 @@ public StreamAllocation streamAllocation() {
             .build();
       }
 
-      Request followUp = followUpRequest(response);
+      Request followUp;
+      try {
+        followUp = followUpRequest(response, streamAllocation.route());
+      } catch (IOException e) {
+        streamAllocation.release();
+        throw e;
+      }
 
       if (followUp == null) {
         if (!forWebSocket) {
@@ -172,8 +184,9 @@ public StreamAllocation streamAllocation() {
 
       if (!sameConnection(response, followUp.url())) {
         streamAllocation.release();
-        streamAllocation = new StreamAllocation(
-            client.connectionPool(), createAddress(followUp.url()), callStackTrace);
+        streamAllocation = new StreamAllocation(client.connectionPool(),
+            createAddress(followUp.url()), call, eventListener, callStackTrace);
+        this.streamAllocation = streamAllocation;
       } else if (streamAllocation.codec() != null) {
         throw new IllegalStateException("Closing the body of " + response
             + " didn't close its backing stream. Bad interceptor?");
@@ -205,7 +218,8 @@ private Address createAddress(HttpUrl url) {
    * be recovered if the body is buffered or if the failure occurred before the request has been
    * sent.
    */
-  private boolean recover(IOException e, boolean requestSendStarted, Request userRequest) {
+  private boolean recover(IOException e, StreamAllocation streamAllocation,
+      boolean requestSendStarted, Request userRequest) {
     streamAllocation.streamFailed(e);
 
     // The application layer has forbidden retries.
@@ -261,12 +275,8 @@ private boolean isRecoverable(IOException e, boolean requestSendStarted) {
    * either add authentication headers, follow redirects or handle a client request timeout. If a
    * follow-up is either unnecessary or not applicable, this returns null.
    */
-  private Request followUpRequest(Response userResponse) throws IOException {
+  private Request followUpRequest(Response userResponse, Route route) throws IOException {
     if (userResponse == null) throw new IllegalStateException();
-    Connection connection = streamAllocation.connection();
-    Route route = connection != null
-        ? connection.route()
-        : null;
     int responseCode = userResponse.code();
 
     final String method = userResponse.request().method();
@@ -339,17 +349,62 @@ private Request followUpRequest(Response userResponse) throws IOException {
         // 408's are rare in practice, but some servers like HAProxy use this response code. The
         // spec says that we may repeat the request without modifications. Modern browsers also
         // repeat the request (even non-idempotent ones.)
+        if (!client.retryOnConnectionFailure()) {
+          // The application layer has directed us not to retry the request.
+          return null;
+        }
+
         if (userResponse.request().body() instanceof UnrepeatableRequestBody) {
           return null;
         }
 
+        if (userResponse.priorResponse() != null
+            && userResponse.priorResponse().code() == HTTP_CLIENT_TIMEOUT) {
+          // We attempted to retry and got another timeout. Give up.
+          return null;
+        }
+
+        if (retryAfter(userResponse, 0) > 0) {
+          return null;
+        }
+
         return userResponse.request();
 
+      case HTTP_UNAVAILABLE:
+        if (userResponse.priorResponse() != null
+            && userResponse.priorResponse().code() == HTTP_UNAVAILABLE) {
+          // We attempted to retry and got another timeout. Give up.
+          return null;
+        }
+
+        if (retryAfter(userResponse, Integer.MAX_VALUE) == 0) {
+          // specifically received an instruction to retry without delay
+          return userResponse.request();
+        }
+
+        return null;
+
       default:
         return null;
     }
   }
 
+  private int retryAfter(Response userResponse, int defaultDelay) {
+    String header = userResponse.header("Retry-After");
+
+    if (header == null) {
+      return defaultDelay;
+    }
+
+    // https://tools.ietf.org/html/rfc7231#section-7.1.3
+    // currently ignores a HTTP-date, and assumes any non int 0 is a delay
+    if (header.matches("\\d+")) {
+      return Integer.valueOf(header);
+    }
+
+    return Integer.MAX_VALUE;
+  }
+
   /**
    * Returns true if an HTTP request for {@code followUp} can reuse the connection used by this
    * engine.
diff --git a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
index 625c173bf3..6c7b4373c4 100644
--- a/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http1/Http1Codec.java
@@ -74,6 +74,7 @@
   private static final int STATE_OPEN_RESPONSE_BODY = 4;
   private static final int STATE_READING_RESPONSE_BODY = 5;
   private static final int STATE_CLOSED = 6;
+  private static final int HEADER_LIMIT = 256 * 1024;
 
   /** The client that configures this stream. May be null for HTTPS proxy tunnels. */
   final OkHttpClient client;
@@ -83,6 +84,7 @@
   final BufferedSource source;
   final BufferedSink sink;
   int state = STATE_IDLE;
+  private long headerLimit = HEADER_LIMIT;
 
   public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, BufferedSource source,
       BufferedSink sink) {
@@ -129,28 +131,26 @@ public Http1Codec(OkHttpClient client, StreamAllocation streamAllocation, Buffer
   }
 
   @Override public ResponseBody openResponseBody(Response response) throws IOException {
-    Source source = getTransferStream(response);
-    return new RealResponseBody(response.headers(), Okio.buffer(source));
-  }
+    streamAllocation.eventListener.responseBodyStart(streamAllocation.call);
+    String contentType = response.header("Content-Type");
 
-  private Source getTransferStream(Response response) throws IOException {
     if (!HttpHeaders.hasBody(response)) {
-      return newFixedLengthSource(0);
+      Source source = newFixedLengthSource(0);
+      return new RealResponseBody(contentType, 0, Okio.buffer(source));
     }
 
     if ("chunked".equalsIgnoreCase(response.header("Transfer-Encoding"))) {
-      return newChunkedSource(response.request().url());
+      Source source = newChunkedSource(response.request().url());
+      return new RealResponseBody(contentType, -1L, Okio.buffer(source));
     }
 
     long contentLength = HttpHeaders.contentLength(response);
     if (contentLength != -1) {
-      return newFixedLengthSource(contentLength);
+      Source source = newFixedLengthSource(contentLength);
+      return new RealResponseBody(contentType, contentLength, Okio.buffer(source));
     }
 
-    // Wrap the input stream from the connection (rather than just returning
-    // "socketIn" directly here), so that we can control its use after the
-    // reference escapes.
-    return newUnknownLengthSource();
+    return new RealResponseBody(contentType, -1L, Okio.buffer(newUnknownLengthSource()));
   }
 
   /** Returns true if this connection is closed. */
@@ -186,7 +186,7 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
     }
 
     try {
-      StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());
+      StatusLine statusLine = StatusLine.parse(readHeaderLine());
 
       Response.Builder responseBuilder = new Response.Builder()
           .protocol(statusLine.protocol)
@@ -196,6 +196,9 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
 
       if (expectContinue && statusLine.code == HTTP_CONTINUE) {
         return null;
+      } else if (statusLine.code == HTTP_CONTINUE) {
+        state = STATE_READ_RESPONSE_HEADERS;
+        return responseBuilder;
       }
 
       state = STATE_OPEN_RESPONSE_BODY;
@@ -208,11 +211,17 @@ public void writeRequest(Headers headers, String requestLine) throws IOException
     }
   }
 
+  private String readHeaderLine() throws IOException {
+    String line = source.readUtf8LineStrict(headerLimit);
+    headerLimit -= line.length();
+    return line;
+  }
+
   /** Reads headers or trailers. */
   public Headers readHeaders() throws IOException {
     Headers.Builder headers = new Headers.Builder();
     // parse the result headers until the first blank line
-    for (String line; (line = source.readUtf8LineStrict()).length() != 0; ) {
+    for (String line; (line = readHeaderLine()).length() != 0; ) {
       Internal.instance.addLenient(headers, line);
     }
     return headers.build();
@@ -343,16 +352,30 @@ void detachTimeout(ForwardingTimeout timeout) {
   private abstract class AbstractSource implements Source {
     protected final ForwardingTimeout timeout = new ForwardingTimeout(source.timeout());
     protected boolean closed;
+    protected long bytesRead = 0;
 
     @Override public Timeout timeout() {
       return timeout;
     }
 
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      try {
+        long read = source.read(sink, byteCount);
+        if (read > 0) {
+          bytesRead += read;
+        }
+        return read;
+      } catch (IOException e) {
+        endOfInput(false, e);
+        throw e;
+      }
+    }
+
     /**
      * Closes the cache entry and makes the socket available for reuse. This should be invoked when
      * the end of the body has been reached.
      */
-    protected final void endOfInput(boolean reuseConnection) throws IOException {
+    protected final void endOfInput(boolean reuseConnection, IOException e) throws IOException {
       if (state == STATE_CLOSED) return;
       if (state != STATE_READING_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
 
@@ -360,7 +383,7 @@ protected final void endOfInput(boolean reuseConnection) throws IOException {
 
       state = STATE_CLOSED;
       if (streamAllocation != null) {
-        streamAllocation.streamFinished(!reuseConnection, Http1Codec.this);
+        streamAllocation.streamFinished(!reuseConnection, Http1Codec.this, bytesRead, e);
       }
     }
   }
@@ -369,10 +392,10 @@ protected final void endOfInput(boolean reuseConnection) throws IOException {
   private class FixedLengthSource extends AbstractSource {
     private long bytesRemaining;
 
-    public FixedLengthSource(long length) throws IOException {
+    FixedLengthSource(long length) throws IOException {
       bytesRemaining = length;
       if (bytesRemaining == 0) {
-        endOfInput(true);
+        endOfInput(true, null);
       }
     }
 
@@ -381,15 +404,16 @@ public FixedLengthSource(long length) throws IOException {
       if (closed) throw new IllegalStateException("closed");
       if (bytesRemaining == 0) return -1;
 
-      long read = source.read(sink, Math.min(bytesRemaining, byteCount));
+      long read = super.read(sink, Math.min(bytesRemaining, byteCount));
       if (read == -1) {
-        endOfInput(false); // The server didn't supply the promised content length.
-        throw new ProtocolException("unexpected end of stream");
+        ProtocolException e = new ProtocolException("unexpected end of stream");
+        endOfInput(false, e); // The server didn't supply the promised content length.
+        throw e;
       }
 
       bytesRemaining -= read;
       if (bytesRemaining == 0) {
-        endOfInput(true);
+        endOfInput(true, null);
       }
       return read;
     }
@@ -398,7 +422,7 @@ public FixedLengthSource(long length) throws IOException {
       if (closed) return;
 
       if (bytesRemaining != 0 && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        endOfInput(false);
+        endOfInput(false, null);
       }
 
       closed = true;
@@ -426,10 +450,11 @@ public FixedLengthSource(long length) throws IOException {
         if (!hasMoreChunks) return -1;
       }
 
-      long read = source.read(sink, Math.min(byteCount, bytesRemainingInChunk));
+      long read = super.read(sink, Math.min(byteCount, bytesRemainingInChunk));
       if (read == -1) {
-        endOfInput(false); // The server didn't supply the promised chunk length.
-        throw new ProtocolException("unexpected end of stream");
+        ProtocolException e = new ProtocolException("unexpected end of stream");
+        endOfInput(false, e); // The server didn't supply the promised chunk length.
+        throw e;
       }
       bytesRemainingInChunk -= read;
       return read;
@@ -453,14 +478,14 @@ private void readChunkSize() throws IOException {
       if (bytesRemainingInChunk == 0L) {
         hasMoreChunks = false;
         HttpHeaders.receiveHeaders(client.cookieJar(), url, readHeaders());
-        endOfInput(true);
+        endOfInput(true, null);
       }
     }
 
     @Override public void close() throws IOException {
       if (closed) return;
       if (hasMoreChunks && !Util.discard(this, DISCARD_STREAM_TIMEOUT_MILLIS, MILLISECONDS)) {
-        endOfInput(false);
+        endOfInput(false, null);
       }
       closed = true;
     }
@@ -479,10 +504,10 @@ private void readChunkSize() throws IOException {
       if (closed) throw new IllegalStateException("closed");
       if (inputExhausted) return -1;
 
-      long read = source.read(sink, byteCount);
+      long read = super.read(sink, byteCount);
       if (read == -1) {
         inputExhausted = true;
-        endOfInput(true);
+        endOfInput(true, null);
         return -1;
       }
       return read;
@@ -491,7 +516,7 @@ private void readChunkSize() throws IOException {
     @Override public void close() throws IOException {
       if (closed) return;
       if (!inputExhausted) {
-        endOfInput(false);
+        endOfInput(false, null);
       }
       closed = true;
     }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/ErrorCode.java b/okhttp/src/main/java/okhttp3/internal/http2/ErrorCode.java
index 26defebe06..6a704684fc 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/ErrorCode.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/ErrorCode.java
@@ -28,7 +28,17 @@
 
   REFUSED_STREAM(7),
 
-  CANCEL(8);
+  CANCEL(8),
+
+  COMPRESSION_ERROR(9),
+
+  CONNECT_ERROR(0xa),
+
+  ENHANCE_YOUR_CALM(0xb),
+
+  INADEQUATE_SECURITY(0xc),
+
+  HTTP_1_1_REQUIRED(0xd);
 
   public final int httpCode;
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
index a28698bf01..258ac9b269 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Hpack.java
@@ -221,7 +221,7 @@ private void readIndexedHeader(int index) throws IOException {
         headerList.add(staticEntry);
       } else {
         int dynamicTableIndex = dynamicTableIndex(index - STATIC_HEADER_TABLE.length);
-        if (dynamicTableIndex < 0 || dynamicTableIndex > dynamicTable.length - 1) {
+        if (dynamicTableIndex < 0 || dynamicTableIndex >= dynamicTable.length) {
           throw new IOException("Header index too large " + (index + 1));
         }
         headerList.add(dynamicTable[dynamicTableIndex]);
@@ -258,11 +258,16 @@ private void readLiteralHeaderWithIncrementalIndexingNewName() throws IOExceptio
       insertIntoDynamicTable(-1, new Header(name, value));
     }
 
-    private ByteString getName(int index) {
+    private ByteString getName(int index) throws IOException {
       if (isStaticHeader(index)) {
         return STATIC_HEADER_TABLE[index].name;
       } else {
-        return dynamicTable[dynamicTableIndex(index - STATIC_HEADER_TABLE.length)].name;
+        int dynamicTableIndex = dynamicTableIndex(index - STATIC_HEADER_TABLE.length);
+        if (dynamicTableIndex < 0 || dynamicTableIndex >= dynamicTable.length) {
+          throw new IOException("Header index too large " + (index + 1));
+        }
+
+        return dynamicTable[dynamicTableIndex].name;
       }
     }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
index 66a72ab12a..48986270a0 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Codec.java
@@ -22,6 +22,7 @@
 import java.util.Locale;
 import java.util.concurrent.TimeUnit;
 import okhttp3.Headers;
+import okhttp3.Interceptor;
 import okhttp3.OkHttpClient;
 import okhttp3.Protocol;
 import okhttp3.Request;
@@ -31,9 +32,11 @@
 import okhttp3.internal.Util;
 import okhttp3.internal.connection.StreamAllocation;
 import okhttp3.internal.http.HttpCodec;
+import okhttp3.internal.http.HttpHeaders;
 import okhttp3.internal.http.RealResponseBody;
 import okhttp3.internal.http.RequestLine;
 import okhttp3.internal.http.StatusLine;
+import okio.Buffer;
 import okio.ByteString;
 import okio.ForwardingSource;
 import okio.Okio;
@@ -82,16 +85,20 @@
       ENCODING,
       UPGRADE);
 
-  private final OkHttpClient client;
+  private final Interceptor.Chain chain;
   final StreamAllocation streamAllocation;
   private final Http2Connection connection;
   private Http2Stream stream;
+  private final Protocol protocol;
 
-  public Http2Codec(
-      OkHttpClient client, StreamAllocation streamAllocation, Http2Connection connection) {
-    this.client = client;
+  public Http2Codec(OkHttpClient client, Interceptor.Chain chain, StreamAllocation streamAllocation,
+      Http2Connection connection) {
+    this.chain = chain;
     this.streamAllocation = streamAllocation;
     this.connection = connection;
+    this.protocol = client.protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)
+        ? Protocol.H2_PRIOR_KNOWLEDGE
+        : Protocol.HTTP_2;
   }
 
   @Override public Sink createRequestBody(Request request, long contentLength) {
@@ -104,8 +111,8 @@ public Http2Codec(
     boolean hasRequestBody = request.body() != null;
     List<Header> requestHeaders = http2HeadersList(request);
     stream = connection.newStream(requestHeaders, hasRequestBody);
-    stream.readTimeout().timeout(client.readTimeoutMillis(), TimeUnit.MILLISECONDS);
-    stream.writeTimeout().timeout(client.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
+    stream.readTimeout().timeout(chain.readTimeoutMillis(), TimeUnit.MILLISECONDS);
+    stream.writeTimeout().timeout(chain.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
   }
 
   @Override public void flushRequest() throws IOException {
@@ -118,7 +125,7 @@ public Http2Codec(
 
   @Override public Response.Builder readResponseHeaders(boolean expectContinue) throws IOException {
     List<Header> headers = stream.takeResponseHeaders();
-    Response.Builder responseBuilder = readHttp2HeadersList(headers);
+    Response.Builder responseBuilder = readHttp2HeadersList(headers, protocol);
     if (expectContinue && Internal.instance.code(responseBuilder) == HTTP_CONTINUE) {
       return null;
     }
@@ -130,7 +137,10 @@ public Http2Codec(
     List<Header> result = new ArrayList<>(headers.size() + 4);
     result.add(new Header(TARGET_METHOD, request.method()));
     result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
-    result.add(new Header(TARGET_AUTHORITY, Util.hostHeader(request.url(), false))); // Optional.
+    String host = request.header("Host");
+    if (host != null) {
+      result.add(new Header(TARGET_AUTHORITY, host)); // Optional.
+    }
     result.add(new Header(TARGET_SCHEME, request.url().scheme()));
 
     for (int i = 0, size = headers.size(); i < size; i++) {
@@ -144,7 +154,8 @@ public Http2Codec(
   }
 
   /** Returns headers for a name value block containing an HTTP/2 response. */
-  public static Response.Builder readHttp2HeadersList(List<Header> headerBlock) throws IOException {
+  public static Response.Builder readHttp2HeadersList(List<Header> headerBlock,
+      Protocol protocol) throws IOException {
     StatusLine statusLine = null;
     Headers.Builder headersBuilder = new Headers.Builder();
     for (int i = 0, size = headerBlock.size(); i < size; i++) {
@@ -171,15 +182,18 @@ public Http2Codec(
     if (statusLine == null) throw new ProtocolException("Expected ':status' header not present");
 
     return new Response.Builder()
-        .protocol(Protocol.HTTP_2)
+        .protocol(protocol)
         .code(statusLine.code)
         .message(statusLine.message)
         .headers(headersBuilder.build());
   }
 
   @Override public ResponseBody openResponseBody(Response response) throws IOException {
+    streamAllocation.eventListener.responseBodyStart(streamAllocation.call);
+    String contentType = response.header("Content-Type");
+    long contentLength = HttpHeaders.contentLength(response);
     Source source = new StreamFinishingSource(stream.getSource());
-    return new RealResponseBody(response.headers(), Okio.buffer(source));
+    return new RealResponseBody(contentType, contentLength, Okio.buffer(source));
   }
 
   @Override public void cancel() {
@@ -187,13 +201,35 @@ public Http2Codec(
   }
 
   class StreamFinishingSource extends ForwardingSource {
-    public StreamFinishingSource(Source delegate) {
+    boolean completed = false;
+    long bytesRead = 0;
+
+    StreamFinishingSource(Source delegate) {
       super(delegate);
     }
 
+    @Override public long read(Buffer sink, long byteCount) throws IOException {
+      try {
+        long read = delegate().read(sink, byteCount);
+        if (read > 0) {
+          bytesRead += read;
+        }
+        return read;
+      } catch (IOException e) {
+        endOfInput(e);
+        throw e;
+      }
+    }
+
     @Override public void close() throws IOException {
-      streamAllocation.streamFinished(false, Http2Codec.this);
       super.close();
+      endOfInput(null);
+    }
+
+    private void endOfInput(IOException e) {
+      if (completed) return;
+      completed = true;
+      streamAllocation.streamFinished(false, Http2Codec.this, bytesRead, e);
     }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
index 2548705eed..0920c41eeb 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Connection.java
@@ -27,6 +27,9 @@
 import java.util.Set;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.RejectedExecutionException;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
@@ -40,6 +43,8 @@
 import okio.ByteString;
 import okio.Okio;
 
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static okhttp3.internal.http2.ErrorCode.REFUSED_STREAM;
 import static okhttp3.internal.http2.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 import static okhttp3.internal.platform.Platform.INFO;
 
@@ -66,16 +71,22 @@
   // operations must synchronize on 'this' last. This ensures that we never
   // wait for a blocking operation while holding 'this'.
 
-  static final ExecutorService executor = new ThreadPoolExecutor(0,
+  static final int OKHTTP_CLIENT_WINDOW_SIZE = 16 * 1024 * 1024;
+
+  /**
+   * Shared executor to send notifications of incoming streams. This executor requires multiple
+   * threads because listeners are not required to return promptly.
+   */
+  private static final ExecutorService listenerExecutor = new ThreadPoolExecutor(0,
       Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(),
-      Util.threadFactory("OkHttp FramedConnection", true));
+      Util.threadFactory("OkHttp Http2Connection", true));
 
   /** True if this peer initiated the connection. */
   final boolean client;
 
   /**
    * User code to run in response to incoming streams or settings. Calls to this are always invoked
-   * on {@link #executor}.
+   * on {@link #listenerExecutor}.
    */
   final Listener listener;
   final Map<Integer, Http2Stream> streams = new LinkedHashMap<>();
@@ -84,14 +95,17 @@
   int nextStreamId;
   boolean shutdown;
 
+  /** Asynchronously writes frames to the outgoing socket. */
+  private final ScheduledExecutorService writerExecutor;
+
   /** Ensures push promise callbacks events are sent in order per stream. */
   private final ExecutorService pushExecutor;
 
-  /** Lazily-created map of in-flight pings awaiting a response. Guarded by this. */
-  private Map<Integer, Ping> pings;
   /** User code to run in response to push promise events. */
   final PushObserver pushObserver;
-  private int nextPingId;
+
+  /** True if we have sent a ping that is still awaiting a reply. */
+  private boolean awaitingPong;
 
   /**
    * The total number of bytes consumed by the application, but not yet acknowledged by sending a
@@ -109,8 +123,6 @@
   /** Settings we communicate to the peer. */
   Settings okHttpSettings = new Settings();
 
-  private static final int OKHTTP_CLIENT_WINDOW_SIZE = 16 * 1024 * 1024;
-
   /** Settings we receive from the peer. */
   // TODO: MWS will need to guard on this setting before attempting to push.
   final Settings peerSettings = new Settings();
@@ -132,8 +144,6 @@
       nextStreamId += 2; // In HTTP/2, 1 on client is reserved for Upgrade.
     }
 
-    nextPingId = builder.client ? 1 : 2;
-
     // Flow control was designed more for servers, or proxies than edge clients.
     // If we are a client, set the flow control window to 16MiB.  This avoids
     // thrashing window updates every 64KiB, yet small enough to avoid blowing
@@ -144,6 +154,13 @@
 
     hostname = builder.hostname;
 
+    writerExecutor = new ScheduledThreadPoolExecutor(1,
+        Util.threadFactory(Util.format("OkHttp %s Writer", hostname), false));
+    if (builder.pingIntervalMillis != 0) {
+      writerExecutor.scheduleAtFixedRate(new PingRunnable(false, 0, 0),
+          builder.pingIntervalMillis, builder.pingIntervalMillis, MILLISECONDS);
+    }
+
     // Like newSingleThreadExecutor, except lazy creates the thread.
     pushExecutor = new ThreadPoolExecutor(0, 1, 60, TimeUnit.SECONDS,
         new LinkedBlockingQueue<Runnable>(),
@@ -183,6 +200,14 @@ public synchronized int maxConcurrentStreams() {
     return peerSettings.getMaxConcurrentStreams(Integer.MAX_VALUE);
   }
 
+  synchronized void updateConnectionFlowControl(long read) {
+    unacknowledgedBytesRead += read;
+    if (unacknowledgedBytesRead >= okHttpSettings.getInitialWindowSize() / 2) {
+      writeWindowUpdateLater(0, unacknowledgedBytesRead);
+      unacknowledgedBytesRead = 0;
+    }
+  }
+
   /**
    * Returns a new server-initiated stream.
    *
@@ -215,6 +240,9 @@ private Http2Stream newStream(
 
     synchronized (writer) {
       synchronized (this) {
+        if (nextStreamId > Integer.MAX_VALUE / 2) {
+          shutdown(REFUSED_STREAM);
+        }
         if (shutdown) {
           throw new ConnectionShutdownException();
         }
@@ -279,6 +307,7 @@ public void writeData(int streamId, boolean outFinished, Buffer buffer, long byt
             Http2Connection.this.wait(); // Wait until we receive a WINDOW_UPDATE.
           }
         } catch (InterruptedException e) {
+          Thread.currentThread().interrupt(); // Retain interrupted status.
           throw new InterruptedIOException();
         }
 
@@ -292,23 +321,20 @@ public void writeData(int streamId, boolean outFinished, Buffer buffer, long byt
     }
   }
 
-  /**
-   * {@code delta} will be negative if a settings frame initial window is smaller than the last.
-   */
-  void addBytesToWriteWindow(long delta) {
-    bytesLeftInWriteWindow += delta;
-    if (delta > 0) Http2Connection.this.notifyAll();
-  }
-
   void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
-    executor.execute(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
-      @Override public void execute() {
-        try {
-          writeSynReset(streamId, errorCode);
-        } catch (IOException ignored) {
+    try {
+      writerExecutor.execute(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
+        @Override public void execute() {
+          try {
+            writeSynReset(streamId, errorCode);
+          } catch (IOException e) {
+            failConnection();
+          }
         }
-      }
-    });
+      });
+    } catch (RejectedExecutionException ignored) {
+      // This connection has been closed.
+    }
   }
 
   void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
@@ -316,59 +342,70 @@ void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
   }
 
   void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRead) {
-    executor.execute(new NamedRunnable("OkHttp Window Update %s stream %d", hostname, streamId) {
-      @Override public void execute() {
-        try {
-          writer.windowUpdate(streamId, unacknowledgedBytesRead);
-        } catch (IOException ignored) {
-        }
-      }
-    });
+    try {
+      writerExecutor.execute(
+          new NamedRunnable("OkHttp Window Update %s stream %d", hostname, streamId) {
+            @Override public void execute() {
+              try {
+                writer.windowUpdate(streamId, unacknowledgedBytesRead);
+              } catch (IOException e) {
+                failConnection();
+              }
+            }
+          });
+    } catch (RejectedExecutionException ignored) {
+      // This connection has been closed.
+    }
   }
 
-  /**
-   * Sends a ping frame to the peer. Use the returned object to await the ping's response and
-   * observe its round trip time.
-   */
-  public Ping ping() throws IOException {
-    Ping ping = new Ping();
-    int pingId;
-    synchronized (this) {
-      if (shutdown) {
-        throw new ConnectionShutdownException();
-      }
-      pingId = nextPingId;
-      nextPingId += 2;
-      if (pings == null) pings = new LinkedHashMap<>();
-      pings.put(pingId, ping);
+  final class PingRunnable extends NamedRunnable {
+    final boolean reply;
+    final int payload1;
+    final int payload2;
+
+    PingRunnable(boolean reply, int payload1, int payload2) {
+      super("OkHttp %s ping %08x%08x", hostname, payload1, payload2);
+      this.reply = reply;
+      this.payload1 = payload1;
+      this.payload2 = payload2;
+    }
+
+    @Override public void execute() {
+      writePing(reply, payload1, payload2);
     }
-    writePing(false, pingId, 0x4f4b6f6b /* ASCII "OKok" */, ping);
-    return ping;
   }
 
-  void writePingLater(
-      final boolean reply, final int payload1, final int payload2, final Ping ping) {
-    executor.execute(new NamedRunnable("OkHttp %s ping %08x%08x",
-        hostname, payload1, payload2) {
-      @Override public void execute() {
-        try {
-          writePing(reply, payload1, payload2, ping);
-        } catch (IOException ignored) {
-        }
+  void writePing(boolean reply, int payload1, int payload2) {
+    if (!reply) {
+      boolean failedDueToMissingPong;
+      synchronized (this) {
+        failedDueToMissingPong = awaitingPong;
+        awaitingPong = true;
       }
-    });
-  }
+      if (failedDueToMissingPong) {
+        failConnection();
+        return;
+      }
+    }
 
-  void writePing(boolean reply, int payload1, int payload2, Ping ping) throws IOException {
-    synchronized (writer) {
-      // Observe the sent time immediately before performing I/O.
-      if (ping != null) ping.send();
+    try {
       writer.ping(reply, payload1, payload2);
+    } catch (IOException e) {
+      failConnection();
     }
   }
 
-  synchronized Ping removePing(int id) {
-    return pings != null ? pings.remove(id) : null;
+  /** For testing: sends a ping and waits for a pong. */
+  void writePingAndAwaitPong() throws InterruptedException {
+    writePing(false, 0x4f4b6f6b /* "OKok" */, 0xf09f8da9 /* donut */);
+    awaitPong();
+  }
+
+  /** For testing: waits until {@code requiredPongCount} pings have been received from the peer. */
+  synchronized void awaitPong() throws InterruptedException {
+    while (awaitingPong) {
+      wait();
+    }
   }
 
   public void flush() throws IOException {
@@ -414,16 +451,11 @@ void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
     }
 
     Http2Stream[] streamsToClose = null;
-    Ping[] pingsToCancel = null;
     synchronized (this) {
       if (!streams.isEmpty()) {
         streamsToClose = streams.values().toArray(new Http2Stream[streams.size()]);
         streams.clear();
       }
-      if (pings != null) {
-        pingsToCancel = pings.values().toArray(new Ping[pings.size()]);
-        pings = null;
-      }
     }
 
     if (streamsToClose != null) {
@@ -436,12 +468,6 @@ void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
       }
     }
 
-    if (pingsToCancel != null) {
-      for (Ping ping : pingsToCancel) {
-        ping.cancel();
-      }
-    }
-
     // Close the writer to release its resources (such as deflaters).
     try {
       writer.close();
@@ -456,9 +482,20 @@ void close(ErrorCode connectionCode, ErrorCode streamCode) throws IOException {
       thrown = e;
     }
 
+    // Release the threads.
+    writerExecutor.shutdown();
+    pushExecutor.shutdown();
+
     if (thrown != null) throw thrown;
   }
 
+  private void failConnection() {
+    try {
+      close(ErrorCode.PROTOCOL_ERROR, ErrorCode.PROTOCOL_ERROR);
+    } catch (IOException ignored) {
+    }
+  }
+
   /**
    * Sends any initial frames and starts reading frames from the remote peer. This should be called
    * after {@link Builder#build} for all new connections.
@@ -491,8 +528,8 @@ public void setSettings(Settings settings) throws IOException {
           throw new ConnectionShutdownException();
         }
         okHttpSettings.merge(settings);
-        writer.settings(settings);
       }
+      writer.settings(settings);
     }
   }
 
@@ -508,6 +545,7 @@ public synchronized boolean isShutdown() {
     Listener listener = Listener.REFUSE_INCOMING_STREAMS;
     PushObserver pushObserver = PushObserver.CANCEL;
     boolean client;
+    int pingIntervalMillis;
 
     /**
      * @param client true if this peer initiated the connection; false if this peer accepted the
@@ -541,7 +579,12 @@ public Builder pushObserver(PushObserver pushObserver) {
       return this;
     }
 
-    public Http2Connection build() throws IOException {
+    public Builder pingIntervalMillis(int pingIntervalMillis) {
+      this.pingIntervalMillis = pingIntervalMillis;
+      return this;
+    }
+
+    public Http2Connection build() {
       return new Http2Connection(this);
     }
   }
@@ -588,6 +631,7 @@ public Http2Connection build() throws IOException {
       Http2Stream dataStream = getStream(streamId);
       if (dataStream == null) {
         writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR);
+        updateConnectionFlowControl(length);
         source.skip(length);
         return;
       }
@@ -605,12 +649,12 @@ public Http2Connection build() throws IOException {
       }
       Http2Stream stream;
       synchronized (Http2Connection.this) {
-        // If we're shutdown, don't bother with this stream.
-        if (shutdown) return;
-
         stream = getStream(streamId);
 
         if (stream == null) {
+          // If we're shutdown, don't bother with this stream.
+          if (shutdown) return;
+
           // If the stream ID is less than the last created ID, assume it's already closed.
           if (streamId <= lastGoodStreamId) return;
 
@@ -622,12 +666,12 @@ public Http2Connection build() throws IOException {
               false, inFinished, headerBlock);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
-          executor.execute(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
+          listenerExecutor.execute(new NamedRunnable("OkHttp %s stream %d", hostname, streamId) {
             @Override public void execute() {
               try {
                 listener.onStream(newStream);
               } catch (IOException e) {
-                Platform.get().log(INFO, "FramedConnection.Listener failure for " + hostname, e);
+                Platform.get().log(INFO, "Http2Connection.Listener failure for " + hostname, e);
                 try {
                   newStream.close(ErrorCode.PROTOCOL_ERROR);
                 } catch (IOException ignored) {
@@ -667,14 +711,13 @@ public Http2Connection build() throws IOException {
         if (peerInitialWindowSize != -1 && peerInitialWindowSize != priorWriteWindowSize) {
           delta = peerInitialWindowSize - priorWriteWindowSize;
           if (!receivedInitialPeerSettings) {
-            addBytesToWriteWindow(delta);
             receivedInitialPeerSettings = true;
           }
           if (!streams.isEmpty()) {
             streamsToNotify = streams.values().toArray(new Http2Stream[streams.size()]);
           }
         }
-        executor.execute(new NamedRunnable("OkHttp %s settings", hostname) {
+        listenerExecutor.execute(new NamedRunnable("OkHttp %s settings", hostname) {
           @Override public void execute() {
             listener.onSettings(Http2Connection.this);
           }
@@ -690,14 +733,19 @@ public Http2Connection build() throws IOException {
     }
 
     private void applyAndAckSettings(final Settings peerSettings) {
-      executor.execute(new NamedRunnable("OkHttp %s ACK Settings", hostname) {
-        @Override public void execute() {
-          try {
-            writer.applyAndAckSettings(peerSettings);
-          } catch (IOException ignored) {
+      try {
+        writerExecutor.execute(new NamedRunnable("OkHttp %s ACK Settings", hostname) {
+          @Override public void execute() {
+            try {
+              writer.applyAndAckSettings(peerSettings);
+            } catch (IOException e) {
+              failConnection();
+            }
           }
-        }
-      });
+        });
+      } catch (RejectedExecutionException ignored) {
+        // This connection has been closed.
+      }
     }
 
     @Override public void ackSettings() {
@@ -706,13 +754,17 @@ private void applyAndAckSettings(final Settings peerSettings) {
 
     @Override public void ping(boolean reply, int payload1, int payload2) {
       if (reply) {
-        Ping ping = removePing(payload1);
-        if (ping != null) {
-          ping.receive();
+        synchronized (Http2Connection.this) {
+          awaitingPong = false;
+          Http2Connection.this.notifyAll();
         }
       } else {
-        // Send a reply to a client ping if this is a server and vice versa.
-        writePingLater(true, payload1, payload2, null);
+        try {
+          // Send a reply to a client ping if this is a server and vice versa.
+          writerExecutor.execute(new PingRunnable(true, payload1, payload2));
+        } catch (RejectedExecutionException ignored) {
+          // This connection has been closed.
+        }
       }
     }
 
@@ -730,7 +782,7 @@ private void applyAndAckSettings(final Settings peerSettings) {
       // Fail all streams created after the last good stream ID.
       for (Http2Stream http2Stream : streamsCopy) {
         if (http2Stream.getId() > lastGoodStreamId && http2Stream.isLocallyInitiated()) {
-          http2Stream.receiveRstStream(ErrorCode.REFUSED_STREAM);
+          http2Stream.receiveRstStream(REFUSED_STREAM);
           removeStream(http2Stream.getId());
         }
       }
@@ -784,38 +836,46 @@ void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
       }
       currentPushRequests.add(streamId);
     }
-    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Request[%s]", hostname, streamId) {
-      @Override public void execute() {
-        boolean cancel = pushObserver.onRequest(streamId, requestHeaders);
-        try {
-          if (cancel) {
-            writer.rstStream(streamId, ErrorCode.CANCEL);
-            synchronized (Http2Connection.this) {
-              currentPushRequests.remove(streamId);
+    try {
+      pushExecutorExecute(new NamedRunnable("OkHttp %s Push Request[%s]", hostname, streamId) {
+        @Override public void execute() {
+          boolean cancel = pushObserver.onRequest(streamId, requestHeaders);
+          try {
+            if (cancel) {
+              writer.rstStream(streamId, ErrorCode.CANCEL);
+              synchronized (Http2Connection.this) {
+                currentPushRequests.remove(streamId);
+              }
             }
+          } catch (IOException ignored) {
           }
-        } catch (IOException ignored) {
         }
-      }
-    });
+      });
+    } catch (RejectedExecutionException ignored) {
+      // This connection has been closed.
+    }
   }
 
   void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
       final boolean inFinished) {
-    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Headers[%s]", hostname, streamId) {
-      @Override public void execute() {
-        boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished);
-        try {
-          if (cancel) writer.rstStream(streamId, ErrorCode.CANCEL);
-          if (cancel || inFinished) {
-            synchronized (Http2Connection.this) {
-              currentPushRequests.remove(streamId);
+    try {
+      pushExecutorExecute(new NamedRunnable("OkHttp %s Push Headers[%s]", hostname, streamId) {
+        @Override public void execute() {
+          boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished);
+          try {
+            if (cancel) writer.rstStream(streamId, ErrorCode.CANCEL);
+            if (cancel || inFinished) {
+              synchronized (Http2Connection.this) {
+                currentPushRequests.remove(streamId);
+              }
             }
+          } catch (IOException ignored) {
           }
-        } catch (IOException ignored) {
         }
-      }
-    });
+      });
+    } catch (RejectedExecutionException ignored) {
+      // This connection has been closed.
+    }
   }
 
   /**
@@ -828,7 +888,7 @@ void pushDataLater(final int streamId, final BufferedSource source, final int by
     source.require(byteCount); // Eagerly read the frame before firing client thread.
     source.read(buffer, byteCount);
     if (buffer.size() != byteCount) throw new IOException(buffer.size() + " != " + byteCount);
-    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Data[%s]", hostname, streamId) {
+    pushExecutorExecute(new NamedRunnable("OkHttp %s Push Data[%s]", hostname, streamId) {
       @Override public void execute() {
         try {
           boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished);
@@ -845,7 +905,7 @@ void pushDataLater(final int streamId, final BufferedSource source, final int by
   }
 
   void pushResetLater(final int streamId, final ErrorCode errorCode) {
-    pushExecutor.execute(new NamedRunnable("OkHttp %s Push Reset[%s]", hostname, streamId) {
+    pushExecutorExecute(new NamedRunnable("OkHttp %s Push Reset[%s]", hostname, streamId) {
       @Override public void execute() {
         pushObserver.onReset(streamId, errorCode);
         synchronized (Http2Connection.this) {
@@ -855,11 +915,17 @@ void pushResetLater(final int streamId, final ErrorCode errorCode) {
     });
   }
 
+  private synchronized void pushExecutorExecute(NamedRunnable namedRunnable) {
+    if (!isShutdown()) {
+      pushExecutor.execute(namedRunnable);
+    }
+  }
+
   /** Listener of streams and settings initiated by the peer. */
   public abstract static class Listener {
     public static final Listener REFUSE_INCOMING_STREAMS = new Listener() {
       @Override public void onStream(Http2Stream stream) throws IOException {
-        stream.close(ErrorCode.REFUSED_STREAM);
+        stream.close(REFUSED_STREAM);
       }
     };
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
index 2200756dca..1484a269eb 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Reader.java
@@ -67,7 +67,7 @@
   final Hpack.Reader hpackReader;
 
   /** Creates a frame reader with max header table size of 4096. */
-  public Http2Reader(BufferedSource source, boolean client) {
+  Http2Reader(BufferedSource source, boolean client) {
     this.source = source;
     this.client = client;
     this.continuation = new ContinuationSource(this.source);
@@ -199,6 +199,8 @@ private void readHeaders(Handler handler, int length, byte flags, int streamId)
 
   private void readData(Handler handler, int length, byte flags, int streamId)
       throws IOException {
+    if (streamId == 0) throw ioException("PROTOCOL_ERROR: TYPE_DATA streamId == 0");
+
     // TODO: checkState open or half-closed (local) or raise STREAM_CLOSED
     boolean inFinished = (flags & FLAG_END_STREAM) != 0;
     boolean gzipped = (flags & FLAG_COMPRESSED) != 0;
@@ -252,7 +254,7 @@ private void readSettings(Handler handler, int length, byte flags, int streamId)
     if (length % 6 != 0) throw ioException("TYPE_SETTINGS length %% 6 != 0: %s", length);
     Settings settings = new Settings();
     for (int i = 0; i < length; i += 6) {
-      short id = source.readShort();
+      int id = source.readShort() & 0xFFFF;
       int value = source.readInt();
 
       switch (id) {
@@ -354,7 +356,7 @@ private void readWindowUpdate(Handler handler, int length, byte flags, int strea
     int left;
     short padding;
 
-    public ContinuationSource(BufferedSource source) {
+    ContinuationSource(BufferedSource source) {
       this.source = source;
     }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
index 8659fd6a01..5bdcd719d3 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Stream.java
@@ -34,7 +34,7 @@
   // blocking operations are performed while the lock is held.
 
   /**
-   * The total number of bytes consumed by the application (with {@link FramedDataSource#read}), but
+   * The total number of bytes consumed by the application (with {@link FramingSource#read}), but
    * not yet acknowledged by sending a {@code WINDOW_UPDATE} frame on this stream.
    */
   // Visible for testing
@@ -60,8 +60,8 @@
   /** True if response headers have been sent or received. */
   private boolean hasResponseHeaders;
 
-  private final FramedDataSource source;
-  final FramedDataSink sink;
+  private final FramingSource source;
+  final FramingSink sink;
   final StreamTimeout readTimeout = new StreamTimeout();
   final StreamTimeout writeTimeout = new StreamTimeout();
 
@@ -80,9 +80,8 @@
     this.connection = connection;
     this.bytesLeftInWriteWindow =
         connection.peerSettings.getInitialWindowSize();
-    this.source = new FramedDataSource(
-        connection.okHttpSettings.getInitialWindowSize());
-    this.sink = new FramedDataSink();
+    this.source = new FramingSource(connection.okHttpSettings.getInitialWindowSize());
+    this.sink = new FramingSink();
     this.source.finished = inFinished;
     this.sink.finished = outFinished;
     this.requestHeaders = requestHeaders;
@@ -174,16 +173,27 @@ public void sendResponseHeaders(List<Header> responseHeaders, boolean out) throw
       throw new NullPointerException("responseHeaders == null");
     }
     boolean outFinished = false;
+    boolean flushHeaders = false;
     synchronized (this) {
       this.hasResponseHeaders = true;
       if (!out) {
         this.sink.finished = true;
+        flushHeaders = true;
         outFinished = true;
       }
     }
+
+    // Only DATA frames are subject to flow-control. Transmit the HEADER frame if the connection
+    // flow-control window is fully depleted.
+    if (!flushHeaders) {
+      synchronized (connection) {
+        flushHeaders = connection.bytesLeftInWriteWindow == 0L;
+      }
+    }
+
     connection.writeSynReply(id, outFinished, responseHeaders);
 
-    if (outFinished) {
+    if (flushHeaders) {
       connection.flush();
     }
   }
@@ -307,11 +317,11 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
    * synchronization to safely receive incoming data frames, it is not intended for use by multiple
    * readers.
    */
-  private final class FramedDataSource implements Source {
+  private final class FramingSource implements Source {
     /** Buffer to receive data from the network into. Only accessed by the reader thread. */
     private final Buffer receiveBuffer = new Buffer();
 
-    /** Buffer with readable data. Guarded by FramedStream.this. */
+    /** Buffer with readable data. Guarded by Http2Stream.this. */
     private final Buffer readBuffer = new Buffer();
 
     /** Maximum number of bytes to buffer before reporting a flow control error. */
@@ -326,42 +336,57 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
      */
     boolean finished;
 
-    FramedDataSource(long maxByteCount) {
+    FramingSource(long maxByteCount) {
       this.maxByteCount = maxByteCount;
     }
 
     @Override public long read(Buffer sink, long byteCount) throws IOException {
       if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
 
-      long read;
+      long read = -1;
+      ErrorCode errorCode;
       synchronized (Http2Stream.this) {
         waitUntilReadable();
-        checkNotClosed();
-        if (readBuffer.size() == 0) return -1; // This source is exhausted.
+        if (closed) {
+          throw new IOException("stream closed");
+        }
+        errorCode = Http2Stream.this.errorCode;
 
-        // Move bytes from the read buffer into the caller's buffer.
-        read = readBuffer.read(sink, Math.min(byteCount, readBuffer.size()));
+        if (readBuffer.size() > 0) {
+          // Move bytes from the read buffer into the caller's buffer.
+          read = readBuffer.read(sink, Math.min(byteCount, readBuffer.size()));
+          unacknowledgedBytesRead += read;
+        }
 
-        // Flow control: notify the peer that we're ready for more data!
-        unacknowledgedBytesRead += read;
-        if (unacknowledgedBytesRead
-            >= connection.okHttpSettings.getInitialWindowSize() / 2) {
+        if (errorCode == null
+            && unacknowledgedBytesRead >= connection.okHttpSettings.getInitialWindowSize() / 2) {
+          // Flow control: notify the peer that we're ready for more data! Only send a WINDOW_UPDATE
+          // if the stream isn't in error.
           connection.writeWindowUpdateLater(id, unacknowledgedBytesRead);
           unacknowledgedBytesRead = 0;
         }
       }
 
-      // Update connection.unacknowledgedBytesRead outside the stream lock.
-      synchronized (connection) { // Multiple application threads may hit this section.
-        connection.unacknowledgedBytesRead += read;
-        if (connection.unacknowledgedBytesRead
-            >= connection.okHttpSettings.getInitialWindowSize() / 2) {
-          connection.writeWindowUpdateLater(0, connection.unacknowledgedBytesRead);
-          connection.unacknowledgedBytesRead = 0;
-        }
+      if (read != -1) {
+        // Update connection.unacknowledgedBytesRead outside the stream lock.
+        updateConnectionFlowControl(read);
+        return read;
+      }
+
+      if (errorCode != null) {
+        // We defer throwing the exception until now so that we can refill the connection
+        // flow-control window. This is necessary because we don't transmit window updates until the
+        // application reads the data. If we throw this prior to updating the connection
+        // flow-control window, we risk having it go to 0 preventing the server from sending data.
+        throw new StreamResetException(errorCode);
       }
 
-      return read;
+      return -1; // This source is exhausted.
+    }
+
+    private void updateConnectionFlowControl(long read) {
+      assert (!Thread.holdsLock(Http2Stream.this));
+      connection.updateConnectionFlowControl(read);
     }
 
     /** Returns once the source is either readable or finished. */
@@ -421,21 +446,17 @@ void receive(BufferedSource in, long byteCount) throws IOException {
     }
 
     @Override public void close() throws IOException {
+      long bytesDiscarded;
       synchronized (Http2Stream.this) {
         closed = true;
+        bytesDiscarded = readBuffer.size();
         readBuffer.clear();
         Http2Stream.this.notifyAll();
       }
-      cancelStreamIfNecessary();
-    }
-
-    private void checkNotClosed() throws IOException {
-      if (closed) {
-        throw new IOException("stream closed");
-      }
-      if (errorCode != null) {
-        throw new StreamResetException(errorCode);
+      if (bytesDiscarded > 0) {
+        updateConnectionFlowControl(bytesDiscarded);
       }
+      cancelStreamIfNecessary();
     }
   }
 
@@ -458,10 +479,8 @@ void cancelStreamIfNecessary() throws IOException {
     }
   }
 
-  /**
-   * A sink that writes outgoing data frames of a stream. This class is not thread safe.
-   */
-  final class FramedDataSink implements Sink {
+  /** A sink that writes outgoing data frames of a stream. This class is not thread safe. */
+  final class FramingSink implements Sink {
     private static final long EMIT_BUFFER_SIZE = 16384;
 
     /**
@@ -481,7 +500,7 @@ void cancelStreamIfNecessary() throws IOException {
       assert (!Thread.holdsLock(Http2Stream.this));
       sendBuffer.write(source, byteCount);
       while (sendBuffer.size() >= EMIT_BUFFER_SIZE) {
-        emitDataFrame(false);
+        emitFrame(false);
       }
     }
 
@@ -489,7 +508,7 @@ void cancelStreamIfNecessary() throws IOException {
      * Emit a single data frame to the connection. The frame's size be limited by this stream's
      * write window. This method will block until the write window is nonempty.
      */
-    private void emitDataFrame(boolean outFinished) throws IOException {
+    private void emitFrame(boolean outFinished) throws IOException {
       long toWrite;
       synchronized (Http2Stream.this) {
         writeTimeout.enter();
@@ -520,7 +539,7 @@ private void emitDataFrame(boolean outFinished) throws IOException {
         checkOutNotClosed();
       }
       while (sendBuffer.size() > 0) {
-        emitDataFrame(false);
+        emitFrame(false);
         connection.flush();
       }
     }
@@ -538,7 +557,7 @@ private void emitDataFrame(boolean outFinished) throws IOException {
         // Emit the remaining data, setting the END_STREAM flag on the last frame.
         if (sendBuffer.size() > 0) {
           while (sendBuffer.size() > 0) {
-            emitDataFrame(true);
+            emitFrame(true);
           }
         } else {
           // Send an empty frame just so we can set the END_STREAM flag.
@@ -579,6 +598,7 @@ void waitForIo() throws InterruptedIOException {
     try {
       wait();
     } catch (InterruptedException e) {
+      Thread.currentThread().interrupt(); // Retain interrupted status.
       throw new InterruptedIOException();
     }
   }
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java b/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
index 7490b09ba0..5ef6bb9c4a 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Http2Writer.java
@@ -54,7 +54,7 @@
 
   final Hpack.Writer hpackWriter;
 
-  public Http2Writer(BufferedSink sink, boolean client) {
+  Http2Writer(BufferedSink sink, boolean client) {
     this.sink = sink;
     this.client = client;
     this.hpackBuffer = new Buffer();
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Ping.java b/okhttp/src/main/java/okhttp3/internal/http2/Ping.java
deleted file mode 100644
index 7847db7aab..0000000000
--- a/okhttp/src/main/java/okhttp3/internal/http2/Ping.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (C) 2012 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package okhttp3.internal.http2;
-
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-
-/**
- * A locally-originated ping.
- */
-final class Ping {
-  private final CountDownLatch latch = new CountDownLatch(1);
-  private long sent = -1;
-  private long received = -1;
-
-  Ping() {
-  }
-
-  void send() {
-    if (sent != -1) throw new IllegalStateException();
-    sent = System.nanoTime();
-  }
-
-  void receive() {
-    if (received != -1 || sent == -1) throw new IllegalStateException();
-    received = System.nanoTime();
-    latch.countDown();
-  }
-
-  void cancel() {
-    if (received != -1 || sent == -1) throw new IllegalStateException();
-    received = sent - 1;
-    latch.countDown();
-  }
-
-  /**
-   * Returns the round trip time for this ping in nanoseconds, waiting for the response to arrive if
-   * necessary. Returns -1 if the response was canceled.
-   */
-  public long roundTripTime() throws InterruptedException {
-    latch.await();
-    return received - sent;
-  }
-
-  /**
-   * Returns the round trip time for this ping in nanoseconds, or -1 if the response was canceled,
-   * or -2 if the timeout elapsed before the round trip completed.
-   */
-  public long roundTripTime(long timeout, TimeUnit unit) throws InterruptedException {
-    if (latch.await(timeout, unit)) {
-      return received - sent;
-    } else {
-      return -2;
-    }
-  }
-}
diff --git a/okhttp/src/main/java/okhttp3/internal/http2/Settings.java b/okhttp/src/main/java/okhttp3/internal/http2/Settings.java
index a43280c695..5b548de484 100644
--- a/okhttp/src/main/java/okhttp3/internal/http2/Settings.java
+++ b/okhttp/src/main/java/okhttp3/internal/http2/Settings.java
@@ -56,7 +56,7 @@ void clear() {
   }
 
   Settings set(int id, int value) {
-    if (id >= values.length) {
+    if (id < 0 || id >= values.length) {
       return this; // Discard unknown settings.
     }
 
@@ -94,7 +94,6 @@ boolean getEnablePush(boolean defaultValue) {
     return ((bit & set) != 0 ? values[ENABLE_PUSH] : defaultValue ? 1 : 0) == 1;
   }
 
-  // TODO: honor this setting.
   int getMaxConcurrentStreams(int defaultValue) {
     int bit = 1 << MAX_CONCURRENT_STREAMS;
     return (bit & set) != 0 ? values[MAX_CONCURRENT_STREAMS] : defaultValue;
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
index c2cce4b0fb..3721b6a5c7 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/AndroidPlatform.java
@@ -15,6 +15,7 @@
  */
 package okhttp3.internal.platform;
 
+import android.os.Build;
 import android.util.Log;
 import java.io.IOException;
 import java.lang.reflect.Constructor;
@@ -22,16 +23,25 @@
 import java.lang.reflect.Method;
 import java.net.InetSocketAddress;
 import java.net.Socket;
+import java.security.NoSuchAlgorithmException;
+import java.security.Security;
 import java.security.cert.Certificate;
+import java.security.cert.TrustAnchor;
 import java.security.cert.X509Certificate;
 import java.util.List;
+import javax.annotation.Nullable;
+import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.X509TrustManager;
 import okhttp3.Protocol;
 import okhttp3.internal.Util;
+import okhttp3.internal.tls.BasicTrustRootIndex;
 import okhttp3.internal.tls.CertificateChainCleaner;
+import okhttp3.internal.tls.TrustRootIndex;
+
+import static okhttp3.internal.Util.assertionError;
 
 /** Android 2.3 or better. */
 class AndroidPlatform extends Platform {
@@ -47,7 +57,7 @@
 
   private final CloseGuard closeGuard = CloseGuard.get();
 
-  public AndroidPlatform(Class<?> sslParametersClass, OptionalMethod<Socket> setUseSessionTickets,
+  AndroidPlatform(Class<?> sslParametersClass, OptionalMethod<Socket> setUseSessionTickets,
       OptionalMethod<Socket> setHostname, OptionalMethod<Socket> getAlpnSelectedProtocol,
       OptionalMethod<Socket> setAlpnProtocols) {
     this.sslParametersClass = sslParametersClass;
@@ -70,10 +80,20 @@ public AndroidPlatform(Class<?> sslParametersClass, OptionalMethod<Socket> setUs
       IOException ioException = new IOException("Exception in connect");
       ioException.initCause(e);
       throw ioException;
+    } catch (ClassCastException e) {
+      // On android 8.0, socket.connect throws a ClassCastException due to a bug
+      // see https://issuetracker.google.com/issues/63649622
+      if (Build.VERSION.SDK_INT == 26) {
+        IOException ioException = new IOException("Exception in connect");
+        ioException.initCause(e);
+        throw ioException;
+      } else {
+        throw e;
+      }
     }
   }
 
-  @Override public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
+  @Override protected @Nullable X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
     Object context = readFieldOrNull(sslSocketFactory, sslParametersClass, "sslParameters");
     if (context == null) {
       // If that didn't work, try the Google Play Services SSL provider before giving up. This
@@ -110,7 +130,7 @@ public AndroidPlatform(Class<?> sslParametersClass, OptionalMethod<Socket> setUs
     }
   }
 
-  @Override public String getSelectedProtocol(SSLSocket socket) {
+  @Override public @Nullable String getSelectedProtocol(SSLSocket socket) {
     if (getAlpnSelectedProtocol == null) return null;
     if (!getAlpnSelectedProtocol.isSupported(socket)) return null;
 
@@ -118,7 +138,7 @@ public AndroidPlatform(Class<?> sslParametersClass, OptionalMethod<Socket> setUs
     return alpnResult != null ? new String(alpnResult, Util.UTF_8) : null;
   }
 
-  @Override public void log(int level, String message, Throwable t) {
+  @Override public void log(int level, String message, @Nullable Throwable t) {
     int logLevel = level == WARN ? Log.WARN : Log.DEBUG;
     if (t != null) message = message + '\n' + Log.getStackTraceString(t);
 
@@ -151,16 +171,53 @@ public AndroidPlatform(Class<?> sslParametersClass, OptionalMethod<Socket> setUs
       Class<?> networkPolicyClass = Class.forName("android.security.NetworkSecurityPolicy");
       Method getInstanceMethod = networkPolicyClass.getMethod("getInstance");
       Object networkSecurityPolicy = getInstanceMethod.invoke(null);
+      return api24IsCleartextTrafficPermitted(hostname, networkPolicyClass, networkSecurityPolicy);
+    } catch (ClassNotFoundException | NoSuchMethodException e) {
+      return super.isCleartextTrafficPermitted(hostname);
+    } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
+      throw assertionError("unable to determine cleartext support", e);
+    }
+  }
+
+  private boolean api24IsCleartextTrafficPermitted(String hostname, Class<?> networkPolicyClass,
+      Object networkSecurityPolicy) throws InvocationTargetException, IllegalAccessException {
+    try {
       Method isCleartextTrafficPermittedMethod = networkPolicyClass
           .getMethod("isCleartextTrafficPermitted", String.class);
       return (boolean) isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy, hostname);
-    } catch (ClassNotFoundException | NoSuchMethodException e) {
+    } catch (NoSuchMethodException e) {
+      return api23IsCleartextTrafficPermitted(hostname, networkPolicyClass, networkSecurityPolicy);
+    }
+  }
+
+  private boolean api23IsCleartextTrafficPermitted(String hostname, Class<?> networkPolicyClass,
+      Object networkSecurityPolicy) throws InvocationTargetException, IllegalAccessException {
+    try {
+      Method isCleartextTrafficPermittedMethod = networkPolicyClass
+          .getMethod("isCleartextTrafficPermitted");
+      return (boolean) isCleartextTrafficPermittedMethod.invoke(networkSecurityPolicy);
+    } catch (NoSuchMethodException e) {
       return super.isCleartextTrafficPermitted(hostname);
-    } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
-      throw new AssertionError();
     }
   }
 
+  /**
+   * Checks to see if Google Play Services Dynamic Security Provider is present which provides ALPN
+   * support. If it isn't checks to see if device is Android 5.0+ since 4.x device have broken
+   * ALPN support.
+   */
+  private static boolean supportsAlpn() {
+    if (Security.getProvider("GMSCore_OpenSSL") != null) {
+      return true;
+    } else {
+      try {
+        Class.forName("android.net.Network"); // Arbitrary class added in Android 5.0.
+        return true;
+      } catch (ClassNotFoundException ignored) { }
+    }
+    return false;
+  }
+
   public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager trustManager) {
     try {
       Class<?> extensionsClass = Class.forName("android.net.http.X509TrustManagerExtensions");
@@ -193,12 +250,11 @@ public static Platform buildIfSupported() {
       OptionalMethod<Socket> getAlpnSelectedProtocol = null;
       OptionalMethod<Socket> setAlpnProtocols = null;
 
-      // Attempt to find Android 5.0+ APIs.
-      try {
-        Class.forName("android.net.Network"); // Arbitrary class added in Android 5.0.
-        getAlpnSelectedProtocol = new OptionalMethod<>(byte[].class, "getAlpnSelectedProtocol");
-        setAlpnProtocols = new OptionalMethod<>(null, "setAlpnProtocols", byte[].class);
-      } catch (ClassNotFoundException ignored) {
+      if (supportsAlpn()) {
+        getAlpnSelectedProtocol
+            = new OptionalMethod<>(byte[].class, "getAlpnSelectedProtocol");
+        setAlpnProtocols
+            = new OptionalMethod<>(null, "setAlpnProtocols", byte[].class);
       }
 
       return new AndroidPlatform(sslParametersClass, setUseSessionTickets, setHostname,
@@ -210,6 +266,21 @@ public static Platform buildIfSupported() {
     return null;
   }
 
+  @Override
+  public TrustRootIndex buildTrustRootIndex(X509TrustManager trustManager) {
+
+    try {
+      // From org.conscrypt.TrustManagerImpl, we want the method with this signature:
+      // private TrustAnchor findTrustAnchorByIssuerAndSignature(X509Certificate lastCert);
+      Method method = trustManager.getClass().getDeclaredMethod(
+              "findTrustAnchorByIssuerAndSignature", X509Certificate.class);
+      method.setAccessible(true);
+      return new AndroidTrustRootIndex(trustManager, method);
+    } catch (NoSuchMethodException e) {
+      return super.buildTrustRootIndex(trustManager);
+    }
+  }
+
   /**
    * X509TrustManagerExtensions was added to Android in API 17 (Android 4.2, released in late 2012).
    * This is the best way to get a clean chain on Android because it uses the same code as the TLS
@@ -307,4 +378,71 @@ static CloseGuard get() {
       return new CloseGuard(getMethod, openMethod, warnIfOpenMethod);
     }
   }
+
+  /**
+   * An index of trusted root certificates that exploits knowledge of Android implementation
+   * details. This class is potentially much faster to initialize than {@link BasicTrustRootIndex}
+   * because it doesn't need to load and index trusted CA certificates.
+   *
+   * <p>This class uses APIs added to Android in API 14 (Android 4.0, released October 2011). This
+   * class shouldn't be used in Android API 17 or better because those releases are better served by
+   * {@link AndroidPlatform.AndroidCertificateChainCleaner}.
+   */
+  static final class AndroidTrustRootIndex implements TrustRootIndex {
+    private final X509TrustManager trustManager;
+    private final Method findByIssuerAndSignatureMethod;
+
+    AndroidTrustRootIndex(X509TrustManager trustManager, Method findByIssuerAndSignatureMethod) {
+      this.findByIssuerAndSignatureMethod = findByIssuerAndSignatureMethod;
+      this.trustManager = trustManager;
+    }
+
+    @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
+      try {
+        TrustAnchor trustAnchor = (TrustAnchor) findByIssuerAndSignatureMethod.invoke(
+                trustManager, cert);
+        return trustAnchor != null
+                ? trustAnchor.getTrustedCert()
+                : null;
+      } catch (IllegalAccessException e) {
+        throw assertionError("unable to get issues and signature", e);
+      } catch (InvocationTargetException e) {
+        return null;
+      }
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      if (obj == this) {
+        return true;
+      }
+      if (!(obj instanceof AndroidTrustRootIndex)) {
+        return false;
+      }
+      AndroidTrustRootIndex that = (AndroidTrustRootIndex) obj;
+      return trustManager.equals(that.trustManager)
+              && findByIssuerAndSignatureMethod.equals(that.findByIssuerAndSignatureMethod);
+    }
+
+    @Override
+    public int hashCode() {
+      return trustManager.hashCode() + 31 * findByIssuerAndSignatureMethod.hashCode();
+    }
+  }
+
+  @Override public SSLContext getSSLContext() {
+    if (Build.VERSION.SDK_INT >= 16 && Build.VERSION.SDK_INT < 22) {
+      try {
+        return SSLContext.getInstance("TLSv1.2");
+      } catch (NoSuchAlgorithmException e) {
+        // fallback to TLS
+      }
+    }
+
+    try {
+      return SSLContext.getInstance("TLS");
+    } catch (NoSuchAlgorithmException e) {
+      throw new IllegalStateException("No TLS provider", e);
+    }
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.java
new file mode 100644
index 0000000000..5050c067cb
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/platform/ConscryptPlatform.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.platform;
+
+import java.security.NoSuchAlgorithmException;
+import java.security.Provider;
+import java.util.List;
+import javax.annotation.Nullable;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocket;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.X509TrustManager;
+import okhttp3.Protocol;
+import org.conscrypt.Conscrypt;
+import org.conscrypt.OpenSSLProvider;
+
+/**
+ * Platform using Conscrypt (conscrypt.org) if installed as the first Security Provider.
+ *
+ * Requires org.conscrypt:conscrypt-openjdk-uber on the classpath.
+ */
+public class ConscryptPlatform extends Platform {
+  private ConscryptPlatform() {
+  }
+
+  private Provider getProvider() {
+    return new OpenSSLProvider();
+  }
+
+  @Override public @Nullable X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
+    if (!Conscrypt.isConscrypt(sslSocketFactory)) {
+      return super.trustManager(sslSocketFactory);
+    }
+
+    try {
+      // org.conscrypt.SSLParametersImpl
+      Object sp =
+          readFieldOrNull(sslSocketFactory, Object.class, "sslParameters");
+
+      if (sp != null) {
+        return readFieldOrNull(sp, X509TrustManager.class, "x509TrustManager");
+      }
+
+      return null;
+    } catch (Exception e) {
+      throw new UnsupportedOperationException(
+          "clientBuilder.sslSocketFactory(SSLSocketFactory) not supported on Conscrypt", e);
+    }
+  }
+
+  @Override public void configureTlsExtensions(
+      SSLSocket sslSocket, String hostname, List<Protocol> protocols) {
+    if (Conscrypt.isConscrypt(sslSocket)) {
+      // Enable SNI and session tickets.
+      if (hostname != null) {
+        Conscrypt.setUseSessionTickets(sslSocket, true);
+        Conscrypt.setHostname(sslSocket, hostname);
+      }
+
+      // Enable ALPN.
+      List<String> names = Platform.alpnProtocolNames(protocols);
+      Conscrypt.setApplicationProtocols(sslSocket, names.toArray(new String[0]));
+    } else {
+      super.configureTlsExtensions(sslSocket, hostname, protocols);
+    }
+  }
+
+  @Override public @Nullable String getSelectedProtocol(SSLSocket sslSocket) {
+    if (Conscrypt.isConscrypt(sslSocket)) {
+      return Conscrypt.getApplicationProtocol(sslSocket);
+    } else {
+      return super.getSelectedProtocol(sslSocket);
+    }
+  }
+
+  @Override public SSLContext getSSLContext() {
+    try {
+      return SSLContext.getInstance("TLS", getProvider());
+    } catch (NoSuchAlgorithmException e) {
+      throw new IllegalStateException("No TLS provider", e);
+    }
+  }
+
+  public static Platform buildIfSupported() {
+    try {
+      // trigger early exception over a fatal error
+      Class.forName("org.conscrypt.ConscryptEngineSocket");
+
+      if (!Conscrypt.isAvailable()) {
+        return null;
+      }
+
+      return new ConscryptPlatform();
+    } catch (ClassNotFoundException e) {
+      return null;
+    }
+  }
+
+  @Override
+  public void configureSslSocketFactory(SSLSocketFactory socketFactory) {
+    if (Conscrypt.isConscrypt(socketFactory)) {
+      Conscrypt.setUseEngineSocket(socketFactory, true);
+    }
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
index 683e5c1cd4..455e8bcbb8 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Jdk9Platform.java
@@ -18,12 +18,15 @@
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.List;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLParameters;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.X509TrustManager;
 import okhttp3.Protocol;
 
+import static okhttp3.internal.Util.assertionError;
+
 /**
  * OpenJDK 9+.
  */
@@ -31,7 +34,7 @@
   final Method setProtocolMethod;
   final Method getProtocolMethod;
 
-  public Jdk9Platform(Method setProtocolMethod, Method getProtocolMethod) {
+  Jdk9Platform(Method setProtocolMethod, Method getProtocolMethod) {
     this.setProtocolMethod = setProtocolMethod;
     this.getProtocolMethod = getProtocolMethod;
   }
@@ -49,12 +52,12 @@ public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
 
       sslSocket.setSSLParameters(sslParameters);
     } catch (IllegalAccessException | InvocationTargetException e) {
-      throw new AssertionError();
+      throw assertionError("unable to set ssl parameters", e);
     }
   }
 
   @Override
-  public String getSelectedProtocol(SSLSocket socket) {
+  public @Nullable String getSelectedProtocol(SSLSocket socket) {
     try {
       String protocol = (String) getProtocolMethod.invoke(socket);
 
@@ -66,7 +69,7 @@ public String getSelectedProtocol(SSLSocket socket) {
 
       return protocol;
     } catch (IllegalAccessException | InvocationTargetException e) {
-      throw new AssertionError();
+      throw assertionError("unable to get selected protocols", e);
     }
   }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java b/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
index 6821bdf497..dee0b3fe53 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/JdkWithJettyBootPlatform.java
@@ -20,10 +20,13 @@
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.util.List;
+import javax.annotation.Nullable;
 import javax.net.ssl.SSLSocket;
 import okhttp3.Protocol;
 import okhttp3.internal.Util;
 
+import static okhttp3.internal.Util.assertionError;
+
 /**
  * OpenJDK 7 or OpenJDK 8 with {@code org.mortbay.jetty.alpn/alpn-boot} in the boot class path.
  */
@@ -34,7 +37,7 @@
   private final Class<?> clientProviderClass;
   private final Class<?> serverProviderClass;
 
-  public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method removeMethod,
+  JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method removeMethod,
       Class<?> clientProviderClass, Class<?> serverProviderClass) {
     this.putMethod = putMethod;
     this.getMethod = getMethod;
@@ -52,19 +55,19 @@ public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method remov
           new Class[] {clientProviderClass, serverProviderClass}, new JettyNegoProvider(names));
       putMethod.invoke(null, sslSocket, provider);
     } catch (InvocationTargetException | IllegalAccessException e) {
-      throw new AssertionError(e);
+      throw assertionError("unable to set alpn", e);
     }
   }
 
   @Override public void afterHandshake(SSLSocket sslSocket) {
     try {
       removeMethod.invoke(null, sslSocket);
-    } catch (IllegalAccessException | InvocationTargetException ignored) {
-      throw new AssertionError();
+    } catch (IllegalAccessException | InvocationTargetException e) {
+      throw assertionError("unable to remove alpn", e);
     }
   }
 
-  @Override public String getSelectedProtocol(SSLSocket socket) {
+  @Override public @Nullable String getSelectedProtocol(SSLSocket socket) {
     try {
       JettyNegoProvider provider =
           (JettyNegoProvider) Proxy.getInvocationHandler(getMethod.invoke(null, socket));
@@ -75,7 +78,7 @@ public JdkWithJettyBootPlatform(Method putMethod, Method getMethod, Method remov
       }
       return provider.unsupported ? null : provider.selected;
     } catch (InvocationTargetException | IllegalAccessException e) {
-      throw new AssertionError();
+      throw assertionError("unable to get selected protocol", e);
     }
   }
 
@@ -110,7 +113,7 @@ public static Platform buildIfSupported() {
     /** The protocol the server selected. */
     String selected;
 
-    public JettyNegoProvider(List<String> protocols) {
+    JettyNegoProvider(List<String> protocols) {
       this.protocols = protocols;
     }
 
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/OptionalMethod.java b/okhttp/src/main/java/okhttp3/internal/platform/OptionalMethod.java
index b7b1717b0e..c26132fedb 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/OptionalMethod.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/OptionalMethod.java
@@ -42,7 +42,7 @@
    * @param methodName the name of the method
    * @param methodParams the method parameter types
    */
-  public OptionalMethod(Class<?> returnType, String methodName, Class... methodParams) {
+  OptionalMethod(Class<?> returnType, String methodName, Class... methodParams) {
     this.returnType = returnType;
     this.methodName = methodName;
     this.methodParams = methodParams;
diff --git a/okhttp/src/main/java/okhttp3/internal/platform/Platform.java b/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
index 83c36fdd0f..db136a589f 100644
--- a/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
+++ b/okhttp/src/main/java/okhttp3/internal/platform/Platform.java
@@ -20,16 +20,21 @@
 import java.lang.reflect.Field;
 import java.net.InetSocketAddress;
 import java.net.Socket;
+import java.security.NoSuchAlgorithmException;
+import java.security.Security;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.logging.Level;
 import java.util.logging.Logger;
+import javax.annotation.Nullable;
+import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.X509TrustManager;
 import okhttp3.OkHttpClient;
 import okhttp3.Protocol;
 import okhttp3.internal.tls.BasicCertificateChainCleaner;
+import okhttp3.internal.tls.BasicTrustRootIndex;
 import okhttp3.internal.tls.CertificateChainCleaner;
 import okhttp3.internal.tls.TrustRootIndex;
 import okio.Buffer;
@@ -84,7 +89,7 @@ public String getPrefix() {
     return "OkHttp";
   }
 
-  public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
+  protected @Nullable X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
     // Attempt to get the trust manager from an OpenJDK socket factory. We attempt this on all
     // platforms in order to support Robolectric, which mixes classes from both Android and the
     // Oracle JDK. Note that we don't support HTTP/2 or other nice features on Robolectric.
@@ -103,7 +108,7 @@ public X509TrustManager trustManager(SSLSocketFactory sslSocketFactory) {
    *
    * @param hostname non-null for client-side handshakes; null for server-side handshakes.
    */
-  public void configureTlsExtensions(SSLSocket sslSocket, String hostname,
+  public void configureTlsExtensions(SSLSocket sslSocket, @Nullable String hostname,
       List<Protocol> protocols) {
   }
 
@@ -115,16 +120,16 @@ public void afterHandshake(SSLSocket sslSocket) {
   }
 
   /** Returns the negotiated protocol, or null if no protocol was negotiated. */
-  public String getSelectedProtocol(SSLSocket socket) {
+  public @Nullable String getSelectedProtocol(SSLSocket socket) {
     return null;
   }
 
-  public void connectSocket(Socket socket, InetSocketAddress address,
-      int connectTimeout) throws IOException {
+  public void connectSocket(Socket socket, InetSocketAddress address, int connectTimeout)
+      throws IOException {
     socket.connect(address, connectTimeout);
   }
 
-  public void log(int level, String message, Throwable t) {
+  public void log(int level, String message, @Nullable Throwable t) {
     Level logLevel = level == WARN ? Level.WARNING : Level.INFO;
     logger.log(logLevel, message, t);
   }
@@ -164,7 +169,31 @@ public void logCloseableLeak(String message, Object stackTrace) {
   }
 
   public CertificateChainCleaner buildCertificateChainCleaner(X509TrustManager trustManager) {
-    return new BasicCertificateChainCleaner(TrustRootIndex.get(trustManager));
+    return new BasicCertificateChainCleaner(buildTrustRootIndex(trustManager));
+  }
+
+  public CertificateChainCleaner buildCertificateChainCleaner(SSLSocketFactory sslSocketFactory) {
+    X509TrustManager trustManager = trustManager(sslSocketFactory);
+
+    if (trustManager == null) {
+      throw new IllegalStateException("Unable to extract the trust manager on "
+          + Platform.get()
+          + ", sslSocketFactory is "
+          + sslSocketFactory.getClass());
+    }
+
+    return buildCertificateChainCleaner(trustManager);
+  }
+
+  public static boolean isConscryptPreferred() {
+    // mainly to allow tests to run cleanly
+    if ("conscrypt".equals(System.getProperty("okhttp.platform"))) {
+      return true;
+    }
+
+    // check if Provider manually installed
+    String preferredProvider = Security.getProviders()[0].getName();
+    return "Conscrypt".equals(preferredProvider);
   }
 
   /** Attempt to match the host runtime to a capable Platform implementation. */
@@ -175,6 +204,14 @@ private static Platform findPlatform() {
       return android;
     }
 
+    if (isConscryptPreferred()) {
+      Platform conscrypt = ConscryptPlatform.buildIfSupported();
+
+      if (conscrypt != null) {
+        return conscrypt;
+      }
+    }
+
     Platform jdk9 = Jdk9Platform.buildIfSupported();
 
     if (jdk9 != null) {
@@ -206,7 +243,7 @@ private static Platform findPlatform() {
     return result.readByteArray();
   }
 
-  static <T> T readFieldOrNull(Object instance, Class<T> fieldType, String fieldName) {
+  static @Nullable <T> T readFieldOrNull(Object instance, Class<T> fieldType, String fieldName) {
     for (Class<?> c = instance.getClass(); c != Object.class; c = c.getSuperclass()) {
       try {
         Field field = c.getDeclaredField(fieldName);
@@ -228,4 +265,29 @@ private static Platform findPlatform() {
 
     return null;
   }
+
+  public SSLContext getSSLContext() {
+    String jvmVersion = System.getProperty("java.specification.version");
+    if ("1.7".equals(jvmVersion)) {
+      try {
+        // JDK 1.7 (public version) only support > TLSv1 with named protocols
+        return SSLContext.getInstance("TLSv1.2");
+      } catch (NoSuchAlgorithmException e) {
+        // fallback to TLS
+      }
+    }
+
+    try {
+      return SSLContext.getInstance("TLS");
+    } catch (NoSuchAlgorithmException e) {
+      throw new IllegalStateException("No TLS provider", e);
+    }
+  }
+
+  public TrustRootIndex buildTrustRootIndex(X509TrustManager trustManager) {
+    return new BasicTrustRootIndex(trustManager.getAcceptedIssuers());
+  }
+
+  public void configureSslSocketFactory(SSLSocketFactory socketFactory) {
+  }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java b/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
new file mode 100644
index 0000000000..af10898a38
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/publicsuffix/PublicSuffixDatabase.java
@@ -0,0 +1,343 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.publicsuffix;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InterruptedIOException;
+import java.net.IDN;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.atomic.AtomicBoolean;
+import okhttp3.internal.Util;
+import okhttp3.internal.platform.Platform;
+import okio.BufferedSource;
+import okio.GzipSource;
+import okio.Okio;
+
+import static okhttp3.internal.Util.closeQuietly;
+
+/**
+ * A database of public suffixes provided by
+ * <a href="https://publicsuffix.org/">publicsuffix.org</a>.
+ */
+public final class PublicSuffixDatabase {
+  public static final String PUBLIC_SUFFIX_RESOURCE = "publicsuffixes.gz";
+
+  private static final byte[] WILDCARD_LABEL = new byte[]{'*'};
+  private static final String[] EMPTY_RULE = new String[0];
+  private static final String[] PREVAILING_RULE = new String[]{"*"};
+
+  private static final byte EXCEPTION_MARKER = '!';
+
+  private static final PublicSuffixDatabase instance = new PublicSuffixDatabase();
+
+  /** True after we've attempted to read the list for the first time. */
+  private final AtomicBoolean listRead = new AtomicBoolean(false);
+
+  /** Used for concurrent threads reading the list for the first time. */
+  private final CountDownLatch readCompleteLatch = new CountDownLatch(1);
+
+  // The lists are held as a large array of UTF-8 bytes. This is to avoid allocating lots of strings
+  // that will likely never be used. Each rule is separated by '\n'. Please see the
+  // PublicSuffixListGenerator class for how these lists are generated.
+  // Guarded by this.
+  private byte[] publicSuffixListBytes;
+  private byte[] publicSuffixExceptionListBytes;
+
+  public static PublicSuffixDatabase get() {
+    return instance;
+  }
+
+  /**
+   * Returns the effective top-level domain plus one (eTLD+1) by referencing the public suffix list.
+   * Returns null if the domain is a public suffix or a private address.
+   *
+   * <p>Here are some examples: <pre>{@code
+   * assertEquals("google.com", getEffectiveTldPlusOne("google.com"));
+   * assertEquals("google.com", getEffectiveTldPlusOne("www.google.com"));
+   * assertNull(getEffectiveTldPlusOne("com"));
+   * assertNull(getEffectiveTldPlusOne("localhost"));
+   * assertNull(getEffectiveTldPlusOne("mymacbook"));
+   * }</pre>
+   *
+   * @param domain A canonicalized domain. An International Domain Name (IDN) should be punycode
+   *    encoded.
+   */
+  public String getEffectiveTldPlusOne(String domain) {
+    if (domain == null) throw new NullPointerException("domain == null");
+
+    // We use UTF-8 in the list so we need to convert to Unicode.
+    String unicodeDomain = IDN.toUnicode(domain);
+    String[] domainLabels = unicodeDomain.split("\\.");
+    String[] rule = findMatchingRule(domainLabels);
+    if (domainLabels.length == rule.length && rule[0].charAt(0) != EXCEPTION_MARKER) {
+      // The domain is a public suffix.
+      return null;
+    }
+
+    int firstLabelOffset;
+    if (rule[0].charAt(0) == EXCEPTION_MARKER) {
+      // Exception rules hold the effective TLD plus one.
+      firstLabelOffset = domainLabels.length - rule.length;
+    } else {
+      // Otherwise the rule is for a public suffix, so we must take one more label.
+      firstLabelOffset = domainLabels.length - (rule.length + 1);
+    }
+
+    StringBuilder effectiveTldPlusOne = new StringBuilder();
+    String[] punycodeLabels = domain.split("\\.");
+    for (int i = firstLabelOffset; i < punycodeLabels.length; i++) {
+      effectiveTldPlusOne.append(punycodeLabels[i]).append('.');
+    }
+    effectiveTldPlusOne.deleteCharAt(effectiveTldPlusOne.length() - 1);
+
+    return effectiveTldPlusOne.toString();
+  }
+
+  private String[] findMatchingRule(String[] domainLabels) {
+    if (!listRead.get() && listRead.compareAndSet(false, true)) {
+      readTheListUninterruptibly();
+    } else {
+      try {
+        readCompleteLatch.await();
+      } catch (InterruptedException ignored) {
+        Thread.currentThread().interrupt(); // Retain interrupted status.
+      }
+    }
+
+    synchronized (this) {
+      if (publicSuffixListBytes == null) {
+        throw new IllegalStateException("Unable to load " + PUBLIC_SUFFIX_RESOURCE + " resource "
+            + "from the classpath.");
+      }
+    }
+
+    // Break apart the domain into UTF-8 labels, i.e. foo.bar.com turns into [foo, bar, com].
+    byte[][] domainLabelsUtf8Bytes = new byte[domainLabels.length][];
+    for (int i = 0; i < domainLabels.length; i++) {
+      domainLabelsUtf8Bytes[i] = domainLabels[i].getBytes(Util.UTF_8);
+    }
+
+    // Start by looking for exact matches. We start at the leftmost label. For example, foo.bar.com
+    // will look like: [foo, bar, com], [bar, com], [com]. The longest matching rule wins.
+    String exactMatch = null;
+    for (int i = 0; i < domainLabelsUtf8Bytes.length; i++) {
+      String rule = binarySearchBytes(publicSuffixListBytes, domainLabelsUtf8Bytes, i);
+      if (rule != null) {
+        exactMatch = rule;
+        break;
+      }
+    }
+
+    // In theory, wildcard rules are not restricted to having the wildcard in the leftmost position.
+    // In practice, wildcards are always in the leftmost position. For now, this implementation
+    // cheats and does not attempt every possible permutation. Instead, it only considers wildcards
+    // in the leftmost position. We assert this fact when we generate the public suffix file. If
+    // this assertion ever fails we'll need to refactor this implementation.
+    String wildcardMatch = null;
+    if (domainLabelsUtf8Bytes.length > 1) {
+      byte[][] labelsWithWildcard = domainLabelsUtf8Bytes.clone();
+      for (int labelIndex = 0; labelIndex < labelsWithWildcard.length - 1; labelIndex++) {
+        labelsWithWildcard[labelIndex] = WILDCARD_LABEL;
+        String rule = binarySearchBytes(publicSuffixListBytes, labelsWithWildcard, labelIndex);
+        if (rule != null) {
+          wildcardMatch = rule;
+          break;
+        }
+      }
+    }
+
+    // Exception rules only apply to wildcard rules, so only try it if we matched a wildcard.
+    String exception = null;
+    if (wildcardMatch != null) {
+      for (int labelIndex = 0; labelIndex < domainLabelsUtf8Bytes.length - 1; labelIndex++) {
+        String rule = binarySearchBytes(
+            publicSuffixExceptionListBytes, domainLabelsUtf8Bytes, labelIndex);
+        if (rule != null) {
+          exception = rule;
+          break;
+        }
+      }
+    }
+
+    if (exception != null) {
+      // Signal we've identified an exception rule.
+      exception = "!" + exception;
+      return exception.split("\\.");
+    } else if (exactMatch == null && wildcardMatch == null) {
+      return PREVAILING_RULE;
+    }
+
+    String[] exactRuleLabels = exactMatch != null
+        ? exactMatch.split("\\.")
+        : EMPTY_RULE;
+
+    String[] wildcardRuleLabels = wildcardMatch != null
+        ? wildcardMatch.split("\\.")
+        : EMPTY_RULE;
+
+    return exactRuleLabels.length > wildcardRuleLabels.length
+        ? exactRuleLabels
+        : wildcardRuleLabels;
+  }
+
+  private static String binarySearchBytes(byte[] bytesToSearch, byte[][] labels, int labelIndex) {
+    int low = 0;
+    int high = bytesToSearch.length;
+    String match = null;
+    while (low < high) {
+      int mid = (low + high) / 2;
+      // Search for a '\n' that marks the start of a value. Don't go back past the start of the
+      // array.
+      while (mid > -1 && bytesToSearch[mid] != '\n') {
+        mid--;
+      }
+      mid++;
+
+      // Now look for the ending '\n'.
+      int end = 1;
+      while (bytesToSearch[mid + end] != '\n') {
+        end++;
+      }
+      int publicSuffixLength = (mid + end) - mid;
+
+      // Compare the bytes. Note that the file stores UTF-8 encoded bytes, so we must compare the
+      // unsigned bytes.
+      int compareResult;
+      int currentLabelIndex = labelIndex;
+      int currentLabelByteIndex = 0;
+      int publicSuffixByteIndex = 0;
+
+      boolean expectDot = false;
+      while (true) {
+        int byte0;
+        if (expectDot) {
+          byte0 = '.';
+          expectDot = false;
+        } else {
+          byte0 = labels[currentLabelIndex][currentLabelByteIndex] & 0xff;
+        }
+
+        int byte1 = bytesToSearch[mid + publicSuffixByteIndex] & 0xff;
+
+        compareResult = byte0 - byte1;
+        if (compareResult != 0) break;
+
+        publicSuffixByteIndex++;
+        currentLabelByteIndex++;
+        if (publicSuffixByteIndex == publicSuffixLength) break;
+
+        if (labels[currentLabelIndex].length == currentLabelByteIndex) {
+          // We've exhausted our current label. Either there are more labels to compare, in which
+          // case we expect a dot as the next character. Otherwise, we've checked all our labels.
+          if (currentLabelIndex == labels.length - 1) {
+            break;
+          } else {
+            currentLabelIndex++;
+            currentLabelByteIndex = -1;
+            expectDot = true;
+          }
+        }
+      }
+
+      if (compareResult < 0) {
+        high = mid - 1;
+      } else if (compareResult > 0) {
+        low = mid + end + 1;
+      } else {
+        // We found a match, but are the lengths equal?
+        int publicSuffixBytesLeft = publicSuffixLength - publicSuffixByteIndex;
+        int labelBytesLeft = labels[currentLabelIndex].length - currentLabelByteIndex;
+        for (int i = currentLabelIndex + 1; i < labels.length; i++) {
+          labelBytesLeft += labels[i].length;
+        }
+
+        if (labelBytesLeft < publicSuffixBytesLeft) {
+          high = mid - 1;
+        } else if (labelBytesLeft > publicSuffixBytesLeft) {
+          low = mid + end + 1;
+        } else {
+          // Found a match.
+          match = new String(bytesToSearch, mid, publicSuffixLength, Util.UTF_8);
+          break;
+        }
+      }
+    }
+    return match;
+  }
+
+  /**
+   * Reads the public suffix list treating the operation as uninterruptible. We always want to read
+   * the list otherwise we'll be left in a bad state. If the thread was interrupted prior to this
+   * operation, it will be re-interrupted after the list is read.
+   */
+  private void readTheListUninterruptibly() {
+    boolean interrupted = false;
+    try {
+      while (true) {
+        try {
+          readTheList();
+          return;
+        } catch (InterruptedIOException e) {
+          interrupted = true;
+        } catch (IOException e) {
+          Platform.get().log(Platform.WARN, "Failed to read public suffix list", e);
+          return;
+        }
+      }
+    } finally {
+      if (interrupted) {
+        Thread.currentThread().interrupt(); // Retain interrupted status.
+      }
+    }
+  }
+
+  private void readTheList() throws IOException {
+    byte[] publicSuffixListBytes;
+    byte[] publicSuffixExceptionListBytes;
+
+    InputStream resource = PublicSuffixDatabase.class.getResourceAsStream(PUBLIC_SUFFIX_RESOURCE);
+    if (resource == null) return;
+
+    BufferedSource bufferedSource = Okio.buffer(new GzipSource(Okio.source(resource)));
+    try {
+      int totalBytes = bufferedSource.readInt();
+      publicSuffixListBytes = new byte[totalBytes];
+      bufferedSource.readFully(publicSuffixListBytes);
+
+      int totalExceptionBytes = bufferedSource.readInt();
+      publicSuffixExceptionListBytes = new byte[totalExceptionBytes];
+      bufferedSource.readFully(publicSuffixExceptionListBytes);
+    } finally {
+      closeQuietly(bufferedSource);
+    }
+
+    synchronized (this) {
+      this.publicSuffixListBytes = publicSuffixListBytes;
+      this.publicSuffixExceptionListBytes = publicSuffixExceptionListBytes;
+    }
+
+    readCompleteLatch.countDown();
+  }
+
+  /** Visible for testing. */
+  void setListBytes(byte[] publicSuffixListBytes, byte[] publicSuffixExceptionListBytes) {
+    this.publicSuffixListBytes = publicSuffixListBytes;
+    this.publicSuffixExceptionListBytes = publicSuffixExceptionListBytes;
+    listRead.set(true);
+    readCompleteLatch.countDown();
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/BasicTrustRootIndex.java b/okhttp/src/main/java/okhttp3/internal/tls/BasicTrustRootIndex.java
new file mode 100644
index 0000000000..cfd8923668
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/internal/tls/BasicTrustRootIndex.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2016 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.tls;
+
+import java.security.PublicKey;
+import java.security.cert.X509Certificate;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+import javax.security.auth.x500.X500Principal;
+
+/** A simple index that of trusted root certificates that have been loaded into memory. */
+public final class BasicTrustRootIndex implements TrustRootIndex {
+  private final Map<X500Principal, Set<X509Certificate>> subjectToCaCerts;
+
+  public BasicTrustRootIndex(X509Certificate... caCerts) {
+    subjectToCaCerts = new LinkedHashMap<>();
+    for (X509Certificate caCert : caCerts) {
+      X500Principal subject = caCert.getSubjectX500Principal();
+      Set<X509Certificate> subjectCaCerts = subjectToCaCerts.get(subject);
+      if (subjectCaCerts == null) {
+        subjectCaCerts = new LinkedHashSet<>(1);
+        subjectToCaCerts.put(subject, subjectCaCerts);
+      }
+      subjectCaCerts.add(caCert);
+    }
+  }
+
+  @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
+    X500Principal issuer = cert.getIssuerX500Principal();
+    Set<X509Certificate> subjectCaCerts = subjectToCaCerts.get(issuer);
+    if (subjectCaCerts == null) return null;
+
+    for (X509Certificate caCert : subjectCaCerts) {
+      PublicKey publicKey = caCert.getPublicKey();
+      try {
+        cert.verify(publicKey);
+        return caCert;
+      } catch (Exception ignored) {
+      }
+    }
+
+    return null;
+  }
+
+  @Override public boolean equals(Object other) {
+    if (other == this) return true;
+    return other instanceof okhttp3.internal.tls.BasicTrustRootIndex
+        && ((okhttp3.internal.tls.BasicTrustRootIndex) other).subjectToCaCerts.equals(
+        subjectToCaCerts);
+  }
+
+  @Override public int hashCode() {
+    return subjectToCaCerts.hashCode();
+  }
+}
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
index 3e69f23061..98060db27a 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/CertificateChainCleaner.java
@@ -42,6 +42,6 @@ public static CertificateChainCleaner get(X509TrustManager trustManager) {
   }
 
   public static CertificateChainCleaner get(X509Certificate... caCerts) {
-    return new BasicCertificateChainCleaner(TrustRootIndex.get(caCerts));
+    return new BasicCertificateChainCleaner(new BasicTrustRootIndex(caCerts));
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java b/okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java
index 616bca534a..cae8dfae76 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/DistinguishedNameParser.java
@@ -35,7 +35,7 @@
   /** Distinguished name characters. */
   private char[] chars;
 
-  public DistinguishedNameParser(X500Principal principal) {
+  DistinguishedNameParser(X500Principal principal) {
     // RFC2253 is used to ensure we get attributes in the reverse
     // order of the underlying ASN.1 encoding, so that the most
     // significant values of repeated attributes occur first.
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java b/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
index a85df784d7..36ac5b3813 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/OkHostnameVerifier.java
@@ -27,7 +27,6 @@
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLException;
 import javax.net.ssl.SSLSession;
-import javax.security.auth.x500.X500Principal;
 
 import static okhttp3.internal.Util.verifyAsIpAddress;
 
@@ -73,24 +72,12 @@ private boolean verifyIpAddress(String ipAddress, X509Certificate certificate) {
   /** Returns true if {@code certificate} matches {@code hostname}. */
   private boolean verifyHostname(String hostname, X509Certificate certificate) {
     hostname = hostname.toLowerCase(Locale.US);
-    boolean hasDns = false;
     List<String> altNames = getSubjectAltNames(certificate, ALT_DNS_NAME);
-    for (int i = 0, size = altNames.size(); i < size; i++) {
-      hasDns = true;
-      if (verifyHostname(hostname, altNames.get(i))) {
+    for (String altName : altNames) {
+      if (verifyHostname(hostname, altName)) {
         return true;
       }
     }
-
-    if (!hasDns) {
-      X500Principal principal = certificate.getSubjectX500Principal();
-      // RFC 2818 advises using the most specific name for matching.
-      String cn = new DistinguishedNameParser(principal).findMostSpecific("cn");
-      if (cn != null) {
-        return verifyHostname(hostname, cn);
-      }
-    }
-
     return false;
   }
 
@@ -139,7 +126,7 @@ private boolean verifyHostname(String hostname, X509Certificate certificate) {
    * @param pattern domain name pattern from certificate. May be a wildcard pattern such as {@code
    * *.android.com}.
    */
-  private boolean verifyHostname(String hostname, String pattern) {
+  public boolean verifyHostname(String hostname, String pattern) {
     // Basic sanity checks
     // Check length == 0 instead of .isEmpty() to support Java 5.
     if ((hostname == null) || (hostname.length() == 0) || (hostname.startsWith("."))
diff --git a/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java b/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
index e42ad1b0fc..499f120e33 100644
--- a/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
+++ b/okhttp/src/main/java/okhttp3/internal/tls/TrustRootIndex.java
@@ -15,132 +15,9 @@
  */
 package okhttp3.internal.tls;
 
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.security.PublicKey;
-import java.security.cert.TrustAnchor;
 import java.security.cert.X509Certificate;
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-import javax.net.ssl.X509TrustManager;
-import javax.security.auth.x500.X500Principal;
 
-public abstract class TrustRootIndex {
+public interface TrustRootIndex {
   /** Returns the trusted CA certificate that signed {@code cert}. */
-  public abstract X509Certificate findByIssuerAndSignature(X509Certificate cert);
-
-  public static TrustRootIndex get(X509TrustManager trustManager) {
-    try {
-      // From org.conscrypt.TrustManagerImpl, we want the method with this signature:
-      // private TrustAnchor findTrustAnchorByIssuerAndSignature(X509Certificate lastCert);
-      Method method = trustManager.getClass().getDeclaredMethod(
-          "findTrustAnchorByIssuerAndSignature", X509Certificate.class);
-      method.setAccessible(true);
-      return new AndroidTrustRootIndex(trustManager, method);
-    } catch (NoSuchMethodException e) {
-      return get(trustManager.getAcceptedIssuers());
-    }
-  }
-
-  public static TrustRootIndex get(X509Certificate... caCerts) {
-    return new BasicTrustRootIndex(caCerts);
-  }
-
-  /**
-   * An index of trusted root certificates that exploits knowledge of Android implementation
-   * details. This class is potentially much faster to initialize than {@link BasicTrustRootIndex}
-   * because it doesn't need to load and index trusted CA certificates.
-   *
-   * <p>This class uses APIs added to Android in API 14 (Android 4.0, released October 2011). This
-   * class shouldn't be used in Android API 17 or better because those releases are better served by
-   * {@link okhttp3.internal.AndroidPlatform.AndroidCertificateChainCleaner}.
-   */
-  static final class AndroidTrustRootIndex extends TrustRootIndex {
-    private final X509TrustManager trustManager;
-    private final Method findByIssuerAndSignatureMethod;
-
-    AndroidTrustRootIndex(X509TrustManager trustManager, Method findByIssuerAndSignatureMethod) {
-      this.findByIssuerAndSignatureMethod = findByIssuerAndSignatureMethod;
-      this.trustManager = trustManager;
-    }
-
-    @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
-      try {
-        TrustAnchor trustAnchor = (TrustAnchor) findByIssuerAndSignatureMethod.invoke(
-            trustManager, cert);
-        return trustAnchor != null
-            ? trustAnchor.getTrustedCert()
-            : null;
-      } catch (IllegalAccessException e) {
-        throw new AssertionError();
-      } catch (InvocationTargetException e) {
-        return null;
-      }
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-      if (obj == this) {
-        return true;
-      }
-      if (!(obj instanceof AndroidTrustRootIndex)) {
-        return false;
-      }
-      AndroidTrustRootIndex that = (AndroidTrustRootIndex) obj;
-      return trustManager.equals(that.trustManager)
-              && findByIssuerAndSignatureMethod.equals(that.findByIssuerAndSignatureMethod);
-    }
-
-    @Override
-    public int hashCode() {
-      return trustManager.hashCode() + 31 * findByIssuerAndSignatureMethod.hashCode();
-    }
-  }
-
-  /** A simple index that of trusted root certificates that have been loaded into memory. */
-  static final class BasicTrustRootIndex extends TrustRootIndex {
-    private final Map<X500Principal, Set<X509Certificate>> subjectToCaCerts;
-
-    public BasicTrustRootIndex(X509Certificate... caCerts) {
-      subjectToCaCerts = new LinkedHashMap<>();
-      for (X509Certificate caCert : caCerts) {
-        X500Principal subject = caCert.getSubjectX500Principal();
-        Set<X509Certificate> subjectCaCerts = subjectToCaCerts.get(subject);
-        if (subjectCaCerts == null) {
-          subjectCaCerts = new LinkedHashSet<>(1);
-          subjectToCaCerts.put(subject, subjectCaCerts);
-        }
-        subjectCaCerts.add(caCert);
-      }
-    }
-
-    @Override public X509Certificate findByIssuerAndSignature(X509Certificate cert) {
-      X500Principal issuer = cert.getIssuerX500Principal();
-      Set<X509Certificate> subjectCaCerts = subjectToCaCerts.get(issuer);
-      if (subjectCaCerts == null) return null;
-
-      for (X509Certificate caCert : subjectCaCerts) {
-        PublicKey publicKey = caCert.getPublicKey();
-        try {
-          cert.verify(publicKey);
-          return caCert;
-        } catch (Exception ignored) {
-        }
-      }
-
-      return null;
-    }
-
-    @Override public boolean equals(Object other) {
-      if (other == this) return true;
-      return other instanceof BasicTrustRootIndex
-          && ((BasicTrustRootIndex) other).subjectToCaCerts.equals(subjectToCaCerts);
-    }
-
-    @Override public int hashCode() {
-      return subjectToCaCerts.hashCode();
-    }
-  }
+  X509Certificate findByIssuerAndSignature(X509Certificate cert);
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
index 4be0381202..092dc5775e 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/RealWebSocket.java
@@ -18,6 +18,7 @@
 import java.io.Closeable;
 import java.io.IOException;
 import java.net.ProtocolException;
+import java.net.SocketTimeoutException;
 import java.util.ArrayDeque;
 import java.util.Collections;
 import java.util.List;
@@ -26,8 +27,10 @@
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import javax.annotation.Nullable;
 import okhttp3.Call;
 import okhttp3.Callback;
+import okhttp3.EventListener;
 import okhttp3.OkHttpClient;
 import okhttp3.Protocol;
 import okhttp3.Request;
@@ -70,6 +73,7 @@
 
   final WebSocketListener listener;
   private final Random random;
+  private final long pingIntervalMillis;
   private final String key;
 
   /** Non-null for client web sockets. These can be canceled. */
@@ -123,19 +127,27 @@
   /** True if this web socket failed and the listener has been notified. */
   private boolean failed;
 
-  /** For testing. */
-  int pingCount;
+  /** Total number of pings sent by this web socket. */
+  private int sentPingCount;
 
-  /** For testing. */
-  int pongCount;
+  /** Total number of pings received by this web socket. */
+  private int receivedPingCount;
 
-  public RealWebSocket(Request request, WebSocketListener listener, Random random) {
+  /** Total number of pongs received by this web socket. */
+  private int receivedPongCount;
+
+  /** True if we have sent a ping that is still awaiting a reply. */
+  private boolean awaitingPong;
+
+  public RealWebSocket(Request request, WebSocketListener listener, Random random,
+      long pingIntervalMillis) {
     if (!"GET".equals(request.method())) {
       throw new IllegalArgumentException("Request must be GET: " + request.method());
     }
     this.originalRequest = request;
     this.listener = listener;
     this.random = random;
+    this.pingIntervalMillis = pingIntervalMillis;
 
     byte[] nonce = new byte[16];
     random.nextBytes(nonce);
@@ -167,9 +179,9 @@ public RealWebSocket(Request request, WebSocketListener listener, Random random)
 
   public void connect(OkHttpClient client) {
     client = client.newBuilder()
+        .eventListener(EventListener.NONE)
         .protocols(ONLY_HTTP1)
         .build();
-    final int pingIntervalMillis = client.pingIntervalMillis();
     final Request request = originalRequest.newBuilder()
         .header("Upgrade", "websocket")
         .header("Connection", "Upgrade")
@@ -196,7 +208,7 @@ public void connect(OkHttpClient client) {
         try {
           listener.onOpen(RealWebSocket.this, response);
           String name = "OkHttp WebSocket " + request.url().redact();
-          initReaderAndWriter(name, pingIntervalMillis, streams);
+          initReaderAndWriter(name, streams);
           streamAllocation.connection().socket().setSoTimeout(0);
           loopReader();
         } catch (Exception e) {
@@ -237,8 +249,7 @@ void checkResponse(Response response) throws ProtocolException {
     }
   }
 
-  public void initReaderAndWriter(
-      String name, long pingIntervalMillis, Streams streams) throws IOException {
+  public void initReaderAndWriter(String name, Streams streams) throws IOException {
     synchronized (this) {
       this.streams = streams;
       this.writer = new WebSocketWriter(streams.client, streams.sink, random);
@@ -284,12 +295,27 @@ void awaitTermination(int timeout, TimeUnit timeUnit) throws InterruptedExceptio
     executor.awaitTermination(timeout, timeUnit);
   }
 
-  synchronized int pingCount() {
-    return pingCount;
+  /**
+   * For testing: force this web socket to release its threads.
+   */
+  void tearDown() throws InterruptedException {
+    if (cancelFuture != null) {
+      cancelFuture.cancel(false);
+    }
+    executor.shutdown();
+    executor.awaitTermination(10, TimeUnit.SECONDS);
   }
 
-  synchronized int pongCount() {
-    return pongCount;
+  synchronized int sentPingCount() {
+    return sentPingCount;
+  }
+
+  synchronized int receivedPingCount() {
+    return receivedPingCount;
+  }
+
+  synchronized int receivedPongCount() {
+    return receivedPongCount;
   }
 
   @Override public void onReadMessage(String text) throws IOException {
@@ -306,12 +332,13 @@ synchronized int pongCount() {
 
     pongQueue.add(payload);
     runWriter();
-    pingCount++;
+    receivedPingCount++;
   }
 
   @Override public synchronized void onReadPong(ByteString buffer) {
     // This API doesn't expose pings.
-    pongCount++;
+    receivedPongCount++;
+    awaitingPong = false;
   }
 
   @Override public void onReadClose(int code, String reason) {
@@ -505,9 +532,20 @@ boolean writeOneFrame() throws IOException {
 
   void writePingFrame() {
     WebSocketWriter writer;
+    int failedPing;
     synchronized (this) {
       if (failed) return;
       writer = this.writer;
+      failedPing = awaitingPong ? sentPingCount : -1;
+      sentPingCount++;
+      awaitingPong = true;
+    }
+
+    if (failedPing != -1) {
+      failWebSocket(new SocketTimeoutException("sent ping but didn't receive pong within "
+          + pingIntervalMillis + "ms (after " + (failedPing - 1) + " successful ping/pongs)"),
+          null);
+      return;
     }
 
     try {
@@ -517,7 +555,7 @@ void writePingFrame() {
     }
   }
 
-  void failWebSocket(Exception e, Response response) {
+  public void failWebSocket(Exception e, @Nullable Response response) {
     Streams streamsToClose;
     synchronized (this) {
       if (failed) return; // Already failed.
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
index 5be61eea5f..489979845e 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketProtocol.java
@@ -15,8 +15,7 @@
  */
 package okhttp3.internal.ws;
 
-import java.io.IOException;
-import java.net.ProtocolException;
+import okio.Buffer;
 import okio.ByteString;
 
 public final class WebSocketProtocol {
@@ -90,19 +89,19 @@
 
   /** Used when an unchecked exception was thrown in a listener. */
   static final int CLOSE_CLIENT_GOING_AWAY = 1001;
-  /** Used when a {@link ProtocolException} was thrown by the reader or writer. */
-  static final int CLOSE_PROTOCOL_EXCEPTION = 1002;
   /** Used when an empty close frame was received (i.e., without a status code). */
   static final int CLOSE_NO_STATUS_CODE = 1005;
-  /** Used when a non-{@link ProtocolException} {@link IOException} was thrown by the reader. */
-  static final int CLOSE_ABNORMAL_TERMINATION = 1006;
 
-  static void toggleMask(byte[] buffer, long byteCount, byte[] key, long frameBytesRead) {
+  static void toggleMask(Buffer.UnsafeCursor cursor, byte[] key) {
+    int keyIndex = 0;
     int keyLength = key.length;
-    for (int i = 0; i < byteCount; i++, frameBytesRead++) {
-      int keyIndex = (int) (frameBytesRead % keyLength);
-      buffer[i] = (byte) (buffer[i] ^ key[keyIndex]);
-    }
+    do {
+      byte[] buffer = cursor.data;
+      for (int i = cursor.start, end = cursor.end; i < end; i++, keyIndex++) {
+        keyIndex %= keyLength; // Reassign to prevent overflow breaking counter.
+        buffer[i] = (byte) (buffer[i] ^ key[keyIndex]);
+      }
+    } while (cursor.next() != -1);
   }
 
   static String closeCodeExceptionMessage(int code) {
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
index 7e83a30a1d..6d5d22e67d 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketReader.java
@@ -15,7 +15,6 @@
  */
 package okhttp3.internal.ws;
 
-import java.io.EOFException;
 import java.io.IOException;
 import java.net.ProtocolException;
 import java.util.concurrent.TimeUnit;
@@ -46,8 +45,8 @@
 
 /**
  * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame reader.
- * <p>
- * This class is not thread safe.
+ *
+ * <p>This class is not thread safe.
  */
 final class WebSocketReader {
   public interface FrameCallback {
@@ -67,13 +66,14 @@
   // Stateful data about the current frame.
   int opcode;
   long frameLength;
-  long frameBytesRead;
   boolean isFinalFrame;
   boolean isControlFrame;
-  boolean isMasked;
 
-  final byte[] maskKey = new byte[4];
-  final byte[] maskBuffer = new byte[8192];
+  private final Buffer controlFrameBuffer = new Buffer();
+  private final Buffer messageFrameBuffer = new Buffer();
+
+  private final byte[] maskKey;
+  private final Buffer.UnsafeCursor maskCursor;
 
   WebSocketReader(boolean isClient, BufferedSource source, FrameCallback frameCallback) {
     if (source == null) throw new NullPointerException("source == null");
@@ -81,6 +81,10 @@
     this.isClient = isClient;
     this.source = source;
     this.frameCallback = frameCallback;
+
+    // Masks are only a concern for server writers.
+    maskKey = isClient ? null : new byte[4];
+    maskCursor = isClient ? null : new Buffer.UnsafeCursor();
   }
 
   /**
@@ -134,7 +138,7 @@ private void readHeader() throws IOException {
 
     int b1 = source.readByte() & 0xff;
 
-    isMasked = (b1 & B1_FLAG_MASK) != 0;
+    boolean isMasked = (b1 & B1_FLAG_MASK) != 0;
     if (isMasked == isClient) {
       // Masked payloads must be read on the server. Unmasked payloads must be read on the client.
       throw new ProtocolException(isClient
@@ -153,7 +157,6 @@ private void readHeader() throws IOException {
             "Frame length 0x" + Long.toHexString(frameLength) + " > 0x7FFFFFFFFFFFFFFF");
       }
     }
-    frameBytesRead = 0;
 
     if (isControlFrame && frameLength > PAYLOAD_BYTE_MAX) {
       throw new ProtocolException("Control frame must be less than " + PAYLOAD_BYTE_MAX + "B.");
@@ -166,38 +169,33 @@ private void readHeader() throws IOException {
   }
 
   private void readControlFrame() throws IOException {
-    Buffer buffer = new Buffer();
-    if (frameBytesRead < frameLength) {
-      if (isClient) {
-        source.readFully(buffer, frameLength);
-      } else {
-        while (frameBytesRead < frameLength) {
-          int toRead = (int) Math.min(frameLength - frameBytesRead, maskBuffer.length);
-          int read = source.read(maskBuffer, 0, toRead);
-          if (read == -1) throw new EOFException();
-          toggleMask(maskBuffer, read, maskKey, frameBytesRead);
-          buffer.write(maskBuffer, 0, read);
-          frameBytesRead += read;
-        }
+    if (frameLength > 0) {
+      source.readFully(controlFrameBuffer, frameLength);
+
+      if (!isClient) {
+        controlFrameBuffer.readAndWriteUnsafe(maskCursor);
+        maskCursor.seek(0);
+        toggleMask(maskCursor, maskKey);
+        maskCursor.close();
       }
     }
 
     switch (opcode) {
       case OPCODE_CONTROL_PING:
-        frameCallback.onReadPing(buffer.readByteString());
+        frameCallback.onReadPing(controlFrameBuffer.readByteString());
         break;
       case OPCODE_CONTROL_PONG:
-        frameCallback.onReadPong(buffer.readByteString());
+        frameCallback.onReadPong(controlFrameBuffer.readByteString());
         break;
       case OPCODE_CONTROL_CLOSE:
         int code = CLOSE_NO_STATUS_CODE;
         String reason = "";
-        long bufferSize = buffer.size();
+        long bufferSize = controlFrameBuffer.size();
         if (bufferSize == 1) {
           throw new ProtocolException("Malformed close payload length of 1.");
         } else if (bufferSize != 0) {
-          code = buffer.readShort();
-          reason = buffer.readUtf8();
+          code = controlFrameBuffer.readShort();
+          reason = controlFrameBuffer.readUtf8();
           String codeExceptionMessage = WebSocketProtocol.closeCodeExceptionMessage(code);
           if (codeExceptionMessage != null) throw new ProtocolException(codeExceptionMessage);
         }
@@ -215,18 +213,17 @@ private void readMessageFrame() throws IOException {
       throw new ProtocolException("Unknown opcode: " + toHexString(opcode));
     }
 
-    Buffer message = new Buffer();
-    readMessage(message);
+    readMessage();
 
     if (opcode == OPCODE_TEXT) {
-      frameCallback.onReadMessage(message.readUtf8());
+      frameCallback.onReadMessage(messageFrameBuffer.readUtf8());
     } else {
-      frameCallback.onReadMessage(message.readByteString());
+      frameCallback.onReadMessage(messageFrameBuffer.readByteString());
     }
   }
 
   /** Read headers and process any control frames until we reach a non-control frame. */
-  void readUntilNonControlFrame() throws IOException {
+  private void readUntilNonControlFrame() throws IOException {
     while (!closed) {
       readHeader();
       if (!isControlFrame) {
@@ -241,37 +238,27 @@ void readUntilNonControlFrame() throws IOException {
    * fragments will be processed. If the message payload is masked this will unmask as it's being
    * processed.
    */
-  private void readMessage(Buffer sink) throws IOException {
+  private void readMessage() throws IOException {
     while (true) {
       if (closed) throw new IOException("closed");
 
-      if (frameBytesRead == frameLength) {
-        if (isFinalFrame) return; // We are exhausted and have no continuations.
+      if (frameLength > 0) {
+        source.readFully(messageFrameBuffer, frameLength);
 
-        readUntilNonControlFrame();
-        if (opcode != OPCODE_CONTINUATION) {
-          throw new ProtocolException("Expected continuation opcode. Got: " + toHexString(opcode));
-        }
-        if (isFinalFrame && frameLength == 0) {
-          return; // Fast-path for empty final frame.
+        if (!isClient) {
+          messageFrameBuffer.readAndWriteUnsafe(maskCursor);
+          maskCursor.seek(messageFrameBuffer.size() - frameLength);
+          toggleMask(maskCursor, maskKey);
+          maskCursor.close();
         }
       }
 
-      long toRead = frameLength - frameBytesRead;
-
-      long read;
-      if (isMasked) {
-        toRead = Math.min(toRead, maskBuffer.length);
-        read = source.read(maskBuffer, 0, (int) toRead);
-        if (read == -1) throw new EOFException();
-        toggleMask(maskBuffer, read, maskKey, frameBytesRead);
-        sink.write(maskBuffer, 0, (int) read);
-      } else {
-        read = source.read(sink, toRead);
-        if (read == -1) throw new EOFException();
-      }
+      if (isFinalFrame) break; // We are exhausted and have no continuations.
 
-      frameBytesRead += read;
+      readUntilNonControlFrame();
+      if (opcode != OPCODE_CONTINUATION) {
+        throw new ProtocolException("Expected continuation opcode. Got: " + toHexString(opcode));
+      }
     }
   }
 }
diff --git a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
index 9c466d672d..baffe06b19 100644
--- a/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
+++ b/okhttp/src/main/java/okhttp3/internal/ws/WebSocketWriter.java
@@ -39,18 +39,15 @@
 /**
  * An <a href="http://tools.ietf.org/html/rfc6455">RFC 6455</a>-compatible WebSocket frame writer.
  *
- * <p>This class is partially thread safe. Only a single "main" thread should be sending messages
- * via calls to {@link #newMessageSink}, {@link #writePing}, or {@link #writeClose}. Other threads
- * may call {@link #writePing}, {@link #writePong}, or {@link #writeClose} which will interleave on
- * the wire with frames from the "main" sending thread.
+ * <p>This class is not thread safe.
  */
 final class WebSocketWriter {
   final boolean isClient;
   final Random random;
 
-  /** Writes must be guarded by synchronizing on 'this'. */
   final BufferedSink sink;
-  /** Access must be guarded by synchronizing on 'this'. */
+  /** The {@link Buffer} of {@link #sink}. Write to this and then flush/emit {@link #sink}. */
+  final Buffer sinkBuffer;
   boolean writerClosed;
 
   final Buffer buffer = new Buffer();
@@ -58,33 +55,30 @@
 
   boolean activeWriter;
 
-  final byte[] maskKey;
-  final byte[] maskBuffer;
+  private final byte[] maskKey;
+  private final Buffer.UnsafeCursor maskCursor;
 
   WebSocketWriter(boolean isClient, BufferedSink sink, Random random) {
     if (sink == null) throw new NullPointerException("sink == null");
     if (random == null) throw new NullPointerException("random == null");
     this.isClient = isClient;
     this.sink = sink;
+    this.sinkBuffer = sink.buffer();
     this.random = random;
 
     // Masks are only a concern for client writers.
     maskKey = isClient ? new byte[4] : null;
-    maskBuffer = isClient ? new byte[8192] : null;
+    maskCursor = isClient ? new Buffer.UnsafeCursor() : null;
   }
 
   /** Send a ping with the supplied {@code payload}. */
   void writePing(ByteString payload) throws IOException {
-    synchronized (this) {
-      writeControlFrameSynchronized(OPCODE_CONTROL_PING, payload);
-    }
+    writeControlFrame(OPCODE_CONTROL_PING, payload);
   }
 
   /** Send a pong with the supplied {@code payload}. */
   void writePong(ByteString payload) throws IOException {
-    synchronized (this) {
-      writeControlFrameSynchronized(OPCODE_CONTROL_PONG, payload);
-    }
+    writeControlFrame(OPCODE_CONTROL_PONG, payload);
   }
 
   /**
@@ -108,18 +102,14 @@ void writeClose(int code, ByteString reason) throws IOException {
       payload = buffer.readByteString();
     }
 
-    synchronized (this) {
-      try {
-        writeControlFrameSynchronized(OPCODE_CONTROL_CLOSE, payload);
-      } finally {
-        writerClosed = true;
-      }
+    try {
+      writeControlFrame(OPCODE_CONTROL_CLOSE, payload);
+    } finally {
+      writerClosed = true;
     }
   }
 
-  private void writeControlFrameSynchronized(int opcode, ByteString payload) throws IOException {
-    assert Thread.holdsLock(this);
-
+  private void writeControlFrame(int opcode, ByteString payload) throws IOException {
     if (writerClosed) throw new IOException("closed");
 
     int length = payload.size();
@@ -129,22 +119,28 @@ private void writeControlFrameSynchronized(int opcode, ByteString payload) throw
     }
 
     int b0 = B0_FLAG_FIN | opcode;
-    sink.writeByte(b0);
+    sinkBuffer.writeByte(b0);
 
     int b1 = length;
     if (isClient) {
       b1 |= B1_FLAG_MASK;
-      sink.writeByte(b1);
+      sinkBuffer.writeByte(b1);
 
       random.nextBytes(maskKey);
-      sink.write(maskKey);
+      sinkBuffer.write(maskKey);
+
+      if (length > 0) {
+        long payloadStart = sinkBuffer.size();
+        sinkBuffer.write(payload);
 
-      byte[] bytes = payload.toByteArray();
-      toggleMask(bytes, bytes.length, maskKey, 0);
-      sink.write(bytes);
+        sinkBuffer.readAndWriteUnsafe(maskCursor);
+        maskCursor.seek(payloadStart);
+        toggleMask(maskCursor, maskKey);
+        maskCursor.close();
+      }
     } else {
-      sink.writeByte(b1);
-      sink.write(payload);
+      sinkBuffer.writeByte(b1);
+      sinkBuffer.write(payload);
     }
 
     sink.flush();
@@ -169,17 +165,15 @@ Sink newMessageSink(int formatOpcode, long contentLength) {
     return frameSink;
   }
 
-  void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boolean isFirstFrame,
+  void writeMessageFrame(int formatOpcode, long byteCount, boolean isFirstFrame,
       boolean isFinal) throws IOException {
-    assert Thread.holdsLock(this);
-
     if (writerClosed) throw new IOException("closed");
 
     int b0 = isFirstFrame ? formatOpcode : OPCODE_CONTINUATION;
     if (isFinal) {
       b0 |= B0_FLAG_FIN;
     }
-    sink.writeByte(b0);
+    sinkBuffer.writeByte(b0);
 
     int b1 = 0;
     if (isClient) {
@@ -187,31 +181,32 @@ void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boolean isF
     }
     if (byteCount <= PAYLOAD_BYTE_MAX) {
       b1 |= (int) byteCount;
-      sink.writeByte(b1);
+      sinkBuffer.writeByte(b1);
     } else if (byteCount <= PAYLOAD_SHORT_MAX) {
       b1 |= PAYLOAD_SHORT;
-      sink.writeByte(b1);
-      sink.writeShort((int) byteCount);
+      sinkBuffer.writeByte(b1);
+      sinkBuffer.writeShort((int) byteCount);
     } else {
       b1 |= PAYLOAD_LONG;
-      sink.writeByte(b1);
-      sink.writeLong(byteCount);
+      sinkBuffer.writeByte(b1);
+      sinkBuffer.writeLong(byteCount);
     }
 
     if (isClient) {
       random.nextBytes(maskKey);
-      sink.write(maskKey);
-
-      for (long written = 0; written < byteCount; ) {
-        int toRead = (int) Math.min(byteCount, maskBuffer.length);
-        int read = buffer.read(maskBuffer, 0, toRead);
-        if (read == -1) throw new AssertionError();
-        toggleMask(maskBuffer, read, maskKey, written);
-        sink.write(maskBuffer, 0, read);
-        written += read;
+      sinkBuffer.write(maskKey);
+
+      if (byteCount > 0) {
+        long bufferStart = sinkBuffer.size();
+        sinkBuffer.write(buffer, byteCount);
+
+        sinkBuffer.readAndWriteUnsafe(maskCursor);
+        maskCursor.seek(bufferStart);
+        toggleMask(maskCursor, maskKey);
+        maskCursor.close();
       }
     } else {
-      sink.write(buffer, byteCount);
+      sinkBuffer.write(buffer, byteCount);
     }
 
     sink.emit();
@@ -235,9 +230,7 @@ void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boolean isF
 
       long emitCount = buffer.completeSegmentByteCount();
       if (emitCount > 0 && !deferWrite) {
-        synchronized (WebSocketWriter.this) {
-          writeMessageFrameSynchronized(formatOpcode, emitCount, isFirstFrame, false /* final */);
-        }
+        writeMessageFrame(formatOpcode, emitCount, isFirstFrame, false /* final */);
         isFirstFrame = false;
       }
     }
@@ -245,9 +238,7 @@ void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boolean isF
     @Override public void flush() throws IOException {
       if (closed) throw new IOException("closed");
 
-      synchronized (WebSocketWriter.this) {
-        writeMessageFrameSynchronized(formatOpcode, buffer.size(), isFirstFrame, false /* final */);
-      }
+      writeMessageFrame(formatOpcode, buffer.size(), isFirstFrame, false /* final */);
       isFirstFrame = false;
     }
 
@@ -259,9 +250,7 @@ void writeMessageFrameSynchronized(int formatOpcode, long byteCount, boolean isF
     @Override public void close() throws IOException {
       if (closed) throw new IOException("closed");
 
-      synchronized (WebSocketWriter.this) {
-        writeMessageFrameSynchronized(formatOpcode, buffer.size(), isFirstFrame, true /* final */);
-      }
+      writeMessageFrame(formatOpcode, buffer.size(), isFirstFrame, true /* final */);
       closed = true;
       activeWriter = false;
     }
diff --git a/okhttp/src/main/java/okhttp3/package-info.java b/okhttp/src/main/java/okhttp3/package-info.java
new file mode 100644
index 0000000000..a34c5bbf86
--- /dev/null
+++ b/okhttp/src/main/java/okhttp3/package-info.java
@@ -0,0 +1,3 @@
+/** An HTTP+HTTP/2 client for Android and Java applications. */
+@javax.annotation.ParametersAreNonnullByDefault
+package okhttp3;
diff --git a/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro b/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro
new file mode 100644
index 0000000000..0c6f707575
--- /dev/null
+++ b/okhttp/src/main/resources/META-INF/proguard/okhttp3.pro
@@ -0,0 +1,11 @@
+# JSR 305 annotations are for embedding nullability information.
+-dontwarn javax.annotation.**
+
+# A resource is loaded with a relative path so the package of this class must be preserved.
+-keepnames class okhttp3.internal.publicsuffix.PublicSuffixDatabase
+
+# Animal Sniffer compileOnly dependency to ensure APIs are compatible with older versions of Java.
+-dontwarn org.codehaus.mojo.animal_sniffer.*
+
+# OkHttp platform used only on JVM and when Conscrypt dependency is available.
+-dontwarn okhttp3.internal.platform.ConscryptPlatform
diff --git a/okhttp/src/main/resources/okhttp3/internal/publicsuffix/publicsuffixes.gz b/okhttp/src/main/resources/okhttp3/internal/publicsuffix/publicsuffixes.gz
new file mode 100644
index 0000000000..3d9b2c9ccf
Binary files /dev/null and b/okhttp/src/main/resources/okhttp3/internal/publicsuffix/publicsuffixes.gz differ
diff --git a/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixListGenerator.java b/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixListGenerator.java
new file mode 100644
index 0000000000..50b1f8703a
--- /dev/null
+++ b/okhttp/src/test/java/okhttp3/internal/publicsuffix/PublicSuffixListGenerator.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.internal.publicsuffix;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.SortedSet;
+import java.util.TreeSet;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.GzipSink;
+import okio.Okio;
+import okio.Sink;
+
+/**
+ * Downloads the public suffix list from https://publicsuffix.org/list/public_suffix_list.dat and
+ * transforms the file into an efficient format used by OkHttp.
+ *
+ * <p>The intent is to use this class to update the list periodically by manually running the main
+ * method. This should be run from the top-level okhttp directory.
+ *
+ * <p>The resulting file is used by {@link PublicSuffixDatabase}.
+ */
+public final class PublicSuffixListGenerator {
+  private static final String OKHTTP_RESOURCE_DIR = "okhttp" + File.separator + "src"
+      + File.separator + "main" + File.separator + "resources" + File.separator
+      + "okhttp3" + File.separator + "internal" + File.separator + "publicsuffix";
+
+  private static final ByteString EXCEPTION_RULE_MARKER = ByteString.encodeUtf8("!");
+  private static final String WILDCARD_CHAR = "*";
+
+  public static void main(String... args) throws IOException {
+    OkHttpClient client = new OkHttpClient.Builder().build();
+    Request request = new Request.Builder()
+        .url("https://publicsuffix.org/list/public_suffix_list.dat")
+        .build();
+    SortedSet<ByteString> sortedRules = new TreeSet<>();
+    SortedSet<ByteString> sortedExceptionRules = new TreeSet<>();
+    try (Response response = client.newCall(request).execute()) {
+      BufferedSource source = response.body().source();
+      int totalRuleBytes = 0;
+      int totalExceptionRuleBytes = 0;
+      while (!source.exhausted()) {
+        String line = source.readUtf8LineStrict();
+        if (line.trim().isEmpty() || line.startsWith("//")) continue;
+
+        if (line.contains(WILDCARD_CHAR)) {
+          assertWildcardRule(line);
+        }
+
+        ByteString rule = ByteString.encodeUtf8(line);
+        if (rule.startsWith(EXCEPTION_RULE_MARKER)) {
+          rule = rule.substring(1);
+          // We use '\n' for end of value.
+          totalExceptionRuleBytes += rule.size() + 1;
+          sortedExceptionRules.add(rule);
+        } else {
+          totalRuleBytes += rule.size() + 1; // We use '\n' for end of value.
+          sortedRules.add(rule);
+        }
+      }
+
+      File resources = new File(OKHTTP_RESOURCE_DIR);
+      if (!resources.mkdirs() && !resources.exists()) {
+        throw new RuntimeException("Unable to create resource directory!");
+      }
+
+      Sink fileSink = Okio.sink(new File(resources, PublicSuffixDatabase.PUBLIC_SUFFIX_RESOURCE));
+      try (BufferedSink sink = Okio.buffer(new GzipSink(fileSink))) {
+        sink.writeInt(totalRuleBytes);
+        for (ByteString domain : sortedRules) {
+          sink.write(domain).writeByte('\n');
+        }
+
+        sink.writeInt(totalExceptionRuleBytes);
+        for (ByteString domain : sortedExceptionRules) {
+          sink.write(domain).writeByte('\n');
+        }
+      }
+    }
+  }
+
+  /**
+   * These assertions ensure the {@link PublicSuffixDatabase} remains correct. The specification is
+   * very flexible regarding wildcard rules, but this flexibility is not something currently used
+   * in practice. To simplify the implementation, we've avoided implementing the flexible rules in
+   * favor of supporting what's actually used in practice. That means if these assertions ever fail,
+   * the implementation will need to be revisited to support a more flexible rule.
+   */
+  private static void assertWildcardRule(String rule) {
+    if (rule.indexOf(WILDCARD_CHAR) != 0) {
+      throw new RuntimeException("Wildcard Assertion Failure: " + rule + "\nA wildcard rule was "
+          + "added with a wildcard that is not in leftmost position! We'll need to change the "
+          + PublicSuffixDatabase.class.getName() + " to handle this.");
+    }
+    if (rule.indexOf(WILDCARD_CHAR, 1) != -1) {
+      throw new RuntimeException("Wildcard Assertion Failure: " + rule + "\nA wildcard rule was "
+          + "added with multiple wildcards! We'll need to change "
+          + PublicSuffixDatabase.class.getName() + " to handle this.");
+    }
+    if (rule.length() == 1) {
+      throw new RuntimeException("Wildcard Assertion Failure: " + rule + "\nA wildcard rule was "
+          + "added that wildcards the first level! We'll need to change the "
+          + PublicSuffixDatabase.class.getName() + " to handle this.");
+    }
+  }
+}
diff --git a/pom.xml b/pom.xml
index 35a0210990..c9f70dc54e 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
 
   <groupId>com.squareup.okhttp3</groupId>
   <artifactId>parent</artifactId>
-  <version>3.6.0-SNAPSHOT</version>
+  <version>3.12.0-SNAPSHOT</version>
   <packaging>pom</packaging>
 
   <name>OkHttp (Parent)</name>
@@ -25,11 +25,15 @@
     <module>okhttp-android-support</module>
 
     <module>okhttp-apache</module>
+    <module>okhttp-sse</module>
     <module>okhttp-testing-support</module>
+    <module>okhttp-tls</module>
     <module>okhttp-urlconnection</module>
 
     <module>okhttp-logging-interceptor</module>
 
+    <module>okhttp-dnsoverhttps</module>
+
     <module>okcurl</module>
     <module>mockwebserver</module>
     <module>samples</module>
@@ -45,12 +49,14 @@
     <alpn.jdk7.version>7.1.2.v20141202</alpn.jdk7.version>
     <android.version>4.1.1.4</android.version>
     <animal.sniffer.version>1.15</animal.sniffer.version>
-    <apache.http.version>4.2.2</apache.http.version>
+    <apache.http.version>4.2.6</apache.http.version>
     <bouncycastle.version>1.50</bouncycastle.version>
     <guava.version>16.0</guava.version>
     <java.version>1.7</java.version>
     <moshi.version>1.1.0</moshi.version>
-    <okio.version>1.11.0</okio.version>
+    <jnr-unixsocket.version>0.19</jnr-unixsocket.version>
+    <okio.version>1.14.0</okio.version>
+    <conscrypt.version>1.1.4</conscrypt.version>
 
     <!-- Test Dependencies -->
     <junit.version>4.12</junit.version>
@@ -85,6 +91,12 @@
         <artifactId>okio</artifactId>
         <version>${okio.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.google.code.findbugs</groupId>
+        <artifactId>jsr305</artifactId>
+        <version>3.0.2</version>
+        <scope>provided</scope>
+      </dependency>
       <dependency>
         <groupId>junit</groupId>
         <artifactId>junit</artifactId>
@@ -120,6 +132,16 @@
         <artifactId>moshi</artifactId>
         <version>${moshi.version}</version>
       </dependency>
+      <dependency>
+        <groupId>com.github.jnr</groupId>
+        <artifactId>jnr-unixsocket</artifactId>
+        <version>${jnr-unixsocket.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>org.conscrypt</groupId>
+        <artifactId>conscrypt-openjdk-uber</artifactId>
+        <version>${conscrypt.version}</version>
+      </dependency>
     </dependencies>
   </dependencyManagement>
 
@@ -129,21 +151,36 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-compiler-plugin</artifactId>
-          <version>3.0</version>
+          <version>3.7.0</version>
           <configuration>
+            <compilerId>javac-with-errorprone</compilerId>
+            <forceJavacCompilerUse>true</forceJavacCompilerUse>
             <source>${java.version}</source>
             <target>${java.version}</target>
           </configuration>
+          <dependencies>
+            <dependency>
+              <groupId>org.codehaus.plexus</groupId>
+              <artifactId>plexus-compiler-javac-errorprone</artifactId>
+              <version>2.8.4</version>
+            </dependency>
+            <dependency>
+              <groupId>com.google.errorprone</groupId>
+              <artifactId>error_prone_core</artifactId>
+              <version>2.3.1</version>
+            </dependency>
+          </dependencies>
         </plugin>
 
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-surefire-plugin</artifactId>
-          <version>2.17</version>
+          <version>2.21.0</version>
           <configuration>
             <systemPropertyVariables>
               <okhttp.platform>${okhttp.platform}</okhttp.platform>
             </systemPropertyVariables>
+            <redirectTestOutputToFile>true</redirectTestOutputToFile>
             <properties>
               <!--
                 Configure a listener for enforcing that no uncaught exceptions issue from OkHttp
@@ -160,7 +197,7 @@
             <dependency>
               <groupId>org.apache.maven.surefire</groupId>
               <artifactId>surefire-junit47</artifactId>
-              <version>2.17</version>
+              <version>2.21.0</version>
             </dependency>
           </dependencies>
         </plugin>
@@ -168,7 +205,7 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-javadoc-plugin</artifactId>
-          <version>2.9</version>
+          <version>2.10.4</version>
         </plugin>
       </plugins>
     </pluginManagement>
@@ -193,7 +230,14 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-checkstyle-plugin</artifactId>
-        <version>2.12</version>
+        <version>2.17</version>
+        <dependencies>
+          <dependency>
+            <groupId>com.puppycrawl.tools</groupId>
+            <artifactId>checkstyle</artifactId>
+            <version>7.7</version>
+          </dependency>
+        </dependencies>
         <configuration>
           <failsOnError>true</failsOnError>
           <configLocation>checkstyle.xml</configLocation>
@@ -306,10 +350,22 @@
         <okhttp.platform>jdk9</okhttp.platform>
       </properties>
     </profile>
+    <profile>
+      <id>conscrypt</id>
+      <properties>
+        <okhttp.platform>conscrypt</okhttp.platform>
+      </properties>
+      <dependencies>
+        <dependency>
+          <groupId>org.conscrypt</groupId>
+          <artifactId>conscrypt-openjdk-uber</artifactId>
+        </dependency>
+      </dependencies>
+    </profile>
     <!-- ALPN Versions targeted for each Java 8 minor release -->
     <!-- Check versions with this page: -->
     <!-- http://www.eclipse.org/jetty/documentation/current/alpn-chapter.html#alpn-chapterchapterversions -->
-        <profile>
+    <profile>
       <id>alpn-when-jdk8_05</id>
       <activation>
         <jdk>1.8.0_05</jdk>
@@ -507,6 +563,104 @@
         <alpn.jdk8.version>8.1.9.v20160720</alpn.jdk8.version>
       </properties>
     </profile>
+    <profile>
+      <id>alpn-when-jdk8_121</id>
+      <activation>
+        <jdk>1.8.0_121</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_131</id>
+      <activation>
+        <jdk>1.8.0_131</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_141</id>
+      <activation>
+        <jdk>1.8.0_141</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_144</id>
+      <activation>
+        <jdk>1.8.0_144</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_151</id>
+      <activation>
+        <jdk>1.8.0_151</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_152</id>
+      <activation>
+        <jdk>1.8.0_152</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.11.v20170118</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_161</id>
+      <activation>
+        <jdk>1.8.0_161</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_162</id>
+      <activation>
+        <jdk>1.8.0_162</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_171</id>
+      <activation>
+        <jdk>1.8.0_171</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_172</id>
+      <activation>
+        <jdk>1.8.0_172</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
+      </properties>
+    </profile>
+    <profile>
+      <id>alpn-when-jdk8_181</id>
+      <activation>
+        <jdk>1.8.0_181</jdk>
+      </activation>
+      <properties>
+        <alpn.jdk8.version>8.1.12.v20180117</alpn.jdk8.version>
+      </properties>
+    </profile>
   </profiles>
 </project>
-
diff --git a/samples/crawler/pom.xml b/samples/crawler/pom.xml
index 7587628005..97bcf040f2 100644
--- a/samples/crawler/pom.xml
+++ b/samples/crawler/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.6.0-SNAPSHOT</version>
+    <version>3.12.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>crawler</artifactId>
diff --git a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
index 0818961703..07f61032d3 100644
--- a/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
+++ b/samples/crawler/src/main/java/okhttp3/sample/Crawler.java
@@ -95,32 +95,33 @@ public void fetch(HttpUrl url) throws IOException {
     Request request = new Request.Builder()
         .url(url)
         .build();
-    Response response = client.newCall(request).execute();
-    String responseSource = response.networkResponse() != null
-        ? ("(network: " + response.networkResponse().code() + " over " + response.protocol() + ")")
-        : "(cache)";
-    int responseCode = response.code();
-
-    System.out.printf("%03d: %s %s%n", responseCode, url, responseSource);
-
-    String contentType = response.header("Content-Type");
-    if (responseCode != 200 || contentType == null) {
-      response.body().close();
-      return;
-    }
+    try (Response response = client.newCall(request).execute()) {
+      String responseSource = response.networkResponse() != null ? ("(network: "
+          + response.networkResponse().code()
+          + " over "
+          + response.protocol()
+          + ")") : "(cache)";
+      int responseCode = response.code();
+
+      System.out.printf("%03d: %s %s%n", responseCode, url, responseSource);
+
+      String contentType = response.header("Content-Type");
+      if (responseCode != 200 || contentType == null) {
+        return;
+      }
 
-    MediaType mediaType = MediaType.parse(contentType);
-    if (mediaType == null || !mediaType.subtype().equalsIgnoreCase("html")) {
-      response.body().close();
-      return;
-    }
+      MediaType mediaType = MediaType.parse(contentType);
+      if (mediaType == null || !mediaType.subtype().equalsIgnoreCase("html")) {
+        return;
+      }
 
-    Document document = Jsoup.parse(response.body().string(), url.toString());
-    for (Element element : document.select("a[href]")) {
-      String href = element.attr("href");
-      HttpUrl link = response.request().url().resolve(href);
-      if (link == null) continue; // URL is either invalid or its scheme isn't http/https.
-      queue.add(link.newBuilder().fragment(null).build());
+      Document document = Jsoup.parse(response.body().string(), url.toString());
+      for (Element element : document.select("a[href]")) {
+        String href = element.attr("href");
+        HttpUrl link = response.request().url().resolve(href);
+        if (link == null) continue; // URL is either invalid or its scheme isn't http/https.
+        queue.add(link.newBuilder().fragment(null).build());
+      }
     }
   }
 
@@ -139,7 +140,7 @@ public static void main(String[] args) throws IOException {
         .build();
 
     Crawler crawler = new Crawler(client);
-    crawler.queue.add(HttpUrl.parse(args[1]));
+    crawler.queue.add(HttpUrl.get(args[1]));
     crawler.parallelDrainQueue(threadCount);
   }
 }
diff --git a/samples/guide/pom.xml b/samples/guide/pom.xml
index 4b55e5325c..95a9df5bdf 100644
--- a/samples/guide/pom.xml
+++ b/samples/guide/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.6.0-SNAPSHOT</version>
+    <version>3.12.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>guide</artifactId>
@@ -18,6 +18,16 @@
       <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>okhttp-tls</artifactId>
+      <version>${project.version}</version>
+    </dependency>
     <dependency>
       <groupId>com.squareup.moshi</groupId>
       <artifactId>moshi</artifactId>
diff --git a/samples/guide/src/main/java/okhttp3/guide/PostExample.java b/samples/guide/src/main/java/okhttp3/guide/PostExample.java
index b6e70ccc7d..ddaacb6c5e 100644
--- a/samples/guide/src/main/java/okhttp3/guide/PostExample.java
+++ b/samples/guide/src/main/java/okhttp3/guide/PostExample.java
@@ -8,8 +8,7 @@
 import okhttp3.Response;
 
 public class PostExample {
-  public static final MediaType JSON
-      = MediaType.parse("application/json; charset=utf-8");
+  public static final MediaType JSON = MediaType.get("application/json; charset=utf-8");
 
   OkHttpClient client = new OkHttpClient();
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java b/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java
index a3ea23cf39..b568bdf01c 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/CustomCipherSuites.java
@@ -109,7 +109,7 @@ private X509TrustManager defaultTrustManager() throws GeneralSecurityException {
   static class DelegatingSSLSocketFactory extends SSLSocketFactory {
     protected final SSLSocketFactory delegate;
 
-    public DelegatingSSLSocketFactory(SSLSocketFactory delegate) {
+    DelegatingSSLSocketFactory(SSLSocketFactory delegate) {
       this.delegate = delegate;
     }
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/HttpsServer.java b/samples/guide/src/main/java/okhttp3/recipes/HttpsServer.java
new file mode 100644
index 0000000000..dd537f52b2
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/HttpsServer.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.net.InetAddress;
+import okhttp3.Call;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+import okhttp3.tls.HandshakeCertificates;
+import okhttp3.tls.HeldCertificate;
+
+/**
+ * Create an HTTPS server with a self-signed certificate that OkHttp trusts.
+ */
+public class HttpsServer {
+  public void run() throws Exception {
+    String localhost = InetAddress.getByName("localhost").getCanonicalHostName();
+    HeldCertificate localhostCertificate = new HeldCertificate.Builder()
+        .addSubjectAlternativeName(localhost)
+        .build();
+
+    HandshakeCertificates serverCertificates = new HandshakeCertificates.Builder()
+        .heldCertificate(localhostCertificate)
+        .build();
+    MockWebServer server = new MockWebServer();
+    server.useHttps(serverCertificates.sslSocketFactory(), false);
+    server.enqueue(new MockResponse());
+
+    HandshakeCertificates clientCertificates = new HandshakeCertificates.Builder()
+        .addTrustedCertificate(localhostCertificate.certificate())
+        .build();
+    OkHttpClient client = new OkHttpClient.Builder()
+        .sslSocketFactory(clientCertificates.sslSocketFactory(), clientCertificates.trustManager())
+        .build();
+
+    Call call = client.newCall(new Request.Builder()
+        .url(server.url("/"))
+        .build());
+    Response response = call.execute();
+    System.out.println(response.handshake().tlsVersion());
+  }
+
+  public static void main(String... args) throws Exception {
+    new HttpsServer().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostFile.java b/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
index b216b24b3b..0e52cddd26 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostFile.java
@@ -25,7 +25,7 @@
 
 public final class PostFile {
   public static final MediaType MEDIA_TYPE_MARKDOWN
-      = MediaType.parse("text/x-markdown; charset=utf-8");
+      = MediaType.get("text/x-markdown; charset=utf-8");
 
   private final OkHttpClient client = new OkHttpClient();
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java b/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
index 3e93a00e82..60534d7de2 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostMultipart.java
@@ -30,7 +30,7 @@
    * these examples, please request your own client ID! https://api.imgur.com/oauth2
    */
   private static final String IMGUR_CLIENT_ID = "9199fdef135c122";
-  private static final MediaType MEDIA_TYPE_PNG = MediaType.parse("image/png");
+  private static final MediaType MEDIA_TYPE_PNG = MediaType.get("image/png");
 
   private final OkHttpClient client = new OkHttpClient();
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java b/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
index 440c7768ea..90ec01c6b8 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostStreaming.java
@@ -25,7 +25,7 @@
 
 public final class PostStreaming {
   public static final MediaType MEDIA_TYPE_MARKDOWN
-      = MediaType.parse("text/x-markdown; charset=utf-8");
+      = MediaType.get("text/x-markdown; charset=utf-8");
 
   private final OkHttpClient client = new OkHttpClient();
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java b/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java
new file mode 100644
index 0000000000..c73b9154ed
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostStreamingWithPipe.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import okhttp3.MediaType;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.RequestBody;
+import okhttp3.Response;
+import okio.BufferedSink;
+import okio.Okio;
+import okio.Pipe;
+
+public final class PostStreamingWithPipe {
+  public static final MediaType MEDIA_TYPE_MARKDOWN
+      = MediaType.get("text/x-markdown; charset=utf-8");
+
+  private final OkHttpClient client = new OkHttpClient();
+
+  public void run() throws Exception {
+    final PipeBody pipeBody = new PipeBody();
+
+    Request request = new Request.Builder()
+        .url("https://api.github.com/markdown/raw")
+        .post(pipeBody)
+        .build();
+
+    streamPrimesToSinkAsynchronously(pipeBody.sink());
+
+    try (Response response = client.newCall(request).execute()) {
+      if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
+
+      System.out.println(response.body().string());
+    }
+  }
+
+  private void streamPrimesToSinkAsynchronously(final BufferedSink sink) {
+    Thread thread = new Thread("writer") {
+      @Override public void run() {
+        try {
+          sink.writeUtf8("Numbers\n");
+          sink.writeUtf8("-------\n");
+          for (int i = 2; i <= 997; i++) {
+            System.out.println(i);
+            Thread.sleep(10);
+            sink.writeUtf8(String.format(" * %s = %s\n", i, factor(i)));
+          }
+          sink.close();
+        } catch (IOException | InterruptedException e) {
+          e.printStackTrace();
+        }
+      }
+
+      private String factor(int n) {
+        for (int i = 2; i < n; i++) {
+          int x = n / i;
+          if (x * i == n) return factor(x) + " Ã— " + i;
+        }
+        return Integer.toString(n);
+      }
+    };
+
+    thread.start();
+  }
+
+  /**
+   * This request body makes it possible for another thread to stream data to the uploading request.
+   * This is potentially useful for posting live event streams like video capture. Callers should
+   * write to {@code sink()} and close it to complete the post.
+   */
+  static final class PipeBody extends RequestBody {
+    private final Pipe pipe = new Pipe(8192);
+    private final BufferedSink sink = Okio.buffer(pipe.sink());
+
+    public BufferedSink sink() {
+      return sink;
+    }
+
+    @Override public MediaType contentType() {
+      return MEDIA_TYPE_MARKDOWN;
+    }
+
+    @Override public void writeTo(BufferedSink sink) throws IOException {
+      sink.writeAll(pipe.source());
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new PostStreamingWithPipe().run();
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PostString.java b/samples/guide/src/main/java/okhttp3/recipes/PostString.java
index 8a312bde8a..6c8ea4f9e3 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/PostString.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/PostString.java
@@ -24,7 +24,7 @@
 
 public final class PostString {
   public static final MediaType MEDIA_TYPE_MARKDOWN
-      = MediaType.parse("text/x-markdown; charset=utf-8");
+      = MediaType.get("text/x-markdown; charset=utf-8");
 
   private final OkHttpClient client = new OkHttpClient();
 
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java b/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java
new file mode 100644
index 0000000000..1366a82f15
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/PrintEvents.java
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.Connection;
+import okhttp3.EventListener;
+import okhttp3.Handshake;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.ResponseBody;
+
+public final class PrintEvents {
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .eventListenerFactory(PrintingEventListener.FACTORY)
+      .build();
+
+  public void run() throws Exception {
+    Request washingtonPostRequest = new Request.Builder()
+        .url("https://www.washingtonpost.com/")
+        .build();
+    client.newCall(washingtonPostRequest).enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        try (ResponseBody body = response.body()) {
+          // Consume and discard the response body.
+          body.source().readByteString();
+        }
+      }
+    });
+
+    Request newYorkTimesRequest = new Request.Builder()
+        .url("https://www.nytimes.com/")
+        .build();
+    client.newCall(newYorkTimesRequest).enqueue(new Callback() {
+      @Override public void onFailure(Call call, IOException e) {
+      }
+
+      @Override public void onResponse(Call call, Response response) throws IOException {
+        try (ResponseBody body = response.body()) {
+          // Consume and discard the response body.
+          body.source().readByteString();
+        }
+      }
+    });
+  }
+
+  public static void main(String... args) throws Exception {
+    new PrintEvents().run();
+  }
+
+  private static final class PrintingEventListener extends EventListener {
+    private static final Factory FACTORY = new Factory() {
+      final AtomicLong nextCallId = new AtomicLong(1L);
+
+      @Override public EventListener create(Call call) {
+        long callId = nextCallId.getAndIncrement();
+        System.out.printf("%04d %s%n", callId, call.request().url());
+        return new PrintingEventListener(callId, System.nanoTime());
+      }
+    };
+
+    final long callId;
+    final long callStartNanos;
+
+    PrintingEventListener(long callId, long callStartNanos) {
+      this.callId = callId;
+      this.callStartNanos = callStartNanos;
+    }
+
+    private void printEvent(String name) {
+      long elapsedNanos = System.nanoTime() - callStartNanos;
+      System.out.printf("%04d %.3f %s%n", callId, elapsedNanos / 1000000000d, name);
+    }
+
+    @Override public void callStart(Call call) {
+      printEvent("callStart");
+    }
+
+    @Override public void dnsStart(Call call, String domainName) {
+      printEvent("dnsStart");
+    }
+
+    @Override public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
+      printEvent("dnsEnd");
+    }
+
+    @Override public void connectStart(
+        Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
+      printEvent("connectStart");
+    }
+
+    @Override public void secureConnectStart(Call call) {
+      printEvent("secureConnectStart");
+    }
+
+    @Override public void secureConnectEnd(Call call, Handshake handshake) {
+      printEvent("secureConnectEnd");
+    }
+
+    @Override public void connectEnd(
+        Call call, InetSocketAddress inetSocketAddress, Proxy proxy, Protocol protocol) {
+      printEvent("connectEnd");
+    }
+
+    @Override public void connectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,
+        Protocol protocol, IOException ioe) {
+      printEvent("connectFailed");
+    }
+
+    @Override public void connectionAcquired(Call call, Connection connection) {
+      printEvent("connectionAcquired");
+    }
+
+    @Override public void connectionReleased(Call call, Connection connection) {
+      printEvent("connectionReleased");
+    }
+
+    @Override public void requestHeadersStart(Call call) {
+      printEvent("requestHeadersStart");
+    }
+
+    @Override public void requestHeadersEnd(Call call, Request request) {
+      printEvent("requestHeadersEnd");
+    }
+
+    @Override public void requestBodyStart(Call call) {
+      printEvent("requestBodyStart");
+    }
+
+    @Override public void requestBodyEnd(Call call, long byteCount) {
+      printEvent("requestBodyEnd");
+    }
+
+    @Override public void responseHeadersStart(Call call) {
+      printEvent("responseHeadersStart");
+    }
+
+    @Override public void responseHeadersEnd(Call call, Response response) {
+      printEvent("responseHeadersEnd");
+    }
+
+    @Override public void responseBodyStart(Call call) {
+      printEvent("responseBodyStart");
+    }
+
+    @Override public void responseBodyEnd(Call call, long byteCount) {
+      printEvent("responseBodyEnd");
+    }
+
+    @Override public void callEnd(Call call) {
+      printEvent("callEnd");
+    }
+
+    @Override public void callFailed(Call call, IOException ioe) {
+      printEvent("callFailed");
+    }
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java b/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java
new file mode 100644
index 0000000000..6acedb19e7
--- /dev/null
+++ b/samples/guide/src/main/java/okhttp3/recipes/PrintEventsNonConcurrent.java
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2017 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.recipes;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Proxy;
+import java.util.List;
+import okhttp3.Call;
+import okhttp3.Connection;
+import okhttp3.EventListener;
+import okhttp3.Handshake;
+import okhttp3.OkHttpClient;
+import okhttp3.Protocol;
+import okhttp3.Request;
+import okhttp3.Response;
+
+/**
+ * This prints events for a single in-flight call. It won't work for multiple concurrent calls
+ * because we don't know what callStartNanos refers to.
+ */
+public final class PrintEventsNonConcurrent {
+  private final OkHttpClient client = new OkHttpClient.Builder()
+      .eventListener(new PrintingEventListener())
+      .build();
+
+  public void run() throws Exception {
+    Request request = new Request.Builder()
+        .url("https://publicobject.com/helloworld.txt")
+        .build();
+
+    System.out.println("REQUEST 1 (new connection)");
+    try (Response response = client.newCall(request).execute()) {
+      // Consume and discard the response body.
+      response.body().source().readByteString();
+    }
+
+    System.out.println("REQUEST 2 (pooled connection)");
+    try (Response response = client.newCall(request).execute()) {
+      // Consume and discard the response body.
+      response.body().source().readByteString();
+    }
+  }
+
+  public static void main(String... args) throws Exception {
+    new PrintEventsNonConcurrent().run();
+  }
+
+  private static final class PrintingEventListener extends EventListener {
+    long callStartNanos;
+
+    private void printEvent(String name) {
+      long nowNanos = System.nanoTime();
+      if (name.equals("callStart")) {
+        callStartNanos = nowNanos;
+      }
+      long elapsedNanos = nowNanos - callStartNanos;
+      System.out.printf("%.3f %s%n", elapsedNanos / 1000000000d, name);
+    }
+
+    @Override public void callStart(Call call) {
+      printEvent("callStart");
+    }
+
+    @Override public void dnsStart(Call call, String domainName) {
+      printEvent("dnsStart");
+    }
+
+    @Override public void dnsEnd(Call call, String domainName, List<InetAddress> inetAddressList) {
+      printEvent("dnsEnd");
+    }
+
+    @Override public void connectStart(
+        Call call, InetSocketAddress inetSocketAddress, Proxy proxy) {
+      printEvent("connectStart");
+    }
+
+    @Override public void secureConnectStart(Call call) {
+      printEvent("secureConnectStart");
+    }
+
+    @Override public void secureConnectEnd(Call call, Handshake handshake) {
+      printEvent("secureConnectEnd");
+    }
+
+    @Override public void connectEnd(
+        Call call, InetSocketAddress inetSocketAddress, Proxy proxy, Protocol protocol) {
+      printEvent("connectEnd");
+    }
+
+    @Override public void connectFailed(Call call, InetSocketAddress inetSocketAddress, Proxy proxy,
+        Protocol protocol, IOException ioe) {
+      printEvent("connectFailed");
+    }
+
+    @Override public void connectionAcquired(Call call, Connection connection) {
+      printEvent("connectionAcquired");
+    }
+
+    @Override public void connectionReleased(Call call, Connection connection) {
+      printEvent("connectionReleased");
+    }
+
+    @Override public void requestHeadersStart(Call call) {
+      printEvent("requestHeadersStart");
+    }
+
+    @Override public void requestHeadersEnd(Call call, Request request) {
+      printEvent("requestHeadersEnd");
+    }
+
+    @Override public void requestBodyStart(Call call) {
+      printEvent("requestBodyStart");
+    }
+
+    @Override public void requestBodyEnd(Call call, long byteCount) {
+      printEvent("requestBodyEnd");
+    }
+
+    @Override public void responseHeadersStart(Call call) {
+      printEvent("responseHeadersStart");
+    }
+
+    @Override public void responseHeadersEnd(Call call, Response response) {
+      printEvent("responseHeadersEnd");
+    }
+
+    @Override public void responseBodyStart(Call call) {
+      printEvent("responseBodyStart");
+    }
+
+    @Override public void responseBodyEnd(Call call, long byteCount) {
+      printEvent("responseBodyEnd");
+    }
+
+    @Override public void callEnd(Call call) {
+      printEvent("callEnd");
+    }
+
+    @Override public void callFailed(Call call, IOException ioe) {
+      printEvent("callFailed");
+    }
+  }
+}
diff --git a/samples/guide/src/main/java/okhttp3/recipes/Progress.java b/samples/guide/src/main/java/okhttp3/recipes/Progress.java
index f04de79340..e75a3cc949 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/Progress.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/Progress.java
@@ -36,11 +36,27 @@ public void run() throws Exception {
         .build();
 
     final ProgressListener progressListener = new ProgressListener() {
+      boolean firstUpdate = true;
+
       @Override public void update(long bytesRead, long contentLength, boolean done) {
-        System.out.println(bytesRead);
-        System.out.println(contentLength);
-        System.out.println(done);
-        System.out.format("%d%% done\n", (100 * bytesRead) / contentLength);
+        if (done) {
+          System.out.println("completed");
+        } else {
+          if (firstUpdate) {
+            firstUpdate = false;
+            if (contentLength == -1) {
+              System.out.println("content-length: unknown");
+            } else {
+              System.out.format("content-length: %d\n", contentLength);
+            }
+          }
+
+          System.out.println(bytesRead);
+
+          if (contentLength != -1) {
+            System.out.format("%d%% done\n", (100 * bytesRead) / contentLength);
+          }
+        }
       }
     };
 
@@ -72,7 +88,7 @@ public static void main(String... args) throws Exception {
     private final ProgressListener progressListener;
     private BufferedSource bufferedSource;
 
-    public ProgressResponseBody(ResponseBody responseBody, ProgressListener progressListener) {
+    ProgressResponseBody(ResponseBody responseBody, ProgressListener progressListener) {
       this.responseBody = responseBody;
       this.progressListener = progressListener;
     }
diff --git a/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java b/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
index b1a62c0fa3..5473f67011 100644
--- a/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
+++ b/samples/guide/src/main/java/okhttp3/recipes/RequestBodyCompression.java
@@ -39,7 +39,7 @@
    * https://console.developers.google.com/project
    */
   public static final String GOOGLE_API_KEY = "AIzaSyAx2WZYe0My0i-uGurpvraYJxO7XNbwiGs";
-  public static final MediaType MEDIA_TYPE_JSON = MediaType.parse("application/json");
+  public static final MediaType MEDIA_TYPE_JSON = MediaType.get("application/json");
 
   private final OkHttpClient client = new OkHttpClient.Builder()
       .addInterceptor(new GzipRequestInterceptor())
diff --git a/samples/pom.xml b/samples/pom.xml
index d88108480b..f767a9377d 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3</groupId>
     <artifactId>parent</artifactId>
-    <version>3.6.0-SNAPSHOT</version>
+    <version>3.12.0-SNAPSHOT</version>
   </parent>
 
   <groupId>com.squareup.okhttp3.sample</groupId>
@@ -20,6 +20,7 @@
     <module>simple-client</module>
     <module>slack</module>
     <module>static-server</module>
+    <module>unixdomainsockets</module>
   </modules>
 
   <build>
diff --git a/samples/simple-client/pom.xml b/samples/simple-client/pom.xml
index b5f4cb46fb..d4f3ec0ae7 100644
--- a/samples/simple-client/pom.xml
+++ b/samples/simple-client/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.6.0-SNAPSHOT</version>
+    <version>3.12.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>simple-client</artifactId>
diff --git a/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java b/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
index ec9019110b..f2ac973db2 100644
--- a/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
+++ b/samples/simple-client/src/main/java/okhttp3/sample/OkHttpContributors.java
@@ -31,23 +31,22 @@ public static void main(String... args) throws Exception {
         .build();
 
     // Execute the request and retrieve the response.
-    Response response = client.newCall(request).execute();
-
-    // Deserialize HTTP response to concrete type.
-    ResponseBody body = response.body();
-    List<Contributor> contributors = CONTRIBUTORS_JSON_ADAPTER.fromJson(body.source());
-    body.close();
-
-    // Sort list by the most contributions.
-    Collections.sort(contributors, new Comparator<Contributor>() {
-      @Override public int compare(Contributor c1, Contributor c2) {
-        return c2.contributions - c1.contributions;
+    try (Response response = client.newCall(request).execute()) {
+      // Deserialize HTTP response to concrete type.
+      ResponseBody body = response.body();
+      List<Contributor> contributors = CONTRIBUTORS_JSON_ADAPTER.fromJson(body.source());
+
+      // Sort list by the most contributions.
+      Collections.sort(contributors, new Comparator<Contributor>() {
+        @Override public int compare(Contributor c1, Contributor c2) {
+          return c2.contributions - c1.contributions;
+        }
+      });
+
+      // Output list of contributors.
+      for (Contributor contributor : contributors) {
+        System.out.println(contributor.login + ": " + contributor.contributions);
       }
-    });
-
-    // Output list of contributors.
-    for (Contributor contributor : contributors) {
-      System.out.println(contributor.login + ": " + contributor.contributions);
     }
   }
 
diff --git a/samples/slack/pom.xml b/samples/slack/pom.xml
index 06d78916a1..26798cddf0 100644
--- a/samples/slack/pom.xml
+++ b/samples/slack/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.6.0-SNAPSHOT</version>
+    <version>3.12.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>slack</artifactId>
diff --git a/samples/slack/src/main/java/okhttp3/slack/OAuthSessionFactory.java b/samples/slack/src/main/java/okhttp3/slack/OAuthSessionFactory.java
index 04ba201c96..c0ad139aed 100644
--- a/samples/slack/src/main/java/okhttp3/slack/OAuthSessionFactory.java
+++ b/samples/slack/src/main/java/okhttp3/slack/OAuthSessionFactory.java
@@ -76,7 +76,7 @@ private HttpUrl redirectUrl() {
   }
 
   /** When the browser hits the redirect URL, use the provided code to ask Slack for a session. */
-  @Override public MockResponse dispatch(RecordedRequest request) throws InterruptedException {
+  @Override public MockResponse dispatch(RecordedRequest request) {
     HttpUrl requestUrl = mockWebServer.url(request.getPath());
     String code = requestUrl.queryParameter("code");
     String stateString = requestUrl.queryParameter("state");
diff --git a/samples/slack/src/main/java/okhttp3/slack/SlackApi.java b/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
index 0ec0ef7a45..4ab8565942 100644
--- a/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
+++ b/samples/slack/src/main/java/okhttp3/slack/SlackApi.java
@@ -38,7 +38,7 @@
  * http://localhost:53203/oauth/}, passing the same port to this classâ€™ constructor.
  */
 public final class SlackApi {
-  private final HttpUrl baseUrl = HttpUrl.parse("https://slack.com/api/");
+  private final HttpUrl baseUrl = HttpUrl.get("https://slack.com/api/");
   private final OkHttpClient httpClient;
   private final Moshi moshi;
 
@@ -120,7 +120,7 @@ public WebSocket rtm(HttpUrl url, WebSocketListener listener) {
     @FromJson HttpUrl urlFromJson(String urlString) {
       if (urlString.startsWith("wss:")) urlString = "https:" + urlString.substring(4);
       if (urlString.startsWith("ws:")) urlString = "http:" + urlString.substring(3);
-      return HttpUrl.parse(urlString);
+      return HttpUrl.get(urlString);
     }
   }
 }
diff --git a/samples/static-server/pom.xml b/samples/static-server/pom.xml
index 3d86d04ca5..5c949eeb5b 100644
--- a/samples/static-server/pom.xml
+++ b/samples/static-server/pom.xml
@@ -6,7 +6,7 @@
   <parent>
     <groupId>com.squareup.okhttp3.sample</groupId>
     <artifactId>sample-parent</artifactId>
-    <version>3.6.0-SNAPSHOT</version>
+    <version>3.12.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>static-server</artifactId>
diff --git a/samples/unixdomainsockets/pom.xml b/samples/unixdomainsockets/pom.xml
new file mode 100644
index 0000000000..a9ea691926
--- /dev/null
+++ b/samples/unixdomainsockets/pom.xml
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp3.sample</groupId>
+    <artifactId>sample-parent</artifactId>
+    <version>3.12.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>unixdomainsockets</artifactId>
+  <name>Sample: UNIX domain sockets</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp3</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.github.jnr</groupId>
+      <artifactId>jnr-unixsocket</artifactId>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/ClientAndServer.java b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/ClientAndServer.java
new file mode 100644
index 0000000000..8512c2d38d
--- /dev/null
+++ b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/ClientAndServer.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.unixdomainsockets;
+
+import java.io.File;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okhttp3.mockwebserver.MockResponse;
+import okhttp3.mockwebserver.MockWebServer;
+
+/**
+ * Create UNIX domain sockets for MockWebServer and OkHttp and connect 'em together. Note that we
+ * cannot do TLS over domain sockets.
+ */
+public class ClientAndServer {
+  public void run() throws Exception {
+    File socketFile = new File("/tmp/ClientAndServer.sock");
+    socketFile.delete(); // Clean up from previous runs.
+
+    MockWebServer server = new MockWebServer();
+    server.setServerSocketFactory(new UnixDomainServerSocketFactory(socketFile));
+    server.enqueue(new MockResponse().setBody("hello"));
+    server.start();
+
+    OkHttpClient client = new OkHttpClient.Builder()
+        .socketFactory(new UnixDomainSocketFactory(socketFile))
+        .build();
+
+    Request request = new Request.Builder()
+        .url("http://publicobject.com/helloworld.txt")
+        .build();
+
+    try (Response response = client.newCall(request).execute()) {
+      System.out.println(response.body().string());
+    }
+
+    server.shutdown();
+    socketFile.delete();
+  }
+
+  public static void main(String... args) throws Exception {
+    new ClientAndServer().run();
+  }
+}
diff --git a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainServerSocketFactory.java b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainServerSocketFactory.java
new file mode 100644
index 0000000000..f9ec4a08f8
--- /dev/null
+++ b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainServerSocketFactory.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.unixdomainsockets;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.SocketAddress;
+import javax.net.ServerSocketFactory;
+import jnr.unixsocket.UnixServerSocketChannel;
+import jnr.unixsocket.UnixSocket;
+import jnr.unixsocket.UnixSocketAddress;
+import jnr.unixsocket.UnixSocketChannel;
+
+/** Impersonate TCP-style ServerSocketFactory over UNIX domain sockets. */
+public final class UnixDomainServerSocketFactory extends ServerSocketFactory {
+  private final File path;
+
+  public UnixDomainServerSocketFactory(File path) {
+    this.path = path;
+  }
+
+  private ServerSocket createUnixDomainSocket() throws IOException {
+    return new UnixDomainServerSocket();
+  }
+
+  @Override public ServerSocket createServerSocket() throws IOException {
+    return createUnixDomainSocket();
+  }
+
+  @Override public ServerSocket createServerSocket(int port) throws IOException {
+    return createUnixDomainSocket();
+  }
+
+  @Override public ServerSocket createServerSocket(int port, int backlog) throws IOException {
+    return createUnixDomainSocket();
+  }
+
+  @Override public ServerSocket createServerSocket(
+      int port, int backlog, InetAddress inetAddress) throws IOException {
+    return createUnixDomainSocket();
+  }
+
+  final class UnixDomainServerSocket extends ServerSocket {
+    private UnixServerSocketChannel serverSocketChannel;
+    private InetSocketAddress endpoint;
+
+    UnixDomainServerSocket() throws IOException {
+    }
+
+    @Override public void bind(SocketAddress endpoint, int backlog) throws IOException {
+      this.endpoint = (InetSocketAddress) endpoint;
+
+      UnixSocketAddress address = new UnixSocketAddress(path);
+      serverSocketChannel = UnixServerSocketChannel.open();
+      serverSocketChannel.configureBlocking(true);
+      serverSocketChannel.socket().bind(address);
+    }
+
+    @Override public int getLocalPort() {
+      return 1; // A white lie. There is no local port.
+    }
+
+    @Override public SocketAddress getLocalSocketAddress() {
+      return endpoint;
+    }
+
+    @Override public Socket accept() throws IOException {
+      UnixSocketChannel socketChannel = serverSocketChannel.accept();
+
+      return new UnixSocket(socketChannel) {
+        @Override public InetAddress getInetAddress() {
+          return endpoint.getAddress(); // TODO(jwilson): fake the remote address?
+        }
+      };
+    }
+
+    @Override public void close() throws IOException {
+      serverSocketChannel.close();
+    }
+  }
+}
diff --git a/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainSocketFactory.java b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainSocketFactory.java
new file mode 100644
index 0000000000..8b16e398f7
--- /dev/null
+++ b/samples/unixdomainsockets/src/main/java/okhttp3/unixdomainsockets/UnixDomainSocketFactory.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okhttp3.unixdomainsockets;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.InetAddress;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.net.SocketAddress;
+import javax.net.SocketFactory;
+import jnr.unixsocket.UnixSocket;
+import jnr.unixsocket.UnixSocketAddress;
+import jnr.unixsocket.UnixSocketChannel;
+
+/** Impersonate TCP-style SocketFactory over UNIX domain sockets. */
+public final class UnixDomainSocketFactory extends SocketFactory {
+  private final File path;
+
+  public UnixDomainSocketFactory(File path) {
+    this.path = path;
+  }
+
+  private Socket createUnixDomainSocket() throws IOException {
+    UnixSocketChannel channel = UnixSocketChannel.open();
+
+    return new UnixSocket(channel) {
+      private InetSocketAddress inetSocketAddress;
+
+      @Override public void connect(SocketAddress endpoint) throws IOException {
+        connect(endpoint, Integer.valueOf(0));
+      }
+
+      @Override public void connect(SocketAddress endpoint, int timeout) throws IOException {
+        connect(endpoint, Integer.valueOf(timeout));
+      }
+
+      @Override public void connect(SocketAddress endpoint, Integer timeout) throws IOException {
+        this.inetSocketAddress = (InetSocketAddress) endpoint;
+        super.connect(new UnixSocketAddress(path), timeout);
+      }
+
+      @Override public InetAddress getInetAddress() {
+        return inetSocketAddress.getAddress(); // TODO(jwilson): fake the remote address?
+      }
+    };
+  }
+
+  @Override public Socket createSocket() throws IOException {
+    return createUnixDomainSocket();
+  }
+
+  @Override public Socket createSocket(String host, int port) throws IOException {
+    return createUnixDomainSocket();
+  }
+
+  @Override public Socket createSocket(
+      String host, int port, InetAddress localHost, int localPort) throws IOException {
+    return createUnixDomainSocket();
+  }
+
+  @Override public Socket createSocket(InetAddress host, int port) throws IOException {
+    return createUnixDomainSocket();
+  }
+
+  @Override public Socket createSocket(
+      InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
+    return createUnixDomainSocket();
+  }
+}
diff --git a/website/index.html b/website/index.html
index 6f0df48a03..67638d5702 100644
--- a/website/index.html
+++ b/website/index.html
@@ -8,7 +8,7 @@
     <link href="static/bootstrap-combined.min.css" rel="stylesheet">
     <link href="static/app.css" rel="stylesheet">
     <link href="static/app-theme.css" rel="stylesheet">
-    <link href="http://fonts.googleapis.com/css?family=Roboto:400,300italic,100,100italic,300" rel="stylesheet" type="text/css">
+    <link href="https://fonts.googleapis.com/css?family=Roboto:400,300italic,100,100italic,300" rel="stylesheet" type="text/css">
     <!--[if lt IE 9]><script src="static/html5shiv.min.js"></script><![endif]-->
   </head>
   <body data-target=".content-nav">
@@ -22,8 +22,8 @@ <h1>OkHttp</h1>
             <menu>
               <ul>
                 <li><a href="#download" class="menu download">Download <span class="version-tag">Latest</span></a></li>
-                <li><a href="http://github.com/square/okhttp" data-title="View GitHub Project" class="menu github"><img src="static/icon-github.png" alt="GitHub"/></a></li>
-                <li><a href="http://square.github.io/" data-title="Square Open Source Portal" class="menu square"><img src="static/icon-square.png" alt="Square"/></a></li>
+                <li><a href="https://github.com/square/okhttp" data-title="View GitHub Project" class="menu github"><img src="static/icon-github.png" alt="GitHub"/></a></li>
+                <li><a href="https://square.github.io/" data-title="Square Open Source Portal" class="menu square"><img src="static/icon-square.png" alt="Square"/></a></li>
               </ul>
             </menu>
           </div>
@@ -69,7 +69,7 @@ <h3 id="overview">Overview</h3>
 
             <h3 id="examples">Examples</h3>
             <h4>Get a URL</h4>
-            <p>This program downloads a URL and print its contents as a string. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/okhttp3/guide/GetExample.java">Full source</a>.
+            <p>This program downloads a URL and prints its contents as a string. <a href="https://raw.github.com/square/okhttp/master/samples/guide/src/main/java/okhttp3/guide/GetExample.java">Full source</a>.
 <pre class="prettyprint">
 OkHttpClient client = new OkHttpClient();
 
@@ -106,10 +106,10 @@ <h4>Post to a Server</h4>
 
             <h3 id="download">Download</h3>
             <p><a href="https://search.maven.org/remote_content?g=com.squareup.okhttp3&a=okhttp&v=LATEST" class="dl version-href">&darr; <span class="version-tag">Latest</span> JAR</a></p>
-            <p>You'll also need <a href="http://github.com/square/okio">Okio</a>, which OkHttp
+            <p>You'll also need <a href="https://github.com/square/okio">Okio</a>, which OkHttp
                 uses for fast I/O and resizable buffers. Download the
                 <a href="https://search.maven.org/remote_content?g=com.squareup.okio&a=okio&v=LATEST">latest JAR</a>.
-            <p>The source code to OkHttp, its samples, and this website is <a href="http://github.com/square/okhttp">available on GitHub</a>.</p>
+            <p>The source code to OkHttp, its samples, and this website is <a href="https://github.com/square/okhttp">available on GitHub</a>.</p>
 
             <h4>Maven</h4>
             <pre class="prettyprint">&lt;dependency>
@@ -119,12 +119,12 @@ <h4>Maven</h4>
 &lt;/dependency></pre>
 
             <h4>Gradle</h4>
-            <pre class="prettyprint">compile 'com.squareup.okhttp3:okhttp:<span class="version pln"><em>(insert latest version)</em></span>'</pre>
+            <pre class="prettyprint">implementation 'com.squareup.okhttp3:okhttp:<span class="version pln"><em>(insert latest version)</em></span>'</pre>
 
             <h3 id="contributing">Contributing</h3>
             <p>If you would like to contribute code you can do so through GitHub by forking the repository and sending a pull request.</p>
             <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible. Please also make sure your code compiles by running <code>mvn clean verify</code>.</p>
-            <p>Before your code can be accepted into the project you must also sign the <a href="http://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
+            <p>Before your code can be accepted into the project you must also sign the <a href="https://squ.re/sign-the-cla">Individual Contributor License Agreement (CLA)</a>.</p>
 
             <h3 id="license">License</h3>
             <pre>Copyright 2016 Square, Inc.
@@ -153,7 +153,7 @@ <h3 id="license">License</h3>
               <ul class="nav nav-pills nav-stacked secondary">
                 <li><a href="https://github.com/square/okhttp/wiki">Wiki</a></li>
                 <li><a href="3.x/okhttp/">Javadoc</a></li>
-                <li><a href="http://stackoverflow.com/questions/tagged/okhttp?sort=active">StackOverflow</a></li>
+                <li><a href="https://stackoverflow.com/questions/tagged/okhttp?sort=active">StackOverflow</a></li>
               </ul>
             </div>
           </div>
@@ -165,7 +165,7 @@ <h3 id="license">License</h3>
         </div>
       </div>
     </section>
-    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
+    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
     <script src="static/bootstrap.min.js"></script>
     <script src="static/jquery.smooth-scroll.min.js"></script>
     <script src="static/jquery-maven-artifact.min.js"></script>
diff --git a/website/static/jquery-maven-artifact.min.js b/website/static/jquery-maven-artifact.min.js
index 4b78fe23ac..6e134dd857 100644
--- a/website/static/jquery-maven-artifact.min.js
+++ b/website/static/jquery-maven-artifact.min.js
@@ -4,4 +4,4 @@
  * Version: 2.0.0
  * Author: Jake Wharton
  * License: Apache 2.0
- */(function(e){function n(e,t){var n=e.groupId.replace(/\./g,"/"),r="http://repo1.maven.org/maven2/"+n+"/"+e.artifactId+"/"+t+"/"+e.artifactId+"-"+t;return typeof e.classifier!="undefined"&&(r+="-"+e.classifier),r+="."+e.packaging,r}function r(e){var t={groupId:"g",artifactId:"a",packaging:"p",classifier:"l"},n="";for(var r in t)t.hasOwnProperty(r)&&e.hasOwnProperty(r)&&(n!==""&&(n+="+AND+"),n+=t[r]+':"'+e[r]+'"');return n}var t={packaging:"jar"};e.fn.artifactVersion=function(i,s){if(typeof i=="undefined"){alert("Error: config object is required.");return}if(typeof s=="undefined"){alert("Error: callback function required.");return}var i=e.extend({},t,i),o="http://search.maven.org/solrsearch/select/?q="+r(i)+"&wt=json&json.wrf=?";e.getJSON(o,function(e){var t=e.response.docs;if(t.length==0)return;var r=t[0].latestVersion||t[0].v,o=n(i,r);s(r,o)})},e.fn.artifactVersions=function(i,s){if(typeof i=="undefined"){alert("Error: config object is required.");return}if(typeof s=="undefined"){alert("Error: callback function required.");return}var i=e.extend({},t,i),o="http://search.maven.org/solrsearch/select/?q="+r(i)+"&wt=json&rows=10&core=gav&json.wrf=?";e.getJSON(o,function(e){var t=e.response.docs;if(t.length==0)return;t.sort(function(e,t){return e.v>t.v?-1:1});var r=[];for(var o=0;o<t.length;o++){var u=t[o].v;r.push({name:u,url:n(i,u)})}s(r)})}})(jQuery);
\ No newline at end of file
+ */(function(e){function n(e,t){var n=e.groupId.replace(/\./g,"/"),r="https://repo1.maven.org/maven2/"+n+"/"+e.artifactId+"/"+t+"/"+e.artifactId+"-"+t;return typeof e.classifier!="undefined"&&(r+="-"+e.classifier),r+="."+e.packaging,r}function r(e){var t={groupId:"g",artifactId:"a",packaging:"p",classifier:"l"},n="";for(var r in t)t.hasOwnProperty(r)&&e.hasOwnProperty(r)&&(n!==""&&(n+="+AND+"),n+=t[r]+':"'+e[r]+'"');return n}var t={packaging:"jar"};e.fn.artifactVersion=function(i,s){if(typeof i=="undefined"){alert("Error: config object is required.");return}if(typeof s=="undefined"){alert("Error: callback function required.");return}var i=e.extend({},t,i),o="https://search.maven.org/solrsearch/select/?q="+r(i)+"&wt=json&json.wrf=?";e.getJSON(o,function(e){var t=e.response.docs;if(t.length==0)return;var r=t[0].latestVersion||t[0].v,o=n(i,r);s(r,o)})},e.fn.artifactVersions=function(i,s){if(typeof i=="undefined"){alert("Error: config object is required.");return}if(typeof s=="undefined"){alert("Error: callback function required.");return}var i=e.extend({},t,i),o="https://search.maven.org/solrsearch/select/?q="+r(i)+"&wt=json&rows=10&core=gav&json.wrf=?";e.getJSON(o,function(e){var t=e.response.docs;if(t.length==0)return;t.sort(function(e,t){return e.v>t.v?-1:1});var r=[];for(var o=0;o<t.length;o++){var u=t[o].v;r.push({name:u,url:n(i,u)})}s(r)})}})(jQuery);
