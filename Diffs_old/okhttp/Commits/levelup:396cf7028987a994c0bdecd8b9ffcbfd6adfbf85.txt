diff --git a/.travis.yml b/.travis.yml
index 7769867d9d..bc088e91bd 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -3,5 +3,8 @@ language: java
 notifications:
   email: false
 
+before_install:
+ - mvn -version
+
 jdk:
   - oraclejdk7
diff --git a/CHANGELOG.md b/CHANGELOG.md
index f52d93ada6..860b62b0dd 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,8 +1,75 @@
 Change Log
 ==========
 
-Version 1.3.0 *(2014-01-11)*
-----------------------------
+## Version 1.5.2
+
+_2014-03-17_
+
+ * Fix bug where deleting a file that was absent from the `HttpResponseCache`
+   caused an IOException.
+ * Fix bug in HTTP/2 where our HPACK decoder wasn't emitting entries in
+   certain eviction scenarios, leading to dropped response headers.
+
+## Version 1.5.1
+
+_2014-03-11_
+
+ * Fix 1.5.0 regression where connections should not have been recycled.
+ * Fix 1.5.0 regression where transparent Gzip was broken by attempting to
+   recover from another I/O failure.
+ * Fix problems where spdy/3.1 headers may not have been compressed properly.
+ * Fix problems with spdy/3.1 and http/2 where the wrong window size was being
+   used.
+ * Fix 1.5.0 regression where conditional cache responses could corrupt the
+   connection pool.
+
+
+## Version 1.5.0
+
+_2014-03-07_
+
+
+##### OkHttp no longer uses the default SSL context.
+
+Applications that want to use the global SSL context with OkHttp should configure their
+OkHttpClient instances with the following:
+
+```java
+okHttpClient.setSslSocketFactory(HttpsURLConnection.getDefaultSSLSocketFactory());
+```
+
+A simpler solution is to avoid the shared default SSL socket factory. Instead, if you
+need to customize SSL, do so for your specific OkHttpClient instance only.
+
+##### Synthetic headers have changed
+
+Previously OkHttp added a synthetic response header, `OkHttp-Selected-Transport`. It
+has been replaced with a new synthetic header, `OkHttp-Selected-Protocol`.
+
+##### Changes
+
+ * New: Support for `HTTP-draft-09/2.0`.
+ * New: Support for `spdy/3.1`. Dropped support for `spdy/3`.
+ * New: Use ALPN on Android platforms that support it (4.4+)
+ * New: CacheControl model and parser.
+ * New: Protocol selection in MockWebServer.
+ * Fix: Route selection shouldn't use TLS modes that we know will fail.
+ * Fix: Cache SPDY responses even if the response body is closed prematurely.
+ * Fix: Use strict timeouts when aborting a download.
+ * Fix: Support Shoutcast HTTP responses like `ICY 200 OK`.
+ * Fix: Don't unzip if there isn't a response body.
+ * Fix: Don't leak gzip streams on redirects.
+ * Fix: Don't do DNS lookups on invalid hosts.
+ * Fix: Exhaust the underlying stream when reading gzip streams.
+ * Fix: Support the `PATCH` method.
+ * Fix: Support request bodies on `DELETE` method.
+ * Fix: Drop the `okhttp-protocols` module.
+ * Internal: Replaced internal byte array buffers with pooled buffers ("OkBuffer").
+
+
+## Version 1.3.0
+
+_2014-01-11_
 
  * New: Support for "PATCH" HTTP method in client and MockWebServer.
  * Fix: Drop `Content-Length` header when redirected from POST to GET.
@@ -20,15 +87,17 @@ Version 1.3.0 *(2014-01-11)*
  * Fix: Honor read timeout when parsing SPDY headers.
 
 
-Version 1.2.1 *(2013-08-23)*
-----------------------------
+## Version 1.2.1
+
+_2013-08-23_
 
  * Resolve issue with 'jar-with-dependencies' artifact creation.
  * Fix: Support empty SPDY header values.
 
 
-Version 1.2.0 *(2013-08-11)*
-----------------------------
+## Version 1.2.0
+
+_2013-08-11_
 
  *  New APIs on OkHttpClient to set default timeouts for connect and read.
  *  Fix bug when caching SPDY responses.
@@ -53,15 +122,17 @@ Version 1.2.0 *(2013-08-11)*
  *  Bring MockWebServer into OkHttp and teach it SPDY.
 
 
-Version 1.1.1 *(2013-06-23)*
-----------------------------
+## Version 1.1.1
+
+_2013-06-23_
 
  * Fix: ClassCastException when caching responses that were redirected from
    HTTP to HTTPS.
 
 
-Version 1.1.0 *(2013-06-15)*
-----------------------------
+## Version 1.1.0
+
+_2013-06-15_
 
  * Fix: Connection reuse was broken for most HTTPS connections due to a bug in
    the way the hostname verifier was selected.
@@ -73,22 +144,26 @@ Version 1.1.0 *(2013-06-15)*
    Use `X-Android-Transports` to write the preferred transports and
    `X-Android-Selected-Transport` to read the negotiated transport.
 
-Version 1.0.2 *(2013-05-11)*
-----------------------------
+
+## Version 1.0.2
+
+_2013-05-11_
 
  * Fix: Remove use of Java 6-only APIs.
  * Fix: Properly handle exceptions from `NetworkInterface` when querying MTU.
  * Fix: Ensure MTU has a reasonable default and upper-bound.
 
 
-Version 1.0.1 *(2013-05-06)*
-----------------------------
+## Version 1.0.1
+
+_2013-05-06_
 
  * Correct casing of SSL in method names (`getSslSocketFactory`/`setSslSocketFactory`).
 
 
-Version 1.0.0 *(2013-05-06)*
-----------------------------
+## Version 1.0.0
+
+_2013-05-06_
 
 Initial release.
 
diff --git a/README.md b/README.md
index 90a0f0e900..cd3bd0241d 100644
--- a/README.md
+++ b/README.md
@@ -24,6 +24,14 @@ Download [the latest JAR][2] or grab via Maven:
 Building
 --------
 
+OkHttp requires Java 7 to build and run tests. Runtime compatibility with Java 6 is enforced as
+part of the build to ensure compliance with Android and older versions of the JVM.
+
+
+
+Testing
+-------
+
 ### On the Desktop
 
 Run OkHttp tests on the desktop with Maven. Running SPDY tests on the desktop uses
@@ -92,7 +100,7 @@ License
 
 
  [1]: http://square.github.io/okhttp
- [2]: http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.okhttp&a=okhttp&v=LATEST&c=jar-with-dependencies
+ [2]: http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.okhttp&a=okhttp&v=LATEST
  [3]: http://wiki.eclipse.org/Jetty/Feature/NPN
  [4]: https://code.google.com/p/vogar/
- [5]: http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.okhttp&a=mockwebserver&v=LATEST&c=jar-with-dependencies
+ [5]: http://repository.sonatype.org/service/local/artifact/maven/redirect?r=central-proxy&g=com.squareup.okhttp&a=mockwebserver&v=LATEST
diff --git a/benchmarks/README.md b/benchmarks/README.md
new file mode 100644
index 0000000000..59f571fc55
--- /dev/null
+++ b/benchmarks/README.md
@@ -0,0 +1,8 @@
+OkHttp Benchmarks
+=======================================
+
+This module allows you to test the performance of HTTP clients.
+
+### Running
+  1. If you made modifications to `com.squareup.okhttp.benchmarks.Benchmark` run `mvn compile`.
+  2. Run `mvn exec:exec` to launch a new JVM, which will execute the benchmark.
diff --git a/benchmarks/pom.xml b/benchmarks/pom.xml
new file mode 100644
index 0000000000..6425e64f10
--- /dev/null
+++ b/benchmarks/pom.xml
@@ -0,0 +1,98 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp</groupId>
+    <artifactId>parent</artifactId>
+    <version>2.0.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>benchmarks</artifactId>
+  <name>Benchmarks</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.google.caliper</groupId>
+      <artifactId>caliper</artifactId>
+      <version>1.0-beta-1</version>
+    </dependency>
+    <!-- caliper needs to be updated to be compatible with guava 16 -->
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+      <version>14.0.1</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.bouncycastle</groupId>
+      <artifactId>bcprov-jdk15on</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>org.mortbay.jetty.npn</groupId>
+      <artifactId>npn-boot</artifactId>
+      <scope>provided</scope>
+    </dependency>
+    <dependency>
+      <groupId>org.apache.httpcomponents</groupId>
+      <artifactId>httpclient</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-transport</artifactId>
+      <version>4.0.15.Final</version>
+    </dependency>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-handler</artifactId>
+      <version>4.0.15.Final</version>
+    </dependency>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-codec-http</artifactId>
+      <version>4.0.15.Final</version>
+    </dependency>
+    <!-- Netty needs this if gzip is enabled. -->
+    <dependency>
+      <groupId>com.jcraft</groupId>
+      <artifactId>jzlib</artifactId>
+      <version>1.1.2</version>
+    </dependency>
+  </dependencies>
+  <build>
+    <plugins>
+    <plugin>
+      <groupId>org.codehaus.mojo</groupId>
+      <artifactId>exec-maven-plugin</artifactId>
+      <executions>
+        <execution>
+          <goals>
+            <goal>java</goal>
+          </goals>
+        </execution>
+      </executions>
+      <configuration>
+        <executable>java</executable>
+        <arguments>
+          <argument>-Xms512m</argument>
+          <argument>-Xmx512m</argument>
+          <commandlineArgs>-Xbootclasspath/p:${settings.localRepository}/org/mortbay/jetty/npn/npn-boot/${npn.version}/npn-boot-${npn.version}.jar</commandlineArgs>
+          <argument>-classpath</argument>
+          <classpath/>
+          <argument>com.squareup.okhttp.benchmarks.Benchmark</argument>
+        </arguments>
+      </configuration>
+    </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/ApacheHttpClient.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/ApacheHttpClient.java
new file mode 100644
index 0000000000..cb8e719111
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/ApacheHttpClient.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import com.squareup.okhttp.internal.SslContextBuilder;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.concurrent.TimeUnit;
+import java.util.zip.GZIPInputStream;
+import javax.net.ssl.SSLContext;
+import org.apache.http.Header;
+import org.apache.http.HttpResponse;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.conn.ClientConnectionManager;
+import org.apache.http.conn.scheme.Scheme;
+import org.apache.http.conn.ssl.SSLSocketFactory;
+import org.apache.http.impl.client.DefaultHttpClient;
+import org.apache.http.impl.conn.PoolingClientConnectionManager;
+
+/** Benchmark Apache HTTP client. */
+class ApacheHttpClient extends SynchronousHttpClient {
+  private static final boolean VERBOSE = false;
+
+  private HttpClient client;
+
+  @Override public void prepare(Benchmark benchmark) {
+    super.prepare(benchmark);
+    ClientConnectionManager connectionManager = new PoolingClientConnectionManager();
+    if (benchmark.tls) {
+      SSLContext sslContext = SslContextBuilder.localhost();
+      connectionManager.getSchemeRegistry().register(
+          new Scheme("https", 443, new SSLSocketFactory(sslContext)));
+    }
+    client = new DefaultHttpClient(connectionManager);
+  }
+
+  @Override public Runnable request(URL url) {
+    return new ApacheHttpClientRequest(url);
+  }
+
+  class ApacheHttpClientRequest implements Runnable {
+    private final URL url;
+
+    public ApacheHttpClientRequest(URL url) {
+      this.url = url;
+    }
+
+    public void run() {
+      long start = System.nanoTime();
+      try {
+        HttpResponse response = client.execute(new HttpGet(url.toString()));
+        InputStream in = response.getEntity().getContent();
+        Header contentEncoding = response.getFirstHeader("Content-Encoding");
+        if (contentEncoding != null && contentEncoding.getValue().equals("gzip")) {
+          in = new GZIPInputStream(in);
+        }
+
+        long total = readAllAndClose(in);
+        long finish = System.nanoTime();
+
+        if (VERBOSE) {
+          System.out.println(String.format("Transferred % 8d bytes in %4d ms",
+              total, TimeUnit.NANOSECONDS.toMillis(finish - start)));
+        }
+      } catch (IOException e) {
+        System.out.println("Failed: " + e);
+      }
+    }
+  }
+}
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
new file mode 100644
index 0000000000..151128d6c0
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Benchmark.java
@@ -0,0 +1,223 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import com.google.caliper.Param;
+import com.google.caliper.model.ArbitraryMeasurement;
+import com.google.caliper.runner.CaliperMain;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.mockwebserver.Dispatcher;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.URL;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.TimeUnit;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import java.util.zip.GZIPOutputStream;
+import javax.net.ssl.SSLContext;
+
+/**
+ * This benchmark is fake, but may be useful for certain relative comparisons.
+ * It uses a local connection to a MockWebServer to measure how many identical
+ * requests per second can be carried over a fixed number of threads.
+ */
+public class Benchmark extends com.google.caliper.Benchmark {
+  private static final int NUM_REPORTS = 10;
+  private static final boolean VERBOSE = false;
+
+  private final Random random = new Random(0);
+
+  /** Which client to run.*/
+  @Param
+  Client client;
+
+  /** How many concurrent requests to execute. */
+  @Param({ "1", "10" })
+  int concurrencyLevel;
+
+  /** How many requests to enqueue to await threads to execute them. */
+  @Param({ "10" })
+  int targetBacklog;
+
+  /** True to use TLS. */
+  // TODO: compare different ciphers?
+  @Param
+  boolean tls;
+
+  /** True to use gzip content-encoding for the response body. */
+  @Param
+  boolean gzip;
+
+  /** Don't combine chunked with SPDY_3 or HTTP_2; that's not allowed. */
+  @Param
+  boolean chunked;
+
+  /** The size of the HTTP response body, in uncompressed bytes. */
+  @Param({ "128", "1048576" })
+  int bodyByteCount;
+
+  /** How many additional headers were included, beyond the built-in ones. */
+  @Param({ "0", "20" })
+  int headerCount;
+
+  /** Which ALPN/NPN protocols are in use. Only useful with TLS. */
+  List<Protocol> protocols = Arrays.asList(Protocol.HTTP_11);
+
+  public static void main(String[] args) {
+    List<String> allArgs = new ArrayList<String>();
+    allArgs.add("--instrument");
+    allArgs.add("arbitrary");
+    allArgs.addAll(Arrays.asList(args));
+
+    CaliperMain.main(Benchmark.class, allArgs.toArray(new String[allArgs.size()]));
+  }
+
+  @ArbitraryMeasurement(description = "requests per second")
+  public double run() throws Exception {
+    if (VERBOSE) System.out.println(toString());
+    HttpClient httpClient = client.create();
+
+    // Prepare the client & server
+    httpClient.prepare(this);
+    MockWebServer server = startServer();
+    URL url = server.getUrl("/");
+
+    int requestCount = 0;
+    long reportStart = System.nanoTime();
+    long reportPeriod = TimeUnit.SECONDS.toNanos(1);
+    int reports = 0;
+    double best = 0.0;
+
+    // Run until we've printed enough reports.
+    while (reports < NUM_REPORTS) {
+      // Print a report if we haven't recently.
+      long now = System.nanoTime();
+      double reportDuration = now - reportStart;
+      if (reportDuration > reportPeriod) {
+        double requestsPerSecond = requestCount / reportDuration * TimeUnit.SECONDS.toNanos(1);
+        if (VERBOSE) {
+          System.out.println(String.format("Requests per second: %.1f", requestsPerSecond));
+        }
+        best = Math.max(best, requestsPerSecond);
+        requestCount = 0;
+        reportStart = now;
+        reports++;
+      }
+
+      // Fill the job queue with work.
+      while (httpClient.acceptingJobs()) {
+        httpClient.enqueue(url);
+        requestCount++;
+      }
+
+      // The job queue is full. Take a break.
+      sleep(1);
+    }
+
+    return best;
+  }
+
+  @Override public String toString() {
+    List<Object> modifiers = new ArrayList<Object>();
+    if (tls) modifiers.add("tls");
+    if (gzip) modifiers.add("gzip");
+    if (chunked) modifiers.add("chunked");
+    modifiers.addAll(protocols);
+
+    return String.format("%s %s\nbodyByteCount=%s headerCount=%s concurrencyLevel=%s",
+        client, modifiers, bodyByteCount, headerCount, concurrencyLevel);
+  }
+
+  private void sleep(int millis) {
+    try {
+      Thread.sleep(millis);
+    } catch (InterruptedException ignored) {
+    }
+  }
+
+  private MockWebServer startServer() throws IOException {
+    Logger.getLogger(MockWebServer.class.getName()).setLevel(Level.WARNING);
+    MockWebServer server = new MockWebServer();
+
+    if (tls) {
+      SSLContext sslContext = SslContextBuilder.localhost();
+      server.useHttps(sslContext.getSocketFactory(), false);
+      server.setNpnEnabled(true);
+      server.setNpnProtocols(protocols);
+    }
+
+    final MockResponse response = newResponse();
+    server.setDispatcher(new Dispatcher() {
+      @Override public MockResponse dispatch(RecordedRequest request) {
+        return response;
+      }
+    });
+
+    server.play();
+    return server;
+  }
+
+  private MockResponse newResponse() throws IOException {
+    byte[] body = new byte[bodyByteCount];
+    random.nextBytes(body);
+
+    MockResponse result = new MockResponse();
+
+    if (gzip) {
+      body = gzip(body);
+      result.addHeader("Content-Encoding: gzip");
+    }
+
+    if (chunked) {
+      result.setChunkedBody(body, 1024);
+    } else {
+      result.setBody(body);
+    }
+
+    for (int i = 0; i < headerCount; i++) {
+      result.addHeader(randomString(12), randomString(20));
+    }
+
+    return result;
+  }
+
+  private String randomString(int length) {
+    String alphabet = "-abcdefghijklmnopqrstuvwxyz";
+    char[] result = new char[length];
+    for (int i = 0; i < length; i++) {
+      result[i] = alphabet.charAt(random.nextInt(alphabet.length()));
+    }
+    return new String(result);
+  }
+
+  /** Returns a gzipped copy of {@code bytes}. */
+  private byte[] gzip(byte[] bytes) throws IOException {
+    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
+    OutputStream gzippedOut = new GZIPOutputStream(bytesOut);
+    gzippedOut.write(bytes);
+    gzippedOut.close();
+    return bytesOut.toByteArray();
+  }
+}
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Client.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Client.java
new file mode 100644
index 0000000000..bd777aa359
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/Client.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+enum Client {
+  OkHttp {
+    @Override HttpClient create() {
+      return new OkHttp();
+    }
+  },
+
+  OkHttpAsync {
+    @Override HttpClient create() {
+      return new OkHttpAsync();
+    }
+  },
+
+  Apache {
+    @Override HttpClient create() {
+      return new ApacheHttpClient();
+    }
+  },
+
+  UrlConnection {
+    @Override HttpClient create() {
+      return new UrlConnection();
+    }
+  },
+
+  Netty {
+    @Override HttpClient create() {
+      return new NettyHttpClient();
+    }
+  };
+
+  abstract HttpClient create();
+}
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpClient.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpClient.java
new file mode 100644
index 0000000000..136c5d86d3
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/HttpClient.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import java.net.URL;
+
+/** An HTTP client to benchmark. */
+interface HttpClient {
+  void prepare(Benchmark benchmark);
+  void enqueue(URL url) throws Exception;
+  boolean acceptingJobs();
+}
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
new file mode 100644
index 0000000000..9044d0a33c
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/NettyHttpClient.java
@@ -0,0 +1,196 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.internal.Util;
+import io.netty.bootstrap.Bootstrap;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.PooledByteBufAllocator;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInitializer;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.SimpleChannelInboundHandler;
+import io.netty.channel.nio.NioEventLoopGroup;
+import io.netty.channel.socket.SocketChannel;
+import io.netty.channel.socket.nio.NioSocketChannel;
+import io.netty.handler.codec.http.DefaultFullHttpRequest;
+import io.netty.handler.codec.http.HttpClientCodec;
+import io.netty.handler.codec.http.HttpContent;
+import io.netty.handler.codec.http.HttpContentDecompressor;
+import io.netty.handler.codec.http.HttpHeaders;
+import io.netty.handler.codec.http.HttpMethod;
+import io.netty.handler.codec.http.HttpObject;
+import io.netty.handler.codec.http.HttpRequest;
+import io.netty.handler.codec.http.HttpResponse;
+import io.netty.handler.codec.http.HttpVersion;
+import io.netty.handler.codec.http.LastHttpContent;
+import io.netty.handler.ssl.SslHandler;
+import java.net.URL;
+import java.util.ArrayDeque;
+import java.util.Deque;
+import java.util.concurrent.TimeUnit;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+
+/** Netty isn't an HTTP client, but it's almost one. */
+class NettyHttpClient implements HttpClient {
+  private static final boolean VERBOSE = false;
+
+  // Guarded by this. Real apps need more capable connection management.
+  private final Deque<HttpChannel> freeChannels = new ArrayDeque<HttpChannel>();
+  private final Deque<URL> backlog = new ArrayDeque<URL>();
+
+  private int totalChannels = 0;
+  private int concurrencyLevel;
+  private int targetBacklog;
+  private Bootstrap bootstrap;
+
+  @Override public void prepare(final Benchmark benchmark) {
+    this.concurrencyLevel = benchmark.concurrencyLevel;
+    this.targetBacklog = benchmark.targetBacklog;
+
+    ChannelInitializer<SocketChannel> channelInitializer = new ChannelInitializer<SocketChannel>() {
+      @Override public void initChannel(SocketChannel channel) throws Exception {
+        ChannelPipeline pipeline = channel.pipeline();
+
+        if (benchmark.tls) {
+          SSLContext sslContext = SslContextBuilder.localhost();
+          SSLEngine engine = sslContext.createSSLEngine();
+          engine.setUseClientMode(true);
+          pipeline.addLast("ssl", new SslHandler(engine));
+        }
+
+        pipeline.addLast("codec", new HttpClientCodec());
+        pipeline.addLast("inflater", new HttpContentDecompressor());
+        pipeline.addLast("handler", new HttpChannel(channel));
+      }
+    };
+
+    bootstrap = new Bootstrap();
+    bootstrap.group(new NioEventLoopGroup(concurrencyLevel))
+        .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)
+        .channel(NioSocketChannel.class)
+        .handler(channelInitializer);
+  }
+
+  @Override public void enqueue(URL url) throws Exception {
+    HttpChannel httpChannel = null;
+    synchronized (this) {
+      if (!freeChannels.isEmpty()) {
+        httpChannel = freeChannels.pop();
+      } else if (totalChannels < concurrencyLevel) {
+        totalChannels++; // Create a new channel. (outside of the synchronized block).
+      } else {
+        backlog.add(url); // Enqueue this for later, to be picked up when another request completes.
+        return;
+      }
+    }
+    if (httpChannel == null) {
+      Channel channel = bootstrap.connect(url.getHost(), Util.getEffectivePort(url))
+          .sync().channel();
+      httpChannel = (HttpChannel) channel.pipeline().last();
+    }
+    httpChannel.sendRequest(url);
+  }
+
+  @Override public synchronized boolean acceptingJobs() {
+    return backlog.size() < targetBacklog || hasFreeChannels();
+  }
+
+  private boolean hasFreeChannels() {
+    int activeChannels = totalChannels - freeChannels.size();
+    return activeChannels < concurrencyLevel;
+  }
+
+  private void release(HttpChannel httpChannel) {
+    URL url;
+    synchronized (this) {
+      url = backlog.pop();
+      if (url == null) {
+        // There were no URLs in the backlog. Pool this channel for later.
+        freeChannels.push(httpChannel);
+        return;
+      }
+    }
+
+    // We removed a URL from the backlog. Schedule it right away.
+    httpChannel.sendRequest(url);
+  }
+
+  class HttpChannel extends SimpleChannelInboundHandler<HttpObject> {
+    private final SocketChannel channel;
+    byte[] buffer = new byte[1024];
+    int total;
+    long start;
+
+    public HttpChannel(SocketChannel channel) {
+      this.channel = channel;
+    }
+
+    private void sendRequest(URL url) {
+      start = System.nanoTime();
+      total = 0;
+      HttpRequest request = new DefaultFullHttpRequest(
+          HttpVersion.HTTP_1_1, HttpMethod.GET, url.getPath());
+      request.headers().set(HttpHeaders.Names.HOST, url.getHost());
+      request.headers().set(HttpHeaders.Names.ACCEPT_ENCODING, HttpHeaders.Values.GZIP);
+      channel.writeAndFlush(request);
+    }
+
+    @Override protected void channelRead0(
+        ChannelHandlerContext context, HttpObject message) throws Exception {
+      if (message instanceof HttpResponse) {
+        receive((HttpResponse) message);
+      }
+      if (message instanceof HttpContent) {
+        receive((HttpContent) message);
+        if (message instanceof LastHttpContent) {
+          release(this);
+        }
+      }
+    }
+
+    @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception {
+      super.channelInactive(ctx);
+    }
+
+    void receive(HttpResponse response) {
+      // Don't do anything with headers.
+    }
+
+    void receive(HttpContent content) {
+      // Consume the response body.
+      ByteBuf byteBuf = content.content();
+      for (int toRead; (toRead = byteBuf.readableBytes()) > 0; ) {
+        byteBuf.readBytes(buffer, 0, Math.min(buffer.length, toRead));
+        total += toRead;
+      }
+
+      if (VERBOSE && content instanceof LastHttpContent) {
+        long finish = System.nanoTime();
+        System.out.println(String.format("Transferred % 8d bytes in %4d ms",
+            total, TimeUnit.NANOSECONDS.toMillis(finish - start)));
+      }
+    }
+
+    @Override public void exceptionCaught(ChannelHandlerContext context, Throwable cause) {
+      System.out.println("Failed: " + cause);
+    }
+  }
+}
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java
new file mode 100644
index 0000000000..03b9e3c6f1
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttp.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.concurrent.TimeUnit;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSocketFactory;
+
+class OkHttp extends SynchronousHttpClient {
+  private static final boolean VERBOSE = false;
+
+  private OkHttpClient client;
+
+  @Override public void prepare(Benchmark benchmark) {
+    super.prepare(benchmark);
+    client = new OkHttpClient();
+    client.setProtocols(benchmark.protocols);
+
+    if (benchmark.tls) {
+      SSLContext sslContext = SslContextBuilder.localhost();
+      SSLSocketFactory socketFactory = sslContext.getSocketFactory();
+      HostnameVerifier hostnameVerifier = new HostnameVerifier() {
+        @Override public boolean verify(String s, SSLSession session) {
+          return true;
+        }
+      };
+      client.setSslSocketFactory(socketFactory);
+      client.setHostnameVerifier(hostnameVerifier);
+    }
+  }
+
+  @Override public Runnable request(URL url) {
+    return new OkHttpRequest(url);
+  }
+
+  class OkHttpRequest implements Runnable {
+    private final URL url;
+
+    public OkHttpRequest(URL url) {
+      this.url = url;
+    }
+
+    public void run() {
+      long start = System.nanoTime();
+      try {
+        HttpURLConnection urlConnection = client.open(url);
+        long total = readAllAndClose(urlConnection.getInputStream());
+        long finish = System.nanoTime();
+
+        if (VERBOSE) {
+          System.out.println(String.format("Transferred % 8d bytes in %4d ms",
+              total, TimeUnit.NANOSECONDS.toMillis(finish - start)));
+        }
+      } catch (IOException e) {
+        System.out.println("Failed: " + e);
+      }
+    }
+  }
+}
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
new file mode 100644
index 0000000000..b7633b76aa
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/OkHttpAsync.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import com.squareup.okhttp.Dispatcher;
+import com.squareup.okhttp.Failure;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import java.io.IOException;
+import java.net.URL;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSocketFactory;
+
+class OkHttpAsync implements HttpClient {
+  private static final boolean VERBOSE = false;
+
+  private final AtomicInteger requestsInFlight = new AtomicInteger();
+
+  private OkHttpClient client;
+  private Response.Receiver receiver;
+  private int concurrencyLevel;
+  private int targetBacklog;
+
+  @Override public void prepare(final Benchmark benchmark) {
+    concurrencyLevel = benchmark.concurrencyLevel;
+    targetBacklog = benchmark.targetBacklog;
+
+    client = new OkHttpClient();
+    client.setProtocols(benchmark.protocols);
+    client.setDispatcher(new Dispatcher(new ThreadPoolExecutor(benchmark.concurrencyLevel,
+        benchmark.concurrencyLevel, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>())));
+
+    if (benchmark.tls) {
+      SSLContext sslContext = SslContextBuilder.localhost();
+      SSLSocketFactory socketFactory = sslContext.getSocketFactory();
+      HostnameVerifier hostnameVerifier = new HostnameVerifier() {
+        @Override public boolean verify(String s, SSLSession session) {
+          return true;
+        }
+      };
+      client.setSslSocketFactory(socketFactory);
+      client.setHostnameVerifier(hostnameVerifier);
+    }
+
+    receiver = new Response.Receiver() {
+      @Override public void onFailure(Failure failure) {
+        System.out.println("Failed: " + failure.exception());
+      }
+
+      @Override public boolean onResponse(Response response) throws IOException {
+        Response.Body body = response.body();
+        long total = SynchronousHttpClient.readAllAndClose(body.byteStream());
+        long finish = System.nanoTime();
+        if (VERBOSE) {
+          long start = (Long) response.request().tag();
+          System.out.printf("Transferred % 8d bytes in %4d ms%n",
+              total, TimeUnit.NANOSECONDS.toMillis(finish - start));
+        }
+        requestsInFlight.decrementAndGet();
+        return true;
+      }
+    };
+  }
+
+  @Override public void enqueue(URL url) throws Exception {
+    requestsInFlight.incrementAndGet();
+    client.enqueue(new Request.Builder().tag(System.nanoTime()).url(url).build(), receiver);
+  }
+
+  @Override public synchronized boolean acceptingJobs() {
+    return requestsInFlight.get() < (concurrencyLevel + targetBacklog);
+  }
+}
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java
new file mode 100644
index 0000000000..b15eedcd88
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/SynchronousHttpClient.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+
+/** Any HTTP client with a blocking API. */
+abstract class SynchronousHttpClient implements HttpClient {
+  ThreadPoolExecutor executor;
+  int targetBacklog;
+
+  @Override public void prepare(Benchmark benchmark) {
+    this.targetBacklog = benchmark.targetBacklog;
+    executor = new ThreadPoolExecutor(benchmark.concurrencyLevel, benchmark.concurrencyLevel,
+        1, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
+  }
+
+  @Override public void enqueue(URL url) {
+    executor.execute(request(url));
+  }
+
+  @Override public boolean acceptingJobs() {
+    return executor.getQueue().size() < targetBacklog;
+  }
+
+  static long readAllAndClose(InputStream in) throws IOException {
+    byte[] buffer = new byte[1024];
+    long total = 0;
+    for (int count; (count = in.read(buffer)) != -1; ) {
+      total += count;
+    }
+    in.close();
+    return total;
+  }
+
+  abstract Runnable request(URL url);
+}
diff --git a/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java
new file mode 100644
index 0000000000..79abb69eeb
--- /dev/null
+++ b/benchmarks/src/main/java/com/squareup/okhttp/benchmarks/UrlConnection.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.benchmarks;
+
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.internal.http.HttpsURLConnectionImpl;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.URL;
+import java.util.concurrent.TimeUnit;
+import java.util.zip.GZIPInputStream;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
+import javax.net.ssl.SSLSocketFactory;
+
+class UrlConnection extends SynchronousHttpClient {
+  private static final boolean VERBOSE = false;
+
+  @Override public void prepare(Benchmark benchmark) {
+    super.prepare(benchmark);
+    if (benchmark.tls) {
+      SSLContext sslContext = SslContextBuilder.localhost();
+      SSLSocketFactory socketFactory = sslContext.getSocketFactory();
+      HostnameVerifier hostnameVerifier = new HostnameVerifier() {
+        @Override public boolean verify(String s, SSLSession session) {
+          return true;
+        }
+      };
+      HttpsURLConnectionImpl.setDefaultHostnameVerifier(hostnameVerifier);
+      HttpsURLConnectionImpl.setDefaultSSLSocketFactory(socketFactory);
+    }
+  }
+
+  @Override public Runnable request(URL url) {
+    return new UrlConnectionRequest(url);
+  }
+
+  static class UrlConnectionRequest implements Runnable {
+    private final URL url;
+
+    public UrlConnectionRequest(URL url) {
+      this.url = url;
+    }
+
+    public void run() {
+      long start = System.nanoTime();
+      try {
+        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();
+        InputStream in = urlConnection.getInputStream();
+        if ("gzip".equals(urlConnection.getHeaderField("Content-Encoding"))) {
+          in = new GZIPInputStream(in);
+        }
+
+        long total = readAllAndClose(in);
+        long finish = System.nanoTime();
+
+        if (VERBOSE) {
+          System.out.println(String.format("Transferred % 8d bytes in %4d ms",
+              total, TimeUnit.NANOSECONDS.toMillis(finish - start)));
+        }
+      } catch (IOException e) {
+        System.out.println("Failed: " + e);
+      }
+    }
+  }
+}
diff --git a/concurrency.md b/concurrency.md
new file mode 100644
index 0000000000..0858133a31
--- /dev/null
+++ b/concurrency.md
@@ -0,0 +1,63 @@
+# Concurrency in OkHttp
+
+The HttpURLConnection API is a blocking API. You make a blocking write to send a request, and a blocking read to receive the response.
+
+#### Blocking APIs
+
+Blocking APIs are convenient because you get top-to-bottom procedural code without indirection. Network calls work like regular method calls: ask for data and it is returned. If the request fails, you get a stacktrace right were the call was made.
+
+Blocking APIs may be inefficient because you hold a thread idle while waiting on the network. Threads are expensive because they have both a memory overhead and a context-switching overhead.
+
+#### Framed protocols
+
+Framed protocols like spdy/3 and http/2 don't lend themselves to blocking APIs. Each application-layer thread wants to do blocking I/O for a specific stream, but the streams are multiplexed on the socket. You can't just talk to the socket, you need to cooperate with the other application-layer threads that you're sharing it with.
+
+Framing rules make it impractical to implement spdy/3 or http/2 correctly on a single blocking thread. The flow-control features introduce feedback between reads and writes, requiring writes to acknowledge reads and reads to throttle writes.
+
+In OkHttp we expose a blocking API over a framed protocol. This document explains the code and policy that makes that work.
+
+## Threads
+
+#### Application's calling thread
+
+The application-layer must block on writing I/O. We can't return from a write until we've pushed its bytes onto the socket. Otherwise, if the write fails we are unable to deliver its IOException to the application. We would have told the application layer that the write succeeded, but it didn't!
+
+The application-layer can also do blocking reads. If the application asks to read and there's nothing available, we need to hold that thread until either the bytes arrive, the stream is closed, or a timeout elapses. If we get bytes but there's nobody asking for them, we buffer them. We don't consider bytes as delivered for flow control until they're consumed by the application.
+
+Consider an application streaming a video over http/2. Perhaps the user pauses the video and the application stops reading bytes from this stream. The buffer will fill up, and flow control prevents the server from sending more data on this stream. When the user unpauses her video the buffer drains, the read is acknowledged, and the server proceeds to stream data.
+
+#### Shared reader thread
+
+We can't rely on application threads to read data from the socket. Application threads are transient: sometimes they're reading and writing and sometimes they're off doing application-layer things. But the socket is permanent, and it needs constant attention: we dispatch all incoming frames so the connection is good-to-go when the application layer needs it.
+
+So we have a dedicated thread for every socket that just reads frames and dispatches them.
+
+The reader thread must never run application-layer code. Otherwise one slow stream can hold up the entire connection.
+
+Similarly, the reader thread must never block on writing because this can deadlock the connection. Consider a client and server that both violate this rule. If you get unlucky, they could fill up their TCP buffers (so that writes block) and then use their reader threads to write a frame. Nobody is reading on either end, and the buffers are never drained.
+
+#### Do-stuff-later pool
+
+Sometimes there's an action required like calling the application layer or responding to a ping, and the thread discovering the action is not the thread that should do the work. We enqueue a runnable on this executor and it gets handled by one of the executor's threads.
+
+## Locks
+
+We have 3 different things that we synchronize on.
+
+#### SpdyConnection
+
+This lock guards internal state of each connection. This lock is never held for blocking operations. That means that we acquire the lock, read or write a few fields and release the lock. No I/O and no application-layer callbacks.
+
+#### SpdyStream
+
+This lock guards the internal state of each stream. As above, it is never held for blocking operations. When we need to hold an application thread to block a read, we use wait/notify on this lock. This works because the lock is released while `wait()` is waiting.
+
+#### FrameWriter
+
+Socket writes are guarded by the FrameWriter. Only one stream can write at a time so that messages are not interleaved. Writes are either made by application-layer threads or the do-stuff-later pool.
+
+### Holding multiple locks
+
+You're allowed to take the SpdyConnection lock while holding the FrameWriter lock. But not vice-versa. Because taking the FrameWriter lock can block.
+
+This is necessary for bookkeeping when creating new streams. Correct framing requires that stream IDs are sequential on the socket, so we need to bundle assigning the ID with sending the `SYN_STREAM` frame.
diff --git a/mockwebserver/README.md b/mockwebserver/README.md
new file mode 100644
index 0000000000..39257be60b
--- /dev/null
+++ b/mockwebserver/README.md
@@ -0,0 +1,146 @@
+MockWebServer
+=============
+
+A scriptable web server for testing HTTP clients
+
+
+### Motivation
+
+This library makes it easy to test that your app Does The Right Thing when it
+makes HTTP and HTTPS calls. It lets you specify which responses to return and
+then verify that requests were made as expected.
+
+Because it exercises your full HTTP stack, you can be confident that you're
+testing everything. You can even copy & paste HTTP responses from your real web
+server to create representative test cases. Or test that your code survives in
+awkward-to-reproduce situations like 500 errors or slow-loading responses.
+
+
+### Example
+
+Use MockWebServer the same way that you use mocking frameworks like
+[Mockito](https://code.google.com/p/mockito/):
+
+1. Script the mocks.
+2. Run application code.
+3. Verify that the expected requests were made.
+
+Here's a complete example:
+
+```
+  public void test() throws Exception {
+    // Create a MockWebServer. These are lean enough that you can create a new
+    // instance for every unit test.
+    MockWebServer server = new MockWebServer();
+
+    // Schedule some responses.
+    server.enqueue(new MockResponse().setBody("hello, world!"));
+    server.enqueue(new MockResponse().setBody("sup, bra?"));
+    server.enqueue(new MockResponse().setBody("yo dog"));
+
+    // Start the server.
+    server.play();
+
+    // Ask the server for its URL. You'll need this to make HTTP requests.
+    URL baseUrl = server.getUrl("/v1/chat/");
+
+    // Exercise your application code, which should make those HTTP requests.
+    // Responses are returned in the same order that they are enqueued.
+    Chat chat = new Chat(baseUrl);
+
+    chat.loadMore();
+    assertEquals("hello, world!", chat.messages());
+
+    chat.loadMore();
+    chat.loadMore();
+    assertEquals(""
+        + "hello, world!\n"
+        + "sup, bra?\n"
+        + "yo dog", chat.messages());
+
+    // Optional: confirm that your app made the HTTP requests you were expecting.
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("/v1/chat/messages/", request1.getPath());
+    assertNotNull(request1.getHeader("Authorization"));
+
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("/v1/chat/messages/2", request2.getPath());
+
+    RecordedRequest request3 = server.takeRequest();
+    assertEquals("/v1/chat/messages/3", request3.getPath());
+
+    // Shut down the server. Instances cannot be reused.
+    server.shutdown();
+  }
+```
+
+Your unit tests might move the `server` into a field so you can shut it down
+from your test's `tearDown()`.
+
+### API
+
+#### MockResponse
+
+Mock responses default to an empty response body and a `200` status code.
+You can set a custom body with a string, input stream or byte array. Also
+add headers with a fluent builder API.
+
+```
+    MockResponse response = new MockResponse()
+        .addHeader("Content-Type", "application/json; charset=utf-8")
+        .addHeader("Cache-Control", "no-cache")
+        .setBody("{}");
+```
+
+MockResponse can be used to simulate a slow network. This is useful for
+testing timeouts and interactive testing.
+
+```
+    response.throttleBody(1024, 1, TimeUnit.SECONDS);
+```
+
+
+#### RecordedRequest
+
+Verify requests by their method, path, HTTP version, body, and headers.
+
+```
+    RecordedRequest request = server.takeRequest();
+    assertEquals("POST /v1/chat/send HTTP/1.1", request.getRequestLine());
+    assertEquals("application/json; charset=utf-8", request.getHeader("Content-Type"));
+    assertEquals("{}", request.getUtf8Body());
+```
+
+#### Dispatcher
+
+By default MockWebServer uses a queue to specify a series of responses. Use a
+Dispatcher to handle requests using another policy. One natural policy is to
+dispatch on the request path.
+
+
+### Download
+
+The best way to get MockWebServer is via Maven:
+
+```
+<dependency>
+  <groupId>com.squareup.okhttp</groupId>
+  <artifactId>mockwebserver</artifactId>
+  <version>(insert latest version)</version>
+  <scope>test</scope>
+</dependency>
+```
+
+### License
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
diff --git a/mockwebserver/pom.xml b/mockwebserver/pom.xml
index b935acbc68..9c7af9d6ed 100644
--- a/mockwebserver/pom.xml
+++ b/mockwebserver/pom.xml
@@ -15,7 +15,7 @@
   <dependencies>
     <dependency>
       <groupId>com.squareup.okhttp</groupId>
-      <artifactId>okhttp-protocols</artifactId>
+      <artifactId>okhttp</artifactId>
       <version>${project.version}</version>
     </dependency>
     <dependency>
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
index e135ef7ff6..098f3c93be 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/internal/spdy/SpdyServer.java
@@ -18,19 +18,19 @@
 
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.internal.Util;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.OutputStreamWriter;
-import java.io.Writer;
 import java.net.ServerSocket;
 import java.net.Socket;
 import java.util.Arrays;
 import java.util.List;
 import javax.net.ssl.SSLSocket;
 import javax.net.ssl.SSLSocketFactory;
+import okio.BufferedSink;
+import okio.Okio;
 import org.eclipse.jetty.npn.NextProtoNego;
 
 import static com.squareup.okhttp.internal.Util.headerEntries;
@@ -110,9 +110,8 @@ private void send404(SpdyStream stream, String path) throws IOException {
     List<Header> responseHeaders =
         headerEntries(":status", "404", ":version", "HTTP/1.1", "content-type", "text/plain");
     stream.reply(responseHeaders, true);
-    OutputStream out = stream.getOutputStream();
-    String text = "Not found: " + path;
-    out.write(text.getBytes("UTF-8"));
+    BufferedSink out = Okio.buffer(stream.getSink());
+    out.writeUtf8("Not found: " + path);
     out.close();
   }
 
@@ -121,26 +120,29 @@ private void serveDirectory(SpdyStream stream, String[] files) throws IOExceptio
         headerEntries(":status", "200", ":version", "HTTP/1.1", "content-type",
             "text/html; charset=UTF-8");
     stream.reply(responseHeaders, true);
-    OutputStream out = stream.getOutputStream();
-    Writer writer = new OutputStreamWriter(out, "UTF-8");
+    BufferedSink out = Okio.buffer(stream.getSink());
     for (String file : files) {
-      writer.write("<a href='" + file + "'>" + file + "</a><br>");
+      out.writeUtf8("<a href='" + file + "'>" + file + "</a><br>");
     }
-    writer.close();
+    out.close();
   }
 
   private void serveFile(SpdyStream stream, File file) throws IOException {
-    InputStream in = new FileInputStream(file);
     byte[] buffer = new byte[8192];
     stream.reply(
         headerEntries(":status", "200", ":version", "HTTP/1.1", "content-type", contentType(file)),
         true);
-    OutputStream out = stream.getOutputStream();
-    int count;
-    while ((count = in.read(buffer)) != -1) {
-      out.write(buffer, 0, count);
+    InputStream in = new FileInputStream(file);
+    BufferedSink out = Okio.buffer(stream.getSink());
+    try {
+      int count;
+      while ((count = in.read(buffer)) != -1) {
+        out.write(buffer, 0, count);
+      }
+    } finally {
+      Util.closeQuietly(in);
+      Util.closeQuietly(out);
     }
-    out.close();
   }
 
   private String contentType(File file) {
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
index beb4adb36f..7d8e066c34 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockResponse.java
@@ -46,6 +46,8 @@
 
   private int bodyDelayTimeMs = 0;
 
+  private List<PushPromise> promises = new ArrayList<PushPromise>();
+
   /** Creates a new mock response with an empty body. */
   public MockResponse() {
     setBody(new byte[0]);
@@ -54,7 +56,8 @@ public MockResponse() {
   @Override public MockResponse clone() {
     try {
       MockResponse result = (MockResponse) super.clone();
-      result.headers = new ArrayList<String>(result.headers);
+      result.headers = new ArrayList<String>(headers);
+      result.promises = new ArrayList<PushPromise>(promises);
       return result;
     } catch (CloneNotSupportedException e) {
       throw new AssertionError();
@@ -247,6 +250,20 @@ public int getBodyDelayTimeMs() {
     return bodyDelayTimeMs;
   }
 
+  /**
+   * When {@link MockWebServer#setNpnProtocols(java.util.List) protocols}
+   * include a SPDY variant, this attaches a pushed stream to this response.
+   */
+  public MockResponse withPush(PushPromise promise) {
+    this.promises.add(promise);
+    return this;
+  }
+
+  /** Returns the streams the server will push with this response. */
+  public List<PushPromise> getPushPromises() {
+    return promises;
+  }
+
   @Override public String toString() {
     return status;
   }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
index f37fde104d..a1edf0ac0b 100644
--- a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/MockWebServer.java
@@ -18,10 +18,10 @@
 package com.squareup.okhttp.mockwebserver;
 
 import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.NamedRunnable;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.spdy.ErrorCode;
 import com.squareup.okhttp.internal.spdy.Header;
 import com.squareup.okhttp.internal.spdy.IncomingStreamHandler;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
@@ -63,6 +63,10 @@
 import javax.net.ssl.SSLSocketFactory;
 import javax.net.ssl.TrustManager;
 import javax.net.ssl.X509TrustManager;
+import okio.BufferedSink;
+import okio.ByteString;
+import okio.OkBuffer;
+import okio.Okio;
 
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.FAIL_HANDSHAKE;
@@ -72,7 +76,6 @@
  * replays them upon request in sequence.
  */
 public final class MockWebServer {
-
   private static final X509TrustManager UNTRUSTED_TRUST_MANAGER = new X509TrustManager() {
     @Override public void checkClientTrusted(X509Certificate[] chain, String authType)
         throws CertificateException {
@@ -107,6 +110,7 @@
 
   private int port = -1;
   private boolean npnEnabled = true;
+  private List<Protocol> npnProtocols = Protocol.HTTP2_SPDY3_AND_HTTP;
 
   public int getPort() {
     if (port == -1) throw new IllegalStateException("Cannot retrieve port before calling play()");
@@ -166,6 +170,24 @@ public void setNpnEnabled(boolean npnEnabled) {
     this.npnEnabled = npnEnabled;
   }
 
+  /**
+   * Indicates the protocols supported by NPN on incoming HTTPS connections.
+   * This list is ignored when npn is disabled.
+   *
+   * @param protocols the protocols to use, in order of preference. The list
+   *     must contain "http/1.1". It must not contain null.
+   */
+  public void setNpnProtocols(List<Protocol> protocols) {
+    protocols = Util.immutableList(protocols);
+    if (!protocols.contains(Protocol.HTTP_11)) {
+      throw new IllegalArgumentException("protocols doesn't contain http/1.1: " + protocols);
+    }
+    if (protocols.contains(null)) {
+      throw new IllegalArgumentException("protocols must not contain null");
+    }
+    this.npnProtocols = Util.immutableList(protocols);
+  }
+
   /**
    * Serve requests with HTTPS rather than otherwise.
    * @param tunnelProxy true to expect the HTTP CONNECT method before
@@ -305,8 +327,7 @@ public void processConnection() throws Exception {
           openClientSockets.put(socket, true);
 
           if (npnEnabled) {
-            // TODO: expose means to select which protocols to advertise.
-            Platform.get().setNpnProtocols(sslSocket, Protocol.HTTP2_SPDY3_AND_HTTP);
+            Platform.get().setNpnProtocols(sslSocket, npnProtocols);
           }
 
           sslSocket.startHandshake();
@@ -327,7 +348,6 @@ public void processConnection() throws Exception {
               .handler(spdySocketHandler).build();
           openSpdyConnections.put(spdyConnection, Boolean.TRUE);
           openClientSockets.remove(socket);
-          spdyConnection.readConnectionHeader();
           return;
         }
 
@@ -381,7 +401,9 @@ private boolean processOneRequest(Socket socket, InputStream in, OutputStream ou
         } else if (response.getSocketPolicy() == SocketPolicy.SHUTDOWN_OUTPUT_AT_END) {
           socket.shutdownOutput();
         }
-        logger.info("Received request: " + request + " and responded: " + response);
+        if (logger.isLoggable(Level.INFO)) {
+          logger.info("Received request: " + request + " and responded: " + response);
+        }
         sequenceNumber++;
         return true;
       }
@@ -473,7 +495,6 @@ private RecordedRequest readRequest(Socket socket, InputStream in, OutputStream
     if (request.startsWith("OPTIONS ")
         || request.startsWith("GET ")
         || request.startsWith("HEAD ")
-        || request.startsWith("DELETE ")
         || request.startsWith("TRACE ")
         || request.startsWith("CONNECT ")) {
       if (hasBody) {
@@ -481,7 +502,8 @@ private RecordedRequest readRequest(Socket socket, InputStream in, OutputStream
       }
     } else if (!request.startsWith("POST ")
         && !request.startsWith("PUT ")
-        && !request.startsWith("PATCH ")) {
+        && !request.startsWith("PATCH ")
+        && !request.startsWith("DELETE ")) { // Permitted as spec is ambiguous.
       throw new UnsupportedOperationException("Unexpected method: " + request);
     }
 
@@ -611,8 +633,10 @@ private SpdySocketHandler(Socket socket, Protocol protocol) {
         throw new AssertionError(e);
       }
       writeResponse(stream, response);
-      logger.info("Received request: " + request + " and responded: " + response
-          + " protocol is " + protocol.name.utf8());
+      if (logger.isLoggable(Level.INFO)) {
+        logger.info("Received request: " + request + " and responded: " + response
+            + " protocol is " + protocol.name.utf8());
+      }
     }
 
     private RecordedRequest readRequest(SpdyStream stream) throws IOException {
@@ -635,7 +659,7 @@ private RecordedRequest readRequest(SpdyStream stream) throws IOException {
         }
       }
 
-      InputStream bodyIn = stream.getInputStream();
+      InputStream bodyIn = Okio.buffer(stream.getSource()).inputStream();
       ByteArrayOutputStream bodyOut = new ByteArrayOutputStream();
       byte[] buffer = new byte[8192];
       int count;
@@ -672,9 +696,14 @@ private void writeResponse(SpdyStream stream, MockResponse response) throws IOEx
         }
         spdyHeaders.add(new Header(headerParts[0], headerParts[1]));
       }
-      byte[] body = response.getBody();
-      stream.reply(spdyHeaders, body.length > 0);
-      if (body.length > 0) {
+      OkBuffer body = new OkBuffer();
+      if (response.getBody() != null) {
+        body.write(response.getBody());
+      }
+      boolean closeStreamAfterHeaders = body.size() > 0 || !response.getPushPromises().isEmpty();
+      stream.reply(spdyHeaders, closeStreamAfterHeaders);
+      pushPromises(stream, response.getPushPromises());
+      if (body.size() > 0) {
         if (response.getBodyDelayTimeMs() != 0) {
           try {
             Thread.sleep(response.getBodyDelayTimeMs());
@@ -682,8 +711,53 @@ private void writeResponse(SpdyStream stream, MockResponse response) throws IOEx
             throw new AssertionError(e);
           }
         }
-        stream.getOutputStream().write(body);
-        stream.getOutputStream().close();
+        BufferedSink sink = Okio.buffer(stream.getSink());
+        if (response.getThrottleBytesPerPeriod() == Integer.MAX_VALUE) {
+          sink.write(body, body.size());
+          sink.flush();
+        } else {
+          while (body.size() > 0) {
+            long toWrite = Math.min(body.size(), response.getThrottleBytesPerPeriod());
+            sink.write(body, toWrite);
+            sink.flush();
+            try {
+              long delayMs = response.getThrottleUnit().toMillis(response.getThrottlePeriod());
+              if (delayMs != 0) Thread.sleep(delayMs);
+            } catch (InterruptedException e) {
+              throw new AssertionError();
+            }
+          }
+        }
+        sink.close();
+      } else if (closeStreamAfterHeaders) {
+        stream.close(ErrorCode.NO_ERROR);
+      }
+    }
+
+    private void pushPromises(SpdyStream stream, List<PushPromise> promises) throws IOException {
+      for (PushPromise pushPromise : promises) {
+        List<Header> pushedHeaders = new ArrayList<Header>();
+        pushedHeaders.add(new Header(stream.getConnection().getProtocol() == Protocol.SPDY_3
+            ? Header.TARGET_HOST
+            : Header.TARGET_AUTHORITY, getUrl(pushPromise.getPath()).getHost()));
+        pushedHeaders.add(new Header(Header.TARGET_METHOD, pushPromise.getMethod()));
+        pushedHeaders.add(new Header(Header.TARGET_PATH, pushPromise.getPath()));
+        for (int i = 0, size = pushPromise.getHeaders().size(); i < size; i++) {
+          String header = pushPromise.getHeaders().get(i);
+          String[] headerParts = header.split(":", 2);
+          if (headerParts.length != 2) {
+            throw new AssertionError("Unexpected header: " + header);
+          }
+          pushedHeaders.add(new Header(headerParts[0], headerParts[1].trim()));
+        }
+        String requestLine = pushPromise.getMethod() + ' ' + pushPromise.getPath() + " HTTP/1.1";
+        List<Integer> chunkSizes = Collections.emptyList(); // No chunked encoding for SPDY.
+        requestQueue.add(new RecordedRequest(requestLine, pushPromise.getHeaders(), chunkSizes, 0,
+            Util.EMPTY_BYTE_ARRAY, sequenceNumber.getAndIncrement(), socket));
+        byte[] pushedBody = pushPromise.getResponse().getBody();
+        SpdyStream pushedStream =
+            stream.getConnection().pushStream(stream.getId(), pushedHeaders, pushedBody.length > 0);
+        writeResponse(pushedStream, pushPromise.getResponse());
       }
     }
   }
diff --git a/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/PushPromise.java b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/PushPromise.java
new file mode 100644
index 0000000000..d9dd01978b
--- /dev/null
+++ b/mockwebserver/src/main/java/com/squareup/okhttp/mockwebserver/PushPromise.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.mockwebserver;
+
+import java.util.List;
+
+/** An HTTP request initiated by the server. */
+public final class PushPromise {
+  private final String method;
+  private final String path;
+  private final List<String> headers;
+  private final MockResponse response;
+
+  public PushPromise(String method, String path, List<String> headers, MockResponse response) {
+    this.method = method;
+    this.path = path;
+    this.headers = headers;
+    this.response = response;
+  }
+
+  public String getMethod() {
+    return method;
+  }
+
+  public String getPath() {
+    return path;
+  }
+
+  public List<String> getHeaders() {
+    return headers;
+  }
+
+  public MockResponse getResponse() {
+    return response;
+  }
+}
diff --git a/okcurl/README.md b/okcurl/README.md
new file mode 100644
index 0000000000..cea5be4064
--- /dev/null
+++ b/okcurl/README.md
@@ -0,0 +1,7 @@
+OkCurl
+======
+
+_A curl for the next-generation web._
+
+OkCurl is an OkHttp-backed curl clone which allows you to test OkHttp's HTTP engine (including
+SPDY and HTTP/2) against web servers.
diff --git a/okcurl/pom.xml b/okcurl/pom.xml
new file mode 100644
index 0000000000..af0ba2e212
--- /dev/null
+++ b/okcurl/pom.xml
@@ -0,0 +1,94 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp</groupId>
+    <artifactId>parent</artifactId>
+    <version>2.0.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okcurl</artifactId>
+  <name>OkCurl</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.bouncycastle</groupId>
+      <artifactId>bcprov-jdk15on</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>org.mortbay.jetty.npn</groupId>
+      <artifactId>npn-boot</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>io.airlift</groupId>
+      <artifactId>airline</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+
+  <build>
+    <resources>
+      <resource>
+        <directory>src/main/resources</directory>
+        <filtering>true</filtering>
+      </resource>
+    </resources>
+
+    <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-assembly-plugin</artifactId>
+        <configuration>
+          <descriptorRefs>
+            <descriptorRef>jar-with-dependencies</descriptorRef>
+          </descriptorRefs>
+          <archive>
+            <manifest>
+              <mainClass>com.squareup.okhttp.curl.Main</mainClass>
+            </manifest>
+          </archive>
+        </configuration>
+        <executions>
+          <execution>
+            <phase>package</phase>
+            <goals>
+              <goal>single</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
+      <plugin>
+        <groupId>org.skife.maven</groupId>
+        <artifactId>really-executable-jar-maven-plugin</artifactId>
+        <version>1.1.0</version>
+        <executions>
+          <execution>
+            <phase>package</phase>
+            <goals>
+              <goal>really-executable-jar</goal>
+            </goals>
+          </execution>
+        </executions>
+        <configuration>
+          <flags>-Xbootclasspath/p:$0</flags>
+        </configuration>
+      </plugin>
+    </plugins>
+  </build>
+</project>
diff --git a/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java b/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
new file mode 100644
index 0000000000..9a45f20730
--- /dev/null
+++ b/okcurl/src/main/java/com/squareup/okhttp/curl/Main.java
@@ -0,0 +1,254 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.curl;
+
+import com.google.common.base.Function;
+import com.google.common.base.Joiner;
+import com.google.common.collect.Lists;
+import com.squareup.okhttp.ConnectionPool;
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import io.airlift.command.Arguments;
+import io.airlift.command.Command;
+import io.airlift.command.HelpOption;
+import io.airlift.command.Option;
+import io.airlift.command.SingleCommand;
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Properties;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSocketFactory;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.X509TrustManager;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+@Command(name = Main.NAME, description = "A curl for the next-generation web.")
+public class Main extends HelpOption implements Runnable {
+  static final String NAME = "okcurl";
+  static final int DEFAULT_TIMEOUT = -1;
+
+  static Main fromArgs(String... args) {
+    return SingleCommand.singleCommand(Main.class).parse(args);
+  }
+
+  public static void main(String... args) {
+    fromArgs(args).run();
+  }
+
+  private static String versionString() {
+    try {
+      Properties prop = new Properties();
+      InputStream in = Main.class.getResourceAsStream("/okcurl-version.properties");
+      prop.load(in);
+      in.close();
+      return prop.getProperty("version");
+    } catch (IOException e) {
+      throw new AssertionError("Could not load okcurl-version.properties.");
+    }
+  }
+
+  private static String protocols() {
+    return Joiner.on(", ").join(Lists.transform(Arrays.asList(Protocol.values()),
+        new Function<Protocol, String>() {
+          @Override public String apply(Protocol protocol) {
+            return protocol.name.utf8();
+          }
+        }));
+  }
+
+  @Option(name = { "-X", "--request" }, description = "Specify request command to use")
+  public String method;
+
+  @Option(name = { "-d", "--data" }, description = "HTTP POST data")
+  public String data;
+
+  @Option(name = { "-H", "--header" }, description = "Custom header to pass to server")
+  public List<String> headers;
+
+  @Option(name = { "-A", "--user-agent" }, description = "User-Agent to send to server")
+  public String userAgent = NAME + "/" + versionString();
+
+  @Option(name = "--connect-timeout", description = "Maximum time allowed for connection (seconds)")
+  public int connectTimeout = DEFAULT_TIMEOUT;
+
+  @Option(name = "--read-timeout", description = "Maximum time allowed for reading data (seconds)")
+  public int readTimeout = DEFAULT_TIMEOUT;
+
+  @Option(name = { "-L", "--location" }, description = "Follow redirects")
+  public boolean followRedirects;
+
+  @Option(name = { "-k", "--insecure" },
+      description = "Allow connections to SSL sites without certs")
+  public boolean allowInsecure;
+
+  @Option(name = { "-i", "--include" }, description = "Include protocol headers in the output")
+  public boolean showHeaders;
+
+  @Option(name = { "-e", "--referer" }, description = "Referer URL")
+  public String referer;
+
+  @Option(name = { "-V", "--version" }, description = "Show version number and quit")
+  public boolean version;
+
+  @Arguments(title = "url", description = "Remote resource URL")
+  public String url;
+
+  private OkHttpClient client;
+
+  @Override public void run() {
+    if (showHelpIfRequested()) {
+      return;
+    }
+    if (version) {
+      System.out.println(NAME + " " + versionString());
+      System.out.println("Protocols: " + protocols());
+      return;
+    }
+
+    client = createClient();
+    Request request = createRequest();
+    try {
+      Response response = client.execute(request);
+      if (showHeaders) {
+        System.out.println(response.statusLine());
+        Headers headers = response.headers();
+        for (int i = 0, count = headers.size(); i < count; i++) {
+          System.out.println(headers.name(i) + ": " + headers.value(i));
+        }
+        System.out.println();
+      }
+
+      Response.Body body = response.body();
+      byte[] buffer = new byte[1024];
+      while (body.ready()) {
+        int c = body.byteStream().read(buffer);
+        if (c == -1) {
+          return;
+        }
+        System.out.write(buffer, 0, c);
+      }
+      body.close();
+    } catch (IOException e) {
+      e.printStackTrace();
+    } finally {
+      close();
+    }
+  }
+
+  private OkHttpClient createClient() {
+    OkHttpClient client = new OkHttpClient();
+    client.setFollowProtocolRedirects(followRedirects);
+    if (connectTimeout != DEFAULT_TIMEOUT) {
+      client.setConnectTimeout(connectTimeout, SECONDS);
+    }
+    if (readTimeout != DEFAULT_TIMEOUT) {
+      client.setReadTimeout(readTimeout, SECONDS);
+    }
+    if (allowInsecure) {
+      client.setSslSocketFactory(createInsecureSslSocketFactory());
+    }
+    // If we don't set this reference, there's no way to clean shutdown persistent connections.
+    client.setConnectionPool(ConnectionPool.getDefault());
+    return client;
+  }
+
+  private String getRequestMethod() {
+    if (method != null) {
+      return method;
+    }
+    if (data != null) {
+      return "POST";
+    }
+    return "GET";
+  }
+
+  private Request.Body getRequestBody() {
+    if (data == null) {
+      return null;
+    }
+    String bodyData = data;
+
+    String mimeType = "application/x-form-urlencoded";
+    if (headers != null) {
+      for (String header : headers) {
+        String[] parts = header.split(":", -1);
+        if ("Content-Type".equalsIgnoreCase(parts[0])) {
+          mimeType = parts[1].trim();
+          headers.remove(header);
+          break;
+        }
+      }
+    }
+
+    return Request.Body.create(MediaType.parse(mimeType), bodyData);
+  }
+
+  Request createRequest() {
+    Request.Builder request = new Request.Builder();
+
+    request.url(url);
+    request.method(getRequestMethod(), getRequestBody());
+
+    if (headers != null) {
+      for (String header : headers) {
+        String[] parts = header.split(":", -1);
+        request.header(parts[0], parts[1]);
+      }
+    }
+    if (referer != null) {
+      request.header("Referer", referer);
+    }
+    request.header("User-Agent", userAgent);
+
+    return request.build();
+  }
+
+  private void close() {
+    client.getConnectionPool().evictAll(); // Close any persistent connections.
+  }
+
+  private static SSLSocketFactory createInsecureSslSocketFactory() {
+    try {
+      SSLContext context = SSLContext.getInstance("TLS");
+      TrustManager permissive = new X509TrustManager() {
+        @Override public void checkClientTrusted(X509Certificate[] chain, String authType)
+            throws CertificateException {
+        }
+
+        @Override public void checkServerTrusted(X509Certificate[] chain, String authType)
+            throws CertificateException {
+        }
+
+        @Override public X509Certificate[] getAcceptedIssuers() {
+          return null;
+        }
+      };
+      context.init(null, new TrustManager[] { permissive }, null);
+      return context.getSocketFactory();
+    } catch (Exception e) {
+      throw new AssertionError(e);
+    }
+  }
+}
diff --git a/okcurl/src/main/resources/okcurl-version.properties b/okcurl/src/main/resources/okcurl-version.properties
new file mode 100644
index 0000000000..defbd48204
--- /dev/null
+++ b/okcurl/src/main/resources/okcurl-version.properties
@@ -0,0 +1 @@
+version=${project.version}
diff --git a/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java b/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java
new file mode 100644
index 0000000000..6a5b97298b
--- /dev/null
+++ b/okcurl/src/test/java/com/squareup/okhttp/curl/MainTest.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.curl;
+
+import com.squareup.okhttp.Request;
+import java.io.IOException;
+import okio.OkBuffer;
+import org.junit.Test;
+
+import static com.squareup.okhttp.curl.Main.fromArgs;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+
+public class MainTest {
+  @Test public void simple() {
+    Request request = fromArgs("http://example.com").createRequest();
+    assertEquals("GET", request.method());
+    assertEquals("http://example.com", request.urlString());
+    assertNull(request.body());
+  }
+
+  @Test public void put() {
+    Request request = fromArgs("-X", "PUT", "http://example.com").createRequest();
+    assertEquals("PUT", request.method());
+    assertEquals("http://example.com", request.urlString());
+    assertNull(request.body());
+  }
+
+  @Test public void dataPost() {
+    Request request = fromArgs("-d", "foo", "http://example.com").createRequest();
+    Request.Body body = request.body();
+    assertEquals("POST", request.method());
+    assertEquals("http://example.com", request.urlString());
+    assertEquals("application/x-form-urlencoded; charset=utf-8", body.contentType().toString());
+    assertEquals("foo", bodyAsString(body));
+  }
+
+  @Test public void dataPut() {
+    Request request = fromArgs("-d", "foo", "-X", "PUT", "http://example.com").createRequest();
+    Request.Body body = request.body();
+    assertEquals("PUT", request.method());
+    assertEquals("http://example.com", request.urlString());
+    assertEquals("application/x-form-urlencoded; charset=utf-8", body.contentType().toString());
+    assertEquals("foo", bodyAsString(body));
+  }
+
+  @Test public void contentTypeHeader() {
+    Request request = fromArgs("-d", "foo", "-H", "Content-Type: application/json",
+        "http://example.com").createRequest();
+    Request.Body body = request.body();
+    assertEquals("POST", request.method());
+    assertEquals("http://example.com", request.urlString());
+    assertEquals("application/json; charset=utf-8", body.contentType().toString());
+    assertEquals("foo", bodyAsString(body));
+  }
+
+  @Test public void referer() {
+    Request request = fromArgs("-e", "foo", "http://example.com").createRequest();
+    assertEquals("GET", request.method());
+    assertEquals("http://example.com", request.urlString());
+    assertEquals("foo", request.header("Referer"));
+    assertNull(request.body());
+  }
+
+  @Test public void userAgent() {
+    Request request = fromArgs("-A", "foo", "http://example.com").createRequest();
+    assertEquals("GET", request.method());
+    assertEquals("http://example.com", request.urlString());
+    assertEquals("foo", request.header("User-Agent"));
+    assertNull(request.body());
+  }
+
+  private static String bodyAsString(Request.Body body) {
+    try {
+      OkBuffer buffer = new OkBuffer();
+      body.writeTo(buffer);
+      return new String(buffer.readByteString(buffer.size()).toByteArray(),
+          body.contentType().charset());
+    } catch (IOException e) {
+      throw new RuntimeException(e);
+    }
+  }
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/ByteString.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/ByteString.java
deleted file mode 100644
index 9370ebbea6..0000000000
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/ByteString.java
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- * Copyright 2014 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.util.Arrays;
-
-import static com.squareup.okhttp.internal.Util.asciiLowerCase;
-
-/**
- * An immutable sequence of bytes.
- *
- * <p><strong>Full disclosure:</strong> this class provides untrusted input and
- * output streams with raw access to the underlying byte array. A hostile
- * stream implementation could keep a reference to the mutable byte string,
- * violating the immutable guarantee of this class. For this reason a byte
- * string's immutability guarantee cannot be relied upon for security in applets
- * and other environments that run both trusted and untrusted code in the same
- * process.
- */
-public final class ByteString {
-  private final byte[] data;
-  private transient int hashCode; // Lazily computed; 0 if unknown.
-  private transient String utf8; // Lazily computed.
-
-  /** A singleton empty {@code ByteString}. */
-  public static final ByteString EMPTY = new ByteString(Util.EMPTY_BYTE_ARRAY);
-
-  /**
-   * Returns a new byte string containing a clone of the bytes of {@code data}.
-   */
-  public static ByteString of(byte... data) {
-    return new ByteString(data.clone());
-  }
-
-  /** Returns a new byte string containing the {@code UTF-8} bytes of {@code s}. */
-  public static ByteString encodeUtf8(String s) {
-    ByteString byteString = new ByteString(s.getBytes(Util.UTF_8));
-    byteString.utf8 = s;
-    return byteString;
-  }
-
-  /** Constructs a new {@code String} by decoding the bytes as {@code UTF-8}. */
-  public String utf8() {
-    String result = utf8;
-    // We don't care if we double-allocate in racy code.
-    return result != null ? result : (utf8 = new String(data, Util.UTF_8));
-  }
-
-  /**
-   * Returns true when {@code ascii} is not null and equals the bytes wrapped
-   * by this byte string.
-   */
-  public boolean equalsAscii(String ascii) {
-    if (ascii == null || data.length != ascii.length()) {
-      return false;
-    }
-    if (ascii == this.utf8) {
-      return true;
-    }
-    for (int i = 0; i < data.length; i++) {
-      if (data[i] != ascii.charAt(i)) return false;
-    }
-    return true;
-  }
-
-  /**
-   * Reads {@code count} bytes from {@code in} and returns the result.
-   *
-   * @throws java.io.EOFException if {@code in} has fewer than {@code count}
-   * bytes to read.
-   */
-  public static ByteString read(InputStream in, int count) throws IOException {
-    byte[] result = new byte[count];
-    Util.readFully(in, result);
-    return new ByteString(result);
-  }
-
-  /**
-   * Reads {@code count} bytes from {@code in} and returns the result converted
-   * to ASCII lowercase.
-   *
-   * @throws java.io.EOFException if {@code in} has fewer than {@code count}
-   * bytes to read.
-   */
-  public static ByteString readLowerCase(InputStream in, int count) throws IOException {
-    byte[] result = new byte[count];
-    Util.readFully(in, result);
-    asciiLowerCase(result);
-    return new ByteString(result);
-  }
-
-  public static ByteString concat(ByteString... byteStrings) {
-    int size = 0;
-    for (ByteString byteString : byteStrings) {
-      size += byteString.size();
-    }
-    byte[] result = new byte[size];
-    int pos = 0;
-    for (ByteString byteString : byteStrings) {
-      System.arraycopy(byteString.data, 0, result, pos, byteString.size());
-      pos += byteString.size();
-    }
-    return new ByteString(result);
-  }
-
-  private ByteString(byte[] data) {
-    this.data = data; // Trusted internal constructor doesn't clone data.
-  }
-
-  /**
-   * Returns the number of bytes in this ByteString.
-   */
-  public int size() {
-    return data.length;
-  }
-
-  /**
-   * Returns a byte array containing a copy of the bytes in this {@code ByteString}.
-   */
-  public byte[] toByteArray() {
-    return data.clone();
-  }
-
-  /** Writes the contents of this byte string to {@code out}. */
-  public void write(OutputStream out) throws IOException {
-    out.write(data);
-  }
-
-  @Override public boolean equals(Object o) {
-    return o == this || o instanceof ByteString && Arrays.equals(((ByteString) o).data, data);
-  }
-
-  @Override public int hashCode() {
-    int result = hashCode;
-    return result != 0 ? result : (hashCode = Arrays.hashCode(data));
-  }
-}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ByteArrayPool.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ByteArrayPool.java
deleted file mode 100644
index 5961172e1f..0000000000
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ByteArrayPool.java
+++ /dev/null
@@ -1,133 +0,0 @@
-  /*
-   * Copyright (C) 2012 The Android Open Source Project
-   *
-   * Licensed under the Apache License, Version 2.0 (the "License");
-   * you may not use this file except in compliance with the License.
-   * You may obtain a copy of the License at
-   *
-   *      http://www.apache.org/licenses/LICENSE-2.0
-   *
-   * Unless required by applicable law or agreed to in writing, software
-   * distributed under the License is distributed on an "AS IS" BASIS,
-   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   * See the License for the specific language governing permissions and
-   * limitations under the License.
-   */
-
-  package com.squareup.okhttp.internal.spdy;
-
-  import java.util.ArrayList;
-  import java.util.Collections;
-  import java.util.Comparator;
-  import java.util.List;
-
-  /**
-   * ByteArrayPool is a source and repository of <code>byte[]</code> objects. Its purpose is to
-   * supply those buffers to consumers who need to use them for a short period of time and then
-   * dispose of them. Simply creating and disposing such buffers in the conventional manner can
-   * considerable heap churn and garbage collection delays on Android, which lacks good management
-   * of short-lived heap objects. It may be advantageous to trade off some memory in the form of a
-   * permanently allocated pool of buffers in order to gain heap performance improvements; that is
-   * what this class does.
-   * <p>
-   * A good candidate user for this class is something like an I/O system that uses large temporary
-   * <code>byte[]</code> buffers to copy data around. In these use cases, often the consumer wants
-   * the buffer to be a certain minimum size to ensure good performance (e.g. when copying data
-   * chunks off of a stream), but doesn't mind if the buffer is larger than the minimum. Taking this
-   * into account and also to maximize the odds of being able to reuse a recycled buffer, this
-   * class is free to return buffers larger than the requested size. The caller needs to be able
-   * to gracefully deal with getting buffers any size over the minimum.
-   * <p>
-   * If there is not a suitably-sized buffer in its recycling pool when a buffer is requested, this
-   * class will allocate a new buffer and return it.
-   * <p>
-   * This class has no special ownership of buffers it creates; the caller is free to take a buffer
-   * it receives from this pool, use it permanently, and never return it to the pool; additionally,
-   * it is not harmful to return to this pool a buffer that was allocated elsewhere, provided there
-   * are no other lingering references to it.
-   * <p>
-   * This class ensures that the total size of the buffers in its recycling pool never exceeds a
-   * certain byte limit. When a buffer is returned that would cause the pool to exceed the limit,
-   * least-recently-used buffers are disposed.
-   */
-  public class ByteArrayPool {
-    /** The buffer pool, arranged both by last use and by buffer size. */
-    private List<byte[]> mBuffersByLastUse = new ArrayList<byte[]>();
-    private List<byte[]> mBuffersBySize = new ArrayList<byte[]>(64);
-
-    /** The total size of the buffers in the pool. */
-    private int mCurrentSize = 0;
-
-    /**
-     * The maximum aggregate size of the buffers in the pool. Old buffers are discarded to stay
-     * under this limit.
-     */
-    private final int mSizeLimit;
-
-    /** Compares buffers by size. */
-    protected static final Comparator<byte[]> BUF_COMPARATOR = new Comparator<byte[]>() {
-      @Override
-      public int compare(byte[] lhs, byte[] rhs) {
-        return lhs.length - rhs.length;
-      }
-    };
-
-    /**
-     * @param sizeLimit the maximum size of the pool, in bytes
-     */
-    public ByteArrayPool(int sizeLimit) {
-      mSizeLimit = sizeLimit;
-    }
-
-    /**
-     * Returns a buffer from the pool if one is available in the requested size, or
-     * allocates a new one if a pooled one is not available.
-     *
-     * @param len the minimum size, in bytes, of the requested buffer. The returned buffer may be
-     * larger.
-     * @return a byte[] buffer is always returned.
-     */
-    public synchronized byte[] getBuf(int len) {
-      for (int i = 0; i < mBuffersBySize.size(); i++) {
-        byte[] buf = mBuffersBySize.get(i);
-        if (buf.length >= len) {
-          mCurrentSize -= buf.length;
-          mBuffersBySize.remove(i);
-          mBuffersByLastUse.remove(buf);
-          return buf;
-        }
-      }
-      return new byte[len];
-    }
-
-    /**
-     * Returns a buffer to the pool, throwing away old buffers if the pool would exceed its
-     * allotted size.
-     *
-     * @param buf the buffer to return to the pool.
-     */
-    public synchronized void returnBuf(byte[] buf) {
-      if (buf == null || buf.length > mSizeLimit) {
-        return;
-      }
-      mBuffersByLastUse.add(buf);
-      int pos = Collections.binarySearch(mBuffersBySize, buf, BUF_COMPARATOR);
-      if (pos < 0) {
-        pos = -pos - 1;
-      }
-      mBuffersBySize.add(pos, buf);
-      mCurrentSize += buf.length;
-      trim();
-    }
-
-    /**
-     * Removes buffers from the pool until it is under its size limit.
-     */
-    private synchronized void trim() {
-      while (mCurrentSize > mSizeLimit) {
-        byte[] buf = mBuffersByLastUse.remove(0);
-        mBuffersBySize.remove(buf);
-        mCurrentSize -= buf.length;
-      }
-    }
-  }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java b/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
deleted file mode 100644
index 9c72eb5eb5..0000000000
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
+++ /dev/null
@@ -1,112 +0,0 @@
-package com.squareup.okhttp.internal.spdy;
-
-import com.squareup.okhttp.internal.ByteString;
-import com.squareup.okhttp.internal.Util;
-import java.io.Closeable;
-import java.io.DataInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.zip.DataFormatException;
-import java.util.zip.Inflater;
-import java.util.zip.InflaterInputStream;
-
-/**
- * Reads a SPDY/3 Name/Value header block. This class is made complicated by the
- * requirement that we're strict with which bytes we put in the compressed bytes
- * buffer. We need to put all compressed bytes into that buffer -- but no other
- * bytes.
- */
-class NameValueBlockReader implements Closeable {
-  private final DataInputStream headerBlockIn;
-  private final FillableInflaterInputStream fillableInflaterInputStream;
-  private int compressedLimit;
-
-  NameValueBlockReader(final InputStream in) {
-    // Limit the inflater input stream to only those bytes in the Name/Value block. We cut the
-    // inflater off at its source because we can't predict the ratio of compressed bytes to
-    // uncompressed bytes.
-    InputStream throttleStream = new InputStream() {
-      @Override public int read() throws IOException {
-        return Util.readSingleByte(this);
-      }
-
-      @Override public int read(byte[] buffer, int offset, int byteCount) throws IOException {
-        byteCount = Math.min(byteCount, compressedLimit);
-        int consumed = in.read(buffer, offset, byteCount);
-        compressedLimit -= consumed;
-        return consumed;
-      }
-
-      @Override public void close() throws IOException {
-        in.close();
-      }
-    };
-
-    // Subclass inflater to install a dictionary when it's needed.
-    Inflater inflater = new Inflater() {
-      @Override public int inflate(byte[] buffer, int offset, int count)
-          throws DataFormatException {
-        int result = super.inflate(buffer, offset, count);
-        if (result == 0 && needsDictionary()) {
-          setDictionary(Spdy3.DICTIONARY);
-          result = super.inflate(buffer, offset, count);
-        }
-        return result;
-      }
-    };
-
-    fillableInflaterInputStream = new FillableInflaterInputStream(throttleStream, inflater);
-    headerBlockIn = new DataInputStream(fillableInflaterInputStream);
-  }
-
-  /** Extend the inflater stream so we can eagerly fill the compressed bytes buffer if necessary. */
-  static class FillableInflaterInputStream extends InflaterInputStream {
-    public FillableInflaterInputStream(InputStream in, Inflater inf) {
-      super(in, inf);
-    }
-
-    @Override public void fill() throws IOException {
-      super.fill(); // This method is protected in the superclass.
-    }
-  }
-
-  public List<Header> readNameValueBlock(int length) throws IOException {
-    this.compressedLimit += length;
-    int numberOfPairs = headerBlockIn.readInt();
-    if (numberOfPairs < 0) {
-      throw new IOException("numberOfPairs < 0: " + numberOfPairs);
-    }
-    if (numberOfPairs > 1024) {
-      throw new IOException("numberOfPairs > 1024: " + numberOfPairs);
-    }
-    List<Header> entries = new ArrayList<Header>(numberOfPairs);
-    for (int i = 0; i < numberOfPairs; i++) {
-      ByteString name = ByteString.readLowerCase(headerBlockIn, headerBlockIn.readInt());
-      ByteString values = ByteString.read(headerBlockIn, headerBlockIn.readInt());
-      if (name.size() == 0) throw new IOException("name.size == 0");
-      entries.add(new Header(name, values));
-    }
-
-    doneReading();
-
-    return entries;
-  }
-
-  private void doneReading() throws IOException {
-    if (compressedLimit == 0) return;
-
-    // Read any outstanding unread bytes. One side-effect of deflate compression is that sometimes
-    // there are bytes remaining in the stream after we've consumed all of the content.
-    fillableInflaterInputStream.fill();
-
-    if (compressedLimit != 0) {
-      throw new IOException("compressedLimit > 0: " + compressedLimit);
-    }
-  }
-
-  @Override public void close() throws IOException {
-    headerBlockIn.close();
-  }
-}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java
deleted file mode 100644
index bf8101caf6..0000000000
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/ByteStringTest.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright 2014 Square Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.InputStream;
-import java.util.Arrays;
-import org.junit.Test;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-public class ByteStringTest {
-
-  @Test public void equals() throws Exception {
-    ByteString byteString = ByteString.of((byte) 0x0, (byte) 0x1, (byte) 0x2);
-    assertTrue(byteString.equals(byteString));
-    assertTrue(byteString.equals(ByteString.of((byte) 0x0, (byte) 0x1, (byte) 0x2)));
-    assertTrue(ByteString.of().equals(ByteString.EMPTY));
-    assertTrue(ByteString.EMPTY.equals(ByteString.of()));
-    assertFalse(byteString.equals(new Object()));
-    assertFalse(byteString.equals(ByteString.of((byte) 0x0, (byte) 0x2, (byte) 0x1)));
-  }
-
-  private final String bronzeHorseman = "   ";
-
-  @Test public void utf8() throws Exception {
-    ByteString byteString = ByteString.encodeUtf8(bronzeHorseman);
-    assertByteArraysEquals(byteString.toByteArray(), bronzeHorseman.getBytes(Util.UTF_8));
-    assertTrue(byteString.equals(ByteString.of(bronzeHorseman.getBytes(Util.UTF_8))));
-    assertEquals(byteString.utf8(), bronzeHorseman);
-  }
-
-  @Test public void equalsAscii() throws Exception {
-    ByteString byteString = ByteString.encodeUtf8("Content-Length");
-    assertTrue(byteString.equalsAscii("Content-Length"));
-    assertFalse(byteString.equalsAscii("content-length"));
-    assertFalse(ByteString.of((byte) 0x63).equalsAscii(null));
-    assertFalse(byteString.equalsAscii(bronzeHorseman));
-    assertFalse(ByteString.encodeUtf8("Content-Length").equalsAscii("content-length"));
-  }
-
-  @Test public void testHashCode() throws Exception {
-    ByteString byteString = ByteString.of((byte) 0x1, (byte) 0x2);
-    assertEquals(byteString.hashCode(), byteString.hashCode());
-    assertEquals(byteString.hashCode(), ByteString.of((byte) 0x1, (byte) 0x2).hashCode());
-  }
-
-  @Test public void read() throws Exception {
-    InputStream in = new ByteArrayInputStream("abc".getBytes(Util.UTF_8));
-    assertEquals(ByteString.of((byte) 0x61, (byte) 0x62), ByteString.read(in, 2));
-    assertEquals(ByteString.of((byte) 0x63), ByteString.read(in, 1));
-    assertEquals(ByteString.of(), ByteString.read(in, 0));
-  }
-
-  @Test public void readLowerCase() throws Exception {
-    InputStream in = new ByteArrayInputStream("ABC".getBytes(Util.UTF_8));
-    assertEquals(ByteString.of((byte) 0x61, (byte) 0x62), ByteString.readLowerCase(in, 2));
-    assertEquals(ByteString.of((byte) 0x63), ByteString.readLowerCase(in, 1));
-    assertEquals(ByteString.of(), ByteString.readLowerCase(in, 0));
-  }
-
-  @Test public void write() throws Exception {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    ByteString.of((byte) 0x61, (byte) 0x62, (byte) 0x63).write(out);
-    assertByteArraysEquals(new byte[] { 0x61, 0x62, 0x63 }, out.toByteArray());
-  }
-
-  @Test public void concat() {
-    assertEquals(ByteString.of(), ByteString.concat());
-    assertEquals(ByteString.of(), ByteString.concat(ByteString.EMPTY));
-    assertEquals(ByteString.of(), ByteString.concat(ByteString.EMPTY, ByteString.EMPTY));
-    ByteString foo = ByteString.encodeUtf8("foo");
-    ByteString bar = ByteString.encodeUtf8("bar");
-    assertEquals(foo, ByteString.concat(foo));
-    assertEquals(ByteString.encodeUtf8("foobar"), ByteString.concat(foo, bar));
-  }
-
-  private static void assertByteArraysEquals(byte[] a, byte[] b) {
-    assertEquals(Arrays.toString(a), Arrays.toString(b));
-  }
-}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ByteArrayPoolTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ByteArrayPoolTest.java
deleted file mode 100644
index 30132d5c2d..0000000000
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ByteArrayPoolTest.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.spdy;
-
-import org.junit.Test;
-
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertSame;
-import static org.junit.Assert.assertTrue;
-
-public class ByteArrayPoolTest {
-  @Test public void testReusesBuffer() {
-    ByteArrayPool pool = new ByteArrayPool(32);
-
-    byte[] buf1 = pool.getBuf(16);
-    byte[] buf2 = pool.getBuf(16);
-
-    pool.returnBuf(buf1);
-    pool.returnBuf(buf2);
-
-    byte[] buf3 = pool.getBuf(16);
-    byte[] buf4 = pool.getBuf(16);
-    assertTrue(buf3 == buf1 || buf3 == buf2);
-    assertTrue(buf4 == buf1 || buf4 == buf2);
-    assertTrue(buf3 != buf4);
-  }
-
-  @Test public void testObeysSizeLimit() {
-    ByteArrayPool pool = new ByteArrayPool(32);
-
-    byte[] buf1 = pool.getBuf(16);
-    byte[] buf2 = pool.getBuf(16);
-    byte[] buf3 = pool.getBuf(16);
-
-    pool.returnBuf(buf1);
-    pool.returnBuf(buf2);
-    pool.returnBuf(buf3);
-
-    byte[] buf4 = pool.getBuf(16);
-    byte[] buf5 = pool.getBuf(16);
-    byte[] buf6 = pool.getBuf(16);
-
-    assertTrue(buf4 == buf2 || buf4 == buf3);
-    assertTrue(buf5 == buf2 || buf5 == buf3);
-    assertTrue(buf4 != buf5);
-    assertTrue(buf6 != buf1 && buf6 != buf2 && buf6 != buf3);
-  }
-
-  @Test public void testReturnsBufferWithRightSize() {
-    ByteArrayPool pool = new ByteArrayPool(32);
-
-    byte[] buf1 = pool.getBuf(16);
-    pool.returnBuf(buf1);
-
-    byte[] buf2 = pool.getBuf(17);
-    assertNotSame(buf2, buf1);
-
-    byte[] buf3 = pool.getBuf(15);
-    assertSame(buf3, buf1);
-  }
-}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ContinuationInputStreamTest.java b/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ContinuationInputStreamTest.java
deleted file mode 100644
index 67b53223de..0000000000
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/ContinuationInputStreamTest.java
+++ /dev/null
@@ -1,165 +0,0 @@
-/*
- * Copyright (C) 2014 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.spdy;
-
-import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.EOFException;
-import java.io.IOException;
-import java.util.Arrays;
-import org.junit.Test;
-
-import static com.squareup.okhttp.internal.spdy.HpackDraft05Test.MutableByteArrayInputStream;
-import static com.squareup.okhttp.internal.spdy.Http20Draft09.ContinuationInputStream;
-import static com.squareup.okhttp.internal.spdy.Http20Draft09.FLAG_END_STREAM;
-import static com.squareup.okhttp.internal.spdy.Http20Draft09.TYPE_DATA;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class ContinuationInputStreamTest {
-  private final MutableByteArrayInputStream bytesIn = new MutableByteArrayInputStream();
-  private final ContinuationInputStream continuation =
-      new ContinuationInputStream(new DataInputStream(bytesIn));
-
-  @Test public void readCantOverrunHeaderPayload() throws IOException {
-    bytesIn.set(onlyHeadersPayloadFollowedByData());
-
-    continuation.length = continuation.left = 3;
-    continuation.flags = Http20Draft09.FLAG_END_HEADERS;
-    continuation.streamId = 12345;
-
-    assertEquals(1, continuation.read());
-    assertEquals(2, continuation.read());
-    assertEquals(3, continuation.read());
-
-    try {
-      continuation.read();
-      fail();
-    } catch (EOFException expected) {
-    }
-  }
-
-  @Test public void readCantOverrunHeaderContinuationPayload() throws IOException {
-    bytesIn.set(headersPayloadWithContinuationFollowedByData());
-
-    continuation.length = continuation.left = 2;
-    continuation.flags = Http20Draft09.FLAG_NONE;
-    continuation.streamId = 12345;
-
-    assertEquals(1, continuation.read());
-    assertEquals(2, continuation.read());
-    assertEquals(3, continuation.read());
-    assertEquals(0, continuation.available());
-
-    try {
-      continuation.read();
-      fail();
-    } catch (EOFException expected) {
-    }
-  }
-
-  @Test public void availableWithContinuation() throws IOException {
-    bytesIn.set(headersPayloadWithContinuationFollowedByData());
-
-    continuation.length = continuation.left = 2;
-    continuation.flags = Http20Draft09.FLAG_NONE;
-    continuation.streamId = 12345;
-
-    assertEquals(1, continuation.read());
-    assertEquals(2, continuation.read()); // exhaust frame one
-
-    assertEquals(0, continuation.left);
-    assertEquals(1, continuation.available()); // lazy reads next
-
-    assertEquals(1, continuation.length);
-    assertEquals(1, continuation.left);
-    assertEquals(3, continuation.read());
-
-    assertEquals(0, continuation.available());
-    assertEquals(0, continuation.left);
-
-    try {
-      continuation.read();
-      fail();
-    } catch (EOFException expected) {
-    }
-  }
-
-  @Test public void readArrayCantOverrunHeaderPayload() throws IOException {
-    bytesIn.set(onlyHeadersPayloadFollowedByData());
-
-    continuation.length = continuation.left = 3;
-    continuation.flags = Http20Draft09.FLAG_END_HEADERS;
-    continuation.streamId = 12345;
-
-    byte[] buff = new byte[3];
-    assertEquals(3, continuation.read(buff));
-    assertTrue(Arrays.equals(buff, new byte[] {1, 2, 3}));
-
-    try {
-      continuation.read(buff);
-      fail();
-    } catch (EOFException expected) {
-    }
-  }
-
-  @Test public void readArrayCantOverrunHeaderContinuationPayload() throws IOException {
-    bytesIn.set(headersPayloadWithContinuationFollowedByData());
-
-    continuation.length = continuation.left = 2;
-    continuation.flags = Http20Draft09.FLAG_NONE;
-    continuation.streamId = 12345;
-
-    byte[] buff = new byte[3];
-    assertEquals(3, continuation.read(buff));
-    assertTrue(Arrays.equals(buff, new byte[] {1, 2, 3}));
-
-    try {
-      continuation.read(buff);
-      fail();
-    } catch (EOFException expected) {
-    }
-  }
-
-  static byte[] onlyHeadersPayloadFollowedByData() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
-    dataOut.write(new byte[] {1, 2, 3});
-    dataOut.writeShort(0);
-    dataOut.write(TYPE_DATA);
-    dataOut.write(FLAG_END_STREAM);
-    dataOut.writeInt(0xFFFFFFFF);
-    return out.toByteArray();
-  }
-
-  static byte[] headersPayloadWithContinuationFollowedByData() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
-    dataOut.write(new byte[] {1, 2});
-    dataOut.writeShort(1);
-    dataOut.write(Http20Draft09.TYPE_CONTINUATION);
-    dataOut.write(Http20Draft09.FLAG_END_HEADERS);
-    dataOut.writeInt(12345);
-    dataOut.write(3);
-    dataOut.writeShort(0);
-    dataOut.write(TYPE_DATA);
-    dataOut.write(FLAG_END_STREAM);
-    dataOut.writeInt(0xFFFFFFFF);
-    return out.toByteArray();
-  }
-}
diff --git a/okhttp-tests/pom.xml b/okhttp-tests/pom.xml
new file mode 100644
index 0000000000..7c1573df01
--- /dev/null
+++ b/okhttp-tests/pom.xml
@@ -0,0 +1,44 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp</groupId>
+    <artifactId>parent</artifactId>
+    <version>2.0.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>okhttp-tests</artifactId>
+  <name>OkHttp Tests</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okio</groupId>
+      <artifactId>okio</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.mortbay.jetty.npn</groupId>
+      <artifactId>npn-boot</artifactId>
+      <scope>provided</scope>
+    </dependency>
+
+    <dependency>
+      <groupId>junit</groupId>
+      <artifactId>junit</artifactId>
+      <scope>test</scope>
+    </dependency>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>mockwebserver</artifactId>
+      <version>${project.version}</version>
+      <scope>test</scope>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/AsyncApiTest.java
similarity index 93%
rename from okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/AsyncApiTest.java
index a3dcf5c332..bd9ed97954 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/AsyncApiTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/AsyncApiTest.java
@@ -152,9 +152,11 @@
     assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
   }
 
-  @Test public void cache() throws Exception {
+  @Test public void conditionalCacheHit() throws Exception {
     server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
-    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
     server.play();
 
     client.setOkResponseCache(cache);
@@ -174,6 +176,28 @@
     assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
   }
 
+  @Test public void conditionalCacheMiss() throws Exception {
+    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
+    server.enqueue(new MockResponse().setBody("B"));
+    server.play();
+
+    client.setOkResponseCache(cache);
+
+    Request request1 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.enqueue(request1, receiver);
+    receiver.await(request1.url()).assertCode(200).assertBody("A");
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    Request request2 = new Request.Builder()
+        .url(server.getUrl("/"))
+        .build();
+    client.enqueue(request2, receiver);
+    receiver.await(request2.url()).assertCode(200).assertBody("B");
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+  }
+
   @Test public void redirect() throws Exception {
     server.enqueue(new MockResponse()
         .setResponseCode(301)
diff --git a/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
similarity index 89%
rename from okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
index c02be45cfd..f25e5a2bdb 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/ConnectionPoolTest.java
@@ -35,6 +35,7 @@
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
 public final class ConnectionPoolTest {
   private static final int KEEP_ALIVE_DURATION_MS = 5000;
@@ -54,7 +55,6 @@
   private Connection httpD;
   private Connection httpE;
   private Connection spdyA;
-  private Connection spdyB;
 
   @Before public void setUp() throws Exception {
     spdyServer.useHttps(sslContext.getSocketFactory(), false);
@@ -74,20 +74,18 @@
 
     Route httpRoute = new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress, true);
     Route spdyRoute = new Route(spdyAddress, Proxy.NO_PROXY, spdySocketAddress, true);
-    httpA = new Connection(httpRoute);
-    httpA.connect(100, 100, null);
-    httpB = new Connection(httpRoute);
-    httpB.connect(100, 100, null);
-    httpC = new Connection(httpRoute);
-    httpC.connect(100, 100, null);
-    httpD = new Connection(httpRoute);
-    httpD.connect(100, 100, null);
-    httpE = new Connection(httpRoute);
-    httpE.connect(100, 100, null);
-    spdyA = new Connection(spdyRoute);
-    spdyA.connect(100, 100, null);
-    spdyB = new Connection(spdyRoute);
-    spdyB.connect(100, 100, null);
+    httpA = new Connection(null, httpRoute);
+    httpA.connect(200, 200, null);
+    httpB = new Connection(null, httpRoute);
+    httpB.connect(200, 200, null);
+    httpC = new Connection(null, httpRoute);
+    httpC.connect(200, 200, null);
+    httpD = new Connection(null, httpRoute);
+    httpD.connect(200, 200, null);
+    httpE = new Connection(null, httpRoute);
+    httpE.connect(200, 200, null);
+    spdyA = new Connection(null, spdyRoute);
+    spdyA.connect(20000, 20000, null);
   }
 
   @After public void tearDown() throws Exception {
@@ -100,7 +98,6 @@
     Util.closeQuietly(httpD);
     Util.closeQuietly(httpE);
     Util.closeQuietly(spdyA);
-    Util.closeQuietly(spdyB);
   }
 
   @Test public void poolSingleHttpConnection() throws IOException {
@@ -108,8 +105,9 @@
     Connection connection = pool.get(httpAddress);
     assertNull(connection);
 
-    connection = new Connection(new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress, true));
-    connection.connect(100, 100, null);
+    connection = new Connection(
+        null, new Route(httpAddress, Proxy.NO_PROXY, httpSocketAddress, true));
+    connection.connect(200, 200, null);
     assertEquals(0, pool.getConnectionCount());
     pool.recycle(connection);
     assertEquals(1, pool.getConnectionCount());
@@ -134,7 +132,7 @@
 
   @Test public void getSpdyConnection() throws Exception {
     ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.maybeShare(spdyA);
+    pool.share(spdyA);
     assertSame(spdyA, pool.get(spdyAddress));
     assertPooled(pool, spdyA);
   }
@@ -189,7 +187,7 @@
 
   @Test public void gettingSpdyConnectionPromotesItToFrontOfQueue() throws Exception {
     ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.maybeShare(spdyA);
+    pool.share(spdyA);
     pool.recycle(httpA);
     assertPooled(pool, httpA, spdyA);
     assertSame(spdyA, pool.get(spdyAddress));
@@ -210,9 +208,13 @@
     assertTrue(httpA.getSocket().isClosed());
   }
 
-  @Test public void shareHttpConnectionDoesNothing() throws Exception {
+  @Test public void shareHttpConnectionFails() throws Exception {
     ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.maybeShare(httpA);
+    try {
+      pool.share(httpA);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
     assertPooled(pool);
   }
 
@@ -224,7 +226,7 @@
 
   @Test public void validateIdleSpdyConnectionTimeout() throws Exception {
     ConnectionPool pool = new ConnectionPool(2, KEEP_ALIVE_DURATION_MS);
-    pool.maybeShare(spdyA);
+    pool.share(spdyA);
     Thread.sleep((int) (KEEP_ALIVE_DURATION_MS * 0.7));
     assertNull(pool.get(httpAddress));
     assertPooled(pool, spdyA); // Connection should still be in the pool.
@@ -270,7 +272,7 @@
     assertEquals(0, pool.getSpdyConnectionCount());
 
     // spdy A should be added and http B should be removed.
-    pool.maybeShare(spdyA);
+    pool.share(spdyA);
     Thread.sleep(50);
     assertEquals(2, pool.getConnectionCount());
     assertEquals(1, pool.getHttpConnectionCount());
@@ -299,13 +301,6 @@
     assertEquals(1, pool.getHttpConnectionCount());
     assertEquals(1, pool.getSpdyConnectionCount());
 
-    // Nothing should change.
-    pool.maybeShare(spdyB);
-    Thread.sleep(50);
-    assertEquals(2, pool.getConnectionCount());
-    assertEquals(1, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
     // An http connection should be removed from the pool.
     recycledHttpConnection = pool.get(httpAddress);
     assertNotNull(recycledHttpConnection);
@@ -314,13 +309,6 @@
     assertEquals(0, pool.getHttpConnectionCount());
     assertEquals(1, pool.getSpdyConnectionCount());
 
-    // Shouldn't change numbers because spdyConnections A and B user the same server address.
-    pool.maybeShare(spdyB);
-    Thread.sleep(50);
-    assertEquals(1, pool.getConnectionCount());
-    assertEquals(0, pool.getHttpConnectionCount());
-    assertEquals(1, pool.getSpdyConnectionCount());
-
     // spdy A will be returned and kept in the pool. Pool shouldn't change.
     sharedSpdyConnection = pool.get(spdyAddress);
     assertEquals(spdyA, sharedSpdyConnection);
@@ -350,7 +338,7 @@
     // Add 3 connections to the pool.
     pool.recycle(httpA);
     pool.recycle(httpB);
-    pool.maybeShare(spdyA);
+    pool.share(spdyA);
     assertEquals(3, pool.getConnectionCount());
     assertEquals(2, pool.getHttpConnectionCount());
     assertEquals(1, pool.getSpdyConnectionCount());
@@ -383,7 +371,7 @@
     pool.recycle(httpA);
     Util.closeQuietly(httpA); // Include a closed connection in the pool.
     pool.recycle(httpB);
-    pool.maybeShare(spdyA);
+    pool.share(spdyA);
     int connectionCount = pool.getConnectionCount();
     assertTrue(connectionCount == 2 || connectionCount == 3);
 
diff --git a/okhttp/src/test/java/com/squareup/okhttp/DispatcherTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
similarity index 88%
rename from okhttp/src/test/java/com/squareup/okhttp/DispatcherTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
index 034ed84b64..a42362fbff 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/DispatcherTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/DispatcherTest.java
@@ -4,7 +4,8 @@
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
-import java.util.concurrent.Executor;
+import java.util.concurrent.AbstractExecutorService;
+import java.util.concurrent.TimeUnit;
 import org.junit.Before;
 import org.junit.Test;
 
@@ -129,7 +130,7 @@
     executor.assertJobs("http://a/2");
   }
 
-  class RecordingExecutor implements Executor {
+  class RecordingExecutor extends AbstractExecutorService {
     private List<Job> jobs = new ArrayList<Job>();
 
     @Override public void execute(Runnable command) {
@@ -155,6 +156,27 @@ public void finishJob(String url) {
       }
       throw new AssertionError("No such job: " + url);
     }
+
+    @Override public void shutdown() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public List<Runnable> shutdownNow() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public boolean isShutdown() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public boolean isTerminated() {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public boolean awaitTermination(long timeout, TimeUnit unit)
+        throws InterruptedException {
+      throw new UnsupportedOperationException();
+    }
   }
 
   private Request newRequest(String url) {
diff --git a/okhttp/src/test/java/com/squareup/okhttp/MediaTypeTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/MediaTypeTest.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/MediaTypeTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/MediaTypeTest.java
diff --git a/okhttp/src/test/java/com/squareup/okhttp/RecordedResponse.java b/okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/RecordedResponse.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/RecordedResponse.java
diff --git a/okhttp/src/test/java/com/squareup/okhttp/RecordingReceiver.java b/okhttp-tests/src/test/java/com/squareup/okhttp/RecordingReceiver.java
similarity index 94%
rename from okhttp/src/test/java/com/squareup/okhttp/RecordingReceiver.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/RecordingReceiver.java
index f5b54eede0..9bc8475998 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/RecordingReceiver.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/RecordingReceiver.java
@@ -19,6 +19,7 @@
 import java.io.IOException;
 import java.net.URL;
 import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
@@ -73,8 +74,10 @@
   public synchronized RecordedResponse await(URL url) throws Exception {
     long timeoutMillis = TimeUnit.NANOSECONDS.toMillis(System.nanoTime()) + TIMEOUT_MILLIS;
     while (true) {
-      for (RecordedResponse recordedResponse : responses) {
+      for (Iterator<RecordedResponse> i = responses.iterator(); i.hasNext(); ) {
+        RecordedResponse recordedResponse = i.next();
         if (recordedResponse.request.url().equals(url)) {
+          i.remove();
           return recordedResponse;
         }
       }
diff --git a/okhttp/src/test/java/com/squareup/okhttp/RequestTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java
similarity index 87%
rename from okhttp/src/test/java/com/squareup/okhttp/RequestTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java
index ed43e194a7..08f304e3a4 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/RequestTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/RequestTest.java
@@ -16,10 +16,10 @@
 package com.squareup.okhttp;
 
 import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
+import okio.OkBuffer;
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
@@ -74,17 +74,8 @@
   }
 
   private String bodyToHex(Request.Body body) throws IOException {
-    ByteArrayOutputStream bytes = new ByteArrayOutputStream();
-    body.writeTo(bytes);
-    return bytesToHex(bytes.toByteArray());
-  }
-
-  private String bytesToHex(byte[] bytes) {
-    StringBuilder hex = new StringBuilder();
-    for (byte b : bytes) {
-      if ((b & 0xff) < 0x10) hex.append('0');
-      hex.append(Integer.toHexString(b & 0xff));
-    }
-    return hex.toString();
+    OkBuffer buffer = new OkBuffer();
+    body.writeTo(buffer);
+    return buffer.readByteString(buffer.size()).hex();
   }
 }
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/SyncApiTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/SyncApiTest.java
new file mode 100644
index 0000000000..1153299c6b
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/SyncApiTest.java
@@ -0,0 +1,286 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp;
+
+import com.squareup.okhttp.internal.RecordingHostnameVerifier;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import com.squareup.okhttp.mockwebserver.SocketPolicy;
+import java.io.File;
+import java.io.IOException;
+import java.net.HttpURLConnection;
+import java.util.UUID;
+import javax.net.ssl.SSLContext;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class SyncApiTest {
+  private MockWebServer server = new MockWebServer();
+  private OkHttpClient client = new OkHttpClient();
+
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
+  private HttpResponseCache cache;
+
+  @Before public void setUp() throws Exception {
+    String tmp = System.getProperty("java.io.tmpdir");
+    File cacheDir = new File(tmp, "HttpCache-" + UUID.randomUUID());
+    cache = new HttpResponseCache(cacheDir, Integer.MAX_VALUE);
+  }
+
+  @After public void tearDown() throws Exception {
+    server.shutdown();
+    cache.delete();
+  }
+
+  @Test public void get() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .header("User-Agent", "SyncApiTest")
+        .build();
+
+    onSuccess(request)
+        .assertCode(200)
+        .assertContainsHeaders("Content-Type: text/plain")
+        .assertBody("abc");
+
+    assertTrue(server.takeRequest().getHeaders().contains("User-Agent: SyncApiTest"));
+  }
+
+  @Test public void connectionPooling() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.enqueue(new MockResponse().setBody("ghi"));
+    server.play();
+
+    onSuccess(new Request.Builder().url(server.getUrl("/a")).build())
+        .assertBody("abc");
+
+    onSuccess(new Request.Builder().url(server.getUrl("/b")).build())
+        .assertBody("def");
+
+    onSuccess(new Request.Builder().url(server.getUrl("/c")).build())
+        .assertBody("ghi");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
+  @Test public void tls() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .addHeader("Content-Type: text/plain"));
+    server.play();
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    onSuccess(new Request.Builder().url(server.getUrl("/")).build())
+        .assertHandshake();
+  }
+
+  @Test public void recoverFromTlsHandshakeFailure() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.FAIL_HANDSHAKE));
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.play();
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    onSuccess(new Request.Builder().url(server.getUrl("/")).build())
+        .assertBody("abc");
+  }
+
+  @Test public void post() throws Exception {
+    server.enqueue(new MockResponse().setBody("abc"));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .post(Request.Body.create(MediaType.parse("text/plain"), "def"))
+        .build();
+
+    onSuccess(request)
+        .assertCode(200)
+        .assertBody("abc");
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    assertEquals("def", recordedRequest.getUtf8Body());
+    assertEquals("3", recordedRequest.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", recordedRequest.getHeader("Content-Type"));
+  }
+
+  @Test public void conditionalCacheHit() throws Exception {
+    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.play();
+
+    client.setOkResponseCache(cache);
+
+    onSuccess(new Request.Builder().url(server.getUrl("/")).build())
+        .assertCode(200).assertBody("A");
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    onSuccess(new Request.Builder().url(server.getUrl("/")).build())
+        .assertCode(200).assertBody("A");
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+  }
+
+  @Test public void conditionalCacheMiss() throws Exception {
+    server.enqueue(new MockResponse().setBody("A").addHeader("ETag: v1"));
+    server.enqueue(new MockResponse().setBody("B"));
+    server.play();
+
+    client.setOkResponseCache(cache);
+
+    onSuccess(new Request.Builder().url(server.getUrl("/")).build())
+        .assertCode(200).assertBody("A");
+    assertNull(server.takeRequest().getHeader("If-None-Match"));
+
+    onSuccess(new Request.Builder().url(server.getUrl("/")).build())
+        .assertCode(200).assertBody("B");
+    assertEquals("v1", server.takeRequest().getHeader("If-None-Match"));
+  }
+
+  @Test public void redirect() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: /b")
+        .addHeader("Test", "Redirect from /a to /b")
+        .setBody("/a has moved!"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /c")
+        .addHeader("Test", "Redirect from /b to /c")
+        .setBody("/b has moved!"));
+    server.enqueue(new MockResponse().setBody("C"));
+    server.play();
+
+    onSuccess(new Request.Builder().url(server.getUrl("/a")).build())
+        .assertCode(200)
+        .assertBody("C")
+        .redirectedBy()
+        .assertCode(302)
+        .assertContainsHeaders("Test: Redirect from /b to /c")
+        .redirectedBy()
+        .assertCode(301)
+        .assertContainsHeaders("Test: Redirect from /a to /b");
+
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // New connection.
+    assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection reused.
+    assertEquals(2, server.takeRequest().getSequenceNumber()); // Connection reused again!
+  }
+
+  @Test public void redirectWithRedirectsDisabled() throws Exception {
+    client.setFollowProtocolRedirects(false);
+    server.enqueue(new MockResponse()
+        .setResponseCode(301)
+        .addHeader("Location: /b")
+        .addHeader("Test", "Redirect from /a to /b")
+        .setBody("/a has moved!"));
+    server.play();
+
+    onSuccess(new Request.Builder().url(server.getUrl("/a")).build())
+        .assertCode(301)
+        .assertBody("/a has moved!")
+        .assertContainsHeaders("Location: /b");
+  }
+
+  @Test public void follow20Redirects() throws Exception {
+    for (int i = 0; i < 20; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(301)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+    server.enqueue(new MockResponse().setBody("Success!"));
+    server.play();
+
+    onSuccess(new Request.Builder().url(server.getUrl("/0")).build())
+        .assertCode(200)
+        .assertBody("Success!");
+  }
+
+  @Test public void doesNotFollow21Redirects() throws Exception {
+    for (int i = 0; i < 21; i++) {
+      server.enqueue(new MockResponse()
+          .setResponseCode(301)
+          .addHeader("Location: /" + (i + 1))
+          .setBody("Redirecting to /" + (i + 1)));
+    }
+    server.play();
+
+    try {
+      client.execute(new Request.Builder().url(server.getUrl("/0")).build());
+      fail();
+    } catch (IOException e) {
+      assertEquals("Too many redirects: 21", e.getMessage());
+    }
+  }
+
+  @Test public void postBodyRetransmittedOnRedirect() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(302)
+        .addHeader("Location: /b")
+        .setBody("Moved to /b !"));
+    server.enqueue(new MockResponse()
+        .setBody("This is b."));
+    server.play();
+
+    Request request = new Request.Builder()
+        .url(server.getUrl("/"))
+        .post(Request.Body.create(MediaType.parse("text/plain"), "body!"))
+        .build();
+
+    onSuccess(request)
+        .assertCode(200)
+        .assertBody("This is b.");
+
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("body!", request1.getUtf8Body());
+    assertEquals("5", request1.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", request1.getHeader("Content-Type"));
+    assertEquals(0, request1.getSequenceNumber());
+
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("body!", request2.getUtf8Body());
+    assertEquals("5", request2.getHeader("Content-Length"));
+    assertEquals("text/plain; charset=utf-8", request2.getHeader("Content-Type"));
+    assertEquals(1, request2.getSequenceNumber());
+  }
+
+  private RecordedResponse onSuccess(Request request) throws IOException {
+    Response response = client.execute(request);
+    return new RecordedResponse(request, response, response.body().string(), null);
+  }
+}
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/BitArrayTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/BitArrayTest.java
similarity index 100%
rename from okhttp-protocols/src/test/java/com/squareup/okhttp/internal/BitArrayTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/BitArrayTest.java
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingAuthenticator.java
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingHostnameVerifier.java
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/RecordingOkAuthenticator.java
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java
new file mode 100644
index 0000000000..a44e6839f8
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/CookiesTest.java
@@ -0,0 +1,351 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.net.CookieHandler;
+import java.net.CookieManager;
+import java.net.HttpCookie;
+import java.net.HttpURLConnection;
+import java.net.URI;
+import java.net.URLConnection;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import static java.net.CookiePolicy.ACCEPT_ORIGINAL_SERVER;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/** Android's CookiesTest. */
+public class CookiesTest {
+
+  private OkHttpClient client;
+
+  @Before
+  public void setUp() throws Exception {
+    client = new OkHttpClient();
+  }
+
+  @After
+  public void tearDown() throws Exception {
+    CookieHandler.setDefault(null);
+  }
+
+  @Test
+  public void testNetscapeResponse() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    CookieHandler.setDefault(cookieManager);
+    MockWebServer server = new MockWebServer();
+    server.play();
+
+    server.enqueue(new MockResponse().addHeader("Set-Cookie: a=android; "
+        + "expires=Fri, 31-Dec-9999 23:59:59 GMT; "
+        + "path=/path; "
+        + "domain=" + server.getCookieDomain() + "; "
+        + "secure"));
+    get(server, "/path/foo");
+
+    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
+    assertEquals(1, cookies.size());
+    HttpCookie cookie = cookies.get(0);
+    assertEquals("a", cookie.getName());
+    assertEquals("android", cookie.getValue());
+    assertEquals(null, cookie.getComment());
+    assertEquals(null, cookie.getCommentURL());
+    assertEquals(false, cookie.getDiscard());
+    assertEquals(server.getCookieDomain(), cookie.getDomain());
+    assertTrue(cookie.getMaxAge() > 100000000000L);
+    assertEquals("/path", cookie.getPath());
+    assertEquals(true, cookie.getSecure());
+    assertEquals(0, cookie.getVersion());
+  }
+
+  @Test public void testRfc2109Response() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    CookieHandler.setDefault(cookieManager);
+    MockWebServer server = new MockWebServer();
+    server.play();
+
+    server.enqueue(new MockResponse().addHeader("Set-Cookie: a=android; "
+        + "Comment=this cookie is delicious; "
+        + "Domain=" + server.getCookieDomain() + "; "
+        + "Max-Age=60; "
+        + "Path=/path; "
+        + "Secure; "
+        + "Version=1"));
+    get(server, "/path/foo");
+
+    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
+    assertEquals(1, cookies.size());
+    HttpCookie cookie = cookies.get(0);
+    assertEquals("a", cookie.getName());
+    assertEquals("android", cookie.getValue());
+    assertEquals("this cookie is delicious", cookie.getComment());
+    assertEquals(null, cookie.getCommentURL());
+    assertEquals(false, cookie.getDiscard());
+    assertEquals(server.getCookieDomain(), cookie.getDomain());
+    assertEquals(60, cookie.getMaxAge());
+    assertEquals("/path", cookie.getPath());
+    assertEquals(true, cookie.getSecure());
+    assertEquals(1, cookie.getVersion());
+  }
+
+  @Test public void testRfc2965Response() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    CookieHandler.setDefault(cookieManager);
+    MockWebServer server = new MockWebServer();
+    server.play();
+
+    server.enqueue(new MockResponse().addHeader("Set-Cookie2: a=android; "
+        + "Comment=this cookie is delicious; "
+        + "CommentURL=http://google.com/; "
+        + "Discard; "
+        + "Domain=" + server.getCookieDomain() + "; "
+        + "Max-Age=60; "
+        + "Path=/path; "
+        + "Port=\"80,443," + server.getPort() + "\"; "
+        + "Secure; "
+        + "Version=1"));
+    get(server, "/path/foo");
+
+    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
+    assertEquals(1, cookies.size());
+    HttpCookie cookie = cookies.get(0);
+    assertEquals("a", cookie.getName());
+    assertEquals("android", cookie.getValue());
+    assertEquals("this cookie is delicious", cookie.getComment());
+    assertEquals("http://google.com/", cookie.getCommentURL());
+    assertEquals(true, cookie.getDiscard());
+    assertEquals(server.getCookieDomain(), cookie.getDomain());
+    assertEquals(60, cookie.getMaxAge());
+    assertEquals("/path", cookie.getPath());
+    assertEquals("80,443," + server.getPort(), cookie.getPortlist());
+    assertEquals(true, cookie.getSecure());
+    assertEquals(1, cookie.getVersion());
+  }
+
+  @Test public void testQuotedAttributeValues() throws Exception {
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    CookieHandler.setDefault(cookieManager);
+    MockWebServer server = new MockWebServer();
+    server.play();
+
+    server.enqueue(new MockResponse().addHeader("Set-Cookie2: a=\"android\"; "
+        + "Comment=\"this cookie is delicious\"; "
+        + "CommentURL=\"http://google.com/\"; "
+        + "Discard; "
+        + "Domain=\"" + server.getCookieDomain() + "\"; "
+        + "Max-Age=\"60\"; "
+        + "Path=\"/path\"; "
+        + "Port=\"80,443," + server.getPort() + "\"; "
+        + "Secure; "
+        + "Version=\"1\""));
+    get(server, "/path/foo");
+
+    List<HttpCookie> cookies = cookieManager.getCookieStore().getCookies();
+    assertEquals(1, cookies.size());
+    HttpCookie cookie = cookies.get(0);
+    assertEquals("a", cookie.getName());
+    assertEquals("android", cookie.getValue());
+    assertEquals("this cookie is delicious", cookie.getComment());
+    assertEquals("http://google.com/", cookie.getCommentURL());
+    assertEquals(true, cookie.getDiscard());
+    assertEquals(server.getCookieDomain(), cookie.getDomain());
+    assertEquals(60, cookie.getMaxAge());
+    assertEquals("/path", cookie.getPath());
+    assertEquals("80,443," + server.getPort(), cookie.getPortlist());
+    assertEquals(true, cookie.getSecure());
+    assertEquals(1, cookie.getVersion());
+  }
+
+  @Test public void testSendingCookiesFromStore() throws Exception {
+    MockWebServer server = new MockWebServer();
+    server.enqueue(new MockResponse());
+    server.play();
+
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    HttpCookie cookieA = new HttpCookie("a", "android");
+    cookieA.setDomain(server.getCookieDomain());
+    cookieA.setPath("/");
+    cookieManager.getCookieStore().add(server.getUrl("/").toURI(), cookieA);
+    HttpCookie cookieB = new HttpCookie("b", "banana");
+    cookieB.setDomain(server.getCookieDomain());
+    cookieB.setPath("/");
+    cookieManager.getCookieStore().add(server.getUrl("/").toURI(), cookieB);
+    CookieHandler.setDefault(cookieManager);
+
+    get(server, "/");
+    RecordedRequest request = server.takeRequest();
+
+    List<String> receivedHeaders = request.getHeaders();
+    assertContains(receivedHeaders, "Cookie: $Version=\"1\"; "
+        + "a=\"android\";$Path=\"/\";$Domain=\"" + server.getCookieDomain() + "\"; "
+        + "b=\"banana\";$Path=\"/\";$Domain=\"" + server.getCookieDomain() + "\"");
+  }
+
+  @Test public void testRedirectsDoNotIncludeTooManyCookies() throws Exception {
+    MockWebServer redirectTarget = new MockWebServer();
+    redirectTarget.enqueue(new MockResponse().setBody("A"));
+    redirectTarget.play();
+
+    MockWebServer redirectSource = new MockWebServer();
+    redirectSource.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: " + redirectTarget.getUrl("/")));
+    redirectSource.play();
+
+    CookieManager cookieManager = new CookieManager(null, ACCEPT_ORIGINAL_SERVER);
+    HttpCookie cookie = new HttpCookie("c", "cookie");
+    cookie.setDomain(redirectSource.getCookieDomain());
+    cookie.setPath("/");
+    String portList = Integer.toString(redirectSource.getPort());
+    cookie.setPortlist(portList);
+    cookieManager.getCookieStore().add(redirectSource.getUrl("/").toURI(), cookie);
+    CookieHandler.setDefault(cookieManager);
+
+    get(redirectSource, "/");
+    RecordedRequest request = redirectSource.takeRequest();
+
+    assertContains(request.getHeaders(), "Cookie: $Version=\"1\"; "
+        + "c=\"cookie\";$Path=\"/\";$Domain=\"" + redirectSource.getCookieDomain()
+        + "\";$Port=\"" + portList + "\"");
+
+    for (String header : redirectTarget.takeRequest().getHeaders()) {
+      if (header.startsWith("Cookie")) {
+        fail(header);
+      }
+    }
+  }
+
+  /**
+   * Test which headers show up where. The cookie manager should be notified
+   * of both user-specified and derived headers like {@code Host}. Headers
+   * named {@code Cookie} or {@code Cookie2} that are returned by the cookie
+   * manager should show up in the request and in {@code
+   * getRequestProperties}.
+   */
+  @Test public void testHeadersSentToCookieHandler() throws IOException, InterruptedException {
+    final Map<String, List<String>> cookieHandlerHeaders = new HashMap<String, List<String>>();
+    CookieHandler.setDefault(new CookieManager() {
+      @Override
+      public Map<String, List<String>> get(URI uri,
+          Map<String, List<String>> requestHeaders) throws IOException {
+        cookieHandlerHeaders.putAll(requestHeaders);
+        Map<String, List<String>> result = new HashMap<String, List<String>>();
+        result.put("Cookie", Collections.singletonList("Bar=bar"));
+        result.put("Cookie2", Collections.singletonList("Baz=baz"));
+        result.put("Quux", Collections.singletonList("quux"));
+        return result;
+      }
+    });
+    MockWebServer server = new MockWebServer();
+    server.enqueue(new MockResponse());
+    server.play();
+
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    assertEquals(Collections.<String, List<String>>emptyMap(),
+        connection.getRequestProperties());
+
+    connection.setRequestProperty("Foo", "foo");
+    connection.setDoOutput(true);
+    connection.getOutputStream().write(5);
+    connection.getOutputStream().close();
+    connection.getInputStream().close();
+
+    RecordedRequest request = server.takeRequest();
+
+    assertContainsAll(cookieHandlerHeaders.keySet(), "Foo");
+    assertContainsAll(cookieHandlerHeaders.keySet(),
+        "Content-type", "User-Agent", "Connection", "Host");
+    assertFalse(cookieHandlerHeaders.containsKey("Cookie"));
+
+    /*
+     * The API specifies that calling getRequestProperties() on a connected instance should fail
+     * with an IllegalStateException, but the RI violates the spec and returns a valid map.
+     * http://www.mail-archive.com/net-dev@openjdk.java.net/msg01768.html
+     */
+    try {
+      assertContainsAll(connection.getRequestProperties().keySet(), "Foo");
+      assertContainsAll(connection.getRequestProperties().keySet(),
+          "Content-type", "Content-Length", "User-Agent", "Connection", "Host");
+      assertContainsAll(connection.getRequestProperties().keySet(), "Cookie", "Cookie2");
+      assertFalse(connection.getRequestProperties().containsKey("Quux"));
+    } catch (IllegalStateException expected) {
+    }
+
+    assertContainsAll(request.getHeaders(), "Foo: foo", "Cookie: Bar=bar", "Cookie2: Baz=baz");
+    assertFalse(request.getHeaders().contains("Quux: quux"));
+  }
+
+  @Test public void testCookiesSentIgnoresCase() throws Exception {
+    CookieHandler.setDefault(new CookieManager() {
+      @Override public Map<String, List<String>> get(URI uri,
+          Map<String, List<String>> requestHeaders) throws IOException {
+        Map<String, List<String>> result = new HashMap<String, List<String>>();
+        result.put("COOKIE", Collections.singletonList("Bar=bar"));
+        result.put("cooKIE2", Collections.singletonList("Baz=baz"));
+        return result;
+      }
+    });
+    MockWebServer server = new MockWebServer();
+    server. enqueue(new MockResponse());
+    server.play();
+
+    get(server, "/");
+
+    RecordedRequest request = server.takeRequest();
+    assertContainsAll(request.getHeaders(), "COOKIE: Bar=bar", "cooKIE2: Baz=baz");
+    assertFalse(request.getHeaders().contains("Quux: quux"));
+  }
+
+  private void assertContains(Collection<String> collection, String element) {
+    for (String c : collection) {
+      if (c != null && c.equalsIgnoreCase(element)) {
+        return;
+      }
+    }
+    fail("No " + element + " in " + collection);
+  }
+
+  private void assertContainsAll(Collection<String> collection, String... toFind) {
+    for (String s : toFind) {
+      assertContains(collection, s);
+    }
+  }
+
+  private Map<String,List<String>> get(MockWebServer server, String path) throws Exception {
+    URLConnection connection = client.open(server.getUrl(path));
+    Map<String, List<String>> headers = connection.getHeaderFields();
+    connection.getInputStream().close();
+    return headers;
+  }
+
+}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
similarity index 92%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
index a7b85e3537..1c5198c696 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalHttp2Example.java
@@ -17,6 +17,7 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Protocol;
 import java.io.BufferedReader;
 import java.io.InputStreamReader;
 import java.net.URL;
@@ -29,8 +30,9 @@
 
 public final class ExternalHttp2Example {
   public static void main(String[] args) throws Exception {
-    URL url = new URL("https://twitter.com/");
-    HttpsURLConnection connection = (HttpsURLConnection) new OkHttpClient().open(url);
+    URL url = new URL("https://http2.iijplus.jp/push/test1");
+    HttpsURLConnection connection = (HttpsURLConnection) new OkHttpClient()
+        .setProtocols(Protocol.HTTP2_AND_HTTP_11).open(url);
 
     connection.setHostnameVerifier(new HostnameVerifier() {
       @Override public boolean verify(String s, SSLSession sslSession) {
@@ -46,6 +48,7 @@ public static void main(String[] args) throws Exception {
     if (protocolValues != null && !protocolValues.isEmpty()) {
       System.out.println("PROTOCOL " + protocolValues.get(0));
     }
+
     BufferedReader reader =
         new BufferedReader(new InputStreamReader(connection.getInputStream(), "UTF-8"));
     String line;
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
similarity index 94%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
index e43fbb0650..dab90c138f 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ExternalSpdyExample.java
@@ -17,6 +17,7 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.Protocol;
 import java.io.BufferedReader;
 import java.io.InputStreamReader;
 import java.net.URL;
@@ -30,7 +31,8 @@
 public final class ExternalSpdyExample {
   public static void main(String[] args) throws Exception {
     URL url = new URL("https://www.google.ca/");
-    HttpsURLConnection connection = (HttpsURLConnection) new OkHttpClient().open(url);
+    HttpsURLConnection connection = (HttpsURLConnection) new OkHttpClient()
+        .setProtocols(Protocol.SPDY3_AND_HTTP11).open(url);
 
     connection.setHostnameVerifier(new HostnameVerifier() {
       @Override public boolean verify(String s, SSLSession sslSession) {
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
similarity index 81%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
index 36b63f07ed..80db747041 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HeadersTest.java
@@ -25,8 +25,8 @@
 import org.junit.Test;
 
 import static com.squareup.okhttp.internal.Util.headerEntries;
-import static junit.framework.Assert.assertNull;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNull;
 
 public final class HeadersTest {
   @Test public void parseNameValueBlock() throws IOException {
@@ -39,21 +39,19 @@
     Response response =
         SpdyTransport.readNameValueBlock(headerBlock, Protocol.SPDY_3).request(request).build();
     Headers headers = response.headers();
-    assertEquals(5, headers.size());
+    assertEquals(4, headers.size());
     assertEquals("HTTP/1.1 200 OK", response.statusLine());
     assertEquals("no-cache, no-store", headers.get("cache-control"));
     assertEquals("Cookie2", headers.get("set-cookie"));
-    assertEquals(Protocol.SPDY_3.name.utf8(), headers.get(OkHeaders.SELECTED_TRANSPORT));
-    assertEquals(OkHeaders.SELECTED_TRANSPORT, headers.name(0));
     assertEquals(Protocol.SPDY_3.name.utf8(), headers.get(OkHeaders.SELECTED_PROTOCOL));
-    assertEquals(OkHeaders.SELECTED_PROTOCOL, headers.name(1));
-    assertEquals(Protocol.SPDY_3.name.utf8(), headers.value(1));
-    assertEquals("cache-control", headers.name(2));
-    assertEquals("no-cache, no-store", headers.value(2));
+    assertEquals(OkHeaders.SELECTED_PROTOCOL, headers.name(0));
+    assertEquals(Protocol.SPDY_3.name.utf8(), headers.value(0));
+    assertEquals("cache-control", headers.name(1));
+    assertEquals("no-cache, no-store", headers.value(1));
+    assertEquals("set-cookie", headers.name(2));
+    assertEquals("Cookie1", headers.value(2));
     assertEquals("set-cookie", headers.name(3));
-    assertEquals("Cookie1", headers.value(3));
-    assertEquals("set-cookie", headers.name(4));
-    assertEquals("Cookie2", headers.value(4));
+    assertEquals("Cookie2", headers.value(3));
     assertNull(headers.get(":status"));
     assertNull(headers.get(":version"));
   }
@@ -67,11 +65,9 @@
     Response response =
         SpdyTransport.readNameValueBlock(headerBlock, Protocol.SPDY_3).request(request).build();
     Headers headers = response.headers();
-    assertEquals(2, headers.size());
-    assertEquals(OkHeaders.SELECTED_TRANSPORT, headers.name(0));
+    assertEquals(1, headers.size());
+    assertEquals(OkHeaders.SELECTED_PROTOCOL, headers.name(0));
     assertEquals(Protocol.SPDY_3.name.utf8(), headers.value(0));
-    assertEquals(OkHeaders.SELECTED_PROTOCOL, headers.name(1));
-    assertEquals(Protocol.SPDY_3.name.utf8(), headers.value(1));;
   }
 
   @Test public void readNameValueBlockDropsForbiddenHeadersHttp2() throws IOException {
@@ -83,11 +79,9 @@
     Response response = SpdyTransport.readNameValueBlock(headerBlock, Protocol.HTTP_2)
         .request(request).build();
     Headers headers = response.headers();
-    assertEquals(2, headers.size());
-    assertEquals(OkHeaders.SELECTED_TRANSPORT, headers.name(0));
+    assertEquals(1, headers.size());
+    assertEquals(OkHeaders.SELECTED_PROTOCOL, headers.name(0));
     assertEquals(Protocol.HTTP_2.name.utf8(), headers.value(0));
-    assertEquals(OkHeaders.SELECTED_PROTOCOL, headers.name(1));
-    assertEquals(Protocol.HTTP_2.name.utf8(), headers.value(1));
   }
 
   @Test public void toNameValueBlock() {
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java
new file mode 100644
index 0000000000..851a9c1f96
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2013 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.PushPromise;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import java.util.Arrays;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+
+public class HttpOverHttp20Draft09Test extends HttpOverSpdyTest {
+
+  public HttpOverHttp20Draft09Test() {
+    super(Protocol.HTTP_2);
+    this.hostHeader = ":authority";
+  }
+
+  @Test public void serverSendsPushPromise_GET() throws Exception {
+    MockResponse response = new MockResponse().setBody("ABCDE").setStatus("HTTP/1.1 200 Sweet")
+        .withPush(new PushPromise("GET", "/foo/bar", Arrays.asList("foo: bar"),
+            new MockResponse().setBody("bar").setStatus("HTTP/1.1 200 Sweet")));
+    server.enqueue(response);
+    server.play();
+
+    connection = client.open(server.getUrl("/foo"));
+    assertContent("ABCDE", connection, Integer.MAX_VALUE);
+    assertEquals(200, connection.getResponseCode());
+    assertEquals("Sweet", connection.getResponseMessage());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+    assertContains(request.getHeaders(), ":scheme: https");
+    assertContains(request.getHeaders(), hostHeader + ": " + hostName + ":" + server.getPort());
+
+    RecordedRequest pushedRequest = server.takeRequest();
+    assertEquals("GET /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
+    assertEquals(Arrays.asList("foo: bar"), pushedRequest.getHeaders());
+  }
+
+  @Test public void serverSendsPushPromise_HEAD() throws Exception {
+    MockResponse response = new MockResponse().setBody("ABCDE").setStatus("HTTP/1.1 200 Sweet")
+        .withPush(new PushPromise("HEAD", "/foo/bar", Arrays.asList("foo: bar"),
+            new MockResponse().setStatus("HTTP/1.1 204 Sweet")));
+    server.enqueue(response);
+    server.play();
+
+    connection = client.open(server.getUrl("/foo"));
+    assertContent("ABCDE", connection, Integer.MAX_VALUE);
+    assertEquals(200, connection.getResponseCode());
+    assertEquals("Sweet", connection.getResponseMessage());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
+    assertContains(request.getHeaders(), ":scheme: https");
+    assertContains(request.getHeaders(), hostHeader + ": " + hostName + ":" + server.getPort());
+
+    RecordedRequest pushedRequest = server.takeRequest();
+    assertEquals("HEAD /foo/bar HTTP/1.1", pushedRequest.getRequestLine());
+    assertEquals(Arrays.asList("foo: bar"), pushedRequest.getHeaders());
+  }
+}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdy3Test.java
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
similarity index 79%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
index 8cc7bfd702..c725a751a3 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpOverSpdyTest.java
@@ -34,7 +34,6 @@
 import java.net.CookieManager;
 import java.net.HttpURLConnection;
 import java.net.URL;
-import java.net.URLConnection;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
@@ -53,6 +52,7 @@
 import org.junit.Ignore;
 import org.junit.Test;
 
+import static java.util.concurrent.TimeUnit.SECONDS;
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
@@ -77,10 +77,11 @@ public boolean verify(String hostname, SSLSession session) {
   };
 
   private static final SSLContext sslContext = SslContextBuilder.localhost();
-  private final MockWebServer server = new MockWebServer();
-  private final String hostName = server.getHostName();
-  private final OkHttpClient client = new OkHttpClient();
-  private HttpResponseCache cache;
+  protected final MockWebServer server = new MockWebServer();
+  protected final String hostName = server.getHostName();
+  protected final OkHttpClient client = new OkHttpClient();
+  protected HttpURLConnection connection;
+  protected HttpResponseCache cache;
 
   @Before public void setUp() throws Exception {
     server.useHttps(sslContext.getSocketFactory(), false);
@@ -102,7 +103,7 @@ public boolean verify(String hostname, SSLSession session) {
     server.enqueue(response);
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
     assertContent("ABCDE", connection, Integer.MAX_VALUE);
     assertEquals(200, connection.getResponseCode());
     assertEquals("Sweet", connection.getResponseMessage());
@@ -117,19 +118,19 @@ public boolean verify(String hostname, SSLSession session) {
     server.enqueue(new MockResponse());
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
     assertEquals(-1, connection.getInputStream().read());
   }
 
   byte[] postBytes = "FGHIJ".getBytes(Util.UTF_8);
 
   /** An output stream can be written to more than once, so we can't guess content length. */
-   @Test public void noDefaultContentLengthOnPost() throws Exception {
+  @Test public void noDefaultContentLengthOnPost() throws Exception {
     MockResponse response = new MockResponse().setBody("ABCDE");
     server.enqueue(response);
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
     connection.setDoOutput(true);
     connection.getOutputStream().write(postBytes);
     assertContent("ABCDE", connection, Integer.MAX_VALUE);
@@ -145,7 +146,7 @@ public boolean verify(String hostname, SSLSession session) {
     server.enqueue(response);
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
     connection.setRequestProperty("Content-Length", String.valueOf(postBytes.length));
     connection.setDoOutput(true);
     connection.getOutputStream().write(postBytes);
@@ -157,12 +158,31 @@ public boolean verify(String hostname, SSLSession session) {
     assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
   }
 
+  @Test public void closeAfterFlush() throws Exception {
+    MockResponse response = new MockResponse().setBody("ABCDE");
+    server.enqueue(response);
+    server.play();
+
+    connection = client.open(server.getUrl("/foo"));
+    connection.setRequestProperty("Content-Length", String.valueOf(postBytes.length));
+    connection.setDoOutput(true);
+    connection.getOutputStream().write(postBytes); // push bytes into SpdyDataOutputStream.buffer
+    connection.getOutputStream().flush(); // SpdyConnection.writeData subject to write window
+    connection.getOutputStream().close(); // SpdyConnection.writeData empty frame
+    assertContent("ABCDE", connection, Integer.MAX_VALUE);
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("POST /foo HTTP/1.1", request.getRequestLine());
+    assertArrayEquals(postBytes, request.getBody());
+    assertEquals(postBytes.length, Integer.parseInt(request.getHeader("Content-Length")));
+  }
+
   @Test public void setFixedLengthStreamingModeSetsContentLength() throws Exception {
     MockResponse response = new MockResponse().setBody("ABCDE");
     server.enqueue(response);
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
     connection.setFixedLengthStreamingMode(postBytes.length);
     connection.setDoOutput(true);
     connection.getOutputStream().write(postBytes);
@@ -218,7 +238,7 @@ public boolean verify(String hostname, SSLSession session) {
     server.play();
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
     RecordedRequest denied = server.takeRequest();
@@ -236,7 +256,7 @@ public boolean verify(String hostname, SSLSession session) {
     server.enqueue(new MockResponse().setBody("This is the new location!"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertContent("This is the new location!", connection, Integer.MAX_VALUE);
 
     RecordedRequest request1 = server.takeRequest();
@@ -249,23 +269,70 @@ public boolean verify(String hostname, SSLSession session) {
     server.enqueue(new MockResponse().setBody("ABC"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     InputStream in = connection.getInputStream();
     assertEquals("ABC", readAscii(in, 3));
     assertEquals(-1, in.read());
     assertEquals(-1, in.read());
   }
 
+  @Ignore // See https://github.com/square/okhttp/issues/578
   @Test(timeout = 3000) public void readResponseHeaderTimeout() throws Exception {
     server.enqueue(new MockResponse().setSocketPolicy(SocketPolicy.NO_RESPONSE));
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setReadTimeout(1000);
     assertContent("A", connection, Integer.MAX_VALUE);
   }
 
+  /**
+   * Test to ensure we don't  throw a read timeout on responses that are
+   * progressing.  For this case, we take a 4KiB body and throttle it to
+   * 1KiB/second.  We set the read timeout to two seconds.  If our
+   * implementation is acting correctly, it will not throw, as it is
+   * progressing.
+   */
+  @Test public void readTimeoutMoreGranularThanBodySize() throws Exception {
+    char[] body = new char[4096]; // 4KiB to read
+    Arrays.fill(body, 'y');
+    server.enqueue(new MockResponse()
+        .setBody(new String(body))
+        .throttleBody(1024, 1, SECONDS)); // slow connection 1KiB/second
+    server.play();
+
+    connection = client.open(server.getUrl("/"));
+    connection.setReadTimeout(2000); // 2 seconds to read something.
+    assertContent(new String(body), connection, Integer.MAX_VALUE);
+  }
+
+  /**
+   * Test to ensure we throw a read timeout on responses that are progressing
+   * too slowly.  For this case, we take a 2KiB body and throttle it to
+   * 1KiB/second.  We set the read timeout to half a second.  If our
+   * implementation is acting correctly, it will throw, as a byte doesn't
+   * arrive in time.
+   */
+  @Test public void readTimeoutOnSlowConnection() throws Exception {
+    char[] body = new char[2048]; // 2KiB to read
+    Arrays.fill(body, 'y');
+    server.enqueue(new MockResponse()
+        .setBody(new String(body))
+        .throttleBody(1024, 1, SECONDS)); // slow connection 1KiB/second
+    server.play();
+
+    connection = client.open(server.getUrl("/"));
+    connection.setReadTimeout(500); // half a second to read something
+    connection.connect();
+    try {
+      readAscii(connection.getInputStream(), Integer.MAX_VALUE);
+      fail("Should have timed out!");
+    } catch (IOException e){
+      assertEquals("Read timed out", e.getMessage());
+    }
+  }
+
   @Test public void spdyConnectionTimeout() throws Exception {
     MockResponse response = new MockResponse().setBody("A");
     response.setBodyDelayTimeMs(1000);
@@ -322,12 +389,12 @@ public boolean verify(String hostname, SSLSession session) {
     server.enqueue(new MockResponse().addHeader("cache-control: max-age=60").setBody("EFGH"));
     server.play();
 
-    URLConnection connection1 = client.open(server.getUrl("/"));
+    HttpURLConnection connection1 = client.open(server.getUrl("/"));
     InputStream in1 = connection1.getInputStream();
     assertEquals("AB", readAscii(in1, 2));
     in1.close();
 
-    URLConnection connection2 = client.open(server.getUrl("/"));
+    HttpURLConnection connection2 = client.open(server.getUrl("/"));
     InputStream in2 = connection2.getInputStream();
     assertEquals("ABCD", readAscii(in2, Integer.MAX_VALUE));
     in2.close();
@@ -355,15 +422,14 @@ public boolean verify(String hostname, SSLSession session) {
     assertContains(requestB.getHeaders(), "cookie: c=oreo");
   }
 
-  private <T> void assertContains(Collection<T> collection, T value) {
+  <T> void assertContains(Collection<T> collection, T value) {
     assertTrue(collection.toString(), collection.contains(value));
   }
 
-  private void assertContent(String expected, URLConnection connection, int limit)
+  void assertContent(String expected, HttpURLConnection connection, int limit)
       throws IOException {
     connection.connect();
     assertEquals(expected, readAscii(connection.getInputStream(), limit));
-    ((HttpURLConnection) connection).disconnect();
   }
 
   private void assertContainsNoneMatching(List<String> headers, String pattern) {
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
similarity index 96%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
index 40a35e7e31..b6edaae92e 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/HttpResponseCacheTest.java
@@ -16,6 +16,7 @@
 
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.ConnectionPool;
 import com.squareup.okhttp.HttpResponseCache;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.OkResponseCache;
@@ -37,14 +38,11 @@
 import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.net.CacheRequest;
-import java.net.CacheResponse;
 import java.net.CookieHandler;
 import java.net.CookieManager;
 import java.net.HttpCookie;
 import java.net.HttpURLConnection;
 import java.net.ResponseCache;
-import java.net.SecureCacheResponse;
-import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
 import java.net.URLConnection;
@@ -58,7 +56,6 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
-import java.util.Map;
 import java.util.TimeZone;
 import java.util.UUID;
 import java.util.concurrent.TimeUnit;
@@ -79,10 +76,14 @@
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
-/** Android's HttpResponseCacheTest. */
+/**
+ * Android's HttpResponseCacheTest. This tests both the {@link HttpResponseCache} implementation and
+ * the behavior of {@link com.squareup.okhttp.OkResponseCache} classes generally.
+ */
 public final class HttpResponseCacheTest {
   private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
     @Override public boolean verify(String s, SSLSession sslSession) {
@@ -119,6 +120,20 @@ private HttpURLConnection openConnection(URL url) {
     return client.open(url);
   }
 
+  @Test public void responseCacheAccessWithOkHttpMember() throws IOException {
+    ResponseCache.setDefault(null);
+    client.setResponseCache(cache);
+    assertSame(cache, client.getOkResponseCache());
+    assertNull(client.getResponseCache());
+  }
+
+  @Test public void responseCacheAccessWithGlobalDefault() throws IOException {
+    ResponseCache.setDefault(cache);
+    client.setResponseCache(null);
+    assertNull(client.getOkResponseCache());
+    assertNull(client.getResponseCache());
+  }
+
   /**
    * Test that response caching is consistent with the RI and the spec.
    * http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.4
@@ -360,26 +375,6 @@ private void testResponseCaching(TransferKind transferKind) throws IOException {
     assertEquals(localPrincipal, c2.getLocalPrincipal());
   }
 
-  @Test public void cacheReturnsInsecureResponseForSecureRequest() throws IOException {
-    server.useHttps(sslContext.getSocketFactory(), false);
-    server.enqueue(new MockResponse().setBody("ABC"));
-    server.enqueue(new MockResponse().setBody("DEF"));
-    server.play();
-
-    ResponseCache.setDefault(new InsecureResponseCache());
-
-    HttpsURLConnection connection1 = (HttpsURLConnection) client.open(server.getUrl("/"));
-    connection1.setSSLSocketFactory(sslContext.getSocketFactory());
-    connection1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals("ABC", readAscii(connection1));
-
-    // Not cached!
-    HttpsURLConnection connection2 = (HttpsURLConnection) client.open(server.getUrl("/"));
-    connection2.setSSLSocketFactory(sslContext.getSocketFactory());
-    connection2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
-    assertEquals("DEF", readAscii(connection2));
-  }
-
   @Test public void responseCachingAndRedirects() throws Exception {
     server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
         .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
@@ -972,6 +967,22 @@ private void assertNonIdentityEncodingCached(MockResponse response) throws Excep
     assertEquals("DEFDEFDEF", readAscii(openConnection(server.getUrl("/"))));
   }
 
+  @Test public void conditionalCacheHitIsNotDoublePooled() throws Exception {
+    server.enqueue(new MockResponse().addHeader("ETag: v1").setBody("A"));
+    server.enqueue(new MockResponse()
+        .clearHeaders()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.play();
+
+    ConnectionPool pool = ConnectionPool.getDefault();
+    pool.evictAll();
+    client.setConnectionPool(pool);
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals(1, client.getConnectionPool().getConnectionCount());
+  }
+
   @Test public void expiresDateBeforeModifiedDate() throws Exception {
     assertConditionallyCached(
         new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
@@ -1164,17 +1175,57 @@ private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String
     return server.takeRequest();
   }
 
+  /**
+   * Confirm that {@link URLConnection#setIfModifiedSince} causes an
+   * If-Modified-Since header with a GMT timestamp.
+   *
+   * https://code.google.com/p/android/issues/detail?id=66135
+   */
   @Test public void setIfModifiedSince() throws Exception {
-    Date since = new Date();
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
 
     URL url = server.getUrl("/");
     URLConnection connection = openConnection(url);
-    connection.setIfModifiedSince(since.getTime());
+    connection.setIfModifiedSince(1393666200000L);
     assertEquals("A", readAscii(connection));
     RecordedRequest request = server.takeRequest();
-    assertTrue(request.getHeaders().contains("If-Modified-Since: " + formatDate(since)));
+    String ifModifiedSinceHeader = request.getHeader("If-Modified-Since");
+    assertEquals("Sat, 01 Mar 2014 09:30:00 GMT", ifModifiedSinceHeader);
+  }
+
+  /**
+   * For Last-Modified and Date headers, we should echo the date back in the
+   * exact format we were served.
+   */
+  @Test public void retainServedDateFormat() throws Exception {
+    // Serve a response with a non-standard date format that OkHttp supports.
+    Date lastModifiedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-1));
+    Date servedDate = new Date(System.currentTimeMillis() + TimeUnit.HOURS.toMillis(-2));
+    DateFormat dateFormat = new SimpleDateFormat("EEE dd-MMM-yyyy HH:mm:ss z", Locale.US);
+    dateFormat.setTimeZone(TimeZone.getTimeZone("EDT"));
+    String lastModifiedString = dateFormat.format(lastModifiedDate);
+    String servedString = dateFormat.format(servedDate);
+
+    // This response should be conditionally cached.
+    server.enqueue(new MockResponse()
+        .addHeader("Last-Modified: " + lastModifiedString)
+        .addHeader("Expires: " + servedString)
+        .setBody("A"));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.play();
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+
+    // The first request has no conditions.
+    RecordedRequest request1 = server.takeRequest();
+    assertNull(request1.getHeader("If-Modified-Since"));
+
+    // The 2nd request uses the server's date format.
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals(lastModifiedString, request2.getHeader("If-Modified-Since"));
   }
 
   @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
@@ -1802,7 +1853,7 @@ public void assertCookies(URL url, String... expectedCookies) throws Exception {
     writeFile(cache.getDirectory(), urlKey + ".1", entryBody);
     writeFile(cache.getDirectory(), "journal", journalBody);
     cache = new HttpResponseCache(cache.getDirectory(), Integer.MAX_VALUE);
-    client.setResponseCache(cache);
+    client.setOkResponseCache(cache);
 
     HttpURLConnection connection = client.open(url);
     assertEquals(entryBody, readAscii(connection));
@@ -2000,28 +2051,6 @@ void setBody(MockResponse response, String content, int chunkSize) throws IOExce
     return bytesOut.toByteArray();
   }
 
-  private class InsecureResponseCache extends ResponseCache {
-    @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-      return cache.put(uri, connection);
-    }
-
-    @Override public CacheResponse get(URI uri, String requestMethod,
-        Map<String, List<String>> requestHeaders) throws IOException {
-      final CacheResponse response = cache.get(uri, requestMethod, requestHeaders);
-      if (response instanceof SecureCacheResponse) {
-        return new CacheResponse() {
-          @Override public InputStream getBody() throws IOException {
-            return response.getBody();
-          }
-          @Override public Map<String, List<String>> getHeaders() throws IOException {
-            return response.getHeaders();
-          }
-        };
-      }
-      return response;
-    }
-  }
-
   static abstract class AbstractOkResponseCache implements OkResponseCache {
     @Override public Response get(Request request) throws IOException {
       return null;
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ResponseCacheAdapterTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ResponseCacheAdapterTest.java
new file mode 100644
index 0000000000..9b880ef58b
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ResponseCacheAdapterTest.java
@@ -0,0 +1,569 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.IOException;
+import java.net.CacheRequest;
+import java.net.CacheResponse;
+import java.net.HttpURLConnection;
+import java.net.ResponseCache;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.net.URLConnection;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLSession;
+
+import static org.junit.Assert.assertArrayEquals;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/**
+ * A white-box test for {@link ResponseCacheAdapter}. See also {@link ResponseCacheTest} for
+ * black-box tests that check that {@link ResponseCache} classes are called correctly by OkHttp.
+ */
+public class ResponseCacheAdapterTest {
+
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
+  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
+    public boolean verify(String hostname, SSLSession session) {
+      return true;
+    }
+  };
+
+  private MockWebServer server;
+
+  private OkHttpClient client;
+
+  private HttpURLConnection connection;
+
+  @Before
+  public void setUp() throws Exception {
+    server = new MockWebServer();
+    client = new OkHttpClient();
+  }
+
+  @After
+  public void tearDown() throws Exception {
+    if (connection != null) {
+      connection.disconnect();
+    }
+    server.shutdown();
+  }
+
+  @Test public void get_allParameters() throws Exception {
+    final URL serverUrl = configureServer(new MockResponse());
+    assertEquals("http", serverUrl.getProtocol());
+
+    ResponseCache responseCache = new NoOpResponseCache() {
+      @Override
+      public CacheResponse get(URI uri, String method, Map<String, List<String>> headers) throws IOException {
+        assertEquals(toUri(serverUrl), uri);
+        assertEquals("GET", method);
+        assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
+        assertEquals(Collections.singletonList("value1"), headers.get("key1"));
+        return null;
+      }
+    };
+    client.setResponseCache(responseCache);
+
+    connection = client.open(serverUrl);
+    connection.setRequestProperty("key1", "value1");
+
+    executeGet(connection);
+  }
+
+  @Test public void put_uriAndClass() throws Exception {
+    final URL serverUrl = configureServer(new MockResponse());
+
+    ResponseCache responseCache = new NoOpResponseCache() {
+      @Override
+      public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
+        assertTrue(urlConnection instanceof HttpURLConnection);
+        assertFalse(urlConnection instanceof HttpsURLConnection);
+        assertEquals(toUri(serverUrl), uri);
+        assertEquals(serverUrl, urlConnection.getURL());
+        return null;
+      }
+    };
+    client.setResponseCache(responseCache);
+
+    connection = client.open(serverUrl);
+    executeGet(connection);
+  }
+
+  @Test public void put_requestHeadersPartlyUnavailable() throws Exception {
+    final URL serverUrl = configureServer(new MockResponse());
+
+    ResponseCache responseCache = new NoOpResponseCache() {
+      @Override
+      public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
+        // This is to be compatible with OkHttp's HttpURLConnectionImpl and the RI.
+        try {
+          urlConnection.getRequestProperties();
+          fail();
+        } catch (UnsupportedOperationException expected) {
+        }
+
+        assertEquals("value", urlConnection.getRequestProperty("key"));
+
+        return null;
+      }
+    };
+    client.setResponseCache(responseCache);
+
+    connection = client.open(serverUrl);
+    connection.setRequestProperty("key", "value");
+
+    executeGet(connection);
+  }
+
+  @Test public void put_requestChangesForbidden() throws Exception {
+    final URL serverUrl = configureServer(new MockResponse());
+
+    ResponseCache responseCache = new NoOpResponseCache() {
+      @Override
+      public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
+        HttpURLConnection httpUrlConnection = (HttpURLConnection) urlConnection;
+        // Check an arbitrary (not complete) set of methods that can be used to modify the
+        // request.
+        try {
+          httpUrlConnection.setRequestProperty("key", "value");
+          fail();
+        } catch (UnsupportedOperationException expected) {
+        }
+        try {
+          httpUrlConnection.setFixedLengthStreamingMode(1234);
+          fail();
+        } catch (UnsupportedOperationException expected) {
+        }
+        try {
+          httpUrlConnection.setRequestMethod("PUT");
+          fail();
+        } catch (UnsupportedOperationException expected) {
+        }
+        try {
+          httpUrlConnection.getHeaderFields().put("key", Collections.singletonList("value"));
+          fail();
+        } catch (UnsupportedOperationException expected) {
+        }
+        try {
+          httpUrlConnection.getOutputStream();
+          fail();
+        } catch (UnsupportedOperationException expected) {
+        }
+        return null;
+      }
+    };
+    client.setResponseCache(responseCache);
+
+    connection = client.open(serverUrl);
+
+    executeGet(connection);
+  }
+
+  @Test public void connectionChangesForbidden() throws Exception {
+    final URL serverUrl = configureServer(new MockResponse());
+
+    ResponseCache responseCache = new NoOpResponseCache() {
+      @Override
+      public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
+        HttpURLConnection httpUrlConnection = (HttpURLConnection) urlConnection;
+        try {
+          httpUrlConnection.connect();
+          fail();
+        } catch (UnsupportedOperationException expected) {
+        }
+        try {
+          httpUrlConnection.disconnect();
+          fail();
+        } catch (UnsupportedOperationException expected) {
+        }
+        return null;
+      }
+    };
+    client.setResponseCache(responseCache);
+
+    connection = client.open(serverUrl);
+
+    executeGet(connection);
+  }
+
+  @Test public void put_responseChangesForbidden() throws Exception {
+    final URL serverUrl = configureServer(new MockResponse());
+
+    ResponseCache responseCache = new NoOpResponseCache() {
+      @Override
+      public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
+        HttpURLConnection httpUrlConnection = (HttpURLConnection) urlConnection;
+        // Check an arbitrary (not complete) set of methods that can be used to access the response
+        // body.
+        try {
+          httpUrlConnection.getInputStream();
+          fail();
+        } catch (UnsupportedOperationException expected) {
+        }
+        try {
+          httpUrlConnection.getContent();
+          fail();
+        } catch (UnsupportedOperationException expected) {
+        }
+        try {
+          httpUrlConnection.setFixedLengthStreamingMode(1234);
+          fail();
+        } catch (UnsupportedOperationException expected) {
+        }
+        try {
+          httpUrlConnection.setRequestMethod("PUT");
+          fail();
+        } catch (UnsupportedOperationException expected) {
+        }
+        try {
+          urlConnection.getHeaderFields().put("key", Collections.singletonList("value"));
+          fail();
+        } catch (UnsupportedOperationException expected) {
+        }
+        return null;
+      }
+    };
+    client.setResponseCache(responseCache);
+
+    connection = client.open(serverUrl);
+
+    executeGet(connection);
+  }
+
+  @Test public void put_responseHeadersOk() throws Exception {
+    final String statusLine = "HTTP/1.1 200 Fantastic";
+    final URL serverUrl = configureServer(
+        new MockResponse()
+            .setStatus(statusLine)
+            .addHeader("A", "c")
+            .addHeader("B", "d")
+            .addHeader("A", "e"));
+
+    ResponseCache responseCache = new NoOpResponseCache() {
+      @Override
+      public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
+        HttpURLConnection httpUrlConnection = (HttpURLConnection) urlConnection;
+        assertEquals(200, httpUrlConnection.getResponseCode());
+        assertEquals("Fantastic", httpUrlConnection.getResponseMessage());
+        assertEquals(0, urlConnection.getContentLength());
+
+        // Check retrieval by string key.
+        assertEquals(statusLine, httpUrlConnection.getHeaderField(null));
+        assertEquals("e", httpUrlConnection.getHeaderField("A"));
+        // The RI and OkHttp supports case-insensitive matching for this method.
+        assertEquals("e", httpUrlConnection.getHeaderField("a"));
+
+        // Check retrieval using a Map.
+        Map<String, List<String>> responseHeaders = httpUrlConnection.getHeaderFields();
+        assertEquals(Arrays.asList(statusLine), responseHeaders.get(null));
+        assertEquals(newSet("c", "e"), new HashSet<String>(responseHeaders.get("A")));
+        // OkHttp supports case-insensitive matching here. The RI does not.
+        assertEquals(newSet("c", "e"), new HashSet<String>(responseHeaders.get("a")));
+
+        // Check the Map iterator contains the expected mappings.
+        assertHeadersContainsMapping(responseHeaders, null, statusLine);
+        assertHeadersContainsMapping(responseHeaders, "A", "c", "e");
+        assertHeadersContainsMapping(responseHeaders, "B", "d");
+
+        // Check immutability of the headers Map.
+        try {
+          responseHeaders.put("N", Arrays.asList("o"));
+          fail("Modified an unmodifiable view.");
+        } catch (UnsupportedOperationException expected) {
+        }
+        try {
+          responseHeaders.get("A").add("f");
+          fail("Modified an unmodifiable view.");
+        } catch (UnsupportedOperationException expected) {
+        }
+
+        // Check retrieval of headers by index.
+        assertEquals(null, httpUrlConnection.getHeaderFieldKey(0));
+        assertEquals(statusLine, httpUrlConnection.getHeaderField(0));
+        // After header zero there may be additional entries provided at the beginning or end by the
+        // implementation. It's probably important that the relative ordering of the headers is
+        // preserved, particularly if there are multiple value for the same key.
+        int i = 1;
+        while (!httpUrlConnection.getHeaderFieldKey(i).equals("A")) {
+          i++;
+        }
+        // Check the ordering of the headers set by app code.
+        assertResponseHeaderAtIndex(httpUrlConnection, i++, "A", "c");
+        assertResponseHeaderAtIndex(httpUrlConnection, i++, "B", "d");
+        assertResponseHeaderAtIndex(httpUrlConnection, i++, "A", "e");
+        // There may be some additional headers provided by the implementation.
+        while (httpUrlConnection.getHeaderField(i) != null) {
+          assertNotNull(httpUrlConnection.getHeaderFieldKey(i));
+          i++;
+        }
+        // Confirm the correct behavior when the index is out-of-range.
+        assertNull(httpUrlConnection.getHeaderFieldKey(i));
+
+        return null;
+      }
+    };
+    client.setResponseCache(responseCache);
+
+    connection = client.open(serverUrl);
+
+    executeGet(connection);
+  }
+
+  private static void assertResponseHeaderAtIndex(HttpURLConnection httpUrlConnection, int headerIndex,
+      String expectedKey, String expectedValue) {
+    assertEquals(expectedKey, httpUrlConnection.getHeaderFieldKey(headerIndex));
+    assertEquals(expectedValue, httpUrlConnection.getHeaderField(headerIndex));
+
+  }
+
+  private void assertHeadersContainsMapping(Map<String, List<String>> headers, String expectedKey,
+      String... expectedValues) {
+    assertTrue(headers.containsKey(expectedKey));
+    assertEquals(newSet(expectedValues), new HashSet<String>(headers.get(expectedKey)));
+  }
+
+  @Test public void put_accessibleRequestInfo_GET() throws Exception {
+    final URL serverUrl = configureServer(new MockResponse());
+
+    ResponseCache responseCache = new NoOpResponseCache() {
+      @Override
+      public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
+        // Status Line is treated as a special header by the Java APIs.
+        HttpURLConnection httpUrlConnection = (HttpURLConnection) urlConnection;
+        assertEquals("GET", httpUrlConnection.getRequestMethod());
+        assertTrue(httpUrlConnection.getDoInput());
+        assertFalse(httpUrlConnection.getDoOutput());
+
+        return null;
+      }
+    };
+    client.setResponseCache(responseCache);
+
+    connection = client.open(serverUrl);
+
+    executeGet(connection);
+  }
+
+  @Test public void put_accessibleRequestInfo_POST() throws Exception {
+    final URL serverUrl = configureServer(new MockResponse());
+
+    ResponseCache responseCache = new NoOpResponseCache() {
+      @Override
+      public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
+        // Status Line is treated as a special header by the Java APIs.
+        HttpURLConnection httpUrlConnection = (HttpURLConnection) urlConnection;
+        assertEquals("POST", httpUrlConnection.getRequestMethod());
+        assertTrue(httpUrlConnection.getDoInput());
+        assertTrue(httpUrlConnection.getDoOutput());
+        return null;
+      }
+    };
+    client.setResponseCache(responseCache);
+
+    connection = client.open(serverUrl);
+
+    executePost(connection);
+  }
+
+  @Test public void get_https_allParameters() throws Exception {
+    final URL serverUrl = configureHttpsServer(new MockResponse());
+    assertEquals("https", serverUrl.getProtocol());
+
+    ResponseCache responseCache = new NoOpResponseCache() {
+      @Override
+      public CacheResponse get(URI uri, String method, Map<String, List<String>> headers) throws IOException {
+        assertEquals("https", uri.getScheme());
+        assertEquals(toUri(serverUrl), uri);
+        assertEquals("GET", method);
+        assertTrue("Arbitrary standard header not present", headers.containsKey("User-Agent"));
+        assertEquals(Collections.singletonList("value1"), headers.get("key1"));
+        return null;
+      }
+    };
+    client.setResponseCache(responseCache);
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+
+    connection = client.open(serverUrl);
+    connection.setRequestProperty("key1", "value1");
+
+    executeGet(connection);
+  }
+
+  @Test public void put_https_uriAndClass() throws Exception {
+    final URL serverUrl = configureHttpsServer(new MockResponse());
+    assertEquals("https", serverUrl.getProtocol());
+
+    ResponseCache responseCache = new NoOpResponseCache() {
+      @Override
+      public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
+        assertTrue(urlConnection instanceof HttpsURLConnection);
+        assertEquals(toUri(serverUrl), uri);
+        assertEquals(serverUrl, urlConnection.getURL());
+        return null;
+      }
+    };
+    client.setResponseCache(responseCache);
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+
+    connection = client.open(serverUrl);
+    executeGet(connection);
+  }
+
+  @Test public void put_https_extraHttpsMethods() throws Exception {
+    final URL serverUrl = configureHttpsServer(new MockResponse());
+    assertEquals("https", serverUrl.getProtocol());
+
+    ResponseCache responseCache = new NoOpResponseCache() {
+      @Override
+      public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
+        HttpsURLConnection cacheHttpsUrlConnection = (HttpsURLConnection) urlConnection;
+        HttpsURLConnection realHttpsUrlConnection = (HttpsURLConnection) connection;
+        assertEquals(realHttpsUrlConnection.getCipherSuite(),
+            cacheHttpsUrlConnection.getCipherSuite());
+        assertEquals(realHttpsUrlConnection.getPeerPrincipal(),
+            cacheHttpsUrlConnection.getPeerPrincipal());
+        assertArrayEquals(realHttpsUrlConnection.getLocalCertificates(),
+            cacheHttpsUrlConnection.getLocalCertificates());
+        assertArrayEquals(realHttpsUrlConnection.getServerCertificates(),
+            cacheHttpsUrlConnection.getServerCertificates());
+        assertEquals(realHttpsUrlConnection.getLocalPrincipal(),
+            cacheHttpsUrlConnection.getLocalPrincipal());
+        return null;
+      }
+    };
+    client.setResponseCache(responseCache);
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+
+    connection = client.open(serverUrl);
+    executeGet(connection);
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    recordedRequest.getSslProtocol();
+  }
+
+  @Test public void put_https_forbiddenFields() throws Exception {
+    final URL serverUrl = configureHttpsServer(new MockResponse());
+
+    ResponseCache responseCache = new NoOpResponseCache() {
+      @Override
+      public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
+        HttpsURLConnection httpsUrlConnection = (HttpsURLConnection) urlConnection;
+        try {
+          httpsUrlConnection.getHostnameVerifier();
+          fail();
+        } catch (UnsupportedOperationException expected) {
+        }
+        try {
+          httpsUrlConnection.getSSLSocketFactory();
+          fail();
+        } catch (UnsupportedOperationException expected) {
+        }
+        return null;
+      }
+    };
+    client.setResponseCache(responseCache);
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+
+    connection = client.open(serverUrl);
+    executeGet(connection);
+
+    RecordedRequest recordedRequest = server.takeRequest();
+    recordedRequest.getSslProtocol();
+  }
+
+  private void executeGet(HttpURLConnection connection) throws IOException {
+    connection.connect();
+    connection.getHeaderFields();
+    connection.disconnect();
+  }
+
+  private void executePost(HttpURLConnection connection) throws IOException {
+    connection.setDoOutput(true);
+    connection.connect();
+    connection.getOutputStream().write("Hello World".getBytes());
+    connection.disconnect();
+  }
+
+  private URL configureServer(MockResponse mockResponse) throws Exception {
+    server.enqueue(mockResponse);
+    server.play();
+    return server.getUrl("/");
+  }
+
+  private URL configureHttpsServer(MockResponse mockResponse) throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false /* tunnelProxy */);
+    server.enqueue(mockResponse);
+    server.play();
+    return server.getUrl("/");
+  }
+
+  private static class NoOpResponseCache extends ResponseCache {
+
+    @Override
+    public CacheResponse get(URI uri, String s, Map<String, List<String>> stringListMap)
+        throws IOException {
+      return null;
+    }
+
+    @Override
+    public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
+      return null;
+    }
+  }
+
+  private static URI toUri(URL serverUrl) {
+    try {
+      return serverUrl.toURI();
+    } catch (URISyntaxException e) {
+      fail(e.getMessage());
+      return null;
+    }
+  }
+
+  private static Set<String> newSet(String... elements) {
+    return new HashSet<String>(Arrays.asList(elements));
+  }
+}
diff --git a/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ResponseCacheTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ResponseCacheTest.java
new file mode 100644
index 0000000000..1cbd654560
--- /dev/null
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/ResponseCacheTest.java
@@ -0,0 +1,1747 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.ResponseSource;
+import com.squareup.okhttp.internal.SslContextBuilder;
+import com.squareup.okhttp.mockwebserver.MockResponse;
+import com.squareup.okhttp.mockwebserver.MockWebServer;
+import com.squareup.okhttp.mockwebserver.RecordedRequest;
+import java.io.BufferedReader;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.OutputStream;
+import java.net.CacheRequest;
+import java.net.CacheResponse;
+import java.net.CookieManager;
+import java.net.HttpCookie;
+import java.net.HttpURLConnection;
+import java.net.ResponseCache;
+import java.net.SecureCacheResponse;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.net.URLConnection;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.TimeZone;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.zip.GZIPOutputStream;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSession;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/**
+ * Tests for interaction between OkHttp and the ResponseCache. This test is based on
+ * {@link com.squareup.okhttp.internal.http.HttpResponseCacheTest}. Some tests for the
+ * {@link com.squareup.okhttp.OkResponseCache} found in HttpResponseCacheTest provide
+ * coverage for ResponseCache as well.
+ */
+public final class ResponseCacheTest {
+  private static final HostnameVerifier NULL_HOSTNAME_VERIFIER = new HostnameVerifier() {
+    @Override public boolean verify(String s, SSLSession sslSession) {
+      return true;
+    }
+  };
+
+  private static final SSLContext sslContext = SslContextBuilder.localhost();
+
+  private OkHttpClient client;
+  private MockWebServer server;
+  private MockWebServer server2;
+  private ResponseCache cache;
+
+  @Before public void setUp() throws Exception {
+    server =  new MockWebServer();
+    server.setNpnEnabled(false);
+    server2 =  new MockWebServer();
+
+    client = new OkHttpClient();
+    cache = new InMemoryResponseCache();
+    ResponseCache.setDefault(cache);
+  }
+
+  @After public void tearDown() throws Exception {
+    server.shutdown();
+    server2.shutdown();
+    CookieManager.setDefault(null);
+  }
+
+  private HttpURLConnection openConnection(URL url) {
+    return client.open(url);
+  }
+
+  @Test public void responseCacheAccessWithOkHttpMember() throws IOException {
+    ResponseCache.setDefault(null);
+    client.setResponseCache(cache);
+    assertSame(cache, client.getResponseCache());
+    assertTrue(client.getOkResponseCache() instanceof ResponseCacheAdapter);
+  }
+
+  @Test public void responseCacheAccessWithGlobalDefault() throws IOException {
+    ResponseCache.setDefault(cache);
+    client.setResponseCache(null);
+    assertNull(client.getOkResponseCache());
+    assertNull(client.getResponseCache());
+  }
+
+  @Test public void responseCachingAndInputStreamSkipWithFixedLength() throws IOException {
+    testResponseCaching(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void responseCachingAndInputStreamSkipWithChunkedEncoding() throws IOException {
+    testResponseCaching(TransferKind.CHUNKED);
+  }
+
+  @Test public void responseCachingAndInputStreamSkipWithNoLengthHeaders() throws IOException {
+    testResponseCaching(TransferKind.END_OF_STREAM);
+  }
+
+  /**
+   * HttpURLConnection.getInputStream().skip(long) causes ResponseCache corruption
+   * http://code.google.com/p/android/issues/detail?id=8175
+   */
+  private void testResponseCaching(TransferKind transferKind) throws IOException {
+    MockResponse response =
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+            .setStatus("HTTP/1.1 200 Fantastic");
+    transferKind.setBody(response, "I love puppies but hate spiders", 1);
+    server.enqueue(response);
+    server.play();
+
+    // Make sure that calling skip() doesn't omit bytes from the cache.
+    HttpURLConnection urlConnection = openConnection(server.getUrl("/"));
+    InputStream in = urlConnection.getInputStream();
+    assertEquals("I love ", readAscii(urlConnection, "I love ".length()));
+    reliableSkip(in, "puppies but hate ".length());
+    assertEquals("spiders", readAscii(urlConnection, "spiders".length()));
+    assertEquals(-1, in.read());
+    in.close();
+
+    urlConnection = openConnection(server.getUrl("/")); // cached!
+    in = urlConnection.getInputStream();
+    assertEquals("I love puppies but hate spiders",
+        readAscii(urlConnection, "I love puppies but hate spiders".length()));
+    assertEquals(200, urlConnection.getResponseCode());
+    assertEquals("Fantastic", urlConnection.getResponseMessage());
+
+    assertEquals(-1, in.read());
+    in.close();
+  }
+
+  @Test public void secureResponseCaching() throws IOException {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+    server.play();
+
+    HttpsURLConnection c1 = (HttpsURLConnection) openConnection(server.getUrl("/"));
+    c1.setSSLSocketFactory(sslContext.getSocketFactory());
+    c1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    assertEquals("ABC", readAscii(c1));
+
+    // OpenJDK 6 fails on this line, complaining that the connection isn't open yet
+    String suite = c1.getCipherSuite();
+    List<Certificate> localCerts = toListOrNull(c1.getLocalCertificates());
+    List<Certificate> serverCerts = toListOrNull(c1.getServerCertificates());
+    Principal peerPrincipal = c1.getPeerPrincipal();
+    Principal localPrincipal = c1.getLocalPrincipal();
+
+    HttpsURLConnection c2 = (HttpsURLConnection) openConnection(server.getUrl("/")); // cached!
+    c2.setSSLSocketFactory(sslContext.getSocketFactory());
+    c2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    assertEquals("ABC", readAscii(c2));
+
+    assertEquals(suite, c2.getCipherSuite());
+    assertEquals(localCerts, toListOrNull(c2.getLocalCertificates()));
+    assertEquals(serverCerts, toListOrNull(c2.getServerCertificates()));
+    assertEquals(peerPrincipal, c2.getPeerPrincipal());
+    assertEquals(localPrincipal, c2.getLocalPrincipal());
+  }
+
+  @Test public void cacheReturnsInsecureResponseForSecureRequest() throws IOException {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse().setBody("ABC"));
+    server.enqueue(new MockResponse().setBody("DEF"));
+    server.play();
+
+    client.setResponseCache(new InsecureResponseCache(new InMemoryResponseCache()));
+
+    HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.getUrl("/"));
+    connection1.setSSLSocketFactory(sslContext.getSocketFactory());
+    connection1.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    assertEquals("ABC", readAscii(connection1));
+
+    // Not cached!
+    HttpsURLConnection connection2 = (HttpsURLConnection) openConnection(server.getUrl("/"));
+    connection2.setSSLSocketFactory(sslContext.getSocketFactory());
+    connection2.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+    assertEquals("DEF", readAscii(connection2));
+  }
+
+  @Test public void responseCachingAndRedirects() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+    server.enqueue(new MockResponse().setBody("DEF"));
+    server.play();
+
+    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("ABC", readAscii(connection));
+
+    connection = openConnection(server.getUrl("/")); // cached!
+    assertEquals("ABC", readAscii(connection));
+  }
+
+  @Test public void redirectToCachedResult() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60").setBody("ABC"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse().setBody("DEF"));
+    server.play();
+
+    assertEquals("ABC", readAscii(openConnection(server.getUrl("/foo"))));
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("GET /foo HTTP/1.1", request1.getRequestLine());
+    assertEquals(0, request1.getSequenceNumber());
+
+    assertEquals("ABC", readAscii(openConnection(server.getUrl("/bar"))));
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("GET /bar HTTP/1.1", request2.getRequestLine());
+    assertEquals(1, request2.getSequenceNumber());
+
+    // an unrelated request should reuse the pooled connection
+    assertEquals("DEF", readAscii(openConnection(server.getUrl("/baz"))));
+    RecordedRequest request3 = server.takeRequest();
+    assertEquals("GET /baz HTTP/1.1", request3.getRequestLine());
+    assertEquals(2, request3.getSequenceNumber());
+  }
+
+  @Test public void secureResponseCachingAndRedirects() throws IOException {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: /foo"));
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+    server.enqueue(new MockResponse().setBody("DEF"));
+    server.play();
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+
+    HttpsURLConnection connection1 = (HttpsURLConnection) openConnection(server.getUrl("/"));
+    assertEquals("ABC", readAscii(connection1));
+    assertNotNull(connection1.getCipherSuite());
+
+    // Cached!
+    HttpsURLConnection connection2 = (HttpsURLConnection) openConnection(server.getUrl("/"));
+    assertEquals("ABC", readAscii(connection2));
+    assertNotNull(connection2.getCipherSuite());
+
+    assertEquals(connection1.getCipherSuite(), connection2.getCipherSuite());
+  }
+
+  /**
+   * We've had bugs where caching and cross-protocol redirects yield class
+   * cast exceptions internal to the cache because we incorrectly assumed that
+   * HttpsURLConnection was always HTTPS and HttpURLConnection was always HTTP;
+   * in practice redirects mean that each can do either.
+   *
+   * https://github.com/square/okhttp/issues/214
+   */
+  @Test public void secureResponseCachingAndProtocolRedirects() throws IOException {
+    server2.useHttps(sslContext.getSocketFactory(), false);
+    server2.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setBody("ABC"));
+    server2.enqueue(new MockResponse().setBody("DEF"));
+    server2.play();
+
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_PERM)
+        .addHeader("Location: " + server2.getUrl("/")));
+    server.play();
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(NULL_HOSTNAME_VERIFIER);
+
+    HttpURLConnection connection1 = openConnection(server.getUrl("/"));
+    assertEquals("ABC", readAscii(connection1));
+
+    // Cached!
+    HttpURLConnection connection2 = openConnection(server.getUrl("/"));
+    assertEquals("ABC", readAscii(connection2));
+  }
+
+  @Test public void responseCacheRequestHeaders() throws IOException, URISyntaxException {
+    server.enqueue(new MockResponse().setBody("ABC"));
+    server.play();
+
+    final AtomicReference<Map<String, List<String>>> requestHeadersRef =
+        new AtomicReference<Map<String, List<String>>>();
+    client.setResponseCache(new ResponseCache() {
+      @Override
+      public CacheResponse get(URI uri, String requestMethod,
+          Map<String, List<String>> requestHeaders) throws IOException {
+        requestHeadersRef.set(requestHeaders);
+        return null;
+      }
+
+      @Override
+      public CacheRequest put(URI uri, URLConnection conn) throws IOException {
+        return null;
+      }
+    });
+
+    URL url = server.getUrl("/");
+    URLConnection urlConnection = openConnection(url);
+    urlConnection.addRequestProperty("A", "android");
+    readAscii(urlConnection);
+    assertEquals(Arrays.asList("android"), requestHeadersRef.get().get("A"));
+  }
+
+  @Test public void serverDisconnectsPrematurelyWithContentLengthHeader() throws IOException {
+    testServerPrematureDisconnect(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void serverDisconnectsPrematurelyWithChunkedEncoding() throws IOException {
+    testServerPrematureDisconnect(TransferKind.CHUNKED);
+  }
+
+  @Test public void serverDisconnectsPrematurelyWithNoLengthHeaders() throws IOException {
+    // Intentionally empty. This case doesn't make sense because there's no
+    // such thing as a premature disconnect when the disconnect itself
+    // indicates the end of the data stream.
+  }
+
+  private void testServerPrematureDisconnect(TransferKind transferKind) throws IOException {
+    MockResponse response = new MockResponse();
+    transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 16);
+    server.enqueue(truncateViolently(response, 16));
+    server.enqueue(new MockResponse().setBody("Request #2"));
+    server.play();
+
+    BufferedReader reader = new BufferedReader(
+        new InputStreamReader(openConnection(server.getUrl("/")).getInputStream()));
+    assertEquals("ABCDE", reader.readLine());
+    try {
+      reader.readLine();
+      fail("This implementation silently ignored a truncated HTTP body.");
+    } catch (IOException expected) {
+        expected.printStackTrace();
+    } finally {
+      reader.close();
+    }
+
+    URLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("Request #2", readAscii(connection));
+  }
+
+  @Test public void clientPrematureDisconnectWithContentLengthHeader() throws IOException {
+    testClientPrematureDisconnect(TransferKind.FIXED_LENGTH);
+  }
+
+  @Test public void clientPrematureDisconnectWithChunkedEncoding() throws IOException {
+    testClientPrematureDisconnect(TransferKind.CHUNKED);
+  }
+
+  @Test public void clientPrematureDisconnectWithNoLengthHeaders() throws IOException {
+    testClientPrematureDisconnect(TransferKind.END_OF_STREAM);
+  }
+
+  private void testClientPrematureDisconnect(TransferKind transferKind) throws IOException {
+    // Setting a low transfer speed ensures that stream discarding will time out.
+    MockResponse response = new MockResponse().throttleBody(6, 1, TimeUnit.SECONDS);
+    transferKind.setBody(response, "ABCDE\nFGHIJKLMNOPQRSTUVWXYZ", 1024);
+    server.enqueue(response);
+    server.enqueue(new MockResponse().setBody("Request #2"));
+    server.play();
+
+    URLConnection connection = openConnection(server.getUrl("/"));
+    InputStream in = connection.getInputStream();
+    assertEquals("ABCDE", readAscii(connection, 5));
+    in.close();
+    try {
+      in.read();
+      fail("Expected an IOException because the stream is closed.");
+    } catch (IOException expected) {
+    }
+
+    connection = openConnection(server.getUrl("/"));
+    assertEquals("Request #2", readAscii(connection));
+  }
+
+  @Test public void defaultExpirationDateFullyCachedForLessThan24Hours() throws Exception {
+    //      last modified: 105 seconds ago
+    //             served:   5 seconds ago
+    //   default lifetime: (105 - 5) / 10 = 10 seconds
+    //            expires:  10 seconds from served date = 5 seconds from now
+    server.enqueue(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
+            .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
+            .setBody("A"));
+    server.play();
+
+    URL url = server.getUrl("/");
+    assertEquals("A", readAscii(openConnection(url)));
+    URLConnection connection = openConnection(url);
+    assertEquals("A", readAscii(connection));
+    assertNull(connection.getHeaderField("Warning"));
+  }
+
+  @Test public void defaultExpirationDateConditionallyCached() throws Exception {
+    //      last modified: 115 seconds ago
+    //             served:  15 seconds ago
+    //   default lifetime: (115 - 15) / 10 = 10 seconds
+    //            expires:  10 seconds from served date = 5 seconds ago
+    String lastModifiedDate = formatDate(-115, TimeUnit.SECONDS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(
+        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
+            .addHeader("Date: " + formatDate(-15, TimeUnit.SECONDS)));
+    List<String> headers = conditionalRequest.getHeaders();
+    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+  }
+
+  @Test public void defaultExpirationDateFullyCachedForMoreThan24Hours() throws Exception {
+    //      last modified: 105 days ago
+    //             served:   5 days ago
+    //   default lifetime: (105 - 5) / 10 = 10 days
+    //            expires:  10 days from served date = 5 days from now
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.DAYS))
+        .addHeader("Date: " + formatDate(-5, TimeUnit.DAYS))
+        .setBody("A"));
+    server.play();
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    URLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(connection));
+    assertEquals("113 HttpURLConnection \"Heuristic expiration\"",
+        connection.getHeaderField("Warning"));
+  }
+
+  @Test public void noDefaultExpirationForUrlsWithQueryString() throws Exception {
+    server.enqueue(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-105, TimeUnit.SECONDS))
+            .addHeader("Date: " + formatDate(-5, TimeUnit.SECONDS))
+            .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+    server.play();
+
+    URL url = server.getUrl("/?foo=bar");
+    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("B", readAscii(openConnection(url)));
+  }
+
+  @Test public void expirationDateInThePastWithLastModifiedHeader() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(
+        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
+            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    List<String> headers = conditionalRequest.getHeaders();
+    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+  }
+
+  @Test public void expirationDateInThePastWithNoLastModifiedHeader() throws Exception {
+    assertNotCached(new MockResponse().addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+  }
+
+  @Test public void expirationDateInTheFuture() throws Exception {
+    assertFullyCached(new MockResponse().addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+  }
+
+  @Test public void maxAgePreferredWithMaxAgeAndExpires() throws Exception {
+    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInThePastWithDateAndLastModifiedHeaders() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(
+        new MockResponse().addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
+            .addHeader("Last-Modified: " + lastModifiedDate)
+            .addHeader("Cache-Control: max-age=60"));
+    List<String> headers = conditionalRequest.getHeaders();
+    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+  }
+
+  @Test public void maxAgeInThePastWithDateHeaderButNoLastModifiedHeader() throws Exception {
+    // Chrome interprets max-age relative to the local clock. Both our cache
+    // and Firefox both use the earlier of the local and server's clock.
+    assertNotCached(new MockResponse().addHeader("Date: " + formatDate(-120, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInTheFutureWithDateHeader() throws Exception {
+    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInTheFutureWithNoDateHeader() throws Exception {
+    assertFullyCached(new MockResponse().addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeWithLastModifiedButNoServedDate() throws Exception {
+    assertFullyCached(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+            .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgeInTheFutureWithDateAndLastModifiedHeaders() throws Exception {
+    assertFullyCached(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+            .addHeader("Cache-Control: max-age=60"));
+  }
+
+  @Test public void maxAgePreferredOverLowerSharedMaxAge() throws Exception {
+    assertFullyCached(new MockResponse().addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+        .addHeader("Cache-Control: s-maxage=60")
+        .addHeader("Cache-Control: max-age=180"));
+  }
+
+  @Test public void maxAgePreferredOverHigherMaxAge() throws Exception {
+    assertNotCached(new MockResponse().addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+        .addHeader("Cache-Control: s-maxage=180")
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  /**
+   * Tests that the ResponseCache can cache something. The InMemoryResponseCache only caches GET
+   * requests.
+   */
+  @Test public void responseCacheCanCache() throws Exception {
+    testRequestMethod("GET", true);
+  }
+
+  /**
+   * Confirm the ResponseCache can elect to not cache something. The InMemoryResponseCache only
+   * caches GET requests.
+   */
+  @Test public void responseCacheCanIgnore() throws Exception {
+    testRequestMethod("HEAD", false);
+  }
+
+  private void testRequestMethod(String requestMethod, boolean expectCached) throws Exception {
+    // 1. seed the cache (potentially)
+    // 2. expect a cache hit or miss
+    server.enqueue(new MockResponse().addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("X-Response-ID: 1"));
+    server.enqueue(new MockResponse().addHeader("X-Response-ID: 2"));
+    server.play();
+
+    URL url = server.getUrl("/");
+
+    HttpURLConnection request1 = openConnection(url);
+    request1.setRequestMethod(requestMethod);
+    addRequestBodyIfNecessary(requestMethod, request1);
+    assertEquals("1", request1.getHeaderField("X-Response-ID"));
+
+    URLConnection request2 = openConnection(url);
+    if (expectCached) {
+      assertEquals("1", request2.getHeaderField("X-Response-ID"));
+    } else {
+      assertEquals("2", request2.getHeaderField("X-Response-ID"));
+    }
+  }
+
+  /**
+   * Equivalent to {@link HttpResponseCacheTest#postInvalidatesCacheWithUncacheableResponse()} but
+   * demonstrating that {@link ResponseCache} provides no mechanism for cache invalidation as the
+   * result of locally-made requests. In reality invalidation could take place from other clients at
+   * any time.
+   */
+  @Test public void postInvalidatesCacheWithUncacheableResponse() throws Exception {
+    // 1. seed the cache
+    // 2. invalidate it with uncacheable response
+    // 3. the cache to return the original value
+    server.enqueue(
+        new MockResponse().setBody("A").addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse().setBody("B").setResponseCode(500));
+    server.play();
+
+    URL url = server.getUrl("/");
+
+    assertEquals("A", readAscii(openConnection(url)));
+
+    HttpURLConnection invalidate = openConnection(url);
+    invalidate.setRequestMethod("POST");
+    addRequestBodyIfNecessary("POST", invalidate);
+    assertEquals("B", readAscii(invalidate));
+
+    assertEquals("A", readAscii(openConnection(url)));
+  }
+
+  @Test public void etag() throws Exception {
+    RecordedRequest conditionalRequest =
+        assertConditionallyCached(new MockResponse().addHeader("ETag: v1"));
+    assertTrue(conditionalRequest.getHeaders().contains("If-None-Match: v1"));
+  }
+
+  @Test public void etagAndExpirationDateInThePast() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(
+        new MockResponse().addHeader("ETag: v1")
+            .addHeader("Last-Modified: " + lastModifiedDate)
+            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    List<String> headers = conditionalRequest.getHeaders();
+    assertTrue(headers.contains("If-None-Match: v1"));
+    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+  }
+
+  @Test public void etagAndExpirationDateInTheFuture() throws Exception {
+    assertFullyCached(new MockResponse().addHeader("ETag: v1")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+  }
+
+  @Test public void cacheControlNoCache() throws Exception {
+    assertNotCached(new MockResponse().addHeader("Cache-Control: no-cache"));
+  }
+
+  @Test public void cacheControlNoCacheAndExpirationDateInTheFuture() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(
+        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
+            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+            .addHeader("Cache-Control: no-cache"));
+    List<String> headers = conditionalRequest.getHeaders();
+    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+  }
+
+  @Test public void pragmaNoCache() throws Exception {
+    assertNotCached(new MockResponse().addHeader("Pragma: no-cache"));
+  }
+
+  @Test public void pragmaNoCacheAndExpirationDateInTheFuture() throws Exception {
+    String lastModifiedDate = formatDate(-2, TimeUnit.HOURS);
+    RecordedRequest conditionalRequest = assertConditionallyCached(
+        new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
+            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+            .addHeader("Pragma: no-cache"));
+    List<String> headers = conditionalRequest.getHeaders();
+    assertTrue(headers.contains("If-Modified-Since: " + lastModifiedDate));
+  }
+
+  @Test public void cacheControlNoStore() throws Exception {
+    assertNotCached(new MockResponse().addHeader("Cache-Control: no-store"));
+  }
+
+  @Test public void cacheControlNoStoreAndExpirationDateInTheFuture() throws Exception {
+    assertNotCached(new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: no-store"));
+  }
+
+  @Test public void partialRangeResponsesDoNotCorruptCache() throws Exception {
+    // 1. request a range
+    // 2. request a full document, expecting a cache miss
+    server.enqueue(new MockResponse().setBody("AA")
+        .setResponseCode(HttpURLConnection.HTTP_PARTIAL)
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS))
+        .addHeader("Content-Range: bytes 1000-1001/2000"));
+    server.enqueue(new MockResponse().setBody("BB"));
+    server.play();
+
+    URL url = server.getUrl("/");
+
+    URLConnection range = openConnection(url);
+    range.addRequestProperty("Range", "bytes=1000-1001");
+    assertEquals("AA", readAscii(range));
+
+    assertEquals("BB", readAscii(openConnection(url)));
+  }
+
+  @Test public void serverReturnsDocumentOlderThanCache() throws Exception {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse().setBody("B")
+        .addHeader("Last-Modified: " + formatDate(-4, TimeUnit.HOURS)));
+    server.play();
+
+    URL url = server.getUrl("/");
+
+    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(openConnection(url)));
+  }
+
+  @Test public void nonIdentityEncodingAndConditionalCache() throws Exception {
+    assertNonIdentityEncodingCached(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+            .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+  }
+
+  @Test public void nonIdentityEncodingAndFullCache() throws Exception {
+    assertNonIdentityEncodingCached(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+            .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+  }
+
+  private void assertNonIdentityEncodingCached(MockResponse response) throws Exception {
+    server.enqueue(
+        response.setBody(gzip("ABCABCABC".getBytes("UTF-8"))).addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    server.play();
+
+    // At least three request/response pairs are required because after the first request is cached
+    // a different execution path might be taken. Thus modifications to the cache applied during
+    // the second request might not be visible until another request is performed.
+    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
+  }
+
+  @Test public void notModifiedSpecifiesEncoding() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody(gzip("ABCABCABC".getBytes("UTF-8")))
+        .addHeader("Content-Encoding: gzip")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Expires: " + formatDate(-1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED)
+        .addHeader("Content-Encoding: gzip"));
+    server.enqueue(new MockResponse()
+        .setBody("DEFDEFDEF"));
+
+    server.play();
+    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("ABCABCABC", readAscii(openConnection(server.getUrl("/"))));
+    assertEquals("DEFDEFDEF", readAscii(openConnection(server.getUrl("/"))));
+  }
+
+  @Test public void expiresDateBeforeModifiedDate() throws Exception {
+    assertConditionallyCached(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+            .addHeader("Expires: " + formatDate(-2, TimeUnit.HOURS)));
+  }
+
+  @Test public void requestMaxAge() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Last-Modified: " + formatDate(-2, TimeUnit.HOURS))
+        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES))
+        .addHeader("Expires: " + formatDate(1, TimeUnit.HOURS)));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    server.play();
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+
+    URLConnection connection = openConnection(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "max-age=30");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void requestMinFresh() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=60")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    server.play();
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+
+    URLConnection connection = openConnection(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "min-fresh=120");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void requestMaxStale() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=120")
+        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    server.play();
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+
+    URLConnection connection = openConnection(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "max-stale=180");
+    assertEquals("A", readAscii(connection));
+    assertEquals("110 HttpURLConnection \"Response is stale\"",
+        connection.getHeaderField("Warning"));
+  }
+
+  @Test public void requestMaxStaleNotHonoredWithMustRevalidate() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=120, must-revalidate")
+        .addHeader("Date: " + formatDate(-4, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse().setBody("B"));
+
+    server.play();
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+
+    URLConnection connection = openConnection(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "max-stale=180");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void requestOnlyIfCachedWithNoResponseCached() throws IOException {
+    // (no responses enqueued)
+    server.play();
+
+    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertGatewayTimeout(connection);
+  }
+
+  @Test public void requestOnlyIfCachedWithFullResponseCached() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+    server.play();
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    URLConnection connection = openConnection(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertEquals("A", readAscii(connection));
+  }
+
+  @Test public void requestOnlyIfCachedWithConditionalResponseCached() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(-1, TimeUnit.MINUTES)));
+    server.play();
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertGatewayTimeout(connection);
+  }
+
+  @Test public void requestOnlyIfCachedWithUnhelpfulResponseCached() throws IOException {
+    server.enqueue(new MockResponse().setBody("A"));
+    server.play();
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertGatewayTimeout(connection);
+  }
+
+  @Test public void requestCacheControlNoCache() throws Exception {
+    server.enqueue(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+            .addHeader("Cache-Control: max-age=60")
+            .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+    server.play();
+
+    URL url = server.getUrl("/");
+    assertEquals("A", readAscii(openConnection(url)));
+    URLConnection connection = openConnection(url);
+    connection.setRequestProperty("Cache-Control", "no-cache");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void requestPragmaNoCache() throws Exception {
+    server.enqueue(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-120, TimeUnit.SECONDS))
+            .addHeader("Date: " + formatDate(0, TimeUnit.SECONDS))
+            .addHeader("Cache-Control: max-age=60")
+            .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+    server.play();
+
+    URL url = server.getUrl("/");
+    assertEquals("A", readAscii(openConnection(url)));
+    URLConnection connection = openConnection(url);
+    connection.setRequestProperty("Pragma", "no-cache");
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void clientSuppliedIfModifiedSinceWithCachedResult() throws Exception {
+    MockResponse response =
+        new MockResponse().addHeader("ETag: v3").addHeader("Cache-Control: max-age=0");
+    String ifModifiedSinceDate = formatDate(-24, TimeUnit.HOURS);
+    RecordedRequest request =
+        assertClientSuppliedCondition(response, "If-Modified-Since", ifModifiedSinceDate);
+    List<String> headers = request.getHeaders();
+    assertTrue(headers.contains("If-Modified-Since: " + ifModifiedSinceDate));
+    assertFalse(headers.contains("If-None-Match: v3"));
+  }
+
+  @Test public void clientSuppliedIfNoneMatchSinceWithCachedResult() throws Exception {
+    String lastModifiedDate = formatDate(-3, TimeUnit.MINUTES);
+    MockResponse response = new MockResponse().addHeader("Last-Modified: " + lastModifiedDate)
+        .addHeader("Date: " + formatDate(-2, TimeUnit.MINUTES))
+        .addHeader("Cache-Control: max-age=0");
+    RecordedRequest request = assertClientSuppliedCondition(response, "If-None-Match", "v1");
+    List<String> headers = request.getHeaders();
+    assertTrue(headers.contains("If-None-Match: v1"));
+    assertFalse(headers.contains("If-Modified-Since: " + lastModifiedDate));
+  }
+
+  private RecordedRequest assertClientSuppliedCondition(MockResponse seed, String conditionName,
+      String conditionValue) throws Exception {
+    server.enqueue(seed.setBody("A"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.play();
+
+    URL url = server.getUrl("/");
+    assertEquals("A", readAscii(openConnection(url)));
+
+    HttpURLConnection connection = openConnection(url);
+    connection.addRequestProperty(conditionName, conditionValue);
+    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
+    assertEquals("", readAscii(connection));
+
+    server.takeRequest(); // seed
+    return server.takeRequest();
+  }
+
+  @Test public void setIfModifiedSince() throws Exception {
+    Date since = new Date();
+    server.enqueue(new MockResponse().setBody("A"));
+    server.play();
+
+    URL url = server.getUrl("/");
+    URLConnection connection = openConnection(url);
+    connection.setIfModifiedSince(since.getTime());
+    assertEquals("A", readAscii(connection));
+    RecordedRequest request = server.takeRequest();
+    assertTrue(request.getHeaders().contains("If-Modified-Since: " + formatDate(since)));
+  }
+
+  @Test public void clientSuppliedConditionWithoutCachedResult() throws Exception {
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.play();
+
+    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    String clientIfModifiedSince = formatDate(-24, TimeUnit.HOURS);
+    connection.addRequestProperty("If-Modified-Since", clientIfModifiedSince);
+    assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection.getResponseCode());
+    assertEquals("", readAscii(connection));
+  }
+
+  @Test public void authorizationRequestHeaderPreventsCaching() throws Exception {
+    server.enqueue(
+        new MockResponse().addHeader("Last-Modified: " + formatDate(-2, TimeUnit.MINUTES))
+            .addHeader("Cache-Control: max-age=60")
+            .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+    server.play();
+
+    URL url = server.getUrl("/");
+    URLConnection connection = openConnection(url);
+    connection.addRequestProperty("Authorization", "password");
+    assertEquals("A", readAscii(connection));
+    assertEquals("B", readAscii(openConnection(url)));
+  }
+
+  @Test public void authorizationResponseCachedWithSMaxAge() throws Exception {
+    assertAuthorizationRequestFullyCached(
+        new MockResponse().addHeader("Cache-Control: s-maxage=60"));
+  }
+
+  @Test public void authorizationResponseCachedWithPublic() throws Exception {
+    assertAuthorizationRequestFullyCached(new MockResponse().addHeader("Cache-Control: public"));
+  }
+
+  @Test public void authorizationResponseCachedWithMustRevalidate() throws Exception {
+    assertAuthorizationRequestFullyCached(
+        new MockResponse().addHeader("Cache-Control: must-revalidate"));
+  }
+
+  public void assertAuthorizationRequestFullyCached(MockResponse response) throws Exception {
+    server.enqueue(response.addHeader("Cache-Control: max-age=60").setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+    server.play();
+
+    URL url = server.getUrl("/");
+    URLConnection connection = openConnection(url);
+    connection.addRequestProperty("Authorization", "password");
+    assertEquals("A", readAscii(connection));
+    assertEquals("A", readAscii(openConnection(url)));
+  }
+
+  @Test public void contentLocationDoesNotPopulateCache() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=60")
+        .addHeader("Content-Location: /bar")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+    server.play();
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/foo"))));
+    assertEquals("B", readAscii(openConnection(server.getUrl("/bar"))));
+  }
+
+  @Test public void useCachesFalseDoesNotWriteToCache() throws Exception {
+    server.enqueue(
+        new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+    server.play();
+
+    URLConnection connection = openConnection(server.getUrl("/"));
+    connection.setUseCaches(false);
+    assertEquals("A", readAscii(connection));
+    assertEquals("B", readAscii(openConnection(server.getUrl("/"))));
+  }
+
+  @Test public void useCachesFalseDoesNotReadFromCache() throws Exception {
+    server.enqueue(
+        new MockResponse().addHeader("Cache-Control: max-age=60").setBody("A").setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+    server.play();
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    URLConnection connection = openConnection(server.getUrl("/"));
+    connection.setUseCaches(false);
+    assertEquals("B", readAscii(connection));
+  }
+
+  @Test public void defaultUseCachesSetsInitialValueOnly() throws Exception {
+    URL url = new URL("http://localhost/");
+    URLConnection c1 = openConnection(url);
+    URLConnection c2 = openConnection(url);
+    assertTrue(c1.getDefaultUseCaches());
+    c1.setDefaultUseCaches(false);
+    try {
+      assertTrue(c1.getUseCaches());
+      assertTrue(c2.getUseCaches());
+      URLConnection c3 = openConnection(url);
+      assertFalse(c3.getUseCaches());
+    } finally {
+      c1.setDefaultUseCaches(true);
+    }
+  }
+
+  @Test public void connectionIsReturnedToPoolAfterConditionalSuccess() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.enqueue(new MockResponse().setBody("B"));
+    server.play();
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/a"))));
+    assertEquals("A", readAscii(openConnection(server.getUrl("/a"))));
+    assertEquals("B", readAscii(openConnection(server.getUrl("/b"))));
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(1, server.takeRequest().getSequenceNumber());
+    assertEquals(2, server.takeRequest().getSequenceNumber());
+  }
+
+  /**
+   * Confirms the cache implementation may determine the criteria for caching. In real caches
+   * this would be the "Vary" headers.
+   */
+  @Test public void cacheCanUseCriteriaBesidesVariantObeyed() throws Exception {
+    server.enqueue(
+        new MockResponse().addHeader("Cache-Control: max-age=60")
+            .addHeader(InMemoryResponseCache.CACHE_VARIANT_HEADER, "A").setBody("A"));
+    server.enqueue(
+        new MockResponse().addHeader("Cache-Control: max-age=60")
+            .addHeader(InMemoryResponseCache.CACHE_VARIANT_HEADER, "B").setBody("B"));
+    server.play();
+
+    URL url = server.getUrl("/");
+    URLConnection connection1 = openConnection(url);
+    connection1.addRequestProperty(InMemoryResponseCache.CACHE_VARIANT_HEADER, "A");
+    assertEquals("A", readAscii(connection1));
+    URLConnection connection2 = openConnection(url);
+    connection2.addRequestProperty(InMemoryResponseCache.CACHE_VARIANT_HEADER, "A");
+    assertEquals("A", readAscii(connection2));
+    assertEquals(1, server.getRequestCount());
+
+    URLConnection connection3 = openConnection(url);
+    connection3.addRequestProperty(InMemoryResponseCache.CACHE_VARIANT_HEADER, "B");
+    assertEquals("B", readAscii(connection3));
+    assertEquals(2, server.getRequestCount());
+
+    URLConnection connection4 = openConnection(url);
+    connection4.addRequestProperty(InMemoryResponseCache.CACHE_VARIANT_HEADER, "A");
+    assertEquals("A", readAscii(connection4));
+    assertEquals(2, server.getRequestCount());
+  }
+
+  @Test public void cachePlusCookies() throws Exception {
+    server.enqueue(new MockResponse().addHeader(
+        "Set-Cookie: a=FIRST; domain=" + server.getCookieDomain() + ";")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().addHeader(
+        "Set-Cookie: a=SECOND; domain=" + server.getCookieDomain() + ";")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.play();
+
+    CookieManager cookieManager = new CookieManager();
+    CookieManager.setDefault(cookieManager);
+
+    URL url = server.getUrl("/");
+    assertEquals("A", readAscii(openConnection(url)));
+    assertCookies(cookieManager, url, "a=FIRST");
+    assertEquals("A", readAscii(openConnection(url)));
+    assertCookies(cookieManager, url, "a=SECOND");
+  }
+
+  @Test public void getHeadersReturnsNetworkEndToEndHeaders() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Allow: GET, HEAD")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().addHeader("Allow: GET, HEAD, PUT")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.play();
+
+    URLConnection connection1 = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(connection1));
+    assertEquals("GET, HEAD", connection1.getHeaderField("Allow"));
+
+    URLConnection connection2 = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(connection2));
+    assertEquals("GET, HEAD, PUT", connection2.getHeaderField("Allow"));
+  }
+
+  @Test public void getHeadersReturnsCachedHopByHopHeaders() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Transfer-Encoding: identity")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().addHeader("Transfer-Encoding: none")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.play();
+
+    URLConnection connection1 = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(connection1));
+    assertEquals("identity", connection1.getHeaderField("Transfer-Encoding"));
+
+    URLConnection connection2 = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(connection2));
+    assertEquals("identity", connection2.getHeaderField("Transfer-Encoding"));
+  }
+
+  @Test public void getHeadersDeletesCached100LevelWarnings() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Warning: 199 test danger")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.play();
+
+    URLConnection connection1 = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(connection1));
+    assertEquals("199 test danger", connection1.getHeaderField("Warning"));
+
+    URLConnection connection2 = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(connection2));
+    assertEquals(null, connection2.getHeaderField("Warning"));
+  }
+
+  @Test public void getHeadersRetainsCached200LevelWarnings() throws Exception {
+    server.enqueue(new MockResponse().addHeader("Warning: 299 test danger")
+        .addHeader("Last-Modified: " + formatDate(-1, TimeUnit.HOURS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    server.play();
+
+    URLConnection connection1 = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(connection1));
+    assertEquals("299 test danger", connection1.getHeaderField("Warning"));
+
+    URLConnection connection2 = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(connection2));
+    assertEquals("299 test danger", connection2.getHeaderField("Warning"));
+  }
+
+  public void assertCookies(CookieManager cookieManager, URL url, String... expectedCookies)
+      throws Exception {
+    List<String> actualCookies = new ArrayList<String>();
+    for (HttpCookie cookie : cookieManager.getCookieStore().get(url.toURI())) {
+      actualCookies.add(cookie.toString());
+    }
+    assertEquals(Arrays.asList(expectedCookies), actualCookies);
+  }
+
+  @Test public void cachePlusRange() throws Exception {
+    assertNotCached(new MockResponse().setResponseCode(HttpURLConnection.HTTP_PARTIAL)
+        .addHeader("Date: " + formatDate(0, TimeUnit.HOURS))
+        .addHeader("Content-Range: bytes 100-100/200")
+        .addHeader("Cache-Control: max-age=60"));
+  }
+
+  /**
+   * Equivalent to {@link HttpResponseCacheTest#conditionalHitUpdatesCache()}, except a Java
+   * standard cache has no means to update the headers for an existing entry so the behavior is
+   * different.
+   */
+  @Test public void conditionalHitDoesNotUpdateCache() throws Exception {
+    // A response that is cacheable, but with a short life.
+    server.enqueue(new MockResponse().addHeader("Last-Modified: " + formatDate(0, TimeUnit.SECONDS))
+        .addHeader("Cache-Control: max-age=0")
+        .setBody("A"));
+    // A response that refers to the previous response, but is cacheable with a long life.
+    // Contains a header we can recognize as having come from the server.
+    server.enqueue(new MockResponse().addHeader("Cache-Control: max-age=30")
+        .addHeader("Allow: GET, HEAD")
+        .setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+    // A response that is cacheable with a long life.
+    server.enqueue(new MockResponse().setBody("B").addHeader("Cache-Control: max-age=30"));
+    // A response that should never be requested.
+    server.enqueue(new MockResponse().setBody("C"));
+    server.play();
+
+    // cache miss; seed the cache with an entry that will require a network hit to be sure it is
+    // still valid
+    HttpURLConnection connection1 = openConnection(server.getUrl("/a"));
+    assertEquals("A", readAscii(connection1));
+    assertEquals(null, connection1.getHeaderField("Allow"));
+
+    // conditional cache hit; The cached data should be returned, but the cache is not updated.
+    HttpURLConnection connection2 = openConnection(server.getUrl("/a"));
+    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
+    assertEquals("A", readAscii(connection2));
+    assertEquals("GET, HEAD", connection2.getHeaderField("Allow"));
+
+    // conditional cache hit; The server responds with new data. The cache is updated.
+    HttpURLConnection connection3 = openConnection(server.getUrl("/a"));
+    assertEquals("B", readAscii(connection3));
+
+    // full cache hit; The data from connection3 has now replaced that from connection 1.
+    HttpURLConnection connection4 = openConnection(server.getUrl("/a"));
+    assertEquals("B", readAscii(connection4));
+
+    assertEquals(3, server.getRequestCount());
+  }
+
+  @Test public void responseSourceHeaderCached() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+    server.play();
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    URLConnection connection = openConnection(server.getUrl("/"));
+    connection.addRequestProperty("Cache-Control", "only-if-cached");
+    assertEquals("A", readAscii(connection));
+
+    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
+    assertEquals(ResponseSource.CACHE + " 200", source);
+  }
+
+  @Test public void responseSourceHeaderConditionalCacheFetched() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(-31, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse().setBody("B")
+        .addHeader("Cache-Control: max-age=30")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+    server.play();
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("B", readAscii(connection));
+
+    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
+    assertEquals(ResponseSource.CONDITIONAL_CACHE + " 200", source);
+  }
+
+  @Test public void responseSourceHeaderConditionalCacheNotFetched() throws IOException {
+    server.enqueue(new MockResponse().setBody("A")
+        .addHeader("Cache-Control: max-age=0")
+        .addHeader("Date: " + formatDate(0, TimeUnit.MINUTES)));
+    server.enqueue(new MockResponse().setResponseCode(304));
+    server.play();
+
+    assertEquals("A", readAscii(openConnection(server.getUrl("/"))));
+    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(connection));
+
+    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
+    assertEquals(ResponseSource.CONDITIONAL_CACHE + " 304", source);
+  }
+
+  @Test public void responseSourceHeaderFetched() throws IOException {
+    server.enqueue(new MockResponse().setBody("A"));
+    server.play();
+
+    URLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", readAscii(connection));
+
+    String source = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
+    assertEquals(ResponseSource.NETWORK + " 200", source);
+  }
+
+  @Test public void emptyResponseHeaderNameFromCacheIsLenient() throws Exception {
+    server.enqueue(new MockResponse()
+        .addHeader("Cache-Control: max-age=120")
+        .addHeader(": A")
+        .setBody("body"));
+    server.play();
+    HttpURLConnection connection = openConnection(server.getUrl("/"));
+    assertEquals("A", connection.getHeaderField(""));
+  }
+
+  /**
+   * @param delta the offset from the current date to use. Negative
+   * values yield dates in the past; positive values yield dates in the
+   * future.
+   */
+  private String formatDate(long delta, TimeUnit timeUnit) {
+    return formatDate(new Date(System.currentTimeMillis() + timeUnit.toMillis(delta)));
+  }
+
+  private String formatDate(Date date) {
+    DateFormat rfc1123 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz", Locale.US);
+    rfc1123.setTimeZone(TimeZone.getTimeZone("GMT"));
+    return rfc1123.format(date);
+  }
+
+  private void addRequestBodyIfNecessary(String requestMethod, HttpURLConnection invalidate)
+      throws IOException {
+    if (requestMethod.equals("POST") || requestMethod.equals("PUT")) {
+      invalidate.setDoOutput(true);
+      OutputStream requestBody = invalidate.getOutputStream();
+      requestBody.write('x');
+      requestBody.close();
+    }
+  }
+
+  private void assertNotCached(MockResponse response) throws Exception {
+    server.enqueue(response.setBody("A"));
+    server.enqueue(new MockResponse().setBody("B"));
+    server.play();
+
+    URL url = server.getUrl("/");
+    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("B", readAscii(openConnection(url)));
+  }
+
+  /** @return the request with the conditional get headers. */
+  private RecordedRequest assertConditionallyCached(MockResponse response) throws Exception {
+    // scenario 1: condition succeeds
+    server.enqueue(response.setBody("A").setStatus("HTTP/1.1 200 A-OK"));
+    server.enqueue(new MockResponse().setResponseCode(HttpURLConnection.HTTP_NOT_MODIFIED));
+
+    // scenario 2: condition fails
+    server.enqueue(response.setBody("B").setStatus("HTTP/1.1 200 B-OK"));
+    server.enqueue(new MockResponse().setStatus("HTTP/1.1 200 C-OK").setBody("C"));
+
+    server.play();
+
+    URL valid = server.getUrl("/valid");
+    HttpURLConnection connection1 = openConnection(valid);
+    assertEquals("A", readAscii(connection1));
+    assertEquals(HttpURLConnection.HTTP_OK, connection1.getResponseCode());
+    assertEquals("A-OK", connection1.getResponseMessage());
+    HttpURLConnection connection2 = openConnection(valid);
+    assertEquals("A", readAscii(connection2));
+    assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
+    assertEquals("A-OK", connection2.getResponseMessage());
+
+    URL invalid = server.getUrl("/invalid");
+    HttpURLConnection connection3 = openConnection(invalid);
+    assertEquals("B", readAscii(connection3));
+    assertEquals(HttpURLConnection.HTTP_OK, connection3.getResponseCode());
+    assertEquals("B-OK", connection3.getResponseMessage());
+    HttpURLConnection connection4 = openConnection(invalid);
+    assertEquals("C", readAscii(connection4));
+    assertEquals(HttpURLConnection.HTTP_OK, connection4.getResponseCode());
+    assertEquals("C-OK", connection4.getResponseMessage());
+
+    server.takeRequest(); // regular get
+    return server.takeRequest(); // conditional get
+  }
+
+  private void assertFullyCached(MockResponse response) throws Exception {
+    server.enqueue(response.setBody("A"));
+    server.enqueue(response.setBody("B"));
+    server.play();
+
+    URL url = server.getUrl("/");
+    assertEquals("A", readAscii(openConnection(url)));
+    assertEquals("A", readAscii(openConnection(url)));
+  }
+
+  /**
+   * Shortens the body of {@code response} but not the corresponding headers.
+   * Only useful to test how clients respond to the premature conclusion of
+   * the HTTP body.
+   */
+  private MockResponse truncateViolently(MockResponse response, int numBytesToKeep) {
+    response.setSocketPolicy(DISCONNECT_AT_END);
+    List<String> headers = new ArrayList<String>(response.getHeaders());
+    response.setBody(Arrays.copyOfRange(response.getBody(), 0, numBytesToKeep));
+    response.getHeaders().clear();
+    response.getHeaders().addAll(headers);
+    return response;
+  }
+
+  /**
+   * Reads {@code count} characters from the stream. If the stream is
+   * exhausted before {@code count} characters can be read, the remaining
+   * characters are returned and the stream is closed.
+   */
+  private String readAscii(URLConnection connection, int count) throws IOException {
+    HttpURLConnection httpConnection = (HttpURLConnection) connection;
+    InputStream in = httpConnection.getResponseCode() < HttpURLConnection.HTTP_BAD_REQUEST
+        ? connection.getInputStream() : httpConnection.getErrorStream();
+    StringBuilder result = new StringBuilder();
+    for (int i = 0; i < count; i++) {
+      int value = in.read();
+      if (value == -1) {
+        in.close();
+        break;
+      }
+      result.append((char) value);
+    }
+    return result.toString();
+  }
+
+  private String readAscii(URLConnection connection) throws IOException {
+    return readAscii(connection, Integer.MAX_VALUE);
+  }
+
+  private void reliableSkip(InputStream in, int length) throws IOException {
+    while (length > 0) {
+      length -= in.skip(length);
+    }
+  }
+
+  private void assertGatewayTimeout(HttpURLConnection connection) throws IOException {
+    try {
+      connection.getInputStream();
+      fail();
+    } catch (FileNotFoundException expected) {
+    }
+    assertEquals(504, connection.getResponseCode());
+    assertEquals(-1, connection.getErrorStream().read());
+    assertEquals(ResponseSource.NONE + " 504",
+        connection.getHeaderField(OkHeaders.RESPONSE_SOURCE));
+  }
+
+  enum TransferKind {
+    CHUNKED() {
+      @Override void setBody(MockResponse response, byte[] content, int chunkSize)
+          throws IOException {
+        response.setChunkedBody(content, chunkSize);
+      }
+    },
+    FIXED_LENGTH() {
+      @Override void setBody(MockResponse response, byte[] content, int chunkSize) {
+        response.setBody(content);
+      }
+    },
+    END_OF_STREAM() {
+      @Override void setBody(MockResponse response, byte[] content, int chunkSize) {
+        response.setBody(content);
+        response.setSocketPolicy(DISCONNECT_AT_END);
+        for (Iterator<String> h = response.getHeaders().iterator(); h.hasNext(); ) {
+          if (h.next().startsWith("Content-Length:")) {
+            h.remove();
+            break;
+          }
+        }
+      }
+    };
+
+    abstract void setBody(MockResponse response, byte[] content, int chunkSize) throws IOException;
+
+    void setBody(MockResponse response, String content, int chunkSize) throws IOException {
+      setBody(response, content.getBytes("UTF-8"), chunkSize);
+    }
+  }
+
+  private <T> List<T> toListOrNull(T[] arrayOrNull) {
+    return arrayOrNull != null ? Arrays.asList(arrayOrNull) : null;
+  }
+
+  /** Returns a gzipped copy of {@code bytes}. */
+  public byte[] gzip(byte[] bytes) throws IOException {
+    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
+    OutputStream gzippedOut = new GZIPOutputStream(bytesOut);
+    gzippedOut.write(bytes);
+    gzippedOut.close();
+    return bytesOut.toByteArray();
+  }
+
+  private static class InsecureResponseCache extends ResponseCache {
+
+    private final ResponseCache delegate;
+
+    private InsecureResponseCache(ResponseCache delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
+      return delegate.put(uri, connection);
+    }
+
+    @Override public CacheResponse get(URI uri, String requestMethod,
+        Map<String, List<String>> requestHeaders) throws IOException {
+      final CacheResponse response = delegate.get(uri, requestMethod, requestHeaders);
+      if (response instanceof SecureCacheResponse) {
+        return new CacheResponse() {
+          @Override public InputStream getBody() throws IOException {
+            return response.getBody();
+          }
+          @Override public Map<String, List<String>> getHeaders() throws IOException {
+            return response.getHeaders();
+          }
+        };
+      }
+      return response;
+    }
+  }
+
+  /**
+   * A trivial and non-thread-safe implementation of ResponseCache that uses an in-memory map to
+   * cache GETs.
+   */
+  private static class InMemoryResponseCache extends ResponseCache {
+
+    /** A request / response header that acts a bit like Vary but without the complexity. */
+    public static final String CACHE_VARIANT_HEADER = "CacheVariant";
+
+    private static class Key {
+      private final URI uri;
+      private final String cacheVariant;
+
+      private Key(URI uri, String cacheVariant) {
+        this.uri = uri;
+        this.cacheVariant = cacheVariant;
+      }
+
+      @Override
+      public boolean equals(Object o) {
+        if (this == o) {
+          return true;
+        }
+        if (o == null || getClass() != o.getClass()) {
+          return false;
+        }
+
+        Key key = (Key) o;
+
+        if (cacheVariant != null ? !cacheVariant.equals(key.cacheVariant)
+            : key.cacheVariant != null) {
+          return false;
+        }
+        if (!uri.equals(key.uri)) {
+          return false;
+        }
+
+        return true;
+      }
+
+      @Override
+      public int hashCode() {
+        int result = uri.hashCode();
+        result = 31 * result + (cacheVariant != null ? cacheVariant.hashCode() : 0);
+        return result;
+      }
+    }
+
+    private class Entry {
+
+      private final URI uri;
+      private final String cacheVariant;
+      private final String method;
+      private final Map<String, List<String>> responseHeaders;
+      private final String cipherSuite;
+      private final Certificate[] serverCertificates;
+      private final Certificate[] localCertificates;
+      private byte[] body;
+
+      public Entry(URI uri, URLConnection urlConnection) {
+        this.uri = uri;
+        HttpURLConnection httpUrlConnection = (HttpURLConnection) urlConnection;
+        method = httpUrlConnection.getRequestMethod();
+        cacheVariant = urlConnection.getHeaderField(CACHE_VARIANT_HEADER);
+        responseHeaders = urlConnection.getHeaderFields();
+        if (urlConnection instanceof HttpsURLConnection) {
+          HttpsURLConnection httpsURLConnection = (HttpsURLConnection) urlConnection;
+          cipherSuite = httpsURLConnection.getCipherSuite();
+          Certificate[] serverCertificates;
+          try {
+            serverCertificates = httpsURLConnection.getServerCertificates();
+          } catch (SSLPeerUnverifiedException e) {
+            serverCertificates = null;
+          }
+          this.serverCertificates = serverCertificates;
+          localCertificates = httpsURLConnection.getLocalCertificates();
+        } else {
+          cipherSuite = null;
+          serverCertificates = null;
+          localCertificates = null;
+        }
+      }
+
+      public CacheResponse asCacheResponse() {
+        if (!method.equals(this.method)) {
+          return null;
+        }
+
+        // Handle SSL
+        if (cipherSuite != null) {
+          return new SecureCacheResponse() {
+            @Override
+            public Map<String, List<String>> getHeaders() throws IOException {
+              return responseHeaders;
+            }
+
+            @Override
+            public InputStream getBody() throws IOException {
+              return new ByteArrayInputStream(body);
+            }
+
+            @Override
+            public String getCipherSuite() {
+              return cipherSuite;
+            }
+
+            @Override
+            public List<Certificate> getLocalCertificateChain() {
+              return localCertificates == null ? null : Arrays.asList(localCertificates);
+            }
+
+            @Override
+            public List<Certificate> getServerCertificateChain() throws SSLPeerUnverifiedException {
+              if (serverCertificates == null) {
+                throw new SSLPeerUnverifiedException("Test implementation");
+              }
+              return Arrays.asList(serverCertificates);
+            }
+
+            @Override
+            public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
+              throw new UnsupportedOperationException();
+            }
+
+            @Override
+            public Principal getLocalPrincipal() {
+              throw new UnsupportedOperationException();
+            }
+          };
+        } else {
+          return new CacheResponse() {
+            @Override
+            public Map<String, List<String>> getHeaders() throws IOException {
+              return responseHeaders;
+            }
+
+            @Override
+            public InputStream getBody() throws IOException {
+              return new ByteArrayInputStream(body);
+            }
+          };
+        }
+      }
+
+      public CacheRequest asCacheRequest() {
+        return new CacheRequest() {
+          @Override
+          public OutputStream getBody() throws IOException {
+            return new ByteArrayOutputStream() {
+              @Override
+              public void close() throws IOException {
+                super.close();
+                body = toByteArray();
+                cache.put(Entry.this.key(), Entry.this);
+              }
+            };
+          }
+
+          @Override
+          public void abort() {
+            // No-op: close() puts the item in the cache, abort need not do anything.
+          }
+        };
+      }
+
+      private Key key() {
+        return new Key(uri, cacheVariant);
+      }
+    }
+
+    private Map<Key, Entry> cache = new HashMap<Key, Entry>();
+
+    @Override
+    public CacheResponse get(URI uri, String method, Map<String, List<String>> requestHeaders)
+        throws IOException {
+
+      if (!"GET".equals(method)) {
+        return null;
+      }
+
+      String cacheVariant =
+          requestHeaders.containsKey(CACHE_VARIANT_HEADER)
+              ? requestHeaders.get(CACHE_VARIANT_HEADER).get(0) : null;
+      Key key = new Key(uri, cacheVariant);
+      Entry entry = cache.get(key);
+      if (entry == null) {
+        return null;
+      }
+      return entry.asCacheResponse();
+    }
+
+    @Override
+    public CacheRequest put(URI uri, URLConnection urlConnection) throws IOException {
+      if (!"GET".equals(((HttpURLConnection) urlConnection).getRequestMethod())) {
+        return null;
+      }
+
+      Entry entry = new Entry(uri, urlConnection);
+      return entry.asCacheRequest();
+    }
+  }
+}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/RouteSelectorTest.java
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
similarity index 98%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
index c3ea3a982d..885570a4db 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/StatusLineTest.java
@@ -19,8 +19,8 @@
 import java.net.ProtocolException;
 import org.junit.Test;
 
-import static junit.framework.Assert.fail;
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
 
 public final class StatusLineTest {
   @Test public void parse() throws IOException {
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
similarity index 86%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
index 7b9eb8d09d..5e86c8e9f4 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLConnectionTest.java
@@ -16,6 +16,7 @@
 
 package com.squareup.okhttp.internal.http;
 
+import com.squareup.okhttp.ConnectionPool;
 import com.squareup.okhttp.HttpResponseCache;
 import com.squareup.okhttp.OkAuthenticator.Credential;
 import com.squareup.okhttp.OkHttpClient;
@@ -62,6 +63,7 @@
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.zip.GZIPInputStream;
 import java.util.zip.GZIPOutputStream;
 import javax.net.ssl.HttpsURLConnection;
@@ -76,6 +78,8 @@
 import org.junit.Ignore;
 import org.junit.Test;
 
+import static com.squareup.okhttp.internal.Util.UTF_8;
+import static com.squareup.okhttp.internal.http.OkHeaders.SELECTED_PROTOCOL;
 import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_END;
 import static com.squareup.okhttp.mockwebserver.SocketPolicy.DISCONNECT_AT_START;
@@ -85,6 +89,7 @@
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
@@ -97,6 +102,7 @@
   private MockWebServer server2 = new MockWebServer();
 
   private final OkHttpClient client = new OkHttpClient();
+  private HttpURLConnection connection;
   private HttpResponseCache cache;
   private String hostName;
 
@@ -124,12 +130,12 @@
     server.enqueue(new MockResponse());
     server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.addRequestProperty("D", "e");
-    urlConnection.addRequestProperty("D", "f");
-    assertEquals("f", urlConnection.getRequestProperty("D"));
-    assertEquals("f", urlConnection.getRequestProperty("d"));
-    Map<String, List<String>> requestHeaders = urlConnection.getRequestProperties();
+    connection = client.open(server.getUrl("/"));
+    connection.addRequestProperty("D", "e");
+    connection.addRequestProperty("D", "f");
+    assertEquals("f", connection.getRequestProperty("D"));
+    assertEquals("f", connection.getRequestProperty("d"));
+    Map<String, List<String>> requestHeaders = connection.getRequestProperties();
     assertEquals(newSet("e", "f"), new HashSet<String>(requestHeaders.get("D")));
     assertEquals(newSet("e", "f"), new HashSet<String>(requestHeaders.get("d")));
     try {
@@ -143,21 +149,21 @@
     } catch (UnsupportedOperationException expected) {
     }
     try {
-      urlConnection.setRequestProperty(null, "j");
+      connection.setRequestProperty(null, "j");
       fail();
     } catch (NullPointerException expected) {
     }
     try {
-      urlConnection.addRequestProperty(null, "k");
+      connection.addRequestProperty(null, "k");
       fail();
     } catch (NullPointerException expected) {
     }
-    urlConnection.setRequestProperty("NullValue", null);
-    assertNull(urlConnection.getRequestProperty("NullValue"));
-    urlConnection.addRequestProperty("AnotherNullValue", null);
-    assertNull(urlConnection.getRequestProperty("AnotherNullValue"));
+    connection.setRequestProperty("NullValue", null);
+    assertNull(connection.getRequestProperty("NullValue"));
+    connection.addRequestProperty("AnotherNullValue", null);
+    assertNull(connection.getRequestProperty("AnotherNullValue"));
 
-    urlConnection.getResponseCode();
+    connection.getResponseCode();
     RecordedRequest request = server.takeRequest();
     assertContains(request.getHeaders(), "D: e");
     assertContains(request.getHeaders(), "D: f");
@@ -167,17 +173,17 @@
     assertContainsNoneMatching(request.getHeaders(), "null:.*");
 
     try {
-      urlConnection.addRequestProperty("N", "o");
+      connection.addRequestProperty("N", "o");
       fail("Set header after connect");
     } catch (IllegalStateException expected) {
     }
     try {
-      urlConnection.setRequestProperty("P", "q");
+      connection.setRequestProperty("P", "q");
       fail("Set header after connect");
     } catch (IllegalStateException expected) {
     }
     try {
-      urlConnection.getRequestProperties();
+      connection.getRequestProperties();
       fail();
     } catch (IllegalStateException expected) {
     }
@@ -185,10 +191,10 @@
 
   @Test public void getRequestPropertyReturnsLastValue() throws Exception {
     server.play();
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.addRequestProperty("A", "value1");
-    urlConnection.addRequestProperty("A", "value2");
-    assertEquals("value2", urlConnection.getRequestProperty("A"));
+    connection = client.open(server.getUrl("/"));
+    connection.addRequestProperty("A", "value1");
+    connection.addRequestProperty("A", "value2");
+    assertEquals("value2", connection.getRequestProperty("A"));
   }
 
   @Test public void responseHeaders() throws IOException, InterruptedException {
@@ -199,11 +205,11 @@
         .setChunkedBody("ABCDE\nFGHIJ\nKLMNO\nPQR", 8));
     server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    assertEquals(200, urlConnection.getResponseCode());
-    assertEquals("Fantastic", urlConnection.getResponseMessage());
-    assertEquals("HTTP/1.0 200 Fantastic", urlConnection.getHeaderField(null));
-    Map<String, List<String>> responseHeaders = urlConnection.getHeaderFields();
+    connection = client.open(server.getUrl("/"));
+    assertEquals(200, connection.getResponseCode());
+    assertEquals("Fantastic", connection.getResponseMessage());
+    assertEquals("HTTP/1.0 200 Fantastic", connection.getHeaderField(null));
+    Map<String, List<String>> responseHeaders = connection.getHeaderFields();
     assertEquals(Arrays.asList("HTTP/1.0 200 Fantastic"), responseHeaders.get(null));
     assertEquals(newSet("c", "e"), new HashSet<String>(responseHeaders.get("A")));
     assertEquals(newSet("c", "e"), new HashSet<String>(responseHeaders.get("a")));
@@ -217,21 +223,21 @@
       fail("Modified an unmodifiable view.");
     } catch (UnsupportedOperationException expected) {
     }
-    assertEquals("A", urlConnection.getHeaderFieldKey(0));
-    assertEquals("c", urlConnection.getHeaderField(0));
-    assertEquals("B", urlConnection.getHeaderFieldKey(1));
-    assertEquals("d", urlConnection.getHeaderField(1));
-    assertEquals("A", urlConnection.getHeaderFieldKey(2));
-    assertEquals("e", urlConnection.getHeaderField(2));
+    assertEquals("A", connection.getHeaderFieldKey(0));
+    assertEquals("c", connection.getHeaderField(0));
+    assertEquals("B", connection.getHeaderFieldKey(1));
+    assertEquals("d", connection.getHeaderField(1));
+    assertEquals("A", connection.getHeaderFieldKey(2));
+    assertEquals("e", connection.getHeaderField(2));
   }
 
   @Test public void serverSendsInvalidResponseHeaders() throws Exception {
     server.enqueue(new MockResponse().setStatus("HTP/1.1 200 OK"));
     server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
-      urlConnection.getResponseCode();
+      connection.getResponseCode();
       fail();
     } catch (IOException expected) {
     }
@@ -241,9 +247,9 @@
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 2147483648 OK"));
     server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
-      urlConnection.getResponseCode();
+      connection.getResponseCode();
       fail();
     } catch (IOException expected) {
     }
@@ -253,9 +259,9 @@
     server.enqueue(new MockResponse().setStatus("HTTP/1.1 00a OK"));
     server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
-      urlConnection.getResponseCode();
+      connection.getResponseCode();
       fail();
     } catch (IOException expected) {
     }
@@ -265,9 +271,9 @@
     server.enqueue(new MockResponse().setStatus(" HTTP/1.1 2147483648 OK"));
     server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
-      urlConnection.getResponseCode();
+      connection.getResponseCode();
       fail();
     } catch (IOException expected) {
     }
@@ -278,7 +284,7 @@
     URL url = server.getUrl("/foo");
     server.shutdown();
 
-    HttpURLConnection connection = client.open(url);
+    connection = client.open(url);
     try {
       connection.connect();
       fail();
@@ -309,7 +315,7 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
     client.setProxySelector(proxySelector);
     server2.shutdown();
 
-    HttpURLConnection connection = client.open(server.getUrl("/def"));
+    connection = client.open(server.getUrl("/def"));
     connection.setDoOutput(true);
     transferKind.setForRequest(connection, 4);
     connection.getOutputStream().write("body".getBytes("UTF-8"));
@@ -321,14 +327,14 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
   @Test public void getErrorStreamOnSuccessfulRequest() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertNull(connection.getErrorStream());
   }
 
   @Test public void getErrorStreamOnUnsuccessfulRequest() throws Exception {
     server.enqueue(new MockResponse().setResponseCode(404).setBody("A"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection.getErrorStream(), Integer.MAX_VALUE));
   }
 
@@ -397,6 +403,17 @@ private void testRequestBodySurvivesRetries(TransferKind transferKind) throws Ex
     testServerClosesOutput(SHUTDOWN_OUTPUT_AT_END);
   }
 
+  @Test public void invalidHost() throws Exception {
+    // Note that 1234.1.1.1 is an invalid host in a URI, but URL isn't as strict.
+    URL url = new URL("http://1234.1.1.1/index.html");
+    HttpURLConnection connection = client.open(url);
+    try {
+      connection.connect();
+      fail();
+    } catch (UnknownHostException expected) {
+    }
+  }
+
   private void testServerClosesOutput(SocketPolicy socketPolicy) throws Exception {
     server.enqueue(new MockResponse().setBody("This connection won't pool properly")
         .setSocketPolicy(socketPolicy));
@@ -508,7 +525,7 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
 
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
 
     assertContent("this response comes via HTTPS", connection);
 
@@ -516,6 +533,36 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
   }
 
+  @Test public void inspectHandshakeThroughoutRequestLifecycle() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse());
+    server.play();
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    HttpsURLConnection httpsConnection = (HttpsURLConnection) client.open(server.getUrl("/foo"));
+
+    // Prior to calling connect(), getting the cipher suite is forbidden.
+    try {
+      httpsConnection.getCipherSuite();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+
+    // Calling connect establishes a handshake...
+    httpsConnection.connect();
+    assertNotNull(httpsConnection.getCipherSuite());
+
+    // ...which remains after we read the response body...
+    assertContent("", httpsConnection);
+    assertNotNull(httpsConnection.getCipherSuite());
+
+    // ...and after we disconnect.
+    httpsConnection.disconnect();
+    assertNotNull(httpsConnection.getCipherSuite());
+  }
+
   @Test public void connectViaHttpsReusingConnections() throws IOException, InterruptedException {
     server.useHttps(sslContext.getSocketFactory(), false);
     server.enqueue(new MockResponse().setBody("this response comes via HTTPS"));
@@ -528,7 +575,7 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
 
     client.setSslSocketFactory(clientSocketFactory);
     client.setHostnameVerifier(hostnameVerifier);
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertContent("this response comes via HTTPS", connection);
 
     connection = client.open(server.getUrl("/"));
@@ -568,7 +615,7 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
 
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
 
     assertContent("this response comes via SSL", connection);
 
@@ -576,6 +623,33 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     assertEquals("GET /foo HTTP/1.1", request.getRequestLine());
   }
 
+  /**
+   * When a pooled connection fails, don't blame the route. Otherwise pooled
+   * connection failures can cause unnecessary SSL fallbacks.
+   *
+   * https://github.com/square/okhttp/issues/515
+   */
+  @Test public void sslFallbackNotUsedWhenRecycledConnectionFails() throws Exception {
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.enqueue(new MockResponse()
+        .setBody("abc")
+        .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
+    server.enqueue(new MockResponse().setBody("def"));
+    server.play();
+
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+
+    assertContent("abc", client.open(server.getUrl("/")));
+    assertContent("def", client.open(server.getUrl("/")));
+
+    RecordedRequest request1 = server.takeRequest();
+    assertEquals("TLSv1", request1.getSslProtocol()); // OkHttp's current best TLS version.
+
+    RecordedRequest request2 = server.takeRequest();
+    assertEquals("TLSv1", request2.getSslProtocol()); // OkHttp's current best TLS version.
+  }
+
   /**
    * Verify that we don't retry connections on certificate verification errors.
    *
@@ -586,7 +660,7 @@ private void doUpload(TransferKind uploadKind, WriteKind writeKind) throws Excep
     server.enqueue(new MockResponse()); // unused
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
     try {
       connection.getInputStream();
       fail();
@@ -614,7 +688,7 @@ private void testConnectViaProxy(ProxyConfig proxyConfig) throws Exception {
     server.play();
 
     URL url = new URL("http://android.com/foo");
-    HttpURLConnection connection = proxyConfig.connect(server, client, url);
+    connection = proxyConfig.connect(server, client, url);
     assertContent("this response comes via a proxy", connection);
     assertTrue(connection.usingProxy());
 
@@ -665,7 +739,7 @@ private void testConnectViaDirectProxyToHttps(ProxyConfig proxyConfig) throws Ex
     URL url = server.getUrl("/foo");
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = proxyConfig.connect(server, client, url);
+    connection = proxyConfig.connect(server, client, url);
 
     assertContent("this response comes via HTTPS", connection);
 
@@ -705,7 +779,7 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
     URL url = new URL("https://android.com/foo");
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(hostnameVerifier);
-    HttpURLConnection connection = proxyConfig.connect(server, client, url);
+    connection = proxyConfig.connect(server, client, url);
 
     assertContent("this response comes via a secure proxy", connection);
 
@@ -741,7 +815,7 @@ private void testConnectViaHttpProxyToHttps(ProxyConfig proxyConfig) throws Exce
 
     URL url = new URL("https://android.com/foo");
     client.setSslSocketFactory(sslContext.getSocketFactory());
-    HttpURLConnection connection = client.open(url);
+    connection = client.open(url);
 
     try {
       connection.getResponseCode();
@@ -762,7 +836,7 @@ private void initResponseCache() throws IOException {
     String tmp = System.getProperty("java.io.tmpdir");
     File cacheDir = new File(tmp, "HttpCache-" + UUID.randomUUID());
     cache = new HttpResponseCache(cacheDir, Integer.MAX_VALUE);
-    client.setResponseCache(cache);
+    client.setOkResponseCache(cache);
   }
 
   /** Test which headers are sent unencrypted to the HTTP proxy. */
@@ -780,7 +854,7 @@ private void initResponseCache() throws IOException {
     URL url = new URL("https://android.com/foo");
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(hostnameVerifier);
-    HttpURLConnection connection = client.open(url);
+    connection = client.open(url);
     connection.addRequestProperty("Private", "Secret");
     connection.addRequestProperty("Proxy-Authorization", "bar");
     connection.addRequestProperty("User-Agent", "baz");
@@ -812,7 +886,7 @@ private void initResponseCache() throws IOException {
     URL url = new URL("https://android.com/foo");
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(url);
+    connection = client.open(url);
     assertContent("A", connection);
 
     RecordedRequest connect1 = server.takeRequest();
@@ -842,7 +916,7 @@ private void initResponseCache() throws IOException {
     URL url = new URL("https://android.com/foo");
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(url);
+    connection = client.open(url);
     connection.setRequestProperty("Connection", "close");
 
     assertContent("this response comes via a proxy", connection);
@@ -871,7 +945,7 @@ private void initResponseCache() throws IOException {
     server.enqueue(new MockResponse().setBody("ABCDEFGHIJKLMNOPQR"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     InputStream in = connection.getInputStream();
     assertEquals('A', (char) in.read());
     connection.disconnect();
@@ -886,9 +960,8 @@ private void initResponseCache() throws IOException {
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.disconnect();
-
     assertContent("A", connection);
     assertEquals(200, connection.getResponseCode());
   }
@@ -1100,6 +1173,41 @@ private void testClientConfiguredGzipContentEncodingAndConnectionReuse(TransferK
     assertEquals(1, server.takeRequest().getSequenceNumber());
   }
 
+  @Test public void transparentGzipWorksAfterExceptionRecovery() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("a")
+        .setSocketPolicy(SHUTDOWN_INPUT_AT_END));
+    server.enqueue(new MockResponse()
+        .addHeader("Content-Encoding: gzip")
+        .setBody(gzip("b".getBytes(UTF_8))));
+    server.play();
+
+    // Seed the pool with a bad connection.
+    assertContent("a", client.open(server.getUrl("/")));
+
+    // This connection will need to be recovered. When it is, transparent gzip should still work!
+    assertContent("b", client.open(server.getUrl("/")));
+
+    assertEquals(0, server.takeRequest().getSequenceNumber());
+    assertEquals(0, server.takeRequest().getSequenceNumber()); // Connection is not pooled.
+  }
+
+  @Test public void endOfStreamResponseIsNotPooled() throws Exception {
+    server.enqueue(new MockResponse()
+        .setBody("{}")
+        .clearHeaders()
+        .setSocketPolicy(DISCONNECT_AT_END));
+    server.play();
+
+    ConnectionPool pool = ConnectionPool.getDefault();
+    pool.evictAll();
+    client.setConnectionPool(pool);
+
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    assertContent("{}", connection);
+    assertEquals(0, client.getConnectionPool().getConnectionCount());
+  }
+
   @Test public void earlyDisconnectDoesntHarmPoolingWithChunkedEncoding() throws Exception {
     testEarlyDisconnectDoesntHarmPooling(TransferKind.CHUNKED);
   }
@@ -1119,15 +1227,15 @@ private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) thr
 
     server.play();
 
-    URLConnection connection1 = client.open(server.getUrl("/"));
+    HttpURLConnection connection1 = client.open(server.getUrl("/"));
     InputStream in1 = connection1.getInputStream();
     assertEquals("ABCDE", readAscii(in1, 5));
-    in1.close();
+    connection1.disconnect();
 
     HttpURLConnection connection2 = client.open(server.getUrl("/"));
     InputStream in2 = connection2.getInputStream();
     assertEquals("LMNOP", readAscii(in2, 5));
-    in2.close();
+    connection2.disconnect();
 
     assertEquals(0, server.takeRequest().getSequenceNumber());
     assertEquals(1, server.takeRequest().getSequenceNumber()); // Connection is pooled!
@@ -1165,12 +1273,12 @@ private void testEarlyDisconnectDoesntHarmPooling(TransferKind transferKind) thr
     server.play();
 
     String body = "ABCDEFGHIJKLMNOPQ";
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.setChunkedStreamingMode(0); // OkHttp does not honor specific chunk sizes.
-    urlConnection.setDoOutput(true);
-    OutputStream outputStream = urlConnection.getOutputStream();
+    connection = client.open(server.getUrl("/"));
+    connection.setChunkedStreamingMode(0); // OkHttp does not honor specific chunk sizes.
+    connection.setDoOutput(true);
+    OutputStream outputStream = connection.getOutputStream();
     outputStream.write(body.getBytes("US-ASCII"));
-    assertEquals(200, urlConnection.getResponseCode());
+    assertEquals(200, connection.getResponseCode());
 
     RecordedRequest request = server.takeRequest();
     assertEquals(body, new String(request.getBody(), "US-ASCII"));
@@ -1193,7 +1301,7 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
     server.play();
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     byte[] requestBody = { 'A', 'B', 'C', 'D' };
     if (streamingMode == StreamingMode.FIXED_LENGTH) {
@@ -1277,7 +1385,6 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
     server.enqueue(pleaseAuthenticate);
     server.play();
 
-    HttpURLConnection connection;
     if (proxy) {
       client.setProxy(server.toProxyAddress());
       connection = client.open(new URL("http://android.com"));
@@ -1297,10 +1404,11 @@ private void testAuthenticateWithStreamingPost(StreamingMode streamingMode) thro
     assertValidRequestMethod("POST");
     assertValidRequestMethod("PUT");
     assertValidRequestMethod("TRACE");
+    assertValidRequestMethod("PATCH");
   }
 
   private void assertValidRequestMethod(String requestMethod) throws Exception {
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setRequestMethod(requestMethod);
     assertEquals(requestMethod, connection.getRequestMethod());
   }
@@ -1316,7 +1424,7 @@ private void assertValidRequestMethod(String requestMethod) throws Exception {
   }
 
   private void assertInvalidRequestMethod(String requestMethod) throws Exception {
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
       connection.setRequestMethod(requestMethod);
       fail();
@@ -1344,7 +1452,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
         .addHeader("icy-metaint:16000")
         .setBody("mp3 data"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals(200, connection.getResponseCode());
     assertEquals("OK", connection.getResponseMessage());
     assertContent("mp3 data", connection);
@@ -1352,7 +1460,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
 
   @Test public void cannotSetNegativeFixedLengthStreamingMode() throws Exception {
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
       connection.setFixedLengthStreamingMode(-2);
       fail();
@@ -1362,14 +1470,14 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
 
   @Test public void canSetNegativeChunkedStreamingMode() throws Exception {
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setChunkedStreamingMode(-2);
   }
 
   @Test public void cannotSetFixedLengthStreamingModeAfterConnect() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
     try {
       connection.setFixedLengthStreamingMode(1);
@@ -1381,7 +1489,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
   @Test public void cannotSetChunkedStreamingModeAfterConnect() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("A", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
     try {
       connection.setChunkedStreamingMode(1);
@@ -1392,7 +1500,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
 
   @Test public void cannotSetFixedLengthStreamingModeAfterChunkedStreamingMode() throws Exception {
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setChunkedStreamingMode(1);
     try {
       connection.setFixedLengthStreamingMode(1);
@@ -1403,7 +1511,7 @@ private void assertInvalidRequestMethod(String requestMethod) throws Exception {
 
   @Test public void cannotSetChunkedStreamingModeAfterFixedLengthStreamingMode() throws Exception {
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setFixedLengthStreamingMode(1);
     try {
       connection.setChunkedStreamingMode(1);
@@ -1431,7 +1539,7 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
 
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     byte[] requestBody = { 'A', 'B', 'C', 'D' };
     if (streamingMode == StreamingMode.FIXED_LENGTH) {
@@ -1471,7 +1579,7 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     server.play();
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     byte[] requestBody = { 'A', 'B', 'C', 'D' };
     OutputStream outputStream = connection.getOutputStream();
@@ -1506,7 +1614,7 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     server.play();
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
     // no authorization header for the first request...
@@ -1531,7 +1639,7 @@ private void testSecureStreamingPost(StreamingMode streamingMode) throws Excepti
     server.play();
 
     Authenticator.setDefault(new RecordingAuthenticator());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("Successful auth!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
 
@@ -1578,7 +1686,7 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
 
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("This is the new location!",
         readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
@@ -1599,7 +1707,7 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
     client.setFollowProtocolRedirects(false);
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
 
@@ -1610,7 +1718,7 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
     server.play();
 
     client.setFollowProtocolRedirects(false);
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
   }
 
@@ -1651,7 +1759,7 @@ private void testRedirected(TransferKind transferKind, boolean reuse) throws Exc
     client.setSslSocketFactory(sslContext.getSocketFactory());
     client.setHostnameVerifier(new RecordingHostnameVerifier());
     client.setFollowProtocolRedirects(true);
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertContent("This is secure HTTPS!", connection);
     assertFalse(connection instanceof HttpsURLConnection);
   }
@@ -1684,7 +1792,7 @@ private void redirectToAnotherOriginServer(boolean https) throws Exception {
     server.enqueue(new MockResponse().setBody("This is the first server again!"));
     server.play();
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertContent("This is the 2nd server!", connection);
     assertEquals(server2.getUrl("/"), connection.getURL());
 
@@ -1754,7 +1862,7 @@ private void testResponseRedirectedWithPost(int redirectCode) throws Exception {
     server.enqueue(new MockResponse().setBody("Page 2"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/page1"));
+    connection = client.open(server.getUrl("/page1"));
     connection.setDoOutput(true);
     byte[] requestBody = { 'A', 'B', 'C', 'D' };
     OutputStream outputStream = connection.getOutputStream();
@@ -1778,7 +1886,7 @@ private void testResponseRedirectedWithPost(int redirectCode) throws Exception {
     server.enqueue(new MockResponse().setBody("Page 2"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/page1"));
+    connection = client.open(server.getUrl("/page1"));
     connection.setDoOutput(true);
     connection.addRequestProperty("Content-Length", "4");
     connection.addRequestProperty("Content-Type", "text/plain; charset=utf-8");
@@ -1804,7 +1912,7 @@ private void testResponseRedirectedWithPost(int redirectCode) throws Exception {
         .setBody("This page has moved!"));
     server.enqueue(new MockResponse().setBody("Proxy Response"));
 
-    HttpURLConnection connection = client.open(server.getUrl("/foo"));
+    connection = client.open(server.getUrl("/foo"));
     // Fails on the RI, which gets "Proxy Response"
     assertEquals("This page has moved!", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
@@ -1840,7 +1948,7 @@ private void test307Redirect(String method) throws Exception {
     server.enqueue(new MockResponse().setBody("Page 2"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/page1"));
+    connection = client.open(server.getUrl("/page1"));
     connection.setRequestMethod(method);
     byte[] requestBody = { 'A', 'B', 'C', 'D' };
     if (method.equals("POST")) {
@@ -1886,7 +1994,7 @@ private void test307Redirect(String method) throws Exception {
     server.enqueue(new MockResponse().setBody("Success!"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/0"));
+    connection = client.open(server.getUrl("/0"));
     assertContent("Success!", connection);
     assertEquals(server.getUrl("/20"), connection.getURL());
   }
@@ -1899,7 +2007,7 @@ private void test307Redirect(String method) throws Exception {
     }
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/0"));
+    connection = client.open(server.getUrl("/0"));
     try {
       connection.getInputStream();
       fail();
@@ -1944,9 +2052,9 @@ private void test307Redirect(String method) throws Exception {
     server.enqueue(new MockResponse().setBody("unused")); // to keep the server alive
     server.play();
 
-    URLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.setReadTimeout(1000);
-    InputStream in = urlConnection.getInputStream();
+    URLConnection connection = client.open(server.getUrl("/"));
+    connection.setReadTimeout(1000);
+    InputStream in = connection.getInputStream();
     assertEquals('A', in.read());
     assertEquals('B', in.read());
     assertEquals('C', in.read());
@@ -1961,11 +2069,11 @@ private void test307Redirect(String method) throws Exception {
     server.enqueue(new MockResponse());
     server.play();
 
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.setRequestProperty("Transfer-encoding", "chunked");
-    urlConnection.setDoOutput(true);
-    urlConnection.getOutputStream().write("ABC".getBytes("UTF-8"));
-    assertEquals(200, urlConnection.getResponseCode());
+    connection = client.open(server.getUrl("/"));
+    connection.setRequestProperty("Transfer-encoding", "chunked");
+    connection.setDoOutput(true);
+    connection.getOutputStream().write("ABC".getBytes("UTF-8"));
+    assertEquals(200, connection.getResponseCode());
 
     RecordedRequest request = server.takeRequest();
     assertEquals("ABC", new String(request.getBody(), "UTF-8"));
@@ -2049,10 +2157,10 @@ private void test307Redirect(String method) throws Exception {
   }
 
   @Test public void singleByteReadIsSigned() throws IOException {
-    server.enqueue(new MockResponse().setBody(new byte[] { -2, -1 }));
+    server.enqueue(new MockResponse().setBody(new byte[] {-2, -1}));
     server.play();
 
-    URLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     InputStream in = connection.getInputStream();
     assertEquals(254, in.read());
     assertEquals(255, in.read());
@@ -2080,7 +2188,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
     server.enqueue(new MockResponse().setBody("abc"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     byte[] upload = "def".getBytes("UTF-8");
 
@@ -2094,7 +2202,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
     out.write(upload);
     assertEquals("abc", readAscii(connection.getInputStream(), Integer.MAX_VALUE));
 
-    out.flush(); // dubious but permitted
+    out.flush(); // Dubious but permitted.
     try {
       out.write("ghi".getBytes("UTF-8"));
       fail();
@@ -2111,7 +2219,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
     }
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
       connection.getInputStream();
       fail();
@@ -2126,7 +2234,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   }
 
   @Test public void dnsFailureThrowsIOException() throws IOException {
-    HttpURLConnection connection = client.open(new URL("http://host.unlikelytld"));
+    connection = client.open(new URL("http://host.unlikelytld"));
     try {
       connection.connect();
       fail();
@@ -2135,7 +2243,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   }
 
   @Test public void malformedUrlThrowsUnknownHostException() throws IOException {
-    HttpURLConnection connection = client.open(new URL("http:///foo.html"));
+    connection = client.open(new URL("http:///foo.html"));
     try {
       connection.connect();
       fail();
@@ -2149,11 +2257,10 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
     server.play();
 
     // The request should work once and then fail
-    URLConnection connection1 = client.open(server.getUrl(""));
+    HttpURLConnection connection1 = client.open(server.getUrl(""));
     connection1.setReadTimeout(100);
     InputStream input = connection1.getInputStream();
     assertEquals("ABC", readAscii(input, Integer.MAX_VALUE));
-    input.close();
     server.shutdown();
     try {
       HttpURLConnection connection2 = client.open(server.getUrl(""));
@@ -2165,22 +2272,35 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   }
 
   /** Don't explode if the cache returns a null body. http://b/3373699 */
-  @Test public void installDeprecatedJavaNetResponseCache() throws Exception {
-    ResponseCache cache = new ResponseCache() {
+  @Test public void responseCacheReturnsNullOutputStream() throws Exception {
+    final AtomicBoolean aborted = new AtomicBoolean();
+    client.setResponseCache(new ResponseCache() {
       @Override public CacheResponse get(URI uri, String requestMethod,
           Map<String, List<String>> requestHeaders) throws IOException {
         return null;
       }
+
       @Override public CacheRequest put(URI uri, URLConnection connection) throws IOException {
-        return null;
+        return new CacheRequest() {
+          @Override public void abort() {
+            aborted.set(true);
+          }
+
+          @Override public OutputStream getBody() throws IOException {
+            return null;
+          }
+        };
       }
-    };
+    });
 
-    try {
-      client.setResponseCache(cache);
-      fail();
-    } catch (UnsupportedOperationException expected) {
-    }
+    server.enqueue(new MockResponse().setBody("abcdef"));
+    server.play();
+
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    InputStream in = connection.getInputStream();
+    assertEquals("abc", readAscii(in, 3));
+    in.close();
+    assertFalse(aborted.get()); // The best behavior is ambiguous, but RI 6 doesn't abort here
   }
 
   /** http://code.google.com/p/android/issues/detail?id=14562 */
@@ -2191,7 +2311,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
         .setSocketPolicy(SocketPolicy.DISCONNECT_AT_END));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     InputStream in = connection.getInputStream();
     assertEquals("ABC", readAscii(in, 3));
     assertEquals(-1, in.read());
@@ -2201,7 +2321,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   @Test public void getContent() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     InputStream in = (InputStream) connection.getContent();
     assertEquals("A", readAscii(in, Integer.MAX_VALUE));
   }
@@ -2209,7 +2329,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   @Test public void getContentOfType() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("A"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
       connection.getContent(null);
       fail();
@@ -2220,14 +2340,13 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
       fail();
     } catch (NullPointerException expected) {
     }
-    assertNull(connection.getContent(new Class[] { getClass() }));
-    connection.disconnect();
+    assertNull(connection.getContent(new Class[] {getClass()}));
   }
 
   @Test public void getOutputStreamOnGetFails() throws Exception {
     server.enqueue(new MockResponse());
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
       connection.getOutputStream();
       fail();
@@ -2238,7 +2357,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   @Test public void getOutputAfterGetInputStreamFails() throws Exception {
     server.enqueue(new MockResponse());
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     try {
       connection.getInputStream();
@@ -2251,7 +2370,7 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   @Test public void setDoOutputOrDoInputAfterConnectFails() throws Exception {
     server.enqueue(new MockResponse());
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.connect();
     try {
       connection.setDoOutput(true);
@@ -2263,13 +2382,12 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
       fail();
     } catch (IllegalStateException expected) {
     }
-    connection.disconnect();
   }
 
   @Test public void clientSendsContentLength() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     OutputStream out = connection.getOutputStream();
     out.write(new byte[] { 'A', 'B', 'C' });
@@ -2282,25 +2400,22 @@ private void testFlushAfterStreamTransmitted(TransferKind transferKind) throws I
   @Test public void getContentLengthConnects() throws Exception {
     server.enqueue(new MockResponse().setBody("ABC"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals(3, connection.getContentLength());
-    connection.disconnect();
   }
 
   @Test public void getContentTypeConnects() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Type: text/plain").setBody("ABC"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("text/plain", connection.getContentType());
-    connection.disconnect();
   }
 
   @Test public void getContentEncodingConnects() throws Exception {
     server.enqueue(new MockResponse().addHeader("Content-Encoding: identity").setBody("ABC"));
     server.play();
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     assertEquals("identity", connection.getContentEncoding());
-    connection.disconnect();
   }
 
   // http://b/4361656
@@ -2332,7 +2447,7 @@ private void testInputStreamAvailable(TransferKind transferKind) throws IOExcept
     transferKind.setBody(response, body, 4);
     server.enqueue(response);
     server.play();
-    URLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     InputStream in = connection.getInputStream();
     for (int i = 0; i < body.length(); i++) {
       assertTrue(in.available() >= 0);
@@ -2371,6 +2486,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
       throws Exception {
     server.enqueue(new MockResponse().setBody("A").setSocketPolicy(SHUTDOWN_INPUT_AT_END));
     server.enqueue(new MockResponse().setBody("B"));
+    server.enqueue(new MockResponse().setBody("C"));
     server.play();
 
     assertContent("A", client.open(server.getUrl("/a")));
@@ -2379,7 +2495,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     byte[] requestBody = new byte[requestSize];
     new Random(0).nextBytes(requestBody);
 
-    HttpURLConnection connection = client.open(server.getUrl("/b"));
+    connection = client.open(server.getUrl("/b"));
     connection.setRequestMethod("POST");
     transferKind.setForRequest(connection, requestBody.length);
     for (int i = 0; i < requestBody.length; i += 1024) {
@@ -2399,7 +2515,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/b"));
+    connection = client.open(server.getUrl("/b"));
     connection.setRequestProperty("Content-Length", "4");
     connection.setRequestMethod("POST");
     OutputStream out = connection.getOutputStream();
@@ -2417,7 +2533,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/b"));
+    connection = client.open(server.getUrl("/b"));
     connection.setRequestProperty("Content-Length", "3");
     connection.setRequestMethod("POST");
     OutputStream out = connection.getOutputStream();
@@ -2426,6 +2542,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     out.write('c');
     try {
       out.write('d');
+      out.flush();
       fail();
     } catch (IOException expected) {
     }
@@ -2458,26 +2575,26 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
   @Test public void emptyRequestHeaderValueIsAllowed() throws Exception {
     server.enqueue(new MockResponse().setBody("body"));
     server.play();
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.addRequestProperty("B", "");
-    assertContent("body", urlConnection);
-    assertEquals("", urlConnection.getRequestProperty("B"));
+    connection = client.open(server.getUrl("/"));
+    connection.addRequestProperty("B", "");
+    assertContent("body", connection);
+    assertEquals("", connection.getRequestProperty("B"));
   }
 
   @Test public void emptyResponseHeaderValueIsAllowed() throws Exception {
     server.enqueue(new MockResponse().addHeader("A:").setBody("body"));
     server.play();
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    assertContent("body", urlConnection);
-    assertEquals("", urlConnection.getHeaderField("A"));
+    connection = client.open(server.getUrl("/"));
+    assertContent("body", connection);
+    assertEquals("", connection.getHeaderField("A"));
   }
 
   @Test public void emptyRequestHeaderNameIsStrict() throws Exception {
     server.enqueue(new MockResponse().setBody("body"));
     server.play();
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     try {
-      urlConnection.setRequestProperty("", "A");
+      connection.setRequestProperty("", "A");
       fail();
     } catch (IllegalArgumentException expected) {
     }
@@ -2486,9 +2603,9 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
   @Test public void emptyResponseHeaderNameIsLenient() throws Exception {
     server.enqueue(new MockResponse().addHeader(":A").setBody("body"));
     server.play();
-    HttpURLConnection urlConnection = client.open(server.getUrl("/"));
-    urlConnection.getResponseCode();
-    assertEquals("A", urlConnection.getHeaderField(""));
+    connection = client.open(server.getUrl("/"));
+    connection.getResponseCode();
+    assertEquals("A", connection.getHeaderField(""));
   }
 
   @Test @Ignore public void deflateCompression() {
@@ -2527,6 +2644,71 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     assertTrue(call, call.contains("challenges=[Basic realm=\"protected area\"]"));
   }
 
+  @Test public void npnSetsProtocolHeader_SPDY_3() throws Exception {
+    npnSetsProtocolHeader(Protocol.SPDY_3);
+  }
+
+  @Test public void npnSetsProtocolHeader_HTTP_2() throws Exception {
+    npnSetsProtocolHeader(Protocol.HTTP_2);
+  }
+
+  private void npnSetsProtocolHeader(Protocol protocol) throws IOException {
+    enableNpn(protocol);
+    server.enqueue(new MockResponse().setBody("A"));
+    server.play();
+    client.setProtocols(Arrays.asList(Protocol.HTTP_11, protocol));
+    connection = client.open(server.getUrl("/"));
+    List<String> protocolValues = connection.getHeaderFields().get(SELECTED_PROTOCOL);
+    assertEquals(Arrays.asList(protocol.name.utf8()), protocolValues);
+    assertContent("A", connection);
+  }
+
+  /** For example, empty Protobuf RPC messages end up as a zero-length POST. */
+  @Test public void zeroLengthPost() throws IOException, InterruptedException {
+    zeroLengthPayload("POST");
+  }
+
+  @Test public void zeroLengthPost_SPDY_3() throws Exception {
+    enableNpn(Protocol.SPDY_3);
+    zeroLengthPost();
+  }
+
+  @Test public void zeroLengthPost_HTTP_2() throws Exception {
+    enableNpn(Protocol.HTTP_2);
+    zeroLengthPost();
+  }
+
+  /** For example, creating an Amazon S3 bucket ends up as a zero-length POST. */
+  @Test public void zeroLengthPut() throws IOException, InterruptedException {
+    zeroLengthPayload("PUT");
+  }
+
+  @Test public void zeroLengthPut_SPDY_3() throws Exception {
+    enableNpn(Protocol.SPDY_3);
+    zeroLengthPut();
+  }
+
+  @Test public void zeroLengthPut_HTTP_2() throws Exception {
+    enableNpn(Protocol.HTTP_2);
+    zeroLengthPut();
+  }
+
+  private void zeroLengthPayload(String method)
+      throws IOException, InterruptedException {
+    server.enqueue(new MockResponse());
+    server.play();
+    connection = client.open(server.getUrl("/"));
+    connection.setRequestProperty("Content-Length", "0");
+    connection.setRequestMethod(method);
+    connection.setFixedLengthStreamingMode(0);
+    connection.setDoOutput(true);
+    assertContent("", connection);
+    RecordedRequest zeroLengthPayload = server.takeRequest();
+    assertEquals(method, zeroLengthPayload.getMethod());
+    assertEquals("0", zeroLengthPayload.getHeader("content-length"));
+    assertEquals(0L, zeroLengthPayload.getBodySize());
+  }
+
   @Test public void setProtocols() throws Exception {
     server.enqueue(new MockResponse().setBody("A"));
     server.play();
@@ -2555,7 +2737,7 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     server.enqueue(new MockResponse());
     server.play();
 
-    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection = client.open(server.getUrl("/"));
     connection.setDoOutput(true);
     long contentLength = Integer.MAX_VALUE + 1L;
     connection.setFixedLengthStreamingMode(contentLength);
@@ -2590,12 +2772,10 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     HttpURLConnection connection1 = client.open(server.getUrl("/"));
     assertEquals(HttpURLConnection.HTTP_NOT_MODIFIED, connection1.getResponseCode());
     assertContent("", connection1);
-    connection1.getInputStream().close();
 
     HttpURLConnection connection2 = client.open(server.getUrl("/"));
     assertEquals(HttpURLConnection.HTTP_OK, connection2.getResponseCode());
     assertContent("b", connection2);
-    connection2.getInputStream().close();
 
     RecordedRequest requestA = server.takeRequest();
     assertEquals(0, requestA.getSequenceNumber());
@@ -2604,6 +2784,48 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
     assertEquals(1, requestB.getSequenceNumber());
   }
 
+  /**
+   * We had a bug where we weren't closing Gzip streams on redirects.
+   * https://github.com/square/okhttp/issues/441
+   */
+  @Test public void gzipWithRedirectAndConnectionReuse() throws Exception {
+    server.enqueue(new MockResponse()
+        .setResponseCode(HttpURLConnection.HTTP_MOVED_TEMP)
+        .addHeader("Location: /foo")
+        .addHeader("Content-Encoding: gzip")
+        .setBody(gzip("Moved! Moved! Moved!".getBytes(UTF_8))));
+    server.enqueue(new MockResponse().setBody("This is the new page!"));
+    server.play();
+
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    assertContent("This is the new page!", connection);
+
+    RecordedRequest requestA = server.takeRequest();
+    assertEquals(0, requestA.getSequenceNumber());
+
+    RecordedRequest requestB = server.takeRequest();
+    assertEquals(1, requestB.getSequenceNumber());
+  }
+
+  /**
+   * The RFC is unclear in this regard as it only specifies that this should
+   * invalidate the cache entry (if any).
+   */
+  @Test public void bodyPermittedOnDelete() throws Exception {
+    server.enqueue(new MockResponse());
+    server.play();
+
+    HttpURLConnection connection = client.open(server.getUrl("/"));
+    connection.setRequestMethod("DELETE");
+    connection.setDoOutput(true);
+    connection.getOutputStream().write("BODY".getBytes(UTF_8));
+    assertEquals(200, connection.getResponseCode());
+
+    RecordedRequest request = server.takeRequest();
+    assertEquals("DELETE", request.getMethod());
+    assertEquals("BODY", new String(request.getBody(), UTF_8));
+  }
+
   /** Returns a gzipped copy of {@code bytes}. */
   public byte[] gzip(byte[] bytes) throws IOException {
     ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
@@ -2617,14 +2839,13 @@ private void reusedConnectionFailsWithPost(TransferKind transferKind, int reques
    * Reads at most {@code limit} characters from {@code in} and asserts that
    * content equals {@code expected}.
    */
-  private void assertContent(String expected, URLConnection connection, int limit)
+  private void assertContent(String expected, HttpURLConnection connection, int limit)
       throws IOException {
     connection.connect();
     assertEquals(expected, readAscii(connection.getInputStream(), limit));
-    ((HttpURLConnection) connection).disconnect();
   }
 
-  private void assertContent(String expected, URLConnection connection) throws IOException {
+  private void assertContent(String expected, HttpURLConnection connection) throws IOException {
     assertContent(expected, connection, Integer.MAX_VALUE);
   }
 
@@ -2772,4 +2993,17 @@ private String certificatesToString(X509Certificate[] certificates) {
     @Override public void connectFailed(URI uri, SocketAddress sa, IOException ioe) {
     }
   }
+
+  /**
+   * Tests that use this will fail unless boot classpath is set. Ex. {@code
+   * -Xbootclasspath/p:/tmp/npn-boot-8.1.2.v20120308.jar}
+   */
+  private void enableNpn(Protocol protocol) {
+    client.setSslSocketFactory(sslContext.getSocketFactory());
+    client.setHostnameVerifier(new RecordingHostnameVerifier());
+    client.setProtocols(Arrays.asList(protocol, Protocol.HTTP_11));
+    server.useHttps(sslContext.getSocketFactory(), false);
+    server.setNpnEnabled(true);
+    server.setNpnProtocols(client.getProtocols());
+  }
 }
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/URLEncodingTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLEncodingTest.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/http/URLEncodingTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/http/URLEncodingTest.java
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
similarity index 80%
rename from okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
index dc08d2f6f4..8f709220ed 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/BaseTestHandler.java
@@ -16,13 +16,14 @@
 package com.squareup.okhttp.internal.spdy;
 
 import java.io.IOException;
-import java.io.InputStream;
 import java.util.List;
+import okio.BufferedSource;
+import okio.ByteString;
 
 import static org.junit.Assert.fail;
 
 class BaseTestHandler implements FrameReader.Handler {
-  @Override public void data(boolean inFinished, int streamId, InputStream in, int length)
+  @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
       throws IOException {
     fail();
   }
@@ -41,7 +42,7 @@ public void headers(boolean outFinished, boolean inFinished, int streamId, int a
     fail();
   }
 
-  @Override public void noop() {
+  @Override public void ackSettings() {
     fail();
   }
 
@@ -49,13 +50,11 @@ public void headers(boolean outFinished, boolean inFinished, int streamId, int a
     fail();
   }
 
-  @Override
-  public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
+  @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
     fail();
   }
 
-  @Override
-  public void windowUpdate(int streamId, long windowSizeIncrement) {
+  @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
     fail();
   }
 
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
similarity index 62%
rename from okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
index f4d4709429..42ddcabc3b 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HpackDraft05Test.java
@@ -15,30 +15,50 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.ByteString;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
 import java.io.IOException;
-import java.io.InputStream;
 import java.util.Arrays;
 import java.util.List;
+import okio.ByteString;
+import okio.OkBuffer;
 import org.junit.Before;
 import org.junit.Test;
 
 import static com.squareup.okhttp.internal.Util.headerEntries;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 
 public class HpackDraft05Test {
 
-  private final MutableByteArrayInputStream bytesIn = new MutableByteArrayInputStream();
+  private final OkBuffer bytesIn = new OkBuffer();
   private HpackDraft05.Reader hpackReader;
+  private OkBuffer bytesOut = new OkBuffer();
+  private HpackDraft05.Writer hpackWriter;
 
-  @Before public void resetReader() {
+  @Before public void reset() {
     hpackReader = newReader(bytesIn);
+    hpackWriter = new HpackDraft05.Writer(bytesOut);
+  }
+
+  /**
+   * Variable-length quantity special cases strings which are longer than 127
+   * bytes.  Values such as cookies can be 4KiB, and should be possible to send.
+   *
+   * <p> http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#section-4.1.2
+   */
+  @Test public void largeHeaderValue() throws IOException {
+    char[] value = new char[4096];
+    Arrays.fill(value, '!');
+    List<Header> headerBlock = headerEntries("cookie", new String(value));
+
+    hpackWriter.writeHeaders(headerBlock);
+    bytesIn.write(bytesOut, bytesOut.size());
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndReset());
   }
 
   /**
@@ -46,16 +66,16 @@
    * Ensure the larger header content is not lost.
    */
   @Test public void tooLargeToHPackIsStillEmitted() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    OkBuffer out = new OkBuffer();
 
-    out.write(0x00); // Literal indexed
-    out.write(0x0a); // Literal name (len = 10)
-    out.write("custom-key".getBytes(), 0, 10);
+    out.writeByte(0x00); // Literal indexed
+    out.writeByte(0x0a); // Literal name (len = 10)
+    out.writeUtf8("custom-key");
 
-    out.write(0x0d); // Literal value (len = 13)
-    out.write("custom-header".getBytes(), 0, 13);
+    out.writeByte(0x0d); // Literal value (len = 13)
+    out.writeUtf8("custom-header");
 
-    bytesIn.set(out.toByteArray());
+    bytesIn.write(out, out.size());
     hpackReader.maxHeaderTableByteCount(1);
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
@@ -67,30 +87,30 @@
 
   /** Oldest entries are evicted to support newer ones. */
   @Test public void testEviction() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    OkBuffer out = new OkBuffer();
 
-    out.write(0x00); // Literal indexed
-    out.write(0x0a); // Literal name (len = 10)
-    out.write("custom-foo".getBytes(), 0, 10);
+    out.writeByte(0x00); // Literal indexed
+    out.writeByte(0x0a); // Literal name (len = 10)
+    out.writeUtf8("custom-foo");
 
-    out.write(0x0d); // Literal value (len = 13)
-    out.write("custom-header".getBytes(), 0, 13);
+    out.writeByte(0x0d); // Literal value (len = 13)
+    out.writeUtf8("custom-header");
 
-    out.write(0x00); // Literal indexed
-    out.write(0x0a); // Literal name (len = 10)
-    out.write("custom-bar".getBytes(), 0, 10);
+    out.writeByte(0x00); // Literal indexed
+    out.writeByte(0x0a); // Literal name (len = 10)
+    out.writeUtf8("custom-bar");
 
-    out.write(0x0d); // Literal value (len = 13)
-    out.write("custom-header".getBytes(), 0, 13);
+    out.writeByte(0x0d); // Literal value (len = 13)
+    out.writeUtf8("custom-header");
 
-    out.write(0x00); // Literal indexed
-    out.write(0x0a); // Literal name (len = 10)
-    out.write("custom-baz".getBytes(), 0, 10);
+    out.writeByte(0x00); // Literal indexed
+    out.writeByte(0x0a); // Literal name (len = 10)
+    out.writeUtf8("custom-baz");
 
-    out.write(0x0d); // Literal value (len = 13)
-    out.write("custom-header".getBytes(), 0, 13);
+    out.writeByte(0x0d); // Literal value (len = 13)
+    out.writeUtf8("custom-header");
 
-    bytesIn.set(out.toByteArray());
+    bytesIn.write(out, out.size());
     // Set to only support 110 bytes (enough for 2 headers).
     hpackReader.maxHeaderTableByteCount(110);
     hpackReader.readHeaders();
@@ -118,18 +138,18 @@
 
   /** Header table backing array is initially 8 long, let's ensure it grows. */
   @Test public void dynamicallyGrowsBeyond64Entries() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    OkBuffer out = new OkBuffer();
 
     for (int i = 0; i < 256; i++) {
-      out.write(0x00); // Literal indexed
-      out.write(0x0a); // Literal name (len = 10)
-      out.write("custom-foo".getBytes(), 0, 10);
+      out.writeByte(0x00); // Literal indexed
+      out.writeByte(0x0a); // Literal name (len = 10)
+      out.writeUtf8("custom-foo");
 
-      out.write(0x0d); // Literal value (len = 13)
-      out.write("custom-header".getBytes(), 0, 13);
+      out.writeByte(0x0d); // Literal value (len = 13)
+      out.writeUtf8("custom-header");
     }
 
-    bytesIn.set(out.toByteArray());
+    bytesIn.write(out, out.size());
     hpackReader.maxHeaderTableByteCount(16384); // Lots of headers need more room!
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
@@ -140,19 +160,19 @@
   }
 
   @Test public void huffmanDecodingSupported() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    OkBuffer out = new OkBuffer();
 
-    out.write(0x04); // == Literal indexed ==
-                     // Indexed name (idx = 4) -> :path
-    out.write(0x8b); // Literal value Huffman encoded 11 bytes
-                     // decodes to www.example.com which is length 15
+    out.writeByte(0x04); // == Literal indexed ==
+                         // Indexed name (idx = 4) -> :path
+    out.writeByte(0x8b); // Literal value Huffman encoded 11 bytes
+                         // decodes to www.example.com which is length 15
     byte[] huffmanBytes = new byte[] {
         (byte) 0xdb, (byte) 0x6d, (byte) 0x88, (byte) 0x3e,
         (byte) 0x68, (byte) 0xd1, (byte) 0xcb, (byte) 0x12,
         (byte) 0x25, (byte) 0xba, (byte) 0x7f};
     out.write(huffmanBytes, 0, huffmanBytes.length);
 
-    bytesIn.set(out.toByteArray());
+    bytesIn.write(out, out.size());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -167,17 +187,17 @@
   /**
    * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.1
    */
-  @Test public void decodeLiteralHeaderFieldWithIndexing() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+  @Test public void readLiteralHeaderFieldWithIndexing() throws IOException {
+    OkBuffer out = new OkBuffer();
 
-    out.write(0x00); // Literal indexed
-    out.write(0x0a); // Literal name (len = 10)
-    out.write("custom-key".getBytes(), 0, 10);
+    out.writeByte(0x00); // Literal indexed
+    out.writeByte(0x0a); // Literal name (len = 10)
+    out.writeUtf8("custom-key");
 
-    out.write(0x0d); // Literal value (len = 13)
-    out.write("custom-header".getBytes(), 0, 13);
+    out.writeByte(0x0d); // Literal value (len = 13)
+    out.writeUtf8("custom-header");
 
-    bytesIn.set(out.toByteArray());
+    bytesIn.write(out, out.size());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -191,36 +211,64 @@
     assertEquals(headerEntries("custom-key", "custom-header"), hpackReader.getAndReset());
   }
 
+  /**
+   * Literal Header Field without Indexing - New Name
+   */
+  @Test public void literalHeaderFieldWithoutIndexingNewName() throws IOException {
+    List<Header> headerBlock = headerEntries("custom-key", "custom-header");
+
+    OkBuffer expectedBytes = new OkBuffer();
+
+    expectedBytes.writeByte(0x40); // Not indexed
+    expectedBytes.writeByte(0x0a); // Literal name (len = 10)
+    expectedBytes.write("custom-key".getBytes(), 0, 10);
+
+    expectedBytes.writeByte(0x0d); // Literal value (len = 13)
+    expectedBytes.write("custom-header".getBytes(), 0, 13);
+
+    hpackWriter.writeHeaders(headerBlock);
+    assertEquals(expectedBytes, bytesOut);
+
+    bytesIn.write(bytesOut, bytesOut.size());
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+
+    assertEquals(0, hpackReader.headerCount);
+
+    assertEquals(headerBlock, hpackReader.getAndReset());
+  }
+
   /**
    * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.2
    */
-  @Test public void decodeLiteralHeaderFieldWithoutIndexingIndexedName() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+  @Test public void literalHeaderFieldWithoutIndexingIndexedName() throws IOException {
+    List<Header> headerBlock = headerEntries(":path", "/sample/path");
 
-    out.write(0x44); // == Literal not indexed ==
-                     // Indexed name (idx = 4) -> :path
-    out.write(0x0c); // Literal value (len = 12)
-    out.write("/sample/path".getBytes(), 0, 12);
+    OkBuffer expectedBytes = new OkBuffer();
+    expectedBytes.writeByte(0x44); // == Literal not indexed ==
+                                   // Indexed name (idx = 4) -> :path
+    expectedBytes.writeByte(0x0c); // Literal value (len = 12)
+    expectedBytes.write("/sample/path".getBytes(), 0, 12);
 
-    bytesIn.set(out.toByteArray());
+    hpackWriter.writeHeaders(headerBlock);
+    assertEquals(expectedBytes, bytesOut);
+
+    bytesIn.write(bytesOut, bytesOut.size());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
     assertEquals(0, hpackReader.headerCount);
 
-    assertEquals(headerEntries(":path", "/sample/path"), hpackReader.getAndReset());
+    assertEquals(headerBlock, hpackReader.getAndReset());
   }
 
   /**
    * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.3
    */
-  @Test public void decodeIndexedHeaderField() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-
-    out.write(0x82); // == Indexed - Add ==
-                     // idx = 2 -> :method: GET
+  @Test public void readIndexedHeaderField() throws IOException {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
 
-    bytesIn.set(out.toByteArray());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -238,16 +286,13 @@
    * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#section-3.2.1
    */
   @Test public void toggleIndex() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-
     // Static table entries are copied to the top of the reference set.
-    out.write(0x82); // == Indexed - Add ==
-                     // idx = 2 -> :method: GET
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
     // Specifying an index to an entry in the reference set removes it.
-    out.write(0x81); // == Indexed - Remove ==
-                     // idx = 1 -> :method: GET
+    bytesIn.writeByte(0x81); // == Indexed - Remove ==
+                             // idx = 1 -> :method: GET
 
-    bytesIn.set(out.toByteArray());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
 
@@ -261,16 +306,55 @@
     assertTrue(hpackReader.getAndReset().isEmpty());
   }
 
+  /** Ensure a later toggle of the same index emits! */
+  @Test public void toggleIndexOffOn() throws IOException {
+
+    bytesIn.writeByte(0x82); // Copy static header 1 to the header table as index 1.
+    bytesIn.writeByte(0x81); // Remove index 1 from the reference set.
+
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+    assertEquals(1, hpackReader.headerCount);
+    assertTrue(hpackReader.getAndReset().isEmpty());
+
+    bytesIn.writeByte(0x81); // Add index 1 back to the reference set.
+
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+    assertEquals(1, hpackReader.headerCount);
+    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndReset());
+  }
+
+  /** Check later toggle of the same index for large header sets. */
+  @Test public void toggleIndexOffBeyond64Entries() throws IOException {
+    int expectedHeaderCount = 65;
+
+    for (int i = 0; i < expectedHeaderCount; i++) {
+      bytesIn.writeByte(0x82 + i); // Copy static header 1 to the header table as index 1.
+      bytesIn.writeByte(0x81); // Remove index 1 from the reference set.
+    }
+
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+    assertEquals(expectedHeaderCount, hpackReader.headerCount);
+    assertTrue(hpackReader.getAndReset().isEmpty());
+
+    bytesIn.writeByte(0x81); // Add index 1 back to the reference set.
+
+    hpackReader.readHeaders();
+    hpackReader.emitReferenceSet();
+    assertEquals(expectedHeaderCount, hpackReader.headerCount);
+    assertHeaderReferenced(headerTableLength() - expectedHeaderCount);
+    assertEquals(headerEntries(":method", "GET"), hpackReader.getAndReset());
+  }
+
   /**
    * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.1.4
    */
-  @Test public void decodeIndexedHeaderFieldFromStaticTableWithoutBuffering() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+  @Test public void readIndexedHeaderFieldFromStaticTableWithoutBuffering() throws IOException {
+    bytesIn.writeByte(0x82); // == Indexed - Add ==
+                             // idx = 2 -> :method: GET
 
-    out.write(0x82); // == Indexed - Add ==
-                     // idx = 2 -> :method: GET
-
-    bytesIn.set(out.toByteArray());
     hpackReader.maxHeaderTableByteCount(0); // SETTINGS_HEADER_TABLE_SIZE == 0
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
@@ -284,44 +368,44 @@
   /**
    * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.2
    */
-  @Test public void decodeRequestExamplesWithoutHuffman() throws IOException {
-    ByteArrayOutputStream out = firstRequestWithoutHuffman();
-    bytesIn.set(out.toByteArray());
+  @Test public void readRequestExamplesWithoutHuffman() throws IOException {
+    OkBuffer out = firstRequestWithoutHuffman();
+    bytesIn.write(out, out.size());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
-    checkFirstRequestWithoutHuffman();
+    checkReadFirstRequestWithoutHuffman();
 
     out = secondRequestWithoutHuffman();
-    bytesIn.set(out.toByteArray());
+    bytesIn.write(out, out.size());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
-    checkSecondRequestWithoutHuffman();
+    checkReadSecondRequestWithoutHuffman();
 
     out = thirdRequestWithoutHuffman();
-    bytesIn.set(out.toByteArray());
+    bytesIn.write(out, out.size());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
-    checkThirdRequestWithoutHuffman();
+    checkReadThirdRequestWithoutHuffman();
   }
 
-  private ByteArrayOutputStream firstRequestWithoutHuffman() {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+  private OkBuffer firstRequestWithoutHuffman() {
+    OkBuffer out = new OkBuffer();
 
-    out.write(0x82); // == Indexed - Add ==
-                     // idx = 2 -> :method: GET
-    out.write(0x87); // == Indexed - Add ==
-                     // idx = 7 -> :scheme: http
-    out.write(0x86); // == Indexed - Add ==
-                     // idx = 6 -> :path: /
-    out.write(0x04); // == Literal indexed ==
-                     // Indexed name (idx = 4) -> :authority
-    out.write(0x0f); // Literal value (len = 15)
-    out.write("www.example.com".getBytes(), 0, 15);
+    out.writeByte(0x82); // == Indexed - Add ==
+                         // idx = 2 -> :method: GET
+    out.writeByte(0x87); // == Indexed - Add ==
+                         // idx = 7 -> :scheme: http
+    out.writeByte(0x86); // == Indexed - Add ==
+                         // idx = 6 -> :path: /
+    out.writeByte(0x04); // == Literal indexed ==
+                         // Indexed name (idx = 4) -> :authority
+    out.writeByte(0x0f); // Literal value (len = 15)
+    out.writeUtf8("www.example.com");
 
     return out;
   }
 
-  private void checkFirstRequestWithoutHuffman() {
+  private void checkReadFirstRequestWithoutHuffman() {
     assertEquals(4, hpackReader.headerCount);
 
     // [  1] (s =  57) :authority: www.example.com
@@ -355,18 +439,18 @@ private void checkFirstRequestWithoutHuffman() {
         ":authority", "www.example.com"), hpackReader.getAndReset());
   }
 
-  private ByteArrayOutputStream secondRequestWithoutHuffman() {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+  private OkBuffer secondRequestWithoutHuffman() {
+    OkBuffer out = new OkBuffer();
 
-    out.write(0x1b); // == Literal indexed ==
-                     // Indexed name (idx = 27) -> cache-control
-    out.write(0x08); // Literal value (len = 8)
-    out.write("no-cache".getBytes(), 0, 8);
+    out.writeByte(0x1b); // == Literal indexed ==
+                         // Indexed name (idx = 27) -> cache-control
+    out.writeByte(0x08); // Literal value (len = 8)
+    out.writeUtf8("no-cache");
 
     return out;
   }
 
-  private void checkSecondRequestWithoutHuffman() {
+  private void checkReadSecondRequestWithoutHuffman() {
     assertEquals(5, hpackReader.headerCount);
 
     // [  1] (s =  53) cache-control: no-cache
@@ -406,28 +490,28 @@ private void checkSecondRequestWithoutHuffman() {
         "cache-control", "no-cache"), hpackReader.getAndReset());
   }
 
-  private ByteArrayOutputStream thirdRequestWithoutHuffman() {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-
-    out.write(0x80); // == Empty reference set ==
-    out.write(0x85); // == Indexed - Add ==
-                     // idx = 5 -> :method: GET
-    out.write(0x8c); // == Indexed - Add ==
-                     // idx = 12 -> :scheme: https
-    out.write(0x8b); // == Indexed - Add ==
-                     // idx = 11 -> :path: /index.html
-    out.write(0x84); // == Indexed - Add ==
-                     // idx = 4 -> :authority: www.example.com
-    out.write(0x00); // Literal indexed
-    out.write(0x0a); // Literal name (len = 10)
-    out.write("custom-key".getBytes(), 0, 10);
-    out.write(0x0c); // Literal value (len = 12)
-    out.write("custom-value".getBytes(), 0, 12);
+  private OkBuffer thirdRequestWithoutHuffman() {
+    OkBuffer out = new OkBuffer();
+
+    out.writeByte(0x80); // == Empty reference set ==
+    out.writeByte(0x85); // == Indexed - Add ==
+                         // idx = 5 -> :method: GET
+    out.writeByte(0x8c); // == Indexed - Add ==
+                         // idx = 12 -> :scheme: https
+    out.writeByte(0x8b); // == Indexed - Add ==
+                         // idx = 11 -> :path: /index.html
+    out.writeByte(0x84); // == Indexed - Add ==
+                         // idx = 4 -> :authority: www.example.com
+    out.writeByte(0x00); // Literal indexed
+    out.writeByte(0x0a); // Literal name (len = 10)
+    out.writeUtf8("custom-key");
+    out.writeByte(0x0c); // Literal value (len = 12)
+    out.writeUtf8("custom-value");
 
     return out;
   }
 
-  private void checkThirdRequestWithoutHuffman() {
+  private void checkReadThirdRequestWithoutHuffman() {
     assertEquals(8, hpackReader.headerCount);
 
     // [  1] (s =  54) custom-key: custom-value
@@ -486,39 +570,39 @@ private void checkThirdRequestWithoutHuffman() {
   /**
    * http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-05#appendix-E.3
    */
-  @Test public void decodeRequestExamplesWithHuffman() throws IOException {
-    ByteArrayOutputStream out = firstRequestWithHuffman();
-    bytesIn.set(out.toByteArray());
+  @Test public void readRequestExamplesWithHuffman() throws IOException {
+    OkBuffer out = firstRequestWithHuffman();
+    bytesIn.write(out, out.size());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
-    checkFirstRequestWithHuffman();
+    checkReadFirstRequestWithHuffman();
 
     out = secondRequestWithHuffman();
-    bytesIn.set(out.toByteArray());
+    bytesIn.write(out, out.size());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
-    checkSecondRequestWithHuffman();
+    checkReadSecondRequestWithHuffman();
 
     out = thirdRequestWithHuffman();
-    bytesIn.set(out.toByteArray());
+    bytesIn.write(out, out.size());
     hpackReader.readHeaders();
     hpackReader.emitReferenceSet();
-    checkThirdRequestWithHuffman();
-  }
-
-  private ByteArrayOutputStream firstRequestWithHuffman() {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-
-    out.write(0x82); // == Indexed - Add ==
-                     // idx = 2 -> :method: GET
-    out.write(0x87); // == Indexed - Add ==
-                     // idx = 7 -> :scheme: http
-    out.write(0x86); // == Indexed - Add ==
-                     // idx = 6 -> :path: /
-    out.write(0x04); // == Literal indexed ==
-                     // Indexed name (idx = 4) -> :authority
-    out.write(0x8b); // Literal value Huffman encoded 11 bytes
-                     // decodes to www.example.com which is length 15
+    checkReadThirdRequestWithHuffman();
+  }
+
+  private OkBuffer firstRequestWithHuffman() {
+    OkBuffer out = new OkBuffer();
+
+    out.writeByte(0x82); // == Indexed - Add ==
+                         // idx = 2 -> :method: GET
+    out.writeByte(0x87); // == Indexed - Add ==
+                         // idx = 7 -> :scheme: http
+    out.writeByte(0x86); // == Indexed - Add ==
+                         // idx = 6 -> :path: /
+    out.writeByte(0x04); // == Literal indexed ==
+                         // Indexed name (idx = 4) -> :authority
+    out.writeByte(0x8b); // Literal value Huffman encoded 11 bytes
+                         // decodes to www.example.com which is length 15
     byte[] huffmanBytes = new byte[] {
         (byte) 0xdb, (byte) 0x6d, (byte) 0x88, (byte) 0x3e,
         (byte) 0x68, (byte) 0xd1, (byte) 0xcb, (byte) 0x12,
@@ -528,7 +612,7 @@ private ByteArrayOutputStream firstRequestWithHuffman() {
     return out;
   }
 
-  private void checkFirstRequestWithHuffman() {
+  private void checkReadFirstRequestWithHuffman() {
     assertEquals(4, hpackReader.headerCount);
 
     // [  1] (s =  57) :authority: www.example.com
@@ -562,13 +646,13 @@ private void checkFirstRequestWithHuffman() {
         ":authority", "www.example.com"), hpackReader.getAndReset());
   }
 
-  private ByteArrayOutputStream secondRequestWithHuffman() {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+  private OkBuffer secondRequestWithHuffman() {
+    OkBuffer out = new OkBuffer();
 
-    out.write(0x1b); // == Literal indexed ==
-                     // Indexed name (idx = 27) -> cache-control
-    out.write(0x86); // Literal value Huffman encoded 6 bytes
-                     // decodes to no-cache which is length 8
+    out.writeByte(0x1b); // == Literal indexed ==
+                         // Indexed name (idx = 27) -> cache-control
+    out.writeByte(0x86); // Literal value Huffman encoded 6 bytes
+                         // decodes to no-cache which is length 8
     byte[] huffmanBytes = new byte[] {
         (byte) 0x63, (byte) 0x65, (byte) 0x4a, (byte) 0x13,
         (byte) 0x98, (byte) 0xff};
@@ -577,7 +661,7 @@ private ByteArrayOutputStream secondRequestWithHuffman() {
     return out;
   }
 
-  private void checkSecondRequestWithHuffman() {
+  private void checkReadSecondRequestWithHuffman() {
     assertEquals(5, hpackReader.headerCount);
 
     // [  1] (s =  53) cache-control: no-cache
@@ -617,27 +701,27 @@ private void checkSecondRequestWithHuffman() {
         "cache-control", "no-cache"), hpackReader.getAndReset());
   }
 
-  private ByteArrayOutputStream thirdRequestWithHuffman() {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-
-    out.write(0x80); // == Empty reference set ==
-    out.write(0x85); // == Indexed - Add ==
-                     // idx = 5 -> :method: GET
-    out.write(0x8c); // == Indexed - Add ==
-                     // idx = 12 -> :scheme: https
-    out.write(0x8b); // == Indexed - Add ==
-                     // idx = 11 -> :path: /index.html
-    out.write(0x84); // == Indexed - Add ==
-                     // idx = 4 -> :authority: www.example.com
-    out.write(0x00); // Literal indexed
-    out.write(0x88); // Literal name Huffman encoded 8 bytes
-                     // decodes to custom-key which is length 10
+  private OkBuffer thirdRequestWithHuffman() {
+    OkBuffer out = new OkBuffer();
+
+    out.writeByte(0x80); // == Empty reference set ==
+    out.writeByte(0x85); // == Indexed - Add ==
+                         // idx = 5 -> :method: GET
+    out.writeByte(0x8c); // == Indexed - Add ==
+                         // idx = 12 -> :scheme: https
+    out.writeByte(0x8b); // == Indexed - Add ==
+                         // idx = 11 -> :path: /index.html
+    out.writeByte(0x84); // == Indexed - Add ==
+                         // idx = 4 -> :authority: www.example.com
+    out.writeByte(0x00); // Literal indexed
+    out.writeByte(0x88); // Literal name Huffman encoded 8 bytes
+                         // decodes to custom-key which is length 10
     byte[] huffmanBytes = new byte[] {
         (byte) 0x4e, (byte) 0xb0, (byte) 0x8b, (byte) 0x74,
         (byte) 0x97, (byte) 0x90, (byte) 0xfa, (byte) 0x7f};
     out.write(huffmanBytes, 0, huffmanBytes.length);
-    out.write(0x89); // Literal value Huffman encoded 6 bytes
-                     // decodes to custom-value which is length 12
+    out.writeByte(0x89); // Literal value Huffman encoded 6 bytes
+                         // decodes to custom-value which is length 12
     huffmanBytes = new byte[] {
         (byte) 0x4e, (byte) 0xb0, (byte) 0x8b, (byte) 0x74,
         (byte) 0x97, (byte) 0x9a, (byte) 0x17, (byte) 0xa8,
@@ -647,7 +731,7 @@ private ByteArrayOutputStream thirdRequestWithHuffman() {
     return out;
   }
 
-  private void checkThirdRequestWithHuffman() {
+  private void checkReadThirdRequestWithHuffman() {
     assertEquals(8, hpackReader.headerCount);
 
     // [  1] (s =  54) custom-key: custom-value
@@ -703,10 +787,6 @@ private void checkThirdRequestWithHuffman() {
         "custom-key", "custom-value"), hpackReader.getAndReset());
   }
 
-  private ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-  private final HpackDraft05.Writer hpackWriter =
-      new HpackDraft05.Writer(new DataOutputStream(bytesOut));
-
   @Test public void readSingleByteInt() throws IOException {
     assertEquals(10, newReader(byteStream()).readInt(10, 31));
     assertEquals(10, newReader(byteStream()).readInt(0xe0 | 10, 31));
@@ -764,28 +844,16 @@ private void checkThirdRequestWithHuffman() {
   @Test public void emptyHeaderName() throws IOException {
     hpackWriter.writeByteString(ByteString.encodeUtf8(""));
     assertBytes(0);
-    assertSame(ByteString.EMPTY, newReader(byteStream(0)).readByteString(true));
-    assertSame(ByteString.EMPTY, newReader(byteStream(0)).readByteString(false));
+    assertEquals(ByteString.EMPTY, newReader(byteStream(0)).readByteString(true));
+    assertEquals(ByteString.EMPTY, newReader(byteStream(0)).readByteString(false));
   }
 
-  @Test public void headersRoundTrip() throws IOException {
-    List<Header> sentHeaders = headerEntries("name", "value");
-    hpackWriter.writeHeaders(sentHeaders);
-    ByteArrayInputStream bytesIn = new ByteArrayInputStream(bytesOut.toByteArray());
-    HpackDraft05.Reader reader = newReader(bytesIn);
-    reader.readHeaders();
-    reader.emitReferenceSet();
-    List<Header> receivedHeaders = reader.getAndReset();
-    assertEquals(sentHeaders, receivedHeaders);
+  private HpackDraft05.Reader newReader(OkBuffer source) {
+    return new HpackDraft05.Reader(false, 4096, source);
   }
 
-  private HpackDraft05.Reader newReader(InputStream input) {
-    return new HpackDraft05.Reader(false, 4096, input);
-  }
-
-  private InputStream byteStream(int... bytes) {
-    byte[] data = intArrayToByteArray(bytes);
-    return new ByteArrayInputStream(data);
+  private OkBuffer byteStream(int... bytes) {
+    return new OkBuffer().write(intArrayToByteArray(bytes));
   }
 
   private void checkEntry(Header entry, String name, String value, int size) {
@@ -795,18 +863,17 @@ private void checkEntry(Header entry, String name, String value, int size) {
   }
 
   private void assertBytes(int... bytes) {
-    byte[] expected = intArrayToByteArray(bytes);
-    byte[] actual = bytesOut.toByteArray();
-    assertEquals(Arrays.toString(expected), Arrays.toString(actual));
-    bytesOut.reset(); // So the next test starts with a clean slate.
+    ByteString expected = intArrayToByteArray(bytes);
+    ByteString actual = bytesOut.readByteString(bytesOut.size());
+    assertEquals(expected, actual);
   }
 
-  private byte[] intArrayToByteArray(int[] bytes) {
+  private ByteString intArrayToByteArray(int[] bytes) {
     byte[] data = new byte[bytes.length];
     for (int i = 0; i < bytes.length; i++) {
       data[i] = (byte) bytes[i];
     }
-    return data;
+    return ByteString.of(data);
   }
 
   private void assertHeaderReferenced(int index) {
@@ -820,17 +887,4 @@ private void assertHeaderNotReferenced(int index) {
   private int headerTableLength() {
     return hpackReader.headerTable.length;
   }
-
-  static class MutableByteArrayInputStream extends ByteArrayInputStream {
-
-    MutableByteArrayInputStream() {
-      super(new byte[] { });
-    }
-
-    void set(byte[] replacement) {
-      this.buf = replacement;
-      this.pos = 0;
-      this.count = replacement.length;
-    }
-  }
 }
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
similarity index 52%
rename from okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
index 8a8aaedfc7..248ea094c5 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Http20Draft09Test.java
@@ -16,17 +16,15 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
 import java.io.IOException;
-import java.io.InputStream;
 import java.util.Arrays;
 import java.util.List;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.OkBuffer;
 import org.junit.Test;
 
 import static com.squareup.okhttp.internal.Util.headerEntries;
-import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
@@ -36,16 +34,15 @@
   static final int expectedStreamId = 15;
 
   @Test public void unknownFrameTypeIgnored() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
-    dataOut.writeShort(4); // has a 4-byte field
-    dataOut.write(99); // type 99
-    dataOut.write(0); // no flags
-    dataOut.writeInt(expectedStreamId);
-    dataOut.writeInt(111111111); // custom data
+    frame.writeShort(4); // has a 4-byte field
+    frame.writeByte(99); // type 99
+    frame.writeByte(0); // no flags
+    frame.writeInt(expectedStreamId);
+    frame.writeInt(111111111); // custom data
 
-    FrameReader fr = newReader(out);
+    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
 
     // Consume the unknown frame.
     fr.nextFrame(new BaseTestHandler());
@@ -54,20 +51,19 @@
   @Test public void onlyOneLiteralHeadersFrame() throws IOException {
     final List<Header> sentHeaders = headerEntries("name", "value");
 
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
     // Write the headers frame, specifying no more frames are expected.
     {
-      byte[] headerBytes = literalHeaders(sentHeaders);
-      dataOut.writeShort(headerBytes.length);
-      dataOut.write(Http20Draft09.TYPE_HEADERS);
-      dataOut.write(Http20Draft09.FLAG_END_HEADERS | Http20Draft09.FLAG_END_STREAM);
-      dataOut.writeInt(expectedStreamId & 0x7fffffff);
-      dataOut.write(headerBytes);
+      OkBuffer headerBytes = literalHeaders(sentHeaders);
+      frame.writeShort((int) headerBytes.size());
+      frame.writeByte(Http20Draft09.TYPE_HEADERS);
+      frame.writeByte(Http20Draft09.FLAG_END_HEADERS | Http20Draft09.FLAG_END_STREAM);
+      frame.writeInt(expectedStreamId & 0x7fffffff);
+      frame.write(headerBytes, headerBytes.size());
     }
 
-    FrameReader fr = newReader(out);
+    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
 
     // Consume the headers frame.
     fr.nextFrame(new BaseTestHandler() {
@@ -88,22 +84,21 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
   }
 
   @Test public void headersWithPriority() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
     final List<Header> sentHeaders = headerEntries("name", "value");
 
     { // Write the headers frame, specifying priority flag and value.
-      byte[] headerBytes = literalHeaders(sentHeaders);
-      dataOut.writeShort(headerBytes.length + 4);
-      dataOut.write(Http20Draft09.TYPE_HEADERS);
-      dataOut.write(Http20Draft09.FLAG_END_HEADERS | Http20Draft09.FLAG_PRIORITY);
-      dataOut.writeInt(expectedStreamId & 0x7fffffff);
-      dataOut.writeInt(0); // Highest priority is 0.
-      dataOut.write(headerBytes);
+      OkBuffer headerBytes = literalHeaders(sentHeaders);
+      frame.writeShort((int) (headerBytes.size() + 4));
+      frame.writeByte(Http20Draft09.TYPE_HEADERS);
+      frame.writeByte(Http20Draft09.FLAG_END_HEADERS | Http20Draft09.FLAG_PRIORITY);
+      frame.writeInt(expectedStreamId & 0x7fffffff);
+      frame.writeInt(0); // Highest priority is 0.
+      frame.write(headerBytes, headerBytes.size());
     }
 
-    FrameReader fr = newReader(out);
+    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
 
     // Consume the headers frame.
     fr.nextFrame(new BaseTestHandler() {
@@ -126,28 +121,27 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
   /** Headers are compressed, then framed. */
   @Test public void headersFrameThenContinuation() throws IOException {
 
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
     // Decoding the first header will cross frame boundaries.
-    byte[] headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
+    OkBuffer headerBlock = literalHeaders(headerEntries("foo", "barrr", "baz", "qux"));
     { // Write the first headers frame.
-      dataOut.writeShort(headerBlock.length / 2);
-      dataOut.write(Http20Draft09.TYPE_HEADERS);
-      dataOut.write(0); // no flags
-      dataOut.writeInt(expectedStreamId & 0x7fffffff);
-      dataOut.write(headerBlock, 0, headerBlock.length / 2);
+      frame.writeShort((int) (headerBlock.size() / 2));
+      frame.writeByte(Http20Draft09.TYPE_HEADERS);
+      frame.writeByte(0); // no flags
+      frame.writeInt(expectedStreamId & 0x7fffffff);
+      frame.write(headerBlock, headerBlock.size() / 2);
     }
 
     { // Write the continuation frame, specifying no more frames are expected.
-      dataOut.writeShort(headerBlock.length / 2);
-      dataOut.write(Http20Draft09.TYPE_CONTINUATION);
-      dataOut.write(Http20Draft09.FLAG_END_HEADERS);
-      dataOut.writeInt(expectedStreamId & 0x7fffffff);
-      dataOut.write(headerBlock, headerBlock.length / 2, headerBlock.length / 2);
+      frame.writeShort((int) headerBlock.size());
+      frame.writeByte(Http20Draft09.TYPE_CONTINUATION);
+      frame.writeByte(Http20Draft09.FLAG_END_HEADERS);
+      frame.writeInt(expectedStreamId & 0x7fffffff);
+      frame.write(headerBlock, headerBlock.size());
     }
 
-    FrameReader fr = newReader(out);
+    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
 
     // Reading the above frames should result in a concatenated headerBlock.
     fr.nextFrame(new BaseTestHandler() {
@@ -168,8 +162,7 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
   }
 
   @Test public void pushPromise() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
     final int expectedPromisedStreamId = 11;
 
@@ -181,16 +174,16 @@ public void headers(boolean outFinished, boolean inFinished, int streamId,
     );
 
     { // Write the push promise frame, specifying the associated stream ID.
-      byte[] headerBytes = literalHeaders(pushPromise);
-      dataOut.writeShort(headerBytes.length + 4);
-      dataOut.write(Http20Draft09.TYPE_PUSH_PROMISE);
-      dataOut.write(Http20Draft09.FLAG_END_PUSH_PROMISE);
-      dataOut.writeInt(expectedStreamId & 0x7fffffff);
-      dataOut.writeInt(expectedPromisedStreamId & 0x7fffffff);
-      dataOut.write(headerBytes);
+      OkBuffer headerBytes = literalHeaders(pushPromise);
+      frame.writeShort((int) (headerBytes.size() + 4));
+      frame.writeByte(Http20Draft09.TYPE_PUSH_PROMISE);
+      frame.writeByte(Http20Draft09.FLAG_END_PUSH_PROMISE);
+      frame.writeInt(expectedStreamId & 0x7fffffff);
+      frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
+      frame.write(headerBytes, headerBytes.size());
     }
 
-    FrameReader fr = newReader(out);
+    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
 
     // Consume the headers frame.
     fr.nextFrame(new BaseTestHandler() {
@@ -205,8 +198,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
   /** Headers are compressed, then framed. */
   @Test public void pushPromiseThenContinuation() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
     final int expectedPromisedStreamId = 11;
 
@@ -218,25 +210,26 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
     );
 
     // Decoding the first header will cross frame boundaries.
-    byte[] headerBlock = literalHeaders(pushPromise);
+    OkBuffer headerBlock = literalHeaders(pushPromise);
+    int firstFrameLength = (int) (headerBlock.size() - 1);
     { // Write the first headers frame.
-      dataOut.writeShort((headerBlock.length / 2) + 4);
-      dataOut.write(Http20Draft09.TYPE_PUSH_PROMISE);
-      dataOut.write(0); // no flags
-      dataOut.writeInt(expectedStreamId & 0x7fffffff);
-      dataOut.writeInt(expectedPromisedStreamId & 0x7fffffff);
-      dataOut.write(headerBlock, 0, headerBlock.length / 2);
+      frame.writeShort(firstFrameLength + 4);
+      frame.writeByte(Http20Draft09.TYPE_PUSH_PROMISE);
+      frame.writeByte(0); // no flags
+      frame.writeInt(expectedStreamId & 0x7fffffff);
+      frame.writeInt(expectedPromisedStreamId & 0x7fffffff);
+      frame.write(headerBlock, firstFrameLength);
     }
 
     { // Write the continuation frame, specifying no more frames are expected.
-      dataOut.writeShort(headerBlock.length / 2);
-      dataOut.write(Http20Draft09.TYPE_CONTINUATION);
-      dataOut.write(Http20Draft09.FLAG_END_HEADERS);
-      dataOut.writeInt(expectedStreamId & 0x7fffffff);
-      dataOut.write(headerBlock, headerBlock.length / 2, headerBlock.length / 2);
+      frame.writeShort(1);
+      frame.writeByte(Http20Draft09.TYPE_CONTINUATION);
+      frame.writeByte(Http20Draft09.FLAG_END_HEADERS);
+      frame.writeInt(expectedStreamId & 0x7fffffff);
+      frame.write(headerBlock, 1);
     }
 
-    FrameReader fr = newReader(out);
+    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
 
     // Reading the above frames should result in a concatenated headerBlock.
     fr.nextFrame(new BaseTestHandler() {
@@ -250,16 +243,15 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
   }
 
   @Test public void readRstStreamFrame() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
-    dataOut.writeShort(4);
-    dataOut.write(Http20Draft09.TYPE_RST_STREAM);
-    dataOut.write(0); // No flags
-    dataOut.writeInt(expectedStreamId & 0x7fffffff);
-    dataOut.writeInt(ErrorCode.COMPRESSION_ERROR.httpCode);
+    frame.writeShort(4);
+    frame.writeByte(Http20Draft09.TYPE_RST_STREAM);
+    frame.writeByte(0); // No flags
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.writeInt(ErrorCode.COMPRESSION_ERROR.httpCode);
 
-    FrameReader fr = newReader(out);
+    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
 
     // Consume the reset frame.
     fr.nextFrame(new BaseTestHandler() {
@@ -271,21 +263,20 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
   }
 
   @Test public void readSettingsFrame() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
     final int reducedTableSizeBytes = 16;
 
-    dataOut.writeShort(16); // 2 settings * 4 bytes for the code and 4 for the value.
-    dataOut.write(Http20Draft09.TYPE_SETTINGS);
-    dataOut.write(0); // No flags
-    dataOut.writeInt(0 & 0x7fffffff); // Settings are always on the connection stream 0.
-    dataOut.writeInt(Settings.HEADER_TABLE_SIZE & 0xffffff);
-    dataOut.writeInt(reducedTableSizeBytes);
-    dataOut.writeInt(Settings.ENABLE_PUSH & 0xffffff);
-    dataOut.writeInt(0);
+    frame.writeShort(16); // 2 settings * 4 bytes for the code and 4 for the value.
+    frame.writeByte(Http20Draft09.TYPE_SETTINGS);
+    frame.writeByte(0); // No flags
+    frame.writeInt(0 & 0x7fffffff); // Settings are always on the connection stream 0.
+    frame.writeInt(Settings.HEADER_TABLE_SIZE & 0xffffff);
+    frame.writeInt(reducedTableSizeBytes);
+    frame.writeInt(Settings.ENABLE_PUSH & 0xffffff);
+    frame.writeInt(0);
 
-    final Http20Draft09.Reader fr = newReader(out);
+    final Http20Draft09.Reader fr = new Http20Draft09.Reader(frame, 4096, false);
 
     // Consume the settings frame.
     fr.nextFrame(new BaseTestHandler() {
@@ -298,24 +289,23 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
   }
 
   @Test public void pingRoundTrip() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
     final int expectedPayload1 = 7;
     final int expectedPayload2 = 8;
 
     // Compose the expected PING frame.
-    dataOut.writeShort(8); // length
-    dataOut.write(Http20Draft09.TYPE_PING);
-    dataOut.write(Http20Draft09.FLAG_ACK);
-    dataOut.writeInt(0); // connection-level
-    dataOut.writeInt(expectedPayload1);
-    dataOut.writeInt(expectedPayload2);
+    frame.writeShort(8); // length
+    frame.writeByte(Http20Draft09.TYPE_PING);
+    frame.writeByte(Http20Draft09.FLAG_ACK);
+    frame.writeInt(0); // connection-level
+    frame.writeInt(expectedPayload1);
+    frame.writeInt(expectedPayload2);
 
     // Check writer sends the same bytes.
-    assertArrayEquals(out.toByteArray(), sendPingFrame(true, expectedPayload1, expectedPayload2));
+    assertEquals(frame, sendPingFrame(true, expectedPayload1, expectedPayload2));
 
-    FrameReader fr = newReader(out);
+    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
 
     fr.nextFrame(new BaseTestHandler() { // Consume the ping frame.
       @Override public void ping(boolean ack, int payload1, int payload2) {
@@ -327,33 +317,31 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
   }
 
   @Test public void maxLengthDataFrame() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
     final byte[] expectedData = new byte[16383];
     Arrays.fill(expectedData, (byte) 2);
 
     // Write the data frame.
-    dataOut.writeShort(expectedData.length);
-    dataOut.write(Http20Draft09.TYPE_DATA);
-    dataOut.write(0); // no flags
-    dataOut.writeInt(expectedStreamId & 0x7fffffff);
-    dataOut.write(expectedData);
+    frame.writeShort(expectedData.length);
+    frame.writeByte(Http20Draft09.TYPE_DATA);
+    frame.writeByte(0); // no flags
+    frame.writeInt(expectedStreamId & 0x7fffffff);
+    frame.write(expectedData);
 
     // Check writer sends the same bytes.
-    assertArrayEquals(out.toByteArray(), sendDataFrame(expectedData));
+    assertEquals(frame, sendDataFrame(new OkBuffer().write(expectedData)));
 
-    FrameReader fr = newReader(out);
+    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
 
     fr.nextFrame(new BaseTestHandler() {
-      @Override public void data(boolean inFinished, int streamId, InputStream in, int length)
-          throws IOException {
+      @Override public void data(
+          boolean inFinished, int streamId, BufferedSource source, int length) throws IOException {
         assertFalse(inFinished);
         assertEquals(expectedStreamId, streamId);
         assertEquals(16383, length);
-        byte[] data = new byte[length];
-        Util.readFully(in, data);
-        for (byte b : data){
+        ByteString data = source.readByteString(length);
+        for (byte b : data.toByteArray()){
           assertEquals(2, b);
         }
       }
@@ -362,7 +350,7 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
 
   @Test public void tooLargeDataFrame() throws IOException {
     try {
-      sendDataFrame(new byte[0x1000000]);
+      sendDataFrame(new OkBuffer().write(new byte[0x1000000]));
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals("FRAME_SIZE_ERROR length > 16383: 16777216", e.getMessage());
@@ -370,22 +358,21 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
   }
 
   @Test public void windowUpdateRoundTrip() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
     final long expectedWindowSizeIncrement = 0x7fffffff;
 
     // Compose the expected window update frame.
-    dataOut.writeShort(4); // length
-    dataOut.write(Http20Draft09.TYPE_WINDOW_UPDATE);
-    dataOut.write(0); // No flags.
-    dataOut.writeInt(expectedStreamId);
-    dataOut.writeInt((int) expectedWindowSizeIncrement);
+    frame.writeShort(4); // length
+    frame.writeByte(Http20Draft09.TYPE_WINDOW_UPDATE);
+    frame.writeByte(0); // No flags.
+    frame.writeInt(expectedStreamId);
+    frame.writeInt((int) expectedWindowSizeIncrement);
 
     // Check writer sends the same bytes.
-    assertArrayEquals(out.toByteArray(), windowUpdate(expectedWindowSizeIncrement));
+    assertEquals(frame, windowUpdate(expectedWindowSizeIncrement));
 
-    FrameReader fr = newReader(out);
+    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
 
     fr.nextFrame(new BaseTestHandler() { // Consume the window update frame.
       @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
@@ -413,102 +400,116 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> headerB
   }
 
   @Test public void goAwayWithoutDebugDataRoundTrip() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
     final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
 
     // Compose the expected GOAWAY frame without debug data.
-    dataOut.writeShort(8); // Without debug data there's only 2 32-bit fields.
-    dataOut.write(Http20Draft09.TYPE_GOAWAY);
-    dataOut.write(0); // no flags.
-    dataOut.writeInt(0); // connection-scope
-    dataOut.writeInt(expectedStreamId); // last good stream.
-    dataOut.writeInt(expectedError.httpCode);
+    frame.writeShort(8); // Without debug data there's only 2 32-bit fields.
+    frame.writeByte(Http20Draft09.TYPE_GOAWAY);
+    frame.writeByte(0); // no flags.
+    frame.writeInt(0); // connection-scope
+    frame.writeInt(expectedStreamId); // last good stream.
+    frame.writeInt(expectedError.httpCode);
 
     // Check writer sends the same bytes.
-    assertArrayEquals(out.toByteArray(),
-        sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
+    assertEquals(frame, sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
 
-    FrameReader fr = newReader(out);
+    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
 
     fr.nextFrame(new BaseTestHandler() { // Consume the go away frame.
-      @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
+      @Override public void goAway(
+          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
         assertEquals(expectedStreamId, lastGoodStreamId);
         assertEquals(expectedError, errorCode);
-        assertEquals(0, debugData.length);
+        assertEquals(0, debugData.size());
       }
     });
   }
 
   @Test public void goAwayWithDebugDataRoundTrip() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
     final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
-    final byte[] expectedData = new byte[8];
-    Arrays.fill(expectedData, (byte) '*');
+    final ByteString expectedData = ByteString.encodeUtf8("abcdefgh");
 
     // Compose the expected GOAWAY frame without debug data.
-    dataOut.writeShort(8 + expectedData.length);
-    dataOut.write(Http20Draft09.TYPE_GOAWAY);
-    dataOut.write(0); // no flags.
-    dataOut.writeInt(0); // connection-scope
-    dataOut.writeInt(0); // never read any stream!
-    dataOut.writeInt(expectedError.httpCode);
-    dataOut.write(expectedData);
+    frame.writeShort(8 + expectedData.size());
+    frame.writeByte(Http20Draft09.TYPE_GOAWAY);
+    frame.writeByte(0); // no flags.
+    frame.writeInt(0); // connection-scope
+    frame.writeInt(0); // never read any stream!
+    frame.writeInt(expectedError.httpCode);
+    frame.write(expectedData.toByteArray());
 
     // Check writer sends the same bytes.
-    assertArrayEquals(out.toByteArray(), sendGoAway(0, expectedError, expectedData));
+    assertEquals(frame, sendGoAway(0, expectedError, expectedData.toByteArray()));
 
-    FrameReader fr = newReader(out);
+    FrameReader fr = new Http20Draft09.Reader(frame, 4096, false);
 
     fr.nextFrame(new BaseTestHandler() { // Consume the go away frame.
-      @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
+      @Override public void goAway(
+          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
         assertEquals(0, lastGoodStreamId);
         assertEquals(expectedError, errorCode);
-        assertArrayEquals(expectedData, debugData);
+        assertEquals(expectedData, debugData);
       }
     });
   }
 
-  private Http20Draft09.Reader newReader(ByteArrayOutputStream out) {
-    return new Http20Draft09.Reader(new ByteArrayInputStream(out.toByteArray()), 4096, false);
+  @Test public void frameSizeError() throws IOException {
+    Http20Draft09.Writer writer = new Http20Draft09.Writer(new OkBuffer(), true);
+
+    try {
+      writer.frameHeader(16384, Http20Draft09.TYPE_DATA, Http20Draft09.FLAG_NONE, 0);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("FRAME_SIZE_ERROR length > 16383: 16384", e.getMessage());
+    }
   }
 
-  private byte[] literalHeaders(List<Header> sentHeaders) throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    new HpackDraft05.Writer(new DataOutputStream(out)).writeHeaders(sentHeaders);
-    return out.toByteArray();
+  @Test public void streamIdHasReservedBit() throws IOException {
+      Http20Draft09.Writer writer = new Http20Draft09.Writer(new OkBuffer(), true);
+
+      try {
+      int streamId = 3;
+      streamId |= 1L << 31; // set reserved bit
+      writer.frameHeader(16383, Http20Draft09.TYPE_DATA, Http20Draft09.FLAG_NONE, streamId);
+      fail();
+    } catch (IllegalArgumentException e) {
+      assertEquals("reserved bit set: -2147483645", e.getMessage());
+    }
+  }
+
+  private OkBuffer literalHeaders(List<Header> sentHeaders) throws IOException {
+    OkBuffer out = new OkBuffer();
+    new HpackDraft05.Writer(out).writeHeaders(sentHeaders);
+    return out;
   }
 
-  private byte[] sendPingFrame(boolean ack, int payload1, int payload2) throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+  private OkBuffer sendPingFrame(boolean ack, int payload1, int payload2) throws IOException {
+    OkBuffer out = new OkBuffer();
     new Http20Draft09.Writer(out, true).ping(ack, payload1, payload2);
-    return out.toByteArray();
+    return out;
   }
 
-  private byte[] sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
+  private OkBuffer sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
       throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    OkBuffer out = new OkBuffer();
     new Http20Draft09.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
-    return out.toByteArray();
-  }
-
-  private byte[] sendDataFrame(byte[] data) throws IOException {
-    return sendDataFrame(data, 0, data.length);
+    return out;
   }
 
-  private byte[] sendDataFrame(byte[] data, int offset, int byteCount) throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+  private OkBuffer sendDataFrame(OkBuffer data) throws IOException {
+    OkBuffer out = new OkBuffer();
     new Http20Draft09.Writer(out, true).dataFrame(expectedStreamId, Http20Draft09.FLAG_NONE, data,
-        offset, byteCount);
-    return out.toByteArray();
+        (int) data.size());
+    return out;
   }
 
-  private byte[] windowUpdate(long windowSizeIncrement) throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+  private OkBuffer windowUpdate(long windowSizeIncrement) throws IOException {
+    OkBuffer out = new OkBuffer();
     new Http20Draft09.Writer(out, true).windowUpdate(expectedStreamId, windowSizeIncrement);
-    return out.toByteArray();
+    return out;
   }
 }
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java
similarity index 100%
rename from okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/HuffmanTest.java
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
similarity index 82%
rename from okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
index e5335fa482..fd6007ddf4 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/MockSpdyPeer.java
@@ -17,7 +17,6 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayOutputStream;
 import java.io.Closeable;
 import java.io.IOException;
 import java.io.InputStream;
@@ -28,26 +27,33 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.BlockingQueue;
-import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.LinkedBlockingQueue;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.OkBuffer;
+import okio.Okio;
 
 /** Replays prerecorded outgoing frames and records incoming frames. */
 public final class MockSpdyPeer implements Closeable {
   private int frameCount = 0;
-  private final boolean client;
-  private final Variant variant;
-  private final ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-  private final FrameWriter frameWriter;
+  private boolean client = false;
+  private Variant variant = new Spdy3();
+  private final OkBuffer bytesOut = new OkBuffer();
+  private FrameWriter frameWriter = variant.newWriter(bytesOut, client);
   private final List<OutFrame> outFrames = new ArrayList<OutFrame>();
   private final BlockingQueue<InFrame> inFrames = new LinkedBlockingQueue<InFrame>();
   private int port;
-  private final Executor executor = Executors.newCachedThreadPool(
+  private final ExecutorService executor = Executors.newSingleThreadExecutor(
       Util.threadFactory("MockSpdyPeer", false));
   private ServerSocket serverSocket;
   private Socket socket;
 
-  public MockSpdyPeer(Variant variant, boolean client) {
+  public void setVariantAndClient(Variant variant, boolean client) {
+    if (this.variant.getProtocol() == variant.getProtocol() && this.client == client) {
+      return;
+    }
     this.client = client;
     this.variant = variant;
     this.frameWriter = variant.newWriter(bytesOut, client);
@@ -57,6 +63,11 @@ public void acceptFrame() {
     frameCount++;
   }
 
+  /** Count of frames sent or received. */
+  public int frameCount() {
+    return frameCount;
+  }
+
   public FrameWriter sendFrame() {
     outFrames.add(new OutFrame(frameCount++, bytesOut.size(), Integer.MAX_VALUE));
     return frameWriter;
@@ -81,10 +92,6 @@ public FrameWriter sendTruncatedFrame(int truncateToLength) {
     return frameWriter;
   }
 
-  public int getPort() {
-    return port;
-  }
-
   public InFrame takeFrame() throws InterruptedException {
     return inFrames.take();
   }
@@ -93,12 +100,13 @@ public void play() throws IOException {
     if (serverSocket != null) throw new IllegalStateException();
     serverSocket = new ServerSocket(0);
     serverSocket.setReuseAddress(true);
-    this.port = serverSocket.getLocalPort();
+    port = serverSocket.getLocalPort();
     executor.execute(new Runnable() {
       @Override public void run() {
         try {
           readAndWriteFrames();
         } catch (IOException e) {
+          Util.closeQuietly(MockSpdyPeer.this);
           throw new RuntimeException(e);
         }
       }
@@ -110,10 +118,10 @@ private void readAndWriteFrames() throws IOException {
     socket = serverSocket.accept();
     OutputStream out = socket.getOutputStream();
     InputStream in = socket.getInputStream();
-    FrameReader reader = variant.newReader(in, client);
+    FrameReader reader = variant.newReader(Okio.buffer(Okio.source(in)), client);
 
     Iterator<OutFrame> outFramesIterator = outFrames.iterator();
-    byte[] outBytes = bytesOut.toByteArray();
+    byte[] outBytes = bytesOut.readByteString(bytesOut.size()).toByteArray();
     OutFrame nextOutFrame = null;
 
     for (int i = 0; i < frameCount; i++) {
@@ -122,9 +130,9 @@ private void readAndWriteFrames() throws IOException {
       }
 
       if (nextOutFrame != null && nextOutFrame.sequence == i) {
-        int start = nextOutFrame.start;
+        long start = nextOutFrame.start;
         int truncateToLength = nextOutFrame.truncateToLength;
-        int end;
+        long end;
         if (outFramesIterator.hasNext()) {
           nextOutFrame = outFramesIterator.next();
           end = nextOutFrame.start;
@@ -133,8 +141,8 @@ private void readAndWriteFrames() throws IOException {
         }
 
         // write a frame
-        int length = Math.min(end - start, truncateToLength);
-        out.write(outBytes, start, length);
+        int length = (int) Math.min(end - start, truncateToLength);
+        out.write(outBytes, (int) start, length);
       } else {
         // read a frame
         InFrame inFrame = new InFrame(i, reader);
@@ -149,25 +157,26 @@ public Socket openSocket() throws IOException {
     return new Socket("localhost", port);
   }
 
-  @Override public void close() throws IOException {
+  @Override public synchronized void close() throws IOException {
+    executor.shutdown();
     Socket socket = this.socket;
     if (socket != null) {
-      socket.close();
+      Util.closeQuietly(socket);
       this.socket = null;
     }
     ServerSocket serverSocket = this.serverSocket;
     if (serverSocket != null) {
-      serverSocket.close();
+      Util.closeQuietly(serverSocket);
       this.serverSocket = null;
     }
   }
 
   private static class OutFrame {
     private final int sequence;
-    private final int start;
+    private final long start;
     private final int truncateToLength;
 
-    private OutFrame(int sequence, int start, int truncateToLength) {
+    private OutFrame(int sequence, long start, int truncateToLength) {
       this.sequence = sequence;
       this.start = start;
       this.truncateToLength = truncateToLength;
@@ -206,6 +215,12 @@ public InFrame(int sequence, FrameReader reader) {
       this.settings = settings;
     }
 
+    @Override public void ackSettings() {
+      if (this.type != -1) throw new IllegalStateException();
+      this.type = Spdy3.TYPE_SETTINGS;
+      this.ack = true;
+    }
+
     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
         int associatedStreamId, int priority, List<Header> headerBlock,
         HeadersMode headersMode) {
@@ -220,14 +235,13 @@ public InFrame(int sequence, FrameReader reader) {
       this.headersMode = headersMode;
     }
 
-    @Override public void data(boolean inFinished, int streamId, InputStream in, int length)
+    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
         throws IOException {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Spdy3.TYPE_DATA;
       this.inFinished = inFinished;
       this.streamId = streamId;
-      this.data = new byte[length];
-      Util.readFully(in, this.data);
+      this.data = source.readByteString(length).toByteArray();
     }
 
     @Override public void rstStream(int streamId, ErrorCode errorCode) {
@@ -245,18 +259,12 @@ public InFrame(int sequence, FrameReader reader) {
       this.payload2 = payload2;
     }
 
-    @Override public void noop() {
-      if (this.type != -1) throw new IllegalStateException();
-      this.type = Spdy3.TYPE_NOOP;
-    }
-
-    @Override
-    public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
+    @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
       if (this.type != -1) throw new IllegalStateException();
       this.type = Spdy3.TYPE_GOAWAY;
       this.streamId = lastGoodStreamId;
       this.errorCode = errorCode;
-      this.data = debugData;
+      this.data = debugData.toByteArray();
     }
 
     @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
similarity index 92%
rename from okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
index 31df6d2fa5..294684f1b9 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SettingsTest.java
@@ -17,6 +17,7 @@
 
 import org.junit.Test;
 
+import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 import static com.squareup.okhttp.internal.spdy.Settings.DOWNLOAD_BANDWIDTH;
 import static com.squareup.okhttp.internal.spdy.Settings.DOWNLOAD_RETRANS_RATE;
 import static com.squareup.okhttp.internal.spdy.Settings.MAX_CONCURRENT_STREAMS;
@@ -39,7 +40,7 @@
     // WARNING: clash on flags between spdy/3 and http/2!
     assertEquals(-3, settings.getUploadBandwidth(-3));
     assertEquals(-1, settings.getHeaderTableSize());
-    settings.set(Settings.UPLOAD_BANDWIDTH, 0, 42);
+    settings.set(UPLOAD_BANDWIDTH, 0, 42);
     assertEquals(42, settings.getUploadBandwidth(-3));
     settings.set(Settings.HEADER_TABLE_SIZE, 0, 8096);
     assertEquals(8096, settings.getHeaderTableSize());
@@ -47,7 +48,7 @@
     // WARNING: clash on flags between spdy/3 and http/2!
     assertEquals(-3, settings.getDownloadBandwidth(-3));
     assertEquals(true, settings.getEnablePush(true));
-    settings.set(Settings.DOWNLOAD_BANDWIDTH, 0, 53);
+    settings.set(DOWNLOAD_BANDWIDTH, 0, 53);
     assertEquals(53, settings.getDownloadBandwidth(-3));
     settings.set(Settings.ENABLE_PUSH, 0, 0);
     assertEquals(false, settings.getEnablePush(true));
@@ -57,7 +58,7 @@
     assertEquals(64, settings.getRoundTripTime(-3));
 
     assertEquals(-3, settings.getMaxConcurrentStreams(-3));
-    settings.set(Settings.MAX_CONCURRENT_STREAMS, 0, 75);
+    settings.set(MAX_CONCURRENT_STREAMS, 0, 75);
     assertEquals(75, settings.getMaxConcurrentStreams(-3));
 
     assertEquals(-3, settings.getCurrentCwnd(-3));
@@ -65,12 +66,13 @@
     assertEquals(86, settings.getCurrentCwnd(-3));
 
     assertEquals(-3, settings.getDownloadRetransRate(-3));
-    settings.set(Settings.DOWNLOAD_RETRANS_RATE, 0, 97);
+    settings.set(DOWNLOAD_RETRANS_RATE, 0, 97);
     assertEquals(97, settings.getDownloadRetransRate(-3));
 
-    assertEquals(-1, settings.getInitialWindowSize());
+    assertEquals(DEFAULT_INITIAL_WINDOW_SIZE,
+        settings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
     settings.set(Settings.INITIAL_WINDOW_SIZE, 0, 108);
-    assertEquals(108, settings.getInitialWindowSize());
+    assertEquals(108, settings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
 
     assertEquals(-3, settings.getClientCertificateVectorSize(-3));
     settings.set(Settings.CLIENT_CERTIFICATE_VECTOR_SIZE, 0, 117);
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
similarity index 54%
rename from okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
index c6adebb51a..1904b908fc 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/Spdy3Test.java
@@ -16,13 +16,11 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.DataOutputStream;
 import java.io.IOException;
+import okio.ByteString;
+import okio.OkBuffer;
 import org.junit.Test;
 
-import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
@@ -31,7 +29,7 @@
 
   @Test public void tooLargeDataFrame() throws IOException {
     try {
-      sendDataFrame(new byte[0x1000000]);
+      sendDataFrame(new OkBuffer().write(new byte[0x1000000]));
       fail();
     } catch (IllegalArgumentException e) {
       assertEquals("FRAME_TOO_LARGE max size is 16Mib: " + 0x1000000L, e.getMessage());
@@ -55,61 +53,49 @@
   }
 
   @Test public void goAwayRoundTrip() throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    DataOutputStream dataOut = new DataOutputStream(out);
+    OkBuffer frame = new OkBuffer();
 
     final ErrorCode expectedError = ErrorCode.PROTOCOL_ERROR;
 
     // Compose the expected GOAWAY frame without debug data
     // |C| Version(15bits) | Type(16bits) |
-    dataOut.writeInt(0x80000000 | (Spdy3.VERSION & 0x7fff) << 16 | Spdy3.TYPE_GOAWAY & 0xffff);
+    frame.writeInt(0x80000000 | (Spdy3.VERSION & 0x7fff) << 16 | Spdy3.TYPE_GOAWAY & 0xffff);
     // | Flags (8)  |  Length (24 bits)   |
-    dataOut.writeInt(8); // no flags and length is 8.
-    dataOut.writeInt(expectedStreamId); // last good stream.
-    dataOut.writeInt(expectedError.spdyGoAwayCode);
+    frame.writeInt(8); // no flags and length is 8.
+    frame.writeInt(expectedStreamId); // last good stream.
+    frame.writeInt(expectedError.spdyGoAwayCode);
 
     // Check writer sends the same bytes.
-    assertArrayEquals(out.toByteArray(),
-        sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
+    assertEquals(frame, sendGoAway(expectedStreamId, expectedError, Util.EMPTY_BYTE_ARRAY));
 
     // SPDY/3 does not send debug data, so bytes should be same!
-    assertArrayEquals(out.toByteArray(), sendGoAway(expectedStreamId, expectedError, new byte[8]));
+    assertEquals(frame, sendGoAway(expectedStreamId, expectedError, new byte[8]));
 
-    FrameReader fr = newReader(out);
+    FrameReader fr = new Spdy3.Reader(frame, false);
 
     fr.nextFrame(new BaseTestHandler() { // Consume the goAway frame.
-      @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
+      @Override public void goAway(
+          int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
         assertEquals(expectedStreamId, lastGoodStreamId);
         assertEquals(expectedError, errorCode);
-        assertEquals(0, debugData.length);
+        assertEquals(0, debugData.size());
       }
     });
   }
 
-  private Spdy3.Reader newReader(ByteArrayOutputStream out) {
-    return new Spdy3.Reader(new ByteArrayInputStream(out.toByteArray()), false);
+  private void sendDataFrame(OkBuffer source) throws IOException {
+    Spdy3.Writer writer = new Spdy3.Writer(new OkBuffer(), true);
+    writer.sendDataFrame(expectedStreamId, 0, source, (int) source.size());
   }
 
-  private byte[] sendDataFrame(byte[] data) throws IOException {
-    return sendDataFrame(data, 0, data.length);
+  private void windowUpdate(long increment) throws IOException {
+    new Spdy3.Writer(new OkBuffer(), true).windowUpdate(expectedStreamId, increment);
   }
 
-  private byte[] sendDataFrame(byte[] data, int offset, int byteCount) throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    new Spdy3.Writer(out, true).sendDataFrame(expectedStreamId, 0, data, offset, byteCount);
-    return out.toByteArray();
-  }
-
-  private byte[] windowUpdate(long increment) throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
-    new Spdy3.Writer(out, true).windowUpdate(expectedStreamId, increment);
-    return out.toByteArray();
-  }
-
-  private byte[] sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
+  private OkBuffer sendGoAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
       throws IOException {
-    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    OkBuffer out = new OkBuffer();
     new Spdy3.Writer(out, true).goAway(lastGoodStreamId, errorCode, debugData);
-    return out.toByteArray();
+    return out;
   }
 }
diff --git a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
similarity index 62%
rename from okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
index fbf6560483..2ef127e99e 100644
--- a/okhttp-protocols/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
+++ b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/spdy/SpdyConnectionTest.java
@@ -15,34 +15,35 @@
  */
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.Base64;
 import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayOutputStream;
 import java.io.IOException;
-import java.io.InputStream;
 import java.io.InterruptedIOException;
-import java.io.OutputStream;
+import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.List;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.OkBuffer;
+import okio.Okio;
+import okio.Source;
 import org.junit.After;
-import org.junit.Ignore;
 import org.junit.Test;
 
-import static com.squareup.okhttp.internal.Util.UTF_8;
 import static com.squareup.okhttp.internal.Util.headerEntries;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.CANCEL;
-import static com.squareup.okhttp.internal.spdy.ErrorCode.FLOW_CONTROL_ERROR;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.INTERNAL_ERROR;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.INVALID_STREAM;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.PROTOCOL_ERROR;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.REFUSED_STREAM;
 import static com.squareup.okhttp.internal.spdy.ErrorCode.STREAM_IN_USE;
+import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 import static com.squareup.okhttp.internal.spdy.Settings.PERSIST_VALUE;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_DATA;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_GOAWAY;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_HEADERS;
-import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_NOOP;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_PING;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_RST_STREAM;
 import static com.squareup.okhttp.internal.spdy.Spdy3.TYPE_SETTINGS;
@@ -55,13 +56,7 @@
 public final class SpdyConnectionTest {
   private static final Variant SPDY3 = new Spdy3();
   private static final Variant HTTP_20_DRAFT_09 = new Http20Draft09();
-
-  private static final IncomingStreamHandler REJECT_INCOMING_STREAMS = new IncomingStreamHandler() {
-    @Override public void receive(SpdyStream stream) throws IOException {
-      throw new AssertionError();
-    }
-  };
-  private final MockSpdyPeer peer = new MockSpdyPeer(SPDY3, false);
+  private final MockSpdyPeer peer = new MockSpdyPeer();
 
   @After public void tearDown() throws Exception {
     peer.close();
@@ -72,16 +67,18 @@
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame()
         .synReply(false, 1, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 1, "robot".getBytes("UTF-8"));
+    peer.sendFrame().data(true, 1, new OkBuffer().writeUtf8("robot"));
     peer.acceptFrame(); // DATA
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
-    assertStreamData("robot", stream.getInputStream());
-    writeAndClose(stream, "c3po");
+    assertStreamData("robot", stream.getSource());
+    BufferedSink out = Okio.buffer(stream.getSink());
+    out.writeUtf8("c3po");
+    out.close();
     assertEquals(0, connection.openStreamCount());
 
     // verify the peer received what was expected
@@ -102,7 +99,7 @@
     peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
     peer.play();
 
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, false);
     assertEquals(1, connection.openStreamCount());
     assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
@@ -118,7 +115,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyConnection connection = connection(peer, SPDY3);
     connection.newStream(headerEntries("b", "banana"), false, true);
     assertEquals(1, connection.openStreamCount());
     connection.ping().roundTripTime(); // Ensure that the SYN_REPLY has been received.
@@ -133,8 +130,16 @@
   }
 
   @Test public void serverCreatesStreamAndClientReplies() throws Exception {
+    final List<Header> pushHeaders = headerEntries(
+        ":scheme", "https",
+        ":host", "localhost:8888",
+        ":method", "GET",
+        ":path", "/index.html",
+        ":status", "200",
+        ":version", "HTTP/1.1",
+        "content-type", "text/html");
     // write the mocking script
-    peer.sendFrame().synStream(false, false, 2, 0, 5, 129, headerEntries("a", "android"));
+    peer.sendFrame().synStream(false, false, 2, 0, 5, 129, pushHeaders);
     peer.acceptFrame(); // SYN_REPLY
     peer.play();
 
@@ -143,7 +148,7 @@
     IncomingStreamHandler handler = new IncomingStreamHandler() {
       @Override public void receive(SpdyStream stream) throws IOException {
         receiveCount.incrementAndGet();
-        assertEquals(headerEntries("a", "android"), stream.getRequestHeaders());
+        assertEquals(pushHeaders, stream.getRequestHeaders());
         assertEquals(null, stream.getErrorCode());
         assertEquals(5, stream.getPriority());
         stream.reply(headerEntries("b", "banana"), true);
@@ -175,29 +180,16 @@
         receiveCount.incrementAndGet();
       }
     };
-    new SpdyConnection.Builder(true, peer.openSocket()).handler(handler).build();
+
+    connectionBuilder(peer, SPDY3).handler(handler).build();
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame reply = peer.takeFrame();
     assertEquals(TYPE_HEADERS, reply.type);
-    assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
     assertTrue(reply.inFinished);
     assertEquals(headerEntries("b", "banana"), reply.headerBlock);
     assertEquals(1, receiveCount.get());
-  }
-
-  @Test public void noop() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // NOOP
-    peer.play();
-
-    // play it back
-    SpdyConnection connection = connection(peer, SPDY3);
-    connection.noop();
-
-    // verify the peer received what was expected
-    MockSpdyPeer.InFrame ping = peer.takeFrame();
-    assertEquals(TYPE_NOOP, ping.type);
+    assertEquals(HeadersMode.SPDY_REPLY, reply.headersMode);
   }
 
   @Test public void serverPingsClient() throws Exception {
@@ -218,7 +210,7 @@
   }
 
   @Test public void serverPingsClientHttp2() throws Exception {
-    MockSpdyPeer peer = new MockSpdyPeer(HTTP_20_DRAFT_09, false);
+    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
 
     // write the mocking script
     peer.sendFrame().ping(false, 2, 3);
@@ -258,7 +250,7 @@
   }
 
   @Test public void clientPingsServerHttp2() throws Exception {
-    MockSpdyPeer peer = new MockSpdyPeer(HTTP_20_DRAFT_09, false);
+    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
 
     // write the mocking script
     peer.acceptFrame(); // PING
@@ -279,6 +271,42 @@
     assertFalse(pingFrame.ack);
   }
 
+  @Test public void peerHttp2ServerLowersInitialWindowSize() throws Exception {
+    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
+
+    Settings initial = new Settings();
+    initial.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 1684);
+    Settings shouldntImpactConnection = new Settings();
+    shouldntImpactConnection.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, 3368);
+
+    peer.sendFrame().settings(initial);
+    peer.acceptFrame(); // ACK
+    peer.sendFrame().settings(shouldntImpactConnection);
+    peer.acceptFrame(); // ACK 2
+    peer.acceptFrame(); // HEADERS
+    peer.play();
+
+    SpdyConnection connection = connection(peer, HTTP_20_DRAFT_09);
+
+    // verify the peer received the ACK
+    MockSpdyPeer.InFrame ackFrame = peer.takeFrame();
+    assertEquals(TYPE_SETTINGS, ackFrame.type);
+    assertEquals(0, ackFrame.streamId);
+    assertTrue(ackFrame.ack);
+    ackFrame = peer.takeFrame();
+    assertEquals(TYPE_SETTINGS, ackFrame.type);
+    assertEquals(0, ackFrame.streamId);
+    assertTrue(ackFrame.ack);
+
+    // This stream was created *after* the connection settings were adjusted.
+    SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
+
+    assertEquals(3368, connection.peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
+    assertEquals(1684, connection.bytesLeftInWriteWindow); // initial wasn't affected.
+    // New Stream is has the most recent initial window size.
+    assertEquals(3368, stream.bytesLeftInWriteWindow);
+  }
+
   @Test public void unexpectedPingIsNotReturned() throws Exception {
     // write the mocking script
     peer.sendFrame().ping(false, 2, 0);
@@ -316,7 +344,7 @@
 
   @Test public void peerHttp2ClientDisablesPush() throws Exception {
     boolean client = false; // Peer is client, so we are server.
-    Settings settings = Http20Draft09.defaultSettings(client);
+    Settings settings = new Settings();
     settings.set(Settings.ENABLE_PUSH, 0, 0); // The peer client disables push.
 
     SpdyConnection connection = sendHttp2SettingsAndCheckForAck(client, settings);
@@ -377,9 +405,38 @@
     }
   }
 
+  @Test public void clearSettingsBeforeMerge() throws Exception {
+    // write the mocking script
+    Settings settings1 = new Settings();
+    settings1.set(Settings.UPLOAD_BANDWIDTH, PERSIST_VALUE, 100);
+    settings1.set(Settings.DOWNLOAD_BANDWIDTH, PERSIST_VALUE, 200);
+    settings1.set(Settings.DOWNLOAD_RETRANS_RATE, 0, 300);
+    peer.sendFrame().settings(settings1);
+    peer.sendFrame().ping(false, 2, 0);
+    peer.acceptFrame();
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connection(peer, SPDY3);
+
+    peer.takeFrame(); // Guarantees that the Settings frame has been processed.
+
+    // fake a settings frame with clear flag set.
+    Settings settings2 = new Settings();
+    settings2.set(Settings.MAX_CONCURRENT_STREAMS, PERSIST_VALUE, 600);
+    connection.readerRunnable.settings(true, settings2);
+
+    synchronized (connection) {
+      assertEquals(-1, connection.peerSettings.getUploadBandwidth(-1));
+      assertEquals(-1, connection.peerSettings.getDownloadBandwidth(-1));
+      assertEquals(-1, connection.peerSettings.getDownloadRetransRate(-1));
+      assertEquals(600, connection.peerSettings.getMaxConcurrentStreams(-1));
+    }
+  }
+
   @Test public void bogusDataFrameDoesNotDisruptConnection() throws Exception {
     // write the mocking script
-    peer.sendFrame().data(true, 42, "bogus".getBytes("UTF-8"));
+    peer.sendFrame().data(true, 41, new OkBuffer().writeUtf8("bogus"));
     peer.acceptFrame(); // RST_STREAM
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame(); // PING
@@ -391,7 +448,7 @@
     // verify the peer received what was expected
     MockSpdyPeer.InFrame rstStream = peer.takeFrame();
     assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(42, rstStream.streamId);
+    assertEquals(41, rstStream.streamId);
     assertEquals(INVALID_STREAM, rstStream.errorCode);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(2, ping.payload1);
@@ -399,7 +456,7 @@
 
   @Test public void bogusReplyFrameDoesNotDisruptConnection() throws Exception {
     // write the mocking script
-    peer.sendFrame().synReply(false, 42, headerEntries("a", "android"));
+    peer.sendFrame().synReply(false, 41, headerEntries("a", "android"));
     peer.acceptFrame(); // RST_STREAM
     peer.sendFrame().ping(false, 2, 0);
     peer.acceptFrame(); // PING
@@ -411,7 +468,7 @@
     // verify the peer received what was expected
     MockSpdyPeer.InFrame rstStream = peer.takeFrame();
     assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(42, rstStream.streamId);
+    assertEquals(41, rstStream.streamId);
     assertEquals(INVALID_STREAM, rstStream.errorCode);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(2, ping.payload1);
@@ -430,16 +487,16 @@
     // play it back
     SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, false);
-    OutputStream out = stream.getOutputStream();
-    out.write("square".getBytes(UTF_8));
+    BufferedSink out = Okio.buffer(stream.getSink());
+    out.writeUtf8("square");
     out.flush();
     assertEquals(1, connection.openStreamCount());
     out.close();
     try {
-      out.write("round".getBytes(UTF_8));
+      out.writeUtf8("round");
       fail();
     } catch (Exception expected) {
-      assertEquals("stream closed", expected.getMessage());
+      assertEquals("closed", expected.getMessage());
     }
     connection.ping().roundTripTime(); // Ensure that the SYN_REPLY has been received.
     assertEquals(0, connection.openStreamCount());
@@ -468,21 +525,26 @@
     peer.sendFrame().rstStream(1, CANCEL);
     peer.acceptFrame(); // PING
     peer.sendFrame().ping(true, 1, 0);
-    peer.acceptFrame(); // DATA
     peer.play();
 
     // play it back
     SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
-    OutputStream out = stream.getOutputStream();
+    BufferedSink out = Okio.buffer(stream.getSink());
     connection.ping().roundTripTime(); // Ensure that the RST_CANCEL has been received.
     try {
-      out.write("square".getBytes(UTF_8));
+      out.writeUtf8("square");
+      out.flush();
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: CANCEL", expected.getMessage());
     }
-    out.close();
+    try {
+      out.close();
+      fail();
+    } catch (IOException expected) {
+      // Close throws because buffered data wasn't flushed.
+    }
     assertEquals(0, connection.openStreamCount());
 
     // verify the peer received what was expected
@@ -494,11 +556,6 @@
     MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
     assertEquals(1, ping.payload1);
-    MockSpdyPeer.InFrame data = peer.takeFrame();
-    assertEquals(TYPE_DATA, data.type);
-    assertEquals(1, data.streamId);
-    assertTrue(data.inFinished);
-    assertFalse(data.outFinished);
   }
 
   /**
@@ -514,17 +571,18 @@
     // play it back
     SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
-    InputStream in = stream.getInputStream();
-    OutputStream out = stream.getOutputStream();
+    Source in = stream.getSource();
+    BufferedSink out = Okio.buffer(stream.getSink());
     in.close();
     try {
-      in.read();
+      in.read(new OkBuffer(), 1);
       fail();
     } catch (IOException expected) {
       assertEquals("stream closed", expected.getMessage());
     }
     try {
-      out.write('a');
+      out.writeUtf8("a");
+      out.flush();
       fail();
     } catch (IOException expected) {
       assertEquals("stream finished", expected.getMessage());
@@ -557,16 +615,16 @@
     // play it back
     SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
-    InputStream in = stream.getInputStream();
-    OutputStream out = stream.getOutputStream();
-    in.close();
+    Source source = stream.getSource();
+    BufferedSink out = Okio.buffer(stream.getSink());
+    source.close();
     try {
-      in.read();
+      source.read(new OkBuffer(), 1);
       fail();
     } catch (IOException expected) {
       assertEquals("stream closed", expected.getMessage());
     }
-    out.write("square".getBytes(UTF_8));
+    out.writeUtf8("square");
     out.flush();
     out.close();
     assertEquals(0, connection.openStreamCount());
@@ -593,14 +651,14 @@
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
-    peer.sendFrame().data(true, 1, "square".getBytes(UTF_8));
+    peer.sendFrame().data(true, 1, new OkBuffer().writeUtf8("square"));
     peer.play();
 
     // play it back
     SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), false, true);
-    InputStream in = stream.getInputStream();
-    assertStreamData("square", in);
+    Source source = stream.getSource();
+    assertStreamData("square", source);
     assertEquals(0, connection.openStreamCount());
 
     // verify the peer received what was expected
@@ -622,12 +680,12 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("c", "cola"), true, true);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
     connection.ping().roundTripTime(); // Ensure that the 2nd SYN REPLY has been received.
     try {
-      stream.getInputStream().read();
+      stream.getSource().read(new OkBuffer(), 1);
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: STREAM_IN_USE", expected.getMessage());
@@ -680,17 +738,17 @@
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.sendFrame().data(true, 1, "robot".getBytes("UTF-8"));
-    peer.sendFrame().data(true, 1, "c3po".getBytes("UTF-8")); // Ignored.
+    peer.sendFrame().data(true, 1, new OkBuffer().writeUtf8("robot"));
+    peer.sendFrame().data(true, 1, new OkBuffer().writeUtf8("c3po")); // Ignored.
     peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
     peer.acceptFrame(); // PING
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
-    assertStreamData("robot", stream.getInputStream());
+    assertStreamData("robot", stream.getSource());
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
@@ -701,18 +759,17 @@
     assertEquals(2, ping.payload1);
   }
 
-  @Test public void remoteSendsTooMuchData() throws Exception {
+  @Test public void clientDoesNotLimitFlowControl() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 1, headerEntries("b", "banana"));
-    peer.sendFrame().data(false, 1, new byte[64 * 1024 + 1]);
-    peer.acceptFrame(); // RST_STREAM
+    peer.sendFrame().data(false, 1, new OkBuffer().write(new byte[64 * 1024 + 1]));
     peer.sendFrame().ping(false, 2, 0); // Ping just to make sure the stream was fastforwarded.
     peer.acceptFrame(); // PING
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     assertEquals(headerEntries("b", "banana"), stream.getResponseHeaders());
 
@@ -720,10 +777,6 @@
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
     assertEquals(TYPE_HEADERS, synStream.type);
     assertEquals(HeadersMode.SPDY_SYN_STREAM, synStream.headersMode);
-    MockSpdyPeer.InFrame rstStream = peer.takeFrame();
-    assertEquals(TYPE_RST_STREAM, rstStream.type);
-    assertEquals(1, rstStream.streamId);
-    assertEquals(FLOW_CONTROL_ERROR, rstStream.errorCode);
     MockSpdyPeer.InFrame ping = peer.takeFrame();
     assertEquals(TYPE_PING, ping.type);
     assertEquals(2, ping.payload1);
@@ -738,7 +791,7 @@
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     try {
       stream.getResponseHeaders();
@@ -767,7 +820,7 @@
   }
 
   private void receiveGoAway(Variant variant) throws Exception {
-    MockSpdyPeer peer = new MockSpdyPeer(variant, false);
+    peer.setVariantAndClient(variant, false);
 
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM 1
@@ -783,15 +836,18 @@ private void receiveGoAway(Variant variant) throws Exception {
     SpdyStream stream1 = connection.newStream(headerEntries("a", "android"), true, true);
     SpdyStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
     connection.ping().roundTripTime(); // Ensure that the GO_AWAY has been received.
-    stream1.getOutputStream().write("abc".getBytes(UTF_8));
+    BufferedSink sink1 = Okio.buffer(stream1.getSink());
+    BufferedSink sink2 = Okio.buffer(stream2.getSink());
+    sink1.writeUtf8("abc");
     try {
-      stream2.getOutputStream().write("abc".getBytes(UTF_8));
+      sink2.writeUtf8("abc");
+      sink2.flush();
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: REFUSED_STREAM", expected.getMessage());
     }
-    stream1.getOutputStream().write("def".getBytes(UTF_8));
-    stream1.getOutputStream().close();
+    sink1.writeUtf8("def");
+    sink1.close();
     try {
       connection.newStream(headerEntries("c", "cola"), true, true);
       fail();
@@ -823,7 +879,7 @@ private void receiveGoAway(Variant variant) throws Exception {
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyConnection connection = connection(peer, SPDY3);
     connection.newStream(headerEntries("a", "android"), true, true);
     Ping ping = connection.ping();
     connection.shutdown(PROTOCOL_ERROR);
@@ -847,7 +903,7 @@ private void receiveGoAway(Variant variant) throws Exception {
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyConnection connection = connection(peer, SPDY3);
     connection.shutdown(INTERNAL_ERROR);
     try {
       connection.ping();
@@ -870,7 +926,7 @@ private void receiveGoAway(Variant variant) throws Exception {
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("a", "android"), true, true);
     assertEquals(1, connection.openStreamCount());
     connection.close();
@@ -881,14 +937,16 @@ private void receiveGoAway(Variant variant) throws Exception {
     } catch (IOException expected) {
       assertEquals("shutdown", expected.getMessage());
     }
+    BufferedSink sink = Okio.buffer(stream.getSink());
     try {
-      stream.getOutputStream().write(0);
+      sink.writeByte(0);
+      sink.flush();
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: CANCEL", expected.getMessage());
     }
     try {
-      stream.getInputStream().read();
+      stream.getSource().read(new OkBuffer(), 1);
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: CANCEL", expected.getMessage());
@@ -912,7 +970,7 @@ private void receiveGoAway(Variant variant) throws Exception {
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyConnection connection = connection(peer, SPDY3);
     Ping ping = connection.ping();
     connection.close();
     assertEquals(-1, ping.roundTripTime());
@@ -927,13 +985,13 @@ private void receiveGoAway(Variant variant) throws Exception {
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     stream.setReadTimeout(1000);
-    InputStream in = stream.getInputStream();
+    Source source = stream.getSource();
     long startNanos = System.nanoTime();
     try {
-      in.read();
+      source.read(new OkBuffer(), 1);
       fail();
     } catch (IOException expected) {
     }
@@ -957,7 +1015,7 @@ private void receiveGoAway(Variant variant) throws Exception {
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
     assertEquals(headerEntries("a", "android", "c", "c3po"), stream.getResponseHeaders());
@@ -980,7 +1038,7 @@ private void receiveGoAway(Variant variant) throws Exception {
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     connection.ping().roundTripTime(); // Ensure that the HEADERS has been received.
     try {
@@ -1005,116 +1063,278 @@ private void receiveGoAway(Variant variant) throws Exception {
     readSendsWindowUpdate(SPDY3);
   }
 
-  /**
-   * This test fails on http/2 as it tries to send too large data frame.  In
-   * practice, {@link SpdyStream#OUTPUT_BUFFER_SIZE} prevents us from sending
-   * too large frames.  The test should probably be rewritten to take into
-   * account max frame size per variant.
-   */
-  @Test @Ignore public void readSendsWindowUpdateHttp2() throws Exception {
+  @Test public void readSendsWindowUpdateHttp2() throws Exception {
     readSendsWindowUpdate(HTTP_20_DRAFT_09);
   }
 
   private void readSendsWindowUpdate(Variant variant)
       throws IOException, InterruptedException {
-    MockSpdyPeer peer = new MockSpdyPeer(variant, false);
-    int windowUpdateThreshold = 65535 / 2;
+    peer.setVariantAndClient(variant, false);
+
+    int windowUpdateThreshold = DEFAULT_INITIAL_WINDOW_SIZE / 2;
 
     // Write the mocking script.
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
     for (int i = 0; i < 3; i++) {
-      peer.sendFrame().data(false, 1, new byte[windowUpdateThreshold]);
-      peer.acceptFrame(); // WINDOW UPDATE
+      // Send frames summing to windowUpdateThreshold.
+      for (int sent = 0, count; sent < windowUpdateThreshold; sent += count) {
+        count = Math.min(variant.maxFrameSize(), windowUpdateThreshold - sent);
+        peer.sendFrame().data(false, 1, data(count));
+      }
+      peer.acceptFrame(); // connection WINDOW UPDATE
+      peer.acceptFrame(); // stream WINDOW UPDATE
     }
-    peer.sendFrame().data(true, 1, new byte[0]);
+    peer.sendFrame().data(true, 1, data(0));
     peer.play();
 
     // Play it back.
     SpdyConnection connection = connection(peer, variant);
-    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    assertEquals(windowUpdateThreshold, stream.windowUpdateThreshold);
+    SpdyStream stream = connection.newStream(headerEntries("b", "banana"), false, true);
+    assertEquals(0, stream.unacknowledgedBytesRead);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
-    InputStream in = stream.getInputStream();
-    int total = 0;
-    byte[] buffer = new byte[1024];
-    int count;
-    while ((count = in.read(buffer)) != -1) {
-      total += count;
-      if (total == 3 * windowUpdateThreshold) break;
+    Source in = stream.getSource();
+    OkBuffer buffer = new OkBuffer();
+    while (in.read(buffer, 1024) != -1) {
+      if (buffer.size() == 3 * windowUpdateThreshold) break;
     }
-    assertEquals(-1, in.read());
+    assertEquals(-1, in.read(buffer, 1));
 
-    // Verify the peer received what was expected.
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
     assertEquals(TYPE_HEADERS, synStream.type);
     for (int i = 0; i < 3; i++) {
-      MockSpdyPeer.InFrame windowUpdate = peer.takeFrame();
-      assertEquals(TYPE_WINDOW_UPDATE, windowUpdate.type);
-      assertEquals(1, windowUpdate.streamId);
-      assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
+      List<Integer> windowUpdateStreamIds = new ArrayList(2);
+      for (int j = 0; j < 2; j++) {
+        MockSpdyPeer.InFrame windowUpdate = peer.takeFrame();
+        assertEquals(TYPE_WINDOW_UPDATE, windowUpdate.type);
+        windowUpdateStreamIds.add(windowUpdate.streamId);
+        assertEquals(windowUpdateThreshold, windowUpdate.windowSizeIncrement);
+      }
+      assertTrue(windowUpdateStreamIds.contains(0)); // connection
+      assertTrue(windowUpdateStreamIds.contains(1)); // stream
     }
   }
 
+  private OkBuffer data(int byteCount) {
+    return new OkBuffer().write(new byte[byteCount]);
+  }
+
+  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdate() throws Exception {
+    serverSendsEmptyDataClientDoesntSendWindowUpdate(SPDY3);
+  }
+
+  @Test public void serverSendsEmptyDataClientDoesntSendWindowUpdateHttp2() throws Exception {
+    serverSendsEmptyDataClientDoesntSendWindowUpdate(HTTP_20_DRAFT_09);
+  }
+
+  private void serverSendsEmptyDataClientDoesntSendWindowUpdate(Variant variant)
+      throws IOException, InterruptedException {
+    peer.setVariantAndClient(variant, false);
+
+    // Write the mocking script.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.sendFrame().data(true, 1, data(0));
+    peer.play();
+
+    // Play it back.
+    SpdyConnection connection = connection(peer, variant);
+    SpdyStream client = connection.newStream(headerEntries("b", "banana"), false, true);
+    assertEquals(-1, client.getSource().read(new OkBuffer(), 1));
+
+    // Verify the peer received what was expected.
+    MockSpdyPeer.InFrame synStream = peer.takeFrame();
+    assertEquals(TYPE_HEADERS, synStream.type);
+    assertEquals(3, peer.frameCount());
+  }
+
+  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdate() throws Exception {
+    clientSendsEmptyDataServerDoesntSendWindowUpdate(SPDY3);
+  }
+
+  @Test public void clientSendsEmptyDataServerDoesntSendWindowUpdateHttp2() throws Exception {
+    clientSendsEmptyDataServerDoesntSendWindowUpdate(HTTP_20_DRAFT_09);
+  }
+
+  private void clientSendsEmptyDataServerDoesntSendWindowUpdate(Variant variant)
+      throws IOException, InterruptedException {
+    peer.setVariantAndClient(variant, false);
+
+    // Write the mocking script.
+    peer.acceptFrame(); // SYN_STREAM
+    peer.acceptFrame(); // DATA
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    peer.play();
+
+    // Play it back.
+    SpdyConnection connection = connection(peer, variant);
+    SpdyStream client = connection.newStream(headerEntries("b", "banana"), true, true);
+    BufferedSink out = Okio.buffer(client.getSink());
+    out.write(Util.EMPTY_BYTE_ARRAY);
+    out.flush();
+    out.close();
+
+    // Verify the peer received what was expected.
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(TYPE_DATA, peer.takeFrame().type);
+    assertEquals(3, peer.frameCount());
+  }
+
   @Test public void writeAwaitsWindowUpdate() throws Exception {
-    int windowSize = 65535;
+    int framesThatFillWindow = roundUp(DEFAULT_INITIAL_WINDOW_SIZE, HTTP_20_DRAFT_09.maxFrameSize());
 
     // Write the mocking script. This accepts more data frames than necessary!
     peer.acceptFrame(); // SYN_STREAM
-    for (int i = 0; i < windowSize / 1024; i++) {
+    for (int i = 0; i < framesThatFillWindow; i++) {
       peer.acceptFrame(); // DATA
     }
+    peer.acceptFrame(); // DATA we won't be able to flush until a window update.
     peer.play();
 
     // Play it back.
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    OutputStream out = stream.getOutputStream();
-    out.write(new byte[windowSize]);
-    interruptAfterDelay(500);
-    try {
-      out.write('a');
-      out.flush();
-      fail();
-    } catch (InterruptedIOException expected) {
-    }
+    BufferedSink out = Okio.buffer(stream.getSink());
+    out.write(new byte[DEFAULT_INITIAL_WINDOW_SIZE]);
+    out.flush();
+
+    // Check that we've filled the window for both the stream and also the connection.
+    assertEquals(0, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
+
+    out.writeByte('a');
+    assertFlushBlocks(out);
+
+    // receiving a window update on the connection isn't enough.
+    connection.readerRunnable.windowUpdate(0, 1);
+    assertFlushBlocks(out);
+
+    // receiving a window update on the stream will unblock the stream.
+    connection.readerRunnable.windowUpdate(1, 1);
+    out.flush();
 
     // Verify the peer received what was expected.
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
     assertEquals(TYPE_HEADERS, synStream.type);
-    MockSpdyPeer.InFrame data = peer.takeFrame();
-    assertEquals(TYPE_DATA, data.type);
+    for (int i = 0; i < framesThatFillWindow; i++) {
+      MockSpdyPeer.InFrame data = peer.takeFrame();
+      assertEquals(TYPE_DATA, data.type);
+    }
+  }
+
+  @Test public void initialSettingsWithWindowSizeAdjustsConnection() throws Exception {
+    int framesThatFillWindow = roundUp(DEFAULT_INITIAL_WINDOW_SIZE, HTTP_20_DRAFT_09.maxFrameSize());
+
+    // Write the mocking script. This accepts more data frames than necessary!
+    peer.acceptFrame(); // SYN_STREAM
+    for (int i = 0; i < framesThatFillWindow; i++) {
+      peer.acceptFrame(); // DATA on stream 1
+    }
+    peer.acceptFrame(); // DATA on stream 2
+    peer.play();
+
+    // Play it back.
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream = connection.newStream(headerEntries("a", "apple"), true, true);
+    BufferedSink out = Okio.buffer(stream.getSink());
+    out.write(new byte[DEFAULT_INITIAL_WINDOW_SIZE]);
+    out.flush();
+
+    // write 1 more than the window size
+    out.writeByte('a');
+    assertFlushBlocks(out);
+
+    // Check that we've filled the window for both the stream and also the connection.
+    assertEquals(0, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
+
+    // Receiving a Settings with a larger window size will unblock the streams.
+    Settings initial = new Settings();
+    initial.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, DEFAULT_INITIAL_WINDOW_SIZE + 1);
+    connection.readerRunnable.settings(false, initial);
+
+    assertEquals(1, connection.bytesLeftInWriteWindow);
+    assertEquals(1, connection.getStream(1).bytesLeftInWriteWindow);
+
+    // The stream should no longer be blocked.
+    out.flush();
+
+    assertEquals(0, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
+
+    // Settings after the initial do not affect the connection window size.
+    Settings next = new Settings();
+    next.set(Settings.INITIAL_WINDOW_SIZE, PERSIST_VALUE, DEFAULT_INITIAL_WINDOW_SIZE + 2);
+    connection.readerRunnable.settings(false, next);
+
+    assertEquals(0, connection.bytesLeftInWriteWindow); // connection wasn't affected.
+    assertEquals(1, connection.getStream(1).bytesLeftInWriteWindow);
   }
 
   @Test public void testTruncatedDataFrame() throws Exception {
     // write the mocking script
     peer.acceptFrame(); // SYN_STREAM
     peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
-    peer.sendTruncatedFrame(8 + 100).data(false, 1, new byte[1024]);
+    peer.sendTruncatedFrame(8 + 100).data(false, 1, data(1024));
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     assertEquals(headerEntries("a", "android"), stream.getResponseHeaders());
-    InputStream in = stream.getInputStream();
+    Source in = stream.getSource();
     try {
-      Util.readFully(in, new byte[101]);
+      Okio.buffer(in).readByteString(101);
       fail();
     } catch (IOException expected) {
       assertEquals("stream was reset: PROTOCOL_ERROR", expected.getMessage());
     }
   }
 
-  /**
-   * This tests that data frames are written in chunks limited by the
-   * SpdyDataOutputStream buffer size.  A side-effect is that this size
-   * prevents us from overrunning the max frame size of SPDY/3 or HTTP/2.
-   */
-  @Test public void spdyStreamOutputBufferSizeLimitsDataFrameLength() throws Exception {
-    MockSpdyPeer peer = new MockSpdyPeer(HTTP_20_DRAFT_09, false);
+  @Test public void blockedStreamDoesntStarveNewStream() throws Exception {
+    int framesThatFillWindow = roundUp(DEFAULT_INITIAL_WINDOW_SIZE, SPDY3.maxFrameSize());
+
+    // Write the mocking script. This accepts more data frames than necessary!
+    peer.acceptFrame(); // SYN_STREAM on stream 1
+    for (int i = 0; i < framesThatFillWindow; i++) {
+      peer.acceptFrame(); // DATA on stream 1
+    }
+    peer.acceptFrame(); // SYN_STREAM on stream 2
+    peer.acceptFrame(); // DATA on stream 2
+    peer.play();
+
+    // Play it back.
+    SpdyConnection connection = connection(peer, SPDY3);
+    SpdyStream stream1 = connection.newStream(headerEntries("a", "apple"), true, true);
+    BufferedSink out1 = Okio.buffer(stream1.getSink());
+    out1.write(new byte[DEFAULT_INITIAL_WINDOW_SIZE]);
+    out1.flush();
+
+    // Check that we've filled the window for both the stream and also the connection.
+    assertEquals(0, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
+
+    // receiving a window update on the the connection will unblock new streams.
+    connection.readerRunnable.windowUpdate(0, 3);
+
+    assertEquals(3, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
 
-    byte[] buff = new byte[SpdyStream.OUTPUT_BUFFER_SIZE * 2];
+    // Another stream should be able to send data even though 1 is blocked.
+    SpdyStream stream2 = connection.newStream(headerEntries("b", "banana"), true, true);
+    BufferedSink out2 = Okio.buffer(stream2.getSink());
+    out2.writeUtf8("foo");
+    out2.flush();
+
+    assertEquals(0, connection.bytesLeftInWriteWindow);
+    assertEquals(0, connection.getStream(1).bytesLeftInWriteWindow);
+    assertEquals(DEFAULT_INITIAL_WINDOW_SIZE - 3, connection.getStream(3).bytesLeftInWriteWindow);
+  }
+
+  @Test public void maxFrameSizeHonored() throws Exception {
+    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
+
+    byte[] buff = new byte[HTTP_20_DRAFT_09.maxFrameSize() + 1];
     Arrays.fill(buff, (byte) '*');
 
     // write the mocking script
@@ -1127,7 +1347,7 @@ private void readSendsWindowUpdate(Variant variant)
     // play it back
     SpdyConnection connection = connection(peer, HTTP_20_DRAFT_09);
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
-    OutputStream out = stream.getOutputStream();
+    BufferedSink out = Okio.buffer(stream.getSink());
     out.write(buff);
     out.flush();
     out.close();
@@ -1135,15 +1355,13 @@ private void readSendsWindowUpdate(Variant variant)
     MockSpdyPeer.InFrame synStream = peer.takeFrame();
     assertEquals(TYPE_HEADERS, synStream.type);
     MockSpdyPeer.InFrame data = peer.takeFrame();
-    assertEquals(SpdyStream.OUTPUT_BUFFER_SIZE, data.data.length);
+    assertEquals(HTTP_20_DRAFT_09.maxFrameSize(), data.data.length);
     data = peer.takeFrame();
-    assertEquals(SpdyStream.OUTPUT_BUFFER_SIZE, data.data.length);
+    assertEquals(1, data.data.length);
   }
 
   /** https://github.com/square/okhttp/issues/333 */
-  @Test public void headerBlockHasTrailingCompressedBytes() throws Exception {
-    // write the mocking script
-    peer.acceptFrame(); // SYN_STREAM
+  @Test public void headerBlockHasTrailingCompressedBytes512() throws Exception {
     // This specially-formatted frame has trailing deflated bytes after the name value block.
     String frame = "gAMAAgAAAgkAAAABeLvjxqfCYgAAAAD//2IAAAAA//9iAAAAAP//YgQAAAD//2IAAAAA//9iAAAAAP/"
         + "/YgAAAAD//2IEAAAA//9KBAAAAP//YgAAAAD//2IAAAAA//9iAAAAAP//sgEAAAD//2IAAAAA\n//9iBAAAAP//Y"
@@ -1154,22 +1372,144 @@ private void readSendsWindowUpdate(Variant variant)
         + "//SAAAAAP//0gQAAAD//9ICAAAA///SBgAAAP//0gEAAAD//9IFAAAA///SAwAAAP//0gcAAAD//zIAAAAA//8yB"
         + "AAAAP//MgIAAAD//zIGAAAA//8yAQAAAP//MgUAAAD//zIDAAAA//8yBwAAAP//sgAAAAD//7IEAAAA//+yAgAAA"
         + "P//sgYAAAD//w==";
-    peer.sendFrame(Base64.decode(frame.getBytes(UTF_8)));
-    peer.sendFrame().data(true, 1, "robot".getBytes("UTF-8"));
+    headerBlockHasTrailingCompressedBytes(frame, 60);
+  }
+
+  @Test public void headerBlockHasTrailingCompressedBytes2048() throws Exception {
+    // This specially-formatted frame has trailing deflated bytes after the name value block.
+    String frame = "gAMAAgAAB/sAAAABeLvjxqfCAqYjRhAGJmxGxUQAAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
+        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
+        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
+        + "AAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD"
+        + "//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0o"
+        + "EAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAA"
+        + "A//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9"
+        + "KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
+        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
+        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
+        + "AAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD"
+        + "//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0o"
+        + "EAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAA"
+        + "A//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9"
+        + "KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
+        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
+        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
+        + "AAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD"
+        + "//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0o"
+        + "EAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAA"
+        + "A//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9"
+        + "KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
+        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
+        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
+        + "AAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD"
+        + "//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0o"
+        + "EAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAA"
+        + "A//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9"
+        + "KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAA"
+        + "AAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP/"
+        + "/SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQAAAD//0oEAAAA//9KBAAAAP//SgQ"
+        + "AAAD//0oEAAAA//8=";
+    headerBlockHasTrailingCompressedBytes(frame, 289);
+  }
+
+  private void headerBlockHasTrailingCompressedBytes(String frame, int length) throws IOException {
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame(ByteString.decodeBase64(frame).toByteArray());
+    peer.sendFrame().data(true, 1, new OkBuffer().writeUtf8("robot"));
     peer.acceptFrame(); // DATA
     peer.play();
 
     // play it back
-    SpdyConnection connection = new SpdyConnection.Builder(true, peer.openSocket()).build();
+    SpdyConnection connection = connection(peer, SPDY3);
     SpdyStream stream = connection.newStream(headerEntries("b", "banana"), true, true);
     assertEquals("a", stream.getResponseHeaders().get(0).name.utf8());
-    assertEquals(60, stream.getResponseHeaders().get(0).value.size());
-    assertStreamData("robot", stream.getInputStream());
+    assertEquals(length, stream.getResponseHeaders().get(0).value.size());
+    assertStreamData("robot", stream.getSource());
+  }
+
+  @Test public void pushPromiseStream() throws Exception {
+    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
+
+    // write the mocking script
+    peer.acceptFrame(); // SYN_STREAM
+    peer.sendFrame().synReply(false, 1, headerEntries("a", "android"));
+    final List<Header> expectedRequestHeaders = Arrays.asList(
+        new Header(Header.TARGET_METHOD, "GET"),
+        new Header(Header.TARGET_SCHEME, "https"),
+        new Header(Header.TARGET_AUTHORITY, "squareup.com"),
+        new Header(Header.TARGET_PATH, "/cached")
+    );
+    peer.sendFrame().pushPromise(1, 2, expectedRequestHeaders);
+    final List<Header> expectedResponseHeaders = Arrays.asList(
+        new Header(Header.RESPONSE_STATUS, "200")
+    );
+    peer.sendFrame().synReply(true, 2, expectedResponseHeaders);
+    peer.sendFrame().data(true, 1, data(0));
+    peer.play();
+
+    final List events = new ArrayList();
+    PushObserver observer = new PushObserver() {
+
+      @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
+        assertEquals(2, streamId);
+        events.add(requestHeaders);
+        return false;
+      }
+
+      @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
+        assertEquals(2, streamId);
+        assertTrue(last);
+        events.add(responseHeaders);
+        return false;
+      }
+
+      @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
+          boolean last) throws IOException {
+        events.add(new AssertionError("onData"));
+        return false;
+      }
+
+      @Override public void onReset(int streamId, ErrorCode errorCode) {
+        events.add(new AssertionError("onReset"));
+      }
+    };
+
+    // play it back
+    SpdyConnection connection = connectionBuilder(peer, HTTP_20_DRAFT_09)
+        .pushObserver(observer).build();
+    SpdyStream client = connection.newStream(headerEntries("b", "banana"), false, true);
+    assertEquals(-1, client.getSource().read(new OkBuffer(), 1));
+
+    // verify the peer received what was expected
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+
+    assertEquals(2, events.size());
+    assertEquals(expectedRequestHeaders, events.get(0));
+    assertEquals(expectedResponseHeaders, events.get(1));
+  }
+
+  @Test public void doublePushPromise() throws Exception {
+    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
+
+    // write the mocking script
+    peer.sendFrame().pushPromise(1,2, headerEntries("a", "android"));
+    peer.acceptFrame(); // SYN_REPLY
+    peer.sendFrame().pushPromise(1, 2, headerEntries("b", "banana"));
+    peer.acceptFrame(); // RST_STREAM
+    peer.play();
+
+    // play it back
+    SpdyConnection connection = connectionBuilder(peer, HTTP_20_DRAFT_09).build();
+    connection.newStream(headerEntries("b", "banana"), false, true);
+
+    // verify the peer received what was expected
+    assertEquals(TYPE_HEADERS, peer.takeFrame().type);
+    assertEquals(PROTOCOL_ERROR, peer.takeFrame().errorCode);
   }
 
-  // TODO: change this to only cancel when local settings disable push
   @Test public void pushPromiseStreamsAutomaticallyCancel() throws Exception {
-    MockSpdyPeer peer = new MockSpdyPeer(HTTP_20_DRAFT_09, false);
+    peer.setVariantAndClient(HTTP_20_DRAFT_09, false);
 
     // write the mocking script
     peer.sendFrame().pushPromise(1, 2, Arrays.asList(
@@ -1178,14 +1518,15 @@ private void readSendsWindowUpdate(Variant variant)
         new Header(Header.TARGET_AUTHORITY, "squareup.com"),
         new Header(Header.TARGET_PATH, "/cached")
     ));
-    peer.sendFrame().synReply(true, 1, Arrays.asList(
+    peer.sendFrame().synReply(true, 2, Arrays.asList(
         new Header(Header.RESPONSE_STATUS, "200")
     ));
     peer.acceptFrame(); // RST_STREAM
     peer.play();
 
     // play it back
-    connection(peer, HTTP_20_DRAFT_09);
+    connectionBuilder(peer, HTTP_20_DRAFT_09)
+        .pushObserver(PushObserver.CANCEL).build();
 
     // verify the peer received what was expected
     MockSpdyPeer.InFrame rstStream = peer.takeFrame();
@@ -1196,7 +1537,7 @@ private void readSendsWindowUpdate(Variant variant)
 
   private SpdyConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings settings)
       throws IOException, InterruptedException {
-    MockSpdyPeer peer = new MockSpdyPeer(HTTP_20_DRAFT_09, client);
+    peer.setVariantAndClient(HTTP_20_DRAFT_09, client);
     peer.sendFrame().settings(settings);
     peer.acceptFrame(); // ACK
     peer.play();
@@ -1205,37 +1546,41 @@ private SpdyConnection sendHttp2SettingsAndCheckForAck(boolean client, Settings
     SpdyConnection connection = connection(peer, HTTP_20_DRAFT_09);
 
     // verify the peer received the ACK
-    MockSpdyPeer.InFrame pingFrame = peer.takeFrame();
-    assertEquals(TYPE_SETTINGS, pingFrame.type);
-    assertEquals(0, pingFrame.streamId);
-    // TODO: check for ACK flag.
-    assertEquals(0, pingFrame.settings.size());
-    peer.close();
+    MockSpdyPeer.InFrame ackFrame = peer.takeFrame();
+    assertEquals(TYPE_SETTINGS, ackFrame.type);
+    assertEquals(0, ackFrame.streamId);
+    assertTrue(ackFrame.ack);
     return connection;
   }
 
   private SpdyConnection connection(MockSpdyPeer peer, Variant variant) throws IOException {
-    return new SpdyConnection.Builder(true, peer.openSocket())
-        .protocol(variant.getProtocol())
-        .handler(REJECT_INCOMING_STREAMS).build();
+    return connectionBuilder(peer, variant).build();
   }
 
-  private void writeAndClose(SpdyStream stream, String data) throws IOException {
-    OutputStream out = stream.getOutputStream();
-    out.write(data.getBytes("UTF-8"));
-    out.close();
+  private SpdyConnection.Builder connectionBuilder(MockSpdyPeer peer, Variant variant)
+      throws IOException {
+    return new SpdyConnection.Builder(true, peer.openSocket())
+        .pushObserver(IGNORE)
+        .protocol(variant.getProtocol());
   }
 
-  private void assertStreamData(String expected, InputStream inputStream) throws IOException {
-    ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();
-    byte[] buffer = new byte[1024];
-    for (int count; (count = inputStream.read(buffer)) != -1; ) {
-      bytesOut.write(buffer, 0, count);
+  private void assertStreamData(String expected, Source source) throws IOException {
+    OkBuffer buffer = new OkBuffer();
+    while (source.read(buffer, Long.MAX_VALUE) != -1) {
     }
-    String actual = bytesOut.toString("UTF-8");
+    String actual = buffer.readUtf8(buffer.size());
     assertEquals(expected, actual);
   }
 
+  private void assertFlushBlocks(BufferedSink out) throws IOException {
+    interruptAfterDelay(500);
+    try {
+      out.flush();
+      fail();
+    } catch (InterruptedIOException expected) {
+    }
+  }
+
   /** Interrupts the current thread after {@code delayMillis}. */
   private void interruptAfterDelay(final long delayMillis) {
     final Thread toInterrupt = Thread.currentThread();
@@ -1250,4 +1595,28 @@ private void interruptAfterDelay(final long delayMillis) {
       }
     }.start();
   }
+
+  static int roundUp(int num, int divisor) {
+    return (num + divisor - 1) / divisor;
+  }
+
+  static final PushObserver IGNORE = new PushObserver() {
+
+    @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
+      return false;
+    }
+
+    @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
+      return false;
+    }
+
+    @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
+        boolean last) throws IOException {
+      source.skip(byteCount);
+      return false;
+    }
+
+    @Override public void onReset(int streamId, ErrorCode errorCode) {
+    }
+  };
 }
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/tls/FakeSSLSession.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/FakeSSLSession.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/tls/FakeSSLSession.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/FakeSSLSession.java
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/tls/HostnameVerifierTest.java b/okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/HostnameVerifierTest.java
similarity index 100%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/tls/HostnameVerifierTest.java
rename to okhttp-tests/src/test/java/com/squareup/okhttp/internal/tls/HostnameVerifierTest.java
diff --git a/okhttp/pom.xml b/okhttp/pom.xml
index 17f4cdac20..c7e3ec4bda 100644
--- a/okhttp/pom.xml
+++ b/okhttp/pom.xml
@@ -14,27 +14,10 @@
 
   <dependencies>
     <dependency>
-      <groupId>com.squareup.okhttp</groupId>
-      <artifactId>okhttp-protocols</artifactId>
+      <groupId>com.squareup.okio</groupId>
+      <artifactId>okio</artifactId>
       <version>${project.version}</version>
     </dependency>
-    <dependency>
-      <groupId>com.squareup.okhttp</groupId>
-      <artifactId>mockwebserver</artifactId>
-      <version>${project.version}</version>
-      <scope>test</scope>
-    </dependency>
-    <dependency>
-      <groupId>org.mortbay.jetty.npn</groupId>
-      <artifactId>npn-boot</artifactId>
-      <scope>provided</scope>
-    </dependency>
-
-    <dependency>
-      <groupId>junit</groupId>
-      <artifactId>junit</artifactId>
-      <scope>test</scope>
-    </dependency>
   </dependencies>
 
   <build>
@@ -46,24 +29,6 @@
           <excludePackageNames>com.squareup.okhttp.internal:com.squareup.okhttp.internal.*</excludePackageNames>
         </configuration>
       </plugin>
-
-      <plugin>
-        <groupId>org.apache.maven.plugins</groupId>
-        <artifactId>maven-assembly-plugin</artifactId>
-        <configuration>
-          <descriptorRefs>
-            <descriptorRef>jar-with-dependencies</descriptorRef>
-          </descriptorRefs>
-        </configuration>
-        <executions>
-          <execution>
-            <phase>package</phase>
-            <goals>
-              <goal>single</goal>
-            </goals>
-          </execution>
-        </executions>
-      </plugin>
     </plugins>
   </build>
 </project>
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Connection.java b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
index 9ff7b7069c..55884dcf43 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Connection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Connection.java
@@ -16,23 +16,19 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.http.HttpAuthenticator;
+import com.squareup.okhttp.internal.http.HttpConnection;
 import com.squareup.okhttp.internal.http.HttpEngine;
 import com.squareup.okhttp.internal.http.HttpTransport;
 import com.squareup.okhttp.internal.http.SpdyTransport;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
-import java.io.BufferedInputStream;
-import java.io.BufferedOutputStream;
 import java.io.Closeable;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
 import java.net.Proxy;
 import java.net.Socket;
-import java.net.SocketTimeoutException;
 import javax.net.ssl.SSLSocket;
+import okio.ByteString;
 
 import static java.net.HttpURLConnection.HTTP_OK;
 import static java.net.HttpURLConnection.HTTP_PROXY_AUTH;
@@ -64,19 +60,20 @@
  * should the attempt fail.
  */
 public final class Connection implements Closeable {
-
+  private final ConnectionPool pool;
   private final Route route;
 
   private Socket socket;
-  private InputStream in;
-  private OutputStream out;
   private boolean connected = false;
+  private HttpConnection httpConnection;
   private SpdyConnection spdyConnection;
   private int httpMinorVersion = 1; // Assume HTTP/1.1
   private long idleStartTimeNs;
   private Handshake handshake;
+  private int recycleCount;
 
-  public Connection(Route route) {
+  public Connection(ConnectionPool pool, Route route) {
+    this.pool = pool;
     this.route = route;
   }
 
@@ -87,13 +84,11 @@ public void connect(int connectTimeout, int readTimeout, TunnelRequest tunnelReq
     socket = (route.proxy.type() != Proxy.Type.HTTP) ? new Socket(route.proxy) : new Socket();
     Platform.get().connectSocket(socket, route.inetSocketAddress, connectTimeout);
     socket.setSoTimeout(readTimeout);
-    in = socket.getInputStream();
-    out = socket.getOutputStream();
 
     if (route.address.sslSocketFactory != null) {
       upgradeToTls(tunnelRequest);
     } else {
-      streamWrapper();
+      httpConnection = new HttpConnection(pool, this, socket);
     }
     connected = true;
   }
@@ -120,19 +115,19 @@ private void upgradeToTls(TunnelRequest tunnelRequest) throws IOException {
       platform.supportTlsIntolerantServer(sslSocket);
     }
 
-    boolean useNpn = route.modernTls && (// Contains a spdy variant.
-        route.address.protocols.contains(Protocol.HTTP_2)
-     || route.address.protocols.contains(Protocol.SPDY_3)
-    );
-
-    if (useNpn) {
-      if (route.address.protocols.contains(Protocol.HTTP_2) // Contains both spdy variants.
-          && route.address.protocols.contains(Protocol.SPDY_3)) {
+    boolean useNpn = false;
+    if (route.modernTls) {
+      boolean http2 = route.address.protocols.contains(Protocol.HTTP_2);
+      boolean spdy3 = route.address.protocols.contains(Protocol.SPDY_3);
+      if (http2 && spdy3) {
         platform.setNpnProtocols(sslSocket, Protocol.HTTP2_SPDY3_AND_HTTP);
-      } else if (route.address.protocols.contains(Protocol.HTTP_2)) {
+        useNpn = true;
+      } else if (http2) {
         platform.setNpnProtocols(sslSocket, Protocol.HTTP2_AND_HTTP_11);
-      } else {
+        useNpn = true;
+      } else if (spdy3) {
         platform.setNpnProtocols(sslSocket, Protocol.SPDY3_AND_HTTP11);
+        useNpn = true;
       }
     }
 
@@ -144,20 +139,21 @@ private void upgradeToTls(TunnelRequest tunnelRequest) throws IOException {
       throw new IOException("Hostname '" + route.address.uriHost + "' was not verified");
     }
 
-    out = sslSocket.getOutputStream();
-    in = sslSocket.getInputStream();
     handshake = Handshake.get(sslSocket.getSession());
-    streamWrapper();
 
     ByteString maybeProtocol;
+    Protocol selectedProtocol = Protocol.HTTP_11;
     if (useNpn && (maybeProtocol = platform.getNpnSelectedProtocol(sslSocket)) != null) {
-      Protocol selectedProtocol = Protocol.find(maybeProtocol); // Throws IOE on unknown.
-      if (selectedProtocol.spdyVariant) {
-        sslSocket.setSoTimeout(0); // SPDY timeouts are set per-stream.
-        spdyConnection = new SpdyConnection.Builder(route.address.getUriHost(), true, in, out)
-            .protocol(selectedProtocol).build();
-        spdyConnection.sendConnectionHeader();
-      }
+      selectedProtocol = Protocol.find(maybeProtocol); // Throws IOE on unknown.
+    }
+
+    if (selectedProtocol.spdyVariant) {
+      sslSocket.setSoTimeout(0); // SPDY timeouts are set per-stream.
+      spdyConnection = new SpdyConnection.Builder(route.address.getUriHost(), true, socket)
+          .protocol(selectedProtocol).build();
+      spdyConnection.sendConnectionHeader();
+    } else {
+      httpConnection = new HttpConnection(pool, this, socket);
     }
   }
 
@@ -194,31 +190,8 @@ public boolean isAlive() {
    * #isAlive()}; callers should check {@link #isAlive()} first.
    */
   public boolean isReadable() {
-    if (!(in instanceof BufferedInputStream)) {
-      return true; // Optimistic.
-    }
-    if (isSpdy()) {
-      return true; // Optimistic. We can't test SPDY because its streams are in use.
-    }
-    BufferedInputStream bufferedInputStream = (BufferedInputStream) in;
-    try {
-      int readTimeout = socket.getSoTimeout();
-      try {
-        socket.setSoTimeout(1);
-        bufferedInputStream.mark(1);
-        if (bufferedInputStream.read() == -1) {
-          return false; // Stream is exhausted; socket is closed.
-        }
-        bufferedInputStream.reset();
-        return true;
-      } finally {
-        socket.setSoTimeout(readTimeout);
-      }
-    } catch (SocketTimeoutException ignored) {
-      return true; // Read timed out; socket is good.
-    } catch (IOException e) {
-      return false; // Couldn't read; socket is closed.
-    }
+    if (httpConnection != null) return httpConnection.isReadable();
+    return true; // SPDY connections, and connections before connect() are both optimistic.
   }
 
   public void resetIdleStartTime() {
@@ -255,7 +228,7 @@ public Handshake getHandshake() {
   public Object newTransport(HttpEngine httpEngine) throws IOException {
     return (spdyConnection != null)
         ? new SpdyTransport(httpEngine, spdyConnection)
-        : new HttpTransport(httpEngine, out, in);
+        : new HttpTransport(httpEngine, httpConnection);
   }
 
   /**
@@ -293,35 +266,52 @@ public void updateReadTimeout(int newTimeout) throws IOException {
     socket.setSoTimeout(newTimeout);
   }
 
+  public void incrementRecycleCount() {
+    recycleCount++;
+  }
+
+  /**
+   * Returns the number of times this connection has been returned to the
+   * connection pool.
+   */
+  public int recycleCount() {
+    return recycleCount;
+  }
+
   /**
    * To make an HTTPS connection over an HTTP proxy, send an unencrypted
    * CONNECT request to create the proxy connection. This may need to be
    * retried if the proxy requires authorization.
    */
   private void makeTunnel(TunnelRequest tunnelRequest) throws IOException {
+    HttpConnection tunnelConnection = new HttpConnection(pool, this, socket);
     Request request = tunnelRequest.getRequest();
     String requestLine = tunnelRequest.requestLine();
     while (true) {
-      HttpTransport.writeRequest(out, request.headers(), requestLine);
-      Response response = HttpTransport.readResponse(in).request(request).build();
+      tunnelConnection.writeRequest(request.headers(), requestLine);
+      tunnelConnection.flush();
+      Response response = tunnelConnection.readResponse().request(request).build();
+      tunnelConnection.emptyResponseBody();
 
       switch (response.code()) {
         case HTTP_OK:
+          // Assume the server won't send a TLS ServerHello until we send a TLS ClientHello. If that
+          // happens, then we will have buffered bytes that are needed by the SSLSocket!
+          if (tunnelConnection.bufferSize() > 0) {
+            throw new IOException("TLS tunnel buffered too many bytes!");
+          }
           return;
+
         case HTTP_PROXY_AUTH:
           request = HttpAuthenticator.processAuthHeader(
               route.address.authenticator, response, route.proxy);
           if (request != null) continue;
           throw new IOException("Failed to authenticate with proxy");
+
         default:
           throw new IOException(
               "Unexpected response code for CONNECT: " + response.code());
       }
     }
   }
-
-  private void streamWrapper() throws IOException {
-    in = new BufferedInputStream(in, 4096);
-    out = new BufferedOutputStream(out, 256);
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
index 5eb4874aa4..24ab543c11 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/ConnectionPool.java
@@ -23,7 +23,6 @@
 import java.util.LinkedList;
 import java.util.List;
 import java.util.ListIterator;
-import java.util.concurrent.Callable;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
@@ -83,8 +82,8 @@
   private final ExecutorService executorService = new ThreadPoolExecutor(0, 1,
       60L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),
       Util.threadFactory("OkHttp ConnectionPool", true));
-  private final Callable<Void> connectionsCleanupCallable = new Callable<Void>() {
-    @Override public Void call() throws Exception {
+  private final Runnable connectionsCleanupRunnable = new Runnable() {
+    @Override public void run() {
       List<Connection> expiredConnections = new ArrayList<Connection>(MAX_CONNECTIONS_TO_CLEANUP);
       int idleConnectionCount = 0;
       synchronized (ConnectionPool.this) {
@@ -113,7 +112,6 @@
       for (Connection expiredConnection : expiredConnections) {
         Util.closeQuietly(expiredConnection);
       }
-      return null;
     }
   };
 
@@ -205,7 +203,7 @@ public synchronized Connection get(Address address) {
       connections.addFirst(foundConnection); // Add it back after iteration.
     }
 
-    executorService.submit(connectionsCleanupCallable);
+    executorService.execute(connectionsCleanupRunnable);
     return foundConnection;
   }
 
@@ -236,22 +234,20 @@ public void recycle(Connection connection) {
 
     synchronized (this) {
       connections.addFirst(connection);
+      connection.incrementRecycleCount();
       connection.resetIdleStartTime();
     }
 
-    executorService.submit(connectionsCleanupCallable);
+    executorService.execute(connectionsCleanupRunnable);
   }
 
   /**
    * Shares the SPDY connection with the pool. Callers to this method may
    * continue to use {@code connection}.
    */
-  public void maybeShare(Connection connection) {
-    executorService.submit(connectionsCleanupCallable);
-    if (!connection.isSpdy()) {
-      // Only SPDY connections are sharable.
-      return;
-    }
+  public void share(Connection connection) {
+    if (!connection.isSpdy()) throw new IllegalArgumentException();
+    executorService.execute(connectionsCleanupRunnable);
     if (connection.isAlive()) {
       synchronized (this) {
         connections.addFirst(connection);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
index 198fd4ea80..58e06be40b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Dispatcher.java
@@ -19,7 +19,7 @@
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.Iterator;
-import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
@@ -27,7 +27,7 @@
 /**
  * Policy on when async requests are executed.
  *
- * <p>Each dispatcher uses an {@link Executor} to run jobs internally. If you
+ * <p>Each dispatcher uses an {@link ExecutorService} to run jobs internally. If you
  * supply your own executor, it should be able to run {@link #getMaxRequests the
  * configured maximum} number of jobs concurrently.
  */
@@ -36,7 +36,7 @@
   private int maxRequestsPerHost = 5;
 
   /** Executes jobs. Created lazily. */
-  private Executor executor;
+  private ExecutorService executorService;
 
   /** Ready jobs in the order they'll be run. */
   private final Deque<Job> readyJobs = new ArrayDeque<Job>();
@@ -44,19 +44,19 @@
   /** Running jobs. Includes canceled jobs that haven't finished yet. */
   private final Deque<Job> runningJobs = new ArrayDeque<Job>();
 
-  public Dispatcher(Executor executor) {
-    this.executor = executor;
+  public Dispatcher(ExecutorService executorService) {
+    this.executorService = executorService;
   }
 
   public Dispatcher() {
   }
 
-  public synchronized Executor getExecutor() {
-    if (executor == null) {
-      executor = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
+  public synchronized ExecutorService getExecutorService() {
+    if (executorService == null) {
+      executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS,
           new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp Dispatcher", false));
     }
-    return executor;
+    return executorService;
   }
 
   /**
@@ -107,7 +107,7 @@ synchronized void enqueue(OkHttpClient client, Request request, Response.Receive
 
     if (runningJobs.size() < maxRequests && runningJobsForHost(job) < maxRequestsPerHost) {
       runningJobs.add(job);
-      getExecutor().execute(job);
+      getExecutorService().execute(job);
     } else {
       readyJobs.add(job);
     }
@@ -143,7 +143,7 @@ private void promoteJobs() {
       if (runningJobsForHost(job) < maxRequestsPerHost) {
         i.remove();
         runningJobs.add(job);
-        getExecutor().execute(job);
+        getExecutorService().execute(job);
       }
 
       if (runningJobs.size() >= maxRequests) return; // Reached max capacity.
diff --git a/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java b/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java
index db8809ebe0..c6edf4b79d 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/HttpResponseCache.java
@@ -16,10 +16,9 @@
 
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.Base64;
 import com.squareup.okhttp.internal.DiskLruCache;
-import com.squareup.okhttp.internal.StrictLineReader;
 import com.squareup.okhttp.internal.Util;
+import com.squareup.okhttp.internal.http.HttpMethod;
 import java.io.BufferedWriter;
 import java.io.ByteArrayInputStream;
 import java.io.File;
@@ -43,8 +42,10 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Okio;
 
-import static com.squareup.okhttp.internal.Util.US_ASCII;
 import static com.squareup.okhttp.internal.Util.UTF_8;
 
 /**
@@ -195,8 +196,7 @@ private static String urlToKey(Request requst) {
   }
 
   @Override public boolean maybeRemove(Request request) {
-    String method = request.method();
-    if (method.equals("POST") || method.equals("PUT") || method.equals("DELETE")) {
+    if (HttpMethod.invalidatesCache(request.method())) {
       try {
         cache.remove(urlToKey(request));
       } catch (IOException ignored) {
@@ -412,32 +412,32 @@ public CacheRequestImpl(final DiskLruCache.Editor editor) throws IOException {
      */
     public Entry(InputStream in) throws IOException {
       try {
-        StrictLineReader reader = new StrictLineReader(in, US_ASCII);
-        url = reader.readLine();
-        requestMethod = reader.readLine();
+        BufferedSource source = Okio.buffer(Okio.source(in));
+        url = source.readUtf8LineStrict();
+        requestMethod = source.readUtf8LineStrict();
         Headers.Builder varyHeadersBuilder = new Headers.Builder();
-        int varyRequestHeaderLineCount = reader.readInt();
+        int varyRequestHeaderLineCount = readInt(source);
         for (int i = 0; i < varyRequestHeaderLineCount; i++) {
-          varyHeadersBuilder.addLine(reader.readLine());
+          varyHeadersBuilder.addLine(source.readUtf8LineStrict());
         }
         varyHeaders = varyHeadersBuilder.build();
 
-        statusLine = reader.readLine();
+        statusLine = source.readUtf8LineStrict();
         Headers.Builder responseHeadersBuilder = new Headers.Builder();
-        int responseHeaderLineCount = reader.readInt();
+        int responseHeaderLineCount = readInt(source);
         for (int i = 0; i < responseHeaderLineCount; i++) {
-          responseHeadersBuilder.addLine(reader.readLine());
+          responseHeadersBuilder.addLine(source.readUtf8LineStrict());
         }
         responseHeaders = responseHeadersBuilder.build();
 
         if (isHttps()) {
-          String blank = reader.readLine();
+          String blank = source.readUtf8LineStrict();
           if (blank.length() > 0) {
             throw new IOException("expected \"\" but was \"" + blank + "\"");
           }
-          String cipherSuite = reader.readLine();
-          List<Certificate> peerCertificates = readCertificateList(reader);
-          List<Certificate> localCertificates = readCertificateList(reader);
+          String cipherSuite = source.readUtf8LineStrict();
+          List<Certificate> peerCertificates = readCertificateList(source);
+          List<Certificate> localCertificates = readCertificateList(source);
           handshake = Handshake.get(cipherSuite, peerCertificates, localCertificates);
         } else {
           handshake = null;
@@ -486,16 +486,16 @@ private boolean isHttps() {
       return url.startsWith("https://");
     }
 
-    private List<Certificate> readCertificateList(StrictLineReader reader) throws IOException {
-      int length = reader.readInt();
+    private List<Certificate> readCertificateList(BufferedSource source) throws IOException {
+      int length = readInt(source);
       if (length == -1) return Collections.emptyList(); // OkHttp v1.2 used -1 to indicate null.
 
       try {
         CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
         List<Certificate> result = new ArrayList<Certificate>(length);
         for (int i = 0; i < length; i++) {
-          String line = reader.readLine();
-          byte[] bytes = Base64.decode(line.getBytes("US-ASCII"));
+          String line = source.readUtf8LineStrict();
+          byte[] bytes = ByteString.decodeBase64(line).toByteArray();
           result.add(certificateFactory.generateCertificate(new ByteArrayInputStream(bytes)));
         }
         return result;
@@ -509,7 +509,7 @@ private void writeCertArray(Writer writer, List<Certificate> certificates) throw
         writer.write(Integer.toString(certificates.size()) + '\n');
         for (int i = 0, size = certificates.size(); i < size; i++) {
           byte[] bytes = certificates.get(i).getEncoded();
-          String line = Base64.encode(bytes);
+          String line = ByteString.of(bytes).base64();
           writer.write(line + '\n');
         }
       } catch (CertificateEncodingException e) {
@@ -536,6 +536,15 @@ public Response response(Request request, DiskLruCache.Snapshot snapshot) {
     }
   }
 
+  private static int readInt(BufferedSource source) throws IOException {
+    String line = source.readUtf8LineStrict();
+    try {
+      return Integer.parseInt(line);
+    } catch (NumberFormatException e) {
+      throw new IOException("Expected an integer but was \"" + line + "\"");
+    }
+  }
+
   private static class CacheResponseBody extends Response.Body {
     private final DiskLruCache.Snapshot snapshot;
     private final InputStream bodyIn;
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Job.java b/okhttp/src/main/java/com/squareup/okhttp/Job.java
index 1a860dfdda..64ce188bf6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Job.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Job.java
@@ -25,6 +25,9 @@
 import java.net.ProtocolException;
 import java.net.Proxy;
 import java.net.URL;
+import okio.BufferedSink;
+import okio.Okio;
+import okio.Source;
 
 import static com.squareup.okhttp.internal.Util.getEffectivePort;
 import static com.squareup.okhttp.internal.http.HttpURLConnectionImpl.HTTP_MOVED_PERM;
@@ -45,7 +48,7 @@
 
   /** The request; possibly a consequence of redirects or auth headers. */
   private Request request;
-  private HttpEngine engine;
+  HttpEngine engine;
 
   public Job(Dispatcher dispatcher, OkHttpClient client, Request request,
       Response.Receiver responseReceiver) {
@@ -80,7 +83,7 @@ Object tag() {
           .exception(e)
           .build());
     } finally {
-      engine.release(true); // Release the connection if it isn't already released.
+      engine.close(); // Close the connection if it isn't already.
       dispatcher.finished(this);
     }
   }
@@ -89,7 +92,7 @@ Object tag() {
    * Performs the request and returns the response. May return null if this job
    * was canceled.
    */
-  private Response getResponse() throws IOException {
+  Response getResponse() throws IOException {
     Response redirectedBy = null;
 
     // Copy body metadata to the appropriate request headers.
@@ -123,7 +126,9 @@ private Response getResponse() throws IOException {
         engine.sendRequest();
 
         if (body != null) {
-          body.writeTo(engine.getRequestBody());
+          BufferedSink sink = Okio.buffer(engine.getRequestBody());
+          body.writeTo(sink);
+          sink.flush();
         }
 
         engine.readResponse();
@@ -142,7 +147,7 @@ private Response getResponse() throws IOException {
       Request redirect = processResponse(engine, response);
 
       if (redirect == null) {
-        engine.automaticallyReleaseConnectionToPool();
+        engine.releaseConnection();
         return response.newBuilder()
             .body(new RealResponseBody(response, engine.getResponseBody()))
             .redirectedBy(redirectedBy)
@@ -150,11 +155,10 @@ private Response getResponse() throws IOException {
       }
 
       if (!sameConnection(request, redirect)) {
-        engine.automaticallyReleaseConnectionToPool();
+        engine.releaseConnection();
       }
 
-      engine.release(false);
-      Connection connection = engine.getConnection();
+      Connection connection = engine.close();
       redirectedBy = response.newBuilder().redirectedBy(redirectedBy).build(); // Chained.
       request = redirect;
       engine = new HttpEngine(client, request, false, connection, null, null);
@@ -229,11 +233,14 @@ static boolean sameConnection(Request a, Request b) {
 
   static class RealResponseBody extends Response.Body {
     private final Response response;
-    private final InputStream in;
+    private final Source source;
 
-    RealResponseBody(Response response, InputStream in) {
+    /** Multiple calls to {@link #byteStream} must return the same instance. */
+    private InputStream in;
+
+    RealResponseBody(Response response, Source source) {
       this.response = response;
-      this.in = in;
+      this.source = source;
     }
 
     @Override public boolean ready() throws IOException {
@@ -249,8 +256,15 @@ static boolean sameConnection(Request a, Request b) {
       return OkHeaders.contentLength(response);
     }
 
+    @Override public Source source() {
+      return source;
+    }
+
     @Override public InputStream byteStream() {
-      return in;
+      InputStream result = in;
+      return result != null
+          ? result
+          : (in = Okio.buffer(source).inputStream());
     }
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkAuthenticator.java b/okhttp/src/main/java/com/squareup/okhttp/OkAuthenticator.java
index a505419248..e8ca5ea87c 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkAuthenticator.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkAuthenticator.java
@@ -15,12 +15,12 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.Base64;
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
 import java.net.Proxy;
 import java.net.URL;
 import java.util.List;
+import okio.ByteString;
 
 /**
  * Responds to authentication challenges from the remote web or proxy server by
@@ -97,7 +97,7 @@ public static Credential basic(String userName, String password) {
       try {
         String usernameAndPassword = userName + ":" + password;
         byte[] bytes = usernameAndPassword.getBytes("ISO-8859-1");
-        String encoded = Base64.encode(bytes);
+        String encoded = ByteString.of(bytes).base64();
         return new Credential("Basic " + encoded);
       } catch (UnsupportedEncodingException e) {
         throw new AssertionError();
diff --git a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
index 5765997626..bb4be687a3 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/OkHttpClient.java
@@ -15,11 +15,11 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.http.HttpAuthenticator;
 import com.squareup.okhttp.internal.http.HttpURLConnectionImpl;
 import com.squareup.okhttp.internal.http.HttpsURLConnectionImpl;
+import com.squareup.okhttp.internal.http.ResponseCacheAdapter;
 import com.squareup.okhttp.internal.tls.OkHostnameVerifier;
 import java.io.IOException;
 import java.net.CookieHandler;
@@ -31,14 +31,26 @@
 import java.net.URLConnection;
 import java.net.URLStreamHandler;
 import java.net.URLStreamHandlerFactory;
+import java.security.GeneralSecurityException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
 import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLSocketFactory;
+import okio.ByteString;
 
-/** Configures and creates HTTP connections. */
+/**
+ * Configures and creates HTTP connections. Most applications can use a single
+ * OkHttpClient for all of their HTTP requests - benefiting from a shared
+ * response cache, thread pool, connection re-use, etc.
+ *
+ * Instances of OkHttpClient are intended to be fully configured before they're
+ * shared - once shared they should be treated as immutable and can safely be used
+ * to concurrently open new connections. If required, threads can call
+ * {@link #clone()} to make a shallow copy of the OkHttpClient that can be
+ * safely modified with further configuration changes.
+ */
 public final class OkHttpClient implements URLStreamHandlerFactory, Cloneable {
 
   private final RouteDatabase routeDatabase;
@@ -160,34 +172,15 @@ public CookieHandler getCookieHandler() {
 
   /**
    * Sets the response cache to be used to read and write cached responses.
-   *
-   * <p>If unset, the {@link ResponseCache#getDefault() system-wide default}
-   * response cache will be used.
-   *
-   * @deprecated OkHttp 2 dropped support for java.net.ResponseCache. That API
-   *     is broken for many reasons: URI instead of URL, no conditional updates,
-   *     no invalidation, and no mechanism for tracking hit rates. Use
-   *     {@link #setOkResponseCache} instead.
    */
-  @Deprecated
   public OkHttpClient setResponseCache(ResponseCache responseCache) {
-    if (responseCache instanceof OkResponseCache) {
-      return setOkResponseCache((OkResponseCache) responseCache);
-    }
-    throw new UnsupportedOperationException("OkHttp 2 dropped support for java.net.ResponseCache. "
-        + "Use setOkResponseCache() instead.");
+    return setOkResponseCache(toOkResponseCache(responseCache));
   }
 
-  /**
-   * @deprecated OkHttp 2 dropped support for java.net.ResponseCache. That API
-   *     is broken for many reasons: URI instead of URL, no conditional updates,
-   *     no invalidation, and no mechanism for tracking hit rates. Use
-   *     {@link #setOkResponseCache} instead.
-   */
-  @Deprecated
   public ResponseCache getResponseCache() {
-    throw new UnsupportedOperationException("OkHttp 2 dropped support for java.net.ResponseCache. "
-        + "Use setOkResponseCache() instead.");
+    return responseCache instanceof ResponseCacheAdapter
+        ? ((ResponseCacheAdapter) responseCache).getDelegate()
+        : null;
   }
 
   public OkHttpClient setOkResponseCache(OkResponseCache responseCache) {
@@ -202,8 +195,7 @@ public OkResponseCache getOkResponseCache() {
   /**
    * Sets the socket factory used to secure HTTPS connections.
    *
-   * <p>If unset, the {@link HttpsURLConnection#getDefaultSSLSocketFactory()
-   * system-wide default} SSL socket factory will be used.
+   * <p>If unset, a lazily created SSL socket factory will be used.
    */
   public OkHttpClient setSslSocketFactory(SSLSocketFactory sslSocketFactory) {
     this.sslSocketFactory = sslSocketFactory;
@@ -218,7 +210,8 @@ public SSLSocketFactory getSslSocketFactory() {
    * Sets the verifier used to confirm that response certificates apply to
    * requested hostnames for HTTPS connections.
    *
-   * <p>If unset, the {@link HttpsURLConnection#getDefaultHostnameVerifier()
+   * <p>If unset, the
+   * {@link javax.net.ssl.HttpsURLConnection#getDefaultHostnameVerifier()
    * system-wide default} hostname verifier will be used.
    */
   public OkHttpClient setHostnameVerifier(HostnameVerifier hostnameVerifier) {
@@ -296,8 +289,9 @@ public Dispatcher getDispatcher() {
   }
 
   /**
-   * @deprecated OkHttp 2 enforces an enumeration of {@link Protocol protocols}
-   * that can be selected. Please switch to {@link #setProtocols(java.util.List)}.
+   * @deprecated OkHttp 1.5 enforces an enumeration of {@link Protocol
+   *     protocols} that can be selected. Please switch to {@link
+   *     #setProtocols(java.util.List)}.
    */
   @Deprecated
   public OkHttpClient setTransports(List<String> transports) {
@@ -323,12 +317,12 @@ public OkHttpClient setTransports(List<String> transports) {
    * <p>The following protocols are currently supported:
    * <ul>
    *   <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html">http/1.1</a>
-   *   <li><a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3">spdy/3</a>
+   *   <li><a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1">spdy/3.1</a>
    *   <li><a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-09">HTTP-draft-09/2.0</a>
    * </ul>
    *
    * <p><strong>This is an evolving set.</strong> Future releases may drop
-   * support for transitional protocols (like spdy/3), in favor of their
+   * support for transitional protocols (like spdy/3.1), in favor of their
    * successors (spdy/4 or http/2.0). The http/1.1 transport will never be
    * dropped.
    *
@@ -349,16 +343,14 @@ public OkHttpClient setProtocols(List<Protocol> protocols) {
     if (protocols.contains(null)) {
       throw new IllegalArgumentException("protocols must not contain null");
     }
-    if (protocols.contains(ByteString.EMPTY)) {
-      throw new IllegalArgumentException("protocols contains an empty string");
-    }
     this.protocols = Util.immutableList(protocols);
     return this;
   }
 
   /**
-   * @deprecated OkHttp 2 enforces an enumeration of {@link Protocol protocols}
-   * that can be selected. Please switch to {@link #getProtocols()}.
+   * @deprecated OkHttp 1.5 enforces an enumeration of {@link Protocol
+   *     protocols} that can be selected. Please switch to {@link
+   *     #getProtocols()}.
    */
   @Deprecated
   public List<String> getTransports() {
@@ -373,6 +365,46 @@ public OkHttpClient setProtocols(List<Protocol> protocols) {
     return protocols;
   }
 
+  /**
+   * Invokes {@code request} immediately, and blocks until the response can be
+   * processed or is in error.
+   *
+   * <p>The caller may read the response body with the response's
+   * {@link Response#body} method.  To facilitate connection recycling, callers
+   * should always {@link Response.Body#close() close the response body}.
+   *
+   * <p>Note that transport-layer success (receiving a HTTP response code,
+   * headers and body) does not necessarily indicate application-layer
+   * success: {@code response} may still indicate an unhappy HTTP response
+   * code like 404 or 500.
+   *
+   * <h3>Non-blocking responses</h3>
+   *
+   * <p>Receivers do not need to block while waiting for the response body to
+   * download. Instead, they can get called back as data arrives. Use {@link
+   * Response.Body#ready} to check if bytes should be read immediately. While
+   * there is data ready, read it.
+   *
+   * <p>The current implementation of {@link Response.Body#ready} always
+   * returns true when the underlying transport is HTTP/1. This results in
+   * blocking on that transport. For effective non-blocking your server must
+   * support {@link Protocol#SPDY_3} or {@link Protocol#HTTP_2}.
+   *
+   * @throws IOException when the request could not be executed due to a
+   * connectivity problem or timeout. Because networks can fail during an
+   * exchange, it is possible that the remote server accepted the request
+   * before the failure.
+   */
+  public Response execute(Request request) throws IOException {
+    // Copy the client. Otherwise changes (socket factory, redirect policy,
+    // etc.) may incorrectly be reflected in the request when it is executed.
+    OkHttpClient client = copyWithDefaults();
+    Job job = new Job(dispatcher, client, request, null);
+    Response result = job.getResponse(); // Since we don't cancel, this won't be null.
+    job.engine.releaseConnection(); // Transfer ownership of the body to the caller.
+    return result;
+  }
+
   /**
    * Schedules {@code request} to be executed at some point in the future. The
    * {@link #getDispatcher dispatcher} defines when the request will run:
@@ -422,10 +454,10 @@ OkHttpClient copyWithDefaults() {
       result.cookieHandler = CookieHandler.getDefault();
     }
     if (result.responseCache == null) {
-      result.responseCache = toOkResponseCacheOrNull(ResponseCache.getDefault());
+      result.responseCache = toOkResponseCache(ResponseCache.getDefault());
     }
     if (result.sslSocketFactory == null) {
-      result.sslSocketFactory = HttpsURLConnection.getDefaultSSLSocketFactory();
+      result.sslSocketFactory = getDefaultSSLSocketFactory();
     }
     if (result.hostnameVerifier == null) {
       result.hostnameVerifier = OkHostnameVerifier.INSTANCE;
@@ -442,6 +474,30 @@ OkHttpClient copyWithDefaults() {
     return result;
   }
 
+  /**
+   * Java and Android programs default to using a single global SSL context,
+   * accessible to HTTP clients as {@link SSLSocketFactory#getDefault()}. If we
+   * used the shared SSL context, when OkHttp enables NPN for its SPDY-related
+   * stuff, it would also enable NPN for other usages, which might crash them
+   * because NPN is enabled when it isn't expected to be.
+   * <p>
+   * This code avoids that by defaulting to an OkHttp created SSL context. The
+   * significant drawback of this approach is that apps that customize the
+   * global SSL context will lose these customizations.
+   */
+  private synchronized SSLSocketFactory getDefaultSSLSocketFactory() {
+    if (sslSocketFactory == null) {
+      try {
+        SSLContext sslContext = SSLContext.getInstance("TLS");
+        sslContext.init(null, null, null);
+        sslSocketFactory = sslContext.getSocketFactory();
+      } catch (GeneralSecurityException e) {
+        throw new AssertionError(); // The system has no TLS. Just give up.
+      }
+    }
+    return sslSocketFactory;
+  }
+
   /** Returns a shallow copy of this OkHttpClient. */
   @Override public OkHttpClient clone() {
     try {
@@ -451,8 +507,10 @@ OkHttpClient copyWithDefaults() {
     }
   }
 
-  private OkResponseCache toOkResponseCacheOrNull(ResponseCache cache) {
-    return cache instanceof OkResponseCache ? ((OkResponseCache) cache) : null;
+  private OkResponseCache toOkResponseCache(ResponseCache responseCache) {
+    return responseCache == null || responseCache instanceof OkResponseCache
+        ? (OkResponseCache) responseCache
+        : new ResponseCacheAdapter(responseCache);
   }
 
   /**
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/Protocol.java b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
similarity index 94%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/Protocol.java
rename to okhttp/src/main/java/com/squareup/okhttp/Protocol.java
index f57361ee0c..e2d7ba9310 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/Protocol.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Protocol.java
@@ -15,27 +15,27 @@
  */
 package com.squareup.okhttp;
 
-import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.List;
+import okio.ByteString;
 
 /**
  * Contains protocols that OkHttp supports
  * <a href="http://tools.ietf.org/html/draft-agl-tls-nextprotoneg-04">NPN</a> or
  * <a href="http://tools.ietf.org/html/draft-ietf-tls-applayerprotoneg">ALPN</a> selection.
  *
- * <p/>
+ * <p>
  * <h3>Protocol vs Scheme</h3>
  * Despite its name, {@link java.net.URL#getProtocol()} returns the
  * {@link java.net.URI#getScheme() scheme} (http, https, etc.) of the URL, not
- * the protocol (http/1.1, spdy/3, etc.).  OkHttp uses the word protocol to
+ * the protocol (http/1.1, spdy/3.1, etc.).  OkHttp uses the word protocol to
  * indicate how HTTP messages are framed.
  */
 public enum Protocol {
   HTTP_2("HTTP-draft-09/2.0", true),
-  SPDY_3("spdy/3", true),
+  SPDY_3("spdy/3.1", true),
   HTTP_11("http/1.1", false);
 
   public static final List<Protocol> HTTP2_SPDY3_AND_HTTP =
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Request.java b/okhttp/src/main/java/com/squareup/okhttp/Request.java
index 317e0b4c86..300dc17e57 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Request.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Request.java
@@ -21,13 +21,13 @@
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.OutputStream;
 import java.io.UnsupportedEncodingException;
 import java.net.MalformedURLException;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.URL;
 import java.util.List;
+import okio.BufferedSink;
 
 /**
  * An HTTP request. Instances of this class are immutable if their {@link #body}
@@ -158,7 +158,7 @@ public long contentLength() {
     }
 
     /** Writes the content of this request to {@code out}. */
-    public abstract void writeTo(OutputStream out) throws IOException;
+    public abstract void writeTo(BufferedSink sink) throws IOException;
 
     /**
      * Returns a new request body that transmits {@code content}. If {@code
@@ -190,8 +190,8 @@ public static Body create(final MediaType contentType, final byte[] content) {
           return content.length;
         }
 
-        @Override public void writeTo(OutputStream out) throws IOException {
-          out.write(content);
+        @Override public void writeTo(BufferedSink sink) throws IOException {
+          sink.write(content);
         }
       };
     }
@@ -210,7 +210,7 @@ public static Body create(final MediaType contentType, final File file) {
           return file.length();
         }
 
-        @Override public void writeTo(OutputStream out) throws IOException {
+        @Override public void writeTo(BufferedSink sink) throws IOException {
           long length = contentLength();
           if (length == 0) return;
 
@@ -219,7 +219,7 @@ public static Body create(final MediaType contentType, final File file) {
             in = new FileInputStream(file);
             byte[] buffer = new byte[(int) Math.min(8192, length)];
             for (int c; (c = in.read(buffer)) != -1; ) {
-              out.write(buffer, 0, c);
+              sink.write(buffer, 0, c);
             }
           } finally {
             Util.closeQuietly(in);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/Response.java b/okhttp/src/main/java/com/squareup/okhttp/Response.java
index 0a95a0de77..13f912420f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/Response.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/Response.java
@@ -32,6 +32,8 @@
 import java.util.List;
 import java.util.Set;
 import java.util.TreeSet;
+import okio.Okio;
+import okio.Source;
 
 import static com.squareup.okhttp.internal.Util.UTF_8;
 import static com.squareup.okhttp.internal.Util.equal;
@@ -189,9 +191,12 @@ public boolean validate(Response network) {
     /** Multiple calls to {@link #charStream()} must return the same instance. */
     private Reader reader;
 
+    /** Multiple calls to {@link #source()} must return the same instance. */
+    private Source source;
+
     /**
      * Returns true if further data from this response body should be read at
-     * this time. For asynchronous protocols like SPDY and HTTP/2.0, this will
+     * this time. For asynchronous protocols like SPDY and HTTP/2, this will
      * return false once all locally-available body bytes have been read.
      *
      * <p>Clients with many concurrent downloads can use this method to reduce
@@ -213,6 +218,12 @@ public boolean validate(Response network) {
 
     public abstract InputStream byteStream();
 
+    // TODO: Source needs to be an API type for this to be public
+    public Source source() {
+      Source s = source;
+      return s != null ? s : (source = Okio.source(byteStream()));
+    }
+
     public final byte[] bytes() throws IOException {
       long contentLength = contentLength();
       if (contentLength > Integer.MAX_VALUE) {
@@ -239,10 +250,8 @@ public boolean validate(Response network) {
      * charset, this will attempt to decode the response body as UTF-8.
      */
     public final Reader charStream() {
-      if (reader == null) {
-        reader = new InputStreamReader(byteStream(), charset());
-      }
-      return reader;
+      Reader r = reader;
+      return r != null ? r : (reader = new InputStreamReader(byteStream(), charset()));
     }
 
     /**
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/AbstractOutputStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/AbstractOutputStream.java
deleted file mode 100644
index 78c9691e6f..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/AbstractOutputStream.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal;
-
-import java.io.IOException;
-import java.io.OutputStream;
-
-/**
- * An output stream for an HTTP request body.
- *
- * <p>Since a single socket's output stream may be used to write multiple HTTP
- * requests to the same server, subclasses should not close the socket stream.
- */
-public abstract class AbstractOutputStream extends OutputStream {
-  protected boolean closed;
-
-  @Override public final void write(int data) throws IOException {
-    write(new byte[] { (byte) data });
-  }
-
-  protected final void checkNotClosed() throws IOException {
-    if (closed) {
-      throw new IOException("stream closed");
-    }
-  }
-
-  /** Returns true if this stream was closed locally. */
-  public boolean isClosed() {
-    return closed;
-  }
-}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/BitArray.java b/okhttp/src/main/java/com/squareup/okhttp/internal/BitArray.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/BitArray.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/BitArray.java
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
index 19e4cee61f..7f4fa11061 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/DiskLruCache.java
@@ -16,7 +16,6 @@
 
 package com.squareup.okhttp.internal;
 
-import java.io.BufferedWriter;
 import java.io.Closeable;
 import java.io.EOFException;
 import java.io.File;
@@ -26,19 +25,19 @@
 import java.io.FilterOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.InputStreamReader;
 import java.io.OutputStream;
-import java.io.OutputStreamWriter;
-import java.io.Writer;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.Map;
-import java.util.concurrent.Callable;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.OkBuffer;
+import okio.Okio;
 
 /**
  * A cache that uses a bounded amount of space on a filesystem. Each cache
@@ -145,7 +144,7 @@
   private long maxSize;
   private final int valueCount;
   private long size = 0;
-  private Writer journalWriter;
+  private BufferedSink journalWriter;
   private final LinkedHashMap<String, Entry> lruEntries =
       new LinkedHashMap<String, Entry>(0, 0.75f, true);
   private int redundantOpCount;
@@ -160,19 +159,22 @@
   /** This cache uses a single background thread to evict entries. */
   final ThreadPoolExecutor executorService = new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS,
       new LinkedBlockingQueue<Runnable>(), Util.threadFactory("OkHttp DiskLruCache", true));
-  private final Callable<Void> cleanupCallable = new Callable<Void>() {
-    public Void call() throws Exception {
+  private final Runnable cleanupRunnable = new Runnable() {
+    public void run() {
       synchronized (DiskLruCache.this) {
         if (journalWriter == null) {
-          return null; // Closed.
+          return; // Closed.
         }
-        trimToSize();
-        if (journalRebuildRequired()) {
-          rebuildJournal();
-          redundantOpCount = 0;
+        try {
+          trimToSize();
+          if (journalRebuildRequired()) {
+            rebuildJournal();
+            redundantOpCount = 0;
+          }
+        } catch (IOException e) {
+          throw new RuntimeException(e);
         }
       }
-      return null;
     }
   };
 
@@ -222,8 +224,7 @@ public static DiskLruCache open(File directory, int appVersion, int valueCount,
       try {
         cache.readJournal();
         cache.processJournal();
-        cache.journalWriter = new BufferedWriter(
-            new OutputStreamWriter(new FileOutputStream(cache.journalFile, true), Util.US_ASCII));
+        cache.journalWriter = Okio.buffer(Okio.sink(new FileOutputStream(cache.journalFile, true)));
         return cache;
       } catch (IOException journalIsCorrupt) {
         Platform.get().logW("DiskLruCache " + directory + " is corrupt: "
@@ -240,13 +241,13 @@ public static DiskLruCache open(File directory, int appVersion, int valueCount,
   }
 
   private void readJournal() throws IOException {
-    StrictLineReader reader = new StrictLineReader(new FileInputStream(journalFile), Util.US_ASCII);
+    BufferedSource source = Okio.buffer(Okio.source(new FileInputStream(journalFile)));
     try {
-      String magic = reader.readLine();
-      String version = reader.readLine();
-      String appVersionString = reader.readLine();
-      String valueCountString = reader.readLine();
-      String blank = reader.readLine();
+      String magic = source.readUtf8LineStrict();
+      String version = source.readUtf8LineStrict();
+      String appVersionString = source.readUtf8LineStrict();
+      String valueCountString = source.readUtf8LineStrict();
+      String blank = source.readUtf8LineStrict();
       if (!MAGIC.equals(magic)
           || !VERSION_1.equals(version)
           || !Integer.toString(appVersion).equals(appVersionString)
@@ -259,7 +260,7 @@ private void readJournal() throws IOException {
       int lineCount = 0;
       while (true) {
         try {
-          readJournalLine(reader.readLine());
+          readJournalLine(source.readUtf8LineStrict());
           lineCount++;
         } catch (EOFException endOfJournal) {
           break;
@@ -267,7 +268,7 @@ private void readJournal() throws IOException {
       }
       redundantOpCount = lineCount - lruEntries.size();
     } finally {
-      Util.closeQuietly(reader);
+      Util.closeQuietly(source);
     }
   }
 
@@ -342,24 +343,23 @@ private synchronized void rebuildJournal() throws IOException {
       journalWriter.close();
     }
 
-    Writer writer = new BufferedWriter(
-        new OutputStreamWriter(new FileOutputStream(journalFileTmp), Util.US_ASCII));
+    BufferedSink writer = Okio.buffer(Okio.sink(new FileOutputStream(journalFileTmp)));
     try {
-      writer.write(MAGIC);
-      writer.write("\n");
-      writer.write(VERSION_1);
-      writer.write("\n");
-      writer.write(Integer.toString(appVersion));
-      writer.write("\n");
-      writer.write(Integer.toString(valueCount));
-      writer.write("\n");
-      writer.write("\n");
+      writer.writeUtf8(MAGIC);
+      writer.writeUtf8("\n");
+      writer.writeUtf8(VERSION_1);
+      writer.writeUtf8("\n");
+      writer.writeUtf8(Integer.toString(appVersion));
+      writer.writeUtf8("\n");
+      writer.writeUtf8(Integer.toString(valueCount));
+      writer.writeUtf8("\n");
+      writer.writeUtf8("\n");
 
       for (Entry entry : lruEntries.values()) {
         if (entry.currentEditor != null) {
-          writer.write(DIRTY + ' ' + entry.key + '\n');
+          writer.writeUtf8(DIRTY + ' ' + entry.key + '\n');
         } else {
-          writer.write(CLEAN + ' ' + entry.key + entry.getLengths() + '\n');
+          writer.writeUtf8(CLEAN + ' ' + entry.key + entry.getLengths() + '\n');
         }
       }
     } finally {
@@ -372,13 +372,13 @@ private synchronized void rebuildJournal() throws IOException {
     renameTo(journalFileTmp, journalFile, false);
     journalFileBackup.delete();
 
-    journalWriter = new BufferedWriter(
-        new OutputStreamWriter(new FileOutputStream(journalFile, true), Util.US_ASCII));
+    journalWriter = Okio.buffer(Okio.sink(new FileOutputStream(journalFile, true)));
   }
 
   private static void deleteIfExists(File file) throws IOException {
-    if (file.exists() && !file.delete()) {
-      throw new IOException();
+    // If delete() fails, make sure it's because the file didn't exist!
+    if (!file.delete() && file.exists()) {
+      throw new IOException("failed to delete " + file);
     }
   }
 
@@ -429,9 +429,9 @@ public synchronized Snapshot get(String key) throws IOException {
     }
 
     redundantOpCount++;
-    journalWriter.append(READ + ' ' + key + '\n');
+    journalWriter.writeUtf8(READ + ' ' + key + '\n');
     if (journalRebuildRequired()) {
-      executorService.submit(cleanupCallable);
+      executorService.execute(cleanupRunnable);
     }
 
     return new Snapshot(key, entry.sequenceNumber, ins, entry.lengths);
@@ -464,7 +464,7 @@ private synchronized Editor edit(String key, long expectedSequenceNumber) throws
     entry.currentEditor = editor;
 
     // Flush the journal before creating files to prevent file leaks.
-    journalWriter.write(DIRTY + ' ' + key + '\n');
+    journalWriter.writeUtf8(DIRTY + ' ' + key + '\n');
     journalWriter.flush();
     return editor;
   }
@@ -478,7 +478,7 @@ public File getDirectory() {
    * Returns the maximum number of bytes that this cache should use to store
    * its data.
    */
-  public long getMaxSize() {
+  public synchronized long getMaxSize() {
     return maxSize;
   }
 
@@ -488,7 +488,7 @@ public long getMaxSize() {
    */
   public synchronized void setMaxSize(long maxSize) {
     this.maxSize = maxSize;
-    executorService.submit(cleanupCallable);
+    executorService.execute(cleanupRunnable);
   }
 
   /**
@@ -540,18 +540,18 @@ private synchronized void completeEdit(Editor editor, boolean success) throws IO
     entry.currentEditor = null;
     if (entry.readable | success) {
       entry.readable = true;
-      journalWriter.write(CLEAN + ' ' + entry.key + entry.getLengths() + '\n');
+      journalWriter.writeUtf8(CLEAN + ' ' + entry.key + entry.getLengths() + '\n');
       if (success) {
         entry.sequenceNumber = nextSequenceNumber++;
       }
     } else {
       lruEntries.remove(entry.key);
-      journalWriter.write(REMOVE + ' ' + entry.key + '\n');
+      journalWriter.writeUtf8(REMOVE + ' ' + entry.key + '\n');
     }
     journalWriter.flush();
 
     if (size > maxSize || journalRebuildRequired()) {
-      executorService.submit(cleanupCallable);
+      executorService.execute(cleanupRunnable);
     }
   }
 
@@ -581,19 +581,17 @@ public synchronized boolean remove(String key) throws IOException {
 
     for (int i = 0; i < valueCount; i++) {
       File file = entry.getCleanFile(i);
-      if (!file.delete()) {
-        throw new IOException("failed to delete " + file);
-      }
+      deleteIfExists(file);
       size -= entry.lengths[i];
       entry.lengths[i] = 0;
     }
 
     redundantOpCount++;
-    journalWriter.append(REMOVE + ' ' + key + '\n');
+    journalWriter.writeUtf8(REMOVE + ' ' + key + '\n');
     lruEntries.remove(key);
 
     if (journalRebuildRequired()) {
-      executorService.submit(cleanupCallable);
+      executorService.execute(cleanupRunnable);
     }
 
     return true;
@@ -659,7 +657,8 @@ private void validateKey(String key) {
   }
 
   private static String inputStreamToString(InputStream in) throws IOException {
-    return Util.readFully(new InputStreamReader(in, Util.UTF_8));
+    OkBuffer buffer = Util.readFully(Okio.source(in));
+    return buffer.readUtf8(buffer.size());
   }
 
   /** A snapshot of the values for an entry. */
@@ -790,13 +789,9 @@ public OutputStream newOutputStream(int index) throws IOException {
 
     /** Sets the value at {@code index} to {@code value}. */
     public void set(int index, String value) throws IOException {
-      Writer writer = null;
-      try {
-        writer = new OutputStreamWriter(newOutputStream(index), Util.UTF_8);
-        writer.write(value);
-      } finally {
-        Util.closeQuietly(writer);
-      }
+      BufferedSink writer = Okio.buffer(Okio.sink(newOutputStream(index)));
+      writer.writeUtf8(value);
+      writer.close();
     }
 
     /**
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/Dns.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Dns.java
index 69b2d37e94..a89b293c08 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/Dns.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Dns.java
@@ -25,6 +25,7 @@
 public interface Dns {
   Dns DEFAULT = new Dns() {
     @Override public InetAddress[] getAllByName(String host) throws UnknownHostException {
+      if (host == null) throw new UnknownHostException("host == null");
       return InetAddress.getAllByName(host);
     }
   };
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/FaultRecoveringOutputStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/FaultRecoveringOutputStream.java
deleted file mode 100644
index c32b27aebb..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/FaultRecoveringOutputStream.java
+++ /dev/null
@@ -1,163 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal;
-
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-
-import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
-
-/**
- * An output stream wrapper that recovers from failures in the underlying stream
- * by replacing it with another stream. This class buffers a fixed amount of
- * data under the assumption that failures occur early in a stream's life.
- * If a failure occurs after the buffer has been exhausted, no recovery is
- * attempted.
- *
- * <p>Subclasses must override {@link #replacementStream} which will request a
- * replacement stream each time an {@link IOException} is encountered on the
- * current stream.
- */
-public abstract class FaultRecoveringOutputStream extends AbstractOutputStream {
-  private final int maxReplayBufferLength;
-
-  /** Bytes to transmit on the replacement stream, or null if no recovery is possible. */
-  private ByteArrayOutputStream replayBuffer;
-  private OutputStream out;
-
-  /**
-   * @param maxReplayBufferLength the maximum number of successfully written
-   *     bytes to buffer so they can be replayed in the event of an error.
-   *     Failure recoveries are not possible once this limit has been exceeded.
-   */
-  public FaultRecoveringOutputStream(int maxReplayBufferLength, OutputStream out) {
-    if (maxReplayBufferLength < 0) throw new IllegalArgumentException();
-    this.maxReplayBufferLength = maxReplayBufferLength;
-    this.replayBuffer = new ByteArrayOutputStream(maxReplayBufferLength);
-    this.out = out;
-  }
-
-  @Override public final void write(byte[] buffer, int offset, int count) throws IOException {
-    if (closed) throw new IOException("stream closed");
-    checkOffsetAndCount(buffer.length, offset, count);
-
-    while (true) {
-      try {
-        out.write(buffer, offset, count);
-
-        if (replayBuffer != null) {
-          if (count + replayBuffer.size() > maxReplayBufferLength) {
-            // Failure recovery is no longer possible once we overflow the replay buffer.
-            replayBuffer = null;
-          } else {
-            // Remember the written bytes to the replay buffer.
-            replayBuffer.write(buffer, offset, count);
-          }
-        }
-        return;
-      } catch (IOException e) {
-        if (!recover(e)) throw e;
-      }
-    }
-  }
-
-  @Override public final void flush() throws IOException {
-    if (closed) {
-      return; // don't throw; this stream might have been closed on the caller's behalf
-    }
-    while (true) {
-      try {
-        out.flush();
-        return;
-      } catch (IOException e) {
-        if (!recover(e)) throw e;
-      }
-    }
-  }
-
-  @Override public final void close() throws IOException {
-    if (closed) {
-      return;
-    }
-    while (true) {
-      try {
-        out.close();
-        closed = true;
-        return;
-      } catch (IOException e) {
-        if (!recover(e)) throw e;
-      }
-    }
-  }
-
-  /**
-   * Attempt to replace {@code out} with another equivalent stream. Returns true
-   * if a suitable replacement stream was found.
-   */
-  private boolean recover(IOException e) {
-    if (replayBuffer == null) {
-      return false; // Can't recover because we've dropped data that we would need to replay.
-    }
-
-    while (true) {
-      OutputStream replacementStream = null;
-      try {
-        replacementStream = replacementStream(e);
-        if (replacementStream == null) {
-          return false;
-        }
-        replaceStream(replacementStream);
-        return true;
-      } catch (IOException replacementStreamFailure) {
-        // The replacement was also broken. Loop to ask for another replacement.
-        Util.closeQuietly(replacementStream);
-        e = replacementStreamFailure;
-      }
-    }
-  }
-
-  /**
-   * Returns true if errors in the underlying stream can currently be recovered.
-   */
-  public boolean isRecoverable() {
-    return replayBuffer != null;
-  }
-
-  /**
-   * Replaces the current output stream with {@code replacementStream}, writing
-   * any replay bytes to it if they exist. The current output stream is closed.
-   */
-  public final void replaceStream(OutputStream replacementStream) throws IOException {
-    if (!isRecoverable()) {
-      throw new IllegalStateException();
-    }
-    if (this.out == replacementStream) {
-      return; // Don't replace a stream with itself.
-    }
-    replayBuffer.writeTo(replacementStream);
-    Util.closeQuietly(out);
-    out = replacementStream;
-  }
-
-  /**
-   * Returns a replacement output stream to recover from {@code e} thrown by the
-   * previous stream. Returns a new OutputStream if recovery was successful, in
-   * which case all previously-written data will be replayed. Returns null if
-   * the failure cannot be recovered.
-   */
-  protected abstract OutputStream replacementStream(IOException e) throws IOException;
-}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java b/okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/NamedRunnable.java
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
similarity index 98%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
index f02a2ca602..1e7bc40c83 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Platform.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Platform.java
@@ -37,6 +37,7 @@
 import java.util.zip.Deflater;
 import java.util.zip.DeflaterOutputStream;
 import javax.net.ssl.SSLSocket;
+import okio.ByteString;
 
 /**
  * Access to Platform-specific features necessary for SPDY and advanced TLS.
@@ -44,7 +45,7 @@
  * <h3>ALPN and NPN</h3>
  * This class uses TLS extensions ALPN and NPN to negotiate the upgrade from
  * HTTP/1.1 (the default protocol to use with TLS on port 443) to either SPDY
- * or HTTP/2.0.
+ * or HTTP/2.
  *
  * <p>NPN (Next Protocol Negotiation) was developed for SPDY. It is widely
  * available and we support it on both Android (4.1+) and OpenJDK 7 (via the
@@ -292,7 +293,9 @@ private Android(
           byte[] alpnResult = (byte[]) getAlpnSelectedProtocol.invoke(socket);
           if (alpnResult != null) return ByteString.of(alpnResult);
         }
-        return ByteString.of((byte[]) getNpnSelectedProtocol.invoke(socket));
+        byte[] npnResult = (byte[]) getNpnSelectedProtocol.invoke(socket);
+        if (npnResult == null) return null;
+        return ByteString.of(npnResult);
       } catch (InvocationTargetException e) {
         throw new RuntimeException(e);
       } catch (IllegalAccessException e) {
@@ -339,7 +342,7 @@ public JdkWithJettyNpnPlatform(Method putMethod, Method getMethod, Class<?> clie
         if (!provider.unsupported && provider.selected == null) {
           Logger logger = Logger.getLogger("com.squareup.okhttp.OkHttpClient");
           logger.log(Level.INFO,
-              "NPN callback dropped so SPDY is disabled. " + "Is npn-boot on the boot class path?");
+              "NPN callback dropped so SPDY is disabled. Is npn-boot on the boot class path?");
           return null;
         }
         return provider.unsupported ? null : ByteString.encodeUtf8(provider.selected);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/StrictLineReader.java b/okhttp/src/main/java/com/squareup/okhttp/internal/StrictLineReader.java
deleted file mode 100644
index 74af6fd533..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/StrictLineReader.java
+++ /dev/null
@@ -1,207 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal;
-
-import java.io.ByteArrayOutputStream;
-import java.io.Closeable;
-import java.io.EOFException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.UnsupportedEncodingException;
-import java.nio.charset.Charset;
-
-/**
- * Buffers input from an {@link InputStream} for reading lines.
- *
- * <p>This class is used for buffered reading of lines. For purposes of this class, a line ends with
- * "\n" or "\r\n". End of input is reported by throwing {@code EOFException}. Unterminated line at
- * end of input is invalid and will be ignored, the caller may use {@code hasUnterminatedLine()}
- * to detect it after catching the {@code EOFException}.
- *
- * <p>This class is intended for reading input that strictly consists of lines, such as line-based
- * cache entries or cache journal. Unlike the {@link java.io.BufferedReader} which in conjunction
- * with {@link java.io.InputStreamReader} provides similar functionality, this class uses different
- * end-of-input reporting and a more restrictive definition of a line.
- *
- * <p>This class supports only charsets that encode '\r' and '\n' as a single byte with value 13
- * and 10, respectively, and the representation of no other character contains these values.
- * We currently check in constructor that the charset is one of US-ASCII, UTF-8 and ISO-8859-1.
- * The default charset is US_ASCII.
- */
-public class StrictLineReader implements Closeable {
-  private static final byte CR = (byte) '\r';
-  private static final byte LF = (byte) '\n';
-
-  private final InputStream in;
-  private final Charset charset;
-
-  /*
-   * Buffered data is stored in {@code buf}. As long as no exception occurs, 0 <= pos <= end
-   * and the data in the range [pos, end) is buffered for reading. At end of input, if there is
-   * an unterminated line, we set end == -1, otherwise end == pos. If the underlying
-   * {@code InputStream} throws an {@code IOException}, end may remain as either pos or -1.
-   */
-  private byte[] buf;
-  private int pos;
-  private int end;
-
-  /**
-   * Constructs a new {@code LineReader} with the specified charset and the default capacity.
-   *
-   * @param in the {@code InputStream} to read data from.
-   * @param charset the charset used to decode data. Only US-ASCII, UTF-8 and ISO-8859-1 are
-   *     supported.
-   * @throws NullPointerException if {@code in} or {@code charset} is null.
-   * @throws IllegalArgumentException if the specified charset is not supported.
-   */
-  public StrictLineReader(InputStream in, Charset charset) {
-    this(in, 8192, charset);
-  }
-
-  /**
-   * Constructs a new {@code LineReader} with the specified capacity and charset.
-   *
-   * @param in the {@code InputStream} to read data from.
-   * @param capacity the capacity of the buffer.
-   * @param charset the charset used to decode data. Only US-ASCII, UTF-8 and ISO-8859-1 are
-   *     supported.
-   * @throws NullPointerException if {@code in} or {@code charset} is null.
-   * @throws IllegalArgumentException if {@code capacity} is negative or zero
-   *     or the specified charset is not supported.
-   */
-  public StrictLineReader(InputStream in, int capacity, Charset charset) {
-    if (in == null || charset == null) {
-      throw new NullPointerException();
-    }
-    if (capacity < 0) {
-      throw new IllegalArgumentException("capacity <= 0");
-    }
-    if (!(charset.equals(Util.US_ASCII))) {
-      throw new IllegalArgumentException("Unsupported encoding");
-    }
-
-    this.in = in;
-    this.charset = charset;
-    buf = new byte[capacity];
-  }
-
-  /**
-   * Closes the reader by closing the underlying {@code InputStream} and
-   * marking this reader as closed.
-   *
-   * @throws IOException for errors when closing the underlying {@code InputStream}.
-   */
-  public void close() throws IOException {
-    synchronized (in) {
-      if (buf != null) {
-        buf = null;
-        in.close();
-      }
-    }
-  }
-
-  /**
-   * Reads the next line. A line ends with {@code "\n"} or {@code "\r\n"},
-   * this end of line marker is not included in the result.
-   *
-   * @return the next line from the input.
-   * @throws IOException for underlying {@code InputStream} errors.
-   * @throws EOFException for the end of source stream.
-   */
-  public String readLine() throws IOException {
-    synchronized (in) {
-      if (buf == null) {
-        throw new IOException("LineReader is closed");
-      }
-
-      // Read more data if we are at the end of the buffered data.
-      // Though it's an error to read after an exception, we will let {@code fillBuf()}
-      // throw again if that happens; thus we need to handle end == -1 as well as end == pos.
-      if (pos >= end) {
-        fillBuf();
-      }
-      // Try to find LF in the buffered data and return the line if successful.
-      for (int i = pos; i != end; ++i) {
-        if (buf[i] == LF) {
-          int lineEnd = (i != pos && buf[i - 1] == CR) ? i - 1 : i;
-          String res = new String(buf, pos, lineEnd - pos, charset.name());
-          pos = i + 1;
-          return res;
-        }
-      }
-
-      // Let's anticipate up to 80 characters on top of those already read.
-      ByteArrayOutputStream out = new ByteArrayOutputStream(end - pos + 80) {
-        @Override public String toString() {
-          int length = (count > 0 && buf[count - 1] == CR) ? count - 1 : count;
-          try {
-            return new String(buf, 0, length, charset.name());
-          } catch (UnsupportedEncodingException e) {
-            throw new AssertionError(e); // Since we control the charset this will never happen.
-          }
-        }
-      };
-
-      while (true) {
-        out.write(buf, pos, end - pos);
-        // Mark unterminated line in case fillBuf throws EOFException or IOException.
-        end = -1;
-        fillBuf();
-        // Try to find LF in the buffered data and return the line if successful.
-        for (int i = pos; i != end; ++i) {
-          if (buf[i] == LF) {
-            if (i != pos) {
-              out.write(buf, pos, i - pos);
-            }
-            pos = i + 1;
-            return out.toString();
-          }
-        }
-      }
-    }
-  }
-
-  /**
-   * Read an {@code int} from a line containing its decimal representation.
-   *
-   * @return the value of the {@code int} from the next line.
-   * @throws IOException for underlying {@code InputStream} errors or conversion error.
-   * @throws EOFException for the end of source stream.
-   */
-  public int readInt() throws IOException {
-    String intString = readLine();
-    try {
-      return Integer.parseInt(intString);
-    } catch (NumberFormatException e) {
-      throw new IOException("expected an int but was \"" + intString + "\"");
-    }
-  }
-
-  /**
-   * Reads new input data into the buffer. Call only with pos == end or end == -1,
-   * depending on the desired outcome if the function throws.
-   */
-  private void fillBuf() throws IOException {
-    int result = in.read(buf, 0, buf.length);
-    if (result == -1) {
-      throw new EOFException();
-    }
-    pos = 0;
-    end = result;
-  }
-}
-
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java b/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
similarity index 59%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
index 0cd85e1917..51e04e845c 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Util.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/Util.java
@@ -24,15 +24,11 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
-import java.io.Reader;
-import java.io.StringWriter;
 import java.io.UnsupportedEncodingException;
 import java.net.ServerSocket;
 import java.net.Socket;
-import java.net.SocketTimeoutException;
 import java.net.URI;
 import java.net.URL;
-import java.nio.ByteOrder;
 import java.nio.charset.Charset;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
@@ -41,7 +37,9 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.atomic.AtomicReference;
+import okio.ByteString;
+import okio.OkBuffer;
+import okio.Source;
 
 import static java.util.concurrent.TimeUnit.NANOSECONDS;
 
@@ -56,10 +54,6 @@
 
   /** A cheap and type-safe constant for the UTF-8 Charset. */
   public static final Charset UTF_8 = Charset.forName("UTF-8");
-  private static AtomicReference<byte[]> skipBuffer = new AtomicReference<byte[]>();
-
-  private static final char[] DIGITS =
-      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
 
   private Util() {
   }
@@ -82,26 +76,12 @@ public static int getDefaultPort(String protocol) {
     return -1;
   }
 
-  public static void checkOffsetAndCount(int arrayLength, int offset, int count) {
+  public static void checkOffsetAndCount(long arrayLength, long offset, long count) {
     if ((offset | count) < 0 || offset > arrayLength || arrayLength - offset < count) {
       throw new ArrayIndexOutOfBoundsException();
     }
   }
 
-  public static void pokeInt(byte[] dst, int offset, int value, ByteOrder order) {
-    if (order == ByteOrder.BIG_ENDIAN) {
-      dst[offset++] = (byte) ((value >> 24) & 0xff);
-      dst[offset++] = (byte) ((value >> 16) & 0xff);
-      dst[offset++] = (byte) ((value >> 8) & 0xff);
-      dst[offset] = (byte) ((value >> 0) & 0xff);
-    } else {
-      dst[offset++] = (byte) ((value >> 0) & 0xff);
-      dst[offset++] = (byte) ((value >> 8) & 0xff);
-      dst[offset++] = (byte) ((value >> 16) & 0xff);
-      dst[offset] = (byte) ((value >> 24) & 0xff);
-    }
-  }
-
   /** Returns true if two possibly-null objects are equal. */
   public static boolean equal(Object a, Object b) {
     return a == b || (a != null && a.equals(b));
@@ -194,28 +174,6 @@ public static void deleteContents(File dir) throws IOException {
     }
   }
 
-  /**
-   * Implements InputStream.read(int) in terms of InputStream.read(byte[], int, int).
-   * InputStream assumes that you implement InputStream.read(int) and provides default
-   * implementations of the others, but often the opposite is more efficient.
-   */
-  public static int readSingleByte(InputStream in) throws IOException {
-    byte[] buffer = new byte[1];
-    int result = in.read(buffer, 0, 1);
-    return (result != -1) ? buffer[0] & 0xff : -1;
-  }
-
-  /**
-   * Implements OutputStream.write(int) in terms of OutputStream.write(byte[], int, int).
-   * OutputStream assumes that you implement OutputStream.write(int) and provides default
-   * implementations of the others, but often the opposite is more efficient.
-   */
-  public static void writeSingleByte(OutputStream out, int b) throws IOException {
-    byte[] buffer = new byte[1];
-    buffer[0] = (byte) (b & 0xff);
-    out.write(buffer);
-  }
-
   /**
    * Fills 'dst' with bytes from 'in', throwing EOFException if insufficient bytes are available.
    */
@@ -251,68 +209,26 @@ public static void readFully(InputStream in, byte[] dst, int offset, int byteCou
     }
   }
 
-  /** Returns the remainder of 'reader' as a string, closing it when done. */
-  public static String readFully(Reader reader) throws IOException {
-    try {
-      StringWriter writer = new StringWriter();
-      char[] buffer = new char[1024];
-      int count;
-      while ((count = reader.read(buffer)) != -1) {
-        writer.write(buffer, 0, count);
-      }
-      return writer.toString();
-    } finally {
-      reader.close();
+  /** Returns the remainder of 'source' as a buffer, closing it when done. */
+  public static OkBuffer readFully(Source source) throws IOException {
+    OkBuffer result = new OkBuffer();
+    while (source.read(result, 2048) != -1) {
     }
+    source.close();
+    return result;
   }
 
-  /**
-   * Call {@code in.read()} repeatedly until either the stream is exhausted or
-   * {@code byteCount} bytes have been read.
-   *
-   * <p>This method reuses the skip buffer but is careful to never use it at
-   * the same time that another stream is using it. Otherwise streams that use
-   * the caller's buffer for consistency checks like CRC could be clobbered by
-   * other threads. A thread-local buffer is also insufficient because some
-   * streams may call other streams in their skip() method, also clobbering the
-   * buffer.
-   *
-   * <p>This method throws a SocketTimeoutException if {@code timeoutMillis}
-   * elapses before the bytes can be skipped.
-   *
-   * @param timeoutMillis the maximum time to wait, or 0 to wait indefinitely.
-   */
-  public static long skipByReading(InputStream in, long byteCount, long timeoutMillis)
-      throws IOException {
-    if (byteCount == 0) return 0L;
-    long startNanos = timeoutMillis != 0 ? System.nanoTime() : 0;
-
-    // acquire the shared skip buffer.
-    byte[] buffer = skipBuffer.getAndSet(null);
-    if (buffer == null) {
-      buffer = new byte[4096];
+  /** Reads until {@code in} is exhausted or the timeout has elapsed. */
+  public static boolean skipAll(Source in, int timeoutMillis) throws IOException {
+    // TODO: Implement deadlines everywhere so they can do this work.
+    long startNanos = System.nanoTime();
+    OkBuffer skipBuffer = new OkBuffer();
+    while (NANOSECONDS.toMillis(System.nanoTime() - startNanos) < timeoutMillis) {
+      long read = in.read(skipBuffer, 2048);
+      if (read == -1) return true; // Successfully exhausted the stream.
+      skipBuffer.clear();
     }
-
-    long skipped = 0;
-    while (skipped < byteCount) {
-      int toRead = (int) Math.min(byteCount - skipped, buffer.length);
-      int read = in.read(buffer, 0, toRead);
-      if (read == -1) break;
-      skipped += read;
-      if (timeoutMillis != 0
-          && NANOSECONDS.toMillis(System.nanoTime() - startNanos) > timeoutMillis) {
-        throw new SocketTimeoutException("Timed out after reading " + skipped + " of " + byteCount);
-      }
-    }
-
-    // release the shared skip buffer.
-    skipBuffer.set(buffer);
-
-    return skipped;
-  }
-
-  public static long skipByReading(InputStream in, long byteCount) throws IOException {
-    return skipByReading(in, byteCount, 0);
+    return false; // Ran out of time.
   }
 
   /**
@@ -330,39 +246,12 @@ public static int copy(InputStream in, OutputStream out) throws IOException {
     return total;
   }
 
-  /**
-   * Returns the ASCII characters up to but not including the next "\r\n", or
-   * "\n".
-   *
-   * @throws java.io.EOFException if the stream is exhausted before the next newline
-   * character.
-   */
-  public static String readAsciiLine(InputStream in) throws IOException {
-    // TODO: support UTF-8 here instead
-    StringBuilder result = new StringBuilder(80);
-    while (true) {
-      int c = in.read();
-      if (c == -1) {
-        throw new EOFException();
-      } else if (c == '\n') {
-        break;
-      }
-
-      result.append((char) c);
-    }
-    int length = result.length();
-    if (length > 0 && result.charAt(length - 1) == '\r') {
-      result.setLength(length - 1);
-    }
-    return result.toString();
-  }
-
   /** Returns a 32 character string containing a hash of {@code s}. */
   public static String hash(String s) {
     try {
       MessageDigest messageDigest = MessageDigest.getInstance("MD5");
       byte[] md5bytes = messageDigest.digest(s.getBytes("UTF-8"));
-      return bytesToHexString(md5bytes);
+      return ByteString.of(md5bytes).hex();
     } catch (NoSuchAlgorithmException e) {
       throw new AssertionError(e);
     } catch (UnsupportedEncodingException e) {
@@ -370,24 +259,13 @@ public static String hash(String s) {
     }
   }
 
-  private static String bytesToHexString(byte[] bytes) {
-    char[] digits = DIGITS;
-    char[] buf = new char[bytes.length * 2];
-    int c = 0;
-    for (byte b : bytes) {
-      buf[c++] = digits[(b >> 4) & 0xf];
-      buf[c++] = digits[b & 0xf];
-    }
-    return new String(buf);
-  }
-
   /** Returns an immutable copy of {@code list}. */
   public static <T> List<T> immutableList(List<T> list) {
     return Collections.unmodifiableList(new ArrayList<T>(list));
   }
 
   /** Returns an immutable list containing {@code elements}. */
-  public static <T> List<T> immutableList(T[] elements) {
+  public static <T> List<T> immutableList(T... elements) {
     return Collections.unmodifiableList(Arrays.asList(elements.clone()));
   }
 
@@ -408,15 +286,4 @@ public static ThreadFactory threadFactory(final String name, final boolean daemo
     }
     return result;
   }
-
-  /** Mutates the byte array to ensure all characters are lowercase. */
-  public static void asciiLowerCase(byte[] bytes) {
-    for (int i = 0; i < bytes.length; i++) {
-      bytes[i] = asciiLowerCase(bytes[i]);
-    }
-  }
-
-  public static byte asciiLowerCase(byte c) {
-    return 'A' <= c && c <= 'Z' ? (byte) (c + 'a' - 'A') : c;
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/AbstractHttpInputStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/AbstractHttpInputStream.java
deleted file mode 100644
index a7a818e2e6..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/AbstractHttpInputStream.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright (C) 2010 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal.http;
-
-import com.squareup.okhttp.internal.Util;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.CacheRequest;
-
-/**
- * An input stream for the body of an HTTP response.
- *
- * <p>Since a single socket's input stream may be used to read multiple HTTP
- * responses from the same server, subclasses shouldn't close the socket stream.
- *
- * <p>A side effect of reading an HTTP response is that the response cache
- * is populated. If the stream is closed early, that cache entry will be
- * invalidated.
- */
-abstract class AbstractHttpInputStream extends InputStream {
-  protected final InputStream in;
-  protected final HttpEngine httpEngine;
-  private final CacheRequest cacheRequest;
-  protected final OutputStream cacheBody;
-  protected boolean closed;
-
-  AbstractHttpInputStream(InputStream in, HttpEngine httpEngine, CacheRequest cacheRequest)
-      throws IOException {
-    this.in = in;
-    this.httpEngine = httpEngine;
-
-    OutputStream cacheBody = cacheRequest != null ? cacheRequest.getBody() : null;
-
-    // Some apps return a null body; for compatibility we treat that like a null cache request.
-    if (cacheBody == null) {
-      cacheRequest = null;
-    }
-
-    this.cacheBody = cacheBody;
-    this.cacheRequest = cacheRequest;
-  }
-
-  /**
-   * read() is implemented using read(byte[], int, int) so subclasses only
-   * need to override the latter.
-   */
-  @Override public final int read() throws IOException {
-    return Util.readSingleByte(this);
-  }
-
-  protected final void checkNotClosed() throws IOException {
-    if (closed) {
-      throw new IOException("stream closed");
-    }
-  }
-
-  protected final void cacheWrite(byte[] buffer, int offset, int count) throws IOException {
-    if (cacheBody != null) {
-      cacheBody.write(buffer, offset, count);
-    }
-  }
-
-  /**
-   * Closes the cache entry and makes the socket available for reuse. This
-   * should be invoked when the end of the body has been reached.
-   */
-  protected final void endOfInput() throws IOException {
-    if (cacheRequest != null) {
-      cacheBody.close();
-    }
-    httpEngine.release(false);
-  }
-
-  /**
-   * Calls abort on the cache entry and disconnects the socket. This
-   * should be invoked when the connection is closed unexpectedly to
-   * invalidate the cache entry and to prevent the HTTP connection from
-   * being reused. HTTP messages are sent in serial so whenever a message
-   * cannot be read to completion, subsequent messages cannot be read
-   * either and the connection must be discarded.
-   *
-   * <p>An earlier implementation skipped the remaining bytes, but this
-   * requires that the entire transfer be completed. If the intention was
-   * to cancel the transfer, closing the connection is the only solution.
-   */
-  protected final void unexpectedEndOfInput() {
-    if (cacheRequest != null) {
-      cacheRequest.abort();
-    }
-    httpEngine.release(true);
-  }
-}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
index ae0acdfb7e..7cc7e211df 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/CacheStrategy.java
@@ -97,9 +97,11 @@ public static boolean isCacheable(Response response, Request request) {
 
     /** The server's time when the cached response was served, if known. */
     private Date servedDate;
+    private String servedDateString;
 
     /** The last modified date of the cached response, if known. */
     private Date lastModified;
+    private String lastModifiedString;
 
     /**
      * The expiration date of the cached response, if known. If both this field
@@ -136,10 +138,12 @@ public Factory(long nowMillis, Request request, Response cacheResponse) {
           String value = cacheResponse.headers().value(i);
           if ("Date".equalsIgnoreCase(fieldName)) {
             servedDate = HttpDate.parse(value);
+            servedDateString = value;
           } else if ("Expires".equalsIgnoreCase(fieldName)) {
             expires = HttpDate.parse(value);
           } else if ("Last-Modified".equalsIgnoreCase(fieldName)) {
             lastModified = HttpDate.parse(value);
+            lastModifiedString = value;
           } else if ("ETag".equalsIgnoreCase(fieldName)) {
             etag = value;
           } else if ("Age".equalsIgnoreCase(fieldName)) {
@@ -232,9 +236,9 @@ private CacheStrategy getCandidate() {
       Request.Builder conditionalRequestBuilder = request.newBuilder();
 
       if (lastModified != null) {
-        conditionalRequestBuilder.header("If-Modified-Since", HttpDate.format(lastModified));
+        conditionalRequestBuilder.header("If-Modified-Since", lastModifiedString);
       } else if (servedDate != null) {
-        conditionalRequestBuilder.header("If-Modified-Since", HttpDate.format(servedDate));
+        conditionalRequestBuilder.header("If-Modified-Since", servedDateString);
       }
 
       if (etag != null) {
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/DelegatingHttpsURLConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/DelegatingHttpsURLConnection.java
new file mode 100644
index 0000000000..fedf1152fa
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/DelegatingHttpsURLConnection.java
@@ -0,0 +1,292 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one or more
+ *  contributor license agreements.  See the NOTICE file distributed with
+ *  this work for additional information regarding copyright ownership.
+ *  The ASF licenses this file to You under the Apache License, Version 2.0
+ *  (the "License"); you may not use this file except in compliance with
+ *  the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Handshake;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.HttpURLConnection;
+import java.net.ProtocolException;
+import java.net.URL;
+import java.security.Permission;
+import java.security.Principal;
+import java.security.cert.Certificate;
+import java.util.List;
+import java.util.Map;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.HttpsURLConnection;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSocketFactory;
+
+/**
+ * Implement an HTTPS connection by delegating to an HTTP connection for
+ * everything but the HTTPS-specific stuff.
+ */
+abstract class DelegatingHttpsURLConnection extends HttpsURLConnection {
+  private final HttpURLConnection delegate;
+
+  public DelegatingHttpsURLConnection(HttpURLConnection delegate) {
+    super(delegate.getURL());
+    this.delegate = delegate;
+  }
+
+  protected abstract Handshake handshake();
+
+  @Override public abstract void setHostnameVerifier(HostnameVerifier hostnameVerifier);
+
+  @Override public abstract HostnameVerifier getHostnameVerifier();
+
+  @Override public abstract void setSSLSocketFactory(SSLSocketFactory sslSocketFactory);
+
+  @Override public abstract SSLSocketFactory getSSLSocketFactory();
+
+  @Override public String getCipherSuite() {
+    Handshake handshake = handshake();
+    return handshake != null ? handshake.cipherSuite() : null;
+  }
+
+  @Override public Certificate[] getLocalCertificates() {
+    Handshake handshake = handshake();
+    if (handshake == null) return null;
+    List<Certificate> result = handshake.localCertificates();
+    return !result.isEmpty() ? result.toArray(new Certificate[result.size()]) : null;
+  }
+
+  @Override public Certificate[] getServerCertificates() throws SSLPeerUnverifiedException {
+    Handshake handshake = handshake();
+    if (handshake == null) return null;
+    List<Certificate> result = handshake.peerCertificates();
+    return !result.isEmpty() ? result.toArray(new Certificate[result.size()]) : null;
+  }
+
+  @Override public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
+    Handshake handshake = handshake();
+    return handshake != null ? handshake.peerPrincipal() : null;
+  }
+
+  @Override public Principal getLocalPrincipal() {
+    Handshake handshake = handshake();
+    return handshake != null ? handshake.localPrincipal() : null;
+  }
+
+  @Override public void connect() throws IOException {
+    connected = true;
+    delegate.connect();
+  }
+
+  @Override public void disconnect() {
+    delegate.disconnect();
+  }
+
+  @Override public InputStream getErrorStream() {
+    return delegate.getErrorStream();
+  }
+
+  @Override public String getRequestMethod() {
+    return delegate.getRequestMethod();
+  }
+
+  @Override public int getResponseCode() throws IOException {
+    return delegate.getResponseCode();
+  }
+
+  @Override public String getResponseMessage() throws IOException {
+    return delegate.getResponseMessage();
+  }
+
+  @Override public void setRequestMethod(String method) throws ProtocolException {
+    delegate.setRequestMethod(method);
+  }
+
+  @Override public boolean usingProxy() {
+    return delegate.usingProxy();
+  }
+
+  @Override public boolean getInstanceFollowRedirects() {
+    return delegate.getInstanceFollowRedirects();
+  }
+
+  @Override public void setInstanceFollowRedirects(boolean followRedirects) {
+    delegate.setInstanceFollowRedirects(followRedirects);
+  }
+
+  @Override public boolean getAllowUserInteraction() {
+    return delegate.getAllowUserInteraction();
+  }
+
+  @Override public Object getContent() throws IOException {
+    return delegate.getContent();
+  }
+
+  @SuppressWarnings("unchecked") // Spec does not generify
+  @Override public Object getContent(Class[] types) throws IOException {
+    return delegate.getContent(types);
+  }
+
+  @Override public String getContentEncoding() {
+    return delegate.getContentEncoding();
+  }
+
+  @Override public int getContentLength() {
+    return delegate.getContentLength();
+  }
+
+  @Override public String getContentType() {
+    return delegate.getContentType();
+  }
+
+  @Override public long getDate() {
+    return delegate.getDate();
+  }
+
+  @Override public boolean getDefaultUseCaches() {
+    return delegate.getDefaultUseCaches();
+  }
+
+  @Override public boolean getDoInput() {
+    return delegate.getDoInput();
+  }
+
+  @Override public boolean getDoOutput() {
+    return delegate.getDoOutput();
+  }
+
+  @Override public long getExpiration() {
+    return delegate.getExpiration();
+  }
+
+  @Override public String getHeaderField(int pos) {
+    return delegate.getHeaderField(pos);
+  }
+
+  @Override public Map<String, List<String>> getHeaderFields() {
+    return delegate.getHeaderFields();
+  }
+
+  @Override public Map<String, List<String>> getRequestProperties() {
+    return delegate.getRequestProperties();
+  }
+
+  @Override public void addRequestProperty(String field, String newValue) {
+    delegate.addRequestProperty(field, newValue);
+  }
+
+  @Override public String getHeaderField(String key) {
+    return delegate.getHeaderField(key);
+  }
+
+  @Override public long getHeaderFieldDate(String field, long defaultValue) {
+    return delegate.getHeaderFieldDate(field, defaultValue);
+  }
+
+  @Override public int getHeaderFieldInt(String field, int defaultValue) {
+    return delegate.getHeaderFieldInt(field, defaultValue);
+  }
+
+  @Override public String getHeaderFieldKey(int position) {
+    return delegate.getHeaderFieldKey(position);
+  }
+
+  @Override public long getIfModifiedSince() {
+    return delegate.getIfModifiedSince();
+  }
+
+  @Override public InputStream getInputStream() throws IOException {
+    return delegate.getInputStream();
+  }
+
+  @Override public long getLastModified() {
+    return delegate.getLastModified();
+  }
+
+  @Override public OutputStream getOutputStream() throws IOException {
+    return delegate.getOutputStream();
+  }
+
+  @Override public Permission getPermission() throws IOException {
+    return delegate.getPermission();
+  }
+
+  @Override public String getRequestProperty(String field) {
+    return delegate.getRequestProperty(field);
+  }
+
+  @Override public URL getURL() {
+    return delegate.getURL();
+  }
+
+  @Override public boolean getUseCaches() {
+    return delegate.getUseCaches();
+  }
+
+  @Override public void setAllowUserInteraction(boolean newValue) {
+    delegate.setAllowUserInteraction(newValue);
+  }
+
+  @Override public void setDefaultUseCaches(boolean newValue) {
+    delegate.setDefaultUseCaches(newValue);
+  }
+
+  @Override public void setDoInput(boolean newValue) {
+    delegate.setDoInput(newValue);
+  }
+
+  @Override public void setDoOutput(boolean newValue) {
+    delegate.setDoOutput(newValue);
+  }
+
+  @Override public void setIfModifiedSince(long newValue) {
+    delegate.setIfModifiedSince(newValue);
+  }
+
+  @Override public void setRequestProperty(String field, String newValue) {
+    delegate.setRequestProperty(field, newValue);
+  }
+
+  @Override public void setUseCaches(boolean newValue) {
+    delegate.setUseCaches(newValue);
+  }
+
+  @Override public void setConnectTimeout(int timeoutMillis) {
+    delegate.setConnectTimeout(timeoutMillis);
+  }
+
+  @Override public int getConnectTimeout() {
+    return delegate.getConnectTimeout();
+  }
+
+  @Override public void setReadTimeout(int timeoutMillis) {
+    delegate.setReadTimeout(timeoutMillis);
+  }
+
+  @Override public int getReadTimeout() {
+    return delegate.getReadTimeout();
+  }
+
+  @Override public String toString() {
+    return delegate.toString();
+  }
+
+  @Override public void setFixedLengthStreamingMode(int contentLength) {
+    delegate.setFixedLengthStreamingMode(contentLength);
+  }
+
+  @Override public void setChunkedStreamingMode(int chunkLength) {
+    delegate.setChunkedStreamingMode(chunkLength);
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
new file mode 100644
index 0000000000..b12b12d3d3
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpConnection.java
@@ -0,0 +1,581 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Connection;
+import com.squareup.okhttp.ConnectionPool;
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.Protocol;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.internal.Util;
+import java.io.IOException;
+import java.io.OutputStream;
+import java.net.CacheRequest;
+import java.net.ProtocolException;
+import java.net.Socket;
+import java.net.SocketTimeoutException;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.Deadline;
+import okio.OkBuffer;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
+
+import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
+import static com.squareup.okhttp.internal.http.StatusLine.HTTP_CONTINUE;
+import static com.squareup.okhttp.internal.http.Transport.DISCARD_STREAM_TIMEOUT_MILLIS;
+
+/**
+ * A socket connection that can be used to send HTTP/1.1 messages. This class
+ * strictly enforces the following lifecycle:
+ * <ol>
+ *   <li>{@link #writeRequest Send request headers}.
+ *   <li>Open a sink to write the request body. Either {@link
+ *       #newFixedLengthSink fixed-length} or {@link #newChunkedSink chunked}.
+ *   <li>Write to and then close that stream.
+ *   <li>{@link #readResponse Read response headers}.
+ *   <li>Open the HTTP response body input stream. Either {@link
+ *       #newFixedLengthSource fixed-length}, {@link #newChunkedSource chunked}
+ *       or {@link #newUnknownLengthSource unknown length}.
+ *   <li>Read from and close that stream.
+ * </ol>
+ * <p>Exchanges that do not have a request body may skip creating and closing
+ * the request body. Exchanges that do not have a response body must call {@link
+ * #emptyResponseBody}.
+ */
+public final class HttpConnection {
+  private static final int STATE_IDLE = 0; // Idle connections are ready to write request headers.
+  private static final int STATE_OPEN_REQUEST_BODY = 1;
+  private static final int STATE_WRITING_REQUEST_BODY = 2;
+  private static final int STATE_READ_RESPONSE_HEADERS = 3;
+  private static final int STATE_OPEN_RESPONSE_BODY = 4;
+  private static final int STATE_READING_RESPONSE_BODY = 5;
+  private static final int STATE_CLOSED = 6;
+
+  private static final int ON_IDLE_HOLD = 0;
+  private static final int ON_IDLE_POOL = 1;
+  private static final int ON_IDLE_CLOSE = 2;
+
+  private final ConnectionPool pool;
+  private final Connection connection;
+  private final Socket socket;
+  private final BufferedSource source;
+  private final BufferedSink sink;
+
+  private int state = STATE_IDLE;
+  private int onIdle = ON_IDLE_HOLD;
+
+  public HttpConnection(ConnectionPool pool, Connection connection, Socket socket)
+      throws IOException {
+    this.pool = pool;
+    this.connection = connection;
+    this.socket = socket;
+    this.source = Okio.buffer(Okio.source(socket.getInputStream()));
+    this.sink = Okio.buffer(Okio.sink(socket.getOutputStream()));
+  }
+
+  /**
+   * Configure this connection to put itself back into the connection pool when
+   * the HTTP response body is exhausted.
+   */
+  public void poolOnIdle() {
+    onIdle = ON_IDLE_POOL;
+
+    // If we're already idle, go to the pool immediately.
+    if (state == STATE_IDLE) {
+      onIdle = ON_IDLE_HOLD; // Set the on idle policy back to the default.
+      pool.recycle(connection);
+    }
+  }
+
+  /**
+   * Configure this connection to close itself when the HTTP response body is
+   * exhausted.
+   */
+  public void closeOnIdle() throws IOException {
+    onIdle = ON_IDLE_CLOSE;
+
+    // If we're already idle, close immediately.
+    if (state == STATE_IDLE) {
+      state = STATE_CLOSED;
+      connection.close();
+    }
+  }
+
+  /** Returns true if this connection is closed. */
+  public boolean isClosed() {
+    return state == STATE_CLOSED;
+  }
+
+  public void flush() throws IOException {
+    sink.flush();
+  }
+
+  /** Returns the number of buffered bytes immediately readable. */
+  public long bufferSize() {
+    return source.buffer().size();
+  }
+
+  /** Test for a stale socket. */
+  public boolean isReadable() {
+    try {
+      int readTimeout = socket.getSoTimeout();
+      try {
+        socket.setSoTimeout(1);
+        if (source.exhausted()) {
+          return false; // Stream is exhausted; socket is closed.
+        }
+        return true;
+      } finally {
+        socket.setSoTimeout(readTimeout);
+      }
+    } catch (SocketTimeoutException ignored) {
+      return true; // Read timed out; socket is good.
+    } catch (IOException e) {
+      return false; // Couldn't read; socket is closed.
+    }
+  }
+
+  /** Returns bytes of a request header for sending on an HTTP transport. */
+  public void writeRequest(Headers headers, String requestLine) throws IOException {
+    if (state != STATE_IDLE) throw new IllegalStateException("state: " + state);
+    sink.writeUtf8(requestLine).writeUtf8("\r\n");
+    for (int i = 0; i < headers.size(); i ++) {
+      sink.writeUtf8(headers.name(i))
+          .writeUtf8(": ")
+          .writeUtf8(headers.value(i))
+          .writeUtf8("\r\n");
+    }
+    sink.writeUtf8("\r\n");
+    state = STATE_OPEN_REQUEST_BODY;
+  }
+
+  /** Parses bytes of a response header from an HTTP transport. */
+  public Response.Builder readResponse() throws IOException {
+    if (state != STATE_OPEN_REQUEST_BODY && state != STATE_READ_RESPONSE_HEADERS) {
+      throw new IllegalStateException("state: " + state);
+    }
+
+    while (true) {
+      String statusLineString = source.readUtf8LineStrict();
+      StatusLine statusLine = new StatusLine(statusLineString);
+
+      Response.Builder responseBuilder = new Response.Builder()
+          .statusLine(statusLine)
+          .header(OkHeaders.SELECTED_PROTOCOL, Protocol.HTTP_11.name.utf8());
+
+      Headers.Builder headersBuilder = new Headers.Builder();
+      readHeaders(headersBuilder);
+      responseBuilder.headers(headersBuilder.build());
+
+      if (statusLine.code() != HTTP_CONTINUE) {
+        state = STATE_OPEN_RESPONSE_BODY;
+        return responseBuilder;
+      }
+    }
+  }
+
+  /** Reads headers or trailers into {@code builder}. */
+  public void readHeaders(Headers.Builder builder) throws IOException {
+    // parse the result headers until the first blank line
+    for (String line; (line = source.readUtf8LineStrict()).length() != 0; ) {
+      builder.addLine(line);
+    }
+  }
+
+  /**
+   * Discards the response body so that the connection can be reused and the
+   * cache entry can be completed. This needs to be done judiciously, since it
+   * delays the current request in order to speed up a potential future request
+   * that may never occur.
+   */
+  public boolean discard(Source in, int timeoutMillis) {
+    try {
+      int socketTimeout = socket.getSoTimeout();
+      socket.setSoTimeout(timeoutMillis);
+      try {
+        return Util.skipAll(in, timeoutMillis);
+      } finally {
+        socket.setSoTimeout(socketTimeout);
+      }
+    } catch (IOException e) {
+      return false;
+    }
+  }
+
+  public Sink newChunkedSink() {
+    if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
+    state = STATE_WRITING_REQUEST_BODY;
+    return new ChunkedSink();
+  }
+
+  public Sink newFixedLengthSink(long contentLength) {
+    if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
+    state = STATE_WRITING_REQUEST_BODY;
+    return new FixedLengthSink(contentLength);
+  }
+
+  public void writeRequestBody(RetryableSink requestBody) throws IOException {
+    if (state != STATE_OPEN_REQUEST_BODY) throw new IllegalStateException("state: " + state);
+    state = STATE_READ_RESPONSE_HEADERS;
+    requestBody.writeToSocket(sink);
+  }
+
+  public Source newFixedLengthSource(CacheRequest cacheRequest, long length)
+      throws IOException {
+    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+    state = STATE_READING_RESPONSE_BODY;
+    return new FixedLengthSource(cacheRequest, length);
+  }
+
+  /**
+   * Call this to advance past a response body for HTTP responses that do not
+   * have a response body.
+   */
+  public void emptyResponseBody() throws IOException {
+    newFixedLengthSource(null, 0L); // Transition to STATE_IDLE.
+  }
+
+  public Source newChunkedSource(CacheRequest cacheRequest, HttpEngine httpEngine)
+      throws IOException {
+    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+    state = STATE_READING_RESPONSE_BODY;
+    return new ChunkedSource(cacheRequest, httpEngine);
+  }
+
+  public Source newUnknownLengthSource(CacheRequest cacheRequest) throws IOException {
+    if (state != STATE_OPEN_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+    state = STATE_READING_RESPONSE_BODY;
+    return new UnknownLengthSource(cacheRequest);
+  }
+
+  /** An HTTP body with a fixed length known in advance. */
+  private final class FixedLengthSink implements Sink {
+    private boolean closed;
+    private long bytesRemaining;
+
+    private FixedLengthSink(long bytesRemaining) {
+      this.bytesRemaining = bytesRemaining;
+    }
+
+    @Override public Sink deadline(Deadline deadline) {
+      return this; // TODO: honor deadline.
+    }
+
+    @Override public void write(OkBuffer source, long byteCount) throws IOException {
+      if (closed) throw new IllegalStateException("closed");
+      checkOffsetAndCount(source.size(), 0, byteCount);
+      if (byteCount > bytesRemaining) {
+        throw new ProtocolException("expected " + bytesRemaining
+            + " bytes but received " + byteCount);
+      }
+      sink.write(source, byteCount);
+      bytesRemaining -= byteCount;
+    }
+
+    @Override public void flush() throws IOException {
+      if (closed) return; // Don't throw; this stream might have been closed on the caller's behalf.
+      sink.flush();
+    }
+
+    @Override public void close() throws IOException {
+      if (closed) return;
+      closed = true;
+      if (bytesRemaining > 0) throw new ProtocolException("unexpected end of stream");
+      state = STATE_READ_RESPONSE_HEADERS;
+    }
+  }
+
+  private static final String CRLF = "\r\n";
+  private static final byte[] HEX_DIGITS = {
+      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
+  };
+  private static final byte[] FINAL_CHUNK = new byte[] { '0', '\r', '\n', '\r', '\n' };
+
+  /**
+   * An HTTP body with alternating chunk sizes and chunk bodies. It is the
+   * caller's responsibility to buffer chunks; typically by using a buffered
+   * sink with this sink.
+   */
+  private final class ChunkedSink implements Sink {
+    /** Scratch space for up to 16 hex digits, and then a constant CRLF. */
+    private final byte[] hex = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '\r', '\n' };
+
+    private boolean closed;
+
+    @Override public Sink deadline(Deadline deadline) {
+      return this; // TODO: honor deadline.
+    }
+
+    @Override public void write(OkBuffer source, long byteCount) throws IOException {
+      if (closed) throw new IllegalStateException("closed");
+      if (byteCount == 0) return;
+
+      writeHex(byteCount);
+      sink.write(source, byteCount);
+      sink.writeUtf8(CRLF);
+    }
+
+    @Override public synchronized void flush() throws IOException {
+      if (closed) return; // Don't throw; this stream might have been closed on the caller's behalf.
+      sink.flush();
+    }
+
+    @Override public synchronized void close() throws IOException {
+      if (closed) return;
+      closed = true;
+      sink.write(FINAL_CHUNK);
+      state = STATE_READ_RESPONSE_HEADERS;
+    }
+
+    /**
+     * Equivalent to, but cheaper than writing Long.toHexString().getBytes()
+     * followed by CRLF.
+     */
+    private void writeHex(long i) throws IOException {
+      int cursor = 16;
+      do {
+        hex[--cursor] = HEX_DIGITS[((int) (i & 0xf))];
+      } while ((i >>>= 4) != 0);
+      sink.write(hex, cursor, hex.length - cursor);
+    }
+  }
+
+  private class AbstractSource {
+    private final CacheRequest cacheRequest;
+    protected final OutputStream cacheBody;
+    protected boolean closed;
+
+    AbstractSource(CacheRequest cacheRequest) throws IOException {
+      // Some apps return a null body; for compatibility we treat that like a null cache request.
+      OutputStream cacheBody = cacheRequest != null ? cacheRequest.getBody() : null;
+      if (cacheBody == null) {
+        cacheRequest = null;
+      }
+
+      this.cacheBody = cacheBody;
+      this.cacheRequest = cacheRequest;
+    }
+
+    /** Copy the last {@code byteCount} bytes of {@code source} to the cache body. */
+    protected final void cacheWrite(OkBuffer source, long byteCount) throws IOException {
+      if (cacheBody != null) {
+        Okio.copy(source, source.size() - byteCount, byteCount, cacheBody);
+      }
+    }
+
+    /**
+     * Closes the cache entry and makes the socket available for reuse. This
+     * should be invoked when the end of the body has been reached.
+     */
+    protected final void endOfInput(boolean recyclable) throws IOException {
+      if (state != STATE_READING_RESPONSE_BODY) throw new IllegalStateException("state: " + state);
+
+      if (cacheRequest != null) {
+        cacheBody.close();
+      }
+
+      state = STATE_IDLE;
+      if (recyclable && onIdle == ON_IDLE_POOL) {
+        onIdle = ON_IDLE_HOLD; // Set the on idle policy back to the default.
+        pool.recycle(connection);
+      } else if (onIdle == ON_IDLE_CLOSE) {
+        state = STATE_CLOSED;
+        connection.close();
+      }
+    }
+
+    /**
+     * Calls abort on the cache entry and disconnects the socket. This
+     * should be invoked when the connection is closed unexpectedly to
+     * invalidate the cache entry and to prevent the HTTP connection from
+     * being reused. HTTP messages are sent in serial so whenever a message
+     * cannot be read to completion, subsequent messages cannot be read
+     * either and the connection must be discarded.
+     *
+     * <p>An earlier implementation skipped the remaining bytes, but this
+     * requires that the entire transfer be completed. If the intention was
+     * to cancel the transfer, closing the connection is the only solution.
+     */
+    protected final void unexpectedEndOfInput() {
+      if (cacheRequest != null) {
+        cacheRequest.abort();
+      }
+      Util.closeQuietly(connection);
+      state = STATE_CLOSED;
+    }
+  }
+
+  /** An HTTP body with a fixed length specified in advance. */
+  private class FixedLengthSource extends AbstractSource implements Source {
+    private long bytesRemaining;
+
+    public FixedLengthSource(CacheRequest cacheRequest, long length) throws IOException {
+      super(cacheRequest);
+      bytesRemaining = length;
+      if (bytesRemaining == 0) {
+        endOfInput(true);
+      }
+    }
+
+    @Override public long read(OkBuffer sink, long byteCount)
+        throws IOException {
+      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+      if (closed) throw new IllegalStateException("closed");
+      if (bytesRemaining == 0) return -1;
+
+      long read = source.read(sink, Math.min(bytesRemaining, byteCount));
+      if (read == -1) {
+        unexpectedEndOfInput(); // the server didn't supply the promised content length
+        throw new ProtocolException("unexpected end of stream");
+      }
+
+      bytesRemaining -= read;
+      cacheWrite(sink, read);
+      if (bytesRemaining == 0) {
+        endOfInput(true);
+      }
+      return read;
+    }
+
+    @Override public Source deadline(Deadline deadline) {
+      source.deadline(deadline);
+      return this;
+    }
+
+    @Override public void close() throws IOException {
+      if (closed) return;
+
+      if (bytesRemaining != 0 && !discard(this, DISCARD_STREAM_TIMEOUT_MILLIS)) {
+        unexpectedEndOfInput();
+      }
+
+      closed = true;
+    }
+  }
+
+  /** An HTTP body with alternating chunk sizes and chunk bodies. */
+  private class ChunkedSource extends AbstractSource implements Source {
+    private static final int NO_CHUNK_YET = -1;
+    private int bytesRemainingInChunk = NO_CHUNK_YET;
+    private boolean hasMoreChunks = true;
+    private final HttpEngine httpEngine;
+
+    ChunkedSource(CacheRequest cacheRequest, HttpEngine httpEngine) throws IOException {
+      super(cacheRequest);
+      this.httpEngine = httpEngine;
+    }
+
+    @Override public long read(
+        OkBuffer sink, long byteCount) throws IOException {
+      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+      if (closed) throw new IllegalStateException("closed");
+      if (!hasMoreChunks) return -1;
+
+      if (bytesRemainingInChunk == 0 || bytesRemainingInChunk == NO_CHUNK_YET) {
+        readChunkSize();
+        if (!hasMoreChunks) return -1;
+      }
+
+      long read = source.read(sink, Math.min(byteCount, bytesRemainingInChunk));
+      if (read == -1) {
+        unexpectedEndOfInput(); // the server didn't supply the promised chunk length
+        throw new IOException("unexpected end of stream");
+      }
+      bytesRemainingInChunk -= read;
+      cacheWrite(sink, read);
+      return read;
+    }
+
+    private void readChunkSize() throws IOException {
+      // read the suffix of the previous chunk
+      if (bytesRemainingInChunk != NO_CHUNK_YET) {
+        source.readUtf8LineStrict();
+      }
+      String chunkSizeString = source.readUtf8LineStrict();
+      int index = chunkSizeString.indexOf(";");
+      if (index != -1) {
+        chunkSizeString = chunkSizeString.substring(0, index);
+      }
+      try {
+        bytesRemainingInChunk = Integer.parseInt(chunkSizeString.trim(), 16);
+      } catch (NumberFormatException e) {
+        throw new ProtocolException("Expected a hex chunk size but was " + chunkSizeString);
+      }
+      if (bytesRemainingInChunk == 0) {
+        hasMoreChunks = false;
+        Headers.Builder trailersBuilder = new Headers.Builder();
+        readHeaders(trailersBuilder);
+        httpEngine.receiveHeaders(trailersBuilder.build());
+        endOfInput(true);
+      }
+    }
+
+    @Override public Source deadline(Deadline deadline) {
+      source.deadline(deadline);
+      return this;
+    }
+
+    @Override public void close() throws IOException {
+      if (closed) return;
+      if (hasMoreChunks && !discard(this, DISCARD_STREAM_TIMEOUT_MILLIS)) {
+        unexpectedEndOfInput();
+      }
+      closed = true;
+    }
+  }
+
+  /** An HTTP message body terminated by the end of the underlying stream. */
+  class UnknownLengthSource extends AbstractSource implements Source {
+    private boolean inputExhausted;
+
+    UnknownLengthSource(CacheRequest cacheRequest) throws IOException {
+      super(cacheRequest);
+    }
+
+    @Override public long read(OkBuffer sink, long byteCount)
+        throws IOException {
+      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+      if (closed) throw new IllegalStateException("closed");
+      if (inputExhausted) return -1;
+
+      long read = source.read(sink, byteCount);
+      if (read == -1) {
+        inputExhausted = true;
+        endOfInput(false);
+        return -1;
+      }
+      cacheWrite(sink, read);
+      return read;
+    }
+
+    @Override public Source deadline(Deadline deadline) {
+      source.deadline(deadline);
+      return this;
+    }
+
+    @Override public void close() throws IOException {
+      if (closed) return;
+      // TODO: discard unknown length streams for best caching?
+      if (!inputExhausted) {
+        unexpectedEndOfInput();
+      }
+      closed = true;
+    }
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java
index bc8407e572..cdb697318b 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpDate.java
@@ -45,13 +45,21 @@
   private static final String[] BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS = new String[] {
       "EEEE, dd-MMM-yy HH:mm:ss zzz", // RFC 1036
       "EEE MMM d HH:mm:ss yyyy", // ANSI C asctime()
-      "EEE, dd-MMM-yyyy HH:mm:ss z", "EEE, dd-MMM-yyyy HH-mm-ss z", "EEE, dd MMM yy HH:mm:ss z",
-      "EEE dd-MMM-yyyy HH:mm:ss z", "EEE dd MMM yyyy HH:mm:ss z", "EEE dd-MMM-yyyy HH-mm-ss z",
-      "EEE dd-MMM-yy HH:mm:ss z", "EEE dd MMM yy HH:mm:ss z", "EEE,dd-MMM-yy HH:mm:ss z",
-      "EEE,dd-MMM-yyyy HH:mm:ss z", "EEE, dd-MM-yyyy HH:mm:ss z",
+      "EEE, dd-MMM-yyyy HH:mm:ss z",
+      "EEE, dd-MMM-yyyy HH-mm-ss z",
+      "EEE, dd MMM yy HH:mm:ss z",
+      "EEE dd-MMM-yyyy HH:mm:ss z",
+      "EEE dd MMM yyyy HH:mm:ss z",
+      "EEE dd-MMM-yyyy HH-mm-ss z",
+      "EEE dd-MMM-yy HH:mm:ss z",
+      "EEE dd MMM yy HH:mm:ss z",
+      "EEE,dd-MMM-yy HH:mm:ss z",
+      "EEE,dd-MMM-yyyy HH:mm:ss z",
+      "EEE, dd-MM-yyyy HH:mm:ss z",
 
-            /* RI bug 6641315 claims a cookie of this format was once served by www.yahoo.com */
-      "EEE MMM d yyyy HH:mm:ss z", };
+      /* RI bug 6641315 claims a cookie of this format was once served by www.yahoo.com */
+      "EEE MMM d yyyy HH:mm:ss z",
+  };
 
   private static final DateFormat[] BROWSER_COMPATIBLE_DATE_FORMATS =
       new DateFormat[BROWSER_COMPATIBLE_DATE_FORMAT_STRINGS.length];
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
index e07de7fa78..1ce0f44c6d 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpEngine.java
@@ -30,7 +30,6 @@
 import com.squareup.okhttp.internal.Dns;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.OutputStream;
 import java.net.CacheRequest;
 import java.net.CookieHandler;
 import java.net.ProtocolException;
@@ -39,10 +38,14 @@
 import java.security.cert.CertificateException;
 import java.util.List;
 import java.util.Map;
-import java.util.zip.GZIPInputStream;
 import javax.net.ssl.HostnameVerifier;
 import javax.net.ssl.SSLHandshakeException;
 import javax.net.ssl.SSLSocketFactory;
+import okio.BufferedSink;
+import okio.GzipSource;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
 
 import static com.squareup.okhttp.internal.Util.closeQuietly;
 import static com.squareup.okhttp.internal.Util.getDefaultPort;
@@ -68,11 +71,6 @@
  *
  * <p>The request and response may be served by the HTTP response cache, by the
  * network, or by both in the event of a conditional GET.
- *
- * <p>This class may hold a socket connection that needs to be released or
- * recycled. By default, this socket connection is held when the last byte of
- * the response is consumed. To release the connection when it is no longer
- * required, use {@link #automaticallyReleaseConnectionToPool()}.
  */
 public class HttpEngine {
   final OkHttpClient client;
@@ -100,15 +98,18 @@
    */
   public final boolean bufferRequestBody;
 
+  private Request originalRequest;
   private Request request;
-  private OutputStream requestBodyOut;
+  private Sink requestBodyOut;
+  private BufferedSink bufferedRequestBody;
 
   private ResponseSource responseSource;
 
   /** Null until a response is received from the network or the cache. */
   private Response response;
-  private InputStream responseTransferIn;
-  private InputStream responseBodyIn;
+  private Source responseTransferSource;
+  private Source responseBody;
+  private InputStream responseBodyBytes;
 
   /**
    * The cache response currently being validated on a conditional get. Null
@@ -121,15 +122,6 @@
   /** The cache request currently being populated from a network response. */
   private CacheRequest cacheRequest;
 
-  /**
-   * True if the socket connection should be released to the connection pool
-   * when the response has been fully read.
-   */
-  private boolean automaticallyReleaseConnectionToPool;
-
-  /** True if the socket connection is no longer needed by this engine. */
-  private boolean connectionReleased;
-
   /**
    * @param request the HTTP request without a body. The body must be
    *     written via the engine's request body stream.
@@ -142,8 +134,9 @@
    *     recover from a failure.
    */
   public HttpEngine(OkHttpClient client, Request request, boolean bufferRequestBody,
-      Connection connection, RouteSelector routeSelector, RetryableOutputStream requestBodyOut) {
+      Connection connection, RouteSelector routeSelector, RetryableSink requestBodyOut) {
     this.client = client;
+    this.originalRequest = request;
     this.request = request;
     this.bufferRequestBody = bufferRequestBody;
     this.connection = connection;
@@ -199,15 +192,16 @@ public final void sendRequest() throws IOException {
       }
 
     } else {
-      // We're using a cached response. Close the connection we may have inherited from a redirect.
+      // We're using a cached response. Recycle a connection we may have inherited from a redirect.
       if (connection != null) {
-        disconnect();
+        client.getConnectionPool().recycle(connection);
+        connection = null;
       }
 
       // No need for the network! Promote the cached response immediately.
       this.response = validatingResponse;
       if (validatingResponse.body() != null) {
-        initContentStream(validatingResponse.body().byteStream());
+        initContentStream(validatingResponse.body().source());
       }
     }
   }
@@ -243,7 +237,7 @@ private void connect() throws IOException {
 
     if (!connection.isConnected()) {
       connection.connect(client.getConnectTimeout(), client.getReadTimeout(), getTunnelConfig());
-      client.getConnectionPool().maybeShare(connection);
+      if (connection.isSpdy()) client.getConnectionPool().share(connection);
       client.getRoutesDatabase().connected(connection.getRoute());
     } else if (!connection.isSpdy()) {
       connection.updateReadTimeout(client.getReadTimeout());
@@ -252,15 +246,6 @@ private void connect() throws IOException {
     route = connection.getRoute();
   }
 
-  /**
-   * Recycle the connection to the origin server. It is an error to call this
-   * with a request in flight.
-   */
-  private void disconnect() {
-    client.getConnectionPool().recycle(connection);
-    connection = null;
-  }
-
   /**
    * Called immediately before the transport transmits HTTP request headers.
    * This is used to observe the sent time should the request be cached.
@@ -271,20 +256,32 @@ public void writingRequestHeaders() {
   }
 
   boolean hasRequestBody() {
-    String method = request.method();
-    return method.equals("POST") || method.equals("PUT") || method.equals("PATCH");
+    return HttpMethod.hasRequestBody(request.method());
   }
 
   /** Returns the request body or null if this request doesn't have a body. */
-  public final OutputStream getRequestBody() {
+  public final Sink getRequestBody() {
     if (responseSource == null) throw new IllegalStateException();
     return requestBodyOut;
   }
 
+  public final BufferedSink getBufferedRequestBody() {
+    BufferedSink result = bufferedRequestBody;
+    if (result != null) return result;
+    Sink requestBody = getRequestBody();
+    return requestBody != null
+        ? (bufferedRequestBody = Okio.buffer(requestBody))
+        : null;
+  }
+
   public final boolean hasResponse() {
     return response != null;
   }
 
+  public final ResponseSource responseSource() {
+    return responseSource;
+  }
+
   public final Request getRequest() {
     return request;
   }
@@ -296,9 +293,16 @@ public final Response getResponse() {
     return response;
   }
 
-  public final InputStream getResponseBody() {
+  public final Source getResponseBody() {
     if (response == null) throw new IllegalStateException();
-    return responseBodyIn;
+    return responseBody;
+  }
+
+  public final InputStream getResponseBodyBytes() {
+    InputStream result = responseBodyBytes;
+    return result != null
+        ? result
+        : (responseBodyBytes = Okio.buffer(getResponseBody()).inputStream());
   }
 
   public final Connection getConnection() {
@@ -315,8 +319,7 @@ public HttpEngine recover(IOException e) {
       routeSelector.connectFailed(connection, e);
     }
 
-    boolean canRetryRequestBody = requestBodyOut == null
-        || requestBodyOut instanceof RetryableOutputStream;
+    boolean canRetryRequestBody = requestBodyOut == null || requestBodyOut instanceof RetryableSink;
     if (routeSelector == null && connection == null // No connection.
         || routeSelector != null && !routeSelector.hasNext() // No more routes to attempt.
         || !isRecoverable(e)
@@ -324,11 +327,11 @@ public HttpEngine recover(IOException e) {
       return null;
     }
 
-    release(true);
+    Connection connection = close();
 
     // For failure recovery, use the same route selector with a new connection.
-    return new HttpEngine(client, request, bufferRequestBody, null, routeSelector,
-        (RetryableOutputStream) requestBodyOut);
+    return new HttpEngine(client, originalRequest, bufferRequestBody, connection, routeSelector,
+        (RetryableSink) requestBodyOut);
   }
 
   private boolean isRecoverable(IOException e) {
@@ -363,48 +366,58 @@ private void maybeCache() throws IOException {
   }
 
   /**
-   * Cause the socket connection to be released to the connection pool when
-   * it is no longer needed. If it is already unneeded, it will be pooled
-   * immediately. Otherwise the connection is held so that redirects can be
-   * handled by the same connection.
+   * Configure the socket connection to be either pooled or closed when it is
+   * either exhausted or closed. If it is unneeded when this is called, it will
+   * be released immediately.
    */
-  public final void automaticallyReleaseConnectionToPool() {
-    automaticallyReleaseConnectionToPool = true;
-    if (connection != null && connectionReleased) {
-      disconnect();
+  public final void releaseConnection() throws IOException {
+    if (transport != null && connection != null) {
+      transport.releaseConnectionOnIdle();
     }
+    connection = null;
   }
 
   /**
-   * Releases this engine so that its resources may be either reused or
-   * closed. Also call {@link #automaticallyReleaseConnectionToPool} unless
-   * the connection will be used to follow a redirect.
+   * Release any resources held by this engine. If a connection is still held by
+   * this engine, it is returned.
    */
-  public final void release(boolean streamCanceled) {
-    // If the response body comes from the cache, close it.
-    if (validatingResponse != null
-        && validatingResponse.body() != null
-        && responseBodyIn == validatingResponse.body().byteStream()) {
-      closeQuietly(responseBodyIn);
+  public final Connection close() {
+    if (bufferedRequestBody != null) {
+      // This also closes the wrapped requestBodyOut.
+      closeQuietly(bufferedRequestBody);
+    } else if (requestBodyOut != null) {
+      closeQuietly(requestBodyOut);
     }
 
-    if (connection != null && !connectionReleased) {
-      connectionReleased = true;
+    // If this engine never achieved a response body, its connection cannot be reused.
+    if (responseBody == null) {
+      closeQuietly(connection);
+      connection = null;
+      return null;
+    }
 
-      if (transport == null
-          || !transport.makeReusable(streamCanceled, requestBodyOut, responseTransferIn)) {
-        closeQuietly(connection);
-        connection = null;
-      } else if (automaticallyReleaseConnectionToPool) {
-        disconnect();
-      }
+    // Close the response body. This will recycle the connection if it is eligible.
+    closeQuietly(responseBody);
+
+    // Clear the buffer held by the response body input stream adapter.
+    closeQuietly(responseBodyBytes);
+
+    // Close the connection if it cannot be reused.
+    if (transport != null && !transport.canReuseConnection()) {
+      closeQuietly(connection);
+      connection = null;
+      return null;
     }
+
+    Connection result = connection;
+    connection = null;
+    return result;
   }
 
   /**
-   * Initialize the response content stream from the response transfer stream.
-   * These two streams are the same unless we're doing transparent gzip, in
-   * which case the content stream is decompressed.
+   * Initialize the response content stream from the response transfer source.
+   * These two sources are the same unless we're doing transparent gzip, in
+   * which case the content source is decompressed.
    *
    * <p>Whenever we do transparent gzip we also strip the corresponding headers.
    * We strip the Content-Encoding header to prevent the application from
@@ -415,18 +428,18 @@ public final void release(boolean streamCanceled) {
    * <p>This method should only be used for non-empty response bodies. Response
    * codes like "304 Not Modified" can include "Content-Encoding: gzip" without
    * a response body and we will crash if we attempt to decompress the zero-byte
-   * stream.
+   * source.
    */
-  private void initContentStream(InputStream transferStream) throws IOException {
-    responseTransferIn = transferStream;
+  private void initContentStream(Source transferSource) throws IOException {
+    responseTransferSource = transferSource;
     if (transparentGzip && "gzip".equalsIgnoreCase(response.header("Content-Encoding"))) {
       response = response.newBuilder()
           .removeHeader("Content-Encoding")
           .removeHeader("Content-Length")
           .build();
-      responseBodyIn = new GZIPInputStream(transferStream);
+      responseBody = new GzipSource(transferSource);
     } else {
-      responseBodyIn = transferStream;
+      responseBody = transferSource;
     }
   }
 
@@ -491,8 +504,14 @@ private void prepareRawRequestHeaders() throws IOException {
 
     CookieHandler cookieHandler = client.getCookieHandler();
     if (cookieHandler != null) {
-      Map<String, List<String>> cookies = cookieHandler.get(
-          request.uri(), OkHeaders.toMultimap(request.getHeaders(), null));
+      // Capture the request headers added so far so that they can be offered to the CookieHandler.
+      // This is mostly to stay close to the RI; it is unlikely any of the headers above would
+      // affect cookie choice besides "Host".
+      Map<String, List<String>> headers = OkHeaders.toMultimap(result.build().headers(), null);
+
+      Map<String, List<String>> cookies = cookieHandler.get(request.uri(), headers);
+
+      // Add any new cookies to the request.
       OkHeaders.addCookies(result, cookies);
     }
 
@@ -519,11 +538,15 @@ public final void readResponse() throws IOException {
     if (responseSource == null) throw new IllegalStateException("call sendRequest() first!");
     if (!responseSource.requiresConnection()) return;
 
+    // Flush the request body if there's data outstanding.
+    if (bufferedRequestBody != null && bufferedRequestBody.buffer().size() > 0) {
+      bufferedRequestBody.flush();
+    }
+
     if (sentRequestMillis == -1) {
-      if (OkHeaders.contentLength(request) == -1
-          && requestBodyOut instanceof RetryableOutputStream) {
+      if (OkHeaders.contentLength(request) == -1 && requestBodyOut instanceof RetryableSink) {
         // We might not learn the Content-Length until the request body has been buffered.
-        long contentLength = ((RetryableOutputStream) requestBodyOut).contentLength();
+        long contentLength = ((RetryableSink) requestBodyOut).contentLength();
         request = request.newBuilder()
             .header("Content-Length", Long.toString(contentLength))
             .build();
@@ -532,9 +555,14 @@ public final void readResponse() throws IOException {
     }
 
     if (requestBodyOut != null) {
-      requestBodyOut.close();
-      if (requestBodyOut instanceof RetryableOutputStream) {
-        transport.writeRequestBody((RetryableOutputStream) requestBodyOut);
+      if (bufferedRequestBody != null) {
+        // This also closes the wrapped requestBodyOut.
+        bufferedRequestBody.close();
+      } else {
+        requestBodyOut.close();
+      }
+      if (requestBodyOut instanceof RetryableSink) {
+        transport.writeRequestBody((RetryableSink) requestBodyOut);
       }
     }
 
@@ -552,7 +580,8 @@ public final void readResponse() throws IOException {
 
     if (responseSource == ResponseSource.CONDITIONAL_CACHE) {
       if (validatingResponse.validate(response)) {
-        release(false);
+        transport.emptyTransferStream();
+        releaseConnection();
         response = combine(validatingResponse, response);
 
         // Update the cache after combining headers but before stripping the
@@ -562,7 +591,7 @@ public final void readResponse() throws IOException {
         responseCache.update(validatingResponse, cacheableResponse());
 
         if (validatingResponse.body() != null) {
-          initContentStream(validatingResponse.body().byteStream());
+          initContentStream(validatingResponse.body().source());
         }
         return;
       } else {
@@ -572,8 +601,8 @@ public final void readResponse() throws IOException {
 
     if (!hasResponseBody()) {
       // Don't call initContentStream() when the response doesn't have any content.
-      responseTransferIn = transport.getTransferStream(cacheRequest);
-      responseBodyIn = responseTransferIn;
+      responseTransferSource = transport.getTransferStream(cacheRequest);
+      responseBody = responseTransferSource;
       return;
     }
 
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java
new file mode 100644
index 0000000000..1577d1018d
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpMethod.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import java.util.Arrays;
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+public final class HttpMethod {
+  public static final Set<String> METHODS = new LinkedHashSet<String>(Arrays.asList(
+      "OPTIONS", "GET", "HEAD", "POST", "PUT", "DELETE", "TRACE", "PATCH"));
+
+  public static boolean invalidatesCache(String method) {
+    return method.equals("POST")
+        || method.equals("PATCH")
+        || method.equals("PUT")
+        || method.equals("DELETE");
+  }
+
+  public static boolean hasRequestBody(String method) {
+    return method.equals("POST")
+        || method.equals("PUT")
+        || method.equals("PATCH")
+        || method.equals("DELETE"); // Permitted as spec is ambiguous.
+  }
+
+  private HttpMethod() {
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
index caf512858a..a1b367f474 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpTransport.java
@@ -16,47 +16,23 @@
 
 package com.squareup.okhttp.internal.http;
 
-import com.squareup.okhttp.Connection;
-import com.squareup.okhttp.Headers;
-import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.AbstractOutputStream;
-import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayOutputStream;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
 import java.net.CacheRequest;
-import java.net.ProtocolException;
-import java.net.Socket;
-
-import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
-import static com.squareup.okhttp.internal.http.StatusLine.HTTP_CONTINUE;
+import okio.Sink;
+import okio.Source;
 
 public final class HttpTransport implements Transport {
-  public static final int DEFAULT_CHUNK_LENGTH = 1024;
-
   private final HttpEngine httpEngine;
-  private final InputStream socketIn;
-  private final OutputStream socketOut;
+  private final HttpConnection httpConnection;
 
-  /**
-   * This stream buffers the request headers and the request body when their
-   * combined size is less than MAX_REQUEST_BUFFER_LENGTH. By combining them
-   * we can save socket writes, which in turn saves a packet transmission.
-   * This is socketOut if the request size is large or unknown.
-   */
-  private OutputStream requestOut;
-
-  public HttpTransport(HttpEngine httpEngine, OutputStream outputStream, InputStream inputStream) {
+  public HttpTransport(HttpEngine httpEngine, HttpConnection httpConnection) {
     this.httpEngine = httpEngine;
-    this.socketOut = outputStream;
-    this.requestOut = outputStream;
-    this.socketIn = inputStream;
+    this.httpConnection = httpConnection;
   }
 
-  @Override public OutputStream createRequestBody(Request request) throws IOException {
+  @Override public Sink createRequestBody(Request request) throws IOException {
     long contentLength = OkHeaders.contentLength(request);
 
     if (httpEngine.bufferRequestBody) {
@@ -68,25 +44,25 @@ public HttpTransport(HttpEngine httpEngine, OutputStream outputStream, InputStre
       if (contentLength != -1) {
         // Buffer a request body of a known length.
         writeRequestHeaders(request);
-        return new RetryableOutputStream((int) contentLength);
+        return new RetryableSink((int) contentLength);
       } else {
         // Buffer a request body of an unknown length. Don't write request
         // headers until the entire body is ready; otherwise we can't set the
         // Content-Length header correctly.
-        return new RetryableOutputStream();
+        return new RetryableSink();
       }
     }
 
     if ("chunked".equalsIgnoreCase(request.header("Transfer-Encoding"))) {
       // Stream a request body of unknown length.
       writeRequestHeaders(request);
-      return new ChunkedOutputStream(requestOut, DEFAULT_CHUNK_LENGTH);
+      return httpConnection.newChunkedSink();
     }
 
     if (contentLength != -1) {
       // Stream a request body of a known length.
       writeRequestHeaders(request);
-      return new FixedLengthOutputStream(requestOut, contentLength);
+      return httpConnection.newFixedLengthSink(contentLength);
     }
 
     throw new IllegalStateException(
@@ -94,12 +70,11 @@ public HttpTransport(HttpEngine httpEngine, OutputStream outputStream, InputStre
   }
 
   @Override public void flushRequest() throws IOException {
-    requestOut.flush();
-    requestOut = socketOut;
+    httpConnection.flush();
   }
 
-  @Override public void writeRequestBody(RetryableOutputStream requestBody) throws IOException {
-    requestBody.writeToSocket(requestOut);
+  @Override public void writeRequestBody(RetryableSink requestBody) throws IOException {
+    httpConnection.writeRequestBody(requestBody);
   }
 
   /**
@@ -119,397 +94,60 @@ public void writeRequestHeaders(Request request) throws IOException {
     String requestLine = RequestLine.get(request,
         httpEngine.getConnection().getRoute().getProxy().type(),
         httpEngine.getConnection().getHttpMinorVersion());
-    writeRequest(requestOut, request.getHeaders(), requestLine);
+    httpConnection.writeRequest(request.getHeaders(), requestLine);
   }
 
   @Override public Response.Builder readResponseHeaders() throws IOException {
-    return readResponse(socketIn);
-  }
-
-  /** Returns bytes of a request header for sending on an HTTP transport. */
-  public static void writeRequest(OutputStream out, Headers headers, String requestLine)
-      throws IOException {
-    StringBuilder result = new StringBuilder(256);
-    result.append(requestLine).append("\r\n");
-    for (int i = 0; i < headers.size(); i ++) {
-      result.append(headers.name(i))
-          .append(": ")
-          .append(headers.value(i))
-          .append("\r\n");
-    }
-    result.append("\r\n");
-    out.write(result.toString().getBytes("ISO-8859-1"));
+    return httpConnection.readResponse();
   }
 
-  /** Parses bytes of a response header from an HTTP transport. */
-  public static Response.Builder readResponse(InputStream in) throws IOException {
-    while (true) {
-      String statusLineString = Util.readAsciiLine(in);
-      StatusLine statusLine = new StatusLine(statusLineString);
-
-      Response.Builder responseBuilder = new Response.Builder()
-          .statusLine(statusLine)
-          .header(OkHeaders.SELECTED_TRANSPORT, Protocol.HTTP_11.name.utf8())
-          .header(OkHeaders.SELECTED_PROTOCOL, Protocol.HTTP_11.name.utf8());
-
-      Headers.Builder headersBuilder = new Headers.Builder();
-      OkHeaders.readHeaders(headersBuilder, in);
-      responseBuilder.headers(headersBuilder.build());
-
-      if (statusLine.code() != HTTP_CONTINUE) return responseBuilder;
+  @Override public void releaseConnectionOnIdle() throws IOException {
+    if (canReuseConnection()) {
+      httpConnection.poolOnIdle();
+    } else {
+      httpConnection.closeOnIdle();
     }
   }
 
-  public boolean makeReusable(boolean streamCanceled, OutputStream requestBodyOut,
-      InputStream responseBodyIn) {
-    if (streamCanceled) {
-      return false;
-    }
-
-    // We cannot reuse sockets that have incomplete output.
-    if (requestBodyOut != null && !((AbstractOutputStream) requestBodyOut).isClosed()) {
-      return false;
-    }
-
+  @Override public boolean canReuseConnection() {
     // If the request specified that the connection shouldn't be reused, don't reuse it.
     if ("close".equalsIgnoreCase(httpEngine.getRequest().header("Connection"))) {
       return false;
     }
 
     // If the response specified that the connection shouldn't be reused, don't reuse it.
-    if (httpEngine.getResponse() != null
-        && "close".equalsIgnoreCase(httpEngine.getResponse().header("Connection"))) {
+    if ("close".equalsIgnoreCase(httpEngine.getResponse().header("Connection"))) {
       return false;
     }
 
-    if (responseBodyIn instanceof UnknownLengthHttpInputStream) {
+    if (httpConnection.isClosed()) {
       return false;
     }
 
-    if (responseBodyIn != null) {
-      return discardStream(httpEngine, responseBodyIn);
-    }
-
     return true;
   }
 
-  /**
-   * Discards the response body so that the connection can be reused. This
-   * needs to be done judiciously, since it delays the current request in
-   * order to speed up a potential future request that may never occur.
-   *
-   * <p>A stream may be discarded to encourage response caching (a response
-   * cannot be cached unless it is consumed completely) or to enable connection
-   * reuse.
-   */
-  private static boolean discardStream(HttpEngine httpEngine, InputStream responseBodyIn) {
-    Connection connection = httpEngine.getConnection();
-    if (connection == null) return false;
-    Socket socket = connection.getSocket();
-    if (socket == null) return false;
-    try {
-      int socketTimeout = socket.getSoTimeout();
-      socket.setSoTimeout(DISCARD_STREAM_TIMEOUT_MILLIS);
-      try {
-        Util.skipByReading(responseBodyIn, Long.MAX_VALUE, DISCARD_STREAM_TIMEOUT_MILLIS);
-        return true;
-      } finally {
-        socket.setSoTimeout(socketTimeout);
-      }
-    } catch (IOException e) {
-      return false;
-    }
+  @Override public void emptyTransferStream() throws IOException {
+    httpConnection.emptyResponseBody();
   }
 
-  @Override public InputStream getTransferStream(CacheRequest cacheRequest) throws IOException {
+  @Override public Source getTransferStream(CacheRequest cacheRequest) throws IOException {
     if (!httpEngine.hasResponseBody()) {
-      return new FixedLengthInputStream(socketIn, cacheRequest, httpEngine, 0);
+      return httpConnection.newFixedLengthSource(cacheRequest, 0);
     }
 
     if ("chunked".equalsIgnoreCase(httpEngine.getResponse().header("Transfer-Encoding"))) {
-      return new ChunkedInputStream(socketIn, cacheRequest, this);
+      return httpConnection.newChunkedSource(cacheRequest, httpEngine);
     }
 
     long contentLength = OkHeaders.contentLength(httpEngine.getResponse());
     if (contentLength != -1) {
-      return new FixedLengthInputStream(socketIn, cacheRequest, httpEngine, contentLength);
+      return httpConnection.newFixedLengthSource(cacheRequest, contentLength);
     }
 
     // Wrap the input stream from the connection (rather than just returning
     // "socketIn" directly here), so that we can control its use after the
     // reference escapes.
-    return new UnknownLengthHttpInputStream(socketIn, cacheRequest, httpEngine);
-  }
-
-  /** An HTTP body with a fixed length known in advance. */
-  private static final class FixedLengthOutputStream extends AbstractOutputStream {
-    private final OutputStream socketOut;
-    private long bytesRemaining;
-
-    private FixedLengthOutputStream(OutputStream socketOut, long bytesRemaining) {
-      this.socketOut = socketOut;
-      this.bytesRemaining = bytesRemaining;
-    }
-
-    @Override public void write(byte[] buffer, int offset, int count) throws IOException {
-      checkNotClosed();
-      checkOffsetAndCount(buffer.length, offset, count);
-      if (count > bytesRemaining) {
-        throw new ProtocolException("expected " + bytesRemaining + " bytes but received " + count);
-      }
-      socketOut.write(buffer, offset, count);
-      bytesRemaining -= count;
-    }
-
-    @Override public void flush() throws IOException {
-      if (closed) {
-        return; // don't throw; this stream might have been closed on the caller's behalf
-      }
-      socketOut.flush();
-    }
-
-    @Override public void close() throws IOException {
-      if (closed) {
-        return;
-      }
-      closed = true;
-      if (bytesRemaining > 0) {
-        throw new ProtocolException("unexpected end of stream");
-      }
-    }
-  }
-
-  /**
-   * An HTTP body with alternating chunk sizes and chunk bodies. Chunks are
-   * buffered until {@code maxChunkLength} bytes are ready, at which point the
-   * chunk is written and the buffer is cleared.
-   */
-  private static final class ChunkedOutputStream extends AbstractOutputStream {
-    private static final byte[] CRLF = { '\r', '\n' };
-    private static final byte[] HEX_DIGITS = {
-        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
-    };
-    private static final byte[] FINAL_CHUNK = new byte[] { '0', '\r', '\n', '\r', '\n' };
-
-    /** Scratch space for up to 8 hex digits, and then a constant CRLF. */
-    private final byte[] hex = { 0, 0, 0, 0, 0, 0, 0, 0, '\r', '\n' };
-
-    private final OutputStream socketOut;
-    private final int maxChunkLength;
-    private final ByteArrayOutputStream bufferedChunk;
-
-    private ChunkedOutputStream(OutputStream socketOut, int maxChunkLength) {
-      this.socketOut = socketOut;
-      this.maxChunkLength = Math.max(1, dataLength(maxChunkLength));
-      this.bufferedChunk = new ByteArrayOutputStream(maxChunkLength);
-    }
-
-    /**
-     * Returns the amount of data that can be transmitted in a chunk whose total
-     * length (data+headers) is {@code dataPlusHeaderLength}. This is presumably
-     * useful to match sizes with wire-protocol packets.
-     */
-    private int dataLength(int dataPlusHeaderLength) {
-      int headerLength = 4; // "\r\n" after the size plus another "\r\n" after the data
-      for (int i = dataPlusHeaderLength - headerLength; i > 0; i >>= 4) {
-        headerLength++;
-      }
-      return dataPlusHeaderLength - headerLength;
-    }
-
-    @Override public synchronized void write(byte[] buffer, int offset, int count)
-        throws IOException {
-      checkNotClosed();
-      checkOffsetAndCount(buffer.length, offset, count);
-
-      while (count > 0) {
-        int numBytesWritten;
-
-        if (bufferedChunk.size() > 0 || count < maxChunkLength) {
-          // fill the buffered chunk and then maybe write that to the stream
-          numBytesWritten = Math.min(count, maxChunkLength - bufferedChunk.size());
-          // TODO: skip unnecessary copies from buffer->bufferedChunk?
-          bufferedChunk.write(buffer, offset, numBytesWritten);
-          if (bufferedChunk.size() == maxChunkLength) {
-            writeBufferedChunkToSocket();
-          }
-        } else {
-          // write a single chunk of size maxChunkLength to the stream
-          numBytesWritten = maxChunkLength;
-          writeHex(numBytesWritten);
-          socketOut.write(buffer, offset, numBytesWritten);
-          socketOut.write(CRLF);
-        }
-
-        offset += numBytesWritten;
-        count -= numBytesWritten;
-      }
-    }
-
-    /**
-     * Equivalent to, but cheaper than writing Integer.toHexString().getBytes()
-     * followed by CRLF.
-     */
-    private void writeHex(int i) throws IOException {
-      int cursor = 8;
-      do {
-        hex[--cursor] = HEX_DIGITS[i & 0xf];
-      } while ((i >>>= 4) != 0);
-      socketOut.write(hex, cursor, hex.length - cursor);
-    }
-
-    @Override public synchronized void flush() throws IOException {
-      if (closed) {
-        return; // don't throw; this stream might have been closed on the caller's behalf
-      }
-      writeBufferedChunkToSocket();
-      socketOut.flush();
-    }
-
-    @Override public synchronized void close() throws IOException {
-      if (closed) {
-        return;
-      }
-      closed = true;
-      writeBufferedChunkToSocket();
-      socketOut.write(FINAL_CHUNK);
-    }
-
-    private void writeBufferedChunkToSocket() throws IOException {
-      int size = bufferedChunk.size();
-      if (size <= 0) {
-        return;
-      }
-
-      writeHex(size);
-      bufferedChunk.writeTo(socketOut);
-      bufferedChunk.reset();
-      socketOut.write(CRLF);
-    }
-  }
-
-  /** An HTTP body with a fixed length specified in advance. */
-  private static class FixedLengthInputStream extends AbstractHttpInputStream {
-    private long bytesRemaining;
-
-    public FixedLengthInputStream(InputStream is, CacheRequest cacheRequest, HttpEngine httpEngine,
-        long length) throws IOException {
-      super(is, httpEngine, cacheRequest);
-      bytesRemaining = length;
-      if (bytesRemaining == 0) {
-        endOfInput();
-      }
-    }
-
-    @Override public int read(byte[] buffer, int offset, int count) throws IOException {
-      checkOffsetAndCount(buffer.length, offset, count);
-      checkNotClosed();
-      if (bytesRemaining == 0) {
-        return -1;
-      }
-      int read = in.read(buffer, offset, (int) Math.min(count, bytesRemaining));
-      if (read == -1) {
-        unexpectedEndOfInput(); // the server didn't supply the promised content length
-        throw new ProtocolException("unexpected end of stream");
-      }
-      bytesRemaining -= read;
-      cacheWrite(buffer, offset, read);
-      if (bytesRemaining == 0) {
-        endOfInput();
-      }
-      return read;
-    }
-
-    @Override public int available() throws IOException {
-      checkNotClosed();
-      return bytesRemaining == 0 ? 0 : (int) Math.min(in.available(), bytesRemaining);
-    }
-
-    @Override public void close() throws IOException {
-      if (closed) {
-        return;
-      }
-      if (bytesRemaining != 0 && !discardStream(httpEngine, this)) {
-        unexpectedEndOfInput();
-      }
-      closed = true;
-    }
-  }
-
-  /** An HTTP body with alternating chunk sizes and chunk bodies. */
-  private static class ChunkedInputStream extends AbstractHttpInputStream {
-    private static final int NO_CHUNK_YET = -1;
-    private int bytesRemainingInChunk = NO_CHUNK_YET;
-    private boolean hasMoreChunks = true;
-
-    ChunkedInputStream(InputStream is, CacheRequest cacheRequest, HttpTransport transport)
-        throws IOException {
-      super(is, transport.httpEngine, cacheRequest);
-    }
-
-    @Override public int read(byte[] buffer, int offset, int count) throws IOException {
-      checkOffsetAndCount(buffer.length, offset, count);
-      checkNotClosed();
-
-      if (!hasMoreChunks) {
-        return -1;
-      }
-      if (bytesRemainingInChunk == 0 || bytesRemainingInChunk == NO_CHUNK_YET) {
-        readChunkSize();
-        if (!hasMoreChunks) {
-          return -1;
-        }
-      }
-      int read = in.read(buffer, offset, Math.min(count, bytesRemainingInChunk));
-      if (read == -1) {
-        unexpectedEndOfInput(); // the server didn't supply the promised chunk length
-        throw new IOException("unexpected end of stream");
-      }
-      bytesRemainingInChunk -= read;
-      cacheWrite(buffer, offset, read);
-      return read;
-    }
-
-    private void readChunkSize() throws IOException {
-      // read the suffix of the previous chunk
-      if (bytesRemainingInChunk != NO_CHUNK_YET) {
-        Util.readAsciiLine(in);
-      }
-      String chunkSizeString = Util.readAsciiLine(in);
-      int index = chunkSizeString.indexOf(";");
-      if (index != -1) {
-        chunkSizeString = chunkSizeString.substring(0, index);
-      }
-      try {
-        bytesRemainingInChunk = Integer.parseInt(chunkSizeString.trim(), 16);
-      } catch (NumberFormatException e) {
-        throw new ProtocolException("Expected a hex chunk size but was " + chunkSizeString);
-      }
-      if (bytesRemainingInChunk == 0) {
-        hasMoreChunks = false;
-        Headers.Builder trailersBuilder = new Headers.Builder();
-        OkHeaders.readHeaders(trailersBuilder, in);
-        httpEngine.receiveHeaders(trailersBuilder.build());
-        endOfInput();
-      }
-    }
-
-    @Override public int available() throws IOException {
-      checkNotClosed();
-      if (!hasMoreChunks || bytesRemainingInChunk == NO_CHUNK_YET) {
-        return 0;
-      }
-      return Math.min(in.available(), bytesRemainingInChunk);
-    }
-
-    @Override public void close() throws IOException {
-      if (closed) {
-        return;
-      }
-      if (hasMoreChunks && !discardStream(httpEngine, this)) {
-        unexpectedEndOfInput();
-      }
-      closed = true;
-    }
+    return httpConnection.newUnknownLengthSource(cacheRequest);
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
index 83a8e831cb..f1a37cbf43 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpURLConnectionImpl.java
@@ -18,13 +18,13 @@
 package com.squareup.okhttp.internal.http;
 
 import com.squareup.okhttp.Connection;
+import com.squareup.okhttp.Handshake;
 import com.squareup.okhttp.Headers;
 import com.squareup.okhttp.OkHttpClient;
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.Route;
-import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
 import java.io.FileNotFoundException;
@@ -45,6 +45,9 @@
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.TimeUnit;
+import okio.BufferedSink;
+import okio.ByteString;
+import okio.Sink;
 
 import static com.squareup.okhttp.internal.Util.getEffectivePort;
 import static com.squareup.okhttp.internal.http.StatusLine.HTTP_TEMP_REDIRECT;
@@ -85,6 +88,12 @@
    */
   private Route route;
 
+  /**
+   * The most recently received TLS handshake. This will be null if we haven't
+   * connected yet, or if the most recent connection was HTTP (and not HTTPS).
+   */
+  Handshake handshake;
+
   public HttpURLConnectionImpl(URL url, OkHttpClient client) {
     super(url);
     this.client = client;
@@ -101,15 +110,7 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
   @Override public final void disconnect() {
     // Calling disconnect() before a connection exists should have no effect.
     if (httpEngine != null) {
-      // We close the response body here instead of in
-      // HttpEngine.release because that is called when input
-      // has been completely read from the underlying socket.
-      // However the response body can be a GZIPInputStream that
-      // still has unread data.
-      if (httpEngine.hasResponse()) {
-        Util.closeQuietly(httpEngine.getResponseBody());
-      }
-      httpEngine.release(true);
+      httpEngine.close();
     }
   }
 
@@ -121,7 +122,7 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
     try {
       HttpEngine response = getResponse();
       if (response.hasResponseBody() && response.getResponse().code() >= HTTP_BAD_REQUEST) {
-        return response.getResponseBody();
+        return response.getResponseBodyBytes();
       }
       return null;
     } catch (IOException e) {
@@ -178,10 +179,7 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
           "Cannot access request header fields after connection is set");
     }
 
-    // For the request line property assigned to the null key, just use no proxy and HTTP 1.1.
-    Request request = new Request.Builder().url(getURL()).method(method, null).build();
-    String requestLine = RequestLine.get(request, null, 1);
-    return OkHeaders.toMultimap(requestHeaders.build(), requestLine);
+    return OkHeaders.toMultimap(requestHeaders.build(), null);
   }
 
   @Override public final InputStream getInputStream() throws IOException {
@@ -199,7 +197,7 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
       throw new FileNotFoundException(url.toString());
     }
 
-    InputStream result = response.getResponseBody();
+    InputStream result = response.getResponseBodyBytes();
     if (result == null) {
       throw new ProtocolException("No response body exists; responseCode=" + getResponseCode());
     }
@@ -209,14 +207,14 @@ public HttpURLConnectionImpl(URL url, OkHttpClient client) {
   @Override public final OutputStream getOutputStream() throws IOException {
     connect();
 
-    OutputStream out = httpEngine.getRequestBody();
-    if (out == null) {
+    BufferedSink sink = httpEngine.getBufferedRequestBody();
+    if (sink == null) {
       throw new ProtocolException("method does not support a request body: " + method);
     } else if (httpEngine.hasResponse()) {
       throw new ProtocolException("cannot write request body after response has been read");
     }
 
-    return out;
+    return sink.outputStream();
   }
 
   @Override public final Permission getPermission() throws IOException {
@@ -264,7 +262,7 @@ private void initHttpEngine() throws IOException {
         if (method.equals("GET")) {
           // they are requesting a stream to write to. This implies a POST method
           method = "POST";
-        } else if (!method.equals("POST") && !method.equals("PUT") && !method.equals("PATCH")) {
+        } else if (!HttpMethod.hasRequestBody(method)) {
           // If the request method is neither POST nor PUT nor PATCH, then you're not writing
           throw new ProtocolException(method + " does not support writing");
         }
@@ -277,7 +275,7 @@ private void initHttpEngine() throws IOException {
   }
 
   private HttpEngine newHttpEngine(String method, Connection connection,
-      RetryableOutputStream requestBody) {
+      RetryableSink requestBody) {
     Request.Builder builder = new Request.Builder()
         .url(getURL())
         .method(method, null /* No body; that's passed separately. */);
@@ -327,13 +325,13 @@ private HttpEngine getResponse() throws IOException {
 
       Retry retry = processResponseHeaders();
       if (retry == Retry.NONE) {
-        httpEngine.automaticallyReleaseConnectionToPool();
+        httpEngine.releaseConnection();
         return httpEngine;
       }
 
       // The first request was insufficient. Prepare for another...
       String retryMethod = method;
-      OutputStream requestBody = httpEngine.getRequestBody();
+      Sink requestBody = httpEngine.getRequestBody();
 
       // Although RFC 2616 10.3.2 specifies that a HTTP_MOVED_PERM
       // redirect should keep the same method, Chrome, Firefox and the
@@ -348,17 +346,16 @@ private HttpEngine getResponse() throws IOException {
         requestBody = null;
       }
 
-      if (requestBody != null && !(requestBody instanceof RetryableOutputStream)) {
+      if (requestBody != null && !(requestBody instanceof RetryableSink)) {
         throw new HttpRetryException("Cannot retry streamed HTTP body", responseCode);
       }
 
       if (retry == Retry.DIFFERENT_CONNECTION) {
-        httpEngine.automaticallyReleaseConnectionToPool();
+        httpEngine.releaseConnection();
       }
 
-      httpEngine.release(false);
-      httpEngine = newHttpEngine(retryMethod, httpEngine.getConnection(),
-          (RetryableOutputStream) requestBody);
+      Connection connection = httpEngine.close();
+      httpEngine = newHttpEngine(retryMethod, connection, (RetryableSink) requestBody);
     }
   }
 
@@ -371,6 +368,9 @@ private boolean execute(boolean readResponse) throws IOException {
     try {
       httpEngine.sendRequest();
       route = httpEngine.getRoute();
+      handshake = httpEngine.getConnection() != null
+          ? httpEngine.getConnection().getHandshake()
+          : null;
       if (readResponse) {
         httpEngine.readResponse();
       }
@@ -567,6 +567,14 @@ private void setProtocols(String protocolsString, boolean append) {
     client.setProtocols(protocolsList);
   }
 
+  @Override public void setRequestMethod(String method) throws ProtocolException {
+    if (!HttpMethod.METHODS.contains(method)) {
+      throw new ProtocolException(
+          "Expected one of " + HttpMethod.METHODS + " but was " + method);
+    }
+    this.method = method;
+  }
+
   @Override public void setFixedLengthStreamingMode(int contentLength) {
     setFixedLengthStreamingMode((long) contentLength);
   }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsURLConnectionImpl.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsURLConnectionImpl.java
index ab0ecd2a16..1982ebeae0 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsURLConnectionImpl.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/HttpsURLConnectionImpl.java
@@ -20,271 +20,33 @@
 import android.os.Build;
 import com.squareup.okhttp.Handshake;
 import com.squareup.okhttp.OkHttpClient;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.ProtocolException;
 import java.net.URL;
-import java.security.Permission;
-import java.security.Principal;
-import java.security.cert.Certificate;
-import java.util.List;
-import java.util.Map;
 import javax.net.ssl.HostnameVerifier;
-import javax.net.ssl.HttpsURLConnection;
-import javax.net.ssl.SSLPeerUnverifiedException;
 import javax.net.ssl.SSLSocketFactory;
 
-public final class HttpsURLConnectionImpl extends HttpsURLConnection {
-
-  /** Reuse HttpURLConnectionImpl. */
+public final class HttpsURLConnectionImpl extends DelegatingHttpsURLConnection {
   private final HttpURLConnectionImpl delegate;
 
   public HttpsURLConnectionImpl(URL url, OkHttpClient client) {
-    super(url);
-    delegate = new HttpURLConnectionImpl(url, client);
-  }
-
-  @Override public String getCipherSuite() {
-    Handshake handshake = handshake();
-    return handshake != null ? handshake.cipherSuite() : null;
-  }
-
-  @Override public Certificate[] getLocalCertificates() {
-    Handshake handshake = handshake();
-    if (handshake == null) return null;
-    List<Certificate> result = handshake.localCertificates();
-    return !result.isEmpty() ? result.toArray(new Certificate[result.size()]) : null;
-  }
-
-  @Override public Certificate[] getServerCertificates() throws SSLPeerUnverifiedException {
-    Handshake handshake = handshake();
-    if (handshake == null) return null;
-    List<Certificate> result = handshake.peerCertificates();
-    return !result.isEmpty() ? result.toArray(new Certificate[result.size()]) : null;
+    this(new HttpURLConnectionImpl(url, client));
   }
 
-  @Override public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
-    Handshake handshake = handshake();
-    return handshake != null ? handshake.peerPrincipal() : null;
+  public HttpsURLConnectionImpl(HttpURLConnectionImpl delegate) {
+    super(delegate);
+    this.delegate = delegate;
   }
 
-  @Override public Principal getLocalPrincipal() {
-    Handshake handshake = handshake();
-    return handshake != null ? handshake.localPrincipal() : null;
-  }
-
-  private Handshake handshake() {
+  @Override protected Handshake handshake() {
     if (delegate.httpEngine == null) {
       throw new IllegalStateException("Connection has not yet been established");
     }
-    return delegate.httpEngine.getResponse().handshake();
-  }
-
-  @Override public void disconnect() {
-    delegate.disconnect();
-  }
-
-  @Override public InputStream getErrorStream() {
-    return delegate.getErrorStream();
-  }
-
-  @Override public String getRequestMethod() {
-    return delegate.getRequestMethod();
-  }
-
-  @Override public int getResponseCode() throws IOException {
-    return delegate.getResponseCode();
-  }
-
-  @Override public String getResponseMessage() throws IOException {
-    return delegate.getResponseMessage();
-  }
-
-  @Override public void setRequestMethod(String method) throws ProtocolException {
-    delegate.setRequestMethod(method);
-  }
-
-  @Override public boolean usingProxy() {
-    return delegate.usingProxy();
-  }
-
-  @Override public boolean getInstanceFollowRedirects() {
-    return delegate.getInstanceFollowRedirects();
-  }
-
-  @Override public void setInstanceFollowRedirects(boolean followRedirects) {
-    delegate.setInstanceFollowRedirects(followRedirects);
-  }
-
-  @Override public void connect() throws IOException {
-    connected = true;
-    delegate.connect();
-  }
-
-  @Override public boolean getAllowUserInteraction() {
-    return delegate.getAllowUserInteraction();
-  }
-
-  @Override public Object getContent() throws IOException {
-    return delegate.getContent();
-  }
-
-  @SuppressWarnings("unchecked") // Spec does not generify
-  @Override public Object getContent(Class[] types) throws IOException {
-    return delegate.getContent(types);
-  }
-
-  @Override public String getContentEncoding() {
-    return delegate.getContentEncoding();
-  }
-
-  @Override public int getContentLength() {
-    return delegate.getContentLength();
-  }
-
-  @Override public String getContentType() {
-    return delegate.getContentType();
-  }
-
-  @Override public long getDate() {
-    return delegate.getDate();
-  }
-
-  @Override public boolean getDefaultUseCaches() {
-    return delegate.getDefaultUseCaches();
-  }
-
-  @Override public boolean getDoInput() {
-    return delegate.getDoInput();
-  }
-
-  @Override public boolean getDoOutput() {
-    return delegate.getDoOutput();
-  }
-
-  @Override public long getExpiration() {
-    return delegate.getExpiration();
-  }
-
-  @Override public String getHeaderField(int pos) {
-    return delegate.getHeaderField(pos);
-  }
-
-  @Override public Map<String, List<String>> getHeaderFields() {
-    return delegate.getHeaderFields();
-  }
-
-  @Override public Map<String, List<String>> getRequestProperties() {
-    return delegate.getRequestProperties();
-  }
-
-  @Override public void addRequestProperty(String field, String newValue) {
-    delegate.addRequestProperty(field, newValue);
-  }
 
-  @Override public String getHeaderField(String key) {
-    return delegate.getHeaderField(key);
-  }
-
-  @Override public long getHeaderFieldDate(String field, long defaultValue) {
-    return delegate.getHeaderFieldDate(field, defaultValue);
-  }
-
-  @Override public int getHeaderFieldInt(String field, int defaultValue) {
-    return delegate.getHeaderFieldInt(field, defaultValue);
-  }
-
-  @Override public String getHeaderFieldKey(int position) {
-    return delegate.getHeaderFieldKey(position);
-  }
-
-  @Override public long getIfModifiedSince() {
-    return delegate.getIfModifiedSince();
-  }
-
-  @Override public InputStream getInputStream() throws IOException {
-    return delegate.getInputStream();
-  }
-
-  @Override public long getLastModified() {
-    return delegate.getLastModified();
-  }
-
-  @Override public OutputStream getOutputStream() throws IOException {
-    return delegate.getOutputStream();
-  }
-
-  @Override public Permission getPermission() throws IOException {
-    return delegate.getPermission();
-  }
-
-  @Override public String getRequestProperty(String field) {
-    return delegate.getRequestProperty(field);
-  }
-
-  @Override public URL getURL() {
-    return delegate.getURL();
-  }
-
-  @Override public boolean getUseCaches() {
-    return delegate.getUseCaches();
-  }
-
-  @Override public void setAllowUserInteraction(boolean newValue) {
-    delegate.setAllowUserInteraction(newValue);
-  }
-
-  @Override public void setDefaultUseCaches(boolean newValue) {
-    delegate.setDefaultUseCaches(newValue);
-  }
-
-  @Override public void setDoInput(boolean newValue) {
-    delegate.setDoInput(newValue);
-  }
-
-  @Override public void setDoOutput(boolean newValue) {
-    delegate.setDoOutput(newValue);
-  }
-
-  @Override public void setIfModifiedSince(long newValue) {
-    delegate.setIfModifiedSince(newValue);
-  }
-
-  @Override public void setRequestProperty(String field, String newValue) {
-    delegate.setRequestProperty(field, newValue);
-  }
-
-  @Override public void setUseCaches(boolean newValue) {
-    delegate.setUseCaches(newValue);
-  }
-
-  @Override public void setConnectTimeout(int timeoutMillis) {
-    delegate.setConnectTimeout(timeoutMillis);
-  }
-
-  @Override public int getConnectTimeout() {
-    return delegate.getConnectTimeout();
-  }
-
-  @Override public void setReadTimeout(int timeoutMillis) {
-    delegate.setReadTimeout(timeoutMillis);
-  }
-
-  @Override public int getReadTimeout() {
-    return delegate.getReadTimeout();
-  }
-
-  @Override public String toString() {
-    return delegate.toString();
-  }
-
-  @Override public void setFixedLengthStreamingMode(int contentLength) {
-    delegate.setFixedLengthStreamingMode(contentLength);
-  }
-
-  @Override public void setChunkedStreamingMode(int chunkLength) {
-    delegate.setChunkedStreamingMode(chunkLength);
+    // If there's a response, get the handshake from there so that caching
+    // works. Otherwise get the handshake from the connection because we might
+    // have not connected yet.
+    return delegate.httpEngine.hasResponse()
+        ? delegate.httpEngine.getResponse().handshake()
+        : delegate.handshake;
   }
 
   @Override public void setHostnameVerifier(HostnameVerifier hostnameVerifier) {
@@ -307,4 +69,16 @@ private Handshake handshake() {
   @Override public void setFixedLengthStreamingMode(long contentLength) {
     delegate.setFixedLengthStreamingMode(contentLength);
   }
+
+  @Override public long getContentLengthLong() {
+    return delegate.getContentLengthLong();
+  }
+
+  @Override public void setFixedLengthStreamingMode(long contentLength) {
+    delegate.setFixedLengthStreamingMode(contentLength);
+  }
+
+  @Override public long getHeaderFieldLong(String field, long defaultValue) {
+    return delegate.getHeaderFieldLong(field, defaultValue);
+  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
index bc18ea6ed3..456c9c7535 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/OkHeaders.java
@@ -4,9 +4,6 @@
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import com.squareup.okhttp.internal.Platform;
-import com.squareup.okhttp.internal.Util;
-import java.io.IOException;
-import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
@@ -49,16 +46,9 @@
    */
   public static final String RESPONSE_SOURCE = PREFIX + "-Response-Source";
 
-  /**
-   * @deprecated OkHttp 2 enforces an enumeration of {@link com.squareup.okhttp.Protocol protocols}
-   * that can be selected. Please use #SELECTED_PROTOCOL
-   */
-  @Deprecated
-  public static final String SELECTED_TRANSPORT = PREFIX + "-Selected-Transport";
-
   /**
    * Synthetic response header: the selected
-   * {@link com.squareup.okhttp.Protocol protocol} ("spdy/3", "http/1.1", etc).
+   * {@link com.squareup.okhttp.Protocol protocol} ("spdy/3.1", "http/1.1", etc).
    */
   public static final String SELECTED_PROTOCOL = PREFIX + "-Selected-Protocol";
 
@@ -66,11 +56,15 @@ private OkHeaders() {
   }
 
   public static long contentLength(Request request) {
-    return stringToLong(request.header("Content-Length"));
+    return contentLength(request.headers());
   }
 
   public static long contentLength(Response response) {
-    return stringToLong(response.header("Content-Length"));
+    return contentLength(response.headers());
+  }
+
+  public static long contentLength(Headers headers) {
+    return stringToLong(headers.get("Content-Length"));
   }
 
   private static long stringToLong(String s) {
@@ -131,12 +125,4 @@ private static String buildCookieHeader(List<String> cookies) {
     }
     return sb.toString();
   }
-
-  /** Reads headers or trailers into {@code builder}. */
-  public static void readHeaders(Headers.Builder builder, InputStream in) throws IOException {
-    // parse the result headers until the first blank line
-    for (String line; (line = Util.readAsciiLine(in)).length() != 0; ) {
-      builder.addLine(line);
-    }
-  }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/ResponseCacheAdapter.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/ResponseCacheAdapter.java
new file mode 100644
index 0000000000..9d6eb22c60
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/ResponseCacheAdapter.java
@@ -0,0 +1,557 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.http;
+
+import com.squareup.okhttp.Handshake;
+import com.squareup.okhttp.Headers;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.OkResponseCache;
+import com.squareup.okhttp.Request;
+import com.squareup.okhttp.Response;
+import com.squareup.okhttp.ResponseSource;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.CacheRequest;
+import java.net.CacheResponse;
+import java.net.HttpURLConnection;
+import java.net.ProtocolException;
+import java.net.ResponseCache;
+import java.net.SecureCacheResponse;
+import java.net.URI;
+import java.security.cert.Certificate;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLPeerUnverifiedException;
+import javax.net.ssl.SSLSocketFactory;
+
+/**
+ * An adapter from {@link ResponseCache} to {@link com.squareup.okhttp.OkResponseCache}. This class
+ * enables OkHttp to continue supporting Java standard response cache implementations.
+ */
+public class ResponseCacheAdapter implements OkResponseCache {
+
+  private final ResponseCache delegate;
+
+  public ResponseCacheAdapter(ResponseCache delegate) {
+    this.delegate = delegate;
+  }
+
+  public ResponseCache getDelegate() {
+    return delegate;
+  }
+
+  @Override
+  public Response get(Request request) throws IOException {
+    CacheResponse javaResponse = getJavaCachedResponse(request);
+    if (javaResponse == null) {
+      return null;
+    }
+
+    Response.Builder okResponseBuilder = new Response.Builder();
+
+    // Request: Use the one provided.
+    okResponseBuilder.request(request);
+
+    // Status Line: Java has this as one of the headers.
+    okResponseBuilder.statusLine(extractStatusLine(javaResponse));
+
+    // Response headers
+    Headers okHeaders = extractOkHeaders(javaResponse);
+    okResponseBuilder.headers(okHeaders);
+
+    // Meta data: Defaulted
+    okResponseBuilder.setResponseSource(ResponseSource.CACHE);
+
+    // Response body
+    Response.Body okBody = createOkBody(okHeaders, javaResponse.getBody());
+    okResponseBuilder.body(okBody);
+
+    // Handle SSL handshake information as needed.
+    if (javaResponse instanceof SecureCacheResponse) {
+      SecureCacheResponse javaSecureCacheResponse = (SecureCacheResponse) javaResponse;
+
+      // Handshake doesn't support null lists.
+      List<Certificate> peerCertificates;
+      try {
+        peerCertificates = javaSecureCacheResponse.getServerCertificateChain();
+      } catch (SSLPeerUnverifiedException e) {
+        peerCertificates = Collections.emptyList();
+      }
+      List<Certificate> localCertificates = javaSecureCacheResponse.getLocalCertificateChain();
+      if (localCertificates == null) {
+        localCertificates = Collections.emptyList();
+      }
+      Handshake handshake = Handshake.get(
+          javaSecureCacheResponse.getCipherSuite(), peerCertificates, localCertificates);
+      okResponseBuilder.handshake(handshake);
+    }
+
+    return okResponseBuilder.build();
+  }
+
+  @Override
+  public CacheRequest put(Response response) throws IOException {
+    URI uri = response.request().uri();
+    HttpURLConnection connection = createJavaUrlConnection(response);
+    return delegate.put(uri, connection);
+  }
+
+  @Override
+  public boolean maybeRemove(Request request) throws IOException {
+    // This method is treated as optional and there is no obvious way of implementing it with
+    // ResponseCache. Removing items from the cache due to modifications made from this client is
+    // not essential given that modifications could be made from any other client. We have to assume
+    // that it's ok to keep using the cached data. Otherwise the server shouldn't declare it as
+    // cacheable or the client should be careful about caching it.
+    return false;
+  }
+
+  @Override
+  public void update(Response cached, Response network) throws IOException {
+    // This method is treated as optional and there is no obvious way of implementing it with
+    // ResponseCache. Updating headers is useful if the server changes the metadata for a resource
+    // (e.g. max age) to extend or truncate the life of that resource in the cache. If the metadata
+    // is not updated the caching behavior may not be optimal, but will obey the metadata sent
+    // with the original cached response.
+  }
+
+  @Override
+  public void trackConditionalCacheHit() {
+    // This method is treated as optional.
+  }
+
+  @Override
+  public void trackResponse(ResponseSource source) {
+    // This method is treated as optional.
+  }
+
+  /**
+   * Returns the {@link CacheResponse} from the delegate by converting the
+   * OkHttp {@link Request} into the arguments required by the {@link ResponseCache}.
+   */
+  private CacheResponse getJavaCachedResponse(Request request) throws IOException {
+    Map<String, List<String>> headers = extractJavaHeaders(request);
+    return delegate.get(request.uri(), request.method(), headers);
+  }
+
+  /**
+   * Creates an {@link HttpURLConnection} of the correct subclass from the supplied OkHttp response.
+   */
+  private static HttpURLConnection createJavaUrlConnection(Response okResponse) {
+    Request request = okResponse.request();
+    // Create an object of the correct class in case the ResponseCache uses instanceof.
+    if (request.isHttps()) {
+      return new CacheHttpsURLConnection(new CacheHttpURLConnection(okResponse));
+    } else {
+      return new CacheHttpURLConnection(okResponse);
+    }
+  }
+
+  /**
+   * Extracts OkHttp headers from the supplied {@link CacheResponse}. Only real headers are
+   * extracted. The status line entry (which has a null key) is discarded.
+   * See {@link #extractStatusLine(java.net.CacheResponse)}.
+   */
+  private static Headers extractOkHeaders(CacheResponse javaResponse) throws IOException {
+    Map<String, List<String>> cachedHeaders = javaResponse.getHeaders();
+    Headers.Builder okHeadersBuilder = new Headers.Builder();
+    for (Map.Entry<String, List<String>> cachedHeader : cachedHeaders.entrySet()) {
+      String name = cachedHeader.getKey();
+      if (name == null) {
+        // The Java API uses the null key to store the status line.
+        continue;
+      }
+      for (String value : cachedHeader.getValue()) {
+        okHeadersBuilder.add(name, value);
+      }
+    }
+    return okHeadersBuilder.build();
+  }
+
+  /**
+   * Extracts the status line {@link CacheResponse} from the supplied Java API response. As per the
+   * spec, the status line is held as the header with the null key. Returns {@code null} if there is
+   * no status line.
+   */
+  private static String extractStatusLine(CacheResponse javaResponse) throws IOException {
+    List<String> values = javaResponse.getHeaders().get(null);
+    if (values == null || values.size() == 0) {
+      return null;
+    }
+    return values.get(0);
+  }
+
+  /**
+   * Extracts an immutable header map from the supplied {@link Headers}.
+   */
+  private static Map<String, List<String>> extractJavaHeaders(Request request) {
+    return OkHeaders.toMultimap(request.headers(), null);
+  }
+
+  /**
+   * Creates an OkHttp Response.Body containing the supplied information.
+   */
+  private static Response.Body createOkBody(final Headers okHeaders, final InputStream body) {
+    return new Response.Body() {
+
+      @Override
+      public boolean ready() throws IOException {
+        return true;
+      }
+
+      @Override
+      public MediaType contentType() {
+        String contentTypeHeader = okHeaders.get("Content-Type");
+        return contentTypeHeader == null ? null : MediaType.parse(contentTypeHeader);
+      }
+
+      @Override
+      public long contentLength() {
+        return OkHeaders.contentLength(okHeaders);
+      }
+
+      @Override
+      public InputStream byteStream() {
+        return body;
+      }
+    };
+  }
+
+  /**
+   * An {@link HttpURLConnection} that represents an HTTP request at the point where
+   * the request has been made, and the response headers have been received, but the body content,
+   * if present, has not been read yet. This intended to provide enough information for
+   * {@link ResponseCache} subclasses and no more.
+   *
+   * <p>Much of the method implementations are overrides to delegate to the OkHttp request and
+   * response, or to deny access to information as a real HttpURLConnection would after connection.
+   */
+  private static final class CacheHttpURLConnection extends HttpURLConnection {
+
+    private final Request request;
+    private final Response response;
+
+    public CacheHttpURLConnection(Response response) {
+      super(response.request().url());
+      this.request = response.request();
+      this.response = response;
+
+      // Configure URLConnection inherited fields.
+      this.connected = true;
+      this.doOutput = response.body() == null;
+
+      // Configure HttpUrlConnection inherited fields.
+      this.method = request.method();
+    }
+
+    // HTTP connection lifecycle methods
+
+    @Override
+    public void connect() throws IOException {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public void disconnect() {
+      throw throwRequestModificationException();
+    }
+
+    // HTTP Request methods
+
+    @Override
+    public void setRequestProperty(String key, String value) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public void addRequestProperty(String key, String value) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public String getRequestProperty(String key) {
+      return request.header(key);
+    }
+
+    @Override
+    public Map<String, List<String>> getRequestProperties() {
+      // This is to preserve RI and compatibility with OkHttp's HttpURLConnectionImpl. There seems
+      // no good reason why this should fail while getRequestProperty() is ok.
+      throw throwRequestHeaderAccessException();
+    }
+
+    @Override
+    public void setFixedLengthStreamingMode(int contentLength) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public void setFixedLengthStreamingMode(long contentLength) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public void setChunkedStreamingMode(int chunklen) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public void setInstanceFollowRedirects(boolean followRedirects) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public boolean getInstanceFollowRedirects() {
+      // Return the platform default.
+      return super.getInstanceFollowRedirects();
+    }
+
+    @Override
+    public void setRequestMethod(String method) throws ProtocolException {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public String getRequestMethod() {
+      return request.method();
+    }
+
+    // HTTP Response methods
+
+    @Override
+    public String getHeaderFieldKey(int position) {
+      // Deal with index 0 meaning "status line"
+      if (position < 0) {
+        throw new IllegalArgumentException("Invalid header index: " + position);
+      }
+      if (position == 0) {
+        return null;
+      }
+      return response.headers().name(position - 1);
+    }
+
+    @Override
+    public String getHeaderField(int position) {
+      // Deal with index 0 meaning "status line"
+      if (position < 0) {
+        throw new IllegalArgumentException("Invalid header index: " + position);
+      }
+      if (position == 0) {
+        return response.statusLine();
+      }
+      return response.headers().value(position - 1);
+    }
+
+    @Override
+    public String getHeaderField(String fieldName) {
+      return fieldName == null ? response.statusLine() : response.headers().get(fieldName);
+    }
+
+    @Override
+    public Map<String, List<String>> getHeaderFields() {
+      return OkHeaders.toMultimap(response.headers(), response.statusLine());
+    }
+
+    @Override
+    public int getResponseCode() throws IOException {
+      return response.code();
+    }
+
+    @Override
+    public String getResponseMessage() throws IOException {
+      return response.statusMessage();
+    }
+
+    @Override
+    public InputStream getErrorStream() {
+      return null;
+    }
+
+    // HTTP miscellaneous methods
+
+    @Override
+    public boolean usingProxy() {
+      // It's safe to return false here, even if a proxy is in use. The problem is we don't
+      // necessarily know if we're going to use a proxy by the time we ask the cache for a response.
+      return false;
+    }
+
+    // URLConnection methods
+
+    @Override
+    public void setConnectTimeout(int timeout) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public int getConnectTimeout() {
+      // Impossible to say.
+      return 0;
+    }
+
+    @Override
+    public void setReadTimeout(int timeout) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public int getReadTimeout() {
+      // Impossible to say.
+      return 0;
+    }
+
+    @Override
+    public Object getContent() throws IOException {
+      throw throwResponseBodyAccessException();
+    }
+
+    @Override
+    public Object getContent(Class[] classes) throws IOException {
+      throw throwResponseBodyAccessException();
+    }
+
+    @Override
+    public InputStream getInputStream() throws IOException {
+      throw throwResponseBodyAccessException();
+    }
+
+    @Override
+    public OutputStream getOutputStream() throws IOException {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public void setDoInput(boolean doInput) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public boolean getDoInput() {
+      return true;
+    }
+
+    @Override
+    public void setDoOutput(boolean doOutput) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public boolean getDoOutput() {
+      return request.body() != null;
+    }
+
+    @Override
+    public void setAllowUserInteraction(boolean allowUserInteraction) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public boolean getAllowUserInteraction() {
+      return false;
+    }
+
+    @Override
+    public void setUseCaches(boolean useCaches) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public boolean getUseCaches() {
+      return super.getUseCaches();
+    }
+
+    @Override
+    public void setIfModifiedSince(long ifModifiedSince) {
+      throw throwRequestModificationException();
+    }
+
+    @Override
+    public long getIfModifiedSince() {
+      return 0;
+    }
+
+    @Override
+    public boolean getDefaultUseCaches() {
+      return super.getDefaultUseCaches();
+    }
+
+    @Override
+    public void setDefaultUseCaches(boolean defaultUseCaches) {
+      super.setDefaultUseCaches(defaultUseCaches);
+    }
+  }
+
+  /** An HttpsURLConnection to offer to the cache. */
+  private static final class CacheHttpsURLConnection extends DelegatingHttpsURLConnection {
+    private final CacheHttpURLConnection delegate;
+
+    public CacheHttpsURLConnection(CacheHttpURLConnection delegate) {
+      super(delegate);
+      this.delegate = delegate;
+    }
+
+    @Override protected Handshake handshake() {
+      return delegate.response.handshake();
+    }
+
+    @Override public void setHostnameVerifier(HostnameVerifier hostnameVerifier) {
+      throw throwRequestModificationException();
+    }
+
+    @Override public HostnameVerifier getHostnameVerifier() {
+      throw throwRequestSslAccessException();
+    }
+
+    @Override public void setSSLSocketFactory(SSLSocketFactory socketFactory) {
+      throw throwRequestModificationException();
+    }
+
+    @Override public SSLSocketFactory getSSLSocketFactory() {
+      throw throwRequestSslAccessException();
+    }
+
+    @Override public long getContentLengthLong() {
+      return delegate.getContentLengthLong();
+    }
+
+    @Override public void setFixedLengthStreamingMode(long contentLength) {
+      delegate.setFixedLengthStreamingMode(contentLength);
+    }
+
+    @Override public long getHeaderFieldLong(String field, long defaultValue) {
+      return delegate.getHeaderFieldLong(field, defaultValue);
+    }
+  }
+
+  private static RuntimeException throwRequestModificationException() {
+    throw new UnsupportedOperationException("ResponseCache cannot modify the request.");
+  }
+
+  private static RuntimeException throwRequestHeaderAccessException() {
+    throw new UnsupportedOperationException("ResponseCache cannot access request headers");
+  }
+
+  private static RuntimeException throwRequestSslAccessException() {
+    throw new UnsupportedOperationException("ResponseCache cannot access SSL internals");
+  }
+
+  private static RuntimeException throwResponseBodyAccessException() {
+    throw new UnsupportedOperationException("ResponseCache cannot access the response body.");
+  }
+}
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableOutputStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
similarity index 57%
rename from okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableOutputStream.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
index 5eb6b76455..b8f53a3d84 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableOutputStream.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RetryableSink.java
@@ -16,11 +16,12 @@
 
 package com.squareup.okhttp.internal.http;
 
-import com.squareup.okhttp.internal.AbstractOutputStream;
-import java.io.ByteArrayOutputStream;
 import java.io.IOException;
-import java.io.OutputStream;
 import java.net.ProtocolException;
+import okio.BufferedSink;
+import okio.Deadline;
+import okio.OkBuffer;
+import okio.Sink;
 
 import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
 
@@ -29,24 +30,21 @@
  * the post body to be transparently re-sent if the HTTP request must be
  * sent multiple times.
  */
-final class RetryableOutputStream extends AbstractOutputStream {
+final class RetryableSink implements Sink {
+  private boolean closed;
   private final int limit;
-  private final ByteArrayOutputStream content;
+  private final OkBuffer content = new OkBuffer();
 
-  public RetryableOutputStream(int limit) {
+  public RetryableSink(int limit) {
     this.limit = limit;
-    this.content = new ByteArrayOutputStream(limit);
   }
 
-  public RetryableOutputStream() {
-    this.limit = -1;
-    this.content = new ByteArrayOutputStream();
+  public RetryableSink() {
+    this(-1);
   }
 
-  @Override public synchronized void close() throws IOException {
-    if (closed) {
-      return;
-    }
+  @Override public void close() throws IOException {
+    if (closed) return;
     closed = true;
     if (content.size() < limit) {
       throw new ProtocolException(
@@ -54,22 +52,28 @@ public RetryableOutputStream() {
     }
   }
 
-  @Override public synchronized void write(byte[] buffer, int offset, int count)
-      throws IOException {
-    checkNotClosed();
-    checkOffsetAndCount(buffer.length, offset, count);
-    if (limit != -1 && content.size() > limit - count) {
+  @Override public void write(OkBuffer source, long byteCount) throws IOException {
+    if (closed) throw new IllegalStateException("closed");
+    checkOffsetAndCount(source.size(), 0, byteCount);
+    if (limit != -1 && content.size() > limit - byteCount) {
       throw new ProtocolException("exceeded content-length limit of " + limit + " bytes");
     }
-    content.write(buffer, offset, count);
+    content.write(source, byteCount);
+  }
+
+  @Override public void flush() throws IOException {
+  }
+
+  @Override public Sink deadline(Deadline deadline) {
+    return this;
   }
 
-  public synchronized int contentLength() throws IOException {
-    close();
+  public long contentLength() throws IOException {
     return content.size();
   }
 
-  public void writeToSocket(OutputStream socketOut) throws IOException {
-    content.writeTo(socketOut);
+  public void writeToSocket(BufferedSink socketOut) throws IOException {
+    // Clone the content; otherwise we won't have data to retry.
+    socketOut.write(content.clone(), content.size());
   }
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
index 3f1dc9a2dc..f935d5cd1f 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/RouteSelector.java
@@ -34,6 +34,7 @@
 import java.util.List;
 import java.util.NoSuchElementException;
 import javax.net.ssl.SSLHandshakeException;
+import javax.net.ssl.SSLProtocolException;
 
 import static com.squareup.okhttp.internal.Util.getEffectivePort;
 
@@ -117,7 +118,7 @@ public Connection next(String method) throws IOException {
           if (!hasNextPostponed()) {
             throw new NoSuchElementException();
           }
-          return new Connection(nextPostponed());
+          return new Connection(pool, nextPostponed());
         }
         lastProxy = nextProxy();
         resetNextInetSocketAddress(lastProxy);
@@ -135,7 +136,7 @@ public Connection next(String method) throws IOException {
       return next(method);
     }
 
-    return new Connection(route);
+    return new Connection(pool, route);
   }
 
   /**
@@ -143,6 +144,9 @@ public Connection next(String method) throws IOException {
    * failure on a connection returned by this route selector.
    */
   public void connectFailed(Connection connection, IOException failure) {
+    // If this is a recycled connection, don't count its failure against the route.
+    if (connection.recycleCount() > 0) return;
+
     Route failedRoute = connection.getRoute();
     if (failedRoute.getProxy().type() != Proxy.Type.DIRECT && proxySelector != null) {
       // Tell the proxy selector when we fail to connect on a fresh connection.
@@ -154,7 +158,9 @@ public void connectFailed(Connection connection, IOException failure) {
     // If the previously returned route's problem was not related to TLS, and
     // the next route only changes the TLS mode, we shouldn't even attempt it.
     // This suppresses it in both this selector and also in the route database.
-    if (hasNextTlsMode() && !(failure instanceof SSLHandshakeException)) {
+    if (hasNextTlsMode()
+        && !(failure instanceof SSLHandshakeException)
+        && !(failure instanceof SSLProtocolException)) {
       boolean modernTls = nextTlsMode() == TLS_MODE_MODERN;
       Route routeToSuppress = new Route(address, lastProxy, lastInetSocketAddress, modernTls);
       routeDatabase.failed(routeToSuppress);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
index 9c1453b647..e775d347c6 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/SpdyTransport.java
@@ -20,14 +20,12 @@
 import com.squareup.okhttp.Protocol;
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
-import com.squareup.okhttp.internal.ByteString;
 import com.squareup.okhttp.internal.Util;
 import com.squareup.okhttp.internal.spdy.ErrorCode;
 import com.squareup.okhttp.internal.spdy.Header;
 import com.squareup.okhttp.internal.spdy.SpdyConnection;
 import com.squareup.okhttp.internal.spdy.SpdyStream;
 import java.io.IOException;
-import java.io.InputStream;
 import java.io.OutputStream;
 import java.net.CacheRequest;
 import java.net.ProtocolException;
@@ -36,8 +34,13 @@
 import java.util.List;
 import java.util.Locale;
 import java.util.Set;
+import okio.ByteString;
+import okio.Deadline;
+import okio.OkBuffer;
+import okio.Okio;
+import okio.Sink;
+import okio.Source;
 
-import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
 import static com.squareup.okhttp.internal.spdy.Header.RESPONSE_STATUS;
 import static com.squareup.okhttp.internal.spdy.Header.TARGET_AUTHORITY;
 import static com.squareup.okhttp.internal.spdy.Header.TARGET_HOST;
@@ -47,6 +50,25 @@
 import static com.squareup.okhttp.internal.spdy.Header.VERSION;
 
 public final class SpdyTransport implements Transport {
+  /** See http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1#TOC-3.2.1-Request. */
+  private static final List<ByteString> SPDY_3_PROHIBITED_HEADERS = Util.immutableList(
+      ByteString.encodeUtf8("connection"),
+      ByteString.encodeUtf8("host"),
+      ByteString.encodeUtf8("keep-alive"),
+      ByteString.encodeUtf8("proxy-connection"),
+      ByteString.encodeUtf8("transfer-encoding"));
+
+  /** See http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3. */
+  private static final List<ByteString> HTTP_2_PROHIBITED_HEADERS = Util.immutableList(
+      ByteString.encodeUtf8("connection"),
+      ByteString.encodeUtf8("host"),
+      ByteString.encodeUtf8("keep-alive"),
+      ByteString.encodeUtf8("proxy-connection"),
+      ByteString.encodeUtf8("te"),
+      ByteString.encodeUtf8("transfer-encoding"),
+      ByteString.encodeUtf8("encoding"),
+      ByteString.encodeUtf8("upgrade"));
+
   private final HttpEngine httpEngine;
   private final SpdyConnection spdyConnection;
   private SpdyStream stream;
@@ -56,10 +78,10 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
     this.spdyConnection = spdyConnection;
   }
 
-  @Override public OutputStream createRequestBody(Request request) throws IOException {
+  @Override public Sink createRequestBody(Request request) throws IOException {
     // TODO: if bufferRequestBody is set, we must buffer the whole request
     writeRequestHeaders(request);
-    return stream.getOutputStream();
+    return stream.getSink();
   }
 
   @Override public void writeRequestHeaders(Request request) throws IOException {
@@ -75,12 +97,12 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
     stream.setReadTimeout(httpEngine.client.getReadTimeout());
   }
 
-  @Override public void writeRequestBody(RetryableOutputStream requestBody) throws IOException {
+  @Override public void writeRequestBody(RetryableSink requestBody) throws IOException {
     throw new UnsupportedOperationException();
   }
 
   @Override public void flushRequest() throws IOException {
-    stream.getOutputStream().close();
+    stream.getSink().close();
   }
 
   @Override public Response.Builder readResponseHeaders() throws IOException {
@@ -98,8 +120,7 @@ public SpdyTransport(HttpEngine httpEngine, SpdyConnection spdyConnection) {
     // TODO: make the known header names constants.
     List<Header> result = new ArrayList<Header>(headers.size() + 10);
     result.add(new Header(TARGET_METHOD, request.method()));
-    result.add(
-        new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
+    result.add(new Header(TARGET_PATH, RequestLine.requestPath(request.url())));
     String host = HttpEngine.hostHeader(request.url());
     if (Protocol.SPDY_3 == protocol) {
       result.add(new Header(VERSION, version));
@@ -159,7 +180,6 @@ private static String joinOnNull(String first, String second) {
     String version = "HTTP/1.1"; // :version present only in spdy/3.
 
     Headers.Builder headersBuilder = new Headers.Builder();
-    headersBuilder.set(OkHeaders.SELECTED_TRANSPORT, protocol.name.utf8());
     headersBuilder.set(OkHeaders.SELECTED_PROTOCOL, protocol.name.utf8());
     for (int i = 0; i < headerBlock.size(); i++) {
       ByteString name = headerBlock.get(i).name;
@@ -188,75 +208,81 @@ private static String joinOnNull(String first, String second) {
         .headers(headersBuilder.build());
   }
 
-  @Override public InputStream getTransferStream(CacheRequest cacheRequest) throws IOException {
-    return new SpdyInputStream(stream, cacheRequest, httpEngine);
+  @Override public void emptyTransferStream() {
+    // Do nothing.
+  }
+
+  @Override public Source getTransferStream(CacheRequest cacheRequest) throws IOException {
+    return new SpdySource(stream, cacheRequest);
   }
 
-  @Override public boolean makeReusable(boolean streamCanceled, OutputStream requestBodyOut,
-      InputStream responseBodyIn) {
-    return true; // SPDY sockets are always reusable.
+  @Override public void releaseConnectionOnIdle() {
+  }
+
+  @Override public boolean canReuseConnection() {
+    return true; // TODO: spdyConnection.isClosed() ?
   }
 
   /** When true, this header should not be emitted or consumed. */
   private static boolean isProhibitedHeader(Protocol protocol, ByteString name) {
-    boolean prohibited = false;
     if (protocol == Protocol.SPDY_3) {
-      // http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3#TOC-3.2.1-Request
-      if (name.equalsAscii("connection")
-          || name.equalsAscii("host")
-          || name.equalsAscii("keep-alive")
-          || name.equalsAscii("proxy-connection")
-          || name.equalsAscii("transfer-encoding")) {
-        prohibited = true;
-      }
+      return SPDY_3_PROHIBITED_HEADERS.contains(name);
     } else if (protocol == Protocol.HTTP_2) {
-      // http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-8.1.3
-      if (name.equalsAscii("connection")
-          || name.equalsAscii("host")
-          || name.equalsAscii("keep-alive")
-          || name.equalsAscii("proxy-connection")
-          || name.equalsAscii("te")
-          || name.equalsAscii("transfer-encoding")
-          || name.equalsAscii("encoding")
-          || name.equalsAscii("upgrade")) {
-        prohibited = true;
-      }
+      return HTTP_2_PROHIBITED_HEADERS.contains(name);
     } else {
       throw new AssertionError(protocol);
     }
-    return prohibited;
   }
 
   /** An HTTP message body terminated by the end of the underlying stream. */
-  private static class SpdyInputStream extends AbstractHttpInputStream {
+  private static class SpdySource implements Source {
     private final SpdyStream stream;
+    private final Source source;
+    private final CacheRequest cacheRequest;
+    private final OutputStream cacheBody;
+
     private boolean inputExhausted;
+    private boolean closed;
 
-    SpdyInputStream(SpdyStream stream, CacheRequest cacheRequest, HttpEngine httpEngine)
-        throws IOException {
-      super(stream.getInputStream(), httpEngine, cacheRequest);
+    SpdySource(SpdyStream stream, CacheRequest cacheRequest) throws IOException {
       this.stream = stream;
-    }
+      this.source = stream.getSource();
 
-    @Override public int read(byte[] buffer, int offset, int count) throws IOException {
-      checkOffsetAndCount(buffer.length, offset, count);
-      checkNotClosed();
-      if (in == null || inputExhausted) {
-        return -1;
+      // Some apps return a null body; for compatibility we treat that like a null cache request.
+      OutputStream cacheBody = cacheRequest != null ? cacheRequest.getBody() : null;
+      if (cacheBody == null) {
+        cacheRequest = null;
       }
-      int read = in.read(buffer, offset, count);
+
+      this.cacheBody = cacheBody;
+      this.cacheRequest = cacheRequest;
+    }
+
+    @Override public long read(OkBuffer sink, long byteCount)
+        throws IOException {
+      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+      if (closed) throw new IllegalStateException("closed");
+      if (inputExhausted) return -1;
+
+      long read = source.read(sink, byteCount);
       if (read == -1) {
         inputExhausted = true;
-        endOfInput();
+        if (cacheRequest != null) {
+          cacheBody.close();
+        }
         return -1;
       }
-      cacheWrite(buffer, offset, read);
+
+      if (cacheBody != null) {
+        Okio.copy(sink, sink.size() - read, read, cacheBody);
+      }
+
       return read;
     }
 
-    @Override public int available() throws IOException {
-      checkNotClosed();
-      return in == null ? 0 : in.available();
+    @Override public Source deadline(Deadline deadline) {
+      source.deadline(deadline);
+      return this;
     }
 
     @Override public void close() throws IOException {
@@ -270,7 +296,9 @@ private static boolean isProhibitedHeader(Protocol protocol, ByteString name) {
 
       if (!inputExhausted) {
         stream.closeLater(ErrorCode.CANCEL);
-        unexpectedEndOfInput();
+        if (cacheRequest != null) {
+          cacheRequest.abort();
+        }
       }
     }
 
@@ -280,7 +308,7 @@ private boolean discardStream() {
         stream.setReadTimeout(socketTimeout);
         stream.setReadTimeout(DISCARD_STREAM_TIMEOUT_MILLIS);
         try {
-          Util.skipByReading(this, Long.MAX_VALUE, DISCARD_STREAM_TIMEOUT_MILLIS);
+          Util.skipAll(this, DISCARD_STREAM_TIMEOUT_MILLIS);
           return true;
         } finally {
           stream.setReadTimeout(socketTimeout);
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
index b1c38fec5a..94c90d48e4 100644
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/http/Transport.java
@@ -19,9 +19,9 @@
 import com.squareup.okhttp.Request;
 import com.squareup.okhttp.Response;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
 import java.net.CacheRequest;
+import okio.Sink;
+import okio.Source;
 
 interface Transport {
   /**
@@ -47,7 +47,7 @@
    */
   // TODO: don't bother retransmitting the request body? It's quite a corner
   // case and there's uncertainty whether Firefox or Chrome do this
-  OutputStream createRequestBody(Request request) throws IOException;
+  Sink createRequestBody(Request request) throws IOException;
 
   /** This should update the HTTP engine's sentRequestMillis field. */
   void writeRequestHeaders(Request request) throws IOException;
@@ -56,7 +56,7 @@
    * Sends the request body returned by {@link #createRequestBody} to the
    * remote peer.
    */
-  void writeRequestBody(RetryableOutputStream requestBody) throws IOException;
+  void writeRequestBody(RetryableSink requestBody) throws IOException;
 
   /** Flush the request body to the underlying socket. */
   void flushRequest() throws IOException;
@@ -64,10 +64,21 @@
   /** Read response headers and update the cookie manager. */
   Response.Builder readResponseHeaders() throws IOException;
 
+  /** Notify the transport that no response body will be read. */
+  void emptyTransferStream() throws IOException;
+
   // TODO: make this the content stream?
-  InputStream getTransferStream(CacheRequest cacheRequest) throws IOException;
+  Source getTransferStream(CacheRequest cacheRequest) throws IOException;
+
+  /**
+   * Configures the response body to pool or close the socket connection when
+   * the response body is closed.
+   */
+  void releaseConnectionOnIdle() throws IOException;
 
-  /** Returns true if the underlying connection can be recycled. */
-  boolean makeReusable(boolean streamCanceled, OutputStream requestBodyOut,
-      InputStream responseBodyIn);
+  /**
+   * Returns true if the socket connection held by this transport can be reused
+   * for a follow-up exchange.
+   */
+  boolean canReuseConnection();
 }
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/http/UnknownLengthHttpInputStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/http/UnknownLengthHttpInputStream.java
deleted file mode 100644
index ca6bb59f2e..0000000000
--- a/okhttp/src/main/java/com/squareup/okhttp/internal/http/UnknownLengthHttpInputStream.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal.http;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.net.CacheRequest;
-
-import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
-
-/** An HTTP message body terminated by the end of the underlying stream. */
-final class UnknownLengthHttpInputStream extends AbstractHttpInputStream {
-  private boolean inputExhausted;
-
-  UnknownLengthHttpInputStream(InputStream in, CacheRequest cacheRequest, HttpEngine httpEngine)
-      throws IOException {
-    super(in, httpEngine, cacheRequest);
-  }
-
-  @Override public int read(byte[] buffer, int offset, int count) throws IOException {
-    checkOffsetAndCount(buffer.length, offset, count);
-    checkNotClosed();
-    if (in == null || inputExhausted) {
-      return -1;
-    }
-    int read = in.read(buffer, offset, count);
-    if (read == -1) {
-      inputExhausted = true;
-      endOfInput();
-      return -1;
-    }
-    cacheWrite(buffer, offset, read);
-    return read;
-  }
-
-  @Override public int available() throws IOException {
-    checkNotClosed();
-    return in == null ? 0 : in.available();
-  }
-
-  @Override public void close() throws IOException {
-    if (closed) {
-      return;
-    }
-    closed = true;
-    if (!inputExhausted) {
-      unexpectedEndOfInput();
-    }
-  }
-}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/ErrorCode.java
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
similarity index 86%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
index 36e2e152a4..c87226a612 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameReader.java
@@ -18,21 +18,23 @@
 
 import java.io.Closeable;
 import java.io.IOException;
-import java.io.InputStream;
 import java.util.List;
+import okio.BufferedSource;
+import okio.ByteString;
 
-/** Reads transport frames for SPDY/3 or HTTP/2.0. */
+/** Reads transport frames for SPDY/3 or HTTP/2. */
 public interface FrameReader extends Closeable {
   void readConnectionHeader() throws IOException;
   boolean nextFrame(Handler handler) throws IOException;
 
   public interface Handler {
-    void data(boolean inFinished, int streamId, InputStream in, int length) throws IOException;
+    void data(boolean inFinished, int streamId, BufferedSource source, int length)
+        throws IOException;
 
     /**
      * Create or update incoming headers, creating the corresponding streams
      * if necessary. Frames that trigger this are SPDY SYN_STREAM, HEADERS, and
-     * SYN_REPLY, and HTTP/2.0 HEADERS and PUSH_PROMISE.
+     * SYN_REPLY, and HTTP/2 HEADERS and PUSH_PROMISE.
      *
      * @param outFinished true if the receiver should not send further frames.
      * @param inFinished true if the sender will not send further frames.
@@ -40,23 +42,25 @@
      * @param associatedStreamId the stream that triggered the sender to create
      * this stream.
      * @param priority or -1 for no priority. For SPDY, priorities range from 0
-     * (highest) thru 7 (lowest). For HTTP/2.0, priorities range from 0
+     * (highest) thru 7 (lowest). For HTTP/2, priorities range from 0
      * (highest) thru 2^31-1 (lowest), defaulting to 2^30.
      */
     void headers(boolean outFinished, boolean inFinished, int streamId, int associatedStreamId,
         int priority, List<Header> headerBlock, HeadersMode headersMode);
     void rstStream(int streamId, ErrorCode errorCode);
     void settings(boolean clearPrevious, Settings settings);
-    void noop();
+
+    /** HTTP/2 only. */
+    void ackSettings();
 
     /**
      *  Read a connection-level ping from the peer.  {@code ack} indicates this
      *  is a reply.  Payload parameters are different between SPDY/3 and HTTP/2.
-     *  <p/>
+     *  <p>
      *  In SPDY/3, only the first {@code payload1} parameter is set.  If the
      *  reader is a client, it is an unsigned even number.  Likewise, a server
      *  will receive an odd number.
-     *  <p/>
+     *  <p>
      *  In HTTP/2, both {@code payload1} and {@code payload2} parameters are
      *  set. The data is opaque binary, and there are no rules on the content.
      */
@@ -69,11 +73,12 @@ void headers(boolean outFinished, boolean inFinished, int streamId, int associat
      * on a new connection if they are idempotent.
      *
      * @param lastGoodStreamId the last stream ID the peer processed before
-     * sending this message. If {@lastGoodStreamId} is zero, the peer processed no frames.
+     *     sending this message. If {@code lastGoodStreamId} is zero, the peer
+     *     processed no frames.
      * @param errorCode reason for closing the connection.
      * @param debugData only valid for http/2; opaque debug data to send.
      */
-    void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData);
+    void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData);
 
     /**
      * Notifies that an additional {@code windowSizeIncrement} bytes can be
@@ -84,7 +89,7 @@ void headers(boolean outFinished, boolean inFinished, int streamId, int associat
 
     /**
      * HTTP/2 only. Receive a push promise header block.
-     * <p/>
+     * <p>
      * A push promise contains all the headers that pertain to a server-initiated
      * request, and a {@code promisedStreamId} to which response frames will be
      * delivered. Push promise frames are sent as a part of the response to
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
similarity index 88%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
index e508c96f14..f96c2aa095 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/FrameWriter.java
@@ -19,16 +19,17 @@
 import java.io.Closeable;
 import java.io.IOException;
 import java.util.List;
+import okio.OkBuffer;
 
-/** Writes transport frames for SPDY/3 or HTTP/2.0. */
+/** Writes transport frames for SPDY/3 or HTTP/2. */
 public interface FrameWriter extends Closeable {
-  /** HTTP/2.0 only. */
+  /** HTTP/2 only. */
   void connectionHeader() throws IOException;
   void ackSettings() throws IOException;
 
   /**
    * HTTP/2 only. Send a push promise header block.
-   * <p/>
+   * <p>
    * A push promise contains all the headers that pertain to a server-initiated
    * request, and a {@code promisedStreamId} to which response frames will be
    * delivered. Push promise frames are sent as a part of the response to
@@ -56,28 +57,24 @@ void synReply(boolean outFinished, int streamId, List<Header> headerBlock)
   /**
    * {@code data.length} may be longer than the max length of the variant's data frame.
    * Implementations must send multiple frames as necessary.
+   *
+   * @param source the buffer to draw bytes from. May be null if byteCount is 0.
    */
-  void data(boolean outFinished, int streamId, byte[] data) throws IOException;
+  void data(boolean outFinished, int streamId, OkBuffer source, int byteCount) throws IOException;
 
-  /**
-   * {@code byteCount} may be longer than the max length of the variant's data frame.
-   * Implementations must send multiple frames as necessary.
-   */
-  void data(boolean outFinished, int streamId, byte[] data, int offset, int byteCount)
-      throws IOException;
+  void data(boolean outFinished, int streamId, OkBuffer source) throws IOException;
 
   /** Write okhttp's settings to the peer. */
   void settings(Settings okHttpSettings) throws IOException;
-  void noop() throws IOException;
 
   /**
    *  Send a connection-level ping to the peer.  {@code ack} indicates this is
    *  a reply.  Payload parameters are different between SPDY/3 and HTTP/2.
-   *  <p/>
+   *  <p>
    *  In SPDY/3, only the first {@code payload1} parameter is sent.  If the
    *  sender is a client, it is an unsigned odd number.  Likewise, a server
    *  will send an even number.
-   *  <p/>
+   *  <p>
    *  In HTTP/2, both {@code payload1} and {@code payload2} parameters are
    *  sent.  The data is opaque binary, and there are no rules on the content.
    */
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Header.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Header.java
similarity index 97%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Header.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Header.java
index 7b1f44b5c2..1e9b50312e 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Header.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Header.java
@@ -1,6 +1,6 @@
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.ByteString;
+import okio.ByteString;
 
 /** HTTP header: the name is an ASCII string, but the value can be UTF-8. */
 public final class Header {
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HeadersMode.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HeadersMode.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HeadersMode.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HeadersMode.java
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
similarity index 78%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
index 87ba091d7e..645f162ce3 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/HpackDraft05.java
@@ -1,16 +1,18 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.internal.BitArray;
-import com.squareup.okhttp.internal.ByteString;
-import com.squareup.okhttp.internal.Util;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashMap;
 import java.util.List;
-
-import static com.squareup.okhttp.internal.Util.asciiLowerCase;
+import java.util.Map;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.OkBuffer;
+import okio.Okio;
+import okio.Source;
 
 /**
  * Read and write HPACK v05.
@@ -24,7 +26,6 @@
 final class HpackDraft05 {
   private static final int PREFIX_6_BITS = 0x3f;
   private static final int PREFIX_7_BITS = 0x7f;
-  private static final int PREFIX_8_BITS = 0xff;
 
   private static final Header[] STATIC_HEADER_TABLE = new Header[] {
       new Header(Header.TARGET_AUTHORITY, ""),
@@ -96,8 +97,8 @@ private HpackDraft05() {
   static final class Reader {
     private final Huffman.Codec huffmanCodec;
 
-    private final InputStream in;
     private final List<Header> emittedHeaders = new ArrayList<Header>();
+    private final BufferedSource source;
     private int maxHeaderTableByteCount;
 
     // Visible for testing.
@@ -113,17 +114,15 @@ private HpackDraft05() {
     BitArray referencedHeaders = new BitArray.FixedCapacity();
 
     /**
-     * Set bit positions indicate {@code STATIC_HEADER_TABLE[pos]} should be
-     * emitted.
+     * Set bit positions indicate {@code headerTable[pos]} was already emitted.
      */
-    // Using a long since the static table < 64 entries.
-    long referencedStaticHeaders = 0L;
+    BitArray emittedReferencedHeaders = new BitArray.FixedCapacity();
     int headerTableByteCount = 0;
 
-    Reader(boolean client, int maxHeaderTableByteCount, InputStream in) {
+    Reader(boolean client, int maxHeaderTableByteCount, Source source) {
       this.huffmanCodec = client ? Huffman.Codec.RESPONSE : Huffman.Codec.REQUEST;
       this.maxHeaderTableByteCount = maxHeaderTableByteCount;
-      this.in = in;
+      this.source = Okio.buffer(source);
     }
 
     int maxHeaderTableByteCount() {
@@ -132,7 +131,7 @@ int maxHeaderTableByteCount() {
 
     /**
      * Called by the reader when the peer sent a new header table size setting.
-     * <p/>
+     * <p>
      * Evicts entries or clears the table as needed.
      */
     void maxHeaderTableByteCount(int newMaxHeaderTableByteCount) {
@@ -166,6 +165,7 @@ private int evictToRecoverBytes(int bytesToRecover) {
           entriesToEvict++;
         }
         referencedHeaders.shiftLeft(entriesToEvict);
+        emittedReferencedHeaders.shiftLeft(entriesToEvict);
         System.arraycopy(headerTable, nextHeaderIndex + 1, headerTable,
             nextHeaderIndex + 1 + entriesToEvict, headerCount);
         nextHeaderIndex += entriesToEvict;
@@ -178,8 +178,8 @@ private int evictToRecoverBytes(int bytesToRecover) {
      * set of emitted headers.
      */
     void readHeaders() throws IOException {
-      while (in.available() > 0) {
-        int b = in.read() & 0xff;
+      while (!source.exhausted()) {
+        int b = source.readByte() & 0xff;
         if (b == 0x80) { // 10000000
           clearReferenceSet();
         } else if ((b & 0x80) == 0x80) { // 1NNNNNNN
@@ -188,7 +188,7 @@ void readHeaders() throws IOException {
         } else { // 0NNNNNNN
           if (b == 0x40) { // 01000000
             readLiteralHeaderWithoutIndexingNewName();
-          } else if ((b & 0xe0) == 0x40) {  // 01NNNNNN
+          } else if ((b & 0x40) == 0x40) {  // 01NNNNNN
             int index = readInt(b, PREFIX_6_BITS);
             readLiteralHeaderWithoutIndexingIndexedName(index - 1);
           } else if (b == 0) { // 00000000
@@ -205,18 +205,13 @@ void readHeaders() throws IOException {
     }
 
     private void clearReferenceSet() {
-      referencedStaticHeaders = 0L;
       referencedHeaders.clear();
+      emittedReferencedHeaders.clear();
     }
 
     void emitReferenceSet() {
-      for (int i = 0; i < STATIC_HEADER_TABLE.length; ++i) {
-        if (((referencedStaticHeaders >> i) & 1L) == 1) {
-          emittedHeaders.add(STATIC_HEADER_TABLE[i]);
-        }
-      }
       for (int i = headerTable.length - 1; i != nextHeaderIndex; --i) {
-        if (referencedHeaders.get(i)) {
+        if (referencedHeaders.get(i) && !emittedReferencedHeaders.get(i)) {
           emittedHeaders.add(headerTable[i]);
         }
       }
@@ -229,19 +224,25 @@ void emitReferenceSet() {
     List<Header> getAndReset() {
       List<Header> result = new ArrayList<Header>(emittedHeaders);
       emittedHeaders.clear();
+      emittedReferencedHeaders.clear();
       return result;
     }
 
     private void readIndexedHeader(int index) {
       if (isStaticHeader(index)) {
+        Header staticEntry = STATIC_HEADER_TABLE[index - headerCount];
         if (maxHeaderTableByteCount == 0) {
-          referencedStaticHeaders |= (1L << (index - headerCount));
+          emittedHeaders.add(staticEntry);
         } else {
-          Header staticEntry = STATIC_HEADER_TABLE[index - headerCount];
           insertIntoHeaderTable(-1, staticEntry);
         }
       } else {
-        referencedHeaders.toggle(headerTableIndex(index));
+        int headerTableIndex = headerTableIndex(index);
+        if (!referencedHeaders.get(headerTableIndex)) { // When re-referencing, emit immediately.
+          emittedHeaders.add(headerTable[headerTableIndex]);
+          emittedReferencedHeaders.set(headerTableIndex);
+        }
+        referencedHeaders.toggle(headerTableIndex);
       }
     }
 
@@ -306,14 +307,17 @@ private void insertIntoHeaderTable(int index, Header entry) {
       int bytesToRecover = (headerTableByteCount + delta) - maxHeaderTableByteCount;
       int entriesEvicted = evictToRecoverBytes(bytesToRecover);
 
-      if (index == -1) {
-        if (headerCount + 1 > headerTable.length) {
+      if (index == -1) { // Adding a value to the header table.
+        if (headerCount + 1 > headerTable.length) { // Need to grow the header table.
           Header[] doubled = new Header[headerTable.length * 2];
           System.arraycopy(headerTable, 0, doubled, headerTable.length, headerTable.length);
           if (doubled.length == 64) {
             referencedHeaders = ((BitArray.FixedCapacity) referencedHeaders).toVariableCapacity();
+            emittedReferencedHeaders =
+                ((BitArray.FixedCapacity) emittedReferencedHeaders).toVariableCapacity();
           }
           referencedHeaders.shiftLeft(headerTable.length);
+          emittedReferencedHeaders.shiftLeft(headerTable.length);
           nextHeaderIndex = headerTable.length - 1;
           headerTable = doubled;
         }
@@ -330,7 +334,7 @@ private void insertIntoHeaderTable(int index, Header entry) {
     }
 
     private int readByte() throws IOException {
-      return in.read() & 0xff;
+      return source.readByte() & 0xff;
     }
 
     int readInt(int firstByte, int prefixMask) throws IOException {
@@ -361,33 +365,57 @@ int readInt(int firstByte, int prefixMask) throws IOException {
      */
     ByteString readByteString(boolean asciiLowercase) throws IOException {
       int firstByte = readByte();
-      int length = readInt(firstByte, PREFIX_8_BITS);
-      if ((length & 0x80) == 0x80) { // 1NNNNNNN
-        length &= ~0x80;
-        byte[] buff = new byte[length];
-        Util.readFully(in, buff);
-        buff = huffmanCodec.decode(buff); // TODO: streaming Huffman!
-        if (asciiLowercase) asciiLowerCase(buff);
-        return ByteString.of(buff);
+      boolean huffmanDecode = (firstByte & 0x80) == 0x80; // 1NNNNNNN
+      int length = readInt(firstByte, PREFIX_7_BITS);
+
+      ByteString byteString = source.readByteString(length);
+
+      if (huffmanDecode) {
+        byteString = huffmanCodec.decode(byteString); // TODO: streaming Huffman!
+      }
+
+      if (asciiLowercase) {
+        byteString = byteString.toAsciiLowercase();
+      }
+
+      return byteString;
+    }
+  }
+
+  private static final Map<ByteString, Integer> NAME_TO_FIRST_INDEX = nameToFirstIndex();
+
+  private static Map<ByteString, Integer> nameToFirstIndex() {
+    Map<ByteString, Integer> result =
+        new LinkedHashMap<ByteString, Integer>(STATIC_HEADER_TABLE.length);
+    for (int i = 0; i < STATIC_HEADER_TABLE.length; i++) {
+      if (!result.containsKey(STATIC_HEADER_TABLE[i].name)) {
+        result.put(STATIC_HEADER_TABLE[i].name, i);
       }
-      return length == 0 ? ByteString.EMPTY
-          : asciiLowercase ? ByteString.readLowerCase(in, length) : ByteString.read(in, length);
     }
+    return Collections.unmodifiableMap(result);
   }
 
   static final class Writer {
-    private final OutputStream out;
+    private final OkBuffer out;
 
-    Writer(OutputStream out) {
+    Writer(OkBuffer out) {
       this.out = out;
     }
 
     void writeHeaders(List<Header> headerBlock) throws IOException {
-      // TODO: implement a compression strategy.
+      // TODO: implement index tracking
       for (int i = 0, size = headerBlock.size(); i < size; i++) {
-        out.write(0x40); // Literal Header without Indexing - New Name.
-        writeByteString(headerBlock.get(i).name);
-        writeByteString(headerBlock.get(i).value);
+        ByteString name = headerBlock.get(i).name;
+        Integer staticIndex = NAME_TO_FIRST_INDEX.get(name);
+        if (staticIndex != null) {
+          // Literal Header Field without Indexing - Indexed Name.
+          writeInt(staticIndex + 1, PREFIX_6_BITS, 0x40);
+          writeByteString(headerBlock.get(i).value);
+        } else {
+          out.writeByte(0x40); // Literal Header without Indexing - New Name.
+          writeByteString(name);
+          writeByteString(headerBlock.get(i).value);
+        }
       }
     }
 
@@ -395,26 +423,26 @@ void writeHeaders(List<Header> headerBlock) throws IOException {
     void writeInt(int value, int prefixMask, int bits) throws IOException {
       // Write the raw value for a single byte value.
       if (value < prefixMask) {
-        out.write(bits | value);
+        out.writeByte(bits | value);
         return;
       }
 
       // Write the mask to start a multibyte value.
-      out.write(bits | prefixMask);
+      out.writeByte(bits | prefixMask);
       value -= prefixMask;
 
       // Write 7 bits at a time 'til we're done.
       while (value >= 0x80) {
         int b = value & 0x7f;
-        out.write(b | 0x80);
+        out.writeByte(b | 0x80);
         value >>>= 7;
       }
-      out.write(value);
+      out.writeByte(value);
     }
 
     void writeByteString(ByteString data) throws IOException {
-      writeInt(data.size(), PREFIX_8_BITS, 0);
-      data.write(out);
+      writeInt(data.size(), PREFIX_7_BITS, 0);
+      out.write(data);
     }
   }
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
similarity index 68%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
index ada0d6b2f7..a88b747ef1 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Http20Draft09.java
@@ -16,16 +16,14 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.EOFException;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.util.Arrays;
 import java.util.List;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Deadline;
+import okio.OkBuffer;
+import okio.Source;
 
 /**
  * Read and write http/2 v09 frames.
@@ -37,19 +35,8 @@
     return Protocol.HTTP_2;
   }
 
-  // http://tools.ietf.org/html/draft-ietf-httpbis-http2-09#section-6.5
-  static Settings defaultSettings(boolean client) {
-    Settings settings = new Settings();
-    settings.set(Settings.HEADER_TABLE_SIZE, 0, 4096);
-    if (client) { // client specifies whether or not it accepts push.
-      settings.set(Settings.ENABLE_PUSH, 0, 1);
-    }
-    settings.set(Settings.INITIAL_WINDOW_SIZE, 0, 65535);
-    return settings;
-  }
-
-  private static final byte[] CONNECTION_HEADER =
-      "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n".getBytes(Util.UTF_8);
+  private static final ByteString CONNECTION_HEADER
+      = ByteString.encodeUtf8("PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n");
 
   static final byte TYPE_DATA = 0x0;
   static final byte TYPE_HEADERS = 0x1;
@@ -69,49 +56,51 @@ static Settings defaultSettings(boolean client) {
   static final byte FLAG_END_PUSH_PROMISE = 0x4;
   static final byte FLAG_PRIORITY = 0x8;
 
-  @Override public FrameReader newReader(InputStream in, boolean client) {
-    return new Reader(in, 4096, client);
+  @Override public FrameReader newReader(BufferedSource source, boolean client) {
+    return new Reader(source, 4096, client);
   }
 
-  @Override public FrameWriter newWriter(OutputStream out, boolean client) {
-    return new Writer(out, client);
+  @Override public FrameWriter newWriter(BufferedSink sink, boolean client) {
+    return new Writer(sink, client);
+  }
+
+  @Override public int maxFrameSize() {
+    return 16383;
   }
 
   static final class Reader implements FrameReader {
-    private final DataInputStream in;
-    private final ContinuationInputStream continuation;
+    private final BufferedSource source;
+    private final ContinuationSource continuation;
     private final boolean client;
 
     // Visible for testing.
     final HpackDraft05.Reader hpackReader;
 
-    Reader(InputStream in, int headerTableSize, boolean client) {
-      this.in = new DataInputStream(in);
+    Reader(BufferedSource source, int headerTableSize, boolean client) {
+      this.source = source;
       this.client = client;
-      this.continuation = new ContinuationInputStream(this.in);
+      this.continuation = new ContinuationSource(this.source);
       this.hpackReader = new HpackDraft05.Reader(client, headerTableSize, continuation);
     }
 
     @Override public void readConnectionHeader() throws IOException {
       if (client) return; // Nothing to read; servers don't send connection headers!
-      byte[] connectionHeader = new byte[CONNECTION_HEADER.length];
-      Util.readFully(in, connectionHeader);
-      if (!Arrays.equals(connectionHeader, CONNECTION_HEADER)) {
-        throw ioException("Expected a connection header but was %s",
-            Arrays.toString(connectionHeader));
+      ByteString connectionHeader = source.readByteString(CONNECTION_HEADER.size());
+      if (!CONNECTION_HEADER.equals(connectionHeader)) {
+        throw ioException("Expected a connection header but was %s", connectionHeader.utf8());
       }
     }
 
     @Override public boolean nextFrame(Handler handler) throws IOException {
       int w1;
+      int w2;
       try {
-        w1 = in.readInt();
+        w1 = source.readInt();
+        w2 = source.readInt();
       } catch (IOException e) {
         return false; // This might be a normal socket close.
       }
 
-      int w2 = in.readInt();
-
       // boolean r = (w1 & 0xc0000000) != 0; // Reserved: Ignore first 2 bits.
       short length = (short) ((w1 & 0x3fff0000) >> 16); // 14-bit unsigned == max 16383
       byte type = (byte) ((w1 & 0xff00) >> 8);
@@ -158,7 +147,7 @@ static Settings defaultSettings(boolean client) {
 
         default:
           // Implementations MUST ignore frames of unsupported or unrecognized types.
-          Util.skipByReading(in, length);
+          source.skip(length);
       }
       return true;
     }
@@ -171,7 +160,7 @@ private void readHeaders(Handler handler, short length, byte flags, int streamId
 
       int priority = -1;
       if ((flags & FLAG_PRIORITY) != 0) {
-        priority = in.readInt() & 0x7fffffff;
+        priority = source.readInt() & 0x7fffffff;
         length -= 4; // account for above read.
       }
 
@@ -198,14 +187,14 @@ private void readData(Handler handler, short length, byte flags, int streamId)
         throws IOException {
       boolean inFinished = (flags & FLAG_END_STREAM) != 0;
       // TODO: checkState open or half-closed (local) or raise STREAM_CLOSED
-      handler.data(inFinished, streamId, in, length);
+      handler.data(inFinished, streamId, source, length);
     }
 
     private void readPriority(Handler handler, short length, byte flags, int streamId)
         throws IOException {
       if (length != 4) throw ioException("TYPE_PRIORITY length: %d != 4", length);
       if (streamId == 0) throw ioException("TYPE_PRIORITY streamId == 0");
-      int w1 = in.readInt();
+      int w1 = source.readInt();
       // boolean r = (w1 & 0x80000000) != 0; // Reserved.
       int priority = (w1 & 0x7fffffff);
       handler.priority(streamId, priority);
@@ -215,7 +204,7 @@ private void readRstStream(Handler handler, short length, byte flags, int stream
         throws IOException {
       if (length != 4) throw ioException("TYPE_RST_STREAM length: %d != 4", length);
       if (streamId == 0) throw ioException("TYPE_RST_STREAM streamId == 0");
-      int errorCodeInt = in.readInt();
+      int errorCodeInt = source.readInt();
       ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
       if (errorCode == null) {
         throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
@@ -225,16 +214,18 @@ private void readRstStream(Handler handler, short length, byte flags, int stream
 
     private void readSettings(Handler handler, short length, byte flags, int streamId)
         throws IOException {
+      if (streamId != 0) throw ioException("TYPE_SETTINGS streamId != 0");
       if ((flags & FLAG_ACK) != 0) {
         if (length != 0) throw ioException("FRAME_SIZE_ERROR ack frame should be empty!");
+        handler.ackSettings();
+        return;
       }
 
       if (length % 8 != 0) throw ioException("TYPE_SETTINGS length %% 8 != 0: %s", length);
-      if (streamId != 0) throw ioException("TYPE_SETTINGS streamId != 0");
       Settings settings = new Settings();
       for (int i = 0; i < length; i += 8) {
-        int w1 = in.readInt();
-        int value = in.readInt();
+        int w1 = source.readInt();
+        int value = source.readInt();
         // int r = (w1 & 0xff000000) >>> 24; // Reserved.
         int id = w1 & 0xffffff;
         settings.set(id, 0, value);
@@ -250,7 +241,7 @@ private void readPushPromise(Handler handler, short length, byte flags, int stre
       if (streamId == 0) {
         throw ioException("PROTOCOL_ERROR: TYPE_PUSH_PROMISE streamId == 0");
       }
-      int promisedStreamId = in.readInt() & 0x7fffffff;
+      int promisedStreamId = source.readInt() & 0x7fffffff;
       length -= 4; // account for above read.
       List<Header> headerBlock = readHeaderBlock(length, flags, streamId);
       handler.pushPromise(streamId, promisedStreamId, headerBlock);
@@ -260,8 +251,8 @@ private void readPing(Handler handler, short length, byte flags, int streamId)
         throws IOException {
       if (length != 8) throw ioException("TYPE_PING length != 8: %s", length);
       if (streamId != 0) throw ioException("TYPE_PING streamId != 0");
-      int payload1 = in.readInt();
-      int payload2 = in.readInt();
+      int payload1 = source.readInt();
+      int payload2 = source.readInt();
       boolean ack = (flags & FLAG_ACK) != 0;
       handler.ping(ack, payload1, payload2);
     }
@@ -270,17 +261,16 @@ private void readGoAway(Handler handler, short length, byte flags, int streamId)
         throws IOException {
       if (length < 8) throw ioException("TYPE_GOAWAY length < 8: %s", length);
       if (streamId != 0) throw ioException("TYPE_GOAWAY streamId != 0");
-      int lastStreamId = in.readInt();
-      int errorCodeInt = in.readInt();
+      int lastStreamId = source.readInt();
+      int errorCodeInt = source.readInt();
       int opaqueDataLength = length - 8;
       ErrorCode errorCode = ErrorCode.fromHttp2(errorCodeInt);
       if (errorCode == null) {
         throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
       }
-      byte[] debugData = Util.EMPTY_BYTE_ARRAY;
+      ByteString debugData = ByteString.EMPTY;
       if (opaqueDataLength > 0) { // Must read debug data in order to not corrupt the connection.
-        debugData = new byte[opaqueDataLength];
-        Util.readFully(in, debugData);
+        debugData = source.readByteString(opaqueDataLength);
       }
       handler.goAway(lastStreamId, errorCode, debugData);
     }
@@ -288,127 +278,139 @@ private void readGoAway(Handler handler, short length, byte flags, int streamId)
     private void readWindowUpdate(Handler handler, short length, byte flags, int streamId)
         throws IOException {
       if (length != 4) throw ioException("TYPE_WINDOW_UPDATE length !=4: %s", length);
-      long increment = (in.readInt() & 0x7fffffff);
+      long increment = (source.readInt() & 0x7fffffff);
       if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
       handler.windowUpdate(streamId, increment);
     }
 
     @Override public void close() throws IOException {
-      in.close();
+      source.close();
     }
   }
 
   static final class Writer implements FrameWriter {
-    private final DataOutputStream out;
+    private final BufferedSink sink;
     private final boolean client;
-    private final ByteArrayOutputStream hpackBuffer;
+    private final OkBuffer hpackBuffer;
     private final HpackDraft05.Writer hpackWriter;
+    private boolean closed;
 
-    Writer(OutputStream out, boolean client) {
-      this.out = new DataOutputStream(out);
+    Writer(BufferedSink sink, boolean client) {
+      this.sink = sink;
       this.client = client;
-      this.hpackBuffer = new ByteArrayOutputStream();
+      this.hpackBuffer = new OkBuffer();
       this.hpackWriter = new HpackDraft05.Writer(hpackBuffer);
     }
 
     @Override public synchronized void flush() throws IOException {
-      out.flush();
+      if (closed) throw new IOException("closed");
+      sink.flush();
     }
 
     @Override public synchronized void ackSettings() throws IOException {
+      if (closed) throw new IOException("closed");
       int length = 0;
       byte type = TYPE_SETTINGS;
       byte flags = FLAG_ACK;
       int streamId = 0;
       frameHeader(length, type, flags, streamId);
+      sink.flush();
     }
 
     @Override public synchronized void connectionHeader() throws IOException {
+      if (closed) throw new IOException("closed");
       if (!client) return; // Nothing to write; servers don't send connection headers!
-      out.write(CONNECTION_HEADER);
+      sink.write(CONNECTION_HEADER.toByteArray());
+      sink.flush();
     }
 
-    @Override
-    public synchronized void synStream(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, int slot, List<Header> headerBlock)
+    @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
+        int streamId, int associatedStreamId, int priority, int slot, List<Header> headerBlock)
         throws IOException {
       if (inFinished) throw new UnsupportedOperationException();
+      if (closed) throw new IOException("closed");
       headers(outFinished, streamId, priority, headerBlock);
     }
 
     @Override public synchronized void synReply(boolean outFinished, int streamId,
         List<Header> headerBlock) throws IOException {
+      if (closed) throw new IOException("closed");
       headers(outFinished, streamId, -1, headerBlock);
     }
 
     @Override public synchronized void headers(int streamId, List<Header> headerBlock)
         throws IOException {
+      if (closed) throw new IOException("closed");
       headers(false, streamId, -1, headerBlock);
     }
 
-    @Override
-    public synchronized void pushPromise(int streamId, int promisedStreamId,
-        List<Header> requestHeaders)
-        throws IOException {
-      hpackBuffer.reset();
+    @Override public synchronized void pushPromise(int streamId, int promisedStreamId,
+        List<Header> requestHeaders) throws IOException {
+      if (closed) throw new IOException("closed");
+      if (hpackBuffer.size() != 0) throw new IllegalStateException();
       hpackWriter.writeHeaders(requestHeaders);
 
-      int length = 4 + hpackBuffer.size();
+      int length = (int) (4 + hpackBuffer.size());
       byte type = TYPE_PUSH_PROMISE;
       byte flags = FLAG_END_HEADERS;
       frameHeader(length, type, flags, streamId); // TODO: CONTINUATION
-      out.writeInt(promisedStreamId & 0x7fffffff);
-      hpackBuffer.writeTo(out);
+      sink.writeInt(promisedStreamId & 0x7fffffff);
+      sink.write(hpackBuffer, hpackBuffer.size());
     }
 
     private void headers(boolean outFinished, int streamId, int priority,
         List<Header> headerBlock) throws IOException {
-      hpackBuffer.reset();
+      if (closed) throw new IOException("closed");
+      if (hpackBuffer.size() != 0) throw new IllegalStateException();
       hpackWriter.writeHeaders(headerBlock);
 
-      int length = hpackBuffer.size();
+      int length = (int) hpackBuffer.size();
       byte type = TYPE_HEADERS;
       byte flags = FLAG_END_HEADERS;
       if (outFinished) flags |= FLAG_END_STREAM;
       if (priority != -1) flags |= FLAG_PRIORITY;
       if (priority != -1) length += 4;
       frameHeader(length, type, flags, streamId); // TODO: CONTINUATION
-      if (priority != -1) out.writeInt(priority & 0x7fffffff);
-      hpackBuffer.writeTo(out);
+      if (priority != -1) sink.writeInt(priority & 0x7fffffff);
+      sink.write(hpackBuffer, hpackBuffer.size());
     }
 
     @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
         throws IOException {
+      if (closed) throw new IOException("closed");
       if (errorCode.spdyRstCode == -1) throw new IllegalArgumentException();
 
       int length = 4;
       byte type = TYPE_RST_STREAM;
       byte flags = FLAG_NONE;
       frameHeader(length, type, flags, streamId);
-      out.writeInt(errorCode.httpCode);
-      out.flush();
+      sink.writeInt(errorCode.httpCode);
+      sink.flush();
     }
 
-    @Override public synchronized void data(boolean outFinished, int streamId, byte[] data)
+    @Override public synchronized void data(boolean outFinished, int streamId, OkBuffer source)
         throws IOException {
-      data(outFinished, streamId, data, 0, data.length);
+      data(outFinished, streamId, source, (int) source.size());
     }
 
-    @Override public synchronized void data(boolean outFinished, int streamId, byte[] data,
-        int offset, int byteCount) throws IOException {
+    @Override public synchronized void data(boolean outFinished, int streamId, OkBuffer source,
+        int byteCount) throws IOException {
+      if (closed) throw new IOException("closed");
       byte flags = FLAG_NONE;
       if (outFinished) flags |= FLAG_END_STREAM;
-      dataFrame(streamId, flags, data, offset, byteCount); // TODO: Implement looping strategy
+      dataFrame(streamId, flags, source, byteCount);
     }
 
-    void dataFrame(int streamId, byte flags, byte[] data, int offset, int length)
-        throws IOException {
+    void dataFrame(int streamId, byte flags, OkBuffer buffer, int byteCount) throws IOException {
       byte type = TYPE_DATA;
-      frameHeader(length, type, flags, streamId);
-      out.write(data, offset, length);
+      frameHeader(byteCount, type, flags, streamId);
+      if (byteCount > 0) {
+        sink.write(buffer, byteCount);
+      }
     }
 
     @Override public synchronized void settings(Settings settings) throws IOException {
+      if (closed) throw new IOException("closed");
       int length = settings.size() * 8;
       byte type = TYPE_SETTINGS;
       byte flags = FLAG_NONE;
@@ -416,44 +418,45 @@ void dataFrame(int streamId, byte flags, byte[] data, int offset, int length)
       frameHeader(length, type, flags, streamId);
       for (int i = 0; i < Settings.COUNT; i++) {
         if (!settings.isSet(i)) continue;
-        out.writeInt(i & 0xffffff);
-        out.writeInt(settings.get(i));
+        sink.writeInt(i & 0xffffff);
+        sink.writeInt(settings.get(i));
       }
-    }
-
-    @Override public synchronized void noop() throws IOException {
-      throw new UnsupportedOperationException();
+      sink.flush();
     }
 
     @Override public synchronized void ping(boolean ack, int payload1, int payload2)
         throws IOException {
+      if (closed) throw new IOException("closed");
       int length = 8;
       byte type = TYPE_PING;
       byte flags = ack ? FLAG_ACK : FLAG_NONE;
       int streamId = 0;
       frameHeader(length, type, flags, streamId);
-      out.writeInt(payload1);
-      out.writeInt(payload2);
+      sink.writeInt(payload1);
+      sink.writeInt(payload2);
+      sink.flush();
     }
 
-    @Override
-    public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
-        throws IOException {
+    @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode,
+        byte[] debugData) throws IOException {
+      if (closed) throw new IOException("closed");
       if (errorCode.httpCode == -1) throw illegalArgument("errorCode.httpCode == -1");
       int length = 8 + debugData.length;
       byte type = TYPE_GOAWAY;
       byte flags = FLAG_NONE;
       int streamId = 0;
       frameHeader(length, type, flags, streamId);
-      out.writeInt(lastGoodStreamId);
-      out.writeInt(errorCode.httpCode);
+      sink.writeInt(lastGoodStreamId);
+      sink.writeInt(errorCode.httpCode);
       if (debugData.length > 0) {
-        out.write(debugData);
+        sink.write(debugData);
       }
+      sink.flush();
     }
 
     @Override public synchronized void windowUpdate(int streamId, long windowSizeIncrement)
         throws IOException {
+      if (closed) throw new IOException("closed");
       if (windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL) {
         throw illegalArgument("windowSizeIncrement == 0 || windowSizeIncrement > 0x7fffffffL: %s",
             windowSizeIncrement);
@@ -462,20 +465,20 @@ public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[
       byte type = TYPE_WINDOW_UPDATE;
       byte flags = FLAG_NONE;
       frameHeader(length, type, flags, streamId);
-      out.writeInt((int) windowSizeIncrement);
+      sink.writeInt((int) windowSizeIncrement);
+      sink.flush();
     }
 
-    @Override public void close() throws IOException {
-      out.close();
+    @Override public synchronized void close() throws IOException {
+      closed = true;
+      sink.close();
     }
 
-    private void frameHeader(int length, byte type, byte flags, int streamId)
-        throws IOException {
+    void frameHeader(int length, byte type, byte flags, int streamId) throws IOException {
       if (length > 16383) throw illegalArgument("FRAME_SIZE_ERROR length > 16383: %s", length);
-      if ((streamId & 0x80000000) == 1) throw illegalArgument("(streamId & 0x80000000) == 1: %s",
-          streamId);
-      out.writeInt((length & 0x3fff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
-      out.writeInt(streamId & 0x7fffffff);
+      if ((streamId & 0x80000000) != 0) throw illegalArgument("reserved bit set: %s", streamId);
+      sink.writeInt((length & 0x3fff) << 16 | (type & 0xff) << 8 | (flags & 0xff));
+      sink.writeInt(streamId & 0x7fffffff);
     }
   }
 
@@ -488,11 +491,12 @@ private static IOException ioException(String message, Object... args) throws IO
   }
 
   /**
-   * Decompression of the header block occurs above the framing layer.  This class lazily reads
-   * continuation frames as they are needed by {@link HpackDraft05.Reader#readHeaders()}.
+   * Decompression of the header block occurs above the framing layer. This
+   * class lazily reads continuation frames as they are needed by {@link
+   * HpackDraft05.Reader#readHeaders()}.
    */
-  static final class ContinuationInputStream extends InputStream {
-    private final DataInputStream in;
+  static final class ContinuationSource implements Source {
+    private final BufferedSource source;
 
     int length;
     byte flags;
@@ -500,65 +504,35 @@ private static IOException ioException(String message, Object... args) throws IO
 
     int left;
 
-    ContinuationInputStream(DataInputStream in) {
-      this.in = in;
+    public ContinuationSource(BufferedSource source) {
+      this.source = source;
     }
 
-    @Override public int read() throws IOException {
-      if (left == 0) {
-        if (endHeaders()) {
-          throw eofReading(1);
-        } else {
-          readContinuationHeader();
-        }
+    @Override public long read(OkBuffer sink, long byteCount) throws IOException {
+      while (left == 0) {
+        if ((flags & FLAG_END_HEADERS) != 0) return -1;
+        readContinuationHeader();
+        // TODO: test case for empty continuation header?
       }
-      left--;
-      return in.read();
+
+      long read = source.read(sink, Math.min(byteCount, left));
+      if (read == -1) return -1;
+      left -= read;
+      return read;
     }
 
-    @Override public int available() throws IOException {
-      if (left == 0) {
-        if (endHeaders()) {
-          return 0;
-        } else {
-          readContinuationHeader();
-        }
-      }
-      return left;
-    }
-
-    @Override public int read(byte[] dst, int offset, int byteCount) throws IOException {
-      if (byteCount > left) {
-        if (endHeaders()) {
-          throw eofReading(byteCount);
-        } else {
-          int beforeContinuation = left;
-          Util.readFully(in, dst, offset, beforeContinuation);
-          readContinuationHeader();
-          int afterContinuation = byteCount - beforeContinuation;
-          offset += beforeContinuation;
-          Util.readFully(in, dst, offset, afterContinuation);
-          left -= afterContinuation;
-          return byteCount;
-        }
-      } else {
-        Util.readFully(in, dst, offset, byteCount);
-        left -= byteCount;
-        return byteCount;
-      }
+    @Override public Source deadline(Deadline deadline) {
+      source.deadline(deadline);
+      return this;
     }
 
-    private EOFException eofReading(int byteCount) throws EOFException {
-      int read = length - left;
-      throw new EOFException(
-          String.format("EOF reading %s more bytes; read %s/%s of frame.", byteCount, read,
-              length));
+    @Override public void close() throws IOException {
     }
 
     private void readContinuationHeader() throws IOException {
       int previousStreamId = streamId;
-      int w1 = in.readInt();
-      int w2 = in.readInt();
+      int w1 = source.readInt();
+      int w2 = source.readInt();
       length = left = (short) ((w1 & 0x3fff0000) >> 16);
       byte type = (byte) ((w1 & 0xff00) >> 8);
       flags = (byte) (w1 & 0xff);
@@ -566,9 +540,5 @@ private void readContinuationHeader() throws IOException {
       if (type != TYPE_CONTINUATION) throw ioException("%s != TYPE_CONTINUATION", type);
       if (streamId != previousStreamId) throw ioException("TYPE_CONTINUATION streamId changed");
     }
-
-    private boolean endHeaders() {
-      return (flags & FLAG_END_HEADERS) != 0;
-    }
   }
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
similarity index 98%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
index a7768d0ae3..45d882f6e4 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Huffman.java
@@ -18,6 +18,7 @@
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
+import okio.ByteString;
 
 /**
  * This class was originally composed from the following classes in
@@ -84,6 +85,10 @@ int encodedLength(byte[] bytes) {
       return (int) ((len + 7) >> 3);
     }
 
+    ByteString decode(ByteString buf) throws IOException {
+      return ByteString.of(decode(buf.toByteArray()));
+    }
+
     byte[] decode(byte[] buf) throws IOException {
       // FIXME
       ByteArrayOutputStream baos = new ByteArrayOutputStream();
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/IncomingStreamHandler.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/IncomingStreamHandler.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/IncomingStreamHandler.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/IncomingStreamHandler.java
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
new file mode 100644
index 0000000000..293d817a19
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/NameValueBlockReader.java
@@ -0,0 +1,113 @@
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.zip.DataFormatException;
+import java.util.zip.Inflater;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.Deadline;
+import okio.InflaterSource;
+import okio.OkBuffer;
+import okio.Okio;
+import okio.Source;
+
+/**
+ * Reads a SPDY/3 Name/Value header block. This class is made complicated by the
+ * requirement that we're strict with which bytes we put in the compressed bytes
+ * buffer. We need to put all compressed bytes into that buffer -- but no other
+ * bytes.
+ */
+class NameValueBlockReader {
+  /** This source transforms compressed bytes into uncompressed bytes. */
+  private final InflaterSource inflaterSource;
+
+  /**
+   * How many compressed bytes must be read into inflaterSource before
+   * {@link #readNameValueBlock} returns.
+   */
+  private int compressedLimit;
+
+  /** This source holds inflated bytes. */
+  private final BufferedSource source;
+
+  public NameValueBlockReader(final BufferedSource source) {
+    // Limit the inflater input stream to only those bytes in the Name/Value
+    // block. We cut the inflater off at its source because we can't predict the
+    // ratio of compressed bytes to uncompressed bytes.
+    Source throttleSource = new Source() {
+      @Override public long read(OkBuffer sink, long byteCount)
+          throws IOException {
+        if (compressedLimit == 0) return -1; // Out of data for the current block.
+        long read = source.read(sink, Math.min(byteCount, compressedLimit));
+        if (read == -1) return -1;
+        compressedLimit -= read;
+        return read;
+      }
+
+      @Override public void close() throws IOException {
+        source.close();
+      }
+
+      @Override public Source deadline(Deadline deadline) {
+        source.deadline(deadline);
+        return this;
+      }
+    };
+
+    // Subclass inflater to install a dictionary when it's needed.
+    Inflater inflater = new Inflater() {
+      @Override public int inflate(byte[] buffer, int offset, int count)
+          throws DataFormatException {
+        int result = super.inflate(buffer, offset, count);
+        if (result == 0 && needsDictionary()) {
+          setDictionary(Spdy3.DICTIONARY);
+          result = super.inflate(buffer, offset, count);
+        }
+        return result;
+      }
+    };
+
+    this.inflaterSource = new InflaterSource(throttleSource, inflater);
+    this.source = Okio.buffer(inflaterSource);
+  }
+
+  public List<Header> readNameValueBlock(int length) throws IOException {
+    this.compressedLimit += length;
+
+    int numberOfPairs = source.readInt();
+    if (numberOfPairs < 0) throw new IOException("numberOfPairs < 0: " + numberOfPairs);
+    if (numberOfPairs > 1024) throw new IOException("numberOfPairs > 1024: " + numberOfPairs);
+
+    List<Header> entries = new ArrayList<Header>(numberOfPairs);
+    for (int i = 0; i < numberOfPairs; i++) {
+      ByteString name = readByteString().toAsciiLowercase();
+      ByteString values = readByteString();
+      if (name.size() == 0) throw new IOException("name.size == 0");
+      entries.add(new Header(name, values));
+    }
+
+    doneReading();
+    return entries;
+  }
+
+  private ByteString readByteString() throws IOException {
+    int length = source.readInt();
+    return source.readByteString(length);
+  }
+
+  private void doneReading() throws IOException {
+    // Move any outstanding unread bytes into the inflater. One side-effect of
+    // deflate compression is that sometimes there are bytes remaining in the
+    // stream after we've consumed all of the content.
+    if (compressedLimit > 0) {
+      inflaterSource.refill();
+      if (compressedLimit != 0) throw new IOException("compressedLimit > 0: " + compressedLimit);
+    }
+  }
+
+  public void close() throws IOException {
+    source.close();
+  }
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java
similarity index 100%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Ping.java
diff --git a/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java
new file mode 100644
index 0000000000..8eecf6b848
--- /dev/null
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/PushObserver.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.internal.spdy;
+
+import java.io.IOException;
+import java.util.List;
+import okio.BufferedSource;
+
+/**
+ * {@link com.squareup.okhttp.Protocol#HTTP_2 HTTP/2} only.
+ * Processes server-initiated HTTP requests on the client.
+ *
+ * <p>Use the stream ID to correlate response headers and data.
+ *
+ * <p>Return true to request cancellation of a pushed stream.  Note that this
+ * does not guarantee future frames won't arrive on the stream ID.
+ */
+public interface PushObserver {
+  /**
+   * Describes the request that the server intends to push a response for.
+   *
+   * @param streamId server-initiated stream ID: an even number.
+   * @param requestHeaders minimally includes {@code :method}, {@code :scheme},
+   * {@code :authority}, and (@code :path}.
+   */
+  boolean onRequest(int streamId, List<Header> requestHeaders);
+
+  /**
+   * The response headers corresponding to a pushed request.  When {@code last}
+   * is true, there are no data frames to follow.
+   *
+   * @param streamId server-initiated stream ID: an even number.
+   * @param responseHeaders minimally includes {@code :status}.
+   * @param last when true, there is no response data.
+   */
+  boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last);
+
+  /**
+   * A chunk of response data corresponding to a pushed request.  This data
+   * must either be read or skipped.
+   *
+   * @param streamId server-initiated stream ID: an even number.
+   * @param source location of data corresponding with this stream ID.
+   * @param byteCount number of bytes to read or skip from the source.
+   * @param last when true, there are no data frames to follow.
+   */
+  boolean onData(int streamId, BufferedSource source, int byteCount, boolean last)
+      throws IOException;
+
+  /** Indicates the reason why this stream was cancelled. */
+  void onReset(int streamId, ErrorCode errorCode);
+
+  PushObserver CANCEL = new PushObserver() {
+
+    @Override public boolean onRequest(int streamId, List<Header> requestHeaders) {
+      return true;
+    }
+
+    @Override public boolean onHeaders(int streamId, List<Header> responseHeaders, boolean last) {
+      return true;
+    }
+
+    @Override public boolean onData(int streamId, BufferedSource source, int byteCount,
+        boolean last) throws IOException {
+      source.skip(byteCount);
+      return true;
+    }
+
+    @Override public void onReset(int streamId, ErrorCode errorCode) {
+    }
+  };
+}
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
similarity index 93%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
index f886b1b2ad..bf430882ec 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Settings.java
@@ -22,6 +22,12 @@
  * Settings are {@link com.squareup.okhttp.internal.spdy.SpdyConnection connection} scoped.
  */
 final class Settings {
+  /**
+   * From the SPDY/3 and HTTP/2 specs, the default initial window size for all
+   * streams is 64 KiB. (Chrome 25 uses 10 MiB).
+   */
+  static final int DEFAULT_INITIAL_WINDOW_SIZE = 64 * 1024;
+
   /** Peer request to clear durable settings. */
   static final int FLAG_CLEAR_PREVIOUSLY_PERSISTED_SETTINGS = 0x1;
 
@@ -76,9 +82,9 @@ void clear() {
     Arrays.fill(values, 0);
   }
 
-  void set(int id, int idFlags, int value) {
+  Settings set(int id, int idFlags, int value) {
     if (id >= values.length) {
-      return; // Discard unknown settings.
+      return this; // Discard unknown settings.
     }
 
     int bit = 1 << id;
@@ -95,6 +101,7 @@ void set(int id, int idFlags, int value) {
     }
 
     values[id] = value;
+    return this;
   }
 
   /** Returns true if a value has been assigned for the setting {@code id}. */
@@ -170,11 +177,9 @@ int getDownloadRetransRate(int defaultValue) {
     return (bit & set) != 0 ? values[DOWNLOAD_RETRANS_RATE] : defaultValue;
   }
 
-  // TODO: honor this setting in http/2.
-  /** Returns -1 if unset. */
-  int getInitialWindowSize() {
+  int getInitialWindowSize(int defaultValue) {
     int bit = 1 << INITIAL_WINDOW_SIZE;
-    return (bit & set) != 0 ? values[INITIAL_WINDOW_SIZE] : -1;
+    return (bit & set) != 0 ? values[INITIAL_WINDOW_SIZE] : defaultValue;
   }
 
   /** spdy/3 only. */
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
similarity index 69%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
index e20c9d7103..a71bc6f5fc 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Spdy3.java
@@ -16,43 +16,38 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.Protocol;
-import com.squareup.okhttp.internal.ByteString;
-import com.squareup.okhttp.internal.Platform;
 import com.squareup.okhttp.internal.Util;
-import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
 import java.io.UnsupportedEncodingException;
 import java.net.ProtocolException;
 import java.util.List;
 import java.util.zip.Deflater;
-
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.DeflaterSink;
+import okio.OkBuffer;
+import okio.Okio;
+
+/**
+ * Read and write spdy/3.1 frames.
+ * http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3-1
+ */
 final class Spdy3 implements Variant {
 
   @Override public Protocol getProtocol() {
     return Protocol.SPDY_3;
   }
 
-  static Settings defaultSettings(boolean client) {
-    Settings settings = new Settings();
-    settings.set(Settings.INITIAL_WINDOW_SIZE, 0, 65535);
-    return settings;
-  }
-
   static final int TYPE_DATA = 0x0;
   static final int TYPE_SYN_STREAM = 0x1;
   static final int TYPE_SYN_REPLY = 0x2;
   static final int TYPE_RST_STREAM = 0x3;
   static final int TYPE_SETTINGS = 0x4;
-  static final int TYPE_NOOP = 0x5;
   static final int TYPE_PING = 0x6;
   static final int TYPE_GOAWAY = 0x7;
   static final int TYPE_HEADERS = 0x8;
   static final int TYPE_WINDOW_UPDATE = 0x9;
-  static final int TYPE_CREDENTIAL = 0x10;
 
   static final int FLAG_FIN = 0x1;
   static final int FLAG_UNIDIRECTIONAL = 0x2;
@@ -100,23 +95,27 @@ static Settings defaultSettings(boolean client) {
     }
   }
 
-  @Override public FrameReader newReader(InputStream in, boolean client) {
-    return new Reader(in, client);
+  @Override public FrameReader newReader(BufferedSource source, boolean client) {
+    return new Reader(source, client);
   }
 
-  @Override public FrameWriter newWriter(OutputStream out, boolean client) {
-    return new Writer(out, client);
+  @Override public FrameWriter newWriter(BufferedSink sink, boolean client) {
+    return new Writer(sink, client);
+  }
+
+  @Override public int maxFrameSize() {
+    return 16383;
   }
 
   /** Read spdy/3 frames. */
   static final class Reader implements FrameReader {
-    private final DataInputStream in;
+    private final BufferedSource source;
     private final boolean client;
     private final NameValueBlockReader headerBlockReader;
 
-    Reader(InputStream in, boolean client) {
-      this.in = new DataInputStream(in);
-      this.headerBlockReader = new NameValueBlockReader(in);
+    Reader(BufferedSource source, boolean client) {
+      this.source = source;
+      this.headerBlockReader = new NameValueBlockReader(this.source);
       this.client = client;
     }
 
@@ -129,12 +128,13 @@ static Settings defaultSettings(boolean client) {
      */
     @Override public boolean nextFrame(Handler handler) throws IOException {
       int w1;
+      int w2;
       try {
-        w1 = in.readInt();
+        w1 = source.readInt();
+        w2 = source.readInt();
       } catch (IOException e) {
         return false; // This might be a normal socket close.
       }
-      int w2 = in.readInt();
 
       boolean control = (w1 & 0x80000000) != 0;
       int flags = (w2 & 0xff000000) >>> 24;
@@ -165,11 +165,6 @@ static Settings defaultSettings(boolean client) {
             readSettings(handler, flags, length);
             return true;
 
-          case TYPE_NOOP:
-            if (length != 0) throw ioException("TYPE_NOOP length: %d != 0", length);
-            handler.noop();
-            return true;
-
           case TYPE_PING:
             readPing(handler, flags, length);
             return true;
@@ -186,29 +181,26 @@ static Settings defaultSettings(boolean client) {
             readWindowUpdate(handler, flags, length);
             return true;
 
-          case TYPE_CREDENTIAL:
-            Util.skipByReading(in, length);
-            throw new UnsupportedOperationException("TODO"); // TODO: implement
-
           default:
-            throw new IOException("Unexpected frame");
+            source.skip(length);
+            return true;
         }
       } else {
         int streamId = w1 & 0x7fffffff;
         boolean inFinished = (flags & FLAG_FIN) != 0;
-        handler.data(inFinished, streamId, in, length);
+        handler.data(inFinished, streamId, source, length);
         return true;
       }
     }
 
     private void readSynStream(Handler handler, int flags, int length) throws IOException {
-      int w1 = in.readInt();
-      int w2 = in.readInt();
-      int s3 = in.readShort();
+      int w1 = source.readInt();
+      int w2 = source.readInt();
+      int s3 = source.readShort();
       int streamId = w1 & 0x7fffffff;
       int associatedStreamId = w2 & 0x7fffffff;
       int priority = (s3 & 0xe000) >>> 13;
-      int slot = s3 & 0xff;
+      // int slot = s3 & 0xff;
       List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 10);
 
       boolean inFinished = (flags & FLAG_FIN) != 0;
@@ -218,7 +210,7 @@ private void readSynStream(Handler handler, int flags, int length) throws IOExce
     }
 
     private void readSynReply(Handler handler, int flags, int length) throws IOException {
-      int w1 = in.readInt();
+      int w1 = source.readInt();
       int streamId = w1 & 0x7fffffff;
       List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
       boolean inFinished = (flags & FLAG_FIN) != 0;
@@ -227,8 +219,8 @@ private void readSynReply(Handler handler, int flags, int length) throws IOExcep
 
     private void readRstStream(Handler handler, int flags, int length) throws IOException {
       if (length != 8) throw ioException("TYPE_RST_STREAM length: %d != 8", length);
-      int streamId = in.readInt() & 0x7fffffff;
-      int errorCodeInt = in.readInt();
+      int streamId = source.readInt() & 0x7fffffff;
+      int errorCodeInt = source.readInt();
       ErrorCode errorCode = ErrorCode.fromSpdy3Rst(errorCodeInt);
       if (errorCode == null) {
         throw ioException("TYPE_RST_STREAM unexpected error code: %d", errorCodeInt);
@@ -237,7 +229,7 @@ private void readRstStream(Handler handler, int flags, int length) throws IOExce
     }
 
     private void readHeaders(Handler handler, int flags, int length) throws IOException {
-      int w1 = in.readInt();
+      int w1 = source.readInt();
       int streamId = w1 & 0x7fffffff;
       List<Header> headerBlock = headerBlockReader.readNameValueBlock(length - 4);
       handler.headers(false, false, streamId, -1, -1, headerBlock, HeadersMode.SPDY_HEADERS);
@@ -245,8 +237,8 @@ private void readHeaders(Handler handler, int flags, int length) throws IOExcept
 
     private void readWindowUpdate(Handler handler, int flags, int length) throws IOException {
       if (length != 8) throw ioException("TYPE_WINDOW_UPDATE length: %d != 8", length);
-      int w1 = in.readInt();
-      int w2 = in.readInt();
+      int w1 = source.readInt();
+      int w2 = source.readInt();
       int streamId = w1 & 0x7fffffff;
       long increment = w2 & 0x7fffffff;
       if (increment == 0) throw ioException("windowSizeIncrement was 0", increment);
@@ -255,31 +247,31 @@ private void readWindowUpdate(Handler handler, int flags, int length) throws IOE
 
     private void readPing(Handler handler, int flags, int length) throws IOException {
       if (length != 4) throw ioException("TYPE_PING length: %d != 4", length);
-      int id = in.readInt();
-      boolean ack = client == ((id % 2) == 1);
+      int id = source.readInt();
+      boolean ack = client == ((id & 1) == 1);
       handler.ping(ack, id, 0);
     }
 
     private void readGoAway(Handler handler, int flags, int length) throws IOException {
       if (length != 8) throw ioException("TYPE_GOAWAY length: %d != 8", length);
-      int lastGoodStreamId = in.readInt() & 0x7fffffff;
-      int errorCodeInt = in.readInt();
+      int lastGoodStreamId = source.readInt() & 0x7fffffff;
+      int errorCodeInt = source.readInt();
       ErrorCode errorCode = ErrorCode.fromSpdyGoAway(errorCodeInt);
       if (errorCode == null) {
         throw ioException("TYPE_GOAWAY unexpected error code: %d", errorCodeInt);
       }
-      handler.goAway(lastGoodStreamId, errorCode, Util.EMPTY_BYTE_ARRAY);
+      handler.goAway(lastGoodStreamId, errorCode, ByteString.EMPTY);
     }
 
     private void readSettings(Handler handler, int flags, int length) throws IOException {
-      int numberOfEntries = in.readInt();
+      int numberOfEntries = source.readInt();
       if (length != 4 + 8 * numberOfEntries) {
         throw ioException("TYPE_SETTINGS length: %d != 4 + 8 * %d", length, numberOfEntries);
       }
       Settings settings = new Settings();
       for (int i = 0; i < numberOfEntries; i++) {
-        int w1 = in.readInt();
-        int value = in.readInt();
+        int w1 = source.readInt();
+        int value = source.readInt();
         int idFlags = (w1 & 0xff000000) >>> 24;
         int id = w1 & 0xffffff;
         settings.set(id, idFlags, value);
@@ -293,26 +285,26 @@ private static IOException ioException(String message, Object... args) throws IO
     }
 
     @Override public void close() throws IOException {
-      Util.closeAll(in, headerBlockReader);
+      headerBlockReader.close();
     }
   }
 
   /** Write spdy/3 frames. */
   static final class Writer implements FrameWriter {
-    private final DataOutputStream out;
-    private final ByteArrayOutputStream headerBlockBuffer;
-    private final DataOutputStream headerBlockOut;
+    private final BufferedSink sink;
+    private final OkBuffer headerBlockBuffer;
+    private final BufferedSink headerBlockOut;
     private final boolean client;
+    private boolean closed;
 
-    Writer(OutputStream out, boolean client) {
-      this.out = new DataOutputStream(out);
+    Writer(BufferedSink sink, boolean client) {
+      this.sink = sink;
       this.client = client;
 
       Deflater deflater = new Deflater();
       deflater.setDictionary(DICTIONARY);
-      headerBlockBuffer = new ByteArrayOutputStream();
-      headerBlockOut = new DataOutputStream(
-          Platform.get().newDeflaterOutputStream(headerBlockBuffer, deflater, true));
+      headerBlockBuffer = new OkBuffer();
+      headerBlockOut = Okio.buffer(new DeflaterSink(headerBlockBuffer, deflater));
     }
 
     @Override public void ackSettings() {
@@ -330,162 +322,161 @@ public void pushPromise(int streamId, int promisedStreamId, List<Header> request
     }
 
     @Override public synchronized void flush() throws IOException {
-      out.flush();
+      if (closed) throw new IOException("closed");
+      sink.flush();
     }
 
-    @Override
-    public synchronized void synStream(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, int slot, List<Header> headerBlock)
+    @Override public synchronized void synStream(boolean outFinished, boolean inFinished,
+        int streamId, int associatedStreamId, int priority, int slot, List<Header> headerBlock)
         throws IOException {
+      if (closed) throw new IOException("closed");
       writeNameValueBlockToBuffer(headerBlock);
-      int length = 10 + headerBlockBuffer.size();
+      int length = (int) (10 + headerBlockBuffer.size());
       int type = TYPE_SYN_STREAM;
       int flags = (outFinished ? FLAG_FIN : 0) | (inFinished ? FLAG_UNIDIRECTIONAL : 0);
 
       int unused = 0;
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.writeInt(streamId & 0x7fffffff);
-      out.writeInt(associatedStreamId & 0x7fffffff);
-      out.writeShort((priority & 0x7) << 13 | (unused & 0x1f) << 8 | (slot & 0xff));
-      headerBlockBuffer.writeTo(out);
-      out.flush();
+      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      sink.writeInt(streamId & 0x7fffffff);
+      sink.writeInt(associatedStreamId & 0x7fffffff);
+      sink.writeShort((priority & 0x7) << 13 | (unused & 0x1f) << 8 | (slot & 0xff));
+      sink.write(headerBlockBuffer, headerBlockBuffer.size());
+      sink.flush();
     }
 
     @Override public synchronized void synReply(boolean outFinished, int streamId,
         List<Header> headerBlock) throws IOException {
+      if (closed) throw new IOException("closed");
       writeNameValueBlockToBuffer(headerBlock);
       int type = TYPE_SYN_REPLY;
       int flags = (outFinished ? FLAG_FIN : 0);
-      int length = headerBlockBuffer.size() + 4;
+      int length = (int) (headerBlockBuffer.size() + 4);
 
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.writeInt(streamId & 0x7fffffff);
-      headerBlockBuffer.writeTo(out);
-      out.flush();
+      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      sink.writeInt(streamId & 0x7fffffff);
+      sink.write(headerBlockBuffer, headerBlockBuffer.size());
+      sink.flush();
     }
 
     @Override public synchronized void headers(int streamId, List<Header> headerBlock)
         throws IOException {
+      if (closed) throw new IOException("closed");
       writeNameValueBlockToBuffer(headerBlock);
       int flags = 0;
       int type = TYPE_HEADERS;
-      int length = headerBlockBuffer.size() + 4;
+      int length = (int) (headerBlockBuffer.size() + 4);
 
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.writeInt(streamId & 0x7fffffff);
-      headerBlockBuffer.writeTo(out);
-      out.flush();
+      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      sink.writeInt(streamId & 0x7fffffff);
+      sink.write(headerBlockBuffer, headerBlockBuffer.size());
     }
 
     @Override public synchronized void rstStream(int streamId, ErrorCode errorCode)
         throws IOException {
+      if (closed) throw new IOException("closed");
       if (errorCode.spdyRstCode == -1) throw new IllegalArgumentException();
       int flags = 0;
       int type = TYPE_RST_STREAM;
       int length = 8;
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.writeInt(streamId & 0x7fffffff);
-      out.writeInt(errorCode.spdyRstCode);
-      out.flush();
+      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      sink.writeInt(streamId & 0x7fffffff);
+      sink.writeInt(errorCode.spdyRstCode);
+      sink.flush();
     }
 
-    @Override public synchronized void data(boolean outFinished, int streamId, byte[] data)
+    @Override public synchronized void data(boolean outFinished, int streamId, OkBuffer source)
         throws IOException {
-      data(outFinished, streamId, data, 0, data.length);
+      data(outFinished, streamId, source, (int) source.size());
     }
 
-    @Override public synchronized void data(boolean outFinished, int streamId, byte[] data,
-        int offset, int byteCount) throws IOException {
-      // TODO: Implement looping strategy.
+    @Override public synchronized void data(boolean outFinished, int streamId, OkBuffer source,
+        int byteCount) throws IOException {
       int flags = (outFinished ? FLAG_FIN : 0);
-      sendDataFrame(streamId, flags, data, offset, byteCount);
+      sendDataFrame(streamId, flags, source, byteCount);
     }
 
-    void sendDataFrame(int streamId, int flags, byte[] data, int offset, int byteCount)
+    void sendDataFrame(int streamId, int flags, OkBuffer buffer, int byteCount)
         throws IOException {
+      if (closed) throw new IOException("closed");
       if (byteCount > 0xffffffL) {
         throw new IllegalArgumentException("FRAME_TOO_LARGE max size is 16Mib: " + byteCount);
       }
-      out.writeInt(streamId & 0x7fffffff);
-      out.writeInt((flags & 0xff) << 24 | byteCount & 0xffffff);
-      out.write(data, offset, byteCount);
+      sink.writeInt(streamId & 0x7fffffff);
+      sink.writeInt((flags & 0xff) << 24 | byteCount & 0xffffff);
+      if (byteCount > 0) {
+        sink.write(buffer, byteCount);
+      }
     }
 
     private void writeNameValueBlockToBuffer(List<Header> headerBlock) throws IOException {
-      headerBlockBuffer.reset();
+      if (headerBlockBuffer.size() != 0) throw new IllegalStateException();
       headerBlockOut.writeInt(headerBlock.size());
       for (int i = 0, size = headerBlock.size(); i < size; i++) {
         ByteString name = headerBlock.get(i).name;
         headerBlockOut.writeInt(name.size());
-        name.write(headerBlockOut);
+        headerBlockOut.write(name);
         ByteString value = headerBlock.get(i).value;
         headerBlockOut.writeInt(value.size());
-        value.write(headerBlockOut);
+        headerBlockOut.write(value);
       }
       headerBlockOut.flush();
     }
 
     @Override public synchronized void settings(Settings settings) throws IOException {
+      if (closed) throw new IOException("closed");
       int type = TYPE_SETTINGS;
       int flags = 0;
       int size = settings.size();
       int length = 4 + size * 8;
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.writeInt(size);
+      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      sink.writeInt(size);
       for (int i = 0; i <= Settings.COUNT; i++) {
         if (!settings.isSet(i)) continue;
         int settingsFlags = settings.flags(i);
-        out.writeInt((settingsFlags & 0xff) << 24 | (i & 0xffffff));
-        out.writeInt(settings.get(i));
+        sink.writeInt((settingsFlags & 0xff) << 24 | (i & 0xffffff));
+        sink.writeInt(settings.get(i));
       }
-      out.flush();
-    }
-
-    @Override public synchronized void noop() throws IOException {
-      int type = TYPE_NOOP;
-      int length = 0;
-      int flags = 0;
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.flush();
+      sink.flush();
     }
 
     @Override public synchronized void ping(boolean reply, int payload1, int payload2)
         throws IOException {
-      boolean payloadIsReply = client != ((payload1 % 2) == 1);
+      if (closed) throw new IOException("closed");
+      boolean payloadIsReply = client != ((payload1 & 1) == 1);
       if (reply != payloadIsReply) throw new IllegalArgumentException("payload != reply");
       int type = TYPE_PING;
       int flags = 0;
       int length = 4;
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.writeInt(payload1);
-      out.flush();
+      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      sink.writeInt(payload1);
+      sink.flush();
     }
 
-    @Override
-    public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] ignored)
-        throws IOException {
+    @Override public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode,
+        byte[] ignored) throws IOException {
+      if (closed) throw new IOException("closed");
       if (errorCode.spdyGoAwayCode == -1) {
         throw new IllegalArgumentException("errorCode.spdyGoAwayCode == -1");
       }
       int type = TYPE_GOAWAY;
       int flags = 0;
       int length = 8;
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.writeInt(lastGoodStreamId);
-      out.writeInt(errorCode.spdyGoAwayCode);
-      out.flush();
+      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      sink.writeInt(lastGoodStreamId);
+      sink.writeInt(errorCode.spdyGoAwayCode);
+      sink.flush();
     }
 
     @Override public synchronized void windowUpdate(int streamId, long increment)
         throws IOException {
+      if (closed) throw new IOException("closed");
       if (increment == 0 || increment > 0x7fffffffL) {
         throw new IllegalArgumentException(
             "windowSizeIncrement must be between 1 and 0x7fffffff: " + increment);
@@ -493,15 +484,16 @@ public synchronized void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[
       int type = TYPE_WINDOW_UPDATE;
       int flags = 0;
       int length = 8;
-      out.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
-      out.writeInt((flags & 0xff) << 24 | length & 0xffffff);
-      out.writeInt(streamId);
-      out.writeInt((int) increment);
-      out.flush();
+      sink.writeInt(0x80000000 | (VERSION & 0x7fff) << 16 | type & 0xffff);
+      sink.writeInt((flags & 0xff) << 24 | length & 0xffffff);
+      sink.writeInt(streamId);
+      sink.writeInt((int) increment);
+      sink.flush();
     }
 
-    @Override public void close() throws IOException {
-      Util.closeAll(out, headerBlockOut);
+    @Override public synchronized void close() throws IOException {
+      closed = true;
+      Util.closeAll(sink, headerBlockOut);
     }
   }
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
similarity index 58%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
index b5e143a1cf..da7c4e1745 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyConnection.java
@@ -20,17 +20,26 @@
 import com.squareup.okhttp.internal.Util;
 import java.io.Closeable;
 import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
+import java.io.InterruptedIOException;
+import java.net.InetSocketAddress;
 import java.net.Socket;
 import java.util.HashMap;
 import java.util.Iterator;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.SynchronousQueue;
 import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
+import okio.BufferedSink;
+import okio.BufferedSource;
+import okio.ByteString;
+import okio.OkBuffer;
+import okio.Okio;
+
+import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 
 /**
  * A socket connection to a remote peer. A connection hosts streams which can
@@ -79,50 +88,79 @@
 
   /** Lazily-created map of in-flight pings awaiting a response. Guarded by this. */
   private Map<Integer, Ping> pings;
+  /** User code to run in response to push promise events. */
+  private final PushObserver pushObserver;
   private int nextPingId;
 
+  /**
+   * The total number of bytes consumed by the application, but not yet
+   * acknowledged by sending a {@code WINDOW_UPDATE} frame on this connection.
+   */
+  // Visible for testing
+  long unacknowledgedBytesRead = 0;
+
+  /**
+   * Count of bytes that can be written on the connection before receiving a
+   * window update.
+   */
+  // Visible for testing
+  long bytesLeftInWriteWindow;
+
+  /** Settings we communicate to the peer. */
   // TODO: Do we want to dynamically adjust settings, or KISS and only set once?
-  // Settings we might send include toggling push, adjusting compression table size.
-  final Settings okHttpSettings;
+  final Settings okHttpSettings = new Settings();
+      // okHttpSettings.set(Settings.MAX_CONCURRENT_STREAMS, 0, max);
+
+  /** Settings we receive from the peer. */
   // TODO: MWS will need to guard on this setting before attempting to push.
-  final Settings peerSettings;
+  final Settings peerSettings = new Settings();
+
+  private boolean receivedInitialPeerSettings = false;
   final FrameReader frameReader;
   final FrameWriter frameWriter;
+  final long maxFrameSize;
 
-  final ByteArrayPool bufferPool;
+  // Visible for testing
+  final Reader readerRunnable;
 
   private SpdyConnection(Builder builder) {
     protocol = builder.protocol;
+    pushObserver = builder.pushObserver;
     client = builder.client;
     handler = builder.handler;
     nextStreamId = builder.client ? 1 : 2;
     nextPingId = builder.client ? 1 : 2;
+
+    // Flow control was designed more for servers, or proxies than edge clients.
+    // If we are a client, set the flow control window to 16MiB.  This avoids
+    // thrashing window updates every 64KiB, yet small enough to avoid blowing
+    // up the heap.
+    if (builder.client) {
+      okHttpSettings.set(Settings.INITIAL_WINDOW_SIZE, 0, 16 * 1024 * 1024);
+    }
+
     hostName = builder.hostName;
 
     Variant variant;
     if (protocol == Protocol.HTTP_2) {
-      okHttpSettings = Http20Draft09.defaultSettings(client);
-      variant = new Http20Draft09(); // connection-specific settings here!
+      variant = new Http20Draft09();
     } else if (protocol == Protocol.SPDY_3) {
-      okHttpSettings = Spdy3.defaultSettings(client);
-      variant = new Spdy3(); // connection-specific settings here!
+      variant = new Spdy3();
     } else {
       throw new AssertionError(protocol);
     }
+    bytesLeftInWriteWindow = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
+    frameReader = variant.newReader(builder.source, client);
+    frameWriter = variant.newWriter(builder.sink, client);
+    maxFrameSize = variant.maxFrameSize();
 
-    // TODO: implement stream limit
-    // okHttpSettings.set(Settings.MAX_CONCURRENT_STREAMS, 0, max);
-    peerSettings = okHttpSettings;
-    bufferPool = new ByteArrayPool(peerSettings.getInitialWindowSize() * 8);
-    frameReader = variant.newReader(builder.in, client);
-    frameWriter = variant.newWriter(builder.out, client);
-
-    new Thread(new Reader()).start(); // Not a daemon thread.
+    readerRunnable = new Reader();
+    new Thread(readerRunnable).start(); // Not a daemon thread.
   }
 
   /** The protocol as selected using NPN or ALPN. */
   public Protocol getProtocol() {
-     return protocol;
+    return protocol;
   }
 
   /**
@@ -133,7 +171,7 @@ public synchronized int openStreamCount() {
     return streams.size();
   }
 
-  private synchronized SpdyStream getStream(int id) {
+  synchronized SpdyStream getStream(int id) {
     return streams.get(id);
   }
 
@@ -163,18 +201,37 @@ public synchronized long getIdleStartTimeNs() {
   }
 
   /**
-   * Returns a new locally-initiated stream.
+   * Returns a new server-initiated stream.
    *
+   * @param associatedStreamId the stream that triggered the sender to create
+   *     this stream.
    * @param out true to create an output stream that we can use to send data
    *     to the remote peer. Corresponds to {@code FLAG_FIN}.
-   * @param in true to create an input stream that the remote peer can use to
-   *     send data to us. Corresponds to {@code FLAG_UNIDIRECTIONAL}.
+   */
+  public SpdyStream pushStream(int associatedStreamId, List<Header> requestHeaders, boolean out)
+      throws IOException {
+    if (client) throw new IllegalStateException("Client cannot push requests.");
+    if (protocol != Protocol.HTTP_2) throw new IllegalStateException("protocol != HTTP_2");
+    return newStream(associatedStreamId, requestHeaders, out, false);
+  }
+
+  /**
+   * Returns a new locally-initiated stream.
+   *
+   * @param out true to create an output stream that we can use to send data to the remote peer.
+   *     Corresponds to {@code FLAG_FIN}.
+   * @param in true to create an input stream that the remote peer can use to send data to us.
+   *     Corresponds to {@code FLAG_UNIDIRECTIONAL}.
    */
   public SpdyStream newStream(List<Header> requestHeaders, boolean out, boolean in)
       throws IOException {
+    return newStream(0, requestHeaders, out, in);
+  }
+
+  private SpdyStream newStream(int associatedStreamId, List<Header> requestHeaders, boolean out,
+      boolean in) throws IOException {
     boolean outFinished = !out;
     boolean inFinished = !in;
-    int associatedStreamId = 0;  // TODO: permit the caller to specify an associated stream?
     int priority = -1; // TODO: permit the caller to specify a priority?
     int slot = 0; // TODO: permit the caller to specify a slot?
     SpdyStream stream;
@@ -187,16 +244,24 @@ public SpdyStream newStream(List<Header> requestHeaders, boolean out, boolean in
         }
         streamId = nextStreamId;
         nextStreamId += 2;
-        stream = new SpdyStream(
-            streamId, this, outFinished, inFinished, priority, requestHeaders, peerSettings);
+        stream = new SpdyStream(streamId, this, outFinished, inFinished, priority, requestHeaders);
         if (stream.isOpen()) {
           streams.put(streamId, stream);
           setIdle(false);
         }
       }
+      if (associatedStreamId == 0) {
+        frameWriter.synStream(outFinished, inFinished, streamId, associatedStreamId, priority, slot,
+            requestHeaders);
+      } else if (client) {
+        throw new IllegalArgumentException("client streams shouldn't have associated stream IDs");
+      } else { // HTTP/2 has a PUSH_PROMISE frame.
+        frameWriter.pushPromise(associatedStreamId, streamId, requestHeaders);
+      }
+    }
 
-      frameWriter.synStream(outFinished, inFinished, streamId, associatedStreamId, priority, slot,
-          requestHeaders);
+    if (!out) {
+      frameWriter.flush();
     }
 
     return stream;
@@ -207,9 +272,55 @@ void writeSynReply(int streamId, boolean outFinished, List<Header> alternating)
     frameWriter.synReply(outFinished, streamId, alternating);
   }
 
-  public void writeData(int streamId, boolean outFinished, byte[] buffer, int offset, int byteCount)
+  /**
+   * Callers of this method are not thread safe, and sometimes on application
+   * threads.  Most often, this method will be called to send a buffer worth of
+   * data to the peer.
+   * <p>
+   * Writes are subject to the write window of the stream and the connection.
+   * Until there is a window sufficient to send {@code byteCount}, the caller
+   * will block.  For example, a user of {@code HttpURLConnection} who flushes
+   * more bytes to the output stream than the connection's write window will
+   * block.
+   * <p>
+   * Zero {@code byteCount} writes are not subject to flow control and
+   * will not block.  The only use case for zero {@code byteCount} is closing
+   * a flushed output stream.
+   */
+  public void writeData(int streamId, boolean outFinished, OkBuffer buffer, long byteCount)
       throws IOException {
-    frameWriter.data(outFinished, streamId, buffer, offset, byteCount);
+    if (byteCount == 0) { // Empty data frames are not flow-controlled.
+      frameWriter.data(outFinished, streamId, buffer, 0);
+      return;
+    }
+
+    while (byteCount > 0) {
+      int toWrite;
+      synchronized (SpdyConnection.this) {
+        try {
+          while (bytesLeftInWriteWindow <= 0) {
+            SpdyConnection.this.wait(); // Wait until we receive a WINDOW_UPDATE.
+          }
+        } catch (InterruptedException e) {
+          throw new InterruptedIOException();
+        }
+
+        toWrite = (int) Math.min(Math.min(byteCount, bytesLeftInWriteWindow), maxFrameSize);
+        bytesLeftInWriteWindow -= toWrite;
+      }
+
+      byteCount -= toWrite;
+      frameWriter.data(outFinished && byteCount == 0, streamId, buffer, toWrite);
+    }
+  }
+
+  /**
+   * {@code delta} will be negative if a settings frame initial window is
+   * smaller than the last.
+   */
+  void addBytesToWriteWindow(long delta) {
+    bytesLeftInWriteWindow += delta;
+    if (delta > 0) SpdyConnection.this.notifyAll();
   }
 
   void writeSynResetLater(final int streamId, final ErrorCode errorCode) {
@@ -227,21 +338,17 @@ void writeSynReset(int streamId, ErrorCode statusCode) throws IOException {
     frameWriter.rstStream(streamId, statusCode);
   }
 
-  void writeWindowUpdateLater(final int streamId, final int windowSizeIncrement) {
-    executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
+  void writeWindowUpdateLater(final int streamId, final long unacknowledgedBytesRead) {
+    executor.submit(new NamedRunnable("OkHttp Window Update %s stream %d", hostName, streamId) {
       @Override public void execute() {
         try {
-          writeWindowUpdate(streamId, windowSizeIncrement);
+          frameWriter.windowUpdate(streamId, unacknowledgedBytesRead);
         } catch (IOException ignored) {
         }
       }
     });
   }
 
-  void writeWindowUpdate(int streamId, int windowSizeIncrement) throws IOException {
-    frameWriter.windowUpdate(streamId, windowSizeIncrement);
-  }
-
   /**
    * Sends a ping frame to the peer. Use the returned object to await the
    * ping's response and observe its round trip time.
@@ -287,11 +394,6 @@ private synchronized Ping removePing(int id) {
     return pings != null ? pings.remove(id) : null;
   }
 
-  /** Sends a noop frame to the peer. */
-  public void noop() throws IOException {
-    frameWriter.noop();
-  }
-
   public void flush() throws IOException {
     frameWriter.flush();
   }
@@ -388,47 +490,28 @@ public void sendConnectionHeader() throws IOException {
     frameWriter.settings(okHttpSettings);
   }
 
-  /**
-   * Reads a connection header if the current variant requires it. This should
-   * be called after {@link Builder#build} for all new connections.
-   */
-  public void readConnectionHeader() throws IOException {
-    frameReader.readConnectionHeader();
-  }
-
   public static class Builder {
     private String hostName;
-    private InputStream in;
-    private OutputStream out;
+    private BufferedSource source;
+    private BufferedSink sink;
     private IncomingStreamHandler handler = IncomingStreamHandler.REFUSE_INCOMING_STREAMS;
     private Protocol protocol = Protocol.SPDY_3;
+    private PushObserver pushObserver = PushObserver.CANCEL;
     private boolean client;
 
     public Builder(boolean client, Socket socket) throws IOException {
-      this("", client, socket.getInputStream(), socket.getOutputStream());
-    }
-
-    public Builder(boolean client, InputStream in, OutputStream out) {
-      this("", client, in, out);
-    }
-
-    /**
-     * @param client true if this peer initiated the connection; false if
-     * this peer accepted the connection.
-     */
-    public Builder(String hostName, boolean client, Socket socket) throws IOException {
-      this(hostName, client, socket.getInputStream(), socket.getOutputStream());
+      this(((InetSocketAddress) socket.getRemoteSocketAddress()).getHostName(), client, socket);
     }
 
     /**
      * @param client true if this peer initiated the connection; false if this
-     * peer accepted the connection.
+     *     peer accepted the connection.
      */
-    public Builder(String hostName, boolean client, InputStream in, OutputStream out) {
+    public Builder(String hostName, boolean client, Socket socket) throws IOException {
       this.hostName = hostName;
       this.client = client;
-      this.in = in;
-      this.out = out;
+      this.source = Okio.buffer(Okio.source(socket.getInputStream()));
+      this.sink = Okio.buffer(Okio.sink(socket.getOutputStream()));
     }
 
     public Builder handler(IncomingStreamHandler handler) {
@@ -441,12 +524,21 @@ public Builder protocol(Protocol protocol) {
       return this;
     }
 
+    public Builder pushObserver(PushObserver pushObserver) {
+      this.pushObserver = pushObserver;
+      return this;
+    }
+
     public SpdyConnection build() {
       return new SpdyConnection(this);
     }
   }
 
-  private class Reader extends NamedRunnable implements FrameReader.Handler {
+  /**
+   * Methods in this class must not lock FrameWriter.  If a method needs to
+   * write a frame, create an async task to do so.
+   */
+  class Reader extends NamedRunnable implements FrameReader.Handler {
     private Reader() {
       super("OkHttp %s", hostName);
     }
@@ -455,6 +547,9 @@ private Reader() {
       ErrorCode connectionErrorCode = ErrorCode.INTERNAL_ERROR;
       ErrorCode streamErrorCode = ErrorCode.INTERNAL_ERROR;
       try {
+        if (!client) {
+          frameReader.readConnectionHeader();
+        }
         while (frameReader.nextFrame(this)) {
         }
         connectionErrorCode = ErrorCode.NO_ERROR;
@@ -470,23 +565,30 @@ private Reader() {
       }
     }
 
-    @Override public void data(boolean inFinished, int streamId, InputStream in, int length)
+    @Override public void data(boolean inFinished, int streamId, BufferedSource source, int length)
         throws IOException {
+      if (pushedStream(streamId)) {
+        pushDataLater(streamId, source, length, inFinished);
+        return;
+      }
       SpdyStream dataStream = getStream(streamId);
       if (dataStream == null) {
         writeSynResetLater(streamId, ErrorCode.INVALID_STREAM);
-        Util.skipByReading(in, length);
+        source.skip(length);
         return;
       }
-      dataStream.receiveData(in, length);
+      dataStream.receiveData(source, length);
       if (inFinished) {
         dataStream.receiveFin();
       }
     }
 
     @Override public void headers(boolean outFinished, boolean inFinished, int streamId,
-        int associatedStreamId, int priority, List<Header> headerBlock,
-        HeadersMode headersMode) {
+        int associatedStreamId, int priority, List<Header> headerBlock, HeadersMode headersMode) {
+      if (pushedStream(streamId)) {
+        pushHeadersLater(streamId, headerBlock, inFinished);
+        return;
+      }
       SpdyStream stream;
       synchronized (SpdyConnection.this) {
         // If we're shutdown, don't bother with this stream.
@@ -509,7 +611,7 @@ private Reader() {
 
           // Create a stream.
           final SpdyStream newStream = new SpdyStream(streamId, SpdyConnection.this, outFinished,
-              inFinished, priority, headerBlock, peerSettings);
+              inFinished, priority, headerBlock);
           lastGoodStreamId = streamId;
           streams.put(streamId, newStream);
           executor.submit(new NamedRunnable("OkHttp %s stream %d", hostName, streamId) {
@@ -538,6 +640,10 @@ private Reader() {
     }
 
     @Override public void rstStream(int streamId, ErrorCode errorCode) {
+      if (pushedStream(streamId)) {
+        pushResetLater(streamId, errorCode);
+        return;
+      }
       SpdyStream rstStream = removeStream(streamId);
       if (rstStream != null) {
         rstStream.receiveRstStream(errorCode);
@@ -545,30 +651,31 @@ private Reader() {
     }
 
     @Override public void settings(boolean clearPrevious, Settings newSettings) {
+      long delta = 0;
       SpdyStream[] streamsToNotify = null;
       synchronized (SpdyConnection.this) {
-        if (clearPrevious) {
-          peerSettings.clear();
-        } else {
-          peerSettings.merge(newSettings);
-        }
+        int priorWriteWindowSize = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
+        if (clearPrevious) peerSettings.clear();
+        peerSettings.merge(newSettings);
         if (getProtocol() == Protocol.HTTP_2) {
           ackSettingsLater();
         }
-        if (!streams.isEmpty()) {
-          streamsToNotify = streams.values().toArray(new SpdyStream[streams.size()]);
+        int peerInitialWindowSize = peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
+        if (peerInitialWindowSize != -1 && peerInitialWindowSize != priorWriteWindowSize) {
+          delta = peerInitialWindowSize - priorWriteWindowSize;
+          if (!receivedInitialPeerSettings) {
+            addBytesToWriteWindow(delta);
+            receivedInitialPeerSettings = true;
+          }
+          if (!streams.isEmpty()) {
+            streamsToNotify = streams.values().toArray(new SpdyStream[streams.size()]);
+          }
         }
       }
-      if (streamsToNotify != null) {
-        for (SpdyStream stream : streamsToNotify) {
-          // The synchronization here is ugly. We need to synchronize on 'this' to guard
-          // reads to 'peerSettings'. We synchronize on 'stream' to guard the state change.
-          // And we need to acquire the 'stream' lock first, since that may block.
-          // TODO: this can block the reader thread until a write completes. That's bad!
+      if (streamsToNotify != null && delta != 0) {
+        for (SpdyStream stream : streams.values()) {
           synchronized (stream) {
-            synchronized (SpdyConnection.this) {
-              stream.receiveSettings(peerSettings);
-            }
+            stream.addBytesToWriteWindow(delta);
           }
         }
       }
@@ -585,7 +692,8 @@ private void ackSettingsLater() {
       });
     }
 
-    @Override public void noop() {
+    @Override public void ackSettings() {
+      // TODO: If we don't get this callback after sending settings to the peer, SETTINGS_TIMEOUT.
     }
 
     @Override public void ping(boolean reply, int payload1, int payload2) {
@@ -600,9 +708,8 @@ private void ackSettingsLater() {
       }
     }
 
-    @Override
-    public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData) {
-      if (debugData.length > 0) { // TODO: log the debugData
+    @Override public void goAway(int lastGoodStreamId, ErrorCode errorCode, ByteString debugData) {
+      if (debugData.size() > 0) { // TODO: log the debugData
       }
       synchronized (SpdyConnection.this) {
         shutdown = true;
@@ -622,14 +729,17 @@ public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
 
     @Override public void windowUpdate(int streamId, long windowSizeIncrement) {
       if (streamId == 0) {
-        // TODO: honor connection-level flow control
-        return;
-      }
-
-      // TODO: honor endFlowControl
-      SpdyStream stream = getStream(streamId);
-      if (stream != null) {
-        stream.receiveWindowUpdate(windowSizeIncrement);
+        synchronized (SpdyConnection.this) {
+          bytesLeftInWriteWindow += windowSizeIncrement;
+          SpdyConnection.this.notifyAll();
+        }
+      } else {
+        SpdyStream stream = getStream(streamId);
+        if (stream != null) {
+          synchronized (stream) {
+            stream.addBytesToWriteWindow(windowSizeIncrement);
+          }
+        }
       }
     }
 
@@ -638,21 +748,95 @@ public void goAway(int lastGoodStreamId, ErrorCode errorCode, byte[] debugData)
     }
 
     @Override
-    public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders)
-        throws IOException {
-      // TODO: Wire up properly and only cancel when local settings disable push.
-      cancelStreamLater(promisedStreamId);
+    public void pushPromise(int streamId, int promisedStreamId, List<Header> requestHeaders) {
+      pushRequestLater(promisedStreamId, requestHeaders);
     }
+  }
 
-    private void cancelStreamLater(final int streamId) {
-      executor.submit(new NamedRunnable("OkHttp %s Cancelling Stream %s", hostName, streamId) {
-        @Override public void execute() {
-          try {
+  /** Even, positive numbered streams are pushed streams in HTTP/2. */
+  private boolean pushedStream(int streamId) {
+    return protocol == Protocol.HTTP_2 && streamId != 0 && (streamId & 1) == 0;
+  }
+
+  // Guarded by this.
+  private final Set<Integer> currentPushRequests = new LinkedHashSet<Integer>();
+
+  private void pushRequestLater(final int streamId, final List<Header> requestHeaders) {
+    synchronized (this) {
+      if (currentPushRequests.contains(streamId)) {
+        writeSynResetLater(streamId, ErrorCode.PROTOCOL_ERROR);
+        return;
+      }
+      currentPushRequests.add(streamId);
+    }
+    executor.submit(new NamedRunnable("OkHttp %s Push Request[%s]", hostName, streamId) {
+      @Override public void execute() {
+        boolean cancel = pushObserver.onRequest(streamId, requestHeaders);
+        try {
+          if (cancel) {
             frameWriter.rstStream(streamId, ErrorCode.CANCEL);
-          } catch (IOException ignored) {
+            synchronized (SpdyConnection.this) {
+              currentPushRequests.remove(streamId);
+            }
+          }
+        } catch (IOException ignored) {
+        }
+      }
+    });
+  }
+
+  private void pushHeadersLater(final int streamId, final List<Header> requestHeaders,
+      final boolean inFinished) {
+    executor.submit(new NamedRunnable("OkHttp %s Push Headers[%s]", hostName, streamId) {
+      @Override public void execute() {
+        boolean cancel = pushObserver.onHeaders(streamId, requestHeaders, inFinished);
+        try {
+          if (cancel) frameWriter.rstStream(streamId, ErrorCode.CANCEL);
+          if (cancel || inFinished) {
+            synchronized (SpdyConnection.this) {
+              currentPushRequests.remove(streamId);
+            }
           }
+        } catch (IOException ignored) {
         }
-      });
-    }
+      }
+    });
+  }
+
+  /**
+   * Eagerly reads {@code byteCount} bytes from the source before launching a background task to
+   * process the data.  This avoids corrupting the stream.
+   */
+  private void pushDataLater(final int streamId, final BufferedSource source, final int byteCount,
+      final boolean inFinished) throws IOException {
+    final OkBuffer buffer = new OkBuffer();
+    source.require(byteCount); // Eagerly read the frame before firing client thread.
+    source.read(buffer, byteCount);
+    if (buffer.size() != byteCount) throw new IOException(buffer.size() + " != " + byteCount);
+    executor.submit(new NamedRunnable("OkHttp %s Push Data[%s]", hostName, streamId) {
+      @Override public void execute() {
+        try {
+          boolean cancel = pushObserver.onData(streamId, buffer, byteCount, inFinished);
+          if (cancel) frameWriter.rstStream(streamId, ErrorCode.CANCEL);
+          if (cancel || inFinished) {
+            synchronized (SpdyConnection.this) {
+              currentPushRequests.remove(streamId);
+            }
+          }
+        } catch (IOException ignored) {
+        }
+      }
+    });
+  }
+
+  private void pushResetLater(final int streamId, final ErrorCode errorCode) {
+    executor.submit(new NamedRunnable("OkHttp %s Push Reset[%s]", hostName, streamId) {
+      @Override public void execute() {
+        pushObserver.onReset(streamId, errorCode);
+        synchronized (SpdyConnection.this) {
+          currentPushRequests.remove(streamId);
+        }
+      }
+    });
   }
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
similarity index 52%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
index 68ab921d60..0fcde2dbb8 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/SpdyStream.java
@@ -16,32 +16,40 @@
 
 package com.squareup.okhttp.internal.spdy;
 
-import com.squareup.okhttp.internal.Util;
+import java.io.EOFException;
 import java.io.IOException;
-import java.io.InputStream;
 import java.io.InterruptedIOException;
-import java.io.OutputStream;
 import java.net.SocketTimeoutException;
 import java.util.ArrayList;
 import java.util.List;
+import okio.BufferedSource;
+import okio.Deadline;
+import okio.OkBuffer;
+import okio.Sink;
+import okio.Source;
 
-import static com.squareup.okhttp.internal.Util.checkOffsetAndCount;
+import static com.squareup.okhttp.internal.spdy.Settings.DEFAULT_INITIAL_WINDOW_SIZE;
 
 /** A logical bidirectional stream. */
 public final class SpdyStream {
-  static final int OUTPUT_BUFFER_SIZE = 8192;
-
   // Internal state is guarded by this. No long-running or potentially
   // blocking operations are performed while the lock is held.
 
   /**
-   * The number of unacknowledged bytes at which the input stream will send
-   * the peer a {@code WINDOW_UPDATE} frame. Must be less than this client's
-   * window size, otherwise the remote peer will stop sending data on this
-   * stream. (Chrome 25 uses 5 MiB.)
+   * The total number of bytes consumed by the application (with {@link
+   * SpdyDataSource#read}), but not yet acknowledged by sending a {@code
+   * WINDOW_UPDATE} frame on this stream.
+   */
+  // Visible for testing
+  long unacknowledgedBytesRead = 0;
+
+  /**
+   * Count of bytes that can be written on the stream before receiving a
+   * window update. Even if this is positive, writes will block until there
+   * available bytes in {@code connection.bytesLeftInWriteWindow}.
    */
-  int windowUpdateThreshold;
-  private int writeWindowSize;
+  // guarded by this
+  long bytesLeftInWriteWindow;
 
   private final int id;
   private final SpdyConnection connection;
@@ -54,8 +62,8 @@
   /** Headers sent in the stream reply. Null if reply is either not sent or not sent yet. */
   private List<Header> responseHeaders;
 
-  private final SpdyDataInputStream in;
-  private final SpdyDataOutputStream out;
+  private final SpdyDataSource source;
+  final SpdyDataSink sink;
 
   /**
    * The reason why this stream was abnormally closed. If there are multiple
@@ -65,18 +73,24 @@
   private ErrorCode errorCode = null;
 
   SpdyStream(int id, SpdyConnection connection, boolean outFinished, boolean inFinished,
-      int priority, List<Header> requestHeaders, Settings peerSettings) {
+      int priority, List<Header> requestHeaders) {
     if (connection == null) throw new NullPointerException("connection == null");
     if (requestHeaders == null) throw new NullPointerException("requestHeaders == null");
     this.id = id;
     this.connection = connection;
-    this.in = new SpdyDataInputStream(peerSettings.getInitialWindowSize());
-    this.out = new SpdyDataOutputStream();
-    this.in.finished = inFinished;
-    this.out.finished = outFinished;
+    this.bytesLeftInWriteWindow =
+        connection.peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE);
+    this.source = new SpdyDataSource(
+        connection.okHttpSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE));
+    this.sink = new SpdyDataSink();
+    this.source.finished = inFinished;
+    this.sink.finished = outFinished;
     this.priority = priority;
     this.requestHeaders = requestHeaders;
-    setPeerSettings(peerSettings);
+  }
+
+  public int getId() {
+    return id;
   }
 
   /**
@@ -93,7 +107,9 @@ public synchronized boolean isOpen() {
     if (errorCode != null) {
       return false;
     }
-    if ((in.finished || in.closed) && (out.finished || out.closed) && responseHeaders != null) {
+    if ((source.finished || source.closed)
+        && (sink.finished || sink.closed)
+        && responseHeaders != null) {
       return false;
     }
     return true;
@@ -101,7 +117,7 @@ public synchronized boolean isOpen() {
 
   /** Returns true if this stream was created by this peer. */
   public boolean isLocallyInitiated() {
-    boolean streamIsClient = (id % 2 == 1);
+    boolean streamIsClient = ((id & 1) == 1);
     return connection.client == streamIsClient;
   }
 
@@ -168,19 +184,20 @@ public void reply(List<Header> responseHeaders, boolean out) throws IOException
       if (responseHeaders == null) {
         throw new NullPointerException("responseHeaders == null");
       }
-      if (isLocallyInitiated()) {
-        throw new IllegalStateException("cannot reply to a locally initiated stream");
-      }
       if (this.responseHeaders != null) {
         throw new IllegalStateException("reply already sent");
       }
       this.responseHeaders = responseHeaders;
       if (!out) {
-        this.out.finished = true;
+        this.sink.finished = true;
         outFinished = true;
       }
     }
     connection.writeSynReply(id, outFinished, responseHeaders);
+
+    if (outFinished) {
+      connection.flush();
+    }
   }
 
   /**
@@ -195,24 +212,24 @@ public long getReadTimeoutMillis() {
     return readTimeoutMillis;
   }
 
-  /** Returns an input stream that can be used to read data from the peer. */
-  public InputStream getInputStream() {
-    return in;
+  /** Returns a source that reads data from the peer. */
+  public Source getSource() {
+    return source;
   }
 
   /**
-   * Returns an output stream that can be used to write data to the peer.
+   * Returns a sink that can be used to write data to the peer.
    *
    * @throws IllegalStateException if this stream was initiated by the peer
-   * and a {@link #reply} has not yet been sent.
+   *     and a {@link #reply} has not yet been sent.
    */
-  public OutputStream getOutputStream() {
+  public Sink getSink() {
     synchronized (this) {
       if (responseHeaders == null && !isLocallyInitiated()) {
-        throw new IllegalStateException("reply before requesting the output stream");
+        throw new IllegalStateException("reply before requesting the sink");
       }
     }
-    return out;
+    return sink;
   }
 
   /**
@@ -244,7 +261,7 @@ private boolean closeInternal(ErrorCode errorCode) {
       if (this.errorCode != null) {
         return false;
       }
-      if (in.finished && out.finished) {
+      if (source.finished && sink.finished) {
         return false;
       }
       this.errorCode = errorCode;
@@ -285,16 +302,16 @@ void receiveHeaders(List<Header> headers, HeadersMode headersMode) {
     }
   }
 
-  void receiveData(InputStream in, int length) throws IOException {
+  void receiveData(BufferedSource in, int length) throws IOException {
     assert (!Thread.holdsLock(SpdyStream.this));
-    this.in.receive(in, length);
+    this.source.receive(in, length);
   }
 
   void receiveFin() {
     assert (!Thread.holdsLock(SpdyStream.this));
     boolean open;
     synchronized (this) {
-      this.in.finished = true;
+      this.source.finished = true;
       open = isOpen();
       notifyAll();
     }
@@ -310,61 +327,24 @@ synchronized void receiveRstStream(ErrorCode errorCode) {
     }
   }
 
-  private void setPeerSettings(Settings peerSettings) {
-    // TODO: For HTTP/2.0, also adjust the stream flow control window size
-    // by the difference between the new value and the old value.
-    assert (Thread.holdsLock(connection)); // Because 'settings' is guarded by 'connection'.
-    this.writeWindowSize = peerSettings.getInitialWindowSize();
-    this.windowUpdateThreshold = peerSettings.getInitialWindowSize() / 2;
-  }
-
-  /** Notification received when peer settings change. */
-  void receiveSettings(Settings peerSettings) {
-    assert (Thread.holdsLock(this));
-    setPeerSettings(peerSettings);
-    notifyAll();
-  }
-
-  synchronized void receiveWindowUpdate(long windowSizeIncrement) {
-    out.unacknowledgedBytes -= windowSizeIncrement;
-    notifyAll();
-  }
-
   int getPriority() {
     return priority;
   }
 
   /**
-   * An input stream that reads the incoming data frames of a stream. Although
-   * this class uses synchronization to safely receive incoming data frames,
-   * it is not intended for use by multiple readers.
+   * A source that reads the incoming data frames of a stream. Although this
+   * class uses synchronization to safely receive incoming data frames, it is
+   * not intended for use by multiple readers.
    */
-  private final class SpdyDataInputStream extends InputStream {
-
-    // Store incoming data bytes in a circular buffer. When the buffer is
-    // empty, pos == -1. Otherwise pos is the first byte to read and limit
-    // is the first byte to write.
-    //
-    // { - - - X X X X - - - }
-    //         ^       ^
-    //        pos    limit
-    //
-    // { X X X - - - - X X X }
-    //         ^       ^
-    //       limit    pos
-    private final byte[] buffer;
-
-    private SpdyDataInputStream(int bufferLength) {
-      // TODO: We probably need to change to growable buffers here pretty soon.
-      // Otherwise we have a performance problem where we pay for 64 KiB even if we aren't using it.
-      buffer = connection.bufferPool.getBuf(bufferLength);
-    }
+  private final class SpdyDataSource implements Source {
+    /** Buffer to receive data from the network into. Only accessed by the reader thread. */
+    private final OkBuffer receiveBuffer = new OkBuffer();
 
-    /** the next byte to be read, or -1 if the buffer is empty. Never buffer.length */
-    private int pos = -1;
+    /** Buffer with readable data. Guarded by SpdyStream.this. */
+    private final OkBuffer readBuffer = new OkBuffer();
 
-    /** the last byte to be read. Never buffer.length */
-    private int limit;
+    /** Maximum number of bytes to buffer before reporting a flow control error. */
+    private final long maxByteCount;
 
     /** True if the caller has closed this stream. */
     private boolean closed;
@@ -375,75 +355,43 @@ private SpdyDataInputStream(int bufferLength) {
      */
     private boolean finished;
 
-    /**
-     * The total number of bytes consumed by the application (with {@link
-     * #read}), but not yet acknowledged by sending a {@code WINDOW_UPDATE}
-     * frame.
-     */
-    private int unacknowledgedBytes = 0;
-
-    @Override public int available() throws IOException {
-      synchronized (SpdyStream.this) {
-        checkNotClosed();
-        if (pos == -1) {
-          return 0;
-        } else if (limit > pos) {
-          return limit - pos;
-        } else {
-          return limit + (buffer.length - pos);
-        }
-      }
+    private SpdyDataSource(long maxByteCount) {
+      this.maxByteCount = maxByteCount;
     }
 
-    @Override public int read() throws IOException {
-      return Util.readSingleByte(this);
-    }
+    @Override public long read(OkBuffer sink, long byteCount)
+        throws IOException {
+      if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
 
-    @Override public int read(byte[] b, int offset, int count) throws IOException {
+      long read;
       synchronized (SpdyStream.this) {
-        checkOffsetAndCount(b.length, offset, count);
         waitUntilReadable();
         checkNotClosed();
+        if (readBuffer.size() == 0) return -1; // This source is exhausted.
 
-        if (pos == -1) {
-          return -1;
-        }
-
-        int copied = 0;
-
-        // drain from [pos..buffer.length)
-        if (limit <= pos) {
-          int bytesToCopy = Math.min(count, buffer.length - pos);
-          System.arraycopy(buffer, pos, b, offset, bytesToCopy);
-          pos += bytesToCopy;
-          copied += bytesToCopy;
-          if (pos == buffer.length) {
-            pos = 0;
-          }
-        }
-
-        // drain from [pos..limit)
-        if (copied < count) {
-          int bytesToCopy = Math.min(limit - pos, count - copied);
-          System.arraycopy(buffer, pos, b, offset + copied, bytesToCopy);
-          pos += bytesToCopy;
-          copied += bytesToCopy;
-        }
+        // Move bytes from the read buffer into the caller's buffer.
+        read = readBuffer.read(sink, Math.min(byteCount, readBuffer.size()));
 
         // Flow control: notify the peer that we're ready for more data!
-        unacknowledgedBytes += copied;
-        if (unacknowledgedBytes >= windowUpdateThreshold) {
-          connection.writeWindowUpdateLater(id, unacknowledgedBytes);
-          unacknowledgedBytes = 0;
+        unacknowledgedBytesRead += read;
+        if (unacknowledgedBytesRead
+            >= connection.peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE) / 2) {
+          connection.writeWindowUpdateLater(id, unacknowledgedBytesRead);
+          unacknowledgedBytesRead = 0;
         }
+      }
 
-        if (pos == limit) {
-          pos = -1;
-          limit = 0;
+      // Update connection.unacknowledgedBytesRead outside the stream lock.
+      synchronized (connection) { // Multiple application threads may hit this section.
+        connection.unacknowledgedBytesRead += read;
+        if (connection.unacknowledgedBytesRead
+            >= connection.peerSettings.getInitialWindowSize(DEFAULT_INITIAL_WINDOW_SIZE) / 2) {
+          connection.writeWindowUpdateLater(0, connection.unacknowledgedBytesRead);
+          connection.unacknowledgedBytesRead = 0;
         }
-
-        return copied;
       }
+
+      return read;
     }
 
     /**
@@ -459,14 +407,14 @@ private void waitUntilReadable() throws IOException {
         remaining = readTimeoutMillis;
       }
       try {
-        while (pos == -1 && !finished && !closed && errorCode == null) {
+        while (readBuffer.size() == 0 && !finished && !closed && errorCode == null) {
           if (readTimeoutMillis == 0) {
             SpdyStream.this.wait();
           } else if (remaining > 0) {
             SpdyStream.this.wait(remaining);
             remaining = start + readTimeoutMillis - (System.nanoTime() / 1000000);
           } else {
-            throw new SocketTimeoutException();
+            throw new SocketTimeoutException("Read timed out");
           }
         }
       } catch (InterruptedException e) {
@@ -474,71 +422,56 @@ private void waitUntilReadable() throws IOException {
       }
     }
 
-    void receive(InputStream in, int byteCount) throws IOException {
+    void receive(BufferedSource in, long byteCount) throws IOException {
       assert (!Thread.holdsLock(SpdyStream.this));
 
-      if (byteCount == 0) {
-        return;
-      }
-
-      int pos;
-      int limit;
-      int firstNewByte;
-      boolean finished;
-      boolean flowControlError;
-      synchronized (SpdyStream.this) {
-        finished = this.finished;
-        pos = this.pos;
-        firstNewByte = this.limit;
-        limit = this.limit;
-        flowControlError = byteCount > buffer.length - available();
-      }
-
-      // If the peer sends more data than we can handle, discard it and close the connection.
-      if (flowControlError) {
-        Util.skipByReading(in, byteCount);
-        closeLater(ErrorCode.FLOW_CONTROL_ERROR);
-        return;
-      }
+      while (byteCount > 0) {
+        boolean finished;
+        boolean flowControlError;
+        synchronized (SpdyStream.this) {
+          finished = this.finished;
+          flowControlError = byteCount + readBuffer.size() > maxByteCount;
+        }
 
-      // Discard data received after the stream is finished. It's probably a benign race.
-      if (finished) {
-        Util.skipByReading(in, byteCount);
-        return;
-      }
+        // If the peer sends more data than we can handle, discard it and close the connection.
+        if (flowControlError) {
+          in.skip(byteCount);
+          closeLater(ErrorCode.FLOW_CONTROL_ERROR);
+          return;
+        }
 
-      // Fill the buffer without holding any locks. First fill [limit..buffer.length) if that
-      // won't overwrite unread data. Then fill [limit..pos). We can't hold a lock, otherwise
-      // writes will be blocked until reads complete.
-      if (pos < limit) {
-        int firstCopyCount = Math.min(byteCount, buffer.length - limit);
-        Util.readFully(in, buffer, limit, firstCopyCount);
-        limit += firstCopyCount;
-        byteCount -= firstCopyCount;
-        if (limit == buffer.length) {
-          limit = 0;
+        // Discard data received after the stream is finished. It's probably a benign race.
+        if (finished) {
+          in.skip(byteCount);
+          return;
         }
-      }
-      if (byteCount > 0) {
-        Util.readFully(in, buffer, limit, byteCount);
-        limit += byteCount;
-      }
 
-      synchronized (SpdyStream.this) {
-        // Update the new limit, and mark the position as readable if necessary.
-        this.limit = limit;
-        if (this.pos == -1) {
-          this.pos = firstNewByte;
-          SpdyStream.this.notifyAll();
+        // Fill the receive buffer without holding any locks.
+        long read = in.read(receiveBuffer, byteCount);
+        if (read == -1) throw new EOFException();
+        byteCount -= read;
+
+        // Move the received data to the read buffer to the reader can read it.
+        synchronized (SpdyStream.this) {
+          boolean wasEmpty = readBuffer.size() == 0;
+          readBuffer.write(receiveBuffer, receiveBuffer.size());
+          if (wasEmpty) {
+            SpdyStream.this.notifyAll();
+          }
         }
       }
     }
 
+    @Override public Source deadline(Deadline deadline) {
+      // TODO: honor deadlines.
+      return this;
+    }
+
     @Override public void close() throws IOException {
       synchronized (SpdyStream.this) {
         closed = true;
+        readBuffer.clear();
         SpdyStream.this.notifyAll();
-        SpdyStream.this.connection.bufferPool.returnBuf(buffer);
       }
       cancelStreamIfNecessary();
     }
@@ -558,7 +491,7 @@ private void cancelStreamIfNecessary() throws IOException {
     boolean open;
     boolean cancel;
     synchronized (this) {
-      cancel = !in.finished && in.closed && (out.finished || out.closed);
+      cancel = !source.finished && source.closed && (sink.finished || sink.closed);
       open = isOpen();
     }
     if (cancel) {
@@ -573,14 +506,10 @@ private void cancelStreamIfNecessary() throws IOException {
   }
 
   /**
-   * An output stream that writes outgoing data frames of a stream. This class
-   * is not thread safe.
+   * A sink that writes outgoing data frames of a stream. This class is not
+   * thread safe.
    */
-  private final class SpdyDataOutputStream extends OutputStream {
-    private final byte[] buffer = SpdyStream.this.connection.bufferPool.getBuf(OUTPUT_BUFFER_SIZE);
-    private int pos = 0;
-
-    /** True if the caller has closed this stream. */
+  final class SpdyDataSink implements Sink {
     private boolean closed;
 
     /**
@@ -589,106 +518,74 @@ private void cancelStreamIfNecessary() throws IOException {
      */
     private boolean finished;
 
-    /**
-     * The total number of bytes written out to the peer, but not yet
-     * acknowledged with an incoming {@code WINDOW_UPDATE} frame. Writes
-     * block if they cause this to exceed the {@code WINDOW_SIZE}.
-     */
-    private long unacknowledgedBytes = 0;
-
-    @Override public void write(int b) throws IOException {
-      Util.writeSingleByte(this, b);
-    }
-
-    @Override public void write(byte[] bytes, int offset, int count) throws IOException {
+    @Override public void write(OkBuffer source, long byteCount) throws IOException {
       assert (!Thread.holdsLock(SpdyStream.this));
-      checkOffsetAndCount(bytes.length, offset, count);
-      checkNotClosed();
+      while (byteCount > 0) {
+        long toWrite;
+        synchronized (SpdyStream.this) {
+          try {
+            while (bytesLeftInWriteWindow <= 0) {
+              SpdyStream.this.wait(); // Wait until we receive a WINDOW_UPDATE.
+            }
+          } catch (InterruptedException e) {
+            throw new InterruptedIOException();
+          }
 
-      while (count > 0) {
-        if (pos == buffer.length) {
-          writeFrame(false);
+          checkOutNotClosed(); // Kick out if the stream was reset or closed while waiting.
+          toWrite = Math.min(bytesLeftInWriteWindow, byteCount);
+          bytesLeftInWriteWindow -= toWrite;
         }
-        int bytesToCopy = Math.min(count, buffer.length - pos);
-        System.arraycopy(bytes, offset, buffer, pos, bytesToCopy);
-        pos += bytesToCopy;
-        offset += bytesToCopy;
-        count -= bytesToCopy;
+
+        byteCount -= toWrite;
+        connection.writeData(id, false, source, toWrite);
       }
     }
 
     @Override public void flush() throws IOException {
       assert (!Thread.holdsLock(SpdyStream.this));
-      checkNotClosed();
-      if (pos > 0) {
-        writeFrame(false);
-        connection.flush();
+      synchronized (SpdyStream.this) {
+        checkOutNotClosed();
       }
+      connection.flush();
+    }
+
+    @Override public Sink deadline(Deadline deadline) {
+      // TODO: honor deadlines.
+      return this;
     }
 
     @Override public void close() throws IOException {
       assert (!Thread.holdsLock(SpdyStream.this));
       synchronized (SpdyStream.this) {
-        if (closed) {
-          return;
-        }
-        closed = true;
-        SpdyStream.this.connection.bufferPool.returnBuf(buffer);
+        if (closed) return;
       }
-      if (!out.finished) {
-        writeFrame(true);
+      if (!sink.finished) {
+        connection.writeData(id, true, null, 0);
       }
-      connection.flush();
-      cancelStreamIfNecessary();
-    }
-
-    private void writeFrame(boolean outFinished) throws IOException {
-      assert (!Thread.holdsLock(SpdyStream.this));
-
-      int length = pos;
       synchronized (SpdyStream.this) {
-        waitUntilWritable(length, outFinished);
-        unacknowledgedBytes += length;
+        closed = true;
       }
-      connection.writeData(id, outFinished, buffer, 0, pos);
-      pos = 0;
+      connection.flush();
+      cancelStreamIfNecessary();
     }
+  }
 
-    /**
-     * Returns once the peer is ready to receive {@code count} bytes.
-     *
-     * @throws IOException if the stream was finished or closed, or the
-     * thread was interrupted.
-     */
-    private void waitUntilWritable(int count, boolean last) throws IOException {
-      try {
-        while (unacknowledgedBytes + count >= writeWindowSize) {
-          SpdyStream.this.wait(); // Wait until we receive a WINDOW_UPDATE.
-
-          // The stream may have been closed or reset while we were waiting!
-          if (!last && closed) {
-            throw new IOException("stream closed");
-          } else if (finished) {
-            throw new IOException("stream finished");
-          } else if (errorCode != null) {
-            throw new IOException("stream was reset: " + errorCode);
-          }
-        }
-      } catch (InterruptedException e) {
-        throw new InterruptedIOException();
-      }
-    }
+  /**
+   * {@code delta} will be negative if a settings frame initial window is
+   * smaller than the last.
+   */
+  void addBytesToWriteWindow(long delta) {
+    bytesLeftInWriteWindow += delta;
+    if (delta > 0) SpdyStream.this.notifyAll();
+  }
 
-    private void checkNotClosed() throws IOException {
-      synchronized (SpdyStream.this) {
-        if (closed) {
-          throw new IOException("stream closed");
-        } else if (finished) {
-          throw new IOException("stream finished");
-        } else if (errorCode != null) {
-          throw new IOException("stream was reset: " + errorCode);
-        }
-      }
+  private void checkOutNotClosed() throws IOException {
+    if (sink.closed) {
+      throw new IOException("stream closed");
+    } else if (sink.finished) {
+      throw new IOException("stream finished");
+    } else if (errorCode != null) {
+      throw new IOException("stream was reset: " + errorCode);
     }
   }
 }
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
similarity index 83%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
rename to okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
index 784d02ef26..f8b14acbd0 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
+++ b/okhttp/src/main/java/com/squareup/okhttp/internal/spdy/Variant.java
@@ -16,8 +16,8 @@
 package com.squareup.okhttp.internal.spdy;
 
 import com.squareup.okhttp.Protocol;
-import java.io.InputStream;
-import java.io.OutputStream;
+import okio.BufferedSink;
+import okio.BufferedSource;
 
 /** A version and dialect of the framed socket protocol. */
 interface Variant {
@@ -28,10 +28,12 @@
   /**
    * @param client true if this is the HTTP client's reader, reading frames from a server.
    */
-  FrameReader newReader(InputStream in, boolean client);
+  FrameReader newReader(BufferedSource source, boolean client);
 
   /**
    * @param client true if this is the HTTP client's writer, writing frames to a server.
    */
-  FrameWriter newWriter(OutputStream out, boolean client);
+  FrameWriter newWriter(BufferedSink sink, boolean client);
+
+  int maxFrameSize();
 }
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/FaultRecoveringOutputStreamTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/FaultRecoveringOutputStreamTest.java
deleted file mode 100644
index e933c177c3..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/FaultRecoveringOutputStreamTest.java
+++ /dev/null
@@ -1,224 +0,0 @@
-/*
- * Copyright (C) 2013 Square, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.squareup.okhttp.internal;
-
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Deque;
-import java.util.List;
-import org.junit.Test;
-
-import static com.squareup.okhttp.internal.Util.UTF_8;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
-public final class FaultRecoveringOutputStreamTest {
-  @Test public void noRecoveryWithoutReplacement() throws Exception {
-    FaultingOutputStream faulting = new FaultingOutputStream();
-    TestFaultRecoveringOutputStream recovering = new TestFaultRecoveringOutputStream(10, faulting);
-
-    recovering.write('a');
-    faulting.nextFault = "system on fire";
-    try {
-      recovering.write('b');
-      fail();
-    } catch (IOException e) {
-      assertEquals(Arrays.asList("system on fire"), recovering.exceptionMessages);
-      assertEquals("ab", faulting.receivedUtf8);
-      assertFalse(faulting.closed);
-    }
-  }
-
-  @Test public void successfulRecoveryOnWriteFault() throws Exception {
-    FaultingOutputStream faulting1 = new FaultingOutputStream();
-    FaultingOutputStream faulting2 = new FaultingOutputStream();
-    TestFaultRecoveringOutputStream recovering = new TestFaultRecoveringOutputStream(10, faulting1);
-    recovering.replacements.addLast(faulting2);
-
-    recovering.write('a');
-    assertEquals("a", faulting1.receivedUtf8);
-    assertEquals("", faulting2.receivedUtf8);
-    faulting1.nextFault = "system under water";
-    recovering.write('b');
-    assertEquals(Arrays.asList("system under water"), recovering.exceptionMessages);
-    assertEquals("ab", faulting1.receivedUtf8);
-    assertEquals("ab", faulting2.receivedUtf8);
-    assertTrue(faulting1.closed);
-    assertFalse(faulting2.closed);
-
-    // Confirm that new data goes to the new stream.
-    recovering.write('c');
-    assertEquals("ab", faulting1.receivedUtf8);
-    assertEquals("abc", faulting2.receivedUtf8);
-  }
-
-  @Test public void successfulRecoveryOnFlushFault() throws Exception {
-    FaultingOutputStream faulting1 = new FaultingOutputStream();
-    FaultingOutputStream faulting2 = new FaultingOutputStream();
-    TestFaultRecoveringOutputStream recovering = new TestFaultRecoveringOutputStream(10, faulting1);
-    recovering.replacements.addLast(faulting2);
-
-    recovering.write('a');
-    faulting1.nextFault = "bad weather";
-    recovering.flush();
-    assertEquals(Arrays.asList("bad weather"), recovering.exceptionMessages);
-    assertEquals("a", faulting1.receivedUtf8);
-    assertEquals("a", faulting2.receivedUtf8);
-    assertTrue(faulting1.closed);
-    assertFalse(faulting2.closed);
-    assertEquals("a", faulting2.flushedUtf8);
-
-    // Confirm that new data goes to the new stream.
-    recovering.write('b');
-    assertEquals("a", faulting1.receivedUtf8);
-    assertEquals("ab", faulting2.receivedUtf8);
-    assertEquals("a", faulting2.flushedUtf8);
-  }
-
-  @Test public void successfulRecoveryOnCloseFault() throws Exception {
-    FaultingOutputStream faulting1 = new FaultingOutputStream();
-    FaultingOutputStream faulting2 = new FaultingOutputStream();
-    TestFaultRecoveringOutputStream recovering = new TestFaultRecoveringOutputStream(10, faulting1);
-    recovering.replacements.addLast(faulting2);
-
-    recovering.write('a');
-    faulting1.nextFault = "termites";
-    recovering.close();
-    assertEquals(Arrays.asList("termites"), recovering.exceptionMessages);
-    assertEquals("a", faulting1.receivedUtf8);
-    assertEquals("a", faulting2.receivedUtf8);
-    assertTrue(faulting1.closed);
-    assertTrue(faulting2.closed);
-  }
-
-  @Test public void replacementStreamFaultsImmediately() throws Exception {
-    FaultingOutputStream faulting1 = new FaultingOutputStream();
-    FaultingOutputStream faulting2 = new FaultingOutputStream();
-    FaultingOutputStream faulting3 = new FaultingOutputStream();
-    TestFaultRecoveringOutputStream recovering = new TestFaultRecoveringOutputStream(10, faulting1);
-    recovering.replacements.addLast(faulting2);
-    recovering.replacements.addLast(faulting3);
-
-    recovering.write('a');
-    assertEquals("a", faulting1.receivedUtf8);
-    assertEquals("", faulting2.receivedUtf8);
-    assertEquals("", faulting3.receivedUtf8);
-    faulting1.nextFault = "offline";
-    faulting2.nextFault = "slow";
-    recovering.write('b');
-    assertEquals(Arrays.asList("offline", "slow"), recovering.exceptionMessages);
-    assertEquals("ab", faulting1.receivedUtf8);
-    assertEquals("a", faulting2.receivedUtf8);
-    assertEquals("ab", faulting3.receivedUtf8);
-    assertTrue(faulting1.closed);
-    assertTrue(faulting2.closed);
-    assertFalse(faulting3.closed);
-
-    // Confirm that new data goes to the new stream.
-    recovering.write('c');
-    assertEquals("ab", faulting1.receivedUtf8);
-    assertEquals("a", faulting2.receivedUtf8);
-    assertEquals("abc", faulting3.receivedUtf8);
-  }
-
-  @Test public void recoverWithFullBuffer() throws Exception {
-    FaultingOutputStream faulting1 = new FaultingOutputStream();
-    FaultingOutputStream faulting2 = new FaultingOutputStream();
-    TestFaultRecoveringOutputStream recovering = new TestFaultRecoveringOutputStream(10, faulting1);
-    recovering.replacements.addLast(faulting2);
-
-    recovering.write("abcdefghij".getBytes(UTF_8)); // 10 bytes.
-    faulting1.nextFault = "unlucky";
-    recovering.write('k');
-    assertEquals("abcdefghijk", faulting1.receivedUtf8);
-    assertEquals("abcdefghijk", faulting2.receivedUtf8);
-    assertEquals(Arrays.asList("unlucky"), recovering.exceptionMessages);
-    assertTrue(faulting1.closed);
-    assertFalse(faulting2.closed);
-
-    // Confirm that new data goes to the new stream.
-    recovering.write('l');
-    assertEquals("abcdefghijk", faulting1.receivedUtf8);
-    assertEquals("abcdefghijkl", faulting2.receivedUtf8);
-  }
-
-  @Test public void noRecoveryWithOverfullBuffer() throws Exception {
-    FaultingOutputStream faulting1 = new FaultingOutputStream();
-    FaultingOutputStream faulting2 = new FaultingOutputStream();
-    TestFaultRecoveringOutputStream recovering = new TestFaultRecoveringOutputStream(10, faulting1);
-    recovering.replacements.addLast(faulting2);
-
-    recovering.write("abcdefghijk".getBytes(UTF_8)); // 11 bytes.
-    faulting1.nextFault = "out to lunch";
-    try {
-      recovering.write('l');
-      fail();
-    } catch (IOException expected) {
-      assertEquals("out to lunch", expected.getMessage());
-    }
-
-    assertEquals(Arrays.<String>asList(), recovering.exceptionMessages);
-    assertEquals("abcdefghijkl", faulting1.receivedUtf8);
-    assertEquals("", faulting2.receivedUtf8);
-    assertFalse(faulting1.closed);
-    assertFalse(faulting2.closed);
-  }
-
-  static class FaultingOutputStream extends OutputStream {
-    String receivedUtf8 = "";
-    String flushedUtf8 = null;
-    String nextFault;
-    boolean closed;
-
-    @Override public final void write(int data) throws IOException {
-      write(new byte[] { (byte) data });
-    }
-
-    @Override public void write(byte[] buffer, int offset, int count) throws IOException {
-      receivedUtf8 += new String(buffer, offset, count, UTF_8);
-      if (nextFault != null) throw new IOException(nextFault);
-    }
-
-    @Override public void flush() throws IOException {
-      flushedUtf8 = receivedUtf8;
-      if (nextFault != null) throw new IOException(nextFault);
-    }
-
-    @Override public void close() throws IOException {
-      closed = true;
-      if (nextFault != null) throw new IOException(nextFault);
-    }
-  }
-
-  static class TestFaultRecoveringOutputStream extends FaultRecoveringOutputStream {
-    final List<String> exceptionMessages = new ArrayList<String>();
-    final Deque<OutputStream> replacements = new ArrayDeque<OutputStream>();
-
-    TestFaultRecoveringOutputStream(int maxReplayBufferLength, OutputStream first) {
-      super(maxReplayBufferLength, first);
-    }
-
-    @Override protected OutputStream replacementStream(IOException e) {
-      exceptionMessages.add(e.getMessage());
-      return replacements.poll();
-    }
-  }
-}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/StrictLineReaderTest.java b/okhttp/src/test/java/com/squareup/okhttp/internal/StrictLineReaderTest.java
deleted file mode 100644
index 252f6ac85c..0000000000
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/StrictLineReaderTest.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (C) 2012 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.squareup.okhttp.internal;
-
-import java.io.ByteArrayInputStream;
-import java.io.EOFException;
-import java.io.InputStream;
-import org.junit.Test;
-
-import static com.squareup.okhttp.internal.Util.US_ASCII;
-import static org.junit.Assert.fail;
-
-public final class StrictLineReaderTest {
-  @Test public void lineReaderConsistencyWithReadAsciiLine() throws Exception {
-    // Testing with LineReader buffer capacity 32 to check some corner cases.
-    StrictLineReader lineReader = new StrictLineReader(createTestInputStream(), 32, US_ASCII);
-    InputStream refStream = createTestInputStream();
-    while (true) {
-      try {
-        String refLine = Util.readAsciiLine(refStream);
-        try {
-          String line = lineReader.readLine();
-          if (!refLine.equals(line)) {
-            fail("line (\"" + line + "\") differs from expected (\"" + refLine + "\").");
-          }
-        } catch (EOFException eof) {
-          fail("line reader threw EOFException too early.");
-        }
-      } catch (EOFException refEof) {
-        try {
-          lineReader.readLine();
-          fail("line reader didn't throw the expected EOFException.");
-        } catch (EOFException eof) {
-          // OK
-          break;
-        }
-      }
-    }
-    refStream.close();
-    lineReader.close();
-  }
-
-  private InputStream createTestInputStream() {
-    return new ByteArrayInputStream((
-                /* each source lines below should represent 32 bytes, until the next comment */
-        "12 byte line\n18 byte line......\n" +
-            "pad\nline spanning two 32-byte bu" +
-            "ffers\npad......................\n" +
-            "pad\nline spanning three 32-byte " +
-            "buffers and ending with LF at th" +
-            "e end of a 32 byte buffer......\n" +
-            "pad\nLine ending with CRLF split" +
-            " at the end of a 32-byte buffer\r" +
-            "\npad...........................\n" +
-                        /* end of 32-byte lines */
-            "line ending with CRLF\r\n" +
-            "this is a long line with embedded CR \r ending with CRLF and having more than " +
-            "32 characters\r\n" +
-            "unterminated line - should be dropped").getBytes());
-  }
-}
diff --git a/okhttp-protocols/pom.xml b/okio/pom.xml
similarity index 74%
rename from okhttp-protocols/pom.xml
rename to okio/pom.xml
index 190af43cf3..f1a33b5d66 100644
--- a/okhttp-protocols/pom.xml
+++ b/okio/pom.xml
@@ -9,19 +9,21 @@
     <version>2.0.0-SNAPSHOT</version>
   </parent>
 
-  <artifactId>okhttp-protocols</artifactId>
-  <name>OkHttp SPDY and HTTP/2.0 internals</name>
+  <groupId>com.squareup.okio</groupId>
+  <artifactId>okio</artifactId>
+  <name>Okio</name>
 
   <dependencies>
-    <dependency>
-      <groupId>org.mortbay.jetty.npn</groupId>
-      <artifactId>npn-boot</artifactId>
-      <optional>true</optional>
-    </dependency>
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>org.codehaus.mojo</groupId>
+      <artifactId>animal-sniffer-annotations</artifactId>
+      <version>1.10</version>
+      <optional>true</optional>
+    </dependency>
   </dependencies>
 </project>
diff --git a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Base64.java b/okio/src/main/java/okio/Base64.java
similarity index 53%
rename from okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Base64.java
rename to okio/src/main/java/okio/Base64.java
index 79cd0206f5..087b28747a 100644
--- a/okhttp-protocols/src/main/java/com/squareup/okhttp/internal/Base64.java
+++ b/okio/src/main/java/okio/Base64.java
@@ -19,109 +19,93 @@
  * @author Alexander Y. Kleymenov
  */
 
-package com.squareup.okhttp.internal;
+package okio;
 
 import java.io.UnsupportedEncodingException;
 
-import static com.squareup.okhttp.internal.Util.EMPTY_BYTE_ARRAY;
-
-/**
- * <a href="http://www.ietf.org/rfc/rfc2045.txt">Base64</a> encoder/decoder.
- * In violation of the RFC, this encoder doesn't wrap lines at 76 columns.
- */
-public final class Base64 {
+final class Base64 {
   private Base64() {
   }
 
-  public static byte[] decode(byte[] in) {
-    return decode(in, in.length);
-  }
-
-  public static byte[] decode(byte[] in, int len) {
-    // approximate output length
-    int length = len / 4 * 3;
-    // return an empty array on empty or short input without padding
-    if (length == 0) {
-      return EMPTY_BYTE_ARRAY;
-    }
-    // temporary array
-    byte[] out = new byte[length];
-    // number of padding characters ('=')
-    int pad = 0;
-    byte chr;
-    // compute the number of the padding characters
-    // and adjust the length of the input
-    for (; ; len--) {
-      chr = in[len - 1];
-      // skip the neutral characters
-      if ((chr == '\n') || (chr == '\r') || (chr == ' ') || (chr == '\t')) {
-        continue;
-      }
-      if (chr == '=') {
-        pad++;
-      } else {
+  public static byte[] decode(String in) {
+    // Ignore trailing '=' padding and whitespace from the input.
+    int limit = in.length();
+    for (; limit > 0; limit--) {
+      char c = in.charAt(limit - 1);
+      if (c != '=' && c != '\n' && c != '\r' && c != ' ' && c != '\t') {
         break;
       }
     }
-    // index in the output array
-    int outIndex = 0;
-    // index in the input array
-    int inIndex = 0;
-    // holds the value of the input character
-    int bits = 0;
-    // holds the value of the input quantum
-    int quantum = 0;
-    for (int i = 0; i < len; i++) {
-      chr = in[i];
-      // skip the neutral characters
-      if ((chr == '\n') || (chr == '\r') || (chr == ' ') || (chr == '\t')) {
-        continue;
-      }
-      if ((chr >= 'A') && (chr <= 'Z')) {
+
+    // If the input includes whitespace, this output array will be longer than necessary.
+    byte[] out = new byte[(int) (limit * 6L / 8L)];
+    int outCount = 0;
+    int inCount = 0;
+
+    int word = 0;
+    for (int pos = 0; pos < limit; pos++) {
+      char c = in.charAt(pos);
+
+      int bits;
+      if (c >= 'A' && c <= 'Z') {
         // char ASCII value
         //  A    65    0
         //  Z    90    25 (ASCII - 65)
-        bits = chr - 65;
-      } else if ((chr >= 'a') && (chr <= 'z')) {
+        bits = c - 65;
+      } else if (c >= 'a' && c <= 'z') {
         // char ASCII value
         //  a    97    26
         //  z    122   51 (ASCII - 71)
-        bits = chr - 71;
-      } else if ((chr >= '0') && (chr <= '9')) {
+        bits = c - 71;
+      } else if (c >= '0' && c <= '9') {
         // char ASCII value
         //  0    48    52
         //  9    57    61 (ASCII + 4)
-        bits = chr + 4;
-      } else if (chr == '+') {
+        bits = c + 4;
+      } else if (c == '+') {
         bits = 62;
-      } else if (chr == '/') {
+      } else if (c == '/') {
         bits = 63;
+      } else if (c == '\n' || c == '\r' || c == ' ' || c == '\t') {
+        continue;
       } else {
         return null;
       }
-      // append the value to the quantum
-      quantum = (quantum << 6) | (byte) bits;
-      if (inIndex % 4 == 3) {
-        // 4 characters were read, so make the output:
-        out[outIndex++] = (byte) (quantum >> 16);
-        out[outIndex++] = (byte) (quantum >> 8);
-        out[outIndex++] = (byte) quantum;
+
+      // Append this char's 6 bits to the word.
+      word = (word << 6) | (byte) bits;
+
+      // For every 4 chars of input, we accumulate 24 bits of output. Emit 3 bytes.
+      inCount++;
+      if (inCount % 4 == 0) {
+        out[outCount++] = (byte) (word >> 16);
+        out[outCount++] = (byte) (word >> 8);
+        out[outCount++] = (byte) word;
       }
-      inIndex++;
     }
-    if (pad > 0) {
-      // adjust the quantum value according to the padding
-      quantum = quantum << (6 * pad);
-      // make output
-      out[outIndex++] = (byte) (quantum >> 16);
-      if (pad == 1) {
-        out[outIndex++] = (byte) (quantum >> 8);
-      }
+
+    int lastWordChars = inCount % 4;
+    if (lastWordChars == 1) {
+      // We read 1 char followed by "===". But 6 bits is a truncated byte! Fail.
+      return null;
+    } else if (lastWordChars == 2) {
+      // We read 2 chars followed by "==". Emit 1 byte with 8 of those 12 bits.
+      word = word << 12;
+      out[outCount++] = (byte) (word >> 16);
+    } else if (lastWordChars == 3) {
+      // We read 3 chars, followed by "=". Emit 2 bytes for 16 of those 18 bits.
+      word = word << 6;
+      out[outCount++] = (byte) (word >> 16);
+      out[outCount++] = (byte) (word >> 8);
     }
-    // create the resulting array
-    byte[] result = new byte[outIndex];
-    System.arraycopy(out, 0, result, 0, outIndex);
-    return result;
+
+    // If we sized our out array perfectly, we're done.
+    if (outCount == out.length) return out;
+
+    // Copy the decoded bytes to a new, right-sized array.
+    byte[] prefix = new byte[outCount];
+    System.arraycopy(out, 0, prefix, 0, outCount);
+    return prefix;
   }
 
   private static final byte[] MAP = new byte[] {
diff --git a/okio/src/main/java/okio/BufferedSink.java b/okio/src/main/java/okio/BufferedSink.java
new file mode 100644
index 0000000000..3066011a0e
--- /dev/null
+++ b/okio/src/main/java/okio/BufferedSink.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+/**
+ * A sink that keeps a buffer internally so that callers can do small writes
+ * without a performance penalty.
+ */
+public interface BufferedSink extends Sink {
+  /** Returns this sink's internal buffer. */
+  OkBuffer buffer();
+
+  BufferedSink write(ByteString byteString) throws IOException;
+
+  /**
+   * Like {@link OutputStream#write}, this writes a complete byte array to this
+   * sink.
+   */
+  BufferedSink write(byte[] source) throws IOException;
+
+  /**
+   * Like {@link OutputStream#write}, this writes {@code byteCount} bytes
+   * of {@code source}, starting at {@code offset}.
+   */
+  BufferedSink write(byte[] source, int offset, int byteCount) throws IOException;
+
+  /** Encodes {@code string} in UTF-8 and writes it to this sink. */
+  BufferedSink writeUtf8(String string) throws IOException;
+
+  /** Writes a byte to this sink. */
+  BufferedSink writeByte(int b) throws IOException;
+
+  /** Writes a big-endian short to this sink using two bytes. */
+  BufferedSink writeShort(int s) throws IOException;
+
+  /** Writes a little-endian short to this sink using two bytes. */
+  BufferedSink writeShortLe(int s) throws IOException;
+
+  /** Writes a big-endian int to this sink using four bytes. */
+  BufferedSink writeInt(int i) throws IOException;
+
+  /** Writes a little-endian int to this sink using four bytes. */
+  BufferedSink writeIntLe(int i) throws IOException;
+
+  /** Writes a big-endian long to this sink using eight bytes. */
+  BufferedSink writeLong(long v) throws IOException;
+
+  /** Writes a little-endian long to this sink using eight bytes. */
+  BufferedSink writeLongLe(long v) throws IOException;
+
+  /** Writes complete segments to this sink. Like {@link #flush}, but weaker. */
+  BufferedSink emitCompleteSegments() throws IOException;
+
+  /** Returns an output stream that writes to this sink. */
+  OutputStream outputStream();
+}
diff --git a/okio/src/main/java/okio/BufferedSource.java b/okio/src/main/java/okio/BufferedSource.java
new file mode 100644
index 0000000000..2b48823cec
--- /dev/null
+++ b/okio/src/main/java/okio/BufferedSource.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.IOException;
+import java.io.InputStream;
+
+/**
+ * A source that keeps a buffer internally so that callers can do small reads
+ * without a performance penalty. It also allows clients to read ahead,
+ * buffering as much as necessary before consuming input.
+ */
+public interface BufferedSource extends Source {
+  /** Returns this source's internal buffer. */
+  OkBuffer buffer();
+
+  /**
+   * Returns true if there are no more bytes in this source. This will block
+   * until there are bytes to read or the source is definitely exhausted.
+   */
+  boolean exhausted() throws IOException;
+
+  /**
+   * Returns when the buffer contains at least {@code byteCount} bytes. Throws
+   * an {@link java.io.EOFException} if the source is exhausted before the
+   * required bytes can be read.
+   */
+  void require(long byteCount) throws IOException;
+
+  /** Removes a byte from this source and returns it. */
+  byte readByte() throws IOException;
+
+  /** Removes two bytes from this source and returns a big-endian short. */
+  short readShort() throws IOException;
+
+  /** Removes two bytes from this source and returns a little-endian short. */
+  short readShortLe() throws IOException;
+
+  /** Removes four bytes from this source and returns a big-endian int. */
+  int readInt() throws IOException;
+
+  /** Removes four bytes from this source and returns a little-endian int. */
+  int readIntLe() throws IOException;
+
+  /** Removes eight bytes from this source and returns a big-endian long. */
+  long readLong() throws IOException;
+
+  /** Removes eight bytes from this source and returns a little-endian long. */
+  long readLongLe() throws IOException;
+
+  /**
+   * Reads and discards {@code byteCount} bytes from this source. Throws an
+   * {@link java.io.EOFException} if the source is exhausted before the
+   * requested bytes can be skipped.
+   */
+  void skip(long byteCount) throws IOException;
+
+  /** Removes {@code byteCount} bytes from this and returns them as a byte string. */
+  ByteString readByteString(long byteCount) throws IOException;
+
+  /**
+   * Removes {@code byteCount} bytes from this, decodes them as UTF-8 and
+   * returns the string.
+   */
+  String readUtf8(long byteCount) throws IOException;
+
+  /**
+   * Removes and returns characters up to but not including the next line break.
+   * A line break is either {@code "\n"} or {@code "\r\n"}; these characters are
+   * not included in the result.
+   *
+   * <p><strong>On the end of the stream this method returns null,</strong> just
+   * like {@link java.io.BufferedReader}. If the source doesn't end with a line
+   * break then an implicit line break is assumed. Null is returned once the
+   * source is exhausted. Use this for human-generated data, where a trailing
+   * line break is optional.
+   */
+  String readUtf8Line() throws IOException;
+
+  /**
+   * Removes and returns characters up to but not including the next line break.
+   * A line break is either {@code "\n"} or {@code "\r\n"}; these characters are
+   * not included in the result.
+   *
+   * <p><strong>On the end of the stream this method throws.</strong> Every call
+   * must consume either '\r\n' or '\n'. If these characters are absent in the
+   * stream, an {@link java.io.EOFException} is thrown. Use this for
+   * machine-generated data where a missing line break implies truncated input.
+   */
+  String readUtf8LineStrict() throws IOException;
+
+  /**
+   * Returns the index of {@code b} in the buffer, refilling it if necessary
+   * until it is found. This reads an unbounded number of bytes into the buffer.
+   * Returns -1 if the stream is exhausted before the requested byte is found.
+   */
+  long indexOf(byte b) throws IOException;
+
+  /** Returns an input stream that reads from this source. */
+  InputStream inputStream();
+}
diff --git a/okio/src/main/java/okio/ByteString.java b/okio/src/main/java/okio/ByteString.java
new file mode 100644
index 0000000000..6853adb09b
--- /dev/null
+++ b/okio/src/main/java/okio/ByteString.java
@@ -0,0 +1,211 @@
+/*
+ * Copyright 2014 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Arrays;
+
+/**
+ * An immutable sequence of bytes.
+ *
+ * <p><strong>Full disclosure:</strong> this class provides untrusted input and
+ * output streams with raw access to the underlying byte array. A hostile
+ * stream implementation could keep a reference to the mutable byte string,
+ * violating the immutable guarantee of this class. For this reason a byte
+ * string's immutability guarantee cannot be relied upon for security in applets
+ * and other environments that run both trusted and untrusted code in the same
+ * process.
+ */
+public final class ByteString {
+  private static final char[] HEX_DIGITS =
+      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };
+
+  /** A singleton empty {@code ByteString}. */
+  public static final ByteString EMPTY = ByteString.of();
+
+  final byte[] data;
+  private transient int hashCode; // Lazily computed; 0 if unknown.
+  private transient String utf8; // Lazily computed.
+
+  ByteString(byte[] data) {
+    this.data = data; // Trusted internal constructor doesn't clone data.
+  }
+
+  /**
+   * Returns a new byte string containing a clone of the bytes of {@code data}.
+   */
+  public static ByteString of(byte... data) {
+    return new ByteString(data.clone());
+  }
+
+  /** Returns a new byte string containing the {@code UTF-8} bytes of {@code s}. */
+  public static ByteString encodeUtf8(String s) {
+    ByteString byteString = new ByteString(s.getBytes(Util.UTF_8));
+    byteString.utf8 = s;
+    return byteString;
+  }
+
+  /** Constructs a new {@code String} by decoding the bytes as {@code UTF-8}. */
+  public String utf8() {
+    String result = utf8;
+    // We don't care if we double-allocate in racy code.
+    return result != null ? result : (utf8 = new String(data, Util.UTF_8));
+  }
+
+  /**
+   * Returns this byte string encoded as <a
+   * href="http://www.ietf.org/rfc/rfc2045.txt">Base64</a>. In violation of the
+   * RFC, the returned string does not wrap lines at 76 columns.
+   */
+  public String base64() {
+    return Base64.encode(data);
+  }
+
+  /**
+   * Decodes the Base64-encoded bytes and returns their value as a byte string.
+   * Returns null if {@code base64} is not a Base64-encoded sequence of bytes.
+   */
+  public static ByteString decodeBase64(String base64) {
+    byte[] decoded = Base64.decode(base64);
+    return decoded != null ? new ByteString(decoded) : null;
+  }
+
+  /** Returns this byte string encoded in hexadecimal. */
+  public String hex() {
+    char[] result = new char[data.length * 2];
+    int c = 0;
+    for (byte b : data) {
+      result[c++] = HEX_DIGITS[(b >> 4) & 0xf];
+      result[c++] = HEX_DIGITS[b & 0xf];
+    }
+    return new String(result);
+  }
+
+  /** Decodes the hex-encoded bytes and returns their value a byte string. */
+  public static ByteString decodeHex(String hex) {
+    if (hex.length() % 2 != 0) throw new IllegalArgumentException("Unexpected hex string: " + hex);
+
+    byte[] result = new byte[hex.length() / 2];
+    for (int i = 0; i < result.length; i++) {
+      int d1 = decodeHexDigit(hex.charAt(i * 2)) << 4;
+      int d2 = decodeHexDigit(hex.charAt(i * 2 + 1));
+      result[i] = (byte) (d1 + d2);
+    }
+    return of(result);
+  }
+
+  private static int decodeHexDigit(char c) {
+    if (c >= '0' && c <= '9') return c - '0';
+    if (c >= 'a' && c <= 'f') return c - 'a' + 10;
+    if (c >= 'A' && c <= 'F') return c - 'A' + 10;
+    throw new IllegalArgumentException("Unexpected hex digit: " + c);
+  }
+
+  /**
+   * Reads {@code count} bytes from {@code in} and returns the result.
+   *
+   * @throws java.io.EOFException if {@code in} has fewer than {@code count}
+   *     bytes to read.
+   */
+  public static ByteString read(InputStream in, int byteCount) throws IOException {
+    byte[] result = new byte[byteCount];
+    for (int offset = 0, read; offset < byteCount; offset += read) {
+      read = in.read(result, offset, byteCount - offset);
+      if (read == -1) throw new EOFException();
+    }
+    return new ByteString(result);
+  }
+
+  /**
+   * Returns a byte string equal to this byte string, but with the bytes 'A'
+   * through 'Z' replaced with the corresponding byte in 'a' through 'z'.
+   * Returns this byte string if it contains no bytes in 'A' through 'Z'.
+   */
+  public ByteString toAsciiLowercase() {
+    // Search for an uppercase character. If we don't find one, return this.
+    for (int i = 0; i < data.length; i++) {
+      byte c = data[i];
+      if (c < 'A' || c > 'Z') continue;
+
+      // If we reach this point, this string is not not lowercase. Create and
+      // return a new byte string.
+      byte[] lowercase = data.clone();
+      lowercase[i++] = (byte) (c - ('A' - 'a'));
+      for (; i < lowercase.length; i++) {
+        c = lowercase[i];
+        if (c < 'A' || c > 'Z') continue;
+        lowercase[i] = (byte) (c - ('A' - 'a'));
+      }
+      return new ByteString(lowercase);
+    }
+    return this;
+  }
+
+  /** Returns the byte at {@code pos}. */
+  public byte getByte(int pos) {
+    return data[pos];
+  }
+
+  /**
+   * Returns the number of bytes in this ByteString.
+   */
+  public int size() {
+    return data.length;
+  }
+
+  /**
+   * Returns a byte array containing a copy of the bytes in this {@code ByteString}.
+   */
+  public byte[] toByteArray() {
+    return data.clone();
+  }
+
+  /** Writes the contents of this byte string to {@code out}. */
+  public void write(OutputStream out) throws IOException {
+    out.write(data);
+  }
+
+  @Override public boolean equals(Object o) {
+    return o == this || o instanceof ByteString && Arrays.equals(((ByteString) o).data, data);
+  }
+
+  @Override public int hashCode() {
+    int result = hashCode;
+    return result != 0 ? result : (hashCode = Arrays.hashCode(data));
+  }
+
+  @Override public String toString() {
+    if (data.length == 0) {
+      return "ByteString[size=0]";
+    }
+
+    if (data.length <= 16) {
+      return String.format("ByteString[size=%s data=%s]", data.length, hex());
+    }
+
+    try {
+      return String.format("ByteString[size=%s md5=%s]", data.length,
+          ByteString.of(MessageDigest.getInstance("MD5").digest(data)).hex());
+    } catch (NoSuchAlgorithmException e) {
+      throw new AssertionError();
+    }
+  }
+}
diff --git a/okio/src/main/java/okio/Deadline.java b/okio/src/main/java/okio/Deadline.java
new file mode 100644
index 0000000000..15a7c6d49f
--- /dev/null
+++ b/okio/src/main/java/okio/Deadline.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+
+/**
+ * The time that a requested operation is due. If the deadline is reached before
+ * the operation has completed, the operation should be aborted.
+ */
+public class Deadline {
+  public static final Deadline NONE = new Deadline() {
+    @Override public Deadline start(long timeout, TimeUnit unit) {
+      throw new UnsupportedOperationException();
+    }
+
+    @Override public boolean reached() {
+      return false;
+    }
+  };
+
+  private long deadlineNanos;
+
+  public Deadline() {
+  }
+
+  public Deadline start(long timeout, TimeUnit unit) {
+    deadlineNanos = System.nanoTime() + unit.toNanos(timeout);
+    return this;
+  }
+
+  public boolean reached() {
+    return System.nanoTime() - deadlineNanos >= 0; // Subtract to avoid overflow!
+  }
+
+  public void throwIfReached() throws IOException {
+    // TODO: a more catchable exception type?
+    if (reached()) throw new IOException("Deadline reached");
+  }
+}
diff --git a/okio/src/main/java/okio/DeflaterSink.java b/okio/src/main/java/okio/DeflaterSink.java
new file mode 100644
index 0000000000..ce7081de3f
--- /dev/null
+++ b/okio/src/main/java/okio/DeflaterSink.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.IOException;
+import java.util.zip.Deflater;
+import org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;
+
+import static okio.Util.checkOffsetAndCount;
+
+/**
+ * A sink that uses <a href="http://tools.ietf.org/html/rfc1951">DEFLATE</a> to
+ * compress data written to another source.
+ *
+ * <h3>Sync flush</h3>
+ * Aggressive flushing of this stream may result in reduced compression. Each
+ * call to {@link #flush} immediately compresses all currently-buffered data;
+ * this early compression may be less effective than compression performed
+ * without flushing.
+ *
+ * <p>This is equivalent to using {@link Deflater} with the sync flush option.
+ * This class does not offer any partial flush mechanism. For best performance,
+ * only call {@link #flush} when application behavior requires it.
+ */
+public final class DeflaterSink implements Sink {
+  private final BufferedSink sink;
+  private final Deflater deflater;
+  private boolean closed;
+
+  public DeflaterSink(Sink sink, Deflater deflater) {
+    this.sink = Okio.buffer(sink);
+    this.deflater = deflater;
+  }
+
+  @Override public void write(OkBuffer source, long byteCount)
+      throws IOException {
+    checkOffsetAndCount(source.size, 0, byteCount);
+    while (byteCount > 0) {
+      // Share bytes from the head segment of 'source' with the deflater.
+      Segment head = source.head;
+      int toDeflate = (int) Math.min(byteCount, head.limit - head.pos);
+      deflater.setInput(head.data, head.pos, toDeflate);
+
+      // Deflate those bytes into sink.
+      deflate(false);
+
+      // Mark those bytes as read.
+      source.size -= toDeflate;
+      head.pos += toDeflate;
+      if (head.pos == head.limit) {
+        source.head = head.pop();
+        SegmentPool.INSTANCE.recycle(head);
+      }
+
+      byteCount -= toDeflate;
+    }
+  }
+
+  @IgnoreJRERequirement
+  private void deflate(boolean syncFlush) throws IOException {
+    OkBuffer buffer = sink.buffer();
+    while (true) {
+      Segment s = buffer.writableSegment(1);
+
+      // The 4-parameter overload of deflate() doesn't exist in the RI until
+      // Java 1.7, and is public (although with @hide) on Android since 2.3.
+      // The @hide tag means that this code won't compile against the Android
+      // 2.3 SDK, but it will run fine there.
+      int deflated = syncFlush
+          ? deflater.deflate(s.data, s.limit, Segment.SIZE - s.limit, Deflater.SYNC_FLUSH)
+          : deflater.deflate(s.data, s.limit, Segment.SIZE - s.limit);
+
+      if (deflated > 0) {
+        s.limit += deflated;
+        buffer.size += deflated;
+        sink.emitCompleteSegments();
+      } else if (deflater.needsInput()) {
+        return;
+      }
+    }
+  }
+
+  @Override public void flush() throws IOException {
+    deflate(true);
+    sink.flush();
+  }
+
+  @Override public void close() throws IOException {
+    if (closed) return;
+
+    // Emit deflated data to the underlying sink. If this fails, we still need
+    // to close the deflater and the sink; otherwise we risk leaking resources.
+    Throwable thrown = null;
+    try {
+      deflater.finish();
+      deflate(false);
+    } catch (Throwable e) {
+      thrown = e;
+    }
+
+    try {
+      deflater.end();
+    } catch (Throwable e) {
+      if (thrown == null) thrown = e;
+    }
+
+    try {
+      sink.close();
+    } catch (Throwable e) {
+      if (thrown == null) thrown = e;
+    }
+    closed = true;
+
+    if (thrown != null) Util.sneakyRethrow(thrown);
+  }
+
+  @Override public Sink deadline(Deadline deadline) {
+    sink.deadline(deadline);
+    return this;
+  }
+
+  @Override public String toString() {
+    return "DeflaterSink(" + sink + ")";
+  }
+}
diff --git a/okio/src/main/java/okio/GzipSource.java b/okio/src/main/java/okio/GzipSource.java
new file mode 100644
index 0000000000..eae3a16459
--- /dev/null
+++ b/okio/src/main/java/okio/GzipSource.java
@@ -0,0 +1,200 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.util.zip.CRC32;
+import java.util.zip.Inflater;
+
+public final class GzipSource implements Source {
+  private static final byte FHCRC = 1;
+  private static final byte FEXTRA = 2;
+  private static final byte FNAME = 3;
+  private static final byte FCOMMENT = 4;
+
+  private static final byte SECTION_HEADER = 0;
+  private static final byte SECTION_BODY = 1;
+  private static final byte SECTION_TRAILER = 2;
+  private static final byte SECTION_DONE = 3;
+
+  /** The current section. Always progresses forward. */
+  private int section = SECTION_HEADER;
+
+  /**
+   * Our source should yield a GZIP header (which we consume directly), followed
+   * by deflated bytes (which we consume via an InflaterSource), followed by a
+   * GZIP trailer (which we also consume directly).
+   */
+  private final BufferedSource source;
+
+  /** The inflater used to decompress the deflated body. */
+  private final Inflater inflater;
+
+  /**
+   * The inflater source takes care of moving data between compressed source and
+   * decompressed sink buffers.
+   */
+  private final InflaterSource inflaterSource;
+
+  /** Checksum used to check both the GZIP header and decompressed body. */
+  private final CRC32 crc = new CRC32();
+
+  public GzipSource(Source source) throws IOException {
+    this.inflater = new Inflater(true);
+    this.source = Okio.buffer(source);
+    this.inflaterSource = new InflaterSource(this.source, inflater);
+  }
+
+  @Override public long read(OkBuffer sink, long byteCount) throws IOException {
+    if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+    if (byteCount == 0) return 0;
+
+    // If we haven't consumed the header, we must consume it before anything else.
+    if (section == SECTION_HEADER) {
+      consumeHeader();
+      section = SECTION_BODY;
+    }
+
+    // Attempt to read at least a byte of the body. If we do, we're done.
+    if (section == SECTION_BODY) {
+      long offset = sink.size;
+      long result = inflaterSource.read(sink, byteCount);
+      if (result != -1) {
+        updateCrc(sink, offset, result);
+        return result;
+      }
+      section = SECTION_TRAILER;
+    }
+
+    // The body is exhausted; time to read the trailer. We always consume the
+    // trailer before returning a -1 exhausted result; that way if you read to
+    // the end of a GzipSource you guarantee that the CRC has been checked.
+    if (section == SECTION_TRAILER) {
+      consumeTrailer();
+      section = SECTION_DONE;
+
+      // Gzip streams self-terminate: they return -1 before their underlying
+      // source returns -1. Here we attempt to force the underlying stream to
+      // return -1 which may trigger it to release its resources. If it doesn't
+      // return -1, then our Gzip data finished prematurely!
+      if (!source.exhausted()) {
+        throw new IOException("gzip finished without exhausting source");
+      }
+    }
+
+    return -1;
+  }
+
+  private void consumeHeader() throws IOException {
+    // Read the 10-byte header. We peek at the flags byte first so we know if we
+    // need to CRC the entire header. Then we read the magic ID1ID2 sequence.
+    // We can skip everything else in the first 10 bytes.
+    // +---+---+---+---+---+---+---+---+---+---+
+    // |ID1|ID2|CM |FLG|     MTIME     |XFL|OS | (more-->)
+    // +---+---+---+---+---+---+---+---+---+---+
+    source.require(10);
+    byte flags = source.buffer().getByte(3);
+    boolean fhcrc = ((flags >> FHCRC) & 1) == 1;
+    if (fhcrc) updateCrc(source.buffer(), 0, 10);
+
+    short id1id2 = source.readShort();
+    checkEqual("ID1ID2", (short) 0x1f8b, id1id2);
+    source.skip(8);
+
+    // Skip optional extra fields.
+    // +---+---+=================================+
+    // | XLEN  |...XLEN bytes of "extra field"...| (more-->)
+    // +---+---+=================================+
+    if (((flags >> FEXTRA) & 1) == 1) {
+      source.require(2);
+      if (fhcrc) updateCrc(source.buffer(), 0, 2);
+      int xlen = source.buffer().readShortLe();
+      source.require(xlen);
+      if (fhcrc) updateCrc(source.buffer(), 0, xlen);
+      source.skip(xlen);
+    }
+
+    // Skip an optional 0-terminated name.
+    // +=========================================+
+    // |...original file name, zero-terminated...| (more-->)
+    // +=========================================+
+    if (((flags >> FNAME) & 1) == 1) {
+      long index = source.indexOf((byte) 0);
+      if (index == -1) throw new EOFException();
+      if (fhcrc) updateCrc(source.buffer(), 0, index + 1);
+      source.skip(index + 1);
+    }
+
+    // Skip an optional 0-terminated comment.
+    // +===================================+
+    // |...file comment, zero-terminated...| (more-->)
+    // +===================================+
+    if (((flags >> FCOMMENT) & 1) == 1) {
+      long index = source.indexOf((byte) 0);
+      if (index == -1) throw new EOFException();
+      if (fhcrc) updateCrc(source.buffer(), 0, index + 1);
+      source.skip(index + 1);
+    }
+
+    // Confirm the optional header CRC.
+    // +---+---+
+    // | CRC16 |
+    // +---+---+
+    if (fhcrc) {
+      checkEqual("FHCRC", source.readShortLe(), (short) crc.getValue());
+      crc.reset();
+    }
+  }
+
+  private void consumeTrailer() throws IOException {
+    // Read the eight-byte trailer. Confirm the body's CRC and size.
+    // +---+---+---+---+---+---+---+---+
+    // |     CRC32     |     ISIZE     |
+    // +---+---+---+---+---+---+---+---+
+    checkEqual("CRC", source.readIntLe(), (int) crc.getValue());
+    checkEqual("ISIZE", source.readIntLe(), inflater.getTotalOut());
+  }
+
+  @Override public Source deadline(Deadline deadline) {
+    source.deadline(deadline);
+    return this;
+  }
+
+  @Override public void close() throws IOException {
+    inflaterSource.close();
+  }
+
+  /** Updates the CRC with the given bytes. */
+  private void updateCrc(OkBuffer buffer, long offset, long byteCount) {
+    for (Segment s = buffer.head; byteCount > 0; s = s.next) {
+      int segmentByteCount = s.limit - s.pos;
+      if (offset < segmentByteCount) {
+        int toUpdate = (int) Math.min(byteCount, segmentByteCount - offset);
+        crc.update(s.data, (int) (s.pos + offset), toUpdate);
+        byteCount -= toUpdate;
+      }
+      offset -= segmentByteCount; // Track the offset of the current segment.
+    }
+  }
+
+  private void checkEqual(String name, int expected, int actual) throws IOException {
+    if (actual != expected) {
+      throw new IOException(String.format(
+          "%s: actual 0x%08x != expected 0x%08x", name, actual, expected));
+    }
+  }
+}
diff --git a/okio/src/main/java/okio/InflaterSource.java b/okio/src/main/java/okio/InflaterSource.java
new file mode 100644
index 0000000000..c86c9959a5
--- /dev/null
+++ b/okio/src/main/java/okio/InflaterSource.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.util.zip.DataFormatException;
+import java.util.zip.Inflater;
+
+/**
+ * A source that uses <a href="http://tools.ietf.org/html/rfc1951">DEFLATE</a>
+ * to decompress data read from another source.
+ */
+public final class InflaterSource implements Source {
+  private final BufferedSource source;
+  private final Inflater inflater;
+
+  /**
+   * When we call Inflater.setInput(), the inflater keeps our byte array until
+   * it needs input again. This tracks how many bytes the inflater is currently
+   * holding on to.
+   */
+  private int bufferBytesHeldByInflater;
+  private boolean closed;
+
+  public InflaterSource(Source source, Inflater inflater) {
+    this(Okio.buffer(source), inflater);
+  }
+
+  /**
+   * This package-private constructor shares a buffer with its trusted caller.
+   * In general we can't share a BufferedSource because the inflater holds input
+   * bytes until they are inflated.
+   */
+  InflaterSource(BufferedSource source, Inflater inflater) {
+    if (source == null) throw new IllegalArgumentException("source == null");
+    if (inflater == null) throw new IllegalArgumentException("inflater == null");
+    this.source = source;
+    this.inflater = inflater;
+  }
+
+  @Override public long read(
+      OkBuffer sink, long byteCount) throws IOException {
+    if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+    if (closed) throw new IllegalStateException("closed");
+    if (byteCount == 0) return 0;
+
+    while (true) {
+      boolean sourceExhausted = refill();
+
+      // Decompress the inflater's compressed data into the sink.
+      try {
+        Segment tail = sink.writableSegment(1);
+        int bytesInflated = inflater.inflate(tail.data, tail.limit, Segment.SIZE - tail.limit);
+        if (bytesInflated > 0) {
+          tail.limit += bytesInflated;
+          sink.size += bytesInflated;
+          return bytesInflated;
+        }
+        if (inflater.finished() || inflater.needsDictionary()) {
+          releaseInflatedBytes();
+          return -1;
+        }
+        if (sourceExhausted) throw new EOFException("source exhausted prematurely");
+      } catch (DataFormatException e) {
+        throw new IOException(e);
+      }
+    }
+  }
+
+  /**
+   * Refills the inflater with compressed data if it needs input. (And only if
+   * it needs input). Returns true if the inflater required input but the source
+   * was exhausted.
+   */
+  public boolean refill() throws IOException {
+    if (!inflater.needsInput()) return false;
+
+    releaseInflatedBytes();
+    if (inflater.getRemaining() != 0) throw new IllegalStateException("?"); // TODO: possible?
+
+    // If there are compressed bytes in the source, assign them to the inflater.
+    if (source.exhausted()) return true;
+
+    // Assign buffer bytes to the inflater.
+    Segment head = source.buffer().head;
+    bufferBytesHeldByInflater = head.limit - head.pos;
+    inflater.setInput(head.data, head.pos, bufferBytesHeldByInflater);
+    return false;
+  }
+
+  /** When the inflater has processed compressed data, remove it from the buffer. */
+  private void releaseInflatedBytes() throws IOException {
+    if (bufferBytesHeldByInflater == 0) return;
+    int toRelease = bufferBytesHeldByInflater - inflater.getRemaining();
+    bufferBytesHeldByInflater -= toRelease;
+    source.skip(toRelease);
+  }
+
+  @Override public Source deadline(Deadline deadline) {
+    source.deadline(deadline);
+    return this;
+  }
+
+  @Override public void close() throws IOException {
+    if (closed) return;
+    inflater.end();
+    closed = true;
+    source.close();
+  }
+}
diff --git a/okio/src/main/java/okio/OkBuffer.java b/okio/src/main/java/okio/OkBuffer.java
new file mode 100644
index 0000000000..8dc4290c2b
--- /dev/null
+++ b/okio/src/main/java/okio/OkBuffer.java
@@ -0,0 +1,745 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import static okio.Util.UTF_8;
+import static okio.Util.checkOffsetAndCount;
+import static okio.Util.reverseBytesLong;
+
+/**
+ * A collection of bytes in memory.
+ *
+ * <p><strong>Moving data from one OkBuffer to another is fast.</strong> Instead
+ * of copying bytes from one place in memory to another, this class just changes
+ * ownership of the underlying byte arrays.
+ *
+ * <p><strong>This buffer grows with your data.</strong> Just like ArrayList,
+ * each OkBuffer starts small. It consumes only the memory it needs to.
+ *
+ * <p><strong>This buffer pools its byte arrays.</strong> When you allocate a
+ * byte array in Java, the runtime must zero-fill the requested array before
+ * returning it to you. Even if you're going to write over that space anyway.
+ * This class avoids zero-fill and GC churn by pooling byte arrays.
+ */
+public final class OkBuffer implements BufferedSource, BufferedSink, Cloneable {
+  Segment head;
+  long size;
+
+  public OkBuffer() {
+  }
+
+  /** Returns the number of bytes currently in this buffer. */
+  public long size() {
+    return size;
+  }
+
+  @Override public OkBuffer buffer() {
+    return this;
+  }
+
+  @Override public OutputStream outputStream() {
+    return new OutputStream() {
+      @Override public void write(int b) {
+        writeByte((byte) b);
+      }
+
+      @Override public void write(byte[] data, int offset, int byteCount) {
+        OkBuffer.this.write(data, offset, byteCount);
+      }
+
+      @Override public void flush() {
+      }
+
+      @Override public void close() {
+      }
+
+      @Override public String toString() {
+        return this + ".outputStream()";
+      }
+    };
+  }
+
+  @Override public OkBuffer emitCompleteSegments() {
+    return this; // Nowhere to emit to!
+  }
+
+  @Override public boolean exhausted() {
+    return size == 0;
+  }
+
+  @Override public void require(long byteCount) throws EOFException {
+    if (this.size < byteCount) throw new EOFException();
+  }
+
+  @Override public InputStream inputStream() {
+    return new InputStream() {
+      @Override public int read() {
+        return readByte() & 0xff;
+      }
+
+      @Override public int read(byte[] sink, int offset, int byteCount) {
+        return OkBuffer.this.read(sink, offset, byteCount);
+      }
+
+      @Override public int available() {
+        return (int) Math.min(size, Integer.MAX_VALUE);
+      }
+
+      @Override public void close() {
+      }
+
+      @Override public String toString() {
+        return OkBuffer.this + ".inputStream()";
+      }
+    };
+  }
+
+  /**
+   * Returns the number of bytes in segments that are not writable. This is the
+   * number of bytes that can be flushed immediately to an underlying sink
+   * without harming throughput.
+   */
+  public long completeSegmentByteCount() {
+    long result = size;
+    if (result == 0) return 0;
+
+    // Omit the tail if it's still writable.
+    Segment tail = head.prev;
+    if (tail.limit < Segment.SIZE) {
+      result -= tail.limit - tail.pos;
+    }
+
+    return result;
+  }
+
+  @Override public byte readByte() {
+    if (size == 0) throw new IllegalStateException("size == 0");
+
+    Segment segment = head;
+    int pos = segment.pos;
+    int limit = segment.limit;
+
+    byte[] data = segment.data;
+    byte b = data[pos++];
+    size -= 1;
+
+    if (pos == limit) {
+      head = segment.pop();
+      SegmentPool.INSTANCE.recycle(segment);
+    } else {
+      segment.pos = pos;
+    }
+
+    return b;
+  }
+
+  /** Returns the byte at {@code pos}. */
+  public byte getByte(long pos) {
+    checkOffsetAndCount(size, pos, 1);
+    for (Segment s = head; true; s = s.next) {
+      int segmentByteCount = s.limit - s.pos;
+      if (pos < segmentByteCount) return s.data[s.pos + (int) pos];
+      pos -= segmentByteCount;
+    }
+  }
+
+  @Override public short readShort() {
+    if (size < 2) throw new IllegalStateException("size < 2: " + size);
+
+    Segment segment = head;
+    int pos = segment.pos;
+    int limit = segment.limit;
+
+    // If the short is split across multiple segments, delegate to readByte().
+    if (limit - pos < 2) {
+      int s = (readByte() & 0xff) << 8
+          |   (readByte() & 0xff);
+      return (short) s;
+    }
+
+    byte[] data = segment.data;
+    int s = (data[pos++] & 0xff) << 8
+        |   (data[pos++] & 0xff);
+    size -= 2;
+
+    if (pos == limit) {
+      head = segment.pop();
+      SegmentPool.INSTANCE.recycle(segment);
+    } else {
+      segment.pos = pos;
+    }
+
+    return (short) s;
+  }
+
+  @Override public int readInt() {
+    if (size < 4) throw new IllegalStateException("size < 4: " + size);
+
+    Segment segment = head;
+    int pos = segment.pos;
+    int limit = segment.limit;
+
+    // If the int is split across multiple segments, delegate to readByte().
+    if (limit - pos < 4) {
+      return (readByte() & 0xff) << 24
+          |  (readByte() & 0xff) << 16
+          |  (readByte() & 0xff) <<  8
+          |  (readByte() & 0xff);
+    }
+
+    byte[] data = segment.data;
+    int i = (data[pos++] & 0xff) << 24
+        |   (data[pos++] & 0xff) << 16
+        |   (data[pos++] & 0xff) <<  8
+        |   (data[pos++] & 0xff);
+    size -= 4;
+
+    if (pos == limit) {
+      head = segment.pop();
+      SegmentPool.INSTANCE.recycle(segment);
+    } else {
+      segment.pos = pos;
+    }
+
+    return i;
+  }
+
+  @Override public long readLong() {
+    if (size < 8) throw new IllegalStateException("size < 8: " + size);
+
+    Segment segment = head;
+    int pos = segment.pos;
+    int limit = segment.limit;
+
+    // If the long is split across multiple segments, delegate to readInt().
+    if (limit - pos < 8) {
+      return (readInt() & 0xffffffffL) << 32
+          |  (readInt() & 0xffffffffL);
+    }
+
+    byte[] data = segment.data;
+    long v = (data[pos++] & 0xffL) << 56
+        |    (data[pos++] & 0xffL) << 48
+        |    (data[pos++] & 0xffL) << 40
+        |    (data[pos++] & 0xffL) << 32
+        |    (data[pos++] & 0xffL) << 24
+        |    (data[pos++] & 0xffL) << 16
+        |    (data[pos++] & 0xffL) <<  8
+        |    (data[pos++] & 0xffL);
+    size -= 8;
+
+    if (pos == limit) {
+      head = segment.pop();
+      SegmentPool.INSTANCE.recycle(segment);
+    } else {
+      segment.pos = pos;
+    }
+
+    return v;
+  }
+
+  @Override public short readShortLe() {
+    return Util.reverseBytesShort(readShort());
+  }
+
+  @Override public int readIntLe() {
+    return Util.reverseBytesInt(readInt());
+  }
+
+  @Override public long readLongLe() {
+    return Util.reverseBytesLong(readLong());
+  }
+
+  @Override public ByteString readByteString(long byteCount) {
+    return new ByteString(readBytes(byteCount));
+  }
+
+  @Override public String readUtf8(long byteCount) {
+    checkOffsetAndCount(this.size, 0, byteCount);
+    if (byteCount > Integer.MAX_VALUE) {
+      throw new IllegalArgumentException("byteCount > Integer.MAX_VALUE: " + byteCount);
+    }
+    if (byteCount == 0) return "";
+
+    Segment head = this.head;
+    if (head.pos + byteCount > head.limit) {
+      // If the string spans multiple segments, delegate to readBytes().
+      return new String(readBytes(byteCount), Util.UTF_8);
+    }
+
+    String result = new String(head.data, head.pos, (int) byteCount, UTF_8);
+    head.pos += byteCount;
+    this.size -= byteCount;
+
+    if (head.pos == head.limit) {
+      this.head = head.pop();
+      SegmentPool.INSTANCE.recycle(head);
+    }
+
+    return result;
+  }
+
+  @Override public String readUtf8Line() throws IOException {
+    long newline = indexOf((byte) '\n');
+
+    if (newline == -1) {
+      return size != 0 ? readUtf8(size) : null;
+    }
+
+    return readUtf8Line(newline);
+  }
+
+  @Override public String readUtf8LineStrict() throws IOException {
+    long newline = indexOf((byte) '\n');
+    if (newline == -1) throw new EOFException();
+    return readUtf8Line(newline);
+  }
+
+  String readUtf8Line(long newline) {
+    if (newline > 0 && getByte(newline - 1) == '\r') {
+      // Read everything until '\r\n', then skip the '\r\n'.
+      String result = readUtf8((newline - 1));
+      skip(2);
+      return result;
+
+    } else {
+      // Read everything until '\n', then skip the '\n'.
+      String result = readUtf8(newline);
+      skip(1);
+      return result;
+    }
+  }
+
+  private byte[] readBytes(long byteCount) {
+    checkOffsetAndCount(this.size, 0, byteCount);
+    if (byteCount > Integer.MAX_VALUE) {
+      throw new IllegalArgumentException("byteCount > Integer.MAX_VALUE: " + byteCount);
+    }
+
+    int offset = 0;
+    byte[] result = new byte[(int) byteCount];
+
+    while (offset < byteCount) {
+      int toCopy = (int) Math.min(byteCount - offset, head.limit - head.pos);
+      System.arraycopy(head.data, head.pos, result, offset, toCopy);
+
+      offset += toCopy;
+      head.pos += toCopy;
+
+      if (head.pos == head.limit) {
+        Segment toRecycle = head;
+        head = toRecycle.pop();
+        SegmentPool.INSTANCE.recycle(toRecycle);
+      }
+    }
+
+    this.size -= byteCount;
+    return result;
+  }
+
+  /** Like {@link InputStream#read}. */
+  int read(byte[] sink, int offset, int byteCount) {
+    Segment s = this.head;
+    if (s == null) return -1;
+    int toCopy = Math.min(byteCount, s.limit - s.pos);
+    System.arraycopy(s.data, s.pos, sink, offset, toCopy);
+
+    s.pos += toCopy;
+    this.size -= toCopy;
+
+    if (s.pos == s.limit) {
+      this.head = s.pop();
+      SegmentPool.INSTANCE.recycle(s);
+    }
+
+    return toCopy;
+  }
+
+  /**
+   * Discards all bytes in this buffer. Calling this method when you're done
+   * with a buffer will return its segments to the pool.
+   */
+  public void clear() {
+    skip(size);
+  }
+
+  /** Discards {@code byteCount} bytes from the head of this buffer. */
+  @Override public void skip(long byteCount) {
+    checkOffsetAndCount(this.size, 0, byteCount);
+
+    this.size -= byteCount;
+    while (byteCount > 0) {
+      int toSkip = (int) Math.min(byteCount, head.limit - head.pos);
+      byteCount -= toSkip;
+      head.pos += toSkip;
+
+      if (head.pos == head.limit) {
+        Segment toRecycle = head;
+        head = toRecycle.pop();
+        SegmentPool.INSTANCE.recycle(toRecycle);
+      }
+    }
+  }
+
+  @Override public OkBuffer write(ByteString byteString) {
+    return write(byteString.data, 0, byteString.data.length);
+  }
+
+  @Override public OkBuffer writeUtf8(String string) {
+    // TODO: inline UTF-8 encoding to save allocating a byte[]?
+    byte[] data = string.getBytes(Util.UTF_8);
+    return write(data, 0, data.length);
+  }
+
+  @Override public OkBuffer write(byte[] source) {
+    return write(source, 0, source.length);
+  }
+
+  @Override public OkBuffer write(byte[] source, int offset, int byteCount) {
+    int limit = offset + byteCount;
+    while (offset < limit) {
+      Segment tail = writableSegment(1);
+
+      int toCopy = Math.min(limit - offset, Segment.SIZE - tail.limit);
+      System.arraycopy(source, offset, tail.data, tail.limit, toCopy);
+
+      offset += toCopy;
+      tail.limit += toCopy;
+    }
+
+    this.size += byteCount;
+    return this;
+  }
+
+  @Override public OkBuffer writeByte(int b) {
+    Segment tail = writableSegment(1);
+    tail.data[tail.limit++] = (byte) b;
+    size += 1;
+    return this;
+  }
+
+  @Override public OkBuffer writeShort(int s) {
+    Segment tail = writableSegment(2);
+    byte[] data = tail.data;
+    int limit = tail.limit;
+    data[limit++] = (byte) ((s >>> 8) & 0xff);
+    data[limit++] = (byte)  (s        & 0xff);
+    tail.limit = limit;
+    size += 2;
+    return this;
+  }
+
+  @Override public BufferedSink writeShortLe(int s) {
+    return writeShort(Util.reverseBytesShort((short) s));
+  }
+
+  @Override public OkBuffer writeInt(int i) {
+    Segment tail = writableSegment(4);
+    byte[] data = tail.data;
+    int limit = tail.limit;
+    data[limit++] = (byte) ((i >>> 24) & 0xff);
+    data[limit++] = (byte) ((i >>> 16) & 0xff);
+    data[limit++] = (byte) ((i >>>  8) & 0xff);
+    data[limit++] = (byte)  (i         & 0xff);
+    tail.limit = limit;
+    size += 4;
+    return this;
+  }
+
+  @Override public BufferedSink writeIntLe(int i) {
+    return writeInt(Util.reverseBytesInt(i));
+  }
+
+  @Override public OkBuffer writeLong(long v) {
+    Segment tail = writableSegment(8);
+    byte[] data = tail.data;
+    int limit = tail.limit;
+    data[limit++] = (byte) ((v >>> 56L) & 0xff);
+    data[limit++] = (byte) ((v >>> 48L) & 0xff);
+    data[limit++] = (byte) ((v >>> 40L) & 0xff);
+    data[limit++] = (byte) ((v >>> 32L) & 0xff);
+    data[limit++] = (byte) ((v >>> 24L) & 0xff);
+    data[limit++] = (byte) ((v >>> 16L) & 0xff);
+    data[limit++] = (byte) ((v >>>  8L) & 0xff);
+    data[limit++] = (byte)  (v          & 0xff);
+    tail.limit = limit;
+    size += 8;
+    return this;
+  }
+
+  @Override public BufferedSink writeLongLe(long v) {
+    return writeLong(reverseBytesLong(v));
+  }
+
+  /**
+   * Returns a tail segment that we can write at least {@code minimumCapacity}
+   * bytes to, creating it if necessary.
+   */
+  Segment writableSegment(int minimumCapacity) {
+    if (minimumCapacity < 1 || minimumCapacity > Segment.SIZE) throw new IllegalArgumentException();
+
+    if (head == null) {
+      head = SegmentPool.INSTANCE.take(); // Acquire a first segment.
+      return head.next = head.prev = head;
+    }
+
+    Segment tail = head.prev;
+    if (tail.limit + minimumCapacity > Segment.SIZE) {
+      tail = tail.push(SegmentPool.INSTANCE.take()); // Append a new empty segment to fill up.
+    }
+    return tail;
+  }
+
+  @Override public void write(OkBuffer source, long byteCount) {
+    // Move bytes from the head of the source buffer to the tail of this buffer
+    // while balancing two conflicting goals: don't waste CPU and don't waste
+    // memory.
+    //
+    //
+    // Don't waste CPU (ie. don't copy data around).
+    //
+    // Copying large amounts of data is expensive. Instead, we prefer to
+    // reassign entire segments from one OkBuffer to the other.
+    //
+    //
+    // Don't waste memory.
+    //
+    // As an invariant, adjacent pairs of segments in an OkBuffer should be at
+    // least 50% full, except for the head segment and the tail segment.
+    //
+    // The head segment cannot maintain the invariant because the application is
+    // consuming bytes from this segment, decreasing its level.
+    //
+    // The tail segment cannot maintain the invariant because the application is
+    // producing bytes, which may require new nearly-empty tail segments to be
+    // appended.
+    //
+    //
+    // Moving segments between buffers
+    //
+    // When writing one buffer to another, we prefer to reassign entire segments
+    // over copying bytes into their most compact form. Suppose we have a buffer
+    // with these segment levels [91%, 61%]. If we append a buffer with a
+    // single [72%] segment, that yields [91%, 61%, 72%]. No bytes are copied.
+    //
+    // Or suppose we have a buffer with these segment levels: [100%, 2%], and we
+    // want to append it to a buffer with these segment levels [99%, 3%]. This
+    // operation will yield the following segments: [100%, 2%, 99%, 3%]. That
+    // is, we do not spend time copying bytes around to achieve more efficient
+    // memory use like [100%, 100%, 4%].
+    //
+    // When combining buffers, we will compact adjacent buffers when their
+    // combined level doesn't exceed 100%. For example, when we start with
+    // [100%, 40%] and append [30%, 80%], the result is [100%, 70%, 80%].
+    //
+    //
+    // Splitting segments
+    //
+    // Occasionally we write only part of a source buffer to a sink buffer. For
+    // example, given a sink [51%, 91%], we may want to write the first 30% of
+    // a source [92%, 82%] to it. To simplify, we first transform the source to
+    // an equivalent buffer [30%, 62%, 82%] and then move the head segment,
+    // yielding sink [51%, 91%, 30%] and source [62%, 82%].
+
+    if (source == this) {
+      throw new IllegalArgumentException("source == this");
+    }
+    checkOffsetAndCount(source.size, 0, byteCount);
+
+    while (byteCount > 0) {
+      // Is a prefix of the source's head segment all that we need to move?
+      if (byteCount < (source.head.limit - source.head.pos)) {
+        Segment tail = head != null ? head.prev : null;
+        if (tail == null || byteCount + (tail.limit - tail.pos) > Segment.SIZE) {
+          // We're going to need another segment. Split the source's head
+          // segment in two, then move the first of those two to this buffer.
+          source.head = source.head.split((int) byteCount);
+        } else {
+          // Our existing segments are sufficient. Move bytes from source's head to our tail.
+          source.head.writeTo(tail, (int) byteCount);
+          source.size -= byteCount;
+          this.size += byteCount;
+          return;
+        }
+      }
+
+      // Remove the source's head segment and append it to our tail.
+      Segment segmentToMove = source.head;
+      long movedByteCount = segmentToMove.limit - segmentToMove.pos;
+      source.head = segmentToMove.pop();
+      if (head == null) {
+        head = segmentToMove;
+        head.next = head.prev = head;
+      } else {
+        Segment tail = head.prev;
+        tail = tail.push(segmentToMove);
+        tail.compact();
+      }
+      source.size -= movedByteCount;
+      this.size += movedByteCount;
+      byteCount -= movedByteCount;
+    }
+  }
+
+  @Override public long read(OkBuffer sink, long byteCount) {
+    if (this.size == 0) return -1L;
+    if (byteCount > this.size) byteCount = this.size;
+    sink.write(this, byteCount);
+    return byteCount;
+  }
+
+  @Override public OkBuffer deadline(Deadline deadline) {
+    // All operations are in memory so this class doesn't need to honor deadlines.
+    return this;
+  }
+
+  @Override public long indexOf(byte b) {
+    return indexOf(b, 0);
+  }
+
+  /**
+   * Returns the index of {@code b} in this at or beyond {@code fromIndex}, or
+   * -1 if this buffer does not contain {@code b} in that range.
+   */
+  public long indexOf(byte b, long fromIndex) {
+    Segment s = head;
+    if (s == null) return -1L;
+    long offset = 0L;
+    do {
+      int segmentByteCount = s.limit - s.pos;
+      if (fromIndex > segmentByteCount) {
+        fromIndex -= segmentByteCount;
+      } else {
+        byte[] data = s.data;
+        for (long pos = s.pos + fromIndex, limit = s.limit; pos < limit; pos++) {
+          if (data[(int) pos] == b) return offset + pos - s.pos;
+        }
+        fromIndex = 0;
+      }
+      offset += segmentByteCount;
+      s = s.next;
+    } while (s != head);
+    return -1L;
+  }
+
+  @Override public void flush() {
+  }
+
+  @Override public void close() {
+  }
+
+  /** For testing. This returns the sizes of the segments in this buffer. */
+  List<Integer> segmentSizes() {
+    if (head == null) return Collections.emptyList();
+    List<Integer> result = new ArrayList<Integer>();
+    result.add(head.limit - head.pos);
+    for (Segment s = head.next; s != head; s = s.next) {
+      result.add(s.limit - s.pos);
+    }
+    return result;
+  }
+
+  @Override public boolean equals(Object o) {
+    if (!(o instanceof OkBuffer)) return false;
+    OkBuffer that = (OkBuffer) o;
+    if (size != that.size) return false;
+    if (size == 0) return true; // Both buffers are empty.
+
+    Segment sa = this.head;
+    Segment sb = that.head;
+    int posA = sa.pos;
+    int posB = sb.pos;
+
+    for (long pos = 0, count; pos < size; pos += count) {
+      count = Math.min(sa.limit - posA, sb.limit - posB);
+
+      for (int i = 0; i < count; i++) {
+        if (sa.data[posA++] != sb.data[posB++]) return false;
+      }
+
+      if (posA == sa.limit) {
+        sa = sa.next;
+        posA = sa.pos;
+      }
+
+      if (posB == sb.limit) {
+        sb = sb.next;
+        posB = sb.pos;
+      }
+    }
+
+    return true;
+  }
+
+  @Override public int hashCode() {
+    Segment s = head;
+    if (s == null) return 0;
+    int result = 1;
+    do {
+      for (int pos = s.pos, limit = s.limit; pos < limit; pos++) {
+        result = 31 * result + s.data[pos];
+      }
+      s = s.next;
+    } while (s != head);
+    return result;
+  }
+
+  @Override public String toString() {
+    if (size == 0) {
+      return "OkBuffer[size=0]";
+    }
+
+    if (size <= 16) {
+      ByteString data = clone().readByteString(size);
+      return String.format("OkBuffer[size=%s data=%s]", size, data.hex());
+    }
+
+    try {
+      MessageDigest md5 = MessageDigest.getInstance("MD5");
+      md5.update(head.data, head.pos, head.limit - head.pos);
+      for (Segment s = head.next; s != head; s = s.next) {
+        md5.update(s.data, s.pos, s.limit - s.pos);
+      }
+      return String.format("OkBuffer[size=%s md5=%s]",
+          size, ByteString.of(md5.digest()).hex());
+    } catch (NoSuchAlgorithmException e) {
+      throw new AssertionError();
+    }
+  }
+
+  /** Returns a deep copy of this buffer. */
+  @Override public OkBuffer clone() {
+    OkBuffer result = new OkBuffer();
+    if (size() == 0) return result;
+
+    result.write(head.data, head.pos, head.limit - head.pos);
+    for (Segment s = head.next; s != head; s = s.next) {
+      result.write(s.data, s.pos, s.limit - s.pos);
+    }
+
+    return result;
+  }
+}
diff --git a/okio/src/main/java/okio/Okio.java b/okio/src/main/java/okio/Okio.java
new file mode 100644
index 0000000000..3a9b4f9f83
--- /dev/null
+++ b/okio/src/main/java/okio/Okio.java
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+
+import static okio.Util.checkOffsetAndCount;
+
+public final class Okio {
+  private Okio() {
+  }
+
+  public static BufferedSource buffer(Source source) {
+    return new RealBufferedSource(source);
+  }
+
+  public static BufferedSink buffer(Sink sink) {
+    return new RealBufferedSink(sink);
+  }
+
+  /** Copies bytes from {@code source} to {@code sink}. */
+  public static void copy(OkBuffer source, long offset, long byteCount, OutputStream sink)
+      throws IOException {
+    checkOffsetAndCount(source.size, offset, byteCount);
+
+    // Skip segments that we aren't copying from.
+    Segment s = source.head;
+    while (offset >= (s.limit - s.pos)) {
+      offset -= (s.limit - s.pos);
+      s = s.next;
+    }
+
+    // Copy from one segment at a time.
+    while (byteCount > 0) {
+      int pos = (int) (s.pos + offset);
+      int toWrite = (int) Math.min(s.limit - pos, byteCount);
+      sink.write(s.data, pos, toWrite);
+      byteCount -= toWrite;
+      offset = 0;
+    }
+  }
+
+  /** Returns a sink that writes to {@code out}. */
+  public static Sink sink(final OutputStream out) {
+    return new Sink() {
+      private Deadline deadline = Deadline.NONE;
+
+      @Override public void write(OkBuffer source, long byteCount)
+          throws IOException {
+        checkOffsetAndCount(source.size, 0, byteCount);
+        while (byteCount > 0) {
+          deadline.throwIfReached();
+          Segment head = source.head;
+          int toCopy = (int) Math.min(byteCount, head.limit - head.pos);
+          out.write(head.data, head.pos, toCopy);
+
+          head.pos += toCopy;
+          byteCount -= toCopy;
+          source.size -= toCopy;
+
+          if (head.pos == head.limit) {
+            source.head = head.pop();
+            SegmentPool.INSTANCE.recycle(head);
+          }
+        }
+      }
+
+      @Override public void flush() throws IOException {
+        out.flush();
+      }
+
+      @Override public void close() throws IOException {
+        out.close();
+      }
+
+      @Override public Sink deadline(Deadline deadline) {
+        if (deadline == null) throw new IllegalArgumentException("deadline == null");
+        this.deadline = deadline;
+        return this;
+      }
+
+      @Override public String toString() {
+        return "sink(" + out + ")";
+      }
+    };
+  }
+
+  /** Returns a source that reads from {@code in}. */
+  public static Source source(final InputStream in) {
+    return new Source() {
+      private Deadline deadline = Deadline.NONE;
+
+      @Override public long read(OkBuffer sink, long byteCount) throws IOException {
+        if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+        deadline.throwIfReached();
+        Segment tail = sink.writableSegment(1);
+        int maxToCopy = (int) Math.min(byteCount, Segment.SIZE - tail.limit);
+        int bytesRead = in.read(tail.data, tail.limit, maxToCopy);
+        if (bytesRead == -1) return -1;
+        tail.limit += bytesRead;
+        sink.size += bytesRead;
+        return bytesRead;
+      }
+
+      @Override public void close() throws IOException {
+        in.close();
+      }
+
+      @Override public Source deadline(Deadline deadline) {
+        if (deadline == null) throw new IllegalArgumentException("deadline == null");
+        this.deadline = deadline;
+        return this;
+      }
+
+      @Override public String toString() {
+        return "source(" + in + ")";
+      }
+    };
+  }
+}
diff --git a/okio/src/main/java/okio/RealBufferedSink.java b/okio/src/main/java/okio/RealBufferedSink.java
new file mode 100644
index 0000000000..74454c60ce
--- /dev/null
+++ b/okio/src/main/java/okio/RealBufferedSink.java
@@ -0,0 +1,191 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+final class RealBufferedSink implements BufferedSink {
+  public final OkBuffer buffer;
+  public final Sink sink;
+  private boolean closed;
+
+  public RealBufferedSink(Sink sink, OkBuffer buffer) {
+    if (sink == null) throw new IllegalArgumentException("sink == null");
+    this.buffer = buffer;
+    this.sink = sink;
+  }
+
+  public RealBufferedSink(Sink sink) {
+    this(sink, new OkBuffer());
+  }
+
+  @Override public OkBuffer buffer() {
+    return buffer;
+  }
+
+  @Override public void write(OkBuffer source, long byteCount)
+      throws IOException {
+    if (closed) throw new IllegalStateException("closed");
+    buffer.write(source, byteCount);
+    emitCompleteSegments();
+  }
+
+  @Override public BufferedSink write(ByteString byteString) throws IOException {
+    if (closed) throw new IllegalStateException("closed");
+    buffer.write(byteString);
+    return emitCompleteSegments();
+  }
+
+  @Override public BufferedSink writeUtf8(String string) throws IOException {
+    if (closed) throw new IllegalStateException("closed");
+    buffer.writeUtf8(string);
+    return emitCompleteSegments();
+  }
+
+  @Override public BufferedSink write(byte[] source) throws IOException {
+    if (closed) throw new IllegalStateException("closed");
+    buffer.write(source);
+    return emitCompleteSegments();
+  }
+
+  @Override public BufferedSink write(byte[] source, int offset, int byteCount) throws IOException {
+    if (closed) throw new IllegalStateException("closed");
+    buffer.write(source, offset, byteCount);
+    return emitCompleteSegments();
+  }
+
+  @Override public BufferedSink writeByte(int b) throws IOException {
+    if (closed) throw new IllegalStateException("closed");
+    buffer.writeByte(b);
+    return emitCompleteSegments();
+  }
+
+  @Override public BufferedSink writeShort(int s) throws IOException {
+    if (closed) throw new IllegalStateException("closed");
+    buffer.writeShort(s);
+    return emitCompleteSegments();
+  }
+
+  @Override public BufferedSink writeShortLe(int s) throws IOException {
+    if (closed) throw new IllegalStateException("closed");
+    buffer.writeShortLe(s);
+    return emitCompleteSegments();
+  }
+
+  @Override public BufferedSink writeInt(int i) throws IOException {
+    if (closed) throw new IllegalStateException("closed");
+    buffer.writeInt(i);
+    return emitCompleteSegments();
+  }
+
+  @Override public BufferedSink writeIntLe(int i) throws IOException {
+    if (closed) throw new IllegalStateException("closed");
+    buffer.writeIntLe(i);
+    return emitCompleteSegments();
+  }
+
+  @Override public BufferedSink writeLong(long v) throws IOException {
+    if (closed) throw new IllegalStateException("closed");
+    buffer.writeLong(v);
+    return emitCompleteSegments();
+  }
+
+  @Override public BufferedSink writeLongLe(long v) throws IOException {
+    if (closed) throw new IllegalStateException("closed");
+    buffer.writeLongLe(v);
+    return emitCompleteSegments();
+  }
+
+  @Override public BufferedSink emitCompleteSegments() throws IOException {
+    if (closed) throw new IllegalStateException("closed");
+    long byteCount = buffer.completeSegmentByteCount();
+    if (byteCount > 0) sink.write(buffer, byteCount);
+    return this;
+  }
+
+  @Override public OutputStream outputStream() {
+    return new OutputStream() {
+      @Override public void write(int b) throws IOException {
+        if (closed) throw new IOException("closed");
+        buffer.writeByte((byte) b);
+        emitCompleteSegments();
+      }
+
+      @Override public void write(byte[] data, int offset, int byteCount) throws IOException {
+        if (closed) throw new IOException("closed");
+        buffer.write(data, offset, byteCount);
+        emitCompleteSegments();
+      }
+
+      @Override public void flush() throws IOException {
+        // For backwards compatibility, a flush() on a closed stream is a no-op.
+        if (!closed) {
+          RealBufferedSink.this.flush();
+        }
+      }
+
+      @Override public void close() throws IOException {
+        RealBufferedSink.this.close();
+      }
+
+      @Override public String toString() {
+        return RealBufferedSink.this + ".outputStream()";
+      }
+    };
+  }
+
+  @Override public void flush() throws IOException {
+    if (closed) throw new IllegalStateException("closed");
+    if (buffer.size > 0) {
+      sink.write(buffer, buffer.size);
+    }
+    sink.flush();
+  }
+
+  @Override public void close() throws IOException {
+    if (closed) return;
+
+    // Emit buffered data to the underlying sink. If this fails, we still need
+    // to close the sink; otherwise we risk leaking resources.
+    Throwable thrown = null;
+    try {
+      if (buffer.size > 0) {
+        sink.write(buffer, buffer.size);
+      }
+    } catch (Throwable e) {
+      thrown = e;
+    }
+
+    try {
+      sink.close();
+    } catch (Throwable e) {
+      if (thrown == null) thrown = e;
+    }
+    closed = true;
+
+    if (thrown != null) Util.sneakyRethrow(thrown);
+  }
+
+  @Override public Sink deadline(Deadline deadline) {
+    sink.deadline(deadline);
+    return this;
+  }
+
+  @Override public String toString() {
+    return "buffer(" + sink + ")";
+  }
+}
diff --git a/okio/src/main/java/okio/RealBufferedSource.java b/okio/src/main/java/okio/RealBufferedSource.java
new file mode 100644
index 0000000000..0189d0f7f7
--- /dev/null
+++ b/okio/src/main/java/okio/RealBufferedSource.java
@@ -0,0 +1,205 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InputStream;
+
+import static okio.Util.checkOffsetAndCount;
+
+final class RealBufferedSource implements BufferedSource {
+  public final OkBuffer buffer;
+  public final Source source;
+  private boolean closed;
+
+  public RealBufferedSource(Source source, OkBuffer buffer) {
+    if (source == null) throw new IllegalArgumentException("source == null");
+    this.buffer = buffer;
+    this.source = source;
+  }
+
+  public RealBufferedSource(Source source) {
+    this(source, new OkBuffer());
+  }
+
+  @Override public OkBuffer buffer() {
+    return buffer;
+  }
+
+  @Override public long read(OkBuffer sink, long byteCount) throws IOException {
+    if (byteCount < 0) throw new IllegalArgumentException("byteCount < 0: " + byteCount);
+    if (closed) throw new IllegalStateException("closed");
+
+    if (buffer.size == 0) {
+      long read = source.read(buffer, Segment.SIZE);
+      if (read == -1) return -1;
+    }
+
+    long toRead = Math.min(byteCount, buffer.size);
+    return buffer.read(sink, toRead);
+  }
+
+  @Override public boolean exhausted() throws IOException {
+    if (closed) throw new IllegalStateException("closed");
+    return buffer.exhausted() && source.read(buffer, Segment.SIZE) == -1;
+  }
+
+  @Override public void require(long byteCount) throws IOException {
+    if (closed) throw new IllegalStateException("closed");
+    while (buffer.size < byteCount) {
+      if (source.read(buffer, Segment.SIZE) == -1) throw new EOFException();
+    }
+  }
+
+  @Override public byte readByte() throws IOException {
+    require(1);
+    return buffer.readByte();
+  }
+
+  @Override public ByteString readByteString(long byteCount) throws IOException {
+    require(byteCount);
+    return buffer.readByteString(byteCount);
+  }
+
+  @Override public String readUtf8(long byteCount) throws IOException {
+    require(byteCount);
+    return buffer.readUtf8(byteCount);
+  }
+
+  @Override public String readUtf8Line() throws IOException {
+    long newline = indexOf((byte) '\n');
+
+    if (newline == -1) {
+      return buffer.size != 0 ? readUtf8(buffer.size) : null;
+    }
+
+    return buffer.readUtf8Line(newline);
+  }
+
+  @Override public String readUtf8LineStrict() throws IOException {
+    long newline = indexOf((byte) '\n');
+    if (newline == -1L) throw new EOFException();
+    return buffer.readUtf8Line(newline);
+  }
+
+  @Override public short readShort() throws IOException {
+    require(2);
+    return buffer.readShort();
+  }
+
+  @Override public short readShortLe() throws IOException {
+    require(2);
+    return buffer.readShortLe();
+  }
+
+  @Override public int readInt() throws IOException {
+    require(4);
+    return buffer.readInt();
+  }
+
+  @Override public int readIntLe() throws IOException {
+    require(4);
+    return buffer.readIntLe();
+  }
+
+  @Override public long readLong() throws IOException {
+    require(8);
+    return buffer.readLong();
+  }
+
+  @Override public long readLongLe() throws IOException {
+    require(8);
+    return buffer.readLongLe();
+  }
+
+  @Override public void skip(long byteCount) throws IOException {
+    if (closed) throw new IllegalStateException("closed");
+    while (byteCount > 0) {
+      if (buffer.size == 0 && source.read(buffer, Segment.SIZE) == -1) {
+        throw new EOFException();
+      }
+      long toSkip = Math.min(byteCount, buffer.size());
+      buffer.skip(toSkip);
+      byteCount -= toSkip;
+    }
+  }
+
+  @Override public long indexOf(byte b) throws IOException {
+    if (closed) throw new IllegalStateException("closed");
+    long start = 0;
+    long index;
+    while ((index = buffer.indexOf(b, start)) == -1) {
+      start = buffer.size;
+      if (source.read(buffer, Segment.SIZE) == -1) return -1L;
+    }
+    return index;
+  }
+
+  @Override public InputStream inputStream() {
+    return new InputStream() {
+      @Override public int read() throws IOException {
+        if (closed) throw new IOException("closed");
+        if (buffer.size == 0) {
+          long count = source.read(buffer, Segment.SIZE);
+          if (count == -1) return -1;
+        }
+        return buffer.readByte() & 0xff;
+      }
+
+      @Override public int read(byte[] data, int offset, int byteCount) throws IOException {
+        if (closed) throw new IOException("closed");
+        checkOffsetAndCount(data.length, offset, byteCount);
+
+        if (buffer.size == 0) {
+          long count = source.read(buffer, Segment.SIZE);
+          if (count == -1) return -1;
+        }
+
+        return buffer.read(data, offset, byteCount);
+      }
+
+      @Override public int available() throws IOException {
+        if (closed) throw new IOException("closed");
+        return (int) Math.min(buffer.size, Integer.MAX_VALUE);
+      }
+
+      @Override public void close() throws IOException {
+        RealBufferedSource.this.close();
+      }
+
+      @Override public String toString() {
+        return RealBufferedSource.this + ".inputStream()";
+      }
+    };
+  }
+
+  @Override public Source deadline(Deadline deadline) {
+    source.deadline(deadline);
+    return this;
+  }
+
+  @Override public void close() throws IOException {
+    if (closed) return;
+    closed = true;
+    source.close();
+    buffer.clear();
+  }
+
+  @Override public String toString() {
+    return "buffer(" + source + ")";
+  }
+}
diff --git a/okio/src/main/java/okio/Segment.java b/okio/src/main/java/okio/Segment.java
new file mode 100644
index 0000000000..77dbee186d
--- /dev/null
+++ b/okio/src/main/java/okio/Segment.java
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+/**
+ * A segment of an OkBuffer.
+ *
+ * <p>Each segment in an OkBuffer is a circularly-linked list node referencing
+ * the following and preceding segments in the buffer.
+ *
+ * <p>Each segment in the pool is a singly-linked list node referencing the rest
+ * of segments in the pool.
+ */
+final class Segment {
+  /** The size of all segments in bytes. */
+  // TODO: Using fixed-size segments makes pooling easier. But it harms memory
+  //       efficiency and encourages copying. Try variable sized segments?
+  // TODO: Is 2 KiB a good default segment size?
+  static final int SIZE = 2048;
+
+  final byte[] data = new byte[SIZE];
+
+  /** The next byte of application data byte to read in this segment. */
+  int pos;
+
+  /** The first byte of available data ready to be written to. */
+  int limit;
+
+  /** Next segment in a linked or circularly-linked list. */
+  Segment next;
+
+  /** Previous segment in a circularly-linked list. */
+  Segment prev;
+
+  /**
+   * Removes this segment of a circularly-linked list and returns its successor.
+   * Returns null if the list is now empty.
+   */
+  public Segment pop() {
+    Segment result = next != this ? next : null;
+    prev.next = next;
+    next.prev = prev;
+    next = null;
+    prev = null;
+    return result;
+  }
+
+  /**
+   * Appends {@code segment} after this segment in the circularly-linked list.
+   * Returns the pushed segment.
+   */
+  public Segment push(Segment segment) {
+    segment.prev = this;
+    segment.next = next;
+    next.prev = segment;
+    next = segment;
+    return segment;
+  }
+
+  /**
+   * Splits this head of a circularly-linked list into two segments. The first
+   * segment contains the data in {@code [pos..pos+byteCount)}. The second
+   * segment contains the data in {@code [pos+byteCount..limit)}. This can be
+   * useful when moving partial segments from one OkBuffer to another.
+   *
+   * <p>Returns the new head of the circularly-linked list.
+   */
+  public Segment split(int byteCount) {
+    int aSize = byteCount;
+    int bSize = (limit - pos) - byteCount;
+    if (aSize <= 0 || bSize <= 0) throw new IllegalArgumentException();
+
+    // Which side of the split is larger? We want to copy as few bytes as possible.
+    if (aSize < bSize) {
+      // Create a segment of size 'aSize' before this segment.
+      Segment before = SegmentPool.INSTANCE.take();
+      System.arraycopy(data, pos, before.data, before.pos, aSize);
+      pos += aSize;
+      before.limit += aSize;
+      prev.push(before);
+      return before;
+    } else {
+      // Create a new segment of size 'bSize' after this segment.
+      Segment after = SegmentPool.INSTANCE.take();
+      System.arraycopy(data, pos + aSize, after.data, after.pos, bSize);
+      limit -= bSize;
+      after.limit += bSize;
+      push(after);
+      return this;
+    }
+  }
+
+  /**
+   * Call this when the tail and its predecessor may both be less than half
+   * full. This will copy data so that segments can be recycled.
+   */
+  public void compact() {
+    if (prev == this) throw new IllegalStateException();
+    if ((prev.limit - prev.pos) + (limit - pos) > SIZE) return; // Cannot compact.
+    writeTo(prev, limit - pos);
+    pop();
+    SegmentPool.INSTANCE.recycle(this);
+  }
+
+  /** Moves {@code byteCount} bytes from {@code sink} to this segment. */
+  // TODO: if sink has fewer bytes than this, it may be cheaper to reverse the
+  //       direction of the copy and swap the segments!
+  public void writeTo(Segment sink, int byteCount) {
+    if (byteCount + (sink.limit - sink.pos) > SIZE) throw new IllegalArgumentException();
+
+    if (sink.limit + byteCount > SIZE) {
+      // We can't fit byteCount bytes at the sink's current position. Compact sink first.
+      System.arraycopy(sink.data, sink.pos, sink.data, 0, sink.limit - sink.pos);
+      sink.limit -= sink.pos;
+      sink.pos = 0;
+    }
+
+    System.arraycopy(data, pos, sink.data, sink.limit, byteCount);
+    sink.limit += byteCount;
+    pos += byteCount;
+  }
+}
diff --git a/okio/src/main/java/okio/SegmentPool.java b/okio/src/main/java/okio/SegmentPool.java
new file mode 100644
index 0000000000..c132f244b6
--- /dev/null
+++ b/okio/src/main/java/okio/SegmentPool.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+/**
+ * A collection of unused segments, necessary to avoid GC churn and zero-fill.
+ * This pool is a thread-safe static singleton.
+ */
+final class SegmentPool {
+  static final SegmentPool INSTANCE = new SegmentPool();
+
+  /** The maximum number of bytes to pool. */
+  // TODO: Is 64 KiB a good maximum size? Do we ever have that many idle segments?
+  static final long MAX_SIZE = 64 * 1024; // 64 KiB.
+
+  /** Singly-linked list of segments. */
+  private Segment next;
+
+  /** Total bytes in this pool. */
+  long byteCount;
+
+  private SegmentPool() {
+  }
+
+  Segment take() {
+    synchronized (this) {
+      if (next != null) {
+        Segment result = next;
+        next = result.next;
+        result.next = null;
+        byteCount -= Segment.SIZE;
+        return result;
+      }
+    }
+    return new Segment(); // Pool is empty. Don't zero-fill while holding a lock.
+  }
+
+  void recycle(Segment segment) {
+    if (segment.next != null || segment.prev != null) throw new IllegalArgumentException();
+    synchronized (this) {
+      if (byteCount + Segment.SIZE > MAX_SIZE) return; // Pool is full.
+      byteCount += Segment.SIZE;
+      segment.next = next;
+      segment.pos = segment.limit = 0;
+      next = segment;
+    }
+  }
+}
diff --git a/okio/src/main/java/okio/Sink.java b/okio/src/main/java/okio/Sink.java
new file mode 100644
index 0000000000..402aa0fc3f
--- /dev/null
+++ b/okio/src/main/java/okio/Sink.java
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.Closeable;
+import java.io.IOException;
+
+/**
+ * Receives a stream of bytes. Use this interface to write data wherever it's
+ * needed: to the network, storage, or a buffer in memory. Sinks may be layered
+ * to transform received data, such as to compress, encrypt, throttle, or add
+ * protocol framing.
+ *
+ * <p>Most application code shouldn't operate on a sink directly, but rather
+ * {@link BufferedSink} which is both more efficient and more convenient. Use
+ * {@link Okio#buffer(Sink)} to wrap any sink with a buffer.
+ *
+ * <p>Sinks are easy to test: just use an {@link OkBuffer} in your tests, and
+ * read from it to confirm it received the data that was expected.
+ *
+ * <h3>Comparison with OutputStream</h3>
+ * This interface is functionally equivalent to {@link java.io.OutputStream}.
+ *
+ * <p>{@code OutputStream} requires multiple layers when emitted data is
+ * heterogeneous: a {@code DataOutputStream} for primitive values, a {@code
+ * BufferedOutputStream} for buffering, and {@code OutputStreamWriter} for
+ * charset encoding. This class uses {@code BufferedSink} for all of the above.
+ *
+ * <p>Sink is also easier to layer: there is no {@link
+ * java.io.OutputStream#write(int) single-byte write} method that is awkward to
+ * implement efficiently.
+ *
+ * <h3>Interop with OutputStream</h3>
+ * Use {@link Okio#sink} to adapt an {@code OutputStream} to a sink. Use {@link
+ * BufferedSink#outputStream} to adapt a sink to an {@code OutputStream}.
+ */
+public interface Sink extends Closeable {
+  /** Removes {@code byteCount} bytes from {@code source} and appends them to this. */
+  void write(OkBuffer source, long byteCount) throws IOException;
+
+  /** Pushes all buffered bytes to their final destination. */
+  void flush() throws IOException;
+
+  /**
+   * Sets the deadline for all operations on this sink.
+   * @return this sink.
+   */
+  Sink deadline(Deadline deadline);
+
+  /**
+   * Pushes all buffered bytes to their final destination and releases the
+   * resources held by this sink. It is an error to write a closed sink. It is
+   * safe to close a sink more than once.
+   */
+  @Override void close() throws IOException;
+}
diff --git a/okio/src/main/java/okio/Source.java b/okio/src/main/java/okio/Source.java
new file mode 100644
index 0000000000..d402beed39
--- /dev/null
+++ b/okio/src/main/java/okio/Source.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.Closeable;
+import java.io.IOException;
+
+/**
+ * Supplies a stream of bytes. Use this interface to read data from wherever
+ * it's located: from the network, storage, or a buffer in memory. Sources may
+ * be layered to transform supplied data, such as to decompress, decrypt, or
+ * remove protocol framing.
+ *
+ * <p>Most applications shouldn't operate on a source directly, but rather
+ * {@link BufferedSource} which is both more efficient and more convenient. Use
+ * {@link Okio#buffer(Source)} to wrap any source with a buffer.
+ *
+ * <p>Sources are easy to test: just use an {@link OkBuffer} in your tests, and
+ * fill it with the data your application is to read.
+ *
+ * <h3>Comparison with InputStream</h3>
+ * This interface is functionally equivalent to {@link java.io.InputStream}.
+ *
+ * <p>{@code InputStream} requires multiple layers when consumed data is
+ * heterogeneous: a {@code DataOutputStream} for primitive values, a {@code
+ * BufferedInputStream} for buffering, and {@code InputStreamReader} for
+ * strings. This class uses {@code BufferedSource} for all of the above.
+ *
+ * <p>Source avoids the impossible-to-implement {@link
+ * java.io.InputStream#available available()} method. Instead callers specify
+ * how many bytes they {@link BufferedSource#require require}.
+ *
+ * <p>Source omits the unsafe-to-compose {@link java.io.InputStream#mark mark
+ * and reset} state that's tracked by {@code InputStream}; callers instead just
+ * buffer what they need.
+ *
+ * <p>When implementing a source, you need not worry about the {@link
+ * java.io.InputStream#read single-byte read} method that is awkward to
+ * implement efficiently and that returns one of 257 possible values.
+ *
+ * <p>And source has a stronger {@code skip} method: {@link BufferedSource#skip}
+ * won't return prematurely.
+ *
+ * <h3>Interop with InputStream</h3>
+ * Use {@link Okio#source} to adapt an {@code InputStream} to a source. Use
+ * {@link BufferedSource#inputStream} to adapt a source to an {@code
+ * InputStream}.
+ */
+public interface Source extends Closeable {
+  /**
+   * Removes at least 1, and up to {@code byteCount} bytes from this and appends
+   * them to {@code sink}. Returns the number of bytes read, or -1 if this
+   * source is exhausted.
+   */
+  long read(OkBuffer sink, long byteCount) throws IOException;
+
+  /**
+   * Sets the deadline for all operations on this source.
+   * @return this source.
+   */
+  Source deadline(Deadline deadline);
+
+  /**
+   * Closes this source and releases the resources held by this source. It is an
+   * error to read a closed source. It is safe to close a source more than once.
+   */
+  @Override void close() throws IOException;
+}
diff --git a/okio/src/main/java/okio/Util.java b/okio/src/main/java/okio/Util.java
new file mode 100644
index 0000000000..4759488657
--- /dev/null
+++ b/okio/src/main/java/okio/Util.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.nio.charset.Charset;
+
+final class Util {
+  /** A cheap and type-safe constant for the UTF-8 Charset. */
+  public static final Charset UTF_8 = Charset.forName("UTF-8");
+
+  private Util() {
+  }
+
+  public static void checkOffsetAndCount(long arrayLength, long offset, long count) {
+    if ((offset | count) < 0 || offset > arrayLength || arrayLength - offset < count) {
+      throw new ArrayIndexOutOfBoundsException();
+    }
+  }
+
+  public static short reverseBytesShort(short s) {
+    int i = s & 0xffff;
+    int reversed = (i & 0xff00) >>> 8
+        |          (i & 0x00ff)  << 8;
+    return (short) reversed;
+  }
+
+  public static int reverseBytesInt(int i) {
+    return (i & 0xff000000) >>> 24
+        |  (i & 0x00ff0000) >>>  8
+        |  (i & 0x0000ff00)  <<  8
+        |  (i & 0x000000ff)  << 24;
+  }
+
+  public static long reverseBytesLong(long v) {
+    return (v & 0xff00000000000000L) >>> 56
+        |  (v & 0x00ff000000000000L) >>> 40
+        |  (v & 0x0000ff0000000000L) >>> 24
+        |  (v & 0x000000ff00000000L) >>>  8
+        |  (v & 0x00000000ff000000L)  <<  8
+        |  (v & 0x0000000000ff0000L)  << 24
+        |  (v & 0x000000000000ff00L)  << 40
+        |  (v & 0x00000000000000ffL)  << 56;
+  }
+
+  /**
+   * Throws {@code t}, even if the declared throws clause doesn't permit it.
+   * This is a terrible  but terribly convenient  hack that makes it easy to
+   * catch and rethrow exceptions after cleanup. See Java Puzzlers #43.
+   */
+  public static void sneakyRethrow(Throwable t) {
+    Util.<Error>sneakyThrow2(t);
+  }
+
+  @SuppressWarnings("unchecked")
+  private static <T extends Throwable> void sneakyThrow2(Throwable t) throws T {
+    throw (T) t;
+  }
+}
diff --git a/okio/src/test/java/okio/ByteStringTest.java b/okio/src/test/java/okio/ByteStringTest.java
new file mode 100644
index 0000000000..16b8e2d518
--- /dev/null
+++ b/okio/src/test/java/okio/ByteStringTest.java
@@ -0,0 +1,182 @@
+/*
+ * Copyright 2014 Square Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.InputStream;
+import java.util.Arrays;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertSame;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public class ByteStringTest {
+
+  @Test public void getByte() throws Exception {
+    ByteString byteString = ByteString.decodeHex("ab12");
+    assertEquals(-85, byteString.getByte(0));
+    assertEquals(18, byteString.getByte(1));
+  }
+
+  @Test public void getByteOutOfBounds() throws Exception {
+    ByteString byteString = ByteString.decodeHex("ab12");
+    try {
+      byteString.getByte(2);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void equals() throws Exception {
+    ByteString byteString = ByteString.decodeHex("000102");
+    assertTrue(byteString.equals(byteString));
+    assertTrue(byteString.equals(ByteString.decodeHex("000102")));
+    assertTrue(ByteString.of().equals(ByteString.EMPTY));
+    assertTrue(ByteString.EMPTY.equals(ByteString.of()));
+    assertFalse(byteString.equals(new Object()));
+    assertFalse(byteString.equals(ByteString.decodeHex("000201")));
+  }
+
+  private final String bronzeHorseman = "   ";
+
+  @Test public void utf8() throws Exception {
+    ByteString byteString = ByteString.encodeUtf8(bronzeHorseman);
+    assertByteArraysEquals(byteString.toByteArray(), bronzeHorseman.getBytes(Util.UTF_8));
+    assertTrue(byteString.equals(ByteString.of(bronzeHorseman.getBytes(Util.UTF_8))));
+    assertEquals(byteString.utf8(), bronzeHorseman);
+  }
+
+  @Test public void testHashCode() throws Exception {
+    ByteString byteString = ByteString.decodeHex("0102");
+    assertEquals(byteString.hashCode(), byteString.hashCode());
+    assertEquals(byteString.hashCode(), ByteString.decodeHex("0102").hashCode());
+  }
+
+  @Test public void read() throws Exception {
+    InputStream in = new ByteArrayInputStream("abc".getBytes(Util.UTF_8));
+    assertEquals(ByteString.decodeHex("6162"), ByteString.read(in, 2));
+    assertEquals(ByteString.decodeHex("63"), ByteString.read(in, 1));
+    assertEquals(ByteString.of(), ByteString.read(in, 0));
+  }
+
+  @Test public void readLowerCase() throws Exception {
+    InputStream in = new ByteArrayInputStream("ABC".getBytes(Util.UTF_8));
+    assertEquals(ByteString.encodeUtf8("ab"), ByteString.read(in, 2).toAsciiLowercase());
+    assertEquals(ByteString.encodeUtf8("c"), ByteString.read(in, 1).toAsciiLowercase());
+    assertEquals(ByteString.EMPTY, ByteString.read(in, 0).toAsciiLowercase());
+  }
+
+  @Test public void toAsciiLowerCaseNoUppercase() throws Exception {
+    ByteString s = ByteString.encodeUtf8("a1_+");
+    assertSame(s, s.toAsciiLowercase());
+  }
+
+  @Test public void toAsciiAllUppercase() throws Exception {
+    assertEquals(ByteString.encodeUtf8("ab"), ByteString.encodeUtf8("AB").toAsciiLowercase());
+  }
+
+  @Test public void toAsciiStartsLowercaseEndsUppercase() throws Exception {
+    assertEquals(ByteString.encodeUtf8("abcd"), ByteString.encodeUtf8("abCD").toAsciiLowercase());
+  }
+
+  @Test public void write() throws Exception {
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    ByteString.decodeHex("616263").write(out);
+    assertByteArraysEquals(new byte[] { 0x61, 0x62, 0x63 }, out.toByteArray());
+  }
+
+  @Test public void encodeBase64() {
+    assertEquals("", ByteString.encodeUtf8("").base64());
+    assertEquals("AA==", ByteString.encodeUtf8("\u0000").base64());
+    assertEquals("AAA=", ByteString.encodeUtf8("\u0000\u0000").base64());
+    assertEquals("AAAA", ByteString.encodeUtf8("\u0000\u0000\u0000").base64());
+    assertEquals("V2UncmUgZ29ubmEgbWFrZSBhIGZvcnR1bmUgd2l0aCB0aGlzIHBsYWNlLg==",
+        ByteString.encodeUtf8("We're gonna make a fortune with this place.").base64());
+  }
+
+  @Test public void ignoreUnnecessaryPadding() {
+    assertEquals("", ByteString.decodeBase64("====").utf8());
+    assertEquals("\u0000\u0000\u0000", ByteString.decodeBase64("AAAA====").utf8());
+  }
+
+  @Test public void decodeBase64() {
+    assertEquals("", ByteString.decodeBase64("").utf8());
+    assertEquals(null, ByteString.decodeBase64("/===")); // Can't do anything with 6 bits!
+    assertEquals(ByteString.decodeHex("ff"), ByteString.decodeBase64("//=="));
+    assertEquals(ByteString.decodeHex("ffff"), ByteString.decodeBase64("///="));
+    assertEquals(ByteString.decodeHex("ffffff"), ByteString.decodeBase64("////"));
+    assertEquals(ByteString.decodeHex("ffffffffffff"), ByteString.decodeBase64("////////"));
+    assertEquals("What's to be scared about? It's just a little hiccup in the power...",
+        ByteString.decodeBase64("V2hhdCdzIHRvIGJlIHNjYXJlZCBhYm91dD8gSXQncyBqdXN0IGEgbGl0dGxlIGhpY2"
+            + "N1cCBpbiB0aGUgcG93ZXIuLi4=").utf8());
+  }
+
+  @Test public void decodeBase64WithWhitespace() {
+    assertEquals("\u0000\u0000\u0000", ByteString.decodeBase64(" AA AA ").utf8());
+    assertEquals("\u0000\u0000\u0000", ByteString.decodeBase64(" AA A\r\nA ").utf8());
+    assertEquals("\u0000\u0000\u0000", ByteString.decodeBase64("AA AA").utf8());
+    assertEquals("\u0000\u0000\u0000", ByteString.decodeBase64(" AA AA ").utf8());
+    assertEquals("\u0000\u0000\u0000", ByteString.decodeBase64(" AA A\r\nA ").utf8());
+    assertEquals("\u0000\u0000\u0000", ByteString.decodeBase64("A    AAA").utf8());
+    assertEquals("", ByteString.decodeBase64("    ").utf8());
+  }
+
+  @Test public void encodeHex() throws Exception {
+    assertEquals("000102", ByteString.of((byte) 0x0, (byte) 0x1, (byte) 0x2).hex());
+  }
+
+  @Test public void decodeHex() throws Exception {
+    assertEquals(ByteString.of((byte) 0x0, (byte) 0x1, (byte) 0x2), ByteString.decodeHex("000102"));
+  }
+
+  @Test public void decodeHexOddNumberOfChars() throws Exception {
+    try {
+      ByteString.decodeHex("aaa");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void decodeHexInvalidChar() throws Exception {
+    try {
+      ByteString.decodeHex("a\u0000");
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  @Test public void toStringOnEmptyByteString() {
+    assertEquals("ByteString[size=0]", ByteString.of().toString());
+  }
+
+  @Test public void toStringOnSmallByteStringIncludesContents() {
+    assertEquals("ByteString[size=16 data=a1b2c3d4e5f61a2b3c4d5e6f10203040]",
+        ByteString.decodeHex("a1b2c3d4e5f61a2b3c4d5e6f10203040").toString());
+  }
+
+  @Test public void toStringOnLargeByteStringIncludesMd5() {
+    assertEquals("ByteString[size=17 md5=2c9728a2138b2f25e9f89f99bdccf8db]",
+        ByteString.encodeUtf8("12345678901234567").toString());
+  }
+
+  private static void assertByteArraysEquals(byte[] a, byte[] b) {
+    assertEquals(Arrays.toString(a), Arrays.toString(b));
+  }
+}
diff --git a/okio/src/test/java/okio/DeflaterSinkTest.java b/okio/src/test/java/okio/DeflaterSinkTest.java
new file mode 100644
index 0000000000..0f6b8c2861
--- /dev/null
+++ b/okio/src/test/java/okio/DeflaterSinkTest.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Arrays;
+import java.util.Random;
+import java.util.zip.Deflater;
+import java.util.zip.Inflater;
+import java.util.zip.InflaterInputStream;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class DeflaterSinkTest {
+  @Test public void deflateWithClose() throws Exception {
+    OkBuffer data = new OkBuffer();
+    String original = "They're moving in herds. They do move in herds.";
+    data.writeUtf8(original);
+    OkBuffer sink = new OkBuffer();
+    DeflaterSink deflaterSink = new DeflaterSink(sink, new Deflater());
+    deflaterSink.write(data, data.size());
+    deflaterSink.close();
+    OkBuffer inflated = inflate(sink);
+    assertEquals(original, inflated.readUtf8(inflated.size()));
+  }
+
+  @Test public void deflateWithSyncFlush() throws Exception {
+    String original = "Yes, yes, yes. That's why we're taking extreme precautions.";
+    OkBuffer data = new OkBuffer();
+    data.writeUtf8(original);
+    OkBuffer sink = new OkBuffer();
+    DeflaterSink deflaterSink = new DeflaterSink(sink, new Deflater());
+    deflaterSink.write(data, data.size());
+    deflaterSink.flush();
+    OkBuffer inflated = inflate(sink);
+    assertEquals(original, inflated.readUtf8(inflated.size()));
+  }
+
+  @Test public void deflateWellCompressed() throws IOException {
+    String original = repeat('a', 1024 * 1024);
+    OkBuffer data = new OkBuffer();
+    data.writeUtf8(original);
+    OkBuffer sink = new OkBuffer();
+    DeflaterSink deflaterSink = new DeflaterSink(sink, new Deflater());
+    deflaterSink.write(data, data.size());
+    deflaterSink.close();
+    OkBuffer inflated = inflate(sink);
+    assertEquals(original, inflated.readUtf8(inflated.size()));
+  }
+
+  @Test public void deflatePoorlyCompressed() throws IOException {
+    ByteString original = randomBytes(1024 * 1024);
+    OkBuffer data = new OkBuffer();
+    data.write(original);
+    OkBuffer sink = new OkBuffer();
+    DeflaterSink deflaterSink = new DeflaterSink(sink, new Deflater());
+    deflaterSink.write(data, data.size());
+    deflaterSink.close();
+    OkBuffer inflated = inflate(sink);
+    assertEquals(original, inflated.readByteString(inflated.size()));
+  }
+
+  @Test public void multipleSegmentsWithoutCompression() throws IOException {
+    OkBuffer buffer = new OkBuffer();
+    Deflater deflater = new Deflater();
+    deflater.setLevel(Deflater.NO_COMPRESSION);
+    DeflaterSink deflaterSink = new DeflaterSink(buffer, deflater);
+    int byteCount = Segment.SIZE * 4;
+    deflaterSink.write(new OkBuffer().writeUtf8(repeat('a', byteCount)), byteCount);
+    deflaterSink.close();
+    assertEquals(repeat('a', byteCount), inflate(buffer).readUtf8(byteCount));
+  }
+
+  /**
+   * This test deflates a single segment of without compression because that's
+   * the easiest way to force close() to emit a large amount of data to the
+   * underlying sink.
+   */
+  @Test public void closeWithExceptionWhenWritingAndClosing() throws IOException {
+    MockSink mockSink = new MockSink();
+    mockSink.scheduleThrow(0, new IOException("first"));
+    mockSink.scheduleThrow(1, new IOException("second"));
+    Deflater deflater = new Deflater();
+    deflater.setLevel(Deflater.NO_COMPRESSION);
+    DeflaterSink deflaterSink = new DeflaterSink(mockSink, deflater);
+    deflaterSink.write(new OkBuffer().writeUtf8(repeat('a', Segment.SIZE)), Segment.SIZE);
+    try {
+      deflaterSink.close();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("first", expected.getMessage());
+    }
+    mockSink.assertLogContains("close()");
+  }
+
+  /**
+   * Uses streaming decompression to inflate {@code deflated}. The input must
+   * either be finished or have a trailing sync flush.
+   */
+  private OkBuffer inflate(OkBuffer deflated) throws IOException {
+    InputStream deflatedIn = deflated.inputStream();
+    Inflater inflater = new Inflater();
+    InputStream inflatedIn = new InflaterInputStream(deflatedIn, inflater);
+    OkBuffer result = new OkBuffer();
+    byte[] buffer = new byte[8192];
+    while (!inflater.needsInput() || deflated.size() > 0 || deflatedIn.available() > 0) {
+      int count = inflatedIn.read(buffer, 0, buffer.length);
+      result.write(buffer, 0, count);
+    }
+    return result;
+  }
+
+  private ByteString randomBytes(int length) {
+    Random random = new Random(0);
+    byte[] randomBytes = new byte[length];
+    random.nextBytes(randomBytes);
+    return ByteString.of(randomBytes);
+  }
+
+  private String repeat(char c, int count) {
+    char[] array = new char[count];
+    Arrays.fill(array, c);
+    return new String(array);
+  }
+}
diff --git a/okio/src/test/java/okio/GzipSourceTest.java b/okio/src/test/java/okio/GzipSourceTest.java
new file mode 100644
index 0000000000..f14b99963c
--- /dev/null
+++ b/okio/src/test/java/okio/GzipSourceTest.java
@@ -0,0 +1,234 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.IOException;
+import java.util.zip.CRC32;
+import org.junit.Test;
+
+import static okio.Util.UTF_8;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public class GzipSourceTest {
+
+  @Test public void gunzip() throws Exception {
+    OkBuffer gzipped = new OkBuffer();
+    gzipped.write(gzipHeader);
+    gzipped.write(deflated);
+    gzipped.write(gzipTrailer);
+    assertGzipped(gzipped);
+  }
+
+  @Test public void gunzip_withHCRC() throws Exception {
+    CRC32 hcrc = new CRC32();
+    ByteString gzipHeader = gzipHeaderWithFlags((byte) 0x02);
+    hcrc.update(gzipHeader.toByteArray());
+
+    OkBuffer gzipped = new OkBuffer();
+    gzipped.write(gzipHeader);
+    gzipped.writeShort(Util.reverseBytesShort((short) hcrc.getValue())); // little endian
+    gzipped.write(deflated);
+    gzipped.write(gzipTrailer);
+    assertGzipped(gzipped);
+  }
+
+  @Test public void gunzip_withExtra() throws Exception {
+    OkBuffer gzipped = new OkBuffer();
+    gzipped.write(gzipHeaderWithFlags((byte) 0x04));
+    gzipped.writeShort(Util.reverseBytesShort((short) 7)); // little endian extra length
+    gzipped.write("blubber".getBytes(UTF_8), 0, 7);
+    gzipped.write(deflated);
+    gzipped.write(gzipTrailer);
+    assertGzipped(gzipped);
+  }
+
+  @Test public void gunzip_withName() throws Exception {
+    OkBuffer gzipped = new OkBuffer();
+    gzipped.write(gzipHeaderWithFlags((byte) 0x08));
+    gzipped.write("foo.txt".getBytes(UTF_8), 0, 7);
+    gzipped.writeByte(0); // zero-terminated
+    gzipped.write(deflated);
+    gzipped.write(gzipTrailer);
+    assertGzipped(gzipped);
+  }
+
+  @Test public void gunzip_withComment() throws Exception {
+    OkBuffer gzipped = new OkBuffer();
+    gzipped.write(gzipHeaderWithFlags((byte) 0x10));
+    gzipped.write("rubbish".getBytes(UTF_8), 0, 7);
+    gzipped.writeByte(0); // zero-terminated
+    gzipped.write(deflated);
+    gzipped.write(gzipTrailer);
+    assertGzipped(gzipped);
+  }
+
+  /**
+   * For portability, it is a good idea to export the gzipped bytes and try running gzip.  Ex.
+   * {@code echo gzipped | base64 --decode | gzip -l -v}
+   */
+  @Test public void gunzip_withAll() throws Exception {
+    OkBuffer gzipped = new OkBuffer();
+    gzipped.write(gzipHeaderWithFlags((byte) 0x1c));
+    gzipped.writeShort(Util.reverseBytesShort((short) 7)); // little endian extra length
+    gzipped.write("blubber".getBytes(UTF_8), 0, 7);
+    gzipped.write("foo.txt".getBytes(UTF_8), 0, 7);
+    gzipped.writeByte(0); // zero-terminated
+    gzipped.write("rubbish".getBytes(UTF_8), 0, 7);
+    gzipped.writeByte(0); // zero-terminated
+    gzipped.write(deflated);
+    gzipped.write(gzipTrailer);
+    assertGzipped(gzipped);
+  }
+
+  private void assertGzipped(OkBuffer gzipped) throws IOException {
+    OkBuffer gunzipped = gunzip(gzipped);
+    assertEquals("It's a UNIX system! I know this!", gunzipped.readUtf8(gunzipped.size()));
+  }
+
+  /**
+   * Note that you cannot test this with old versions of gzip, as they interpret flag bit 1 as
+   * CONTINUATION, not HCRC. For example, this is the case with the default gzip on osx.
+   */
+  @Test public void gunzipWhenHeaderCRCIncorrect() throws Exception {
+    OkBuffer gzipped = new OkBuffer();
+    gzipped.write(gzipHeaderWithFlags((byte) 0x02));
+    gzipped.writeShort((short) 0); // wrong HCRC!
+    gzipped.write(deflated);
+    gzipped.write(gzipTrailer);
+
+    try {
+      gunzip(gzipped);
+      fail();
+    } catch (IOException e) {
+      assertEquals("FHCRC: actual 0x0000261d != expected 0x00000000", e.getMessage());
+    }
+  }
+
+  @Test public void gunzipWhenCRCIncorrect() throws Exception {
+    OkBuffer gzipped = new OkBuffer();
+    gzipped.write(gzipHeader);
+    gzipped.write(deflated);
+    gzipped.writeInt(Util.reverseBytesInt(0x1234567)); // wrong CRC
+    gzipped.write(gzipTrailer.toByteArray(), 3, 4);
+
+    try {
+      gunzip(gzipped);
+      fail();
+    } catch (IOException e) {
+      assertEquals("CRC: actual 0x37ad8f8d != expected 0x01234567", e.getMessage());
+    }
+  }
+
+  @Test public void gunzipWhenLengthIncorrect() throws Exception {
+    OkBuffer gzipped = new OkBuffer();
+    gzipped.write(gzipHeader);
+    gzipped.write(deflated);
+    gzipped.write(gzipTrailer.toByteArray(), 0, 4);
+    gzipped.writeInt(Util.reverseBytesInt(0x123456)); // wrong length
+
+    try {
+      gunzip(gzipped);
+      fail();
+    } catch (IOException e) {
+      assertEquals("ISIZE: actual 0x00000020 != expected 0x00123456", e.getMessage());
+    }
+  }
+
+  @Test public void gunzipExhaustsSource() throws Exception {
+    OkBuffer gzippedSource = new OkBuffer()
+        .write(ByteString.decodeHex("1f8b08000000000000004b4c4a0600c241243503000000")); // 'abc'
+
+    ExhaustableSource exhaustableSource = new ExhaustableSource(gzippedSource);
+    BufferedSource gunzippedSource = Okio.buffer(new GzipSource(exhaustableSource));
+
+    assertEquals('a', gunzippedSource.readByte());
+    assertEquals('b', gunzippedSource.readByte());
+    assertEquals('c', gunzippedSource.readByte());
+    assertFalse(exhaustableSource.exhausted);
+    assertEquals(-1, gunzippedSource.read(new OkBuffer(), 1));
+    assertTrue(exhaustableSource.exhausted);
+  }
+
+  @Test public void gunzipThrowsIfSourceIsNotExhausted() throws Exception {
+    OkBuffer gzippedSource = new OkBuffer()
+        .write(ByteString.decodeHex("1f8b08000000000000004b4c4a0600c241243503000000")); // 'abc'
+    gzippedSource.writeByte('d'); // This byte shouldn't be here!
+
+    BufferedSource gunzippedSource = Okio.buffer(new GzipSource(gzippedSource));
+
+    assertEquals('a', gunzippedSource.readByte());
+    assertEquals('b', gunzippedSource.readByte());
+    assertEquals('c', gunzippedSource.readByte());
+    try {
+      gunzippedSource.readByte();
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  private ByteString gzipHeaderWithFlags(byte flags) {
+    byte[] result = gzipHeader.toByteArray();
+    result[3] = flags;
+    return ByteString.of(result);
+  }
+
+  private final ByteString gzipHeader = ByteString.decodeHex("1f8b0800000000000000");
+
+  // Deflated "It's a UNIX system! I know this!"
+  private final ByteString deflated = ByteString.decodeHex(
+      "f32c512f56485408f5f38c5028ae2c2e49cd5554f054c8cecb2f5728c9c82c560400");
+
+  private final ByteString gzipTrailer = ByteString.decodeHex(""
+      + "8d8fad37" // Checksum of deflated.
+      + "20000000" // 32 in little endian.
+  );
+
+  private OkBuffer gunzip(OkBuffer gzipped) throws IOException {
+    OkBuffer result = new OkBuffer();
+    GzipSource source = new GzipSource(gzipped);
+    while (source.read(result, Integer.MAX_VALUE) != -1) {
+    }
+    return result;
+  }
+
+  /** This source keeps track of whether its read have returned -1. */
+  static class ExhaustableSource implements Source {
+    private final Source source;
+    private boolean exhausted;
+
+    ExhaustableSource(Source source) {
+      this.source = source;
+    }
+
+    @Override public long read(OkBuffer sink, long byteCount) throws IOException {
+      long result = source.read(sink, byteCount);
+      if (result == -1) exhausted = true;
+      return result;
+    }
+
+    @Override public Source deadline(Deadline deadline) {
+      source.deadline(deadline);
+      return this;
+    }
+
+    @Override public void close() throws IOException {
+      source.close();
+    }
+  }
+}
diff --git a/okio/src/test/java/okio/InflaterSourceTest.java b/okio/src/test/java/okio/InflaterSourceTest.java
new file mode 100644
index 0000000000..e6f2bc6536
--- /dev/null
+++ b/okio/src/test/java/okio/InflaterSourceTest.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Random;
+import java.util.zip.DeflaterOutputStream;
+import java.util.zip.Inflater;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class InflaterSourceTest {
+  @Test public void inflate() throws Exception {
+    OkBuffer deflated = decodeBase64("eJxzz09RyEjNKVAoLdZRKE9VL0pVyMxTKMlIVchIzEspVshPU0jNS8/MS00tK"
+        + "tYDAF6CD5s=");
+    OkBuffer inflated = inflate(deflated);
+    assertEquals("God help us, we're in the hands of engineers.", readUtf8(inflated));
+  }
+
+  @Test public void inflateTruncated() throws Exception {
+    OkBuffer deflated = decodeBase64("eJxzz09RyEjNKVAoLdZRKE9VL0pVyMxTKMlIVchIzEspVshPU0jNS8/MS00tK"
+        + "tYDAF6CDw==");
+    try {
+      inflate(deflated);
+      fail();
+    } catch (EOFException expected) {
+    }
+  }
+
+  @Test public void inflateWellCompressed() throws Exception {
+    OkBuffer deflated = decodeBase64("eJztwTEBAAAAwqCs61/CEL5AAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
+        + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8B"
+        + "tFeWvE=\n");
+    String original = repeat('a', 1024 * 1024);
+    OkBuffer inflated = inflate(deflated);
+    assertEquals(original, readUtf8(inflated));
+  }
+
+  @Test public void inflatePoorlyCompressed() throws Exception {
+    ByteString original = randomBytes(1024 * 1024);
+    OkBuffer deflated = deflate(original);
+    OkBuffer inflated = inflate(deflated);
+    assertEquals(original, inflated.readByteString(inflated.size()));
+  }
+
+  private OkBuffer decodeBase64(String s) {
+    return new OkBuffer().write(ByteString.decodeBase64(s));
+  }
+
+  private String readUtf8(OkBuffer buffer) {
+    return buffer.readUtf8(buffer.size());
+  }
+
+  /** Use DeflaterOutputStream to deflate source. */
+  private OkBuffer deflate(ByteString source) throws IOException {
+    OkBuffer result = new OkBuffer();
+    Sink sink = Okio.sink(new DeflaterOutputStream(result.outputStream()));
+    sink.write(new OkBuffer().write(source), source.size());
+    sink.close();
+    return result;
+  }
+
+  /** Returns a new buffer containing the inflated contents of {@code deflated}. */
+  private OkBuffer inflate(OkBuffer deflated) throws IOException {
+    OkBuffer result = new OkBuffer();
+    InflaterSource source = new InflaterSource(deflated, new Inflater());
+    while (source.read(result, Integer.MAX_VALUE) != -1) {
+    }
+    return result;
+  }
+
+  private ByteString randomBytes(int length) {
+    Random random = new Random(0);
+    byte[] randomBytes = new byte[length];
+    random.nextBytes(randomBytes);
+    return ByteString.of(randomBytes);
+  }
+
+  private String repeat(char c, int count) {
+    char[] array = new char[count];
+    Arrays.fill(array, c);
+    return new String(array);
+  }
+}
diff --git a/okio/src/test/java/okio/MockSink.java b/okio/src/test/java/okio/MockSink.java
new file mode 100644
index 0000000000..bae3259111
--- /dev/null
+++ b/okio/src/test/java/okio/MockSink.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+/** A scriptable sink. Like Mockito, but worse and requiring less configuration. */
+class MockSink implements Sink {
+  private final List<String> log = new ArrayList<String>();
+  private final Map<Integer, IOException> callThrows = new LinkedHashMap<Integer, IOException>();
+
+  public void assertLog(String... messages) {
+    assertEquals(Arrays.asList(messages), log);
+  }
+
+  public void assertLogContains(String message) {
+    assertTrue(log.contains(message));
+  }
+
+  public void scheduleThrow(int call, IOException e) {
+    callThrows.put(call, e);
+  }
+
+  private void throwIfScheduled() throws IOException {
+    IOException exception = callThrows.get(log.size() - 1);
+    if (exception != null) throw exception;
+  }
+
+  @Override public void write(OkBuffer source, long byteCount) throws IOException {
+    log.add("write(" + source + ", " + byteCount + ")");
+    source.skip(byteCount);
+    throwIfScheduled();
+  }
+
+  @Override public void flush() throws IOException {
+    log.add("flush()");
+    throwIfScheduled();
+  }
+
+  @Override public Sink deadline(Deadline deadline) {
+    log.add("deadline()");
+    return this;
+  }
+
+  @Override public void close() throws IOException {
+    log.add("close()");
+    throwIfScheduled();
+  }
+}
diff --git a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java b/okio/src/test/java/okio/OkBufferReadUtf8LineTest.java
similarity index 66%
rename from okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java
rename to okio/src/test/java/okio/OkBufferReadUtf8LineTest.java
index c1f4d3cf88..ac3de728e8 100644
--- a/okhttp/src/test/java/com/squareup/okhttp/internal/http/HttpOverHttp20Draft09Test.java
+++ b/okio/src/test/java/okio/OkBufferReadUtf8LineTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013 Square, Inc.
+ * Copyright (C) 2014 Square, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,14 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package com.squareup.okhttp.internal.http;
+package okio;
 
-import com.squareup.okhttp.Protocol;
-
-public class HttpOverHttp20Draft09Test extends HttpOverSpdyTest {
-
-  public HttpOverHttp20Draft09Test() {
-    super(Protocol.HTTP_2);
-    this.hostHeader = ":authority";
+public final class OkBufferReadUtf8LineTest extends ReadUtf8LineTest {
+  @Override protected BufferedSource newSource(String s) {
+    return new OkBuffer().writeUtf8(s);
   }
 }
diff --git a/okio/src/test/java/okio/OkBufferTest.java b/okio/src/test/java/okio/OkBufferTest.java
new file mode 100644
index 0000000000..f69613a182
--- /dev/null
+++ b/okio/src/test/java/okio/OkBufferTest.java
@@ -0,0 +1,682 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Random;
+import org.junit.Test;
+
+import static java.util.Arrays.asList;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public final class OkBufferTest {
+  @Test public void readAndWriteUtf8() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8("ab");
+    assertEquals(2, buffer.size());
+    buffer.writeUtf8("cdef");
+    assertEquals(6, buffer.size());
+    assertEquals("abcd", buffer.readUtf8(4));
+    assertEquals(2, buffer.size());
+    assertEquals("ef", buffer.readUtf8(2));
+    assertEquals(0, buffer.size());
+    try {
+      buffer.readUtf8(1);
+      fail();
+    } catch (ArrayIndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void completeSegmentByteCountOnEmptyBuffer() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    assertEquals(0, buffer.completeSegmentByteCount());
+  }
+
+  @Test public void completeSegmentByteCountOnBufferWithFullSegments() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8(repeat('a', Segment.SIZE * 4));
+    assertEquals(Segment.SIZE * 4, buffer.completeSegmentByteCount());
+  }
+
+  @Test public void completeSegmentByteCountOnBufferWithIncompleteTailSegment() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8(repeat('a', Segment.SIZE * 4 - 10));
+    assertEquals(Segment.SIZE * 3, buffer.completeSegmentByteCount());
+  }
+
+  @Test public void readUtf8SpansSegments() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8(repeat('a', Segment.SIZE * 2));
+    buffer.readUtf8(Segment.SIZE - 1);
+    assertEquals("aa", buffer.readUtf8(2));
+  }
+
+  @Test public void readUtf8EntireBuffer() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8(repeat('a', Segment.SIZE));
+    assertEquals(repeat('a', Segment.SIZE), buffer.readUtf8(Segment.SIZE));
+  }
+
+  @Test public void toStringOnEmptyBuffer() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    assertEquals("OkBuffer[size=0]", buffer.toString());
+  }
+
+  @Test public void toStringOnSmallBufferIncludesContents() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.write(ByteString.decodeHex("a1b2c3d4e5f61a2b3c4d5e6f10203040"));
+    assertEquals("OkBuffer[size=16 data=a1b2c3d4e5f61a2b3c4d5e6f10203040]", buffer.toString());
+  }
+
+  @Test public void toStringOnLargeBufferIncludesMd5() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.write(ByteString.encodeUtf8("12345678901234567"));
+    assertEquals("OkBuffer[size=17 md5=2c9728a2138b2f25e9f89f99bdccf8db]", buffer.toString());
+  }
+
+  @Test public void toStringOnMultipleSegmentBuffer() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8(repeat('a', 6144));
+    assertEquals("OkBuffer[size=6144 md5=d890021f28522533c1cc1b9b1f83ce73]", buffer.toString());
+  }
+
+  @Test public void multipleSegmentBuffers() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8(repeat('a',  1000));
+    buffer.writeUtf8(repeat('b', 2500));
+    buffer.writeUtf8(repeat('c', 5000));
+    buffer.writeUtf8(repeat('d', 10000));
+    buffer.writeUtf8(repeat('e', 25000));
+    buffer.writeUtf8(repeat('f', 50000));
+
+    assertEquals(repeat('a', 999), buffer.readUtf8(999)); // a...a
+    assertEquals("a" + repeat('b', 2500) + "c", buffer.readUtf8(2502)); // ab...bc
+    assertEquals(repeat('c', 4998), buffer.readUtf8(4998)); // c...c
+    assertEquals("c" + repeat('d', 10000) + "e", buffer.readUtf8(10002)); // cd...de
+    assertEquals(repeat('e', 24998), buffer.readUtf8(24998)); // e...e
+    assertEquals("e" + repeat('f', 50000), buffer.readUtf8(50001)); // ef...f
+    assertEquals(0, buffer.size());
+  }
+
+  @Test public void fillAndDrainPool() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+
+    // Take 2 * MAX_SIZE segments. This will drain the pool, even if other tests filled it.
+    buffer.write(new byte[(int) SegmentPool.MAX_SIZE]);
+    buffer.write(new byte[(int) SegmentPool.MAX_SIZE]);
+    assertEquals(0, SegmentPool.INSTANCE.byteCount);
+
+    // Recycle MAX_SIZE segments. They're all in the pool.
+    buffer.readByteString(SegmentPool.MAX_SIZE);
+    assertEquals(SegmentPool.MAX_SIZE, SegmentPool.INSTANCE.byteCount);
+
+    // Recycle MAX_SIZE more segments. The pool is full so they get garbage collected.
+    buffer.readByteString(SegmentPool.MAX_SIZE);
+    assertEquals(SegmentPool.MAX_SIZE, SegmentPool.INSTANCE.byteCount);
+
+    // Take MAX_SIZE segments to drain the pool.
+    buffer.write(new byte[(int) SegmentPool.MAX_SIZE]);
+    assertEquals(0, SegmentPool.INSTANCE.byteCount);
+
+    // Take MAX_SIZE more segments. The pool is drained so these will need to be allocated.
+    buffer.write(new byte[(int) SegmentPool.MAX_SIZE]);
+    assertEquals(0, SegmentPool.INSTANCE.byteCount);
+  }
+
+  @Test public void moveBytesBetweenBuffersShareSegment() throws Exception {
+    int size = (Segment.SIZE / 2) - 1;
+    List<Integer> segmentSizes = moveBytesBetweenBuffers(repeat('a', size), repeat('b', size));
+    assertEquals(asList(size * 2), segmentSizes);
+  }
+
+  @Test public void moveBytesBetweenBuffersReassignSegment() throws Exception {
+    int size = (Segment.SIZE / 2) + 1;
+    List<Integer> segmentSizes = moveBytesBetweenBuffers(repeat('a', size), repeat('b', size));
+    assertEquals(asList(size, size), segmentSizes);
+  }
+
+  @Test public void moveBytesBetweenBuffersMultipleSegments() throws Exception {
+    int size = 3 * Segment.SIZE + 1;
+    List<Integer> segmentSizes = moveBytesBetweenBuffers(repeat('a', size), repeat('b', size));
+    assertEquals(asList(Segment.SIZE, Segment.SIZE, Segment.SIZE, 1,
+        Segment.SIZE, Segment.SIZE, Segment.SIZE, 1), segmentSizes);
+  }
+
+  private List<Integer> moveBytesBetweenBuffers(String... contents) {
+    StringBuilder expected = new StringBuilder();
+    OkBuffer buffer = new OkBuffer();
+    for (String s : contents) {
+      OkBuffer source = new OkBuffer();
+      source.writeUtf8(s);
+      buffer.write(source, source.size());
+      expected.append(s);
+    }
+    List<Integer> segmentSizes = buffer.segmentSizes();
+    assertEquals(expected.toString(), buffer.readUtf8(expected.length()));
+    return segmentSizes;
+  }
+
+  /** The big part of source's first segment is being moved. */
+  @Test public void writeSplitSourceBufferLeft() throws Exception {
+    int writeSize = Segment.SIZE / 2 + 1;
+
+    OkBuffer sink = new OkBuffer();
+    sink.writeUtf8(repeat('b', Segment.SIZE - 10));
+
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8(repeat('a', Segment.SIZE * 2));
+    sink.write(source, writeSize);
+
+    assertEquals(asList(Segment.SIZE - 10, writeSize), sink.segmentSizes());
+    assertEquals(asList(Segment.SIZE - writeSize, Segment.SIZE), source.segmentSizes());
+  }
+
+  /** The big part of source's first segment is staying put. */
+  @Test public void writeSplitSourceBufferRight() throws Exception {
+    int writeSize = Segment.SIZE / 2 - 1;
+
+    OkBuffer sink = new OkBuffer();
+    sink.writeUtf8(repeat('b', Segment.SIZE - 10));
+
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8(repeat('a', Segment.SIZE * 2));
+    sink.write(source, writeSize);
+
+    assertEquals(asList(Segment.SIZE - 10, writeSize), sink.segmentSizes());
+    assertEquals(asList(Segment.SIZE - writeSize, Segment.SIZE), source.segmentSizes());
+  }
+
+  @Test public void writePrefixDoesntSplit() throws Exception {
+    OkBuffer sink = new OkBuffer();
+    sink.writeUtf8(repeat('b', 10));
+
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8(repeat('a', Segment.SIZE * 2));
+    sink.write(source, 20);
+
+    assertEquals(asList(30), sink.segmentSizes());
+    assertEquals(asList(Segment.SIZE - 20, Segment.SIZE), source.segmentSizes());
+    assertEquals(30, sink.size());
+    assertEquals(Segment.SIZE * 2 - 20, source.size());
+  }
+
+  @Test public void writePrefixDoesntSplitButRequiresCompact() throws Exception {
+    OkBuffer sink = new OkBuffer();
+    sink.writeUtf8(repeat('b', Segment.SIZE - 10)); // limit = size - 10
+    sink.readUtf8(Segment.SIZE - 20); // pos = size = 20
+
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8(repeat('a', Segment.SIZE * 2));
+    sink.write(source, 20);
+
+    assertEquals(asList(30), sink.segmentSizes());
+    assertEquals(asList(Segment.SIZE - 20, Segment.SIZE), source.segmentSizes());
+    assertEquals(30, sink.size());
+    assertEquals(Segment.SIZE * 2 - 20, source.size());
+  }
+
+  @Test public void readExhaustedSource() throws Exception {
+    OkBuffer sink = new OkBuffer();
+    sink.writeUtf8(repeat('a', 10));
+
+    OkBuffer source = new OkBuffer();
+
+    assertEquals(-1, source.read(sink, 10));
+    assertEquals(10, sink.size());
+    assertEquals(0, source.size());
+  }
+
+  @Test public void readZeroBytesFromSource() throws Exception {
+    OkBuffer sink = new OkBuffer();
+    sink.writeUtf8(repeat('a', 10));
+
+    OkBuffer source = new OkBuffer();
+
+    // Either 0 or -1 is reasonable here. For consistency with Android's
+    // ByteArrayInputStream we return 0.
+    assertEquals(-1, source.read(sink, 0));
+    assertEquals(10, sink.size());
+    assertEquals(0, source.size());
+  }
+
+  @Test public void moveAllRequestedBytesWithRead() throws Exception {
+    OkBuffer sink = new OkBuffer();
+    sink.writeUtf8(repeat('a', 10));
+
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8(repeat('b', 15));
+
+    assertEquals(10, source.read(sink, 10));
+    assertEquals(20, sink.size());
+    assertEquals(5, source.size());
+    assertEquals(repeat('a', 10) + repeat('b', 10), sink.readUtf8(20));
+  }
+
+  @Test public void moveFewerThanRequestedBytesWithRead() throws Exception {
+    OkBuffer sink = new OkBuffer();
+    sink.writeUtf8(repeat('a', 10));
+
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8(repeat('b', 20));
+
+    assertEquals(20, source.read(sink, 25));
+    assertEquals(30, sink.size());
+    assertEquals(0, source.size());
+    assertEquals(repeat('a', 10) + repeat('b', 20), sink.readUtf8(30));
+  }
+
+  @Test public void indexOf() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+
+    // The segment is empty.
+    assertEquals(-1, buffer.indexOf((byte) 'a'));
+
+    // The segment has one value.
+    buffer.writeUtf8("a"); // a
+    assertEquals(0, buffer.indexOf((byte) 'a'));
+    assertEquals(-1, buffer.indexOf((byte) 'b'));
+
+    // The segment has lots of data.
+    buffer.writeUtf8(repeat('b', Segment.SIZE - 2)); // ab...b
+    assertEquals(0, buffer.indexOf((byte) 'a'));
+    assertEquals(1, buffer.indexOf((byte) 'b'));
+    assertEquals(-1, buffer.indexOf((byte) 'c'));
+
+    // The segment doesn't start at 0, it starts at 2.
+    buffer.readUtf8(2); // b...b
+    assertEquals(-1, buffer.indexOf((byte) 'a'));
+    assertEquals(0, buffer.indexOf((byte) 'b'));
+    assertEquals(-1, buffer.indexOf((byte) 'c'));
+
+    // The segment is full.
+    buffer.writeUtf8("c"); // b...bc
+    assertEquals(-1, buffer.indexOf((byte) 'a'));
+    assertEquals(0, buffer.indexOf((byte) 'b'));
+    assertEquals(Segment.SIZE - 3, buffer.indexOf((byte) 'c'));
+
+    // The segment doesn't start at 2, it starts at 4.
+    buffer.readUtf8(2); // b...bc
+    assertEquals(-1, buffer.indexOf((byte) 'a'));
+    assertEquals(0, buffer.indexOf((byte) 'b'));
+    assertEquals(Segment.SIZE - 5, buffer.indexOf((byte) 'c'));
+
+    // Two segments.
+    buffer.writeUtf8("d"); // b...bcd, d is in the 2nd segment.
+    assertEquals(asList(Segment.SIZE - 4, 1), buffer.segmentSizes());
+    assertEquals(Segment.SIZE - 4, buffer.indexOf((byte) 'd'));
+    assertEquals(-1, buffer.indexOf((byte) 'e'));
+  }
+
+  @Test public void indexOfWithOffset() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    int halfSegment = Segment.SIZE / 2;
+    buffer.writeUtf8(repeat('a', halfSegment));
+    buffer.writeUtf8(repeat('b', halfSegment));
+    buffer.writeUtf8(repeat('c', halfSegment));
+    buffer.writeUtf8(repeat('d', halfSegment));
+    assertEquals(0, buffer.indexOf((byte) 'a', 0));
+    assertEquals(halfSegment - 1, buffer.indexOf((byte) 'a', halfSegment - 1));
+    assertEquals(halfSegment, buffer.indexOf((byte) 'b', halfSegment - 1));
+    assertEquals(halfSegment * 2, buffer.indexOf((byte) 'c', halfSegment - 1));
+    assertEquals(halfSegment * 3, buffer.indexOf((byte) 'd', halfSegment - 1));
+    assertEquals(halfSegment * 3, buffer.indexOf((byte) 'd', halfSegment * 2));
+    assertEquals(halfSegment * 3, buffer.indexOf((byte) 'd', halfSegment * 3));
+    assertEquals(halfSegment * 4 - 1, buffer.indexOf((byte) 'd', halfSegment * 4 - 1));
+  }
+
+  @Test public void writeBytes() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeByte(0xab);
+    data.writeByte(0xcd);
+    assertEquals("OkBuffer[size=2 data=abcd]", data.toString());
+  }
+
+  @Test public void writeLastByteInSegment() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeUtf8(repeat('a', Segment.SIZE - 1));
+    data.writeByte(0x20);
+    data.writeByte(0x21);
+    assertEquals(asList(Segment.SIZE, 1), data.segmentSizes());
+    assertEquals(repeat('a', Segment.SIZE - 1), data.readUtf8(Segment.SIZE - 1));
+    assertEquals("OkBuffer[size=2 data=2021]", data.toString());
+  }
+
+  @Test public void writeShort() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeShort(0xabcd);
+    data.writeShort(0x4321);
+    assertEquals("OkBuffer[size=4 data=abcd4321]", data.toString());
+  }
+
+  @Test public void writeShortLe() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeShortLe(0xabcd);
+    data.writeShortLe(0x4321);
+    assertEquals("OkBuffer[size=4 data=cdab2143]", data.toString());
+  }
+
+  @Test public void writeInt() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeInt(0xabcdef01);
+    data.writeInt(0x87654321);
+    assertEquals("OkBuffer[size=8 data=abcdef0187654321]", data.toString());
+  }
+
+  @Test public void writeLastIntegerInSegment() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeUtf8(repeat('a', Segment.SIZE - 4));
+    data.writeInt(0xabcdef01);
+    data.writeInt(0x87654321);
+    assertEquals(asList(Segment.SIZE, 4), data.segmentSizes());
+    assertEquals(repeat('a', Segment.SIZE - 4), data.readUtf8(Segment.SIZE - 4));
+    assertEquals("OkBuffer[size=8 data=abcdef0187654321]", data.toString());
+  }
+
+  @Test public void writeIntegerDoesntQuiteFitInSegment() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeUtf8(repeat('a', Segment.SIZE - 3));
+    data.writeInt(0xabcdef01);
+    data.writeInt(0x87654321);
+    assertEquals(asList(Segment.SIZE - 3, 8), data.segmentSizes());
+    assertEquals(repeat('a', Segment.SIZE - 3), data.readUtf8(Segment.SIZE - 3));
+    assertEquals("OkBuffer[size=8 data=abcdef0187654321]", data.toString());
+  }
+
+  @Test public void writeIntLe() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeIntLe(0xabcdef01);
+    data.writeIntLe(0x87654321);
+    assertEquals("OkBuffer[size=8 data=01efcdab21436587]", data.toString());
+  }
+
+  @Test public void writeLong() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeLong(0xabcdef0187654321L);
+    data.writeLong(0xcafebabeb0b15c00L);
+    assertEquals("OkBuffer[size=16 data=abcdef0187654321cafebabeb0b15c00]", data.toString());
+  }
+
+  @Test public void writeLongLe() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeLongLe(0xabcdef0187654321L);
+    data.writeLongLe(0xcafebabeb0b15c00L);
+    assertEquals("OkBuffer[size=16 data=2143658701efcdab005cb1b0bebafeca]", data.toString());
+  }
+
+  @Test public void readByte() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.write(new byte[] { (byte) 0xab, (byte) 0xcd });
+    assertEquals(0xab, data.readByte() & 0xff);
+    assertEquals(0xcd, data.readByte() & 0xff);
+    assertEquals(0, data.size());
+  }
+
+  @Test public void readShort() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.write(new byte[] {
+        (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0x01
+    });
+    assertEquals((short) 0xabcd, data.readShort());
+    assertEquals((short) 0xef01, data.readShort());
+    assertEquals(0, data.size());
+  }
+
+  @Test public void readShortLe() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.write(new byte[] {
+        (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0x10
+    });
+    assertEquals((short) 0xcdab, data.readShortLe());
+    assertEquals((short) 0x10ef, data.readShortLe());
+    assertEquals(0, data.size());
+  }
+
+  @Test public void readShortSplitAcrossMultipleSegments() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeUtf8(repeat('a', Segment.SIZE - 1));
+    data.write(new byte[] { (byte) 0xab, (byte) 0xcd });
+    data.readUtf8(Segment.SIZE - 1);
+    assertEquals((short) 0xabcd, data.readShort());
+    assertEquals(0, data.size());
+  }
+
+  @Test public void readInt() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.write(new byte[] {
+        (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0x01,
+        (byte) 0x87, (byte) 0x65, (byte) 0x43, (byte) 0x21
+    });
+    assertEquals(0xabcdef01, data.readInt());
+    assertEquals(0x87654321, data.readInt());
+    assertEquals(0, data.size());
+  }
+
+  @Test public void readIntLe() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.write(new byte[] {
+        (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0x10,
+        (byte) 0x87, (byte) 0x65, (byte) 0x43, (byte) 0x21
+    });
+    assertEquals(0x10efcdab, data.readIntLe());
+    assertEquals(0x21436587, data.readIntLe());
+    assertEquals(0, data.size());
+  }
+
+  @Test public void readIntSplitAcrossMultipleSegments() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeUtf8(repeat('a', Segment.SIZE - 3));
+    data.write(new byte[] {
+        (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0x01
+    });
+    data.readUtf8(Segment.SIZE - 3);
+    assertEquals(0xabcdef01, data.readInt());
+    assertEquals(0, data.size());
+  }
+
+  @Test public void readLong() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.write(new byte[] {
+        (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0x10,
+        (byte) 0x87, (byte) 0x65, (byte) 0x43, (byte) 0x21,
+        (byte) 0x36, (byte) 0x47, (byte) 0x58, (byte) 0x69,
+        (byte) 0x12, (byte) 0x23, (byte) 0x34, (byte) 0x45
+    });
+    assertEquals(0xabcdef1087654321L, data.readLong());
+    assertEquals(0x3647586912233445L, data.readLong());
+    assertEquals(0, data.size());
+  }
+
+  @Test public void readLongLe() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.write(new byte[] {
+        (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0x10,
+        (byte) 0x87, (byte) 0x65, (byte) 0x43, (byte) 0x21,
+        (byte) 0x36, (byte) 0x47, (byte) 0x58, (byte) 0x69,
+        (byte) 0x12, (byte) 0x23, (byte) 0x34, (byte) 0x45
+    });
+    assertEquals(0x2143658710efcdabL, data.readLongLe());
+    assertEquals(0x4534231269584736L, data.readLongLe());
+    assertEquals(0, data.size());
+  }
+
+  @Test public void readLongSplitAcrossMultipleSegments() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeUtf8(repeat('a', Segment.SIZE - 7));
+    data.write(new byte[] {
+        (byte) 0xab, (byte) 0xcd, (byte) 0xef, (byte) 0x01,
+        (byte) 0x87, (byte) 0x65, (byte) 0x43, (byte) 0x21,
+    });
+    data.readUtf8(Segment.SIZE - 7);
+    assertEquals(0xabcdef0187654321L, data.readLong());
+    assertEquals(0, data.size());
+  }
+
+  @Test public void byteAt() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8("a");
+    buffer.writeUtf8(repeat('b', Segment.SIZE));
+    buffer.writeUtf8("c");
+    assertEquals('a', buffer.getByte(0));
+    assertEquals('a', buffer.getByte(0)); // getByte doesn't mutate!
+    assertEquals('c', buffer.getByte(buffer.size - 1));
+    assertEquals('b', buffer.getByte(buffer.size - 2));
+    assertEquals('b', buffer.getByte(buffer.size - 3));
+  }
+
+  @Test public void getByteOfEmptyBuffer() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    try {
+      buffer.getByte(0);
+      fail();
+    } catch (IndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void skip() throws Exception {
+    OkBuffer buffer = new OkBuffer();
+    buffer.writeUtf8("a");
+    buffer.writeUtf8(repeat('b', Segment.SIZE));
+    buffer.writeUtf8("c");
+    buffer.skip(1);
+    assertEquals('b', buffer.readByte() & 0xff);
+    buffer.skip(Segment.SIZE - 2);
+    assertEquals('b', buffer.readByte() & 0xff);
+    buffer.skip(1);
+    assertEquals(0, buffer.size());
+  }
+
+  @Test public void testWritePrefixToEmptyBuffer() {
+    OkBuffer sink = new OkBuffer();
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8("abcd");
+    sink.write(source, 2);
+    assertEquals("ab", sink.readUtf8(2));
+  }
+
+  @Test public void cloneDoesNotObserveWritesToOriginal() throws Exception {
+    OkBuffer original = new OkBuffer();
+    OkBuffer clone = original.clone();
+    original.writeUtf8("abc");
+    assertEquals(0, clone.size());
+  }
+
+  @Test public void cloneDoesNotObserveReadsFromOriginal() throws Exception {
+    OkBuffer original = new OkBuffer();
+    original.writeUtf8("abc");
+    OkBuffer clone = original.clone();
+    assertEquals("abc", original.readUtf8(3));
+    assertEquals(3, clone.size());
+    assertEquals("ab", clone.readUtf8(2));
+  }
+
+  @Test public void originalDoesNotObserveWritesToClone() throws Exception {
+    OkBuffer original = new OkBuffer();
+    OkBuffer clone = original.clone();
+    clone.writeUtf8("abc");
+    assertEquals(0, original.size());
+  }
+
+  @Test public void originalDoesNotObserveReadsFromClone() throws Exception {
+    OkBuffer original = new OkBuffer();
+    original.writeUtf8("abc");
+    OkBuffer clone = original.clone();
+    assertEquals("abc", clone.readUtf8(3));
+    assertEquals(3, original.size());
+    assertEquals("ab", original.readUtf8(2));
+  }
+
+  @Test public void cloneMultipleSegments() throws Exception {
+    OkBuffer original = new OkBuffer();
+    original.writeUtf8(repeat('a', Segment.SIZE * 3));
+    OkBuffer clone = original.clone();
+    original.writeUtf8(repeat('b', Segment.SIZE * 3));
+    clone.writeUtf8(repeat('c', Segment.SIZE * 3));
+
+    assertEquals(repeat('a', Segment.SIZE * 3) + repeat('b', Segment.SIZE * 3),
+        original.readUtf8(Segment.SIZE * 6));
+    assertEquals(repeat('a', Segment.SIZE * 3) + repeat('c', Segment.SIZE * 3),
+        clone.readUtf8(Segment.SIZE * 6));
+  }
+
+  @Test public void testEqualsAndHashCodeEmpty() throws Exception {
+    OkBuffer a = new OkBuffer();
+    OkBuffer b = new OkBuffer();
+    assertTrue(a.equals(b));
+    assertTrue(a.hashCode() == b.hashCode());
+  }
+
+  @Test public void testEqualsAndHashCode() throws Exception {
+    OkBuffer a = new OkBuffer().writeUtf8("dog");
+    OkBuffer b = new OkBuffer().writeUtf8("hotdog");
+    assertFalse(a.equals(b));
+    assertFalse(a.hashCode() == b.hashCode());
+
+    b.readUtf8(3); // Leaves b containing 'dog'.
+    assertTrue(a.equals(b));
+    assertTrue(a.hashCode() == b.hashCode());
+  }
+
+  @Test public void testEqualsAndHashCodeSpanningSegments() throws Exception {
+    byte[] data = new byte[1024 * 1024];
+    Random dice = new Random(0);
+    dice.nextBytes(data);
+
+    OkBuffer a = bufferWithRandomSegmentLayout(dice, data);
+    OkBuffer b = bufferWithRandomSegmentLayout(dice, data);
+    assertTrue(a.equals(b));
+    assertTrue(a.hashCode() == b.hashCode());
+
+    data[data.length / 2]++; // Change a single byte.
+    OkBuffer c = bufferWithRandomSegmentLayout(dice, data);
+    assertFalse(a.equals(c));
+    assertFalse(a.hashCode() == c.hashCode());
+  }
+
+  /**
+   * Returns a new buffer containing the data in {@code data}, and a segment
+   * layout determined by {@code dice}.
+   */
+  private OkBuffer bufferWithRandomSegmentLayout(Random dice, byte[] data) {
+    OkBuffer result = new OkBuffer();
+
+    // Writing to result directly will yield packed segments. Instead, write to
+    // other buffers, then write those buffers to result.
+    for (int pos = 0, byteCount; pos < data.length; pos += byteCount) {
+      byteCount = (Segment.SIZE / 2) + dice.nextInt(Segment.SIZE / 2);
+      if (byteCount > data.length - pos) byteCount = data.length - pos;
+      int offset = dice.nextInt(Segment.SIZE - byteCount);
+
+      OkBuffer segment = new OkBuffer();
+      segment.write(new byte[offset]);
+      segment.write(data, pos, byteCount);
+      segment.skip(offset);
+
+      result.write(segment, byteCount);
+    }
+
+    return result;
+  }
+
+  private String repeat(char c, int count) {
+    char[] array = new char[count];
+    Arrays.fill(array, c);
+    return new String(array);
+  }
+}
diff --git a/okio/src/test/java/okio/OkioTest.java b/okio/src/test/java/okio/OkioTest.java
new file mode 100644
index 0000000000..e56979fe4e
--- /dev/null
+++ b/okio/src/test/java/okio/OkioTest.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.InputStream;
+import java.util.Arrays;
+import org.junit.Test;
+
+import static okio.Util.UTF_8;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class OkioTest {
+  @Test public void sinkFromOutputStream() throws Exception {
+    OkBuffer data = new OkBuffer();
+    data.writeUtf8("a");
+    data.writeUtf8(repeat('b', 9998));
+    data.writeUtf8("c");
+
+    ByteArrayOutputStream out = new ByteArrayOutputStream();
+    Sink sink = Okio.sink(out);
+    sink.write(data, 3);
+    assertEquals("abb", out.toString("UTF-8"));
+    sink.write(data, data.size());
+    assertEquals("a" + repeat('b', 9998) + "c", out.toString("UTF-8"));
+  }
+
+  @Test public void sourceFromInputStream() throws Exception {
+    InputStream in = new ByteArrayInputStream(
+        ("a" + repeat('b', Segment.SIZE * 2) + "c").getBytes(UTF_8));
+
+    // Source: ab...bc
+    Source source = Okio.source(in);
+    OkBuffer sink = new OkBuffer();
+
+    // Source: b...bc. Sink: abb.
+    assertEquals(3, source.read(sink, 3));
+    assertEquals("abb", sink.readUtf8(3));
+
+    // Source: b...bc. Sink: b...b.
+    assertEquals(Segment.SIZE, source.read(sink, 20000));
+    assertEquals(repeat('b', Segment.SIZE), sink.readUtf8(sink.size()));
+
+    // Source: b...bc. Sink: b...bc.
+    assertEquals(Segment.SIZE - 1, source.read(sink, 20000));
+    assertEquals(repeat('b', Segment.SIZE - 2) + "c", sink.readUtf8(sink.size()));
+
+    // Source and sink are empty.
+    assertEquals(-1, source.read(sink, 1));
+  }
+
+  @Test public void sourceFromInputStreamBounds() throws Exception {
+    Source source = Okio.source(new ByteArrayInputStream(new byte[100]));
+    try {
+      source.read(new OkBuffer(), -1);
+      fail();
+    } catch (IllegalArgumentException expected) {
+    }
+  }
+
+  private String repeat(char c, int count) {
+    char[] array = new char[count];
+    Arrays.fill(array, c);
+    return new String(array);
+  }
+}
diff --git a/okio/src/test/java/okio/ReadUtf8LineTest.java b/okio/src/test/java/okio/ReadUtf8LineTest.java
new file mode 100644
index 0000000000..79b4c8abda
--- /dev/null
+++ b/okio/src/test/java/okio/ReadUtf8LineTest.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.EOFException;
+import java.io.IOException;
+import org.junit.Test;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+public abstract class ReadUtf8LineTest {
+  protected abstract BufferedSource newSource(String s);
+
+  @Test public void readLines() throws IOException {
+    BufferedSource source = newSource("abc\ndef\n");
+    assertEquals("abc", source.readUtf8LineStrict());
+    assertEquals("def", source.readUtf8LineStrict());
+    try {
+      source.readUtf8LineStrict();
+      fail();
+    } catch (EOFException expected) {
+    }
+  }
+
+  @Test public void emptyLines() throws IOException {
+    BufferedSource source = newSource("\n\n\n");
+    assertEquals("", source.readUtf8LineStrict());
+    assertEquals("", source.readUtf8LineStrict());
+    assertEquals("", source.readUtf8LineStrict());
+    assertTrue(source.exhausted());
+  }
+
+  @Test public void crDroppedPrecedingLf() throws IOException {
+    BufferedSource source = newSource("abc\r\ndef\r\nghi\rjkl\r\n");
+    assertEquals("abc", source.readUtf8LineStrict());
+    assertEquals("def", source.readUtf8LineStrict());
+    assertEquals("ghi\rjkl", source.readUtf8LineStrict());
+  }
+
+  @Test public void bufferedReaderCompatible() throws IOException {
+    BufferedSource source = newSource("abc\ndef");
+    assertEquals("abc", source.readUtf8Line());
+    assertEquals("def", source.readUtf8Line());
+    assertEquals(null, source.readUtf8Line());
+  }
+
+  @Test public void bufferedReaderCompatibleWithTrailingNewline() throws IOException {
+    BufferedSource source = newSource("abc\ndef\n");
+    assertEquals("abc", source.readUtf8Line());
+    assertEquals("def", source.readUtf8Line());
+    assertEquals(null, source.readUtf8Line());
+  }
+}
diff --git a/okio/src/test/java/okio/RealBufferedSinkTest.java b/okio/src/test/java/okio/RealBufferedSinkTest.java
new file mode 100644
index 0000000000..80a1317363
--- /dev/null
+++ b/okio/src/test/java/okio/RealBufferedSinkTest.java
@@ -0,0 +1,215 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.Arrays;
+import org.junit.Test;
+
+import static okio.Util.UTF_8;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class RealBufferedSinkTest {
+  @Test public void outputStreamFromSink() throws Exception {
+    OkBuffer sink = new OkBuffer();
+    OutputStream out = new RealBufferedSink(sink).outputStream();
+    out.write('a');
+    out.write(repeat('b', 9998).getBytes(UTF_8));
+    out.write('c');
+    out.flush();
+    assertEquals("a" + repeat('b', 9998) + "c", sink.readUtf8(10000));
+  }
+
+  @Test public void outputStreamFromSinkBounds() throws Exception {
+    OkBuffer sink = new OkBuffer();
+    OutputStream out = new RealBufferedSink(sink).outputStream();
+    try {
+      out.write(new byte[100], 50, 51);
+      fail();
+    } catch (ArrayIndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void bufferedSinkEmitsTailWhenItIsComplete() throws IOException {
+    OkBuffer sink = new OkBuffer();
+    BufferedSink bufferedSink = new RealBufferedSink(sink);
+    bufferedSink.writeUtf8(repeat('a', Segment.SIZE - 1));
+    assertEquals(0, sink.size());
+    bufferedSink.writeByte(0);
+    assertEquals(Segment.SIZE, sink.size());
+    assertEquals(0, bufferedSink.buffer().size());
+  }
+
+  @Test public void bufferedSinkEmitZero() throws IOException {
+    OkBuffer sink = new OkBuffer();
+    BufferedSink bufferedSink = new RealBufferedSink(sink);
+    bufferedSink.writeUtf8("");
+    assertEquals(0, sink.size());
+  }
+
+  @Test public void bufferedSinkEmitMultipleSegments() throws IOException {
+    OkBuffer sink = new OkBuffer();
+    BufferedSink bufferedSink = new RealBufferedSink(sink);
+    bufferedSink.writeUtf8(repeat('a', Segment.SIZE * 4 - 1));
+    assertEquals(Segment.SIZE * 3, sink.size());
+    assertEquals(Segment.SIZE - 1, bufferedSink.buffer().size());
+  }
+
+  @Test public void bufferedSinkFlush() throws IOException {
+    OkBuffer sink = new OkBuffer();
+    BufferedSink bufferedSink = new RealBufferedSink(sink);
+    bufferedSink.writeByte('a');
+    assertEquals(0, sink.size());
+    bufferedSink.flush();
+    assertEquals(0, bufferedSink.buffer().size());
+    assertEquals(1, sink.size());
+  }
+
+  @Test public void bytesEmittedToSinkWithFlush() throws Exception {
+    OkBuffer sink = new OkBuffer();
+    BufferedSink bufferedSink = new RealBufferedSink(sink);
+    bufferedSink.writeUtf8("abc");
+    bufferedSink.flush();
+    assertEquals(3, sink.size());
+  }
+
+  @Test public void bytesNotEmittedToSinkWithoutFlush() throws Exception {
+    OkBuffer sink = new OkBuffer();
+    BufferedSink bufferedSink = new RealBufferedSink(sink);
+    bufferedSink.writeUtf8("abc");
+    assertEquals(0, sink.size());
+  }
+
+  @Test public void completeSegmentsEmitted() throws Exception {
+    OkBuffer sink = new OkBuffer();
+    BufferedSink bufferedSink = new RealBufferedSink(sink);
+    bufferedSink.writeUtf8(repeat('a', Segment.SIZE * 3));
+    assertEquals(Segment.SIZE * 3, sink.size());
+  }
+
+  @Test public void incompleteSegmentsNotEmitted() throws Exception {
+    OkBuffer sink = new OkBuffer();
+    BufferedSink bufferedSink = new RealBufferedSink(sink);
+    bufferedSink.writeUtf8(repeat('a', Segment.SIZE * 3 - 1));
+    assertEquals(Segment.SIZE * 2, sink.size());
+  }
+
+  @Test public void closeEmitsBufferedBytes() throws IOException {
+    OkBuffer sink = new OkBuffer();
+    BufferedSink bufferedSink = new RealBufferedSink(sink);
+    bufferedSink.writeByte('a');
+    bufferedSink.close();
+    assertEquals('a', sink.readByte());
+  }
+
+  @Test public void closeWithExceptionWhenWriting() throws IOException {
+    MockSink mockSink = new MockSink();
+    mockSink.scheduleThrow(0, new IOException());
+    BufferedSink bufferedSink = new RealBufferedSink(mockSink);
+    bufferedSink.writeByte('a');
+    try {
+      bufferedSink.close();
+      fail();
+    } catch (IOException expected) {
+    }
+    mockSink.assertLog("write(OkBuffer[size=1 data=61], 1)", "close()");
+  }
+
+  @Test public void closeWithExceptionWhenClosing() throws IOException {
+    MockSink mockSink = new MockSink();
+    mockSink.scheduleThrow(1, new IOException());
+    BufferedSink bufferedSink = new RealBufferedSink(mockSink);
+    bufferedSink.writeByte('a');
+    try {
+      bufferedSink.close();
+      fail();
+    } catch (IOException expected) {
+    }
+    mockSink.assertLog("write(OkBuffer[size=1 data=61], 1)", "close()");
+  }
+
+  @Test public void closeWithExceptionWhenWritingAndClosing() throws IOException {
+    MockSink mockSink = new MockSink();
+    mockSink.scheduleThrow(0, new IOException("first"));
+    mockSink.scheduleThrow(1, new IOException("second"));
+    BufferedSink bufferedSink = new RealBufferedSink(mockSink);
+    bufferedSink.writeByte('a');
+    try {
+      bufferedSink.close();
+      fail();
+    } catch (IOException expected) {
+      assertEquals("first", expected.getMessage());
+    }
+    mockSink.assertLog("write(OkBuffer[size=1 data=61], 1)", "close()");
+  }
+
+  @Test public void operationsAfterClose() throws IOException {
+    MockSink mockSink = new MockSink();
+    BufferedSink bufferedSink = new RealBufferedSink(mockSink);
+    bufferedSink.writeByte('a');
+    bufferedSink.close();
+
+    // Test a sample set of methods.
+    try {
+      bufferedSink.writeByte('a');
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+
+    try {
+      bufferedSink.write(new byte[10]);
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+
+    try {
+      bufferedSink.emitCompleteSegments();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+
+    try {
+      bufferedSink.flush();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+
+    // Test a sample set of methods on the OutputStream.
+    OutputStream os = bufferedSink.outputStream();
+    try {
+      os.write('a');
+      fail();
+    } catch (IOException expected) {
+    }
+
+    try {
+      os.write(new byte[10]);
+      fail();
+    } catch (IOException expected) {
+    }
+
+    // Permitted
+    os.flush();
+  }
+
+  private String repeat(char c, int count) {
+    char[] array = new char[count];
+    Arrays.fill(array, c);
+    return new String(array);
+  }
+}
diff --git a/okio/src/test/java/okio/RealBufferedSourceReadUtf8LineTest.java b/okio/src/test/java/okio/RealBufferedSourceReadUtf8LineTest.java
new file mode 100644
index 0000000000..8793640b10
--- /dev/null
+++ b/okio/src/test/java/okio/RealBufferedSourceReadUtf8LineTest.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.IOException;
+
+public final class RealBufferedSourceReadUtf8LineTest extends ReadUtf8LineTest {
+  /** Returns a buffered source that gets bytes of {@code data} one at a time. */
+  @Override protected BufferedSource newSource(String s) {
+    final OkBuffer buffer = new OkBuffer().writeUtf8(s);
+
+    Source slowSource = new Source() {
+      @Override public long read(OkBuffer sink, long byteCount) throws IOException {
+        return buffer.read(sink, Math.min(1, byteCount));
+      }
+
+      @Override public Source deadline(Deadline deadline) {
+        throw new UnsupportedOperationException();
+      }
+
+      @Override public void close() throws IOException {
+        throw new UnsupportedOperationException();
+      }
+    };
+
+    return Okio.buffer(slowSource);
+  }
+}
diff --git a/okio/src/test/java/okio/RealBufferedSourceTest.java b/okio/src/test/java/okio/RealBufferedSourceTest.java
new file mode 100644
index 0000000000..a77eaf2805
--- /dev/null
+++ b/okio/src/test/java/okio/RealBufferedSourceTest.java
@@ -0,0 +1,208 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package okio;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Arrays;
+import org.junit.Test;
+
+import static okio.Util.UTF_8;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+public final class RealBufferedSourceTest {
+  @Test public void inputStreamFromSource() throws Exception {
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8("a");
+    source.writeUtf8(repeat('b', Segment.SIZE));
+    source.writeUtf8("c");
+
+    InputStream in = new RealBufferedSource(source).inputStream();
+    assertEquals(0, in.available());
+    assertEquals(Segment.SIZE + 2, source.size());
+
+    // Reading one byte buffers a full segment.
+    assertEquals('a', in.read());
+    assertEquals(Segment.SIZE - 1, in.available());
+    assertEquals(2, source.size());
+
+    // Reading as much as possible reads the rest of that buffered segment.
+    byte[] data = new byte[Segment.SIZE * 2];
+    assertEquals(Segment.SIZE - 1, in.read(data, 0, data.length));
+    assertEquals(repeat('b', Segment.SIZE - 1), new String(data, 0, Segment.SIZE - 1, UTF_8));
+    assertEquals(2, source.size());
+
+    // Continuing to read buffers the next segment.
+    assertEquals('b', in.read());
+    assertEquals(1, in.available());
+    assertEquals(0, source.size());
+
+    // Continuing to read reads from the buffer.
+    assertEquals('c', in.read());
+    assertEquals(0, in.available());
+    assertEquals(0, source.size());
+
+    // Once we've exhausted the source, we're done.
+    assertEquals(-1, in.read());
+    assertEquals(0, source.size());
+  }
+
+  @Test public void inputStreamFromSourceBounds() throws IOException {
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8(repeat('a', 100));
+    InputStream in = new RealBufferedSource(source).inputStream();
+    try {
+      in.read(new byte[100], 50, 51);
+      fail();
+    } catch (ArrayIndexOutOfBoundsException expected) {
+    }
+  }
+
+  @Test public void requireTracksBufferFirst() throws Exception {
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8("bb");
+
+    BufferedSource bufferedSource = new RealBufferedSource(source);
+    bufferedSource.buffer().writeUtf8("aa");
+
+    bufferedSource.require(2);
+    assertEquals(2, bufferedSource.buffer().size());
+    assertEquals(2, source.size());
+  }
+
+  @Test public void requireIncludesBufferBytes() throws Exception {
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8("b");
+
+    BufferedSource bufferedSource = new RealBufferedSource(source);
+    bufferedSource.buffer().writeUtf8("a");
+
+    bufferedSource.require(2);
+    assertEquals("ab", bufferedSource.buffer().readUtf8(2));
+  }
+
+  @Test public void requireInsufficientData() throws Exception {
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8("a");
+
+    BufferedSource bufferedSource = new RealBufferedSource(source);
+
+    try {
+      bufferedSource.require(2);
+      fail();
+    } catch (EOFException expected) {
+    }
+  }
+
+  @Test public void requireReadsOneSegmentAtATime() throws Exception {
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8(repeat('a', Segment.SIZE));
+    source.writeUtf8(repeat('b', Segment.SIZE));
+
+    BufferedSource bufferedSource = new RealBufferedSource(source);
+
+    bufferedSource.require(2);
+    assertEquals(Segment.SIZE, source.size());
+    assertEquals(Segment.SIZE, bufferedSource.buffer().size());
+  }
+
+  @Test public void skipInsufficientData() throws Exception {
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8("a");
+
+    BufferedSource bufferedSource = new RealBufferedSource(source);
+    try {
+      bufferedSource.skip(2);
+      fail();
+    } catch (EOFException expected) {
+    }
+  }
+
+  @Test public void skipReadsOneSegmentAtATime() throws Exception {
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8(repeat('a', Segment.SIZE));
+    source.writeUtf8(repeat('b', Segment.SIZE));
+    BufferedSource bufferedSource = new RealBufferedSource(source);
+    bufferedSource.skip(2);
+    assertEquals(Segment.SIZE, source.size());
+    assertEquals(Segment.SIZE - 2, bufferedSource.buffer().size());
+  }
+
+  @Test public void skipTracksBufferFirst() throws Exception {
+    OkBuffer source = new OkBuffer();
+    source.writeUtf8("bb");
+
+    BufferedSource bufferedSource = new RealBufferedSource(source);
+    bufferedSource.buffer().writeUtf8("aa");
+
+    bufferedSource.skip(2);
+    assertEquals(0, bufferedSource.buffer().size());
+    assertEquals(2, source.size());
+  }
+
+  @Test public void operationsAfterClose() throws IOException {
+    OkBuffer source = new OkBuffer();
+    BufferedSource bufferedSource = new RealBufferedSource(source);
+    bufferedSource.close();
+
+    // Test a sample set of methods.
+    try {
+      bufferedSource.indexOf((byte) 1);
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+
+    try {
+      bufferedSource.skip(1);
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+
+    try {
+      bufferedSource.readByte();
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+
+    try {
+      bufferedSource.readByteString(10);
+      fail();
+    } catch (IllegalStateException expected) {
+    }
+
+    // Test a sample set of methods on the InputStream.
+    InputStream is = bufferedSource.inputStream();
+    try {
+      is.read();
+      fail();
+    } catch (IOException expected) {
+    }
+
+    try {
+      is.read(new byte[10]);
+      fail();
+    } catch (IOException expected) {
+    }
+  }
+
+  private String repeat(char c, int count) {
+    char[] array = new char[count];
+    Arrays.fill(array, c);
+    return new String(array);
+  }
+}
diff --git a/pom.xml b/pom.xml
index bc32950e10..c534a1d3ff 100644
--- a/pom.xml
+++ b/pom.xml
@@ -21,9 +21,12 @@
   <modules>
     <module>okhttp</module>
     <module>okhttp-apache</module>
-    <module>okhttp-protocols</module>
+    <module>okhttp-tests</module>
+    <module>okcurl</module>
+    <module>okio</module>
     <module>mockwebserver</module>
     <module>samples</module>
+    <module>benchmarks</module>
   </modules>
 
   <properties>
@@ -35,9 +38,11 @@
     <bouncycastle.version>1.48</bouncycastle.version>
     <gson.version>2.2.3</gson.version>
     <apache.http.version>4.2.2</apache.http.version>
+    <airlift.version>0.6</airlift.version>
+    <guava.version>16.0</guava.version>
 
     <!-- Test Dependencies -->
-    <junit.version>4.10</junit.version>
+    <junit.version>4.11</junit.version>
   </properties>
 
   <scm>
@@ -86,6 +91,16 @@
         <artifactId>httpclient</artifactId>
         <version>${apache.http.version}</version>
       </dependency>
+      <dependency>
+        <groupId>io.airlift</groupId>
+        <artifactId>airline</artifactId>
+        <version>${airlift.version}</version>
+      </dependency>
+      <dependency>
+        <groupId>com.google.guava</groupId>
+        <artifactId>guava</artifactId>
+        <version>${guava.version}</version>
+      </dependency>
     </dependencies>
   </dependencyManagement>
 
@@ -105,10 +120,17 @@
         <plugin>
           <groupId>org.apache.maven.plugins</groupId>
           <artifactId>maven-surefire-plugin</artifactId>
-          <version>2.9</version>
+          <version>2.16</version>
           <configuration>
             <argLine>-Xbootclasspath/p:${settings.localRepository}/org/mortbay/jetty/npn/npn-boot/${npn.version}/npn-boot-${npn.version}.jar</argLine>
           </configuration>
+          <dependencies>
+            <dependency>
+              <groupId>org.apache.maven.surefire</groupId>
+              <artifactId>surefire-junit47</artifactId>
+              <version>2.16</version>
+            </dependency>
+          </dependencies>
         </plugin>
 
         <plugin>
@@ -116,19 +138,26 @@
           <artifactId>maven-javadoc-plugin</artifactId>
           <version>2.9</version>
         </plugin>
-
-        <plugin>
-          <groupId>org.apache.maven.plugins</groupId>
-          <artifactId>maven-release-plugin</artifactId>
-          <version>2.3.2</version>
-          <configuration>
-            <autoVersionSubmodules>true</autoVersionSubmodules>
-          </configuration>
-        </plugin>
       </plugins>
     </pluginManagement>
 
     <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-release-plugin</artifactId>
+        <version>2.4.2</version>
+        <dependencies>
+          <dependency>
+            <groupId>org.apache.maven.scm</groupId>
+            <artifactId>maven-scm-provider-gitexe</artifactId>
+            <version>1.9</version>
+          </dependency>
+        </dependencies>
+        <configuration>
+          <autoVersionSubmodules>true</autoVersionSubmodules>
+        </configuration>
+      </plugin>
+
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-checkstyle-plugin</artifactId>
@@ -150,7 +179,7 @@
       <plugin>
         <groupId>org.codehaus.mojo</groupId>
         <artifactId>animal-sniffer-maven-plugin</artifactId>
-        <version>1.9</version>
+        <version>1.10</version>
         <executions>
           <execution>
             <phase>test</phase>
diff --git a/samples/crawler/pom.xml b/samples/crawler/pom.xml
new file mode 100644
index 0000000000..0015f7c1d3
--- /dev/null
+++ b/samples/crawler/pom.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
+  <modelVersion>4.0.0</modelVersion>
+
+  <parent>
+    <groupId>com.squareup.okhttp.sample</groupId>
+    <artifactId>sample-parent</artifactId>
+    <version>2.0.0-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>crawler</artifactId>
+  <name>Sample: Crawler</name>
+
+  <dependencies>
+    <dependency>
+      <groupId>com.squareup.okhttp</groupId>
+      <artifactId>okhttp</artifactId>
+      <version>${project.version}</version>
+    </dependency>
+    <dependency>
+      <groupId>org.jsoup</groupId>
+      <artifactId>jsoup</artifactId>
+      <version>1.7.3</version>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java b/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java
new file mode 100644
index 0000000000..d80c13fbb5
--- /dev/null
+++ b/samples/crawler/src/main/java/com/squareup/okhttp/sample/Crawler.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2014 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.squareup.okhttp.sample;
+
+import com.squareup.okhttp.HttpResponseCache;
+import com.squareup.okhttp.MediaType;
+import com.squareup.okhttp.OkHttpClient;
+import com.squareup.okhttp.internal.http.OkHeaders;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.HttpURLConnection;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.nio.charset.Charset;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import org.jsoup.Jsoup;
+import org.jsoup.nodes.Document;
+import org.jsoup.nodes.Element;
+
+/**
+ * Fetches HTML from a requested URL, follows the links, and repeats.
+ */
+public final class Crawler {
+  public static final Charset UTF_8 = Charset.forName("UTF-8");
+
+  private final OkHttpClient client;
+  private final Set<URL> fetchedUrls = Collections.synchronizedSet(new LinkedHashSet<URL>());
+  private final LinkedBlockingQueue<URL> queue = new LinkedBlockingQueue<URL>();
+
+  public Crawler(OkHttpClient client) {
+    this.client = client;
+  }
+
+  private void parallelDrainQueue(int threadCount) {
+    ExecutorService executor = Executors.newFixedThreadPool(threadCount);
+    for (int i = 0; i < threadCount; i++) {
+      executor.execute(new Runnable() {
+        @Override public void run() {
+          try {
+            drainQueue();
+          } catch (Exception e) {
+            e.printStackTrace();
+          }
+        }
+      });
+    }
+    executor.shutdown();
+  }
+
+  private void drainQueue() throws Exception {
+    for (URL url; (url = queue.take()) != null; ) {
+      if (!fetchedUrls.add(url)) {
+        continue;
+      }
+
+      try {
+        fetch(url);
+      } catch (IOException e) {
+        System.out.printf("XXX: %s %s%n", url, e);
+      }
+    }
+  }
+
+  public void fetch(URL url) throws IOException {
+    HttpURLConnection connection = client.open(url);
+    String responseSource = connection.getHeaderField(OkHeaders.RESPONSE_SOURCE);
+    String contentType = connection.getHeaderField("Content-Type");
+    int responseCode = connection.getResponseCode();
+
+    System.out.printf("%03d: %s %s%n", responseCode, url, responseSource);
+
+    if (responseCode >= 400) {
+      connection.getErrorStream().close();
+      return;
+    }
+
+    InputStream in = connection.getInputStream();
+    if (responseCode != 200 || contentType == null) {
+      in.close();
+      return;
+    }
+
+    MediaType mediaType = MediaType.parse(contentType);
+    Document document = Jsoup.parse(in, mediaType.charset(UTF_8).name(), url.toString());
+    for (Element element : document.select("a[href]")) {
+      String href = element.attr("href");
+      URL link = parseUrl(url, href);
+      if (link != null) queue.add(link);
+    }
+
+    in.close();
+  }
+
+  private URL parseUrl(URL url, String href) {
+    try {
+      URL result = new URL(url, href);
+      return result.getProtocol().equals("http") || result.getProtocol().equals("https")
+          ? result
+          : null;
+    } catch (MalformedURLException e) {
+      return null;
+    }
+  }
+
+  public static void main(String[] args) throws IOException {
+    if (args.length != 2) {
+      System.out.println("Usage: Crawler <cache dir> <root>");
+      return;
+    }
+
+    int threadCount = 20;
+    long cacheByteCount = 1024L * 1024L * 100L;
+
+    OkHttpClient client = new OkHttpClient();
+    HttpResponseCache httpResponseCache = new HttpResponseCache(new File(args[0]), cacheByteCount);
+    client.setOkResponseCache(httpResponseCache);
+
+    Crawler crawler = new Crawler(client);
+    crawler.queue.add(new URL(args[1]));
+    crawler.parallelDrainQueue(threadCount);
+  }
+}
diff --git a/samples/pom.xml b/samples/pom.xml
index b212e99d99..62d1240d7e 100644
--- a/samples/pom.xml
+++ b/samples/pom.xml
@@ -16,6 +16,7 @@
 
   <modules>
     <module>guide</module>
+    <module>crawler</module>
     <module>simple-client</module>
     <module>static-server</module>
   </modules>
diff --git a/samples/simple-client/src/main/java/com/squareup/okhttp/sample/OkHttpContributors.java b/samples/simple-client/src/main/java/com/squareup/okhttp/sample/OkHttpContributors.java
index 8969f47236..c6424e2dec 100644
--- a/samples/simple-client/src/main/java/com/squareup/okhttp/sample/OkHttpContributors.java
+++ b/samples/simple-client/src/main/java/com/squareup/okhttp/sample/OkHttpContributors.java
@@ -18,7 +18,7 @@
       new TypeToken<List<Contributor>>() {
       };
 
-  class Contributor {
+  static class Contributor {
     String login;
     int contributions;
   }
diff --git a/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java b/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java
index 274bf9dd48..cb0e24e37a 100644
--- a/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java
+++ b/samples/static-server/src/main/java/com/squareup/okhttp/sample/SampleServer.java
@@ -9,6 +9,7 @@
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
+import java.io.InputStream;
 import java.security.GeneralSecurityException;
 import java.security.KeyStore;
 import java.security.SecureRandom;
@@ -116,8 +117,12 @@ public static void main(String[] args) throws Exception {
   private static SSLContext sslContext(String keystoreFile, String password)
       throws GeneralSecurityException, IOException {
     KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());
-    keystore.load(new FileInputStream(keystoreFile), password.toCharArray());
-
+    InputStream in = new FileInputStream(keystoreFile);
+    try {
+      keystore.load(in, password.toCharArray());
+    } finally {
+      Util.closeQuietly(in);
+    }
     KeyManagerFactory keyManagerFactory =
         KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
     keyManagerFactory.init(keystore, password.toCharArray());
diff --git a/website/index.html b/website/index.html
index 34234edb19..9ed87bb821 100644
--- a/website/index.html
+++ b/website/index.html
@@ -168,7 +168,7 @@ <h3 id="license">License</h3>
               </ul>
               <ul class="nav nav-pills nav-stacked secondary">
                 <li><a href="javadoc/index.html">Javadoc</a></li>
-                <li><a href="https://plus.google.com/communities/109244258569782858265/stream/b6d99838-775f-45a6-a259-af04d42d8639">Google+ Community</a></li>
+                <li><a href="http://stackoverflow.com/questions/tagged/okhttp?sort=active">StackOverflow</a></li>
               </ul>
             </div>
           </div>
@@ -210,8 +210,7 @@ <h3 id="license">License</h3>
         // Look up the latest version of the library.
         $.fn.artifactVersion({
           'groupId': 'com.squareup.okhttp',
-          'artifactId': 'okhttp',
-          'classifier': 'jar-with-dependencies'
+          'artifactId': 'okhttp'
         }, function(version, url) {
           $('.version').text(version);
           $('.version-tag').text('v' + version);
