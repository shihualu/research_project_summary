diff --git a/lib/src/main/java/org/altbeacon/beacon/service/KalmanFilter b/lib/src/main/java/org/altbeacon/beacon/service/KalmanFilter
new file mode 100644
index 00000000..43d49f61
--- /dev/null
+++ b/lib/src/main/java/org/altbeacon/beacon/service/KalmanFilter
@@ -0,0 +1,75 @@
+import org.altbeacon.beacon.service.RssiFilter;
+
+import java.util.ArrayList;
+
+public class KalmanFilter  implements RssiFilter {
+
+    ArrayList<Double> mMeasurements = new ArrayList<Double>();
+    private static final String TAG = "ArmaRssiFilter";
+
+
+    @Override
+    public void addMeasurement(Integer rssi) {
+        mMeasurements.add(Double.valueOf(rssi));
+    }
+
+    @Override
+    public boolean noMeasurementsAvailable() {
+        return mMeasurements.size() == 0;
+    }
+
+    @Override
+    public double calculateRssi() {
+
+        return kalman(mMeasurements);
+    }
+
+    @Override
+    public int getMeasurementCount() {
+        return mMeasurements.size();
+    }
+
+
+
+    public  Double kalman (ArrayList<Double> inputValues, double initialVariance, double noise){
+        return calculate(inputValues, initialVariance, noise);
+    }
+
+    /* Calculation of Kalman Filter using default values for wireless Access Points data acquisition */
+    public  Double kalman (ArrayList<Double> inputValues){
+        return calculate(inputValues, 50.0, 0.008);
+    }
+
+    /* Calculation of arithmetic mean */
+    public  Double mean (ArrayList<Double> inputValues){
+        return StatUtils.mean(inputValues);
+    }
+
+
+    /*This method is the responsible for calculating the value refined with Kalman Filter */
+    private  Double calculate(ArrayList<Double> inputValues, double initialVariance, double noise){
+        Double kalmanGain;
+        Double variance = initialVariance;
+        Double processNoise = noise;
+        Double measurementNoise = StatUtils.variance(inputValues);
+        Double mean = inputValues.get(0);
+
+        for (Double value : inputValues){
+            variance = variance + processNoise;
+            kalmanGain = variance/((variance+measurementNoise));
+            mean = mean + kalmanGain*(value - mean);
+            variance = variance - (kalmanGain*variance);
+        }
+
+        refreshMeasurements();
+
+        return mean;
+    }
+    private void refreshMeasurements() {
+
+        mMeasurements.clear();
+    }
+
+
+
+}
