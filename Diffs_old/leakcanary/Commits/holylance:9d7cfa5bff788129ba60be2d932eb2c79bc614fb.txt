diff --git a/.github/workflows/greetings.yml b/.github/workflows/greetings.yml
new file mode 100644
index 00000000..4ed1a9a8
--- /dev/null
+++ b/.github/workflows/greetings.yml
@@ -0,0 +1,13 @@
+name: Greetings
+
+on: [pull_request, issues]
+
+jobs:
+  greeting:
+    runs-on: ubuntu-latest
+    steps:
+    - uses: actions/first-interaction@v1
+      with:
+        repo-token: ${{ secrets.GITHUB_TOKEN }}
+        issue-message: 'ðŸ™Thank you for opening an issue! LeakCanary is maintained by @pyricau with help from the community. Please be kind and remember that LeakCanary isn''t anyone''s main job ðŸ˜˜.'
+        pr-message: 'ðŸ™Thank you for your contribution! @pyricau will take a look ðŸ”Ž. Depending on his availability that might take a while ðŸ˜´, but don''t worry, your pull request will not be ignored.'
diff --git a/.travis.yml b/.travis.yml
index ee5ea2c7..950dee62 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -16,7 +16,11 @@ before_install:
   - echo no | avdmanager create avd --force -n test -k "system-images;android-16;default;armeabi-v7a"
   - $ANDROID_HOME/emulator/emulator -avd test -no-audio -no-window &
 
-install: ./gradlew clean build assembleAndroidTest --stacktrace
+install:
+  #Run tasks in sequence so that Gradle doesn't run 'clean' in parallel with 'build'
+  - ./gradlew clean
+  - ./gradlew build --stacktrace
+  - ./gradlew assembleAndroidTest --stacktrace
 
 before_script:
   - android-wait-for-emulator
diff --git a/docs/fundamentals.md b/docs/fundamentals.md
index 16597889..ba6771bb 100644
--- a/docs/fundamentals.md
+++ b/docs/fundamentals.md
@@ -235,3 +235,4 @@ LeakCanary is released as several libraries:
 * LeakCanary Android separate process
 	* Enables running LeakCanary separately from the main app process.
 	* Artifact id: `com.squareup.leakcanary:leakcanary-android-process` (as a replacement for `com.squareup.leakcanary:leakcanary-android`).
+	* See [Running the LeakCanary analysis in a separate process](recipes.md#running-the-leakcanary-analysis-in-a-separate-process).
diff --git a/docs/recipes.md b/docs/recipes.md
index e7390104..1f549f67 100644
--- a/docs/recipes.md
+++ b/docs/recipes.md
@@ -244,6 +244,21 @@ class DebugExampleApplication : ExampleApplication() {
 }
 ```
 
+## Running the LeakCanary analysis in a separate process
+
+LeakCanary runs in your main app process. LeakCanary 2 is optimized to keep memory usage low while analysing and runs in a background thread with priority `Process.THREAD_PRIORITY_BACKGROUND`. If you find that LeakCanary is still using too much memory or impacting the app process performance, you can configure it to run the analysis in a separate process.
+
+All you have to do is replace the `leakcanary-android` depedency with `leakcanary-android-process`:
+
+```groovy
+dependencies {
+  // debugImplementation 'com.squareup.leakcanary:leakcanary-android:${version}'
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android-process:${version}'
+}
+```
+
+You can call [LeakCanaryProcess.isInAnalyzerProcess](/leakcanary/api/leakcanary-android-process/leakcanary/-leak-canary-process/is-in-analyzer-process/) to check if your Application class is being created in the LeakCanary process. This is useful when configuring libraries like Firebase that may crash when running in an unexpected process.
+
 ## Setting up LeakCanary for different product flavors
 
 You can setup LeakCanary to run in a specific product flavors of your app. For example, create:
diff --git a/gradle.properties b/gradle.properties
index 3e75d3bd..2b06e649 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -16,3 +16,8 @@ POM_DEVELOPER_ID=square
 POM_DEVELOPER_NAME=Square, Inc.
 
 android.useAndroidX=true
+
+#Gradle properties: https://docs.gradle.org/current/userguide/build_environment.html
+org.gradle.caching=true
+org.gradle.configureondemand=true
+org.gradle.parallel=true
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
index ee69dd68..ca9d6281 100644
--- a/gradle/wrapper/gradle-wrapper.properties
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -1,5 +1,5 @@
 distributionBase=GRADLE_USER_HOME
 distributionPath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-5.4.1-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-5.6.2-all.zip
 zipStoreBase=GRADLE_USER_HOME
 zipStorePath=wrapper/dists
diff --git a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
index d1137c82..6ef368ed 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
@@ -9,6 +9,7 @@ import shark.IgnoredReferenceMatcher
 import shark.LibraryLeakReferenceMatcher
 import shark.ObjectInspector
 import shark.ReferenceMatcher
+import shark.SharkLog
 
 /**
  * The entry point API for LeakCanary. LeakCanary builds on top of [AppWatcher]. AppWatcher
@@ -145,6 +146,10 @@ object LeakCanary {
    */
   @Volatile
   var config: Config = if (AppWatcher.isInstalled) Config() else InternalLeakCanary.noInstallConfig
+    set(value) {
+      field = value
+      SharkLog.d { "Updated LeakCanary.config to $value" }
+    }
 
   /**
    * Returns a new [Intent] that can be used to programmatically launch the leak display activity.
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ProfiledTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ProfiledTest.kt
index a102ba22..6ef22468 100644
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ProfiledTest.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/ProfiledTest.kt
@@ -30,7 +30,7 @@ class ProfiledTest {
         .copyTo(FileOutputStream(heapDumpFile))
 
     SharkLog.d { "Waiting, please start profiler" }
-    Thread.sleep(20000)
+    Profiler.waitForSamplingStart()
 
     val analyzer = HeapAnalyzer(object : OnAnalysisProgressListener {
       override fun onAnalysisProgress(step: Step) {
@@ -46,7 +46,7 @@ class ProfiledTest {
     )
     SharkLog.d { result.toString() }
     // Giving time to stop CPU profiler (otherwise trace won't succeed)
-    Thread.sleep(20000)
+    Profiler.waitForSamplingStop()
   }
 
 }
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/Profiler.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/Profiler.kt
new file mode 100644
index 00000000..9c053c31
--- /dev/null
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/Profiler.kt
@@ -0,0 +1,59 @@
+package leakcanary
+
+import shark.SharkLog
+
+/**
+ * Helper class for working with Android Studio's Profiler
+ */
+internal object Profiler {
+  private const val SLEEP_TIME_MILLIS = 1000L
+  private const val SAMPLING_THREAD_NAME = "Sampling Profiler"
+
+  /**
+   * Wait until Profiler is attached and CPU Sampling is started.
+   * Calling this on main thread can lead to ANR if you try to interact with UI while it's waiting for
+   * profiler.
+   * Note: only works with 'Sample Java Methods' profiling, won't work with 'Trace Java Methods'!
+   */
+  fun waitForSamplingStart() {
+    SharkLog.d { "Waiting for sampling to start. Go to Profiler -> CPU -> Record" }
+    sleepUntil { samplingThreadExists() }
+    Thread.sleep(SLEEP_TIME_MILLIS) //Wait a bit more to ensure profiler started sampling
+    SharkLog.d { "Sampling started! Proceeding..." }
+  }
+
+
+  /**
+   * Wait until CPU Sampling stops.
+   * Calling this on main thread can lead to ANR if you try to interact with UI while it's waiting for
+   * profiler.
+   */
+  fun waitForSamplingStop() {
+    SharkLog.d { "Waiting for sampling to stop. Go to Profiler -> CPU -> Stop recording" }
+    sleepUntil { !samplingThreadExists() }
+    SharkLog.d { "Sampling stopped! Proceeding..." }
+  }
+
+  private inline fun sleepUntil(condition: () -> Boolean) {
+    while (true) {
+      if (condition()) return else Thread.sleep(SLEEP_TIME_MILLIS)
+    }
+  }
+
+  private fun samplingThreadExists() = findThread(SAMPLING_THREAD_NAME) != null
+
+  /**
+   * Utility to get thread by its name; in case of multiple matches first one will be returned.
+   */
+  private fun findThread(threadName: String): Thread? {
+    // Based on https://stackoverflow.com/a/1323480
+    var rootGroup = Thread.currentThread().threadGroup
+    while (rootGroup.parent != null) rootGroup = rootGroup.parent
+
+    var threads = arrayOfNulls<Thread>(rootGroup.activeCount())
+    while (rootGroup.enumerate(threads, true) == threads.size) {
+      threads = arrayOfNulls(threads.size * 2)
+    }
+    return threads.firstOrNull { it?.name == threadName }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-android-process/src/main/AndroidManifest.xml b/leakcanary-android-process/src/main/AndroidManifest.xml
index 59728db4..6e787bc8 100644
--- a/leakcanary-android-process/src/main/AndroidManifest.xml
+++ b/leakcanary-android-process/src/main/AndroidManifest.xml
@@ -21,13 +21,13 @@
     <service
         android:name="leakcanary.internal.HeapAnalyzerService"
         android:exported="false"
-        android:process=":leakcanary"
-        >
-      <intent-filter>
-        <action android:name="leakcanary.ANALYSIS_ACTION"/>
-      </intent-filter>
-    </service>
+        android:process=":leakcanary" />
 
+    <provider
+        android:name="leakcanary.internal.AppWatcherInstaller$LeakCanaryProcess"
+        android:authorities="${applicationId}.leakcanary-process.installer"
+        android:process=":leakcanary"
+        android:exported="false"/>
   </application>
 
 </manifest>
diff --git a/leakcanary-android/src/main/AndroidManifest.xml b/leakcanary-android/src/main/AndroidManifest.xml
index 0ee35e1c..7ad651e4 100644
--- a/leakcanary-android/src/main/AndroidManifest.xml
+++ b/leakcanary-android/src/main/AndroidManifest.xml
@@ -20,13 +20,7 @@
   <application>
     <service
         android:name="leakcanary.internal.HeapAnalyzerService"
-        android:exported="false"
-        >
-      <intent-filter>
-        <action android:name="leakcanary.ANALYSIS_ACTION"/>
-      </intent-filter>
-    </service>
-
+        android:exported="false" />
   </application>
 
 </manifest>
diff --git a/leakcanary-object-watcher-android/src/main/AndroidManifest.xml b/leakcanary-object-watcher-android/src/main/AndroidManifest.xml
index db08981e..aa51d7c5 100644
--- a/leakcanary-object-watcher-android/src/main/AndroidManifest.xml
+++ b/leakcanary-object-watcher-android/src/main/AndroidManifest.xml
@@ -6,7 +6,7 @@
 
   <application>
     <provider
-        android:name="leakcanary.internal.AppWatcherInstaller"
+        android:name="leakcanary.internal.AppWatcherInstaller$MainProcess"
         android:authorities="${applicationId}.leakcanary-installer"
         android:exported="false"/>
   </application>
diff --git a/leakcanary-object-watcher-android/src/main/java/leakcanary/AppWatcher.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/AppWatcher.kt
index 0aa035a5..2e6e7aaa 100644
--- a/leakcanary-object-watcher-android/src/main/java/leakcanary/AppWatcher.kt
+++ b/leakcanary-object-watcher-android/src/main/java/leakcanary/AppWatcher.kt
@@ -1,9 +1,9 @@
 package leakcanary
 
 import android.app.Application
-import leakcanary.AppWatcher.config
 import leakcanary.AppWatcher.objectWatcher
 import leakcanary.internal.InternalAppWatcher
+import shark.SharkLog
 import java.util.concurrent.TimeUnit
 
 /**
@@ -61,6 +61,10 @@ object AppWatcher {
    */
   @Volatile
   var config: Config = if (isInstalled) Config() else Config(enabled = false)
+    set(value) {
+      field = value
+      SharkLog.d { "Updated AppWatcher.config to $value" }
+    }
 
   /**
    * The [ObjectWatcher] used by AppWatcher to detect retained objects.
diff --git a/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/AppWatcherInstaller.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/AppWatcherInstaller.kt
index 325e21ae..95b0f544 100644
--- a/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/AppWatcherInstaller.kt
+++ b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/AppWatcherInstaller.kt
@@ -5,16 +5,32 @@ import android.content.ContentProvider
 import android.content.ContentValues
 import android.database.Cursor
 import android.net.Uri
-import shark.SharkLog
+import leakcanary.AppWatcher
 
 /**
  * Content providers are loaded before the application class is created. [AppWatcherInstaller] is
  * used to install [leakcanary.AppWatcher] on application start.
  */
-internal class AppWatcherInstaller : ContentProvider() {
+internal sealed class AppWatcherInstaller : ContentProvider() {
+
+  /**
+   * [MainProcess] automatically sets up the LeakCanary code that runs in the main app process.
+   */
+  internal class MainProcess : AppWatcherInstaller()
+
+  /**
+   * When using the `leakcanary-android-process` artifact instead of `leakcanary-android`,
+   * [LeakCanaryProcess] automatically sets up the LeakCanary code
+   */
+  internal class LeakCanaryProcess : AppWatcherInstaller() {
+    override fun onCreate(): Boolean {
+      super.onCreate()
+      AppWatcher.config = AppWatcher.config.copy(enabled = false)
+      return true
+    }
+  }
 
   override fun onCreate(): Boolean {
-    SharkLog.logger = DefaultCanaryLog()
     val application = context!!.applicationContext as Application
     InternalAppWatcher.install(application)
     return true
diff --git a/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/InternalAppWatcher.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/InternalAppWatcher.kt
index ec5f1170..578e28ad 100644
--- a/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/InternalAppWatcher.kt
+++ b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/InternalAppWatcher.kt
@@ -57,6 +57,7 @@ internal object InternalAppWatcher {
   )
 
   fun install(application: Application) {
+    SharkLog.logger = DefaultCanaryLog()
     SharkLog.d { "Installing AppWatcher" }
     checkMainThread()
     if (this::application.isInitialized) {
diff --git a/settings.gradle b/settings.gradle
index fd798995..51e7d44d 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -12,3 +12,4 @@ include ':shark-cli'
 include ':shark-graph'
 include ':shark-hprof'
 include ':shark-log'
+include ':shark-test'
diff --git a/shark-graph/build.gradle b/shark-graph/build.gradle
index 257db8e0..ce649ba5 100644
--- a/shark-graph/build.gradle
+++ b/shark-graph/build.gradle
@@ -12,6 +12,7 @@ dependencies {
 
   testImplementation deps.assertj_core
   testImplementation deps.junit
+  testImplementation project(':shark-test')
 }
 
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/shark-hprof/build.gradle b/shark-hprof/build.gradle
index 5698b219..64a64587 100644
--- a/shark-hprof/build.gradle
+++ b/shark-hprof/build.gradle
@@ -12,6 +12,7 @@ dependencies {
 
   testImplementation deps.assertj_core
   testImplementation deps.junit
+  testImplementation project(':shark-test')
 }
 
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/shark-hprof/src/test/java/HprofReaderPrimitiveArrayTest.kt b/shark-hprof/src/test/java/shark/HprofReaderPrimitiveArrayTest.kt
similarity index 84%
rename from shark-hprof/src/test/java/HprofReaderPrimitiveArrayTest.kt
rename to shark-hprof/src/test/java/shark/HprofReaderPrimitiveArrayTest.kt
index 10fb7616..4810b932 100644
--- a/shark-hprof/src/test/java/HprofReaderPrimitiveArrayTest.kt
+++ b/shark-hprof/src/test/java/shark/HprofReaderPrimitiveArrayTest.kt
@@ -1,9 +1,8 @@
+package shark
+
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Rule
 import org.junit.Test
-import shark.Hprof
-import shark.HprofRecord
-import shark.OnHprofRecordListener
 import kotlin.text.Charsets.UTF_8
 
 class HprofReaderPrimitiveArrayTest {
@@ -24,7 +23,9 @@ class HprofReaderPrimitiveArrayTest {
 
     @Test
     fun reads_primitive_arrays_correctly() {
-        val byteArray = "mybytes".toByteArray(UTF_8)
+        val byteArray = ("Sharks also have a sensory organ called the \"ampullae of Lorenzini\" " +
+                         "which they use to \"feel\" the electrical field coming from its prey.")
+                .toByteArray(UTF_8)
 
         val heapDump = heapDumpRule.dumpHeap()
 
diff --git a/shark-test/build.gradle b/shark-test/build.gradle
new file mode 100644
index 00000000..3e527c9c
--- /dev/null
+++ b/shark-test/build.gradle
@@ -0,0 +1,12 @@
+apply plugin: 'java-library'
+apply plugin: 'kotlin'
+
+sourceCompatibility = JavaVersion.VERSION_1_7
+targetCompatibility = JavaVersion.VERSION_1_7
+
+dependencies {
+    implementation deps.kotlin.stdlib
+    implementation deps.assertj_core
+    implementation deps.junit
+}
+
diff --git a/shark-hprof/src/test/java/HeapDumpRule.kt b/shark-test/src/main/kotlin/shark/HeapDumpRule.kt
similarity index 59%
rename from shark-hprof/src/test/java/HeapDumpRule.kt
rename to shark-test/src/main/kotlin/shark/HeapDumpRule.kt
index bafd457e..89abd305 100644
--- a/shark-hprof/src/test/java/HeapDumpRule.kt
+++ b/shark-test/src/main/kotlin/shark/HeapDumpRule.kt
@@ -1,10 +1,9 @@
-import com.sun.management.HotSpotDiagnosticMXBean
+package shark
+
 import org.junit.rules.ExternalResource
 import org.junit.rules.TemporaryFolder
-
 import java.io.File
 import java.io.IOException
-import java.lang.management.ManagementFactory
 import java.util.UUID
 
 class HeapDumpRule : ExternalResource() {
@@ -21,13 +20,8 @@ class HeapDumpRule : ExternalResource() {
 
     @Throws(IOException::class)
     fun dumpHeap(): File {
-        val hotSpotDiag = ManagementFactory.newPlatformMXBeanProxy(
-                ManagementFactory.getPlatformMBeanServer(),
-                "com.sun.management:type=HotSpotDiagnostic",
-                HotSpotDiagnosticMXBean::class.java
-        )
         val hprof = File(temporaryFolder.root, "heapDump" + UUID.randomUUID() + ".hprof")
-        hotSpotDiag.dumpHeap(hprof.absolutePath, true)
+        JvmTestHeapDumper.dumpHeap(hprof.absolutePath)
         return hprof
     }
 }
diff --git a/shark-graph/src/test/java/shark/JvmTestHeapDumper.kt b/shark-test/src/main/kotlin/shark/JvmTestHeapDumper.kt
similarity index 100%
rename from shark-graph/src/test/java/shark/JvmTestHeapDumper.kt
rename to shark-test/src/main/kotlin/shark/JvmTestHeapDumper.kt
diff --git a/shark/src/main/java/shark/internal/PathFinder.kt b/shark/src/main/java/shark/internal/PathFinder.kt
index 30bb3bfe..aeb344b8 100644
--- a/shark/src/main/java/shark/internal/PathFinder.kt
+++ b/shark/src/main/java/shark/internal/PathFinder.kt
@@ -329,13 +329,7 @@ internal class PathFinder(
         .filter { gcRoot ->
           // GC roots sometimes reference objects that don't exist in the heap dump
           // See https://github.com/square/leakcanary/issues/1516
-          val objectExists = graph.objectExists(gcRoot.id)
-          if (!objectExists) {
-            SharkLog.d {
-              "${gcRoot::class.java.simpleName} gc root ignored because it's pointing to unknown object @${gcRoot.id}"
-            }
-          }
-          objectExists
+          graph.objectExists(gcRoot.id)
         }
         .map { graph.findObjectById(it.id) to it }
         .sortedWith(Comparator { (graphObject1, root1), (graphObject2, root2) ->
@@ -449,13 +443,7 @@ internal class PathFinder(
   ) {
     val record = objectArray.readRecord()
     val nonNullElementIds = record.elementIds.filter { objectId ->
-      objectId != ValueHolder.NULL_REFERENCE && graph.objectExists(objectId).apply {
-        if (!this) {
-          // dalvik.system.PathClassLoader.runtimeInternalObjects references objects which don't
-          // otherwise exist in the heap dump.
-          SharkLog.d { "Invalid Hprof? Found unknown object id $objectId" }
-        }
-      }
+      objectId != ValueHolder.NULL_REFERENCE && graph.objectExists(objectId)
     }
     nonNullElementIds.forEachIndexed { index, elementId ->
       if (computeRetainedHeapSize) {
