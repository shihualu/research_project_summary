diff --git a/build.gradle b/build.gradle
index a0a51484..74017215 100644
--- a/build.gradle
+++ b/build.gradle
@@ -5,7 +5,7 @@ buildscript {
       'minSdk'    : 14,
       'compileSdk': 29,
       'errorProne': '2.3.1',
-      'kotlin'    : '1.3.21',
+      'kotlin'    : '1.3.50',
   ]
   ext.deps = [
       assertj_core  : 'org.assertj:assertj-core:3.9.1',
@@ -29,6 +29,7 @@ buildscript {
           gradlePlugin: "org.jetbrains.kotlin:kotlin-gradle-plugin:${versions.kotlin}",
           stdlib      : "org.jetbrains.kotlin:kotlin-stdlib:${versions.kotlin}"
       ],
+      detekt        : 'io.gitlab.arturbosch.detekt:detekt-gradle-plugin:1.0.0-RC16',
       mockito       : 'org.mockito:mockito-core:2.7.5',
       mockito_kotlin: 'com.nhaarman:mockito-kotlin-kt1.1:1.5.0',
       okio: 'com.squareup.okio:okio:2.2.2',
@@ -41,10 +42,11 @@ buildscript {
   }
   dependencies {
     classpath deps.kotlin.gradlePlugin
-    classpath 'com.android.tools.build:gradle:3.4.2'
+    classpath 'com.android.tools.build:gradle:3.5.0'
     classpath 'net.ltgt.gradle:gradle-errorprone-plugin:0.0.16'
     classpath 'com.github.ben-manes:gradle-versions-plugin:0.20.0'
     classpath "org.jetbrains.dokka:dokka-gradle-plugin:0.9.18"
+    classpath deps.detekt
   }
 }
 
@@ -63,6 +65,7 @@ subprojects {
 
   apply plugin: 'net.ltgt.errorprone'
   apply plugin: 'org.jetbrains.dokka'
+  apply plugin: 'io.gitlab.arturbosch.detekt'
 
   dokka {
     reportUndocumented = false
@@ -115,6 +118,18 @@ subprojects {
     }
   }
 
+  detekt {
+    config = rootProject.files('detekt-config.yml')
+    parallel = true
+    reports {
+      xml.enabled = false
+    }
+  }
+
+  afterEvaluate {
+    project.tasks.getByName('check').dependsOn 'detekt'
+  }
+
   dependencies {
     errorprone "com.google.errorprone:error_prone_core:${versions.errorProne}"
   }
diff --git a/checkstyle.xml b/checkstyle.xml
deleted file mode 100644
index ce09c3d1..00000000
--- a/checkstyle.xml
+++ /dev/null
@@ -1,150 +0,0 @@
-<?xml version="1.0"?>
-<!--
-  Copyright (C) 2014 Square, Inc.
-
-  Licensed under the Apache License, Version 2.0 (the "License");
-  you may not use this file except in compliance with the License.
-  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
-  -->
-<!DOCTYPE module PUBLIC
-    "-//Puppy Crawl//DTD Check Configuration 1.2//EN"
-    "http://www.puppycrawl.com/dtds/configuration_1_2.dtd">
-
-<module name="Checker">
-  <!--module name="NewlineAtEndOfFile"/-->
-  <module name="FileLength"/>
-  <module name="FileTabCharacter"/>
-
-  <!-- Trailing spaces -->
-  <module name="RegexpSingleline">
-    <property name="format" value="\s+$"/>
-    <property name="message" value="Line has trailing spaces."/>
-  </module>
-
-  <!-- Space after 'for' and 'if' -->
-  <module name="RegexpSingleline">
-    <property name="format" value="^\s*(for|if)[^ ]"/>
-    <property name="message" value="Space needed before opening parenthesis."/>
-  </module>
-
-  <!-- For each spacing -->
-  <module name="RegexpSingleline">
-    <property name="format" value="^\s*for \(.*?([^ ]:|:[^ ])"/>
-    <property name="message" value="Space needed around ':' character."/>
-  </module>
-
-  <module name="TreeWalker">
-    <!-- Checks for Javadoc comments.                     -->
-    <!-- See http://checkstyle.sf.net/config_javadoc.html -->
-    <!--module name="JavadocMethod"/-->
-    <!--module name="JavadocType"/-->
-    <!--module name="JavadocVariable"/-->
-    <!--module name="JavadocStyle"/-->
-
-
-    <!-- Checks for Naming Conventions.                  -->
-    <!-- See http://checkstyle.sf.net/config_naming.html -->
-    <!--<module name="ConstantName"/>-->
-    <module name="LocalFinalVariableName"/>
-    <module name="LocalVariableName"/>
-    <module name="MemberName"/>
-    <module name="MethodName">
-      <property name="format" value="^[a-z][a-zA-Z0-9_]*$"/>
-    </module>
-    <module name="PackageName"/>
-    <module name="ParameterName"/>
-    <module name="StaticVariableName"/>
-    <module name="TypeName">
-      <property name="format" value="^[A-Z][a-zA-Z0-9_]*$"/>
-    </module>
-
-
-    <!-- Checks for imports                              -->
-    <!-- See http://checkstyle.sf.net/config_import.html -->
-    <module name="AvoidStarImport"/>
-    <module name="IllegalImport"/>
-    <module name="RedundantImport"/>
-    <module name="UnusedImports">
-      <property name="processJavadoc" value="true"/>
-    </module>
-
-
-    <!-- Checks for Size Violations.                    -->
-    <!-- See http://checkstyle.sf.net/config_sizes.html -->
-    <!--module name="LineLength"-->
-      <!--property name="max" value="100"/-->
-    <!--/module-->
-    <!--module name="MethodLength"/-->
-    <!--<module name="ParameterNumber"/>-->
-
-
-    <!-- Checks for whitespace                               -->
-    <!-- See http://checkstyle.sf.net/config_whitespace.html -->
-    <module name="GenericWhitespace"/>
-    <module name="EmptyForIteratorPad"/>
-    <module name="MethodParamPad"/>
-    <!--<module name="NoWhitespaceAfter"/>-->
-    <!--<module name="NoWhitespaceBefore"/>-->
-    <module name="OperatorWrap"/>
-    <module name="ParenPad"/>
-    <module name="TypecastParenPad"/>
-    <module name="WhitespaceAfter"/>
-    <module name="WhitespaceAround"/>
-
-
-    <!-- Modifier Checks                                    -->
-    <!-- See http://checkstyle.sf.net/config_modifiers.html -->
-    <!--module name="ModifierOrder"/-->
-    <module name="RedundantModifier"/>
-
-
-    <!-- Checks for blocks. You know, those {}'s         -->
-    <!-- See http://checkstyle.sf.net/config_blocks.html -->
-    <!--module name="AvoidNestedBlocks"/-->
-    <!--module name="EmptyBlock"/-->
-    <module name="LeftCurly"/>
-    <module name="NeedBraces"/>
-    <module name="RightCurly"/>
-
-
-    <!-- Checks for common coding problems               -->
-    <!-- See http://checkstyle.sf.net/config_coding.html -->
-    <!--module name="AvoidInlineConditionals"/-->
-    <module name="CovariantEquals"/>
-    <module name="EmptyStatement"/>
-    <!--module name="EqualsAvoidNull"/-->
-    <module name="EqualsHashCode"/>
-    <!--module name="HiddenField"/-->
-    <module name="IllegalInstantiation"/>
-    <!--<module name="InnerAssignment"/>-->
-    <!--module name="MagicNumber"/-->
-    <module name="MissingSwitchDefault"/>
-    <!--module name="RedundantThrows"/-->
-    <module name="SimplifyBooleanExpression"/>
-    <module name="SimplifyBooleanReturn"/>
-
-    <!-- Checks for class design                         -->
-    <!-- See http://checkstyle.sf.net/config_design.html -->
-    <!--module name="DesignForExtension"/-->
-    <!--module name="FinalClass"/-->
-    <module name="HideUtilityClassConstructor"/>
-    <!--module name="InterfaceIsType"/-->
-    <!--module name="VisibilityModifier"/-->
-
-
-    <!-- Miscellaneous other checks.                   -->
-    <!-- See http://checkstyle.sf.net/config_misc.html -->
-    <module name="ArrayTypeStyle"/>
-    <!--module name="FinalParameters"/-->
-    <!--module name="TodoComment"/-->
-    <module name="UpperEll"/>
-  </module>
-</module>
diff --git a/detekt-config.yml b/detekt-config.yml
new file mode 100644
index 00000000..b55d3d68
--- /dev/null
+++ b/detekt-config.yml
@@ -0,0 +1,564 @@
+build:
+  maxIssues: 1
+  weights:
+    # complexity: 2
+    # LongParameterList: 1
+    # style: 1
+    # comments: 1
+
+processors:
+  active: true
+  exclude:
+  # - 'FunctionCountProcessor'
+  # - 'PropertyCountProcessor'
+  # - 'ClassCountProcessor'
+  # - 'PackageCountProcessor'
+  # - 'KtFileCountProcessor'
+
+console-reports:
+  active: true
+  exclude:
+  #  - 'ProjectStatisticsReport'
+  #  - 'ComplexityReport'
+  #  - 'NotificationReport'
+  #  - 'FindingsReport'
+  #  - 'BuildFailureReport'
+
+comments:
+  active: true
+  excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+  CommentOverPrivateFunction:
+    active: false
+  CommentOverPrivateProperty:
+    active: false
+  EndOfSentenceFormat:
+    active: false
+    endOfSentenceFormat: ([.?!][ \t\n\r\f<])|([.?!:]$)
+  UndocumentedPublicClass:
+    active: false
+    searchInNestedClass: true
+    searchInInnerClass: true
+    searchInInnerObject: true
+    searchInInnerInterface: true
+  UndocumentedPublicFunction:
+    active: false
+
+complexity:
+  active: true
+  ComplexCondition:
+    active: true
+    threshold: 4
+  ComplexInterface:
+    active: false
+    threshold: 10
+    includeStaticDeclarations: false
+  ComplexMethod:
+    #LeakCanary - increased allowed complexity from 10 to 30; enabled ignores
+    active: true
+    threshold: 30
+    ignoreSingleWhenExpression: true
+    ignoreSimpleWhenEntries: true
+  LabeledExpression:
+    active: false
+    ignoredLabels: ""
+  LargeClass:
+    active: true
+    threshold: 600
+  LongMethod:
+    #LeakCanary - increased from 60 to 90
+    active: true
+    threshold: 90
+  LongParameterList:
+    #LeakCanary - enabled ignore
+    active: true
+    threshold: 6
+    ignoreDefaultParameters: true
+  MethodOverloading:
+    active: false
+    threshold: 6
+  NestedBlockDepth:
+    #LeakCanary - increased from 4 to 7
+    active: true
+    threshold: 7
+  StringLiteralDuplication:
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    threshold: 3
+    ignoreAnnotation: true
+    excludeStringsWithLessThan5Characters: true
+    ignoreStringsRegex: '$^'
+  TooManyFunctions:
+    #LeakCanary - increased from 11 to 12
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    thresholdInFiles: 12
+    thresholdInClasses: 12
+    thresholdInInterfaces: 12
+    thresholdInObjects: 12
+    thresholdInEnums: 12
+    ignoreDeprecated: false
+    ignorePrivate: false
+    ignoreOverridden: false
+
+empty-blocks:
+  active: true
+  EmptyCatchBlock:
+    active: true
+    allowedExceptionNameRegex: "^(_|(ignore|expected).*)"
+  EmptyClassBlock:
+    active: true
+  EmptyDefaultConstructor:
+    active: true
+  EmptyDoWhileBlock:
+    active: true
+  EmptyElseBlock:
+    active: true
+  EmptyFinallyBlock:
+    active: true
+  EmptyForBlock:
+    active: true
+  EmptyFunctionBlock:
+    #LeakCanary - allow empty overridden functions
+    active: true
+    ignoreOverriddenFunctions: true
+  EmptyIfBlock:
+    active: true
+  EmptyInitBlock:
+    active: true
+  EmptyKtFile:
+    active: true
+  EmptySecondaryConstructor:
+    active: true
+  EmptyWhenBlock:
+    active: true
+  EmptyWhileBlock:
+    active: true
+
+exceptions:
+  active: true
+  ExceptionRaisedInUnexpectedLocation:
+    active: false
+    methodNames: 'toString,hashCode,equals,finalize'
+  InstanceOfCheckForException:
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+  NotImplementedDeclaration:
+    active: false
+  PrintStackTrace:
+    active: false
+  RethrowCaughtException:
+    active: false
+  ReturnFromFinally:
+    active: false
+  SwallowedException:
+    active: false
+    ignoredExceptionTypes: 'InterruptedException,NumberFormatException,ParseException,MalformedURLException'
+  ThrowingExceptionFromFinally:
+    active: false
+  ThrowingExceptionInMain:
+    active: false
+  ThrowingExceptionsWithoutMessageOrCause:
+    active: false
+    exceptions: 'IllegalArgumentException,IllegalStateException,IOException'
+  ThrowingNewInstanceOfSameException:
+    active: false
+  TooGenericExceptionCaught:
+    #LeakCanary - disabled
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    exceptionNames:
+     - ArrayIndexOutOfBoundsException
+     - Error
+     - Exception
+     - IllegalMonitorStateException
+     - NullPointerException
+     - IndexOutOfBoundsException
+     - RuntimeException
+     - Throwable
+    allowedExceptionNameRegex: "^(_|(ignore|expected).*)"
+  TooGenericExceptionThrown:
+    #LeakCanary - disabled
+    active: false
+    exceptionNames:
+     - Error
+     - Exception
+     - Throwable
+     - RuntimeException
+
+formatting:
+  active: true
+  android: false
+  autoCorrect: true
+  AnnotationOnSeparateLine:
+    active: false
+  ChainWrapping:
+    active: true
+    autoCorrect: true
+  CommentSpacing:
+    active: true
+    autoCorrect: true
+  Filename:
+    active: true
+  FinalNewline:
+    active: true
+    autoCorrect: true
+  ImportOrdering:
+    active: false
+  Indentation:
+    active: false
+    indentSize: 4
+    continuationIndentSize: 4
+  MaximumLineLength:
+    active: true
+    maxLineLength: 120
+  ModifierOrdering:
+    active: true
+    autoCorrect: true
+  MultiLineIfElse:
+    active: true
+    autoCorrect: true
+  NoBlankLineBeforeRbrace:
+    active: true
+    autoCorrect: true
+  NoConsecutiveBlankLines:
+    active: true
+    autoCorrect: true
+  NoEmptyClassBody:
+    active: true
+    autoCorrect: true
+  NoItParamInMultilineLambda:
+    active: false
+  NoLineBreakAfterElse:
+    active: true
+    autoCorrect: true
+  NoLineBreakBeforeAssignment:
+    active: true
+    autoCorrect: true
+  NoMultipleSpaces:
+    active: true
+    autoCorrect: true
+  NoSemicolons:
+    active: true
+    autoCorrect: true
+  NoTrailingSpaces:
+    active: true
+    autoCorrect: true
+  NoUnitReturn:
+    active: true
+    autoCorrect: true
+  NoUnusedImports:
+    active: true
+    autoCorrect: true
+  NoWildcardImports:
+    active: true
+    autoCorrect: true
+  PackageName:
+    active: true
+    autoCorrect: true
+  ParameterListWrapping:
+    active: true
+    autoCorrect: true
+    indentSize: 4
+  SpacingAroundColon:
+    active: true
+    autoCorrect: true
+  SpacingAroundComma:
+    active: true
+    autoCorrect: true
+  SpacingAroundCurly:
+    active: true
+    autoCorrect: true
+  SpacingAroundDot:
+    active: true
+    autoCorrect: true
+  SpacingAroundKeyword:
+    active: true
+    autoCorrect: true
+  SpacingAroundOperators:
+    active: true
+    autoCorrect: true
+  SpacingAroundParens:
+    active: true
+    autoCorrect: true
+  SpacingAroundRangeOperator:
+    active: true
+    autoCorrect: true
+  SpacingAroundUnaryOperators:
+    active: true
+    autoCorrect: true
+  StringTemplate:
+    active: true
+    autoCorrect: true
+
+naming:
+  active: true
+  ClassNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    classPattern: '[A-Z$][a-zA-Z0-9$]*'
+  ConstructorParameterNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    parameterPattern: '[a-z][A-Za-z0-9]*'
+    privateParameterPattern: '[a-z][A-Za-z0-9]*'
+    excludeClassPattern: '$^'
+  EnumNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    enumEntryPattern: '^[A-Z][_a-zA-Z0-9]*'
+  ForbiddenClassName:
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    forbiddenName: ''
+  FunctionMaxLength:
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    maximumFunctionNameLength: 30
+  FunctionMinLength:
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    minimumFunctionNameLength: 3
+  FunctionNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    functionPattern: '^([a-z$][a-zA-Z$0-9]*)|(`.*`)$'
+    excludeClassPattern: '$^'
+    ignoreOverridden: true
+  FunctionParameterNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    parameterPattern: '[a-z][A-Za-z0-9]*'
+    excludeClassPattern: '$^'
+    ignoreOverriddenFunctions: true
+  InvalidPackageDeclaration:
+    active: false
+    rootPackage: ''
+  MatchingDeclarationName:
+    active: true
+  MemberNameEqualsClassName:
+    active: false
+    ignoreOverriddenFunction: true
+  ObjectPropertyNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    constantPattern: '[A-Za-z][_A-Za-z0-9]*'
+    propertyPattern: '[A-Za-z][_A-Za-z0-9]*'
+    privatePropertyPattern: '(_)?[A-Za-z][_A-Za-z0-9]*'
+  PackageNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    packagePattern: '^[a-z]+(\.[a-z][A-Za-z0-9]*)*$'
+  TopLevelPropertyNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    constantPattern: '[A-Z][_A-Z0-9]*'
+    propertyPattern: '[A-Za-z][_A-Za-z0-9]*'
+    privatePropertyPattern: '_?[A-Za-z][_A-Za-z0-9]*'
+  VariableMaxLength:
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    maximumVariableNameLength: 64
+  VariableMinLength:
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    minimumVariableNameLength: 1
+  VariableNaming:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    variablePattern: '[a-z][A-Za-z0-9]*'
+    privateVariablePattern: '(_)?[a-z][A-Za-z0-9]*'
+    excludeClassPattern: '$^'
+    ignoreOverridden: true
+
+performance:
+  active: true
+  ArrayPrimitive:
+    active: false
+  ForEachOnRange:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+  SpreadOperator:
+    #LeakCanary - disabled
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+  UnnecessaryTemporaryInstantiation:
+    active: true
+
+potential-bugs:
+  active: true
+  DuplicateCaseInWhenExpression:
+    active: true
+  EqualsAlwaysReturnsTrueOrFalse:
+    active: false
+  EqualsWithHashCodeExist:
+    active: true
+  ExplicitGarbageCollectionCall:
+    #LeakCanary - we want to trigger GC manually
+    active: false
+  InvalidRange:
+    active: false
+  IteratorHasNextCallsNextMethod:
+    active: false
+  IteratorNotThrowingNoSuchElementException:
+    active: false
+  LateinitUsage:
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    excludeAnnotatedProperties: ""
+    ignoreOnClassesPattern: ""
+  MissingWhenCase:
+    active: false
+  RedundantElseInWhen:
+    active: false
+  UnconditionalJumpStatementInLoop:
+    active: false
+  UnreachableCode:
+    active: true
+  UnsafeCallOnNullableType:
+    active: false
+  UnsafeCast:
+    active: false
+  UselessPostfixExpression:
+    active: false
+  WrongEqualsTypeParameter:
+    active: false
+
+style:
+  active: true
+  CollapsibleIfStatements:
+    active: false
+  DataClassContainsFunctions:
+    active: false
+    conversionFunctionPrefix: 'to'
+  DataClassShouldBeImmutable:
+    active: false
+  EqualsNullCall:
+    active: false
+  EqualsOnSignatureLine:
+    active: false
+  ExplicitItLambdaParameter:
+    active: false
+  ExpressionBodySyntax:
+    active: false
+    includeLineWrapping: false
+  ForbiddenComment:
+    active: true
+    values: 'TODO:,FIXME:,STOPSHIP:'
+  ForbiddenImport:
+    active: false
+    imports: ''
+  ForbiddenVoid:
+    active: false
+    ignoreOverridden: false
+  FunctionOnlyReturningConstant:
+    active: false
+    ignoreOverridableFunction: true
+    excludedFunctions: 'describeContents'
+  LibraryCodeMustSpecifyReturnType:
+    active: false
+  LoopWithTooManyJumpStatements:
+    active: false
+    maxJumpCount: 1
+  MagicNumber:
+    #LeakCanary - disabled
+    active: false
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    ignoreNumbers: '-1,0,1,2'
+    ignoreHashCodeFunction: true
+    ignorePropertyDeclaration: false
+    ignoreConstantDeclaration: true
+    ignoreCompanionObjectPropertyDeclaration: true
+    ignoreAnnotation: false
+    ignoreNamedArgument: true
+    ignoreEnums: false
+    ignoreRanges: false
+  MandatoryBracesIfStatements:
+    active: false
+  MaxLineLength:
+    #LeakCanary - increased from 120 to 150
+    active: true
+    maxLineLength: 150
+    excludePackageStatements: true
+    excludeImportStatements: true
+    excludeCommentStatements: false
+  MayBeConst:
+    active: false
+  ModifierOrder:
+    active: true
+  NestedClassesVisibility:
+    active: false
+  NewLineAtEndOfFile:
+    #LeakCanary - disabled
+    active: false
+  NoTabs:
+    active: false
+  OptionalAbstractKeyword:
+    active: true
+  OptionalUnit:
+    active: false
+  OptionalWhenBraces:
+    active: false
+  PreferToOverPairSyntax:
+    active: false
+  ProtectedMemberInFinalClass:
+    active: false
+  RedundantVisibilityModifierRule:
+    active: false
+  ReturnCount:
+    #LeakCanary - increased from 2 to 4
+    active: true
+    max: 4
+    excludedFunctions: "equals"
+    excludeLabeled: false
+    excludeReturnFromLambda: true
+  SafeCast:
+    active: true
+  SerialVersionUIDInSerializableClass:
+    active: false
+  SpacingBetweenPackageAndImports:
+    active: false
+  ThrowsCount:
+    active: true
+    max: 2
+  TrailingWhitespace:
+    active: false
+  UnderscoresInNumericLiterals:
+    active: false
+    acceptableDecimalLength: 5
+  UnnecessaryAbstractClass:
+    active: false
+    excludeAnnotatedClasses: "dagger.Module"
+  UnnecessaryApply:
+    active: false
+  UnnecessaryInheritance:
+    active: false
+  UnnecessaryLet:
+    active: false
+  UnnecessaryParentheses:
+    active: false
+  UntilInsteadOfRangeTo:
+    active: false
+  UnusedImports:
+    active: false
+  UnusedPrivateClass:
+    active: false
+  UnusedPrivateMember:
+    active: false
+    allowedNames: "(_|ignored|expected|serialVersionUID)"
+  UseCheckOrError:
+    active: false
+  UseDataClass:
+    active: false
+    excludeAnnotatedClasses: ""
+  UseRequire:
+    active: false
+  UselessCallOnNotNull:
+    active: false
+  UtilityClassWithPublicConstructor:
+    active: false
+  VarCouldBeVal:
+    active: false
+  WildcardImport:
+    active: true
+    excludes: "**/test/**,**/androidTest/**,**/*.Test.kt,**/*.Spec.kt,**/*.Spek.kt"
+    excludeImports: 'java.util.*,kotlinx.android.synthetic.*'
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/-s-t-a-t-i-c_-m-t-a-r-g-e-t_-v-i-e-w.md b/docs/api/shark-android/shark/-android-reference-matchers/-s-t-a-t-i-c_-m-t-a-r-g-e-t_-v-i-e-w.md
new file mode 100644
index 00000000..79903884
--- /dev/null
+++ b/docs/api/shark-android/shark/-android-reference-matchers/-s-t-a-t-i-c_-m-t-a-r-g-e-t_-v-i-e-w.md
@@ -0,0 +1,5 @@
+[shark-android](../../index.md) / [shark](../index.md) / [AndroidReferenceMatchers](index.md) / [STATIC_MTARGET_VIEW](./-s-t-a-t-i-c_-m-t-a-r-g-e-t_-v-i-e-w.md)
+
+# STATIC_MTARGET_VIEW
+
+`STATIC_MTARGET_VIEW`
\ No newline at end of file
diff --git a/docs/api/shark-android/shark/-android-reference-matchers/index.md b/docs/api/shark-android/shark/-android-reference-matchers/index.md
index 3b1f7151..ada4a330 100644
--- a/docs/api/shark-android/shark/-android-reference-matchers/index.md
+++ b/docs/api/shark-android/shark/-android-reference-matchers/index.md
@@ -68,6 +68,7 @@ Most app developers should use [appDefaults](app-defaults.md). However, you can
 | [VIEW_CONFIGURATION__MCONTEXT](-v-i-e-w_-c-o-n-f-i-g-u-r-a-t-i-o-n__-m-c-o-n-t-e-x-t.md) |  |
 | [AUDIO_MANAGER__MCONTEXT_STATIC](-a-u-d-i-o_-m-a-n-a-g-e-r__-m-c-o-n-t-e-x-t_-s-t-a-t-i-c.md) |  |
 | [ACTIVITY_MANAGER_MCONTEXT](-a-c-t-i-v-i-t-y_-m-a-n-a-g-e-r_-m-c-o-n-t-e-x-t.md) |  |
+| [STATIC_MTARGET_VIEW](-s-t-a-t-i-c_-m-t-a-r-g-e-t_-v-i-e-w.md) |  |
 | [GESTURE_BOOST_MANAGER](-g-e-s-t-u-r-e_-b-o-o-s-t_-m-a-n-a-g-e-r.md) |  |
 | [BUBBLE_POPUP_HELPER__SHELPER](-b-u-b-b-l-e_-p-o-p-u-p_-h-e-l-p-e-r__-s-h-e-l-p-e-r.md) |  |
 | [LGCONTEXT__MCONTEXT](-l-g-c-o-n-t-e-x-t__-m-c-o-n-t-e-x-t.md) |  |
diff --git a/docs/api/shark-hprof/shark/-hprof-reader/-init-.md b/docs/api/shark-hprof/shark/-hprof-reader/-init-.md
index b0cf0c21..6a240bc2 100644
--- a/docs/api/shark-hprof/shark/-hprof-reader/-init-.md
+++ b/docs/api/shark-hprof/shark/-hprof-reader/-init-.md
@@ -2,7 +2,7 @@
 
 # &lt;init&gt;
 
-`HprofReader(source: BufferedSource, identifierByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, startByteReadCount: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)` = 0L)`
+`HprofReader(source: BufferedSource, identifierByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, startPosition: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)` = 0L)`
 
 Reads hprof content from an Okio [BufferedSource](#).
 
diff --git a/docs/api/shark-hprof/shark/-hprof-reader/byte-read-count.md b/docs/api/shark-hprof/shark/-hprof-reader/byte-read-count.md
deleted file mode 100644
index 423d9fb7..00000000
--- a/docs/api/shark-hprof/shark/-hprof-reader/byte-read-count.md
+++ /dev/null
@@ -1,9 +0,0 @@
-[shark-hprof](../../index.md) / [shark](../index.md) / [HprofReader](index.md) / [byteReadCount](./byte-read-count.md)
-
-# byteReadCount
-
-`var byteReadCount: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
-
-Starts at [startByteReadCount](start-byte-read-count.md) and increases as [HprofReader](index.md) reads bytes. This is useful
-for tracking the position of content in the backing [source](#). This never resets.
-
diff --git a/docs/api/shark-hprof/shark/-hprof-reader/index.md b/docs/api/shark-hprof/shark/-hprof-reader/index.md
index 9fdf6601..18961a86 100644
--- a/docs/api/shark-hprof/shark/-hprof-reader/index.md
+++ b/docs/api/shark-hprof/shark/-hprof-reader/index.md
@@ -17,23 +17,27 @@ is largely adapted from https://android.googlesource.com/platform/tools/base/+/s
 
 | Name | Summary |
 |---|---|
-| [&lt;init&gt;](-init-.md) | `HprofReader(source: BufferedSource, identifierByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, startByteReadCount: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)` = 0L)`<br>Reads hprof content from an Okio [BufferedSource](#). |
+| [&lt;init&gt;](-init-.md) | `HprofReader(source: BufferedSource, identifierByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, startPosition: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)` = 0L)`<br>Reads hprof content from an Okio [BufferedSource](#). |
 
 ### Properties
 
 | Name | Summary |
 |---|---|
-| [byteReadCount](byte-read-count.md) | `var byteReadCount: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>Starts at [startByteReadCount](start-byte-read-count.md) and increases as [HprofReader](./index.md) reads bytes. This is useful for tracking the position of content in the backing [source](#). This never resets. |
 | [identifierByteSize](identifier-byte-size.md) | `val identifierByteSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>Size of Hprof identifiers. Identifiers are used to represent UTF8 strings, objects, stack traces, etc. They can have the same size as host pointers or sizeof(void*), but are not required to be. |
-| [startByteReadCount](start-byte-read-count.md) | `val startByteReadCount: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>How many bytes have already been read from [source](#) when this [HprofReader](./index.md) is created. |
+| [position](position.md) | `var position: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>Starts at [startPosition](start-position.md) and increases as [HprofReader](./index.md) reads bytes. This is useful for tracking the position of content in the backing [source](#). This never resets. |
+| [startPosition](start-position.md) | `val startPosition: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>How many bytes have already been read from [source](#) when this [HprofReader](./index.md) is created. |
 
 ### Functions
 
 | Name | Summary |
 |---|---|
 | [readClassDumpRecord](read-class-dump-record.md) | `fun readClassDumpRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord`](../-hprof-record/-heap-dump-record/-object-record/-class-dump-record/index.md)<br>Reads a full class record after a class dump tag. |
-| [readHprofRecords](read-hprof-records.md) | `fun readHprofRecords(recordTypes: `[`Set`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-set/index.html)`<`[`KClass`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html)`<out `[`HprofRecord`](../-hprof-record/index.md)`>>, listener: `[`OnHprofRecordListener`](../-on-hprof-record-listener/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Reads all hprof records from [source](#). Assumes the [reader](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/reader.html) was just created, with a source that currently points to the start position of hprof records. |
+| [readClassSkipContentRecord](read-class-skip-content-record.md) | `fun readClassSkipContentRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.ClassSkipContentRecord`](../-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/index.md)<br>Reads a class record after a class dump tag, skipping its content. |
+| [readHprofRecords](read-hprof-records.md) | `fun readHprofRecords(recordTypes: `[`Set`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-set/index.html)`<`[`KClass`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html)`<out `[`HprofRecord`](../-hprof-record/index.md)`>>, listener: `[`OnHprofRecordListener`](../-on-hprof-record-listener/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Reads all hprof records from [source](#). Assumes the [reader](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/reader.html) was has a source that currently points to the start position of hprof records. |
 | [readInstanceDumpRecord](read-instance-dump-record.md) | `fun readInstanceDumpRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord`](../-hprof-record/-heap-dump-record/-object-record/-instance-dump-record/index.md)<br>Reads a full instance record after a instance dump tag. |
+| [readInstanceSkipContentRecord](read-instance-skip-content-record.md) | `fun readInstanceSkipContentRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.InstanceSkipContentRecord`](../-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/index.md)<br>Reads an instance record after a instance dump tag, skipping its content. |
 | [readObjectArrayDumpRecord](read-object-array-dump-record.md) | `fun readObjectArrayDumpRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord`](../-hprof-record/-heap-dump-record/-object-record/-object-array-dump-record/index.md)<br>Reads a full object array record after a object array dump tag. |
+| [readObjectArraySkipContentRecord](read-object-array-skip-content-record.md) | `fun readObjectArraySkipContentRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArraySkipContentRecord`](../-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/index.md)<br>Reads an object array record after a object array dump tag, skipping its content. |
 | [readPrimitiveArrayDumpRecord](read-primitive-array-dump-record.md) | `fun readPrimitiveArrayDumpRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord`](../-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/index.md)<br>Reads a full primitive array record after a primitive array dump tag. |
+| [readPrimitiveArraySkipContentRecord](read-primitive-array-skip-content-record.md) | `fun readPrimitiveArraySkipContentRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArraySkipContentRecord`](../-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/index.md)<br>Reads a primitive array record after a primitive array dump tag, skipping its content. |
 | [readValue](read-value.md) | `fun readValue(type: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`): `[`ValueHolder`](../-value-holder/index.md)<br>Reads a value in the heap dump, which can be a reference or a primitive type. |
diff --git a/docs/api/shark-hprof/shark/-hprof-reader/position.md b/docs/api/shark-hprof/shark/-hprof-reader/position.md
new file mode 100644
index 00000000..1671c49a
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-reader/position.md
@@ -0,0 +1,9 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofReader](index.md) / [position](./position.md)
+
+# position
+
+`var position: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Starts at [startPosition](start-position.md) and increases as [HprofReader](index.md) reads bytes. This is useful
+for tracking the position of content in the backing [source](#). This never resets.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-reader/read-class-skip-content-record.md b/docs/api/shark-hprof/shark/-hprof-reader/read-class-skip-content-record.md
new file mode 100644
index 00000000..bbba87a1
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-reader/read-class-skip-content-record.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofReader](index.md) / [readClassSkipContentRecord](./read-class-skip-content-record.md)
+
+# readClassSkipContentRecord
+
+`fun readClassSkipContentRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.ClassSkipContentRecord`](../-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/index.md)
+
+Reads a class record after a class dump tag, skipping its content.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-reader/read-hprof-records.md b/docs/api/shark-hprof/shark/-hprof-reader/read-hprof-records.md
index b2bad632..9ccd30f6 100644
--- a/docs/api/shark-hprof/shark/-hprof-reader/read-hprof-records.md
+++ b/docs/api/shark-hprof/shark/-hprof-reader/read-hprof-records.md
@@ -5,6 +5,6 @@
 `fun readHprofRecords(recordTypes: `[`Set`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-set/index.html)`<`[`KClass`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html)`<out `[`HprofRecord`](../-hprof-record/index.md)`>>, listener: `[`OnHprofRecordListener`](../-on-hprof-record-listener/index.md)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
 
 Reads all hprof records from [source](#).
-Assumes the [reader](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/reader.html) was just created, with a source that currently points to the start
-position of hprof records.
+Assumes the [reader](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/reader.html) was has a source that currently points to the start position of hprof
+records.
 
diff --git a/docs/api/shark-hprof/shark/-hprof-reader/read-instance-skip-content-record.md b/docs/api/shark-hprof/shark/-hprof-reader/read-instance-skip-content-record.md
new file mode 100644
index 00000000..73a06701
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-reader/read-instance-skip-content-record.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofReader](index.md) / [readInstanceSkipContentRecord](./read-instance-skip-content-record.md)
+
+# readInstanceSkipContentRecord
+
+`fun readInstanceSkipContentRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.InstanceSkipContentRecord`](../-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/index.md)
+
+Reads an instance record after a instance dump tag, skipping its content.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-reader/read-object-array-skip-content-record.md b/docs/api/shark-hprof/shark/-hprof-reader/read-object-array-skip-content-record.md
new file mode 100644
index 00000000..1e9566ae
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-reader/read-object-array-skip-content-record.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofReader](index.md) / [readObjectArraySkipContentRecord](./read-object-array-skip-content-record.md)
+
+# readObjectArraySkipContentRecord
+
+`fun readObjectArraySkipContentRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArraySkipContentRecord`](../-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/index.md)
+
+Reads an object array record after a object array dump tag, skipping its content.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-reader/read-primitive-array-skip-content-record.md b/docs/api/shark-hprof/shark/-hprof-reader/read-primitive-array-skip-content-record.md
new file mode 100644
index 00000000..f09dbf50
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-reader/read-primitive-array-skip-content-record.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofReader](index.md) / [readPrimitiveArraySkipContentRecord](./read-primitive-array-skip-content-record.md)
+
+# readPrimitiveArraySkipContentRecord
+
+`fun readPrimitiveArraySkipContentRecord(): `[`HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArraySkipContentRecord`](../-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/index.md)
+
+Reads a primitive array record after a primitive array dump tag, skipping its content.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-reader/start-byte-read-count.md b/docs/api/shark-hprof/shark/-hprof-reader/start-byte-read-count.md
deleted file mode 100644
index e58ff467..00000000
--- a/docs/api/shark-hprof/shark/-hprof-reader/start-byte-read-count.md
+++ /dev/null
@@ -1,8 +0,0 @@
-[shark-hprof](../../index.md) / [shark](../index.md) / [HprofReader](index.md) / [startByteReadCount](./start-byte-read-count.md)
-
-# startByteReadCount
-
-`val startByteReadCount: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
-
-How many bytes have already been read from [source](#) when this [HprofReader](index.md) is created.
-
diff --git a/docs/api/shark-hprof/shark/-hprof-reader/start-position.md b/docs/api/shark-hprof/shark/-hprof-reader/start-position.md
new file mode 100644
index 00000000..fed83964
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-reader/start-position.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [HprofReader](index.md) / [startPosition](./start-position.md)
+
+# startPosition
+
+`val startPosition: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+How many bytes have already been read from [source](#) when this [HprofReader](index.md) is created.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/-init-.md
new file mode 100644
index 00000000..9ea742b9
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/-init-.md
@@ -0,0 +1,9 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassSkipContentRecord](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`ClassSkipContentRecord(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, superclassId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, classLoaderId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, signersId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, protectionDomainId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, instanceSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, staticFieldCount: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, fieldCount: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)`
+
+This isn't a real record type as found in the heap dump. It's an alternative to
+[ClassDumpRecord](../-class-dump-record/index.md) for when you don't need the class content.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/class-loader-id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/class-loader-id.md
new file mode 100644
index 00000000..7fca9b04
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/class-loader-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassSkipContentRecord](index.md) / [classLoaderId](./class-loader-id.md)
+
+# classLoaderId
+
+`val classLoaderId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/field-count.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/field-count.md
new file mode 100644
index 00000000..6605e137
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/field-count.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassSkipContentRecord](index.md) / [fieldCount](./field-count.md)
+
+# fieldCount
+
+`val fieldCount: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/id.md
new file mode 100644
index 00000000..142f1570
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassSkipContentRecord](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/index.md
new file mode 100644
index 00000000..c5c8c29b
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/index.md
@@ -0,0 +1,28 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassSkipContentRecord](./index.md)
+
+# ClassSkipContentRecord
+
+`class ClassSkipContentRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](../index.md)
+
+This isn't a real record type as found in the heap dump. It's an alternative to
+[ClassDumpRecord](../-class-dump-record/index.md) for when you don't need the class content.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `ClassSkipContentRecord(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, superclassId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, classLoaderId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, signersId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, protectionDomainId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, instanceSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, staticFieldCount: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, fieldCount: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)`<br>This isn't a real record type as found in the heap dump. It's an alternative to [ClassDumpRecord](../-class-dump-record/index.md) for when you don't need the class content. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [classLoaderId](class-loader-id.md) | `val classLoaderId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [fieldCount](field-count.md) | `val fieldCount: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [instanceSize](instance-size.md) | `val instanceSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [protectionDomainId](protection-domain-id.md) | `val protectionDomainId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [signersId](signers-id.md) | `val signersId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [stackTraceSerialNumber](stack-trace-serial-number.md) | `val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [staticFieldCount](static-field-count.md) | `val staticFieldCount: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [superclassId](superclass-id.md) | `val superclassId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/instance-size.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/instance-size.md
new file mode 100644
index 00000000..36090e41
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/instance-size.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassSkipContentRecord](index.md) / [instanceSize](./instance-size.md)
+
+# instanceSize
+
+`val instanceSize: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/protection-domain-id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/protection-domain-id.md
new file mode 100644
index 00000000..f6bc67f6
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/protection-domain-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassSkipContentRecord](index.md) / [protectionDomainId](./protection-domain-id.md)
+
+# protectionDomainId
+
+`val protectionDomainId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/signers-id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/signers-id.md
new file mode 100644
index 00000000..d1b0531d
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/signers-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassSkipContentRecord](index.md) / [signersId](./signers-id.md)
+
+# signersId
+
+`val signersId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/stack-trace-serial-number.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/stack-trace-serial-number.md
new file mode 100644
index 00000000..bbb455c3
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/stack-trace-serial-number.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassSkipContentRecord](index.md) / [stackTraceSerialNumber](./stack-trace-serial-number.md)
+
+# stackTraceSerialNumber
+
+`val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/static-field-count.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/static-field-count.md
new file mode 100644
index 00000000..76527a27
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/static-field-count.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassSkipContentRecord](index.md) / [staticFieldCount](./static-field-count.md)
+
+# staticFieldCount
+
+`val staticFieldCount: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/superclass-id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/superclass-id.md
new file mode 100644
index 00000000..df584767
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-class-skip-content-record/superclass-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ClassSkipContentRecord](index.md) / [superclassId](./superclass-id.md)
+
+# superclassId
+
+`val superclassId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/-init-.md
new file mode 100644
index 00000000..6092d13c
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/-init-.md
@@ -0,0 +1,9 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [InstanceSkipContentRecord](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`InstanceSkipContentRecord(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, classId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`
+
+This isn't a real record type as found in the heap dump. It's an alternative to
+[InstanceDumpRecord](../-instance-dump-record/index.md) for when you don't need the instance content.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/class-id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/class-id.md
new file mode 100644
index 00000000..03722b5d
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/class-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [InstanceSkipContentRecord](index.md) / [classId](./class-id.md)
+
+# classId
+
+`val classId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/id.md
new file mode 100644
index 00000000..bc50ba0c
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [InstanceSkipContentRecord](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/index.md
new file mode 100644
index 00000000..452a7ff8
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/index.md
@@ -0,0 +1,22 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [InstanceSkipContentRecord](./index.md)
+
+# InstanceSkipContentRecord
+
+`class InstanceSkipContentRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](../index.md)
+
+This isn't a real record type as found in the heap dump. It's an alternative to
+[InstanceDumpRecord](../-instance-dump-record/index.md) for when you don't need the instance content.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `InstanceSkipContentRecord(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, classId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`)`<br>This isn't a real record type as found in the heap dump. It's an alternative to [InstanceDumpRecord](../-instance-dump-record/index.md) for when you don't need the instance content. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [classId](class-id.md) | `val classId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [stackTraceSerialNumber](stack-trace-serial-number.md) | `val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/stack-trace-serial-number.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/stack-trace-serial-number.md
new file mode 100644
index 00000000..09b3f109
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-instance-skip-content-record/stack-trace-serial-number.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [InstanceSkipContentRecord](index.md) / [stackTraceSerialNumber](./stack-trace-serial-number.md)
+
+# stackTraceSerialNumber
+
+`val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/-init-.md
new file mode 100644
index 00000000..792a5391
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/-init-.md
@@ -0,0 +1,9 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ObjectArraySkipContentRecord](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`ObjectArraySkipContentRecord(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, arrayClassId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)`
+
+This isn't a real record type as found in the heap dump. It's an alternative to
+[ObjectArrayDumpRecord](../-object-array-dump-record/index.md) for when you don't need the array content.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/array-class-id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/array-class-id.md
new file mode 100644
index 00000000..349eeb50
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/array-class-id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ObjectArraySkipContentRecord](index.md) / [arrayClassId](./array-class-id.md)
+
+# arrayClassId
+
+`val arrayClassId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/id.md
new file mode 100644
index 00000000..13a21bfd
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ObjectArraySkipContentRecord](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/index.md
new file mode 100644
index 00000000..6983c34a
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/index.md
@@ -0,0 +1,23 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ObjectArraySkipContentRecord](./index.md)
+
+# ObjectArraySkipContentRecord
+
+`class ObjectArraySkipContentRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](../index.md)
+
+This isn't a real record type as found in the heap dump. It's an alternative to
+[ObjectArrayDumpRecord](../-object-array-dump-record/index.md) for when you don't need the array content.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `ObjectArraySkipContentRecord(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, arrayClassId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`)`<br>This isn't a real record type as found in the heap dump. It's an alternative to [ObjectArrayDumpRecord](../-object-array-dump-record/index.md) for when you don't need the array content. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [arrayClassId](array-class-id.md) | `val arrayClassId: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [size](size.md) | `val size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [stackTraceSerialNumber](stack-trace-serial-number.md) | `val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/size.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/size.md
new file mode 100644
index 00000000..d336a001
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/size.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ObjectArraySkipContentRecord](index.md) / [size](./size.md)
+
+# size
+
+`val size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/stack-trace-serial-number.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/stack-trace-serial-number.md
new file mode 100644
index 00000000..3c25e3f3
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-object-array-skip-content-record/stack-trace-serial-number.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [ObjectArraySkipContentRecord](index.md) / [stackTraceSerialNumber](./stack-trace-serial-number.md)
+
+# stackTraceSerialNumber
+
+`val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/index.md
index 348e29c7..c8c44bd1 100644
--- a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/index.md
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-dump-record/index.md
@@ -4,11 +4,6 @@
 
 `sealed class PrimitiveArrayDumpRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](../index.md)
 
-Note: we could move the arrays to the parent class as a ByteString or ByteArray
-and then each subtype can create a new array of the right type if needed.
-However, experimenting with live parsing has shown that we never to read arrays except
-when we want to display leak trace information, in which case we do need the data.
-
 ### Types
 
 | Name | Summary |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/-init-.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/-init-.md
new file mode 100644
index 00000000..950055b1
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/-init-.md
@@ -0,0 +1,9 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [PrimitiveArraySkipContentRecord](index.md) / [&lt;init&gt;](./-init-.md)
+
+# &lt;init&gt;
+
+`PrimitiveArraySkipContentRecord(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, type: `[`PrimitiveType`](../../../../-primitive-type/index.md)`)`
+
+This isn't a real record type as found in the heap dump. It's an alternative to
+[PrimitiveArrayDumpRecord](../-primitive-array-dump-record/index.md) for when you don't need the array content.
+
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/id.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/id.md
new file mode 100644
index 00000000..f6e601bd
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/id.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [PrimitiveArraySkipContentRecord](index.md) / [id](./id.md)
+
+# id
+
+`val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/index.md
new file mode 100644
index 00000000..ee9f0150
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/index.md
@@ -0,0 +1,23 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [PrimitiveArraySkipContentRecord](./index.md)
+
+# PrimitiveArraySkipContentRecord
+
+`class PrimitiveArraySkipContentRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](../index.md)
+
+This isn't a real record type as found in the heap dump. It's an alternative to
+[PrimitiveArrayDumpRecord](../-primitive-array-dump-record/index.md) for when you don't need the array content.
+
+### Constructors
+
+| Name | Summary |
+|---|---|
+| [&lt;init&gt;](-init-.md) | `PrimitiveArraySkipContentRecord(id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`, stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, type: `[`PrimitiveType`](../../../../-primitive-type/index.md)`)`<br>This isn't a real record type as found in the heap dump. It's an alternative to [PrimitiveArrayDumpRecord](../-primitive-array-dump-record/index.md) for when you don't need the array content. |
+
+### Properties
+
+| Name | Summary |
+|---|---|
+| [id](id.md) | `val id: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html) |
+| [size](size.md) | `val size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [stackTraceSerialNumber](stack-trace-serial-number.md) | `val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html) |
+| [type](type.md) | `val type: `[`PrimitiveType`](../../../../-primitive-type/index.md) |
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/size.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/size.md
new file mode 100644
index 00000000..f653bf1b
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/size.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [PrimitiveArraySkipContentRecord](index.md) / [size](./size.md)
+
+# size
+
+`val size: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/stack-trace-serial-number.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/stack-trace-serial-number.md
new file mode 100644
index 00000000..3e180378
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/stack-trace-serial-number.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [PrimitiveArraySkipContentRecord](index.md) / [stackTraceSerialNumber](./stack-trace-serial-number.md)
+
+# stackTraceSerialNumber
+
+`val stackTraceSerialNumber: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/type.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/type.md
new file mode 100644
index 00000000..c582abdf
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/-primitive-array-skip-content-record/type.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../../../../index.md) / [shark](../../../../index.md) / [HprofRecord](../../../index.md) / [HeapDumpRecord](../../index.md) / [ObjectRecord](../index.md) / [PrimitiveArraySkipContentRecord](index.md) / [type](./type.md)
+
+# type
+
+`val type: `[`PrimitiveType`](../../../../-primitive-type/index.md)
\ No newline at end of file
diff --git a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/index.md b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/index.md
index 591f3af7..5a3e02c0 100644
--- a/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/index.md
+++ b/docs/api/shark-hprof/shark/-hprof-record/-heap-dump-record/-object-record/index.md
@@ -9,15 +9,23 @@
 | Name | Summary |
 |---|---|
 | [ClassDumpRecord](-class-dump-record/index.md) | `class ClassDumpRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md) |
+| [ClassSkipContentRecord](-class-skip-content-record/index.md) | `class ClassSkipContentRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md)<br>This isn't a real record type as found in the heap dump. It's an alternative to [ClassDumpRecord](-class-dump-record/index.md) for when you don't need the class content. |
 | [InstanceDumpRecord](-instance-dump-record/index.md) | `class InstanceDumpRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md) |
+| [InstanceSkipContentRecord](-instance-skip-content-record/index.md) | `class InstanceSkipContentRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md)<br>This isn't a real record type as found in the heap dump. It's an alternative to [InstanceDumpRecord](-instance-dump-record/index.md) for when you don't need the instance content. |
 | [ObjectArrayDumpRecord](-object-array-dump-record/index.md) | `class ObjectArrayDumpRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md) |
-| [PrimitiveArrayDumpRecord](-primitive-array-dump-record/index.md) | `sealed class PrimitiveArrayDumpRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md)<br>Note: we could move the arrays to the parent class as a ByteString or ByteArray and then each subtype can create a new array of the right type if needed. However, experimenting with live parsing has shown that we never to read arrays except when we want to display leak trace information, in which case we do need the data. |
+| [ObjectArraySkipContentRecord](-object-array-skip-content-record/index.md) | `class ObjectArraySkipContentRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md)<br>This isn't a real record type as found in the heap dump. It's an alternative to [ObjectArrayDumpRecord](-object-array-dump-record/index.md) for when you don't need the array content. |
+| [PrimitiveArrayDumpRecord](-primitive-array-dump-record/index.md) | `sealed class PrimitiveArrayDumpRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md) |
+| [PrimitiveArraySkipContentRecord](-primitive-array-skip-content-record/index.md) | `class PrimitiveArraySkipContentRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md)<br>This isn't a real record type as found in the heap dump. It's an alternative to [PrimitiveArrayDumpRecord](-primitive-array-dump-record/index.md) for when you don't need the array content. |
 
 ### Inheritors
 
 | Name | Summary |
 |---|---|
 | [ClassDumpRecord](-class-dump-record/index.md) | `class ClassDumpRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md) |
+| [ClassSkipContentRecord](-class-skip-content-record/index.md) | `class ClassSkipContentRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md)<br>This isn't a real record type as found in the heap dump. It's an alternative to [ClassDumpRecord](-class-dump-record/index.md) for when you don't need the class content. |
 | [InstanceDumpRecord](-instance-dump-record/index.md) | `class InstanceDumpRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md) |
+| [InstanceSkipContentRecord](-instance-skip-content-record/index.md) | `class InstanceSkipContentRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md)<br>This isn't a real record type as found in the heap dump. It's an alternative to [InstanceDumpRecord](-instance-dump-record/index.md) for when you don't need the instance content. |
 | [ObjectArrayDumpRecord](-object-array-dump-record/index.md) | `class ObjectArrayDumpRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md) |
-| [PrimitiveArrayDumpRecord](-primitive-array-dump-record/index.md) | `sealed class PrimitiveArrayDumpRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md)<br>Note: we could move the arrays to the parent class as a ByteString or ByteArray and then each subtype can create a new array of the right type if needed. However, experimenting with live parsing has shown that we never to read arrays except when we want to display leak trace information, in which case we do need the data. |
+| [ObjectArraySkipContentRecord](-object-array-skip-content-record/index.md) | `class ObjectArraySkipContentRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md)<br>This isn't a real record type as found in the heap dump. It's an alternative to [ObjectArrayDumpRecord](-object-array-dump-record/index.md) for when you don't need the array content. |
+| [PrimitiveArrayDumpRecord](-primitive-array-dump-record/index.md) | `sealed class PrimitiveArrayDumpRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md) |
+| [PrimitiveArraySkipContentRecord](-primitive-array-skip-content-record/index.md) | `class PrimitiveArraySkipContentRecord : `[`HprofRecord.HeapDumpRecord.ObjectRecord`](./index.md)<br>This isn't a real record type as found in the heap dump. It's an alternative to [PrimitiveArrayDumpRecord](-primitive-array-dump-record/index.md) for when you don't need the array content. |
diff --git a/docs/api/shark-hprof/shark/-hprof/file-length.md b/docs/api/shark-hprof/shark/-hprof/file-length.md
new file mode 100644
index 00000000..0d417a79
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-hprof/file-length.md
@@ -0,0 +1,8 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [Hprof](index.md) / [fileLength](./file-length.md)
+
+# fileLength
+
+`val fileLength: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)
+
+Length of the hprof file, in bytes.
+
diff --git a/docs/api/shark-hprof/shark/-hprof/index.md b/docs/api/shark-hprof/shark/-hprof/index.md
index 97d9b6e7..1d59f3f9 100644
--- a/docs/api/shark-hprof/shark/-hprof/index.md
+++ b/docs/api/shark-hprof/shark/-hprof/index.md
@@ -17,6 +17,7 @@ forget to call [close](close.md) once done.
 
 | Name | Summary |
 |---|---|
+| [fileLength](file-length.md) | `val fileLength: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>Length of the hprof file, in bytes. |
 | [heapDumpTimestamp](heap-dump-timestamp.md) | `val heapDumpTimestamp: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)<br>Unix timestamp at which the heap was dumped. |
 | [hprofVersion](hprof-version.md) | `val hprofVersion: `[`Hprof.HprofVersion`](-hprof-version/index.md)<br>Version of the opened hprof, which is tied to the runtime where the heap was dumped. |
 | [reader](reader.md) | `val reader: `[`HprofReader`](../-hprof-reader/index.md) |
@@ -26,7 +27,7 @@ forget to call [close](close.md) once done.
 | Name | Summary |
 |---|---|
 | [close](close.md) | `fun close(): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html) |
-| [moveReaderTo](move-reader-to.md) | `fun moveReaderTo(newPosition: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Moves [reader](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/reader.html) to a new position in the hprof file. This is transparent to the reader, and will not reset [HprofReader.byteReadCount](../-hprof-reader/byte-read-count.md). |
+| [moveReaderTo](move-reader-to.md) | `fun moveReaderTo(newPosition: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Moves [reader](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/reader.html) to a new position in the hprof file. This is transparent to the reader, and will not reset [HprofReader.position](../-hprof-reader/position.md). |
 
 ### Companion Object Functions
 
diff --git a/docs/api/shark-hprof/shark/-hprof/move-reader-to.md b/docs/api/shark-hprof/shark/-hprof/move-reader-to.md
index dab13147..eda5d968 100644
--- a/docs/api/shark-hprof/shark/-hprof/move-reader-to.md
+++ b/docs/api/shark-hprof/shark/-hprof/move-reader-to.md
@@ -5,5 +5,5 @@
 `fun moveReaderTo(newPosition: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)
 
 Moves [reader](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/reader.html) to a new position in the hprof file. This is transparent to the reader, and
-will not reset [HprofReader.byteReadCount](../-hprof-reader/byte-read-count.md).
+will not reset [HprofReader.position](../-hprof-reader/position.md).
 
diff --git a/docs/api/shark-hprof/shark/-primitive-type/index.md b/docs/api/shark-hprof/shark/-primitive-type/index.md
index 1840e243..e67f6974 100644
--- a/docs/api/shark-hprof/shark/-primitive-type/index.md
+++ b/docs/api/shark-hprof/shark/-primitive-type/index.md
@@ -31,4 +31,5 @@ A primitive type in the prof.
 | Name | Summary |
 |---|---|
 | [byteSizeByHprofType](byte-size-by-hprof-type.md) | `val byteSizeByHprofType: `[`Map`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/index.html)`<`[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`>` |
+| [primitiveTypeByHprofType](primitive-type-by-hprof-type.md) | `val primitiveTypeByHprofType: `[`Map`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/index.html)`<`[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, `[`PrimitiveType`](./index.md)`>` |
 | [REFERENCE_HPROF_TYPE](-r-e-f-e-r-e-n-c-e_-h-p-r-o-f_-t-y-p-e.md) | `const val REFERENCE_HPROF_TYPE: `[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)<br>The hprof defined "basic type" for references. |
diff --git a/docs/api/shark-hprof/shark/-primitive-type/primitive-type-by-hprof-type.md b/docs/api/shark-hprof/shark/-primitive-type/primitive-type-by-hprof-type.md
new file mode 100644
index 00000000..ad2447ea
--- /dev/null
+++ b/docs/api/shark-hprof/shark/-primitive-type/primitive-type-by-hprof-type.md
@@ -0,0 +1,5 @@
+[shark-hprof](../../index.md) / [shark](../index.md) / [PrimitiveType](index.md) / [primitiveTypeByHprofType](./primitive-type-by-hprof-type.md)
+
+# primitiveTypeByHprofType
+
+`val primitiveTypeByHprofType: `[`Map`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/index.html)`<`[`Int`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/index.html)`, `[`PrimitiveType`](index.md)`>`
\ No newline at end of file
diff --git a/docs/assets/adaptative_icon.sketch b/docs/assets/adaptative_icon.sketch
new file mode 100644
index 00000000..7978b281
Binary files /dev/null and b/docs/assets/adaptative_icon.sketch differ
diff --git a/docs/assets/icon_1024.png b/docs/assets/icon_1024.png
new file mode 100644
index 00000000..f15c7586
Binary files /dev/null and b/docs/assets/icon_1024.png differ
diff --git a/docs/assets/icon_512.png b/docs/assets/icon_512.png
new file mode 100644
index 00000000..0ca6bedf
Binary files /dev/null and b/docs/assets/icon_512.png differ
diff --git a/docs/assets/kanary-200px.png b/docs/assets/kanary-200px.png
new file mode 100644
index 00000000..ce9c9eb3
Binary files /dev/null and b/docs/assets/kanary-200px.png differ
diff --git a/docs/assets/kanary-large.png b/docs/assets/kanary-large.png
new file mode 100644
index 00000000..6bb4975c
Binary files /dev/null and b/docs/assets/kanary-large.png differ
diff --git a/docs/assets/leakcanary_shirt.psd b/docs/assets/leakcanary_shirt.psd
new file mode 100644
index 00000000..2273b193
Binary files /dev/null and b/docs/assets/leakcanary_shirt.psd differ
diff --git a/docs/assets/repository-open-graph.png b/docs/assets/repository-open-graph.png
new file mode 100644
index 00000000..86269e91
Binary files /dev/null and b/docs/assets/repository-open-graph.png differ
diff --git a/docs/assets/screenshot.png b/docs/assets/screenshot.png
new file mode 100644
index 00000000..0211a7fd
Binary files /dev/null and b/docs/assets/screenshot.png differ
diff --git a/docs/assets/shark.psd b/docs/assets/shark.psd
new file mode 100644
index 00000000..b9209a65
Binary files /dev/null and b/docs/assets/shark.psd differ
diff --git a/docs/assets/source_icon.png b/docs/assets/source_icon.png
new file mode 100644
index 00000000..d04aace6
Binary files /dev/null and b/docs/assets/source_icon.png differ
diff --git a/docs/assets/sticker.png b/docs/assets/sticker.png
new file mode 100644
index 00000000..4b08925a
Binary files /dev/null and b/docs/assets/sticker.png differ
diff --git a/docs/assets/vector_falling_canary.svg b/docs/assets/vector_falling_canary.svg
new file mode 100644
index 00000000..480d0847
--- /dev/null
+++ b/docs/assets/vector_falling_canary.svg
@@ -0,0 +1,16 @@
+<svg width="185" height="185" viewBox="0 0 185 185" fill="none" xmlns="http://www.w3.org/2000/svg">
+<g clip-path="url(#clip0)">
+<path d="M55.8327 80.944L68.1676 83.3835M59.6321 89.5079L62.4202 75.4109" stroke="#151C1F" stroke-width="4.257" stroke-linecap="round"/>
+<path fill-rule="evenodd" clip-rule="evenodd" d="M33.0396 88.6436L148.284 41.1702C148.308 41.1931 148.333 41.216 148.357 41.2389C147.773 76.5754 125.2 119.136 72.6948 132.558C66.2444 121.606 47.4716 97.5578 32.6694 89.9372C32.799 89.5158 32.9224 89.0844 33.0396 88.6436Z" fill="#F5BD14"/>
+<path d="M81.4818 31.7162L72.8251 55.9266L71.7247 54.5065C66.7399 48.0734 60.8251 42.4184 54.1748 37.7274L69.4736 20.6696L68.6881 39.2884L81.4818 31.7162Z" fill="#F86932"/>
+<circle cx="45.3062" cy="70.8628" r="35.1642" transform="rotate(-33.8126 45.3062 70.8628)" fill="#FFCC32"/>
+<path d="M44.2972 58.986L56.2444 55.066M51.8067 64.5881L47.3268 50.9342" stroke="#151C1F" stroke-width="4.257" stroke-linecap="round"/>
+<path fill-rule="evenodd" clip-rule="evenodd" d="M10.1416 71.2627C10.4815 113.278 38.6085 151.594 81.1309 162.988C113.627 171.695 146.704 162.582 170.003 141.637C159.823 142.304 149.364 141.343 138.964 138.556C113.428 131.714 93.0844 115.164 80.8316 93.9338L10.1416 71.2627Z" fill="#FFCC32"/>
+<path fill-rule="evenodd" clip-rule="evenodd" d="M175.463 56.9136L57.9672 97.0664C57.8158 97.5113 57.6587 97.9458 57.4956 98.3692C71.736 106.994 88.8027 132.282 94.4811 143.653C105.725 141.594 115.73 138.149 124.547 133.665C121.291 132.305 118.248 130.405 115.554 128.011L114.859 127.392C114.033 126.658 113.959 125.394 114.693 124.569C115.427 123.743 116.691 123.669 117.516 124.403L118.212 125.021C121.434 127.886 125.228 129.941 129.286 131.091C130.47 130.405 131.632 129.699 132.769 128.975C130.868 128.149 129.036 127.135 127.302 125.938L126.535 125.409C125.626 124.782 125.398 123.537 126.025 122.627C126.653 121.718 127.898 121.49 128.807 122.117L129.573 122.646C131.83 124.203 134.276 125.407 136.83 126.243C137.942 125.453 139.03 124.644 140.093 123.818C139.482 123.453 138.88 123.067 138.29 122.66L137.524 122.131C136.615 121.504 136.387 120.259 137.014 119.349C137.641 118.44 138.887 118.212 139.796 118.839L140.562 119.368C141.487 120.006 142.444 120.585 143.428 121.104C163.878 103.673 174.394 79.6305 176.271 57.779C176.004 57.4894 175.735 57.2009 175.463 56.9136Z" fill="#FFCC32"/>
+</g>
+<defs>
+<clipPath id="clip0">
+<rect width="185" height="185" fill="white"/>
+</clipPath>
+</defs>
+</svg>
diff --git a/docs/assets/vector_icon.afdesign b/docs/assets/vector_icon.afdesign
new file mode 100644
index 00000000..a30fcf97
Binary files /dev/null and b/docs/assets/vector_icon.afdesign differ
diff --git a/docs/assets/vector_icon.svg b/docs/assets/vector_icon.svg
new file mode 100644
index 00000000..9a17f0dc
--- /dev/null
+++ b/docs/assets/vector_icon.svg
@@ -0,0 +1,6 @@
+<?xml version="1.0" standalone="no"?>
+<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
+<svg width="100%" height="100%" viewBox="0 0 512 512" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:1.41421;">
+    <image id="Container" x="33" y="44" width="443px" height="441px" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAbsAAAG5CAYAAAAXoZoVAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAcMklEQVR4nO3dT4gkZ/nA8Wd6Zmc3mw1ZXEmCfxJCfgZJMDEHwaiRmEsQEolBAkET0Jw96CEXQQRFDyKePOXgIRhFBFFEzCFBEzRIFj0kIaJBCQZB8mezJG522Z3q38Gttqamqrq6u7q76u3PB4bu6Z3p6V525rvPW2/1bI3H4wCAlO2s+wF0YazYAEu1tbW1te7HsIitvnZi1oD19XkADF3bzvU5iL2KXVPg+vQ4Afivur71LXxrjd08cZv1dgDm0xCymT9v3fFbS+zqIld1c/E2oQNYraZGFf+sbRjXFb2Vxq4cuVnill+f9jkAdKdmSqv98/z9utsL7680eiuJ3bTINUWtTfAEEGBxbaazadfrLuu+xqqit9TYtY1c02Xx+iuvvBJ///vf44033ojXX39939upU6fi/PnzS3suAJvm6NGj8a53vStOnDhx4O2GG26Iyy67bF/UpgVvykS41OgtLXbF0LWJXPn6eDyOLMvixRdfjD/84Q/xzDPPxCuvvLKUxwrAbLa3t+PGG2+MW2+9NT7+8Y/HVVddVRu+ttFbZvCWEru60E2LW/7+yZMn46mnnoo//vGPcerUqc4fHwDduvbaa+NjH/tY3HHHHfH+97//QOzaRm9Zwes8dk2hqwpc8e2FF16IRx55JF588cVOHxMAqzEajeLOO++MBx54IE6cOHEgdnVTX/5+4Xqn0es0dnnoZo3cyy+/HD/84Q/jmWee6eyxALA+hw8fjnvvvTfuu+++OHr0aG30Wmxo6SR6ncWuKXTF4GVZNnn/9ddfj0cffTQef/zxyLKsk8cBQH9cfvnlcf/998fdd98dOzs7MRqN1jLldRK7cuiaJrk8di+88EJ885vfjDfffHPhrw9Av910003xta99LS6//PLK4LU4prdQ8BaOXVXoyteL01yWZfH444/HD37wA6cKAGyQq666Kr7xjW/ENddcsy94xesR1Ts4L16fO3gLxa4pdOXAjcfjuHDhQjzyyCPxi1/8Yu6vCcBwXXLJJfHwww/HRz/60QOhy9+P6D54c8euLnRVy5ZZlsXbb78d3/nOd+JPf/rTXF8PgDSMRqN48MEH47777psErjzpRXQbvLli1yZ0eeTG43GcPXs2Hn744fjb3/4289cCIE33339/fOELX5jEboZjeTPHbjTrJ0wLXR65/G1vby++//3vCx0A+/zkJz+Jp59+el8zql5opGLz48xT2kyxaxO6cvB++tOfxlNPPTXr4wIgcePxeDIMlQelvCX5x5WDN6vWsWuz67IYur29vXjmmWfi0UcfneuBAZC+c+fOxbe+9a14/fXXY29v78B0V3cO9qzT3czLmGVV01yWZfGPf/wjvve9781dYQA2w2uvvRbf/va349y5c5PglaO36HJmq9i13XmZR+/8+fPx3e9+N86ePTvjUwZgE/3lL3+Jxx57rHI5s4vgzbKMObms25Syt7cXe3t78cQTT8Q///nPmZ8sAJvrV7/6Vbz66qv7pru6jSuzmhq7umpWLV1mWRZnz56Nxx57bK4HA8DmOnfuXPz4xz9unOwiKl+acmoBG2NXt3xZdQAxn+x++ctfxhtvvLHI8wVgQz355JPx8ssvVwYvovp3oLZRG7um43TF94uhO336dPz85z9f4GkCsMmyLItHH320cikzD1+VadPdPCeVVz6ALMviZz/7WZw5c2bWuwSAiZMnT8YLL7xQu5xZNe1N03Y3Zu3GlPzy3Llz8cQTTyz2DAEgIn7zm9/UblKJ2H+ud65pupt2zO7A+3U7MZ977rl455135n5iAJD785//HOfOnTvwiirTNqvUqYxdsY5NU13x7dlnn+3sSQKw2c6cORPPP//8zKcf1E13TRtUDrxftwPzwoULcfLkyXmfEwAc8Oyzzx54RZWmE82bHIhduYrTjtVlWRYvvfRSnDp1qsOnCMCmO3ny5NRXVClqOu+u1TE7S5gArNqpU6fipZdeqvxtCAtNduVz66quF79I/sWff/75zp4cAOSee+65A92JmP3k8rkmu/JS5muvvdbFcwKAfV577bXaya5K3e1TN6hM24l54cKFePvttzt4SgCw36lTpxo3pjQcv9t3Q9UGlcovWBe9U6dO1f5yPQBYxOnTpw9siqwLXdNS5iR2bXZhVk13dmECsCz5QDXvKQe5upPKay/L46TYAbAsp0+frvzt5RHVQ1l+e1mb32d34LI42fl1PgAsS/4bdeZZuiyuWJZPPaj7hNr10rfeemumURIA2sjbknemKXjT4je6+IeVx+uK18vn2816jgMAzKrq/O7OjtkVv0j5/brz7QCgK3UDVvH9qo+r0+qYXdOOTABYhmLQyptT8tvbrjI2nlRe9UnlOy4Gz4QHQNfqdl+2+Zxcq5PKpx0QBIBlatpL0mZH5kynHtSdhgAAy9IUtrYNmhq7ui8qdACsUlN7Fj6pvOmLAsCyNZ0C19bUUw+6GB8BoAvzrio2vjZm1W2WLwFYpabuzH3MziuiANB3bU8mzxV/xU/ndw4AXVnkUNpcG1SEDoB1mLc/c+/GXOSLAsAsFu1NqxeCFjUA1qWLMwFaT3ZVr54CAKuySHcWWsYEgCEQOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTOwCSJ3YAJE/sAEie2AGQPLEDIHliB0DyxA6A5IkdAMkTO4ABGI/H634IgyZ2AAMwHo8jy7J1P4zBEjuAARG8+YgdwMAI3uzEDqDnqo7XCd5sxA5goASvPbED6LmmnZiC147YAQyc4E0ndgA91vb8OsFrJnYAiRC8emIHkJAsy7zaSgWxA+ixecI1Ho8Fr0TsABIkePuJHUBPLRorwfsfsQNImOD9l9gB9FRXkRI8sQPYCJsePLED2BCbHDyxA+ihZUVpU4MndgAbZhODJ3YAPbTsGG1a8MQOYENtUvDEDqBnVhmgTQme2AFsuE0IntgB9Mw6wpN68MQOgIhIO3hiB8BEqsETO4Ae6UNoUgye2AFwQGrBEzsAKo3H48iybN0PoxNiB9AjfZymUgie2AEw1dCDJ3YAPdHHqa5oyMETOwBaG2rwxA6AmQwxeGIH0BN9X8YsGlrwxA6AuQwpeGIHwNyGEjyxA+iBIS1hlg0heGIHwML6HjyxA+iBIU92uT4HT+wA6Exfgyd2AHQqy7LeTapiB7BmfQtDF/r2K4LEDoCl6FPwxA6ApelL8MQOYM36EINl6kPwxA6ApVt38MQOYI3WPfGs0jqDJ3YArMy6gid2AKzUOoIndgBrtEnLmEWrDp7YAbAWqwye2AGwNqsKntgBrMmmLmGWrSJ4YgfA2i07eGIHsCYmu/2WGbydpdwrAMxB7ADYCMsInmVMgDWwhNms6yVNkx0AvZTHrovomewA6K3xeBx7e3sL34/YAayBZczVEjsAkid2ACRP7ABWzBLm6okdAMkTOwCSJ3YAK2YZc/XEDoDkiR3ACpnq1kPsAEie2AGQPLEDWCHLmOshdgAkT+wASJ7YAayIJcz1ETsAkid2ACRP7ABWxDLm+ogdAMkTO4AVMNWtl9gBkDyxAyB5YgewApYx10vsAEie2AGQPLEDWDJLmOsndgAkT+wASJ7YASyZZcz1EzsAkid2ACRP7ACWyBJmP4gdAMkTO4AlMtn1g9gBkDyxAyB5YgewJJYw+0PsAEie2AGQPLEDWBLLmP0hdgAkT+wASJ7YASyBJcx+ETsAkid2AEtgsusXsQMgeWIH0DFTXf+IHQDJEzsAkid2AB2zjNk/YgdA8sQOoEOmun4SOwCSJ3YAJE/sADpkGbOfxA6A5IkdQEdMdf0ldgAkT+wASJ7YAXTEMmZ/iR0AyRM7gA6Y6vpN7ABIntgBkDyxA+iAZcx+EzsAkid2AAsy1fWf2AGQPLEDWJDJrv/EDoDkiR3AAkx1wyB2ACRP7AAWYLIbBrEDIHliBzAnU91wiB0AyRM7gDmZ7IZD7ABIntgBzMFUNyxiB0DyxA5gDia7YRE7AJIndgAkT+wAZmQJc3jEDoDkiR3AjEx2wyN2ACRP7ABmYKobJrEDIHliBzADk90wiR0AyRM7gJZMdcMldgAtid1wiR0AyRM7gBZMdcMmdgAkT+wAWjDZDZvYAUwhdMMndgAkT+wApjDZDZ/YATQQujSIHQDJEzuABia7NIgdAMkTO4Aaprp0iB1ADbFLh9gBkDyxA6hgqkuL2AGQPLEDqGCyS4vYAZQIXXrEDoDkiR1AickuPWIHUCB0aRI7AJIndgAFJrs0iR3ARUKXLrEDuEjs0iV2ACRP7ADCVJc6sQMIsUud2AEbT+jSJ3YAJE/sgI1nskuf2AEbTeg2g9gBG03sNoPYARtL6DaH2AGQPLEDNpbJbnOIHbCRhG6ziB2wkcRus4gdsHGEbvOIHbBxxG7ziB2wUYRuM4kdsFHEbjOJHbAxhG5ziR2wMcRuc4kdsBGEbrOJHbARxG6ziR2QPKFD7ABIntgByTPZIXZA0oSOCLEDEid2RIgdkLAsy9b9EOgJsQOSZKKjSOyAJIkdRWIHJEfoKBM7IDliR5nYAUkROqqIHZCM8XgsdlQSOyAZQkcdsQOSIHQ0ETsgCWJHE7EDBs8rpTCN2AGDZqKjDbEDBk3saEPsgMGyfElbYgcMkomOWYgdMEhixyzEDhgcy5fMSuyAQTHRMQ+xAwbDa18yL7EDBkPomJfYAYPgOB2LEDug94SORYkd0GuWLumC2AG9ZUMKXRE7oJeEji6JHdBLQkeXxA7oHRtS6JrYAb0idCyD2AG9IXQsi9gBvSB0LJPYAWsndCyb2AFrJXSsgtgBayN0rMrOuh8AsHmcMM6qmeyAlRI61kHsgJUROtbFMiawEo7PsU4mO2DphI51M9kBS2PZkr4w2QFLIXT0ickO6JTI0UcmO6AzQkdfmeyAhYkcfSd2wELstGQIxA6Yi2mOIRE7YCYixxCJHdCKyDFkYgc0EjlSIHasXJZlsbW1FRExuaR/RI6UiB0rNxqNJjv48h+m4tcfIkeKxI612Nra2vcDNb9ejJ/wrY7AkTqxYy3ykNX9gC3+8DX1LUf5PxiQMrFjbaYFL1c19ZXvg/ZMcWwisWOt2gavqGr5UwDrmeBA7OiBeYJXJoD/I25wkNjRC10Er2xaAKveH5qq5wgcJHb0xjKCV1a+7/L7fYzhtMcMTCd29Er5lIRVaxuWZUZQzKB7YkfvFE867ytBgmHxm8rppdHIP02gO36i0FuCB3TFTxN6TfCALvhJQu/1YUckMGxiR+95UWhgUWLHIAgesAixYzAED5iX2DEoggfMQ+wYHMEDZiV2DJLYAbMQOwbLOXhAW35aMGiCB7ThJwWDJ3jANH5KkATBgzR19RtGOvkJMR6P/coT1k7wgDoL/3QQOfrELk1ITxedETuS4hw8SEfely6+p2f+TeX5F80vd3d3DwTPDxvWKf/35z9iMEzlQ2NHjx5d+D4bJ7titOoCdvz48YUfBHTNhAdpGI/HnXSm1TJm0w+N48eP26BCLwkeDN9oNIqdnf8uQi7y/bzQMbutra1J7CIsG9E/ggfDlA9R29vbB76H5/menil25eN1Ef9bxiwGT/ToE7GD4Sg2ZDwex+7ubkQs/n0892SXf+FDhw7FkSNHRI5ecw4eDEfek/F4HIcPH+7kPg/8BKia3qY5duxYZFkmePSa4EH/Fae6LMv27cRc5LDE5Lu/audl8Y7z6+UvtrW1FVdfffXkgRWLDH0jeNBfeTeyLJv05IMf/GDtx88Svrl3Yxajd8stt+yLnNDRZ4IH/VXuyJ133lk7jJVvazLzd33VtHfjjTfGzs7OvhoLHn1m0wr0S3lgyrIsLrvssrjkkksioj5ubb+Xp8auakmzfPvu7m584AMfOPBgBY++ckoC9E+5HzfccMOBASs36/fwzMuYdcfxbr755kmNTXcMgeBBP5Qnurwhd9111+Rj6vaNlP88v14208uFFd8fjUb73r/lllsiIg7ETvDoM8GDfijH7vDhw3HixInGwEV0sIzZtD5anuxGo1EcO3Ysrr/++skDNd0xFIIH61McjPb29ib9+NCHPhQRBye6qgmvaQPL1sUrtefZVX3itLd77rknIv473eUPWvAYAsGD9SlOdFmWxWg0igcffHCygjjtFLj8z5qMLn5Q5Ue1CV3xwVx99dVx880373vQgsdQCB6sVnnpMn+7/fbbY2dnp7Y1uaYJr2zfZFd3MnnVHRe/8Gg0mrz/2c9+Nkaj0b7pLg8e9J3YwWqUQ5f34vDhw3HvvfdWtqZpKXOa1rsxq0JXFbwTJ07ErbfeeuAJmO4YCiedw/IVY1fsxF133XVgiKoL3iym7sactpRZfkCj0SjuuuuuOHLkyIHgmfAYCsGD5akKXZZlcezYsbj99ttbha7NZpWi4mtjbhWuR/F6U+TKoct3Zt5zzz2T3TX5m+AxJIIH3SsvXeZvEREPPfTQvpZU9WWWwBW71njqQd0xvKoHUH679dZb47bbbjvwhCxpMiSCB92pCl3ehM985jNx3XXX1TalzUTXFL+ppx7s++DSMbppwbvnnnvi+uuvPzDhFZ8g9J1NK7C4uokuy7L48Ic/HJ/61Kcae1IVvogOTyov17NqU8r29nZsb2/vu769vR07OzvxxS9+Md797ndXPkHBYwickgDzq9p1WezAlVdeGQ888EBlT+qO3eUrLrMEr3zqwVbp/amnGxTfqh7kJZdcEg899NBkw8re3l5cuHBB9BgUwYPZTQvdkSNH4itf+cq+IanclLrJru6E81y5Z5WTXdU3dfmYXV3sytPdaDSKK664Ir70pS/FpZdeOnmiefAuXLjgtTQZBMGD9so7Li9cuDB5y0P31a9+NXZ3d/c1o9yPcgSrljDLmyqrtHoh6KolzDbLmMW3a6+9Nr785S/HVVdddWDCK056gkefCR40K09yxcjlP+OvuOKK+PrXvx4nTpyobUbdcmbVSmPE9KXMrXJYxhdvyG+vezmX4oSWv50/f37fW/G2/Pq5c+fiRz/6Ubz44osHgrnoAUhYFf8pg/9p04v89ptuuik+//nPx87OTuzs7MShQ4cml8W34m07OzuTfSBVS5s1097+w3JV37DF4FX9nqHiiYDF2FXFrer63t5ePP744/G73/0uxuNx662mxScC6yZ4bLJi4PLL/JBU3YuJfPrTn45PfvKTk9CVg1YVu/zjyhNf1QnnEZPVlwOh2Jn2hOpOMB+NRvtCtb29HVmWxfb29r44lq/n7rzzznjPe94Tv/71r+PNN9+cfEzTQUjRo2/KsVvVv0uRZV2qIlc1zRV//h87dizuv//+uO666/aFrhixqqDVDUER1b8Boen7r3Kyu/gExuUn07SzpmrCq7osr9+eP38+fv/738fTTz8dZ86cqTwmWF6jLT4p0WPdsiw7cNss/y6FiyGoi1x5oitGbnd3N+6444647bbb9gWtagmzPMnVLV/WTXVNOzEjpsSu6olVjal1wSsvX1a95Z979uzZePLJJ+PZZ5+N8+fP5w+41XQnfKxbVfBg6MqBy69PexuNRvGRj3wk7r777srzr8tBqwpeOY7FvR1NG1SqQhfRInZ1T65us0rTlNcUu/x+Tp8+Hb/97W/jr3/9a5w+fbr2pWBm2XIKq2BCY+hq9nBMvcyv7+7uxv/93//F5z73uX2nFIxGowNTXTl2VaErLm222c9RF7qIhthdfBKV013T7sxi7PLrdbErfnz5tdKyLIt//etf8dxzz8VLL70Ur776aozH48a4iR3rZsIjReXJLre1tRWXXnppXHfddfGJT3wirrzyysoXGilPdfn1cuzKf15cuqyLXf44Ll7WRqBxg8rW1tbWeDweb21tVYam+CK5xSBub2/vu738ufnnFx9slmWT9/PYve9974v3vve9kWVZvPnmm/H888/Hv//97/jPf/4Tb7/9dpw5cybeeeedyStmQx+Y8PzHMzWHDh2Ko0ePxtGjR+PYsWNx2WWXxTXXXBM33HBDHDp0qPbFRupiV/fWZnPKvJsVGye7iNmWM8sTXtWUV/V+eSmz/Mv8ipcR//vfc/7Q3nrrrTh9+vTkXI6K59DqLwO6UPXvcJYf/rMszYsKXakaSI4cORLHjx+P3d3dykNJxWNnTS8fWXUMrs2uzGmxm7YppWjqqQfT/kKK013bzys/2PyJ7O3t7bssb2HNL/OvmQf3+PHjcfnll0/uX9wAFtO0EXBa7KpeVaspeMWPaTPRVYR56v/62pxnt5VPd1XLmfn7VUuadX9xTX9J+bl2VedrlF9Dc9qBUwBmV7cBsOqt/HO8OJHl8aqb3KpCV/U6mFN247da3mg12TUFLw9T/mfTJr3yX9CisWsKnegBtFe3hF6MTP4zvnwKQNMSZjl4dUuW5dAVL2seb+t1/NbLmMXglZUjVfXAmv5XUPwL2tvbm1xWnYnfdrorEj2AZlXdqDtOV/czfNpSZtUUV7fjsuo8ulk3pRTNdMyubndmfhwtD115a+rW1lbs7e21Cl1+P/nLj9UFL/+65ejltxeJHUCzqg0q+WXT8bq6ya4ueOX4lT+nvPJXt3w5q5k3qBT/IuqCF1G9caX8wIuvhZmHLo9c+UVEy8ErT3WWMQEWN+/xuvyyKmDTLquWLqeFbpYlzIj5dmNuRfz3lIS2wav7i8oDVjxel7+VJ7umY3Y2qAB0p2ITyIHrdfsuqia8umXKNrsuuwhdxAKTXfEvpSp4VRGqi13dppSqJcy6pczi15nyqjCLPmWAQZvWirbTXdMmlbZvVeEsfr2KxzHXOubUk8qnqXpJsfyyHKaqKa0pblWhm2eDSuGxLvRcAVIxa/CmLWVWxW7abVX3Ufxa5cc5b+giOpjsCg+i8mXBImIy6eVPKP+44kuEFSe7cgyrohlxcKqzMQVgfk2bVPLLWSa8utvaHpvrKnQR3Sxj7juGd/H6gfG3ahorhq94vK9qils0dMIHUK0ucsXrs054VZfFZcqmaa7iMSz8unidTXZFVcfxqp5EHqliDIvBKx77swuTFJT/bXbwPQxLUTdl1U1jVZNa06aTVYYuooNjdmXjwh2WA1QVqbpz5preive9yPKlKAKbpm07Zpnuqm6bthu/+Gd1j62r0EUsIXYR9cHL36+bzOomt2nTXNVzEDKA+bQ5dpdfNgWv7rbi7VVfs8vITe5zWVEYV9xx06RXvK3NRDht96XYAcynqjU1m0Yqp7Sm61X3Ubi+tHX9pcUuV45e06TX9v3y/diMAtCtWTetlC+bPr7mPpd6AHvpscu1mfTa3NZ0e9X9AjC7pumu6s/nCVzhtqXv1FpZ7HJtJr26P2vz523+DICD2jRnWvCabq+4r5VtR1557HLTJr2m29s8ZrEDmM0s7ZkWtKb7WmXkJl9z3VGoil7hz5o+b9r9zv+gADbQtAbNOvkVblv7CaVrj13ZvPEDYHVahm/tkcv1LnZlTfEDoD/6FLey3seujggCrFafYzbNYGMHAG39P8QjHPIeCPK8AAAAAElFTkSuQmCC"/>
+    <path id="Canary Badge" d="M112.189,145.49L254.837,81.3501L396.288,145.49C396.288,145.49 396.862,207.984 396.288,231.803C400.997,350.37 312.745,416.946 254.837,430.897C196.973,416.761 109.794,350.592 112.189,231.803C112.756,203.667 112.189,145.49 112.189,145.49ZM175.089,342.14C175.089,342.14 184.466,327.557 200.474,320.28C204.922,315.034 207.831,307.409 215.292,300.115C219.468,296.033 226.552,291.174 233.166,288.656C239.785,286.137 247.648,284.843 255,285C262.352,285.157 268.152,286.319 277.281,289.599C300.356,298.133 328.246,333.945 334.028,349.404C315.038,361.253 296.986,374.343 277.281,397.842C273.2,395.993 262.831,392.31 245.929,394.232C225.332,398.578 205.605,369.407 206.507,353.455C194.408,348.947 175.089,342.14 175.089,342.14ZM239.502,332.155C236.224,332.127 234.144,330.44 233.732,328.884C233.319,327.329 235.679,323.517 237.026,322.821C244.051,319.192 251.916,319.735 251.916,319.735C251.916,319.735 254.299,332.28 239.502,332.155ZM238.929,221.803L270.281,221.803L270.281,254.418L238.929,254.418L238.929,221.803ZM238.929,136.356L270.281,136.356L270.281,205.834L238.929,205.834L238.929,136.356Z" style="fill:rgb(253,237,0);"/>
+</svg>
diff --git a/docs/changelog.md b/docs/changelog.md
index 2215c120..64ebfcf5 100644
--- a/docs/changelog.md
+++ b/docs/changelog.md
@@ -1,11 +1,28 @@
 # Change Log
 
-## Version 2.0 Beta 2 (2019-08-02)
+## Version 2.0 Beta 3 (2019-08-22)
 
-LeakCanary 2 reached **beta status**: the internals and APIs are mostly stable.
+LeakCanary 2 is in **beta**: the internals and APIs are mostly stable.
 
 Now is a great time to adopt it and provide feedback before the stable release. We're counting on you to find bugs and suggest improvements! Check out the new [Getting Started](https://square.github.io/leakcanary/getting_started) instructions and the [migration guide](https://square.github.io/leakcanary/upgrading-to-leakcanary-2.0/). 
 
+* Baseline memory usage for large hprofs divided by 3 and removed memory spikes [#1543](https://github.com/square/leakcanary/pull/1543)
+* Fixed crash when LeakCanary is initialized from another process [#1529](https://github.com/square/leakcanary/issues/1529)
+* Java local references are deprioritized to look for longer alternative paths [#1525](https://github.com/square/leakcanary/pull/1525)
+* Fixed `JavaLocalPattern` not matching on Lollipop [#1524](https://github.com/square/leakcanary/pull/1524)
+
+Many thanks to
+[@Armaxis](https://github.com/Armaxis),
+[@elihart](https://github.com/elihart),
+[@emartynov](https://github.com/emartynov),
+[@hmcgreevy-instil](https://github.com/hmcgreevy-instil),
+[@pyricau](https://github.com/pyricau)
+for the contributions, bug reports and feature requests.
+
+For more details, see the [2.0-beta-3 Milestone](https://github.com/square/leakcanary/milestone/11) and the [full diff](https://github.com/square/leakcanary/compare/v2.0-beta-2...v2.0-beta-3).
+
+## Version 2.0 Beta 2 (2019-08-02)
+
 * Fixed *Leak analysis failed: Object id not found in heap dump.* [#1516](https://github.com/square/leakcanary/issues/1516)
 * 10x speed increase of hprof indexing on large heap dumps [#1520](https://github.com/square/leakcanary/pull/1520)
 
@@ -94,7 +111,7 @@ For more details, see the [2.0-alpha-2 Milestone](https://github.com/square/leak
 
 ## Version 2.0 Alpha 1 (2019-04-23)
 
-<img src="https://github.com/square/leakcanary/wiki/assets/logo-2.0-200px.png" />
+![logo](images/logo-2.0-200px.png)
 
 * New [logo](https://github.com/square/leakcanary/wiki/FAQ#who-made-the-logo), thanks [@flickator](https://github.com/flickator)!
 * Entirely rewritten to **100% Kotlin**
diff --git a/docs/dev-env.md b/docs/dev-env.md
new file mode 100644
index 00000000..3cb7a7bb
--- /dev/null
+++ b/docs/dev-env.md
@@ -0,0 +1,16 @@
+# Dev Environment for LeakCanary contributors
+
+## Setup
+* Download [Android Studio](https://developer.android.com/studio)
+* We use two spaces code indentation, use https://github.com/square/java-code-styles
+* Build with `./gradlew build`
+* Running the failing UI tests to confirm leak detection correctly fails UI tests: `./gradlew leakcanary-sample:connectedCheck`
+* Normal UI tests: `./gradlew leakcanary-support-fragment:connectedCheck`
+
+
+## Static Code Analysis 
+* LeakCanary [uses](https://github.com/square/leakcanary/pull/1535) tool [Detekt](https://arturbosch.github.io/detekt/) for static Code analysis
+* Analyze whole project with `./gradlew check` or particular modules with `./gradlew :module-name:check` 
+* Detekt will fail the build if any ruleset violations are found. **You should fix all issues before pushing the branch to remote**.
+* If you don't - Travis CI build will fail the check for you. A [git push hook](https://github.com/square/leakcanary/issues/1547) will prevent pushing failing builds in future.
+* Detekt report will be printed in console and saved to `/moduleDir/build/reports/
diff --git a/docs/faq.md b/docs/faq.md
index edc8387a..5838b19d 100644
--- a/docs/faq.md
+++ b/docs/faq.md
@@ -46,7 +46,7 @@ Update your dependencies to the latest SNAPSHOT (see [build.gradle](https://gith
 
 ```gradle
  dependencies {
-   debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-beta-3-SNAPSHOT'
+   debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-beta-4-SNAPSHOT'
  }
 ```
 
@@ -78,5 +78,5 @@ The name **LeakCanary** is a reference to the expression [canary in a coal mine]
 * [@flickator](https://github.com/flickator) designed [a much nicer logo](https://github.com/square/leakcanary/pull/1269) for LeakCanary 2.0!
 
 <p align="center">
-<img src="https://github.com/square/leakcanary/wiki/assets/logo-2.0.png" />
+<img src="../images/logo-2.0.png" />
 </p>
diff --git a/docs/getting_started.md b/docs/getting_started.md
index 6ed84eb9..931160fd 100644
--- a/docs/getting_started.md
+++ b/docs/getting_started.md
@@ -5,7 +5,7 @@ Add LeakCanary to `build.gradle`:
 ```groovy
 dependencies {
   // debugImplementation because LeakCanary should only run in debug builds.
-  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-beta-2'
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-beta-3'
 }
 ```
 
diff --git a/docs/contributing.md b/docs/how_to_help.md
similarity index 84%
rename from docs/contributing.md
rename to docs/how_to_help.md
index 956b4d8c..1a00c4e1 100644
--- a/docs/contributing.md
+++ b/docs/how_to_help.md
@@ -1,4 +1,4 @@
-# Contributing
+# How to help
 
 You are most welcome to contribute code, answer [StackOverflow questions](http://stackoverflow.com/questions/tagged/leakcanary?sort=active), help manage GitHub issues and review pull requests.
 
diff --git a/docs/images/logo-2.0-200px.png b/docs/images/logo-2.0-200px.png
new file mode 100644
index 00000000..005fd285
Binary files /dev/null and b/docs/images/logo-2.0-200px.png differ
diff --git a/docs/images/logo-2.0.png b/docs/images/logo-2.0.png
new file mode 100644
index 00000000..e1b3e927
Binary files /dev/null and b/docs/images/logo-2.0.png differ
diff --git a/docs/images/screenshot-2.0.png b/docs/images/screenshot-2.0.png
new file mode 100644
index 00000000..875db14a
Binary files /dev/null and b/docs/images/screenshot-2.0.png differ
diff --git a/docs/images/shark.png b/docs/images/shark.png
new file mode 100644
index 00000000..4afe96f3
Binary files /dev/null and b/docs/images/shark.png differ
diff --git a/docs/index.md b/docs/index.md
index d35383bf..457cfda6 100644
--- a/docs/index.md
+++ b/docs/index.md
@@ -3,7 +3,7 @@
 LeakCanary is a memory leak detection library for Android.
 
 <p align="center">
-<img src="https://github.com/square/leakcanary/wiki/assets/screenshot-2.0.png"/>
+<img src="../images/screenshot-2.0.png" />
 </p>
 
 LeakCanary's knowledge of the internals of the Android Framework gives it a unique ability to narrow down the cause of each leak, helping developers dramatically reduce OutOfMemoryError crashes.
diff --git a/docs/recipes.md b/docs/recipes.md
index 4ea73d80..aee2ba89 100644
--- a/docs/recipes.md
+++ b/docs/recipes.md
@@ -1,6 +1,7 @@
 # Code Recipes
 
-If you think a recipe might be missing or you're not sure that what you're trying to achieve is possible with the current APIs, please [file an issue](https://github.com/square/leakcanary/issues/new/choose). Your feedback help us make LeakCanary better for the entire community.
+!!! bug
+    If you think a recipe might be missing or you're not sure that what you're trying to achieve is possible with the current APIs, please [file an issue](https://github.com/square/leakcanary/issues/new/choose). Your feedback help us make LeakCanary better for the entire community.
 
 ## Watching objects with a lifecycle
 
@@ -20,6 +21,22 @@ class MyService : Service {
 
 ## Configuration
 
+LeakCanary has a default configuration that should work well for most apps. You can also customize it to your needs. The LeakCanary configuration is held by two singleton objects (`AppWatcher` and `LeakCanary`) and can be updated at any time. Most developers configure LeakCanary in their **debug** [Application](https://developer.android.com/reference/android/app/Application) class:
+
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    AppWatcher.config = AppWatcher.config.copy(watchFragmentViews = false)
+  }
+}
+```
+
+
+!!! info
+    You can create a debug application class in your `src/debug/java` folder. Don't forget to also register it in `src/debug/AndroidManifest.xml`.
+
 To customize the detection of retained objects at runtime, update [AppWatcher.config](/leakcanary/api/leakcanary-object-watcher-android/leakcanary/-app-watcher/config/):
 
 ```
@@ -34,16 +51,11 @@ LeakCanary.config = LeakCanary.config.copy(retainedVisibleThreshold = 3)
 
 The LeakCanary UI can be configured by overriding the following resources:
 
-```xml
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-  <public name="leak_canary_display_activity_label" type="string"/>
-  <public name="leak_canary_heap_dump_toast" type="layout"/>
-  <public name="leak_canary_icon" type="mipmap"/>
-  <public name="leak_canary_add_dynamic_shortcut" type="bool"/>
-  <public name="leak_canary_add_launcher_icon" type="bool"/>
-</resources>
-```
+* `mipmap/leak_canary_icon` see [Icon and label](#icon-and-label)
+* `string/leak_canary_display_activity_label` see [Icon and label](#icon-and-label)
+* `bool/leak_canary_add_dynamic_shortcut` see [Disabling LeakCanary](#disabling-leakcanary)
+* `bool/leak_canary_add_launcher_icon` see [Disabling LeakCanary](#disabling-leakcanary)
+* `layout/leak_canary_heap_dump_toast` the layout for the toast shown when the heap is dumped
 
 ## Disabling LeakCanary
 
@@ -61,13 +73,13 @@ Sometimes it's necessary to disable LeakCanary temporarily, for example for a pr
 
 ## Counting retained instances in production
 
-`com.squareup.leakcanary:leakcanary-android` should only be used in debug builds. It depends on `com.squareup.leakcanary:leakcanary-object-watcher-android` which you can use in production to track and count retained instances.
+The `com.squareup.leakcanary:leakcanary-android` dependency should only be used in debug builds. It depends on `com.squareup.leakcanary:leakcanary-object-watcher-android` which you can use in production to track and count retained instances.
 
 In your `build.gradle`:
 
 ```gradle
 dependencies {
-  implementation 'com.squareup.leakcanary:leakcanary-object-watcher-android:2.0-beta-2'
+  implementation 'com.squareup.leakcanary:leakcanary-object-watcher-android:2.0-beta-3'
 }
 ```
 
@@ -258,6 +270,6 @@ You can now add the LeakCanary dependency for that configuration:
 
 ```
 dependencies {
-  devDebugImplementation "com.squareup.leakcanary:leakcanary-android:${leakCanaryVersion}"
+  devDebugImplementation "com.squareup.leakcanary:leakcanary-android:${version}"
 }
 ```
diff --git a/docs/releasing.md b/docs/releasing.md
new file mode 100644
index 00000000..4626d973
--- /dev/null
+++ b/docs/releasing.md
@@ -0,0 +1,112 @@
+# Releasing LeakCanary
+
+* Create a local release branch from `master`
+```
+git checkout master
+git pull
+git checkout -b release_1.5
+```
+
+* Update `VERSION_NAME` in `gradle.properties` (remove `-SNAPSHOT`)
+```gradle
+VERSION_NAME = "1.5"
+```
+
+* Find all doc references to the current version and update them:
+
+```
+grep -R "2.0-beta-2" docs/
+```
+
+* Generate the Dokka docs
+
+```
+rm -rf docs/api
+./gradlew shark:dokka shark-android:dokka leakcanary-android-core:dokka leakcanary-android-instrumentation:dokka leakcanary-android-process:dokka shark-graph:dokka shark-hprof:dokka leakcanary-object-watcher-android:dokka shark-log:dokka leakcanary-object-watcher:dokka
+```
+
+* Update `docs/changelog.md` after checking out all changes:
+    * https://github.com/square/leakcanary/compare/v1.4...master
+* Take one last look
+```
+git diff
+```
+
+* Commit all local changes
+```
+git commit -am "Prepare 1.5 release"
+```
+
+* Perform a clean build
+```
+./gradlew clean build
+```
+
+* Create a tag and push it
+```
+git tag v1.5
+git push origin v1.5
+```
+
+* Make sure you have valid credentials to upload the artifacts
+
+`~/.gradle/gradle.properties`
+```
+SONATYPE_NEXUS_USERNAME=
+SONATYPE_NEXUS_PASSWORD=
+```
+
+* Upload the artifacts to Sonatype OSS Nexus
+
+```
+./gradlew uploadArchives --no-daemon --no-parallel
+```
+
+* Generate the CLI zip
+
+```
+./gradlew shark-cli:distZip
+```
+
+* Release to Maven Central
+    * Login to Sonatype OSS Nexus: https://oss.sonatype.org/
+    * Click on **Staging Repositories**
+    * Scroll to the bottom, you should see an entry named `comsquareup-XXXX`
+    * Check the box next to the `comsquareup-XXXX` entry, click **Close** then **Confirm**
+    * Wait a bit, hit **Refresh**, until the *Status* for that column changes to *Closed*.
+    * Check the box next to the `comsquareup-XXXX` entry, click **Release** then **Confirm**
+* Merge the release branch to master
+```
+git checkout master
+git pull
+git merge --no-ff release_1.5
+```
+* Update `VERSION_NAME` in `gradle.properties` (increase version and add `-SNAPSHOT`)
+```gradle
+VERSION_NAME = "2.0-alpha-4-SNAPSHOT"
+```
+* Update the snapshot version in `docs/faq.md`:
+```gradle
+ dependencies {
+   debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-4-SNAPSHOT'
+ }
+```
+* Commit your changes
+```
+git commit -am "Prepare for next development iteration"
+```
+
+* Push your changes
+```
+git push
+```
+
+* Go to [Milestones](https://github.com/square/leakcanary/milestones), rename the current release to the version just released, and create a new *Next Release* milestone.
+* Wait for the release to be available [on Maven Central](https://repo1.maven.org/maven2/com/squareup/leakcanary/leakcanary-android/).
+* Redeploy the docs: `mkdocs serve` to check locally, `mkdocs gh-deploy` to deploy.
+* Go to the [Draft a new release](https://github.com/square/leakcanary/releases/new) page, enter the release name (v1.5) as tag and title, and have the description point to the changelog. You can find the direct anchor URL from the [Change Log](https://square.github.io/leakcanary/changelog) page on the doc site.
+```
+See [Change Log](https://square.github.io/leakcanary/changelog#version-20-alpha-2-2019-05-21)
+```
+* Add the CLIP zip from `shark-cli/build/distributions/` to the release. Update the documentation to point to it.
+* Tell your friends, update all of your apps, and tweet the new release. As a nice extra touch, mention external contributions.
\ No newline at end of file
diff --git a/docs/shark.md b/docs/shark.md
index 1998bac7..70896b75 100644
--- a/docs/shark.md
+++ b/docs/shark.md
@@ -4,7 +4,7 @@
 **Shark**: **<span style="color:#c757bc;">S</span><span style="color:#c858b7;">m</span><span style="color:#ca5ab2;">a</span><span style="color:#cb5bad;">r</span><span style="color:#cc5ca9;">t</span><span style="color:#ce5ea4;"> </span><span style="color:#cf5f9f;">H</span><span style="color:#d0609a;">e</span><span style="color:#d26295;">a</span><span style="color:#d36390;">p</span><span style="color:#d4658c;"> </span><span style="color:#d66687;">A</span><span style="color:#d76782;">n</span><span style="color:#d8697d;">a</span><span style="color:#da6a78;">l</span><span style="color:#db6b73;">y</span><span style="color:#dc6d6f;">s</span><span style="color:#de6e6a;">i</span><span style="color:#df6f65;">s</span><span style="color:#e07160;"> </span><span style="color:#e1725b;">R</span><span style="color:#e37356;">e</span><span style="color:#e47552;">p</span><span style="color:#e5764d;">o</span><span style="color:#e77748;">r</span><span style="color:#e87943;">t</span><span style="color:#e97a3e;">s</span><span style="color:#eb7b39;"> </span><span style="color:#ec7d35;">f</span><span style="color:#ed7e30;">o</span><span style="color:#ef802b;">r</span><span style="color:#f08126;"> </span><span style="color:#f18221;">K</span><span style="color:#f3841c;">o</span><span style="color:#f48518;">t</span><span style="color:#f58613;">l</span><span style="color:#f7880e;">i</span><span style="color:#f88909;">n</span>**
 
 <p align="center">
-<img src="https://github.com/square/leakcanary/wiki/assets/shark.png" />
+<img src="../images/shark.png" />
 </p>
 
 Shark is the heap analyzer that powers LeakCanary 2. It's a Kotlin standalone heap analysis library that runs at **high speed** with a **low memory footprint**.
@@ -31,7 +31,7 @@ A few more things:
 
 The Shark Command Line Interface (CLI) enables you to analyze heaps directly from your computer. It can dump the heap of an app installed on a connected Android device, analyze it, and even strip a heap dump of any sensitive data (e.g. PII, passwords or encryption keys) which is useful when sharing a heap dump.
 
-Download it [here](https://github.com/square/leakcanary/releases/download/v2.0-beta-2/shark-cli-2.0-beta-2.zip)!
+Download it [here](https://github.com/square/leakcanary/releases/download/v2.0-beta-3/shark-cli-2.0-beta-3.zip)!
 
 Usage instructions:
 
diff --git a/docs/upgrading-to-leakcanary-2.0.md b/docs/upgrading-to-leakcanary-2.0.md
index 7f2d5906..d982bac0 100644
--- a/docs/upgrading-to-leakcanary-2.0.md
+++ b/docs/upgrading-to-leakcanary-2.0.md
@@ -22,7 +22,7 @@ dependencies {
 
 ```groovy
 dependencies {
-  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-beta-2'
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-beta-3'
 }
 ```
 
@@ -85,7 +85,7 @@ If you were using `RefWatcher` in non debug code, you now get a compile error be
 
 ```groovy
 dependencies {
-  implementation 'com.squareup.leakcanary:leakcanary-object-watcher-android:2.0-beta-2'
+  implementation 'com.squareup.leakcanary:leakcanary-object-watcher-android:2.0-beta-3'
 }
 ```
 
diff --git a/gradle.properties b/gradle.properties
index 151e678d..3e75d3bd 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -1,7 +1,7 @@
 GROUP=com.squareup.leakcanary
-VERSION_NAME=2.0-beta-3-SNAPSHOT
+VERSION_NAME=2.0-beta-4-SNAPSHOT
 
-POM_DESCRIPTION=Leak Canary
+POM_DESCRIPTION=LeakCanary
 
 POM_URL=http://github.com/square/leakcanary/
 POM_SCM_URL=http://github.com/square/leakcanary/
diff --git a/gradle/checkstyle.gradle b/gradle/checkstyle.gradle
deleted file mode 100644
index afc5281a..00000000
--- a/gradle/checkstyle.gradle
+++ /dev/null
@@ -1,23 +0,0 @@
-apply plugin: 'checkstyle'
-
-checkstyle {
-  configFile rootProject.file('checkstyle.xml')
-  ignoreFailures false
-  showViolations true
-}
-
-task checkstyle(type: Checkstyle) {
-  configFile rootProject.file('checkstyle.xml')
-  source 'src/main/java'
-  ignoreFailures false
-  showViolations true
-  include '**/*.java'
-
-  classpath = files()
-}
-
-afterEvaluate {
-  if (project.tasks.getByName("check")) {
-    check.dependsOn('checkstyle')
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-android-core/build.gradle b/leakcanary-android-core/build.gradle
index 4ab7a345..26d64a86 100644
--- a/leakcanary-android-core/build.gradle
+++ b/leakcanary-android-core/build.gradle
@@ -33,5 +33,4 @@ android {
   }
 }
 
-apply from: rootProject.file('gradle/checkstyle.gradle')
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
index 7e490e4a..e663e4f1 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
@@ -47,7 +47,7 @@ import shark.LeakTrace
 import shark.LeakTraceElement
 import shark.LeakTraceElement.Type.STATIC_FIELD
 
-@Suppress("DEPRECATION")
+@Suppress("DEPRECATION", "TooManyFunctions")
 internal class DisplayLeakAdapter constructor(
   context: Context,
   private val leakTrace: LeakTrace,
@@ -216,6 +216,7 @@ internal class DisplayLeakAdapter constructor(
     return builder
   }
 
+  @Suppress("ReturnCount")
   private fun getConnectorType(position: Int): Type {
     if (isFirstConnectorRow(position)) {
       return if (isLeakGroup) HELP_LEAK_GROUP else HELP
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
index 846e068e..a5b480a3 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
@@ -17,6 +17,7 @@ import leakcanary.internal.NotificationReceiver.Action.DUMP_HEAP
 import leakcanary.internal.NotificationType.LEAKCANARY_LOW
 import shark.SharkLog
 
+@Suppress("TooManyFunctions")
 internal class HeapDumpTrigger(
   private val application: Application,
   private val backgroundHandler: Handler,
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
index e5180ca9..1154888f 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
@@ -113,6 +113,7 @@ internal object InternalLeakCanary : (Application) -> Unit, OnObjectRetainedList
     }
   }
 
+  @Suppress("ReturnCount")
   private fun addDynamicShortcut(application: Application) {
     if (VERSION.SDK_INT < VERSION_CODES.N_MR1) {
       return
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
index 352012de..e8132152 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
@@ -56,12 +56,12 @@ internal class LeakDirectoryProvider constructor(
 
     val externalFiles = externalStorageDirectory().listFiles(filter)
     if (externalFiles != null) {
-      files.addAll(Arrays.asList(*externalFiles))
+      files.addAll(externalFiles)
     }
 
     val appFiles = appStorageDirectory().listFiles(filter)
     if (appFiles != null) {
-      files.addAll(Arrays.asList(*appFiles))
+      files.addAll(appFiles)
     }
     return files
   }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/Notifications.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/Notifications.kt
index 9db6e924..a636bea2 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/Notifications.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/Notifications.kt
@@ -36,6 +36,7 @@ internal object Notifications {
     !InternalLeakCanary.application.packageManager.isInstantApp
   } else true
 
+  @Suppress("LongParameterList")
   fun showNotification(
     context: Context,
     contentTitle: CharSequence,
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/Serializables.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/Serializables.kt
index 19800a17..b5cefe21 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/Serializables.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/Serializables.kt
@@ -17,12 +17,7 @@ internal object Serializables {
   inline fun <reified T> fromByteArray(byteArray: ByteArray): T? {
     val inputStream = ByteArrayInputStream(byteArray)
     return try {
-      val deserializedObject = ObjectInputStream(inputStream).readObject()
-      if (deserializedObject is T) {
-        deserializedObject
-      } else {
-        null
-      }
+      ObjectInputStream(inputStream).readObject() as? T
     } catch (ignored: Throwable) {
       null
     }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/SquigglySpan.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/SquigglySpan.kt
index a817e24b..68e59a65 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/SquigglySpan.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/SquigglySpan.kt
@@ -113,6 +113,7 @@ internal class SquigglySpan(context: Context) : ReplacementSpan() {
       }
     }
 
+    @Suppress("LongParameterList")
     private fun squigglyHorizontalPath(
       path: Path,
       left: Float,
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt
index 4f7c8db6..50582257 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakViews.kt
@@ -50,10 +50,10 @@ internal fun View.shareToStackOverflow(content: String) {
   // AsyncTask was needed here due to setPrimaryClip making a disk write which
   // violated StrictMode if on the main thread
   AsyncTask.execute {
-    clipboard.primaryClip = ClipData.newPlainText(
+    clipboard.setPrimaryClip(ClipData.newPlainText(
         context.getString(R.string.leak_canary_leak_clipdata_label),
         "```\n$content```"
-    )
+    ))
   }
   Toast.makeText(context, R.string.leak_canary_leak_copied, Toast.LENGTH_LONG)
       .show()
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
index 4cc1d5bb..daa827f4 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
@@ -46,6 +46,7 @@ internal object HeapDumpRenderer {
       get() = this * density
   }
 
+  @Suppress("LongMethod")
   fun render(
     context: Context,
     heapDumpFile: File,
diff --git a/leakcanary-android-instrumentation/build.gradle b/leakcanary-android-instrumentation/build.gradle
index 02f90246..e8cb5436 100644
--- a/leakcanary-android-instrumentation/build.gradle
+++ b/leakcanary-android-instrumentation/build.gradle
@@ -28,5 +28,4 @@ android {
   }
 }
 
-apply from: rootProject.file('gradle/checkstyle.gradle')
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/AnalysisDurationTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/IndexingTest.kt
similarity index 100%
rename from leakcanary-android-instrumentation/src/androidTest/java/leakcanary/AnalysisDurationTest.kt
rename to leakcanary-android-instrumentation/src/androidTest/java/leakcanary/IndexingTest.kt
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
index 6705c5cf..faff166a 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
@@ -95,6 +95,7 @@ class InstrumentationLeakDetector {
   /**
    * Looks for retained objects, triggers a heap dump if needed and performs an analysis.
    */
+  @Suppress("ReturnCount")
   fun detectLeaks(): Result {
     val leakDetectionTime = SystemClock.uptimeMillis()
     val watchDurationMillis = AppWatcher.config.watchDurationMillis
diff --git a/leakcanary-android-process/build.gradle b/leakcanary-android-process/build.gradle
index 2c2b98eb..a21e2b5e 100644
--- a/leakcanary-android-process/build.gradle
+++ b/leakcanary-android-process/build.gradle
@@ -20,5 +20,4 @@ android {
   }
 }
 
-apply from: rootProject.file('gradle/checkstyle.gradle')
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-android-process/src/main/java/leakcanary/LeakCanaryProcess.kt b/leakcanary-android-process/src/main/java/leakcanary/LeakCanaryProcess.kt
index edfd6257..4f14b7d2 100644
--- a/leakcanary-android-process/src/main/java/leakcanary/LeakCanaryProcess.kt
+++ b/leakcanary-android-process/src/main/java/leakcanary/LeakCanaryProcess.kt
@@ -44,6 +44,7 @@ object LeakCanaryProcess {
     return isInAnalyzerProcess
   }
 
+  @Suppress("ReturnCount")
   private fun isInServiceProcess(
     context: Context,
     serviceClass: Class<out Service>
diff --git a/leakcanary-android/build.gradle b/leakcanary-android/build.gradle
index 2c2b98eb..a21e2b5e 100644
--- a/leakcanary-android/build.gradle
+++ b/leakcanary-android/build.gradle
@@ -20,5 +20,4 @@ android {
   }
 }
 
-apply from: rootProject.file('gradle/checkstyle.gradle')
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-object-watcher-android-androidx/build.gradle b/leakcanary-object-watcher-android-androidx/build.gradle
index afa37c48..99f4467d 100644
--- a/leakcanary-object-watcher-android-androidx/build.gradle
+++ b/leakcanary-object-watcher-android-androidx/build.gradle
@@ -22,5 +22,4 @@ android {
   }
 }
 
-apply from: rootProject.file('gradle/checkstyle.gradle')
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-object-watcher-android/build.gradle b/leakcanary-object-watcher-android/build.gradle
index 2ba1e7b4..f7eb35a0 100644
--- a/leakcanary-object-watcher-android/build.gradle
+++ b/leakcanary-object-watcher-android/build.gradle
@@ -26,5 +26,4 @@ android {
   }
 }
 
-apply from: rootProject.file('gradle/checkstyle.gradle')
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-object-watcher-android/src/main/AndroidManifest.xml b/leakcanary-object-watcher-android/src/main/AndroidManifest.xml
index c11c5661..db08981e 100644
--- a/leakcanary-object-watcher-android/src/main/AndroidManifest.xml
+++ b/leakcanary-object-watcher-android/src/main/AndroidManifest.xml
@@ -7,7 +7,7 @@
   <application>
     <provider
         android:name="leakcanary.internal.AppWatcherInstaller"
-        android:authorities="${applicationId}.leak-sentry-installer"
+        android:authorities="${applicationId}.leakcanary-installer"
         android:exported="false"/>
   </application>
 </manifest>
diff --git a/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/DefaultCanaryLog.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
index e9c09d52..66ed25de 100644
--- a/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
+++ b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
@@ -9,17 +9,12 @@ internal class DefaultCanaryLog : Logger {
     message: String,
     vararg args: Any?
   ) {
-    val formatted = if (args.isNotEmpty()) {
-      String.format(message, *args)
-    } else {
-      message
-    }
+    val formatted = if (args.isNotEmpty()) String.format(message, *args) else message
+
     if (formatted.length < 4000) {
       Log.d("LeakCanary", formatted)
     } else {
-      val lines = formatted.split("\n".toRegex())
-          .toTypedArray()
-      for (line in lines) {
+      formatted.split(NEW_LINE_REGEX).forEach {line ->
         Log.d("LeakCanary", line)
       }
     }
@@ -36,4 +31,8 @@ internal class DefaultCanaryLog : Logger {
         )
     )
   }
+
+  companion object {
+    val NEW_LINE_REGEX = "\n".toRegex()
+  }
 }
\ No newline at end of file
diff --git a/leakcanary-object-watcher/build.gradle b/leakcanary-object-watcher/build.gradle
index e61c3f3c..57d9c255 100644
--- a/leakcanary-object-watcher/build.gradle
+++ b/leakcanary-object-watcher/build.gradle
@@ -12,5 +12,4 @@ dependencies {
   testImplementation deps.junit
 }
 
-apply from: rootProject.file('gradle/checkstyle.gradle')
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/leakcanary-object-watcher/src/main/java/leakcanary/ObjectWatcher.kt b/leakcanary-object-watcher/src/main/java/leakcanary/ObjectWatcher.kt
index 77326949..18fa4766 100644
--- a/leakcanary-object-watcher/src/main/java/leakcanary/ObjectWatcher.kt
+++ b/leakcanary-object-watcher/src/main/java/leakcanary/ObjectWatcher.kt
@@ -136,7 +136,8 @@ class ObjectWatcher constructor(
       KeyedWeakReference(watchedObject, key, name, watchUptimeMillis, queue)
     SharkLog.d(
         "Watching %s with key %s",
-        ((if (watchedObject is Class<*>) watchedObject.toString() else "instance of ${watchedObject.javaClass.name}") + if (name.isNotEmpty()) " named $name" else ""),
+        ((if (watchedObject is Class<*>) watchedObject.toString() else "instance of ${watchedObject.javaClass.name}") +
+            if (name.isNotEmpty()) " named $name" else ""),
         key
     )
 
diff --git a/mkdocs.yml b/mkdocs.yml
index 7f66932a..7edc2f4b 100644
--- a/mkdocs.yml
+++ b/mkdocs.yml
@@ -54,8 +54,11 @@ nav:
     - 'Recorded Presentations': recorded-presentations.md
     - 'Blog Articles': blog-articles.md
     - 'Stack Overflow ': https://stackoverflow.com/questions/tagged/leakcanary?sort=active
-    - 'Contributing': contributing.md
-    - 'Code of Conduct': code_of_conduct.md
+    - 'Contributing':
+        - 'How to help': how_to_help.md
+        - 'Code of Conduct': code_of_conduct.md
+        - 'Dev Environment': dev-env.md
+        - 'Releasing': releasing.md
   - 'Shark':
     - 'Overview': shark.md
     - 'Shark API':
diff --git a/shark-android/build.gradle b/shark-android/build.gradle
index 61694414..b4532853 100644
--- a/shark-android/build.gradle
+++ b/shark-android/build.gradle
@@ -14,5 +14,4 @@ dependencies {
   testImplementation deps.okio
 }
 
-apply from: rootProject.file('gradle/checkstyle.gradle')
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/shark-android/src/main/java/shark/AndroidObjectInspectors.kt b/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
index 01826916..5808425b 100644
--- a/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
+++ b/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
@@ -417,6 +417,7 @@ private fun ObjectReporter.applyFromField(
  * Recursively unwraps `this` [HeapInstance] as a ContextWrapper until an Activity is found in which case it is
  * returned. Returns null if no activity was found.
  */
+@Suppress("NestedBlockDepth")
 fun HeapInstance.unwrapActivityContext(): HeapInstance? {
   if (this instanceOf "android.app.Activity") {
     return this
diff --git a/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt b/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt
index 49c92ec2..5fa0f797 100644
--- a/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt
+++ b/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt
@@ -686,7 +686,8 @@ enum class AndroidReferenceMatchers {
           "mContext"
           ,
           description =
-          "SemClipboardManager is held in memory by an anonymous inner class" + " implementation of android.os.Binder, thereby leaking an activity context."
+          "SemClipboardManager is held in memory by an anonymous inner class" +
+            " implementation of android.os.Binder, thereby leaking an activity context."
       ) {
         manufacturer == SAMSUNG && sdkInt in 19..24
       }
@@ -695,7 +696,8 @@ enum class AndroidReferenceMatchers {
           "this$0"
           ,
           description =
-          "SemClipboardManager is held in memory by an anonymous inner class" + " implementation of android.os.Binder, thereby leaking an activity context."
+          "SemClipboardManager is held in memory by an anonymous inner class" +
+            " implementation of android.os.Binder, thereby leaking an activity context."
       ) {
         manufacturer == SAMSUNG && sdkInt in 22..28
       }
@@ -743,7 +745,8 @@ enum class AndroidReferenceMatchers {
           "com.samsung.android.emergencymode.SemEmergencyManager", "mContext"
           ,
           description =
-          "SemEmergencyManager is a static singleton that leaks a DecorContext." + " Fix: https://gist.github.com/jankovd/a210460b814c04d500eb12025902d60d"
+          "SemEmergencyManager is a static singleton that leaks a DecorContext." +
+            " Fix: https://gist.github.com/jankovd/a210460b814c04d500eb12025902d60d"
       ) {
         manufacturer == SAMSUNG && sdkInt in 19..24
       }
@@ -907,7 +910,8 @@ enum class AndroidReferenceMatchers {
           "android.gestureboost.GestureBoostManager", "mContext"
           ,
           description =
-          "GestureBoostManager is a static singleton that leaks an activity context." + " Fix: https://github.com/square/leakcanary/issues/696#issuecomment-296420756"
+          "GestureBoostManager is a static singleton that leaks an activity context." +
+            " Fix: https://github.com/square/leakcanary/issues/696#issuecomment-296420756"
       ) {
         manufacturer == HUAWEI && sdkInt in 24..25
       }
diff --git a/shark-cli/build.gradle b/shark-cli/build.gradle
index 16b662c3..533e9f79 100644
--- a/shark-cli/build.gradle
+++ b/shark-cli/build.gradle
@@ -26,5 +26,4 @@ jar {
   }
 }
 
-apply from: rootProject.file('gradle/checkstyle.gradle')
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/shark-graph/build.gradle b/shark-graph/build.gradle
index 122838ce..257db8e0 100644
--- a/shark-graph/build.gradle
+++ b/shark-graph/build.gradle
@@ -14,5 +14,4 @@ dependencies {
   testImplementation deps.junit
 }
 
-apply from: rootProject.file('gradle/checkstyle.gradle')
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/HprofHeapGraph.kt b/shark-graph/src/main/java/shark/HprofHeapGraph.kt
index c99f8c7f..978829de 100644
--- a/shark-graph/src/main/java/shark/HprofHeapGraph.kt
+++ b/shark-graph/src/main/java/shark/HprofHeapGraph.kt
@@ -25,6 +25,7 @@ import shark.internal.LruCache
 /**
  * A [HeapGraph] that reads from an indexed [Hprof]. Create a new instance with [indexHprof].
  */
+@Suppress("TooManyFunctions")
 class HprofHeapGraph internal constructor(
   private val hprof: Hprof,
   private val index: HprofInMemoryIndex
@@ -184,7 +185,7 @@ class HprofHeapGraph internal constructor(
 
   companion object {
     fun indexHprof(hprof: Hprof): HeapGraph {
-      val index = HprofInMemoryIndex.createReadingHprof(hprof.reader)
+      val index = HprofInMemoryIndex.createReadingHprof(hprof)
       return HprofHeapGraph(hprof, index)
     }
   }
diff --git a/shark-graph/src/main/java/shark/internal/ByteSubArray.kt b/shark-graph/src/main/java/shark/internal/ByteSubArray.kt
new file mode 100644
index 00000000..6222e13a
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/ByteSubArray.kt
@@ -0,0 +1,95 @@
+package shark.internal
+
+/**
+ * Provides read access to a sub part of a larger array.
+ */
+internal class ByteSubArray(
+  private val array: ByteArray,
+  private val range: IntRange,
+  private val longIdentifiers: Boolean
+) {
+  private val endInclusive = range.endInclusive - range.start
+
+  val size = endInclusive + 1
+  private var currentIndex = 0
+
+  fun readByte(): Byte {
+    val index = currentIndex
+    currentIndex++
+    require(index in 0..endInclusive) {
+      "Index $index should be between 0 and $endInclusive"
+    }
+    return array[range.first + index]
+  }
+
+  fun readId(): Long {
+    return if (longIdentifiers) {
+      readLong()
+    } else {
+      readInt().toLong()
+    }
+  }
+
+  fun readInt(): Int {
+    val index = currentIndex
+    currentIndex += 4
+    require(index >= 0 && index <= endInclusive - 3) {
+      "Index $index should be between 0 and ${endInclusive - 3}"
+    }
+    return array.readInt(range.first + index)
+  }
+
+  fun readTruncatedLong(byteCount: Int): Long {
+    val index = currentIndex
+    currentIndex += byteCount
+    require(index >= 0 && index <= endInclusive - (byteCount - 1)) {
+      "Index $index should be between 0 and ${endInclusive - (byteCount - 1)}"
+    }
+    var pos = range.first + index
+    val array = array
+
+    var value = 0L
+    for (shift in ((byteCount - 1) * 8) downTo 8 step 8) {
+      value = value or (array[pos++] and 0xffL shl shift)
+    }
+    value = value or (array[pos] and 0xffL)
+    return value
+  }
+
+  fun readLong(): Long {
+    val index = currentIndex
+    currentIndex += 8
+    require(index >= 0 && index <= endInclusive - 7) {
+      "Index $index should be between 0 and ${endInclusive - 7}"
+    }
+    return array.readLong(range.first + index)
+  }
+}
+
+internal fun ByteArray.readInt(index: Int): Int {
+  var pos = index
+  val array = this
+  return (array[pos++] and 0xff shl 24
+      or (array[pos++] and 0xff shl 16)
+      or (array[pos++] and 0xff shl 8)
+      or (array[pos] and 0xff))
+}
+
+internal fun ByteArray.readLong(index: Int): Long {
+  var pos = index
+  val array = this
+  return (array[pos++] and 0xffL shl 56
+      or (array[pos++] and 0xffL shl 48)
+      or (array[pos++] and 0xffL shl 40)
+      or (array[pos++] and 0xffL shl 32)
+      or (array[pos++] and 0xffL shl 24)
+      or (array[pos++] and 0xffL shl 16)
+      or (array[pos++] and 0xffL shl 8)
+      or (array[pos] and 0xffL))
+}
+
+@Suppress("NOTHING_TO_INLINE") // Syntactic sugar.
+private inline infix fun Byte.and(other: Long): Long = toLong() and other
+
+@Suppress("NOTHING_TO_INLINE") // Syntactic sugar.
+private inline infix fun Byte.and(other: Int): Int = toInt() and other
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
index c7dd5485..fdcc0c87 100644
--- a/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
+++ b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
@@ -10,21 +10,13 @@ import shark.GcRoot.NativeStack
 import shark.GcRoot.StickyClass
 import shark.GcRoot.ThreadBlock
 import shark.GcRoot.ThreadObject
-import shark.HprofReader
+import shark.Hprof
 import shark.HprofRecord
 import shark.HprofRecord.HeapDumpRecord.GcRootRecord
-import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
-import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
-import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
-import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
-import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
-import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
-import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
-import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
-import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
-import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassSkipContentRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceSkipContentRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArraySkipContentRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArraySkipContentRecord
 import shark.HprofRecord.LoadClassRecord
 import shark.HprofRecord.StringRecord
 import shark.OnHprofRecordListener
@@ -41,10 +33,15 @@ import kotlin.reflect.KClass
 /**
  * This class is not thread safe, should be used from a single thread.
  */
+@Suppress("TooManyFunctions")
 internal class HprofInMemoryIndex private constructor(
+  private val positionSize: Int,
   private val hprofStringCache: LongObjectScatterMap<String>,
   private val classNames: LongLongScatterMap,
-  private val objectIndex: LongObjectScatterMap<IndexedObject>,
+  private val classIndex: SortedBytesMap,
+  private val instanceIndex: SortedBytesMap,
+  private val objectArrayIndex: SortedBytesMap,
+  private val primitiveArrayIndex: SortedBytesMap,
   private val gcRoots: List<GcRoot>,
   val primitiveWrapperTypes: Set<Long>
 ) {
@@ -62,9 +59,10 @@ internal class HprofInMemoryIndex private constructor(
 
   fun classId(className: String): Long? {
     // Note: this performs two linear scans over arrays
-    return hprofStringCache.entrySequence()
+    val hprofStringId = hprofStringCache.entrySequence()
         .firstOrNull { it.second == className }
-        ?.first?.let { stringId ->
+        ?.first
+    return hprofStringId?.let { stringId ->
       classNames.entrySequence()
           .firstOrNull { it.second == stringId }
           ?.first
@@ -72,19 +70,63 @@ internal class HprofInMemoryIndex private constructor(
   }
 
   fun indexedClassSequence(): Sequence<Pair<Long, IndexedClass>> {
-    return objectIndex.entrySequence()
-        .filter { it.second is IndexedClass }
-        .map { it.first to it.second as IndexedClass }
+    return classIndex.entrySequence()
+        .map {
+          val id = it.first
+          val array = it.second
+          id to IndexedClass(
+              position = array.readTruncatedLong(positionSize),
+              superclassId = array.readId(),
+              instanceSize = array.readInt()
+          )
+        }
   }
 
   fun indexedInstanceSequence(): Sequence<Pair<Long, IndexedInstance>> {
-    return objectIndex.entrySequence()
-        .filter { it.second is IndexedInstance }
-        .map { it.first to it.second as IndexedInstance }
+    return instanceIndex.entrySequence()
+        .map {
+          val id = it.first
+          val array = it.second
+          val instance = IndexedInstance(
+              position = array.readTruncatedLong(positionSize),
+              classId = array.readId()
+          )
+          id to instance
+        }
+  }
+
+  fun indexedObjectArraySequence(): Sequence<Pair<Long, IndexedObjectArray>> {
+    return objectArrayIndex.entrySequence()
+        .map {
+          val id = it.first
+          val array = it.second
+          val objectArray = IndexedObjectArray(
+              position = array.readTruncatedLong(positionSize),
+              arrayClassId = array.readId()
+          )
+          id to objectArray
+        }
+  }
+
+  fun indexedPrimitiveArraySequence(): Sequence<Pair<Long, IndexedPrimitiveArray>> {
+    return primitiveArrayIndex.entrySequence()
+        .map {
+          val id = it.first
+          val array = it.second
+
+          val primitiveArray = IndexedPrimitiveArray(
+              position = array.readTruncatedLong(positionSize),
+              primitiveType = PrimitiveType.values()[array.readByte().toInt()]
+          )
+          id to primitiveArray
+        }
   }
 
   fun indexedObjectSequence(): Sequence<Pair<Long, IndexedObject>> {
-    return objectIndex.entrySequence()
+    return indexedClassSequence() +
+        indexedInstanceSequence() +
+        indexedObjectArraySequence() +
+        indexedPrimitiveArraySequence()
   }
 
   fun gcRoots(): List<GcRoot> {
@@ -92,27 +134,85 @@ internal class HprofInMemoryIndex private constructor(
   }
 
   fun indexedObject(objectId: Long): IndexedObject {
-    return objectIndex[objectId] ?: throw IllegalArgumentException(
+    return indexedObjectOrNull(objectId) ?: throw IllegalArgumentException(
         "Object id $objectId not found in heap dump."
     )
   }
 
+  @Suppress("ReturnCount")
+  private fun indexedObjectOrNull(objectId: Long): IndexedObject? {
+    var array: ByteSubArray? = classIndex[objectId]
+    if (array != null) {
+      return IndexedClass(
+          position = array.readTruncatedLong(positionSize),
+          superclassId = array.readId(),
+          instanceSize = array.readInt()
+      )
+    }
+    array = instanceIndex[objectId]
+    if (array != null) {
+      return IndexedInstance(
+          position = array.readTruncatedLong(positionSize),
+          classId = array.readId()
+      )
+    }
+    array = objectArrayIndex[objectId]
+    if (array != null) {
+      return IndexedObjectArray(
+          position = array.readTruncatedLong(positionSize),
+          arrayClassId = array.readId()
+      )
+    }
+    array = primitiveArrayIndex[objectId]
+    if (array != null) {
+      return IndexedPrimitiveArray(
+          position = array.readTruncatedLong(positionSize),
+          primitiveType = PrimitiveType.values()[array.readByte().toInt()]
+      )
+    }
+    return null
+  }
+
+  @Suppress("ReturnCount")
   fun objectIdIsIndexed(objectId: Long): Boolean {
-    return objectIndex[objectId] != null
+    if (classIndex[objectId] != null) {
+      return true
+    }
+    if (instanceIndex[objectId] != null) {
+      return true
+    }
+    if (objectArrayIndex[objectId] != null) {
+      return true
+    }
+    if (primitiveArrayIndex[objectId] != null) {
+      return true
+    }
+    return false
   }
 
   private class Builder(
+    longIdentifiers: Boolean,
+    fileLength: Long,
+    classCount: Int,
+    instanceCount: Int,
+    objectArrayCount: Int,
+    primitiveArrayCount: Int,
     private val indexedGcRootsTypes: Set<KClass<out GcRoot>>
   ) : OnHprofRecordListener {
+
+    private val identifierSize = if (longIdentifiers) 8 else 4
+    private val positionSize = byteSizeForUnsigned(fileLength)
+
     /**
      * Map of string id to string
      * This currently keeps all the hprof strings that we could care about: class names,
      * static field names and instance fields names
      */
     // TODO Replacing with a radix trie reversed into a sparse array of long to trie leaf could save
-    // memory.
-    // Another option is to switch back to reading from the file system as necessary, and keep a much
-    // smaller cache for strings we need during shortest path (those are for exclusions)
+    // memory. Can be stored as 3 arrays: array of keys, array of values which are indexes into
+    // a large array of string bytes. Each "entry" consists of a size, the index of the previous
+    // segment and then the segment content.
+
     private val hprofStringCache = LongObjectScatterMap<String>()
 
     /**
@@ -120,12 +220,26 @@ internal class HprofInMemoryIndex private constructor(
      */
     private val classNames = LongLongScatterMap()
 
-    /**
-     * Object id to [IndexedObject].
-     * The id can be for classes instances, classes, object arrays and primitive arrays
-     */
-    private val objectIndex =
-      LongObjectScatterMap<IndexedObject>()
+    private val classIndex = UnsortedByteEntries(
+        bytesPerValue = positionSize + identifierSize + 4,
+        longIdentifiers = longIdentifiers,
+        initialCapacity = classCount
+    )
+    private val instanceIndex = UnsortedByteEntries(
+        bytesPerValue = positionSize + identifierSize,
+        longIdentifiers = longIdentifiers,
+        initialCapacity = instanceCount
+    )
+    private val objectArrayIndex = UnsortedByteEntries(
+        bytesPerValue = positionSize + identifierSize,
+        longIdentifiers = longIdentifiers,
+        initialCapacity = objectArrayCount
+    )
+    private val primitiveArrayIndex = UnsortedByteEntries(
+        bytesPerValue = positionSize + 1,
+        longIdentifiers = longIdentifiers,
+        initialCapacity = primitiveArrayCount
+    )
 
     /**
      * Class ids for primitive wrapper types
@@ -163,35 +277,49 @@ internal class HprofInMemoryIndex private constructor(
             gcRoots += gcRoot
           }
         }
-        is ClassDumpRecord -> {
-          objectIndex[record.id] = IndexedClass(position, record.superclassId, record.instanceSize)
+        is ClassSkipContentRecord -> {
+          classIndex.append(record.id)
+              .apply {
+                writeTruncatedLong(position, positionSize)
+                writeId(record.superclassId)
+                writeInt(record.instanceSize)
+              }
         }
-        is InstanceDumpRecord -> {
-          objectIndex[record.id] = IndexedInstance(position, record.classId)
+        is InstanceSkipContentRecord -> {
+          instanceIndex.append(record.id)
+              .apply {
+                writeTruncatedLong(position, positionSize)
+                writeId(record.classId)
+              }
         }
-        is ObjectArrayDumpRecord -> {
-          objectIndex[record.id] = IndexedObjectArray(position, record.arrayClassId)
+        is ObjectArraySkipContentRecord -> {
+          objectArrayIndex.append(record.id)
+              .apply {
+                writeTruncatedLong(position, positionSize)
+                writeId(record.arrayClassId)
+              }
         }
-        is PrimitiveArrayDumpRecord -> {
-          val primitiveType = when (record) {
-            is BooleanArrayDump -> PrimitiveType.BOOLEAN
-            is CharArrayDump -> PrimitiveType.CHAR
-            is FloatArrayDump -> PrimitiveType.FLOAT
-            is DoubleArrayDump -> PrimitiveType.DOUBLE
-            is ByteArrayDump -> PrimitiveType.BYTE
-            is ShortArrayDump -> PrimitiveType.SHORT
-            is IntArrayDump -> PrimitiveType.INT
-            is LongArrayDump -> PrimitiveType.LONG
-          }
-          objectIndex[record.id] = IndexedPrimitiveArray(position, primitiveType)
+        is PrimitiveArraySkipContentRecord -> {
+          primitiveArrayIndex.append(record.id)
+              .apply {
+                writeTruncatedLong(position, positionSize)
+                writeByte(record.type.ordinal.toByte())
+              }
         }
       }
     }
 
     fun buildIndex(): HprofInMemoryIndex {
+      val sortedInstanceIndex = instanceIndex.moveToSortedMap()
+      val sortedObjectArrayIndex = objectArrayIndex.moveToSortedMap()
+      val sortedPrimitiveArrayIndex = primitiveArrayIndex.moveToSortedMap()
+      val sortedClassIndex = classIndex.moveToSortedMap()
       // Passing references to avoid copying the underlying data structures.
       return HprofInMemoryIndex(
-          hprofStringCache, classNames, objectIndex, gcRoots,
+          positionSize,
+          hprofStringCache, classNames, sortedClassIndex, sortedInstanceIndex,
+          sortedObjectArrayIndex,
+          sortedPrimitiveArrayIndex, gcRoots,
           primitiveWrapperTypes
       )
     }
@@ -206,8 +334,18 @@ internal class HprofInMemoryIndex private constructor(
         Int::class.java.name, Long::class.java.name
     )
 
+    private fun byteSizeForUnsigned(maxValue: Long): Int {
+      var value = maxValue
+      var byteCount = 0
+      while (value != 0L) {
+        value = value shr 8
+        byteCount++
+      }
+      return byteCount
+    }
+
     fun createReadingHprof(
-      reader: HprofReader,
+      hprof: Hprof,
       indexedGcRootTypes: Set<KClass<out GcRoot>> = setOf(
           JniGlobal::class,
           JavaFrame::class,
@@ -239,14 +377,42 @@ internal class HprofInMemoryIndex private constructor(
       val recordTypes = setOf(
           StringRecord::class,
           LoadClassRecord::class,
-          ClassDumpRecord::class,
-          InstanceDumpRecord::class,
-          ObjectArrayDumpRecord::class,
-          PrimitiveArrayDumpRecord::class,
+          ClassSkipContentRecord::class,
+          InstanceSkipContentRecord::class,
+          ObjectArraySkipContentRecord::class,
+          PrimitiveArraySkipContentRecord::class,
           GcRootRecord::class
       )
-      val indexBuilderListener = Builder(indexedGcRootTypes)
+      val reader = hprof.reader
+
+      // First pass to count and correctly size arrays once and for all.
+      var classCount = 0
+      var instanceCount = 0
+      var objectArrayCount = 0
+      var primitiveArrayCount = 0
+      reader.readHprofRecords(setOf(
+          LoadClassRecord::class,
+          InstanceSkipContentRecord::class,
+          ObjectArraySkipContentRecord::class,
+          PrimitiveArraySkipContentRecord::class
+      ), OnHprofRecordListener { position, record ->
+        when (record) {
+          is LoadClassRecord -> classCount++
+          is InstanceSkipContentRecord -> instanceCount++
+          is ObjectArraySkipContentRecord -> objectArrayCount++
+          is PrimitiveArraySkipContentRecord -> primitiveArrayCount++
+        }
+      })
+
+      hprof.moveReaderTo(reader.startPosition)
+      val indexBuilderListener =
+        Builder(
+            reader.identifierByteSize == 8, hprof.fileLength, classCount, instanceCount,
+            objectArrayCount, primitiveArrayCount, indexedGcRootTypes
+        )
+
       reader.readHprofRecords(recordTypes, indexBuilderListener)
+
       return indexBuilderListener.buildIndex()
     }
 
diff --git a/shark-graph/src/main/java/shark/internal/SortedBytesMap.kt b/shark-graph/src/main/java/shark/internal/SortedBytesMap.kt
new file mode 100644
index 00000000..d3488191
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/SortedBytesMap.kt
@@ -0,0 +1,73 @@
+package shark.internal
+
+/**
+ * A read only map of `id` => `byte array` sorted by id, where `id` is a long if [longIdentifiers]
+ * is true and an int otherwise. Each entry has a value byte array of size [bytesPerValue].
+ *
+ * Instances are created by [UnsortedByteEntries]
+ *
+ * [get] and [contains] perform a binary search to locate a specific entry by key.
+ */
+internal class SortedBytesMap(
+  private val longIdentifiers: Boolean,
+  private val bytesPerValue: Int,
+  private val sortedEntries: ByteArray
+) {
+  private val bytesPerKey = if (longIdentifiers) 8 else 4
+  private val bytesPerEntry = bytesPerKey + bytesPerValue
+
+  private val size = sortedEntries.size / bytesPerEntry
+
+  operator fun get(key: Long): ByteSubArray? {
+    val keyIndex = binarySearch(key)
+    if (keyIndex < 0) {
+      return null
+    }
+    val valueIndex = keyIndex * bytesPerEntry + bytesPerKey
+    return ByteSubArray(
+        sortedEntries, valueIndex until valueIndex + bytesPerValue, longIdentifiers
+    )
+  }
+
+  operator fun contains(key: Long): Boolean {
+    val keyIndex = binarySearch(key)
+    return keyIndex >= 0
+  }
+
+  fun entrySequence(): Sequence<Pair<Long, ByteSubArray>> {
+    return (0 until size).asSequence()
+        .map { keyIndex ->
+          val valueIndex = keyIndex * bytesPerEntry + bytesPerKey
+          keyAt(keyIndex) to ByteSubArray(
+              sortedEntries, valueIndex until valueIndex + bytesPerValue, longIdentifiers
+          )
+        }
+  }
+
+  private fun binarySearch(
+    key: Long
+  ): Int {
+    val startIndex = 0
+    val endIndex = size
+    var lo = startIndex
+    var hi = endIndex - 1
+    while (lo <= hi) {
+      val mid = (lo + hi).ushr(1)
+      val midVal = keyAt(mid)
+      when {
+        midVal < key -> lo = mid + 1
+        midVal > key -> hi = mid - 1
+        else -> return mid
+      }
+    }
+    return lo.inv()
+  }
+
+  private fun keyAt(index: Int): Long {
+    val keyIndex = index * bytesPerEntry
+    return if (longIdentifiers)
+      sortedEntries.readLong(keyIndex)
+    else
+      sortedEntries.readInt(keyIndex).toLong()
+  }
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/internal/UnsortedByteEntries.kt b/shark-graph/src/main/java/shark/internal/UnsortedByteEntries.kt
new file mode 100644
index 00000000..698ca66a
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/UnsortedByteEntries.kt
@@ -0,0 +1,192 @@
+package shark.internal
+
+import shark.internal.aosp.ByteArrayComparator
+import shark.internal.aosp.ByteArrayTimSort
+
+/**
+ * Wraps a byte array of entries where each entry is an id followed by bytes for the value.
+ * `id` is a long if [longIdentifiers] is true and an int otherwise. Each entry has [bytesPerValue]
+ * value bytes. Entries are appended into the array via [append]. Once done, the backing array
+ * is sorted and turned into a [SortedBytesMap] by calling [moveToSortedMap].
+ */
+internal class UnsortedByteEntries(
+  private val bytesPerValue: Int,
+  private val longIdentifiers: Boolean,
+  private val initialCapacity: Int = 4,
+  private val growthFactor: Double = 2.0
+) {
+
+  private val bytesPerEntry = bytesPerValue + if (longIdentifiers) 8 else 4
+
+  private var entries: ByteArray? = null
+  private val subArray = MutableByteSubArray()
+  private var subArrayIndex = 0
+
+  private var assigned: Int = 0
+  private var currentCapacity = 0
+
+  fun append(
+    key: Long
+  ): MutableByteSubArray {
+    if (entries == null) {
+      currentCapacity = initialCapacity
+      entries = ByteArray(currentCapacity * bytesPerEntry)
+    } else {
+      if (currentCapacity == assigned) {
+        val newCapacity = (currentCapacity * growthFactor).toInt()
+        growEntries(newCapacity)
+        currentCapacity = newCapacity
+      }
+    }
+    assigned++
+    subArrayIndex = 0
+    subArray.writeId(key)
+    return subArray
+  }
+
+  fun moveToSortedMap(): SortedBytesMap {
+    if (assigned == 0) {
+      return SortedBytesMap(longIdentifiers, bytesPerValue, ByteArray(0))
+    }
+    val entries = entries!!
+    // Sort entries by keys, which are ids of 4 or 8 bytes.
+    ByteArrayTimSort.sort(entries, 0, assigned, bytesPerEntry, object : ByteArrayComparator {
+      override fun compare(
+        entrySize: Int,
+        o1Array: ByteArray,
+        o1Index: Int,
+        o2Array: ByteArray,
+        o2Index: Int
+      ): Int {
+        return if (longIdentifiers) {
+          readLong(o1Array, o1Index * entrySize)
+              .compareTo(
+                  readLong(o2Array, o2Index * entrySize)
+              )
+        } else {
+          readInt(o1Array, o1Index * entrySize)
+              .compareTo(
+                  readInt(o2Array, o2Index * entrySize)
+              )
+        }
+      }
+    })
+    val sortedEntries = if (entries.size > assigned * bytesPerEntry) {
+      entries.copyOf(assigned * bytesPerEntry)
+    } else entries
+    this.entries = null
+    assigned = 0
+    return SortedBytesMap(
+        longIdentifiers, bytesPerValue, sortedEntries
+    )
+  }
+
+  private fun readInt(
+    array: ByteArray,
+    index: Int
+  ): Int {
+    var pos = index
+    return (array[pos++] and 0xff shl 24
+        or (array[pos++] and 0xff shl 16)
+        or (array[pos++] and 0xff shl 8)
+        or (array[pos] and 0xff))
+  }
+
+  @Suppress("NOTHING_TO_INLINE") // Syntactic sugar.
+  private inline infix fun Byte.and(other: Long): Long = toLong() and other
+
+  @Suppress("NOTHING_TO_INLINE") // Syntactic sugar.
+  private inline infix fun Byte.and(other: Int): Int = toInt() and other
+
+  private fun readLong(
+    array: ByteArray,
+    index: Int
+  ): Long {
+    var pos = index
+    return (array[pos++] and 0xffL shl 56
+        or (array[pos++] and 0xffL shl 48)
+        or (array[pos++] and 0xffL shl 40)
+        or (array[pos++] and 0xffL shl 32)
+        or (array[pos++] and 0xffL shl 24)
+        or (array[pos++] and 0xffL shl 16)
+        or (array[pos++] and 0xffL shl 8)
+        or (array[pos] and 0xffL))
+  }
+
+  private fun growEntries(newCapacity: Int) {
+    val newEntries = ByteArray(newCapacity * bytesPerEntry)
+    System.arraycopy(entries, 0, newEntries, 0, assigned * bytesPerEntry)
+    entries = newEntries
+  }
+
+  internal inner class MutableByteSubArray {
+    fun writeByte(value: Byte) {
+      val index = subArrayIndex
+      subArrayIndex++
+      require(index in 0..bytesPerEntry) {
+        "Index $index should be between 0 and $bytesPerEntry"
+      }
+      val valuesIndex = ((assigned - 1) * bytesPerEntry) + index
+      entries!![valuesIndex] = value
+    }
+
+    fun writeId(value: Long) {
+      if (longIdentifiers) {
+        writeLong(value)
+      } else {
+        writeInt(value.toInt())
+      }
+    }
+
+    fun writeInt(value: Int) {
+      val index = subArrayIndex
+      subArrayIndex += 4
+      require(index >= 0 && index <= bytesPerEntry - 4) {
+        "Index $index should be between 0 and ${bytesPerEntry - 4}"
+      }
+      var pos = ((assigned - 1) * bytesPerEntry) + index
+      val values = entries!!
+      values[pos++] = (value ushr 24 and 0xff).toByte()
+      values[pos++] = (value ushr 16 and 0xff).toByte()
+      values[pos++] = (value ushr 8 and 0xff).toByte()
+      values[pos] = (value and 0xff).toByte()
+    }
+
+    fun writeTruncatedLong(
+      value: Long,
+      byteCount: Int
+    ) {
+      val index = subArrayIndex
+      subArrayIndex += byteCount
+      require(index >= 0 && index <= bytesPerEntry - byteCount) {
+        "Index $index should be between 0 and ${bytesPerEntry - byteCount}"
+      }
+      var pos = ((assigned - 1) * bytesPerEntry) + index
+      val values = entries!!
+      for (shift in ((byteCount - 1) * 8) downTo 8 step 8) {
+        values[pos++] = (value ushr shift and 0xffL).toByte()
+      }
+      values[pos] = (value and 0xffL).toByte()
+    }
+
+    fun writeLong(value: Long) {
+      val index = subArrayIndex
+      subArrayIndex += 8
+      require(index >= 0 && index <= bytesPerEntry - 8) {
+        "Index $index should be between 0 and ${bytesPerEntry - 8}"
+      }
+      var pos = ((assigned - 1) * bytesPerEntry) + index
+      val values = entries!!
+      values[pos++] = (value ushr 56 and 0xffL).toByte()
+      values[pos++] = (value ushr 48 and 0xffL).toByte()
+      values[pos++] = (value ushr 40 and 0xffL).toByte()
+      values[pos++] = (value ushr 32 and 0xffL).toByte()
+      values[pos++] = (value ushr 24 and 0xffL).toByte()
+      values[pos++] = (value ushr 16 and 0xffL).toByte()
+      values[pos++] = (value ushr 8 and 0xffL).toByte()
+      values[pos] = (value and 0xffL).toByte()
+    }
+  }
+
+}
+
diff --git a/shark-graph/src/main/java/shark/internal/aosp/ByteArrayComparator.kt b/shark-graph/src/main/java/shark/internal/aosp/ByteArrayComparator.kt
new file mode 100644
index 00000000..b77672d4
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/aosp/ByteArrayComparator.kt
@@ -0,0 +1,15 @@
+package shark.internal.aosp
+
+internal interface ByteArrayComparator {
+
+  /**
+   * Indexes are divided by entrySize
+   */
+  fun compare(
+    entrySize: Int,
+    o1Array: ByteArray,
+    o1Index: Int,
+    o2Array: ByteArray,
+    o2Index: Int
+  ): Int
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/internal/aosp/ByteArrayTimSort.kt b/shark-graph/src/main/java/shark/internal/aosp/ByteArrayTimSort.kt
new file mode 100644
index 00000000..11b13604
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/aosp/ByteArrayTimSort.kt
@@ -0,0 +1,1073 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package shark.internal.aosp
+
+/*
+This is TimSort.java from AOSP (Jelly Bean MR2, Apache 2 license), converted to Kotlin and adapted
+to work with byte array chunks. The passed in byte array is virtually divided into entries of a
+fixed number of bytes N. Each entry is compared by a custom comparator.
+
+ Copied from https://android.googlesource.com/platform/libcore/+/jb-mr2-release/luni/src/main/java/java/util/TimSort.java
+*/
+
+/**
+ * A stable, adaptive, iterative mergesort that requires far fewer than
+ * n lg(n) comparisons when running on partially sorted arrays, while
+ * offering performance comparable to a traditional mergesort when run
+ * on random arrays.  Like all proper mergesorts, this sort is stable and
+ * runs O(n log n) time (worst case).  In the worst case, this sort requires
+ * temporary storage space for n/2 object references; in the best case,
+ * it requires only a small constant amount of space.
+ *
+ * This implementation was adapted from Tim Peters's list sort for
+ * Python, which is described in detail here:
+ *
+ * http://svn.python.org/projects/python/trunk/Objects/listsort.txt
+ *
+ * Tim's C code may be found here:
+ *
+ * http://svn.python.org/projects/python/trunk/Objects/listobject.c
+ *
+ * The underlying techniques are described in this paper (and may have
+ * even earlier origins):
+ *
+ * "Optimistic Sorting and Information Theoretic Complexity"
+ * Peter McIlroy
+ * SODA (Fourth Annual ACM-SIAM Symposium on Discrete Algorithms),
+ * pp 467-474, Austin, Texas, 25-27 January 1993.
+ *
+ * While the API to this class consists solely of static methods, it is
+ * (privately) instantiable; a TimSort instance holds the state of an ongoing
+ * sort, assuming the input array is large enough to warrant the full-blown
+ * TimSort. Small arrays are sorted in place, using a binary insertion sort.
+ */
+@Suppress("ComplexMethod", "ComplexCondition", "LongMethod", "LongParameterList")
+internal class ByteArrayTimSort
+/**
+ * Creates a TimSort instance to maintain the state of an ongoing sort.
+ *
+ * @param a the array to be sorted
+ * @param c the comparator to determine the order of the sort
+ */
+private constructor(
+  /**
+   * The array being sorted.
+   */
+  private val a: ByteArray,
+  /**
+   * The comparator for this sort.
+   */
+  private val c: ByteArrayComparator,
+
+  private val entrySize: Int
+) {
+  /**
+   * This controls when we get *into* galloping mode.  It is initialized
+   * to MIN_GALLOP.  The mergeLo and mergeHi methods nudge it higher for
+   * random data, and lower for highly structured data.
+   */
+  private var minGallop = MIN_GALLOP
+  /**
+   * Temp storage for merges.
+   */
+  private var tmp: ByteArray? = null // Actual runtime type will be Object[], regardless of T
+  /**
+   * A stack of pending runs yet to be merged.  Run i starts at
+   * address base[i] and extends for len[i] elements.  It's always
+   * true (so long as the indices are in bounds) that:
+   *
+   * runBase[i] + runLen[i] == runBase[i + 1]
+   *
+   * so we could cut the storage for this, but it's a minor amount,
+   * and keeping all the info explicit simplifies the code.
+   */
+  private var stackSize = 0  // Number of pending runs on stack
+  private val runBase: IntArray
+  private val runLen: IntArray
+
+  init {
+    // Allocate temp storage (which may be increased later if necessary)
+    val len = a.size / entrySize
+    val newArray = ByteArray(
+        entrySize *
+            if (len < 2 * INITIAL_TMP_STORAGE_LENGTH)
+              len.ushr(1)
+            else
+              INITIAL_TMP_STORAGE_LENGTH
+    )
+    tmp = newArray
+    /*
+         * Allocate runs-to-be-merged stack (which cannot be expanded).  The
+         * stack length requirements are described in listsort.txt.  The C
+         * version always uses the same stack length (85), but this was
+         * measured to be too expensive when sorting "mid-sized" arrays (e.g.,
+         * 100 elements) in Java.  Therefore, we use smaller (but sufficiently
+         * large) stack lengths for smaller arrays.  The "magic numbers" in the
+         * computation below must be changed if MIN_MERGE is decreased.  See
+         * the MIN_MERGE declaration above for more information.
+         */
+    val stackLen = if (len < 120)
+      5
+    else if (len < 1542)
+      10
+    else if (len < 119151) 19 else 40
+    runBase = IntArray(stackLen)
+    runLen = IntArray(stackLen)
+  }
+
+  /**
+   * Pushes the specified run onto the pending-run stack.
+   *
+   * @param runBase index of the first element in the run
+   * @param runLen  the number of elements in the run
+   */
+  private fun pushRun(
+    runBase: Int,
+    runLen: Int
+  ) {
+    this.runBase[stackSize] = runBase
+    this.runLen[stackSize] = runLen
+    stackSize++
+  }
+
+  /**
+   * Examines the stack of runs waiting to be merged and merges adjacent runs
+   * until the stack invariants are reestablished:
+   *
+   * 1. runLen[i - 3] > runLen[i - 2] + runLen[i - 1]
+   * 2. runLen[i - 2] > runLen[i - 1]
+   *
+   * This method is called each time a new run is pushed onto the stack,
+   * so the invariants are guaranteed to hold for i < stackSize upon
+   * entry to the method.
+   */
+  // Fixed with http://www.envisage-project.eu/proving-android-java-and-python-sorting-algorithm-is-broken-and-how-to-fix-it/
+  private fun mergeCollapse() {
+    while (stackSize > 1) {
+      var n = stackSize - 2
+      if (n >= 1 && runLen[n - 1] <= runLen[n] + runLen[n + 1] || n >= 2 && runLen[n - 2] <= runLen[n] + runLen[n - 1]) {
+        if (runLen[n - 1] < runLen[n + 1])
+          n--
+      } else if (runLen[n] > runLen[n + 1]) {
+        break // Invariant is established
+      }
+      mergeAt(n)
+    }
+  }
+
+  /**
+   * Merges all runs on the stack until only one remains.  This method is
+   * called once, to complete the sort.
+   */
+  private fun mergeForceCollapse() {
+    while (stackSize > 1) {
+      var n = stackSize - 2
+      if (n > 0 && runLen[n - 1] < runLen[n + 1])
+        n--
+      mergeAt(n)
+    }
+  }
+
+  /**
+   * Merges the two runs at stack indices i and i+1.  Run i must be
+   * the penultimate or antepenultimate run on the stack.  In other words,
+   * i must be equal to stackSize-2 or stackSize-3.
+   *
+   * @param i stack index of the first of the two runs to merge
+   */
+  private fun mergeAt(i: Int) {
+    if (DEBUG) assert(stackSize >= 2)
+    if (DEBUG) assert(i >= 0)
+    if (DEBUG) assert(i == stackSize - 2 || i == stackSize - 3)
+    var base1 = runBase[i]
+    var len1 = runLen[i]
+    val base2 = runBase[i + 1]
+    var len2 = runLen[i + 1]
+    if (DEBUG) assert(len1 > 0 && len2 > 0)
+    if (DEBUG) assert(base1 + len1 == base2)
+    /*
+         * Record the length of the combined runs; if i is the 3rd-last
+         * run now, also slide over the last run (which isn't involved
+         * in this merge).  The current run (i+1) goes away in any case.
+         */
+    runLen[i] = len1 + len2
+    if (i == stackSize - 3) {
+      runBase[i + 1] = runBase[i + 2]
+      runLen[i + 1] = runLen[i + 2]
+    }
+    stackSize--
+    /*
+         * Find where the first element of run2 goes in run1. Prior elements
+         * in run1 can be ignored (because they're already in place).
+         */
+    val k = gallopRight(a, base2, a, base1, len1, 0, entrySize, c)
+    if (DEBUG) assert(k >= 0)
+    base1 += k
+    len1 -= k
+    if (len1 == 0)
+      return
+    /*
+         * Find where the last element of run1 goes in run2. Subsequent elements
+         * in run2 can be ignored (because they're already in place).
+         */
+    len2 = gallopLeft(a, base1 + len1 - 1, a, base2, len2, len2 - 1, entrySize, c)
+    if (DEBUG) assert(len2 >= 0)
+    if (len2 == 0)
+      return
+    // Merge remaining runs, using tmp array with min(len1, len2) elements
+    if (len1 <= len2)
+      mergeLo(base1, len1, base2, len2)
+    else
+      mergeHi(base1, len1, base2, len2)
+  }
+
+  /**
+   * Merges two adjacent runs in place, in a stable fashion.  The first
+   * element of the first run must be greater than the first element of the
+   * second run (a[base1] > a[base2]), and the last element of the first run
+   * (a[base1 + len1-1]) must be greater than all elements of the second run.
+   *
+   * For performance, this method should be called only when len1 <= len2;
+   * its twin, mergeHi should be called if len1 >= len2.  (Either method
+   * may be called if len1 == len2.)
+   *
+   * @param base1 index of first element in first run to be merged
+   * @param len1  length of first run to be merged (must be > 0)
+   * @param base2 index of first element in second run to be merged
+   * (must be aBase + aLen)
+   * @param len2  length of second run to be merged (must be > 0)
+   */
+  private fun mergeLo(
+    base1: Int,
+    len1: Int,
+    base2: Int,
+    len2: Int
+  ) {
+    var len1 = len1
+    var len2 = len2
+    if (DEBUG) assert(len1 > 0 && len2 > 0 && base1 + len1 == base2)
+    // Copy first run into temp array
+    val a = this.a // For performance
+    val entrySize = entrySize
+    val tmp = ensureCapacity(len1)
+    System.arraycopy(a, base1 * entrySize, tmp, 0, len1 * entrySize)
+    var cursor1 = 0       // Indexes into tmp array
+    var cursor2 = base2   // Indexes int a
+    var dest = base1      // Indexes int a
+    // Move first element of second run and deal with degenerate cases
+    val destIndex = dest * entrySize
+    val cursor2Index = cursor2 * entrySize
+    for (i in 0 until entrySize) {
+      a[destIndex + i] = a[cursor2Index + i]
+    }
+    dest++
+    cursor2++
+
+    if (--len2 == 0) {
+      System.arraycopy(tmp, cursor1 * entrySize, a, dest * entrySize, len1 * entrySize)
+      return
+    }
+    if (len1 == 1) {
+      System.arraycopy(a, cursor2 * entrySize, a, dest * entrySize, len2 * entrySize)
+      val destLen2Index = (dest + len2) * entrySize
+      val cursor1Index = cursor1 * entrySize
+      for (i in 0 until entrySize) {
+        a[destLen2Index + i] = tmp[cursor1Index + i] // Last elt of run 1 to end of merge
+      }
+      return
+    }
+    val c = this.c  // Use local variable for performance
+    var minGallop = this.minGallop    //  "    "       "     "      "
+    outer@ while (true) {
+      var count1 = 0 // Number of times in a row that first run won
+      var count2 = 0 // Number of times in a row that second run won
+      /*
+       * Do the straightforward thing until (if ever) one run starts
+       * winning consistently.
+       */
+      do {
+        if (DEBUG) assert(len1 > 1 && len2 > 0)
+        if (c.compare(entrySize, a, cursor2, tmp, cursor1) < 0) {
+          val destIndex = dest * entrySize
+          val cursor2Index = cursor2 * entrySize
+          for (i in 0 until entrySize) {
+            a[destIndex + i] = a[cursor2Index + i]
+          }
+          dest++
+          cursor2++
+          count2++
+          count1 = 0
+          if (--len2 == 0)
+            break@outer
+        } else {
+          val destIndex = dest * entrySize
+          val cursor1Index = cursor1 * entrySize
+          for (i in 0 until entrySize) {
+            a[destIndex + i] = tmp[cursor1Index + i]
+          }
+          dest++
+          cursor1++
+          count1++
+          count2 = 0
+          if (--len1 == 1)
+            break@outer
+        }
+      } while (count1 or count2 < minGallop)
+      /*
+             * One run is winning so consistently that galloping may be a
+             * huge win. So try that, and continue galloping until (if ever)
+             * neither run appears to be winning consistently anymore.
+             */
+      do {
+        if (DEBUG) assert(len1 > 1 && len2 > 0)
+        count1 = gallopRight(a, cursor2, tmp, cursor1, len1, 0, entrySize, c)
+        if (count1 != 0) {
+          System.arraycopy(tmp, cursor1 * entrySize, a, dest * entrySize, count1 * entrySize)
+          dest += count1
+          cursor1 += count1
+          len1 -= count1
+          if (len1 <= 1)
+          // len1 == 1 || len1 == 0
+            break@outer
+        }
+        var destIndex = dest * entrySize
+        val cursor2Index = cursor2 * entrySize
+        for (i in 0 until entrySize) {
+          a[destIndex + i] = a[cursor2Index + i]
+        }
+        dest++
+        cursor2++
+        if (--len2 == 0)
+          break@outer
+        count2 = gallopLeft(tmp, cursor1, a, cursor2, len2, 0, entrySize, c)
+        if (count2 != 0) {
+          System.arraycopy(a, cursor2 * entrySize, a, dest * entrySize, count2 * entrySize)
+          dest += count2
+          cursor2 += count2
+          len2 -= count2
+          if (len2 == 0)
+            break@outer
+        }
+        destIndex = dest * entrySize
+        val cursor1Index = cursor1 * entrySize
+        for (i in 0 until entrySize) {
+          a[destIndex + i] = tmp[cursor1Index + i]
+        }
+        dest++
+        cursor1++
+        if (--len1 == 1)
+          break@outer
+        minGallop--
+      } while ((count1 >= MIN_GALLOP) or (count2 >= MIN_GALLOP))
+      if (minGallop < 0)
+        minGallop = 0
+      minGallop += 2  // Penalize for leaving gallop mode
+    }  // End of "outer" loop
+    this.minGallop = if (minGallop < 1) 1 else minGallop  // Write back to field
+    if (len1 == 1) {
+      if (DEBUG) assert(len2 > 0)
+      System.arraycopy(a, cursor2 * entrySize, a, dest * entrySize, len2 * entrySize)
+      val destLen2Index = (dest + len2) * entrySize
+      val cursor1Index = cursor1 * entrySize
+      for (i in 0 until entrySize) {
+        a[destLen2Index + i] = tmp[cursor1Index + i] //  Last elt of run 1 to end of merge
+      }
+    } else if (len1 == 0) {
+      throw IllegalArgumentException(
+          "Comparison method violates its general contract!"
+      )
+    } else {
+      if (DEBUG) assert(len2 == 0)
+      if (DEBUG) assert(len1 > 1)
+      System.arraycopy(tmp, cursor1 * entrySize, a, dest * entrySize, len1 * entrySize)
+    }
+  }
+
+  /**
+   * Like mergeLo, except that this method should be called only if
+   * len1 >= len2; mergeLo should be called if len1 <= len2.  (Either method
+   * may be called if len1 == len2.)
+   *
+   * @param base1 index of first element in first run to be merged
+   * @param len1  length of first run to be merged (must be > 0)
+   * @param base2 index of first element in second run to be merged
+   * (must be aBase + aLen)
+   * @param len2  length of second run to be merged (must be > 0)
+   */
+  private fun mergeHi(
+    base1: Int,
+    len1: Int,
+    base2: Int,
+    len2: Int
+  ) {
+    var len1 = len1
+    var len2 = len2
+    if (DEBUG) assert(len1 > 0 && len2 > 0 && base1 + len1 == base2)
+    // Copy second run into temp array
+    val a = this.a // For performance
+    val tmp = ensureCapacity(len2)
+    val entrySize = entrySize
+    System.arraycopy(a, base2 * entrySize, tmp, 0, len2 * entrySize)
+    var cursor1 = base1 + len1 - 1  // Indexes into a
+    var cursor2 = len2 - 1          // Indexes into tmp array
+    var dest = base2 + len2 - 1     // Indexes into a
+    // Move last element of first run and deal with degenerate cases
+    var destIndex = dest * entrySize
+    val cursor1Index = cursor1 * entrySize
+    for (i in 0 until entrySize) {
+      a[destIndex + i] = a[cursor1Index + i]
+    }
+    dest--
+    cursor1--
+    if (--len1 == 0) {
+      System.arraycopy(tmp, 0, a, (dest - (len2 - 1)) * entrySize, len2 * entrySize)
+      return
+    }
+    if (len2 == 1) {
+      dest -= len1
+      cursor1 -= len1
+      System.arraycopy(a, (cursor1 + 1) * entrySize, a, (dest + 1) * entrySize, len1 * entrySize)
+      val destIndex = dest * entrySize
+      val cursor2Index = cursor2 * entrySize
+      for (i in 0 until entrySize) {
+        a[destIndex + i] = tmp[cursor2Index + i]
+      }
+      return
+    }
+    val c = this.c  // Use local variable for performance
+    var minGallop = this.minGallop    //  "    "       "     "      "
+    outer@ while (true) {
+      var count1 = 0 // Number of times in a row that first run won
+      var count2 = 0 // Number of times in a row that second run won
+      /*
+             * Do the straightforward thing until (if ever) one run
+             * appears to win consistently.
+             */
+      do {
+        if (DEBUG) assert(len1 > 0 && len2 > 1)
+        if (c.compare(entrySize, tmp, cursor2, a, cursor1) < 0) {
+          val destIndex = dest * entrySize
+          val cursor1Index = cursor1 * entrySize
+          for (i in 0 until entrySize) {
+            a[destIndex + i] = a[cursor1Index + i]
+          }
+          dest--
+          cursor1--
+          count1++
+          count2 = 0
+          if (--len1 == 0)
+            break@outer
+        } else {
+          val destIndex = dest * entrySize
+          val cursor2Index = cursor2 * entrySize
+          for (i in 0 until entrySize) {
+            a[destIndex + i] = tmp[cursor2Index + i]
+          }
+          dest--
+          cursor2--
+          count2++
+          count1 = 0
+          if (--len2 == 1)
+            break@outer
+        }
+      } while (count1 or count2 < minGallop)
+      /*
+             * One run is winning so consistently that galloping may be a
+             * huge win. So try that, and continue galloping until (if ever)
+             * neither run appears to be winning consistently anymore.
+             */
+      do {
+        if (DEBUG) assert(len1 > 0 && len2 > 1)
+        count1 = len1 - gallopRight(tmp, cursor2, a, base1, len1, len1 - 1, entrySize, c)
+        if (count1 != 0) {
+          dest -= count1
+          cursor1 -= count1
+          len1 -= count1
+          System.arraycopy(
+              a, (cursor1 + 1) * entrySize, a, (dest + 1) * entrySize, count1 * entrySize
+          )
+          if (len1 == 0)
+            break@outer
+        }
+        destIndex = dest * entrySize
+        val cursor2Index = cursor2 * entrySize
+        for (i in 0 until entrySize) {
+          a[destIndex + i] = tmp[cursor2Index + i]
+        }
+        dest--
+        cursor2--
+        if (--len2 == 1)
+          break@outer
+        count2 = len2 - gallopLeft(a, cursor1, tmp, 0, len2, len2 - 1, entrySize, c)
+        if (count2 != 0) {
+          dest -= count2
+          cursor2 -= count2
+          len2 -= count2
+          System.arraycopy(
+              tmp, (cursor2 + 1) * entrySize, a, (dest + 1) * entrySize, count2 * entrySize
+          )
+          if (len2 <= 1)
+          // len2 == 1 || len2 == 0
+            break@outer
+        }
+        val destIndex = dest * entrySize
+        val cursor1Index = cursor1 * entrySize
+        for (i in 0 until entrySize) {
+          a[destIndex + i] = a[cursor1Index + i]
+        }
+        dest--
+        cursor1--
+        if (--len1 == 0)
+          break@outer
+        minGallop--
+      } while ((count1 >= MIN_GALLOP) or (count2 >= MIN_GALLOP))
+      if (minGallop < 0)
+        minGallop = 0
+      minGallop += 2  // Penalize for leaving gallop mode
+    }  // End of "outer" loop
+    this.minGallop = if (minGallop < 1) 1 else minGallop  // Write back to field
+    if (len2 == 1) {
+      if (DEBUG) assert(len1 > 0)
+      dest -= len1
+      cursor1 -= len1
+      System.arraycopy(a, (cursor1 + 1) * entrySize, a, (dest + 1) * entrySize, len1 * entrySize)
+      val destIndex = dest * entrySize
+      val cursor2Index = cursor2 * entrySize
+      for (i in 0 until entrySize) {
+        a[destIndex + i] = tmp[cursor2Index + i] // Move first elt of run2 to front of merge
+      }
+    } else if (len2 == 0) {
+      throw IllegalArgumentException(
+          "Comparison method violates its general contract!"
+      )
+    } else {
+      if (DEBUG) assert(len1 == 0)
+      if (DEBUG) assert(len2 > 0)
+      System.arraycopy(tmp, 0, a, (dest - (len2 - 1)) * entrySize, len2 * entrySize)
+    }
+  }
+
+  /**
+   * Ensures that the external array tmp has at least the specified
+   * number of elements, increasing its size if necessary.  The size
+   * increases exponentially to ensure amortized linear time complexity.
+   *
+   * @param minCapacity the minimum required capacity of the tmp array
+   * @return tmp, whether or not it grew
+   */
+  private fun ensureCapacity(minCapacity: Int): ByteArray {
+    if (tmp!!.size < minCapacity * entrySize) {
+      // Compute smallest power of 2 > minCapacity
+      var newSize = minCapacity
+      newSize = newSize or (newSize shr 1)
+      newSize = newSize or (newSize shr 2)
+      newSize = newSize or (newSize shr 4)
+      newSize = newSize or (newSize shr 8)
+      newSize = newSize or (newSize shr 16)
+      newSize++
+      if (newSize < 0)
+      // Not bloody likely!
+        newSize = minCapacity
+      else
+        newSize = Math.min(newSize, (a.size / entrySize).ushr(1))
+      val newArray = ByteArray(newSize * entrySize)
+      tmp = newArray
+    }
+    return tmp!!
+  }
+
+  companion object {
+    /**
+     * This is the minimum sized sequence that will be merged.  Shorter
+     * sequences will be lengthened by calling binarySort.  If the entire
+     * array is less than this length, no merges will be performed.
+     *
+     * This constant should be a power of two.  It was 64 in Tim Peter's C
+     * implementation, but 32 was empirically determined to work better in
+     * this implementation.  In the unlikely event that you set this constant
+     * to be a number that's not a power of two, you'll need to change the
+     * [.minRunLength] computation.
+     *
+     * If you decrease this constant, you must change the stackLen
+     * computation in the TimSort constructor, or you risk an
+     * ArrayOutOfBounds exception.  See listsort.txt for a discussion
+     * of the minimum stack length required as a function of the length
+     * of the array being sorted and the minimum merge sequence length.
+     */
+    private val MIN_MERGE = 32
+    /**
+     * When we get into galloping mode, we stay there until both runs win less
+     * often than MIN_GALLOP consecutive times.
+     */
+    private val MIN_GALLOP = 7
+    /**
+     * Maximum initial size of tmp array, which is used for merging.  The array
+     * can grow to accommodate demand.
+     *
+     * Unlike Tim's original C version, we do not allocate this much storage
+     * when sorting smaller arrays.  This change was required for performance.
+     */
+    private val INITIAL_TMP_STORAGE_LENGTH = 256
+    /**
+     * Asserts have been placed in if-statements for performace. To enable them,
+     * set this field to true and enable them in VM with a command line flag.
+     * If you modify this class, please do test the asserts!
+     */
+    private val DEBUG = false
+
+    /*
+     * The next two methods (which are package private and static) constitute
+     * the entire API of this class.  Each of these methods obeys the contract
+     * of the public method with the same signature in java.util.Arrays.
+     */
+    fun sort(
+      a: ByteArray,
+      entrySize: Int,
+      c: ByteArrayComparator
+    ) {
+      sort(a, 0, a.size / entrySize, entrySize, c)
+    }
+
+    fun sort(
+      a: ByteArray,
+      lo: Int,
+      hi: Int,
+      entrySize: Int,
+      c: ByteArrayComparator
+    ) {
+      var lo = lo
+      checkStartAndEnd(a.size / entrySize, lo, hi)
+      var nRemaining = hi - lo
+      if (nRemaining < 2)
+        return   // Arrays of size 0 and 1 are always sorted
+      // If array is small, do a "mini-TimSort" with no merges
+      if (nRemaining < MIN_MERGE) {
+        val initRunLen = countRunAndMakeAscending(a, lo, hi, entrySize, c)
+        binarySort(a, lo, hi, lo + initRunLen, entrySize, c)
+        return
+      }
+      /**
+       * March over the array once, left to right, finding natural runs,
+       * extending short natural runs to minRun elements, and merging runs
+       * to maintain stack invariant.
+       */
+      val ts = ByteArrayTimSort(a, c, entrySize)
+      val minRun = minRunLength(nRemaining)
+      do {
+        // Identify next run
+        var runLen = countRunAndMakeAscending(a, lo, hi, entrySize, c)
+        // If run is short, extend to min(minRun, nRemaining)
+        if (runLen < minRun) {
+          val force = if (nRemaining <= minRun) nRemaining else minRun
+          binarySort(a, lo, lo + force, lo + runLen, entrySize, c)
+          runLen = force
+        }
+        // Push run onto pending-run stack, and maybe merge
+        ts.pushRun(lo, runLen)
+        ts.mergeCollapse()
+        // Advance to find next run
+        lo += runLen
+        nRemaining -= runLen
+      } while (nRemaining != 0)
+      // Merge all remaining runs to complete sort
+      if (DEBUG) assert(lo == hi)
+      ts.mergeForceCollapse()
+      if (DEBUG) assert(ts.stackSize == 1)
+    }
+
+    private fun checkStartAndEnd(
+      len: Int,
+      start: Int,
+      end: Int
+    ) {
+      if (start < 0 || end > len) {
+        throw ArrayIndexOutOfBoundsException(
+            "start < 0 || end > len."
+                + " start=" + start + ", end=" + end + ", len=" + len
+        )
+      }
+      if (start > end) {
+        throw IllegalArgumentException("start > end: $start > $end")
+      }
+    }
+
+    /**
+     * Sorts the specified portion of the specified array using a binary
+     * insertion sort.  This is the best method for sorting small numbers
+     * of elements.  It requires O(n log n) compares, but O(n^2) data
+     * movement (worst case).
+     *
+     * If the initial part of the specified range is already sorted,
+     * this method can take advantage of it: the method assumes that the
+     * elements from index `lo`, inclusive, to `start`,
+     * exclusive are already sorted.
+     *
+     * @param a the array in which a range is to be sorted
+     * @param lo the index of the first element in the range to be sorted
+     * @param hi the index after the last element in the range to be sorted
+     * @param start the index of the first element in the range that is
+     * not already known to be sorted (@code lo <= start <= hi}
+     * @param c comparator to used for the sort
+     */
+    private fun binarySort(
+      a: ByteArray,
+      lo: Int,
+      hi: Int,
+      start: Int,
+      entrySize: Int,
+      c: ByteArrayComparator
+    ) {
+      var start = start
+      if (DEBUG) assert(lo <= start && start <= hi)
+      if (start == lo)
+        start++
+      val pivot = ByteArray(entrySize)
+      while (start < hi) {
+        val startIndex = start * entrySize
+        for (i in 0 until entrySize) {
+          pivot[i] = a[startIndex + i]
+        }
+        // Set left (and right) to the index where a[start] (pivot) belongs
+        var left = lo
+        var right = start
+        if (DEBUG) assert(left <= right)
+        /*
+             * Invariants:
+             *   pivot >= all in [lo, left).
+             *   pivot <  all in [right, start).
+             */
+        while (left < right) {
+          val mid = (left + right).ushr(1)
+          if (c.compare(entrySize, pivot, 0, a, mid) < 0)
+            right = mid
+          else
+            left = mid + 1
+        }
+        if (DEBUG) assert(left == right)
+        /*
+             * The invariants still hold: pivot >= all in [lo, left) and
+             * pivot < all in [left, start), so pivot belongs at left.  Note
+             * that if there are elements equal to pivot, left points to the
+             * first slot after them -- that's why this sort is stable.
+             * Slide elements over to make room for pivot.
+             */
+        val n = start - left  // The number of elements to move
+        // Switch is just an optimization for arraycopy in default case
+        when (n) {
+          2 -> {
+            val leftIndex = left * entrySize
+            val leftPlusOneIndex = (left + 1) * entrySize
+            val leftPlusTwoIndex = (left + 2) * entrySize
+            for (i in 0 until entrySize) {
+              a[leftPlusTwoIndex + i] = a[leftPlusOneIndex + i]
+            }
+            for (i in 0 until entrySize) {
+              a[leftPlusOneIndex + i] = a[leftIndex + i]
+            }
+          }
+          1 -> {
+            val leftIndex = left * entrySize
+            val leftPlusOneIndex = (left + 1) * entrySize
+            for (i in 0 until entrySize) {
+              a[leftPlusOneIndex + i] = a[leftIndex + i]
+            }
+          }
+          else -> {
+            System.arraycopy(a, left * entrySize, a, (left + 1) * entrySize, n * entrySize)
+          }
+        }
+        val leftIndex = left * entrySize
+        for (i in 0 until entrySize) {
+          a[leftIndex + i] = pivot[i]
+        }
+        start++
+      }
+    }
+
+    /**
+     * Returns the length of the run beginning at the specified position in
+     * the specified array and reverses the run if it is descending (ensuring
+     * that the run will always be ascending when the method returns).
+     *
+     * A run is the longest ascending sequence with:
+     *
+     * a[lo] <= a[lo + 1] <= a[lo + 2] <= ...
+     *
+     * or the longest descending sequence with:
+     *
+     * a[lo] >  a[lo + 1] >  a[lo + 2] >  ...
+     *
+     * For its intended use in a stable mergesort, the strictness of the
+     * definition of "descending" is needed so that the call can safely
+     * reverse a descending sequence without violating stability.
+     *
+     * @param a the array in which a run is to be counted and possibly reversed
+     * @param lo index of the first element in the run
+     * @param hi index after the last element that may be contained in the run.
+     * It is required that @code{lo < hi}.
+     * @param c the comparator to used for the sort
+     * @return  the length of the run beginning at the specified position in
+     * the specified array
+     */
+    private fun countRunAndMakeAscending(
+      a: ByteArray,
+      lo: Int,
+      hi: Int,
+      entrySize: Int,
+      c: ByteArrayComparator
+    ): Int {
+      if (DEBUG) assert(lo < hi)
+      var runHi = lo + 1
+      if (runHi == hi)
+        return 1
+      // Find end of run, and reverse range if descending
+
+      val comparison = c.compare(entrySize, a, runHi, a, lo)
+      runHi++
+      if (comparison < 0) { // Descending
+        while (runHi < hi && c.compare(entrySize, a, runHi, a, runHi - 1) < 0)
+          runHi++
+        reverseRange(a, lo, runHi, entrySize)
+      } else {                              // Ascending
+        while (runHi < hi && c.compare(entrySize, a, runHi, a, runHi - 1) >= 0)
+          runHi++
+      }
+      return runHi - lo
+    }
+
+    /**
+     * Reverse the specified range of the specified array.
+     *
+     * @param a the array in which a range is to be reversed
+     * @param lo the index of the first element in the range to be reversed
+     * @param hi the index after the last element in the range to be reversed
+     */
+    private fun reverseRange(
+      a: ByteArray,
+      lo: Int,
+      hi: Int,
+      entrySize: Int
+    ) {
+      var lo = lo
+      var hi = hi
+      hi--
+      while (lo < hi) {
+        val loIndex = lo * entrySize
+        val hiIndex = hi * entrySize
+        for (i in 0 until entrySize) {
+          val t = a[loIndex + i]
+          a[loIndex + i] = a[hiIndex + i]
+          a[hiIndex + i] = t
+        }
+        lo++
+        hi--
+      }
+    }
+
+    /**
+     * Returns the minimum acceptable run length for an array of the specified
+     * length. Natural runs shorter than this will be extended with
+     * [.binarySort].
+     *
+     * Roughly speaking, the computation is:
+     *
+     * If n < MIN_MERGE, return n (it's too small to bother with fancy stuff).
+     * Else if n is an exact power of 2, return MIN_MERGE/2.
+     * Else return an int k, MIN_MERGE/2 <= k <= MIN_MERGE, such that n/k
+     * is close to, but strictly less than, an exact power of 2.
+     *
+     * For the rationale, see listsort.txt.
+     *
+     * @param n the length of the array to be sorted
+     * @return the length of the minimum run to be merged
+     */
+    private fun minRunLength(n: Int): Int {
+      var n = n
+      if (DEBUG) assert(n >= 0)
+      var r = 0      // Becomes 1 if any 1 bits are shifted off
+      while (n >= MIN_MERGE) {
+        r = r or (n and 1)
+        n = n shr 1
+      }
+      return n + r
+    }
+
+    /**
+     * Locates the position at which to insert the specified key into the
+     * specified sorted range; if the range contains an element equal to key,
+     * returns the index of the leftmost equal element.
+     *
+     * @param key the key whose insertion point to search for
+     * @param a the array in which to search
+     * @param base the index of the first element in the range
+     * @param len the length of the range; must be > 0
+     * @param hint the index at which to begin the search, 0 <= hint < n.
+     * The closer hint is to the result, the faster this method will run.
+     * @param c the comparator used to order the range, and to search
+     * @return the int k,  0 <= k <= n such that a[b + k - 1] < key <= a[b + k],
+     * pretending that a[b - 1] is minus infinity and a[b + n] is infinity.
+     * In other words, key belongs at index b + k; or in other words,
+     * the first k elements of a should precede key, and the last n - k
+     * should follow it.
+     */
+    private fun gallopLeft(
+      keyArray: ByteArray,
+        // Index already divided by entrySize
+      keyIndex: Int,
+      a: ByteArray,
+      base: Int,
+      len: Int,
+      hint: Int,
+      entrySize: Int,
+      c: ByteArrayComparator
+    ): Int {
+      if (DEBUG) assert(len > 0 && hint >= 0 && hint < len)
+      var lastOfs = 0
+      var ofs = 1
+      if (c.compare(entrySize, keyArray, keyIndex, a, base + hint) > 0) {
+        // Gallop right until a[base+hint+lastOfs] < key <= a[base+hint+ofs]
+        val maxOfs = len - hint
+        while (ofs < maxOfs && c.compare(entrySize, keyArray, keyIndex, a, base + hint + ofs) > 0) {
+          lastOfs = ofs
+          ofs = ofs * 2 + 1
+          if (ofs <= 0)
+          // int overflow
+            ofs = maxOfs
+        }
+        if (ofs > maxOfs)
+          ofs = maxOfs
+        // Make offsets relative to base
+        lastOfs += hint
+        ofs += hint
+      } else { // key <= a[base + hint]
+        // Gallop left until a[base+hint-ofs] < key <= a[base+hint-lastOfs]
+        val maxOfs = hint + 1
+        while (ofs < maxOfs && c.compare(
+                entrySize, keyArray, keyIndex, a, base + hint - ofs
+            ) <= 0
+        ) {
+          lastOfs = ofs
+          ofs = ofs * 2 + 1
+          if (ofs <= 0)
+          // int overflow
+            ofs = maxOfs
+        }
+        if (ofs > maxOfs)
+          ofs = maxOfs
+        // Make offsets relative to base
+        val tmp = lastOfs
+        lastOfs = hint - ofs
+        ofs = hint - tmp
+      }
+      if (DEBUG) assert(-1 <= lastOfs && lastOfs < ofs && ofs <= len)
+      /*
+         * Now a[base+lastOfs] < key <= a[base+ofs], so key belongs somewhere
+         * to the right of lastOfs but no farther right than ofs.  Do a binary
+         * search, with invariant a[base + lastOfs - 1] < key <= a[base + ofs].
+         */
+      lastOfs++
+      while (lastOfs < ofs) {
+        val m = lastOfs + (ofs - lastOfs).ushr(1)
+        if (c.compare(entrySize, keyArray, keyIndex, a, base + m) > 0)
+          lastOfs = m + 1  // a[base + m] < key
+        else
+          ofs = m          // key <= a[base + m]
+      }
+      if (DEBUG) assert(lastOfs == ofs)    // so a[base + ofs - 1] < key <= a[base + ofs]
+      return ofs
+    }
+
+    /**
+     * Like gallopLeft, except that if the range contains an element equal to
+     * key, gallopRight returns the index after the rightmost equal element.
+     *
+     * @param key the key whose insertion point to search for
+     * @param a the array in which to search
+     * @param base the index of the first element in the range
+     * @param len the length of the range; must be > 0
+     * @param hint the index at which to begin the search, 0 <= hint < n.
+     * The closer hint is to the result, the faster this method will run.
+     * @param c the comparator used to order the range, and to search
+     * @return the int k,  0 <= k <= n such that a[b + k - 1] <= key < a[b + k]
+     */
+    private fun gallopRight(
+      keyArray: ByteArray,
+        // Index already divided by entrySize
+      keyIndex: Int,
+      a: ByteArray,
+      base: Int,
+      len: Int,
+      hint: Int,
+      entrySize: Int,
+      c: ByteArrayComparator
+    ): Int {
+      if (DEBUG) assert(len > 0 && hint >= 0 && hint < len)
+      var ofs = 1
+      var lastOfs = 0
+      if (c.compare(entrySize, keyArray, keyIndex, a, base + hint) < 0) {
+        // Gallop left until a[b+hint - ofs] <= key < a[b+hint - lastOfs]
+        val maxOfs = hint + 1
+        while (ofs < maxOfs && c.compare(entrySize, keyArray, keyIndex, a, base + hint - ofs) < 0) {
+          lastOfs = ofs
+          ofs = ofs * 2 + 1
+          if (ofs <= 0)
+          // int overflow
+            ofs = maxOfs
+        }
+        if (ofs > maxOfs)
+          ofs = maxOfs
+        // Make offsets relative to b
+        val tmp = lastOfs
+        lastOfs = hint - ofs
+        ofs = hint - tmp
+      } else { // a[b + hint] <= key
+        // Gallop right until a[b+hint + lastOfs] <= key < a[b+hint + ofs]
+        val maxOfs = len - hint
+        while (ofs < maxOfs && c.compare(
+                entrySize, keyArray, keyIndex, a, base + hint + ofs
+            ) >= 0
+        ) {
+          lastOfs = ofs
+          ofs = ofs * 2 + 1
+          if (ofs <= 0)
+          // int overflow
+            ofs = maxOfs
+        }
+        if (ofs > maxOfs)
+          ofs = maxOfs
+        // Make offsets relative to b
+        lastOfs += hint
+        ofs += hint
+      }
+      if (DEBUG) assert(-1 <= lastOfs && lastOfs < ofs && ofs <= len)
+      /*
+         * Now a[b + lastOfs] <= key < a[b + ofs], so key belongs somewhere to
+         * the right of lastOfs but no farther right than ofs.  Do a binary
+         * search, with invariant a[b + lastOfs - 1] <= key < a[b + ofs].
+         */
+      lastOfs++
+      while (lastOfs < ofs) {
+        val m = lastOfs + (ofs - lastOfs).ushr(1)
+        if (c.compare(entrySize, keyArray, keyIndex, a, base + m) < 0)
+          ofs = m          // key < a[b + m]
+        else
+          lastOfs = m + 1  // a[b + m] <= key
+      }
+      if (DEBUG) assert(lastOfs == ofs)    // so a[b + ofs - 1] <= key < a[b + ofs]
+      return ofs
+    }
+  }
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/internal/hppc/LongLongScatterMap.kt b/shark-graph/src/main/java/shark/internal/hppc/LongLongScatterMap.kt
index 084f5fa5..25ab8c96 100644
--- a/shark-graph/src/main/java/shark/internal/hppc/LongLongScatterMap.kt
+++ b/shark-graph/src/main/java/shark/internal/hppc/LongLongScatterMap.kt
@@ -23,6 +23,7 @@ import java.util.Locale
  *
  * See https://github.com/carrotsearch/hppc .
  */
+@Suppress("TooManyFunctions")
 class LongLongScatterMap {
   /**
    * The array holding keys.
diff --git a/shark-graph/src/main/java/shark/internal/hppc/LongObjectScatterMap.kt b/shark-graph/src/main/java/shark/internal/hppc/LongObjectScatterMap.kt
index f1b8234e..d705f685 100644
--- a/shark-graph/src/main/java/shark/internal/hppc/LongObjectScatterMap.kt
+++ b/shark-graph/src/main/java/shark/internal/hppc/LongObjectScatterMap.kt
@@ -23,6 +23,7 @@ import java.util.Locale
  *
  * See https://github.com/carrotsearch/hppc .
  */
+@Suppress("TooManyFunctions")
 internal class LongObjectScatterMap<T> {
   /**
    * The array holding keys.
diff --git a/shark-graph/src/test/java/shark/ByteArrayTimSortTest.kt b/shark-graph/src/test/java/shark/ByteArrayTimSortTest.kt
new file mode 100644
index 00000000..292f41e0
--- /dev/null
+++ b/shark-graph/src/test/java/shark/ByteArrayTimSortTest.kt
@@ -0,0 +1,110 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import shark.internal.aosp.ByteArrayComparator
+import shark.internal.aosp.ByteArrayTimSort
+import java.lang.IllegalStateException
+import kotlin.random.Random
+
+class ByteArrayTimSortTest {
+
+  @Test fun smallArray1BytePerEntry() {
+    val toSort = byteArrayOf(2, 1, 4)
+
+    ByteArrayTimSort.sort(toSort, 0, 3, 1, object : ByteArrayComparator {
+      override fun compare(
+        entrySize: Int,
+        o1Array: ByteArray,
+        o1Index: Int,
+        o2Array: ByteArray,
+        o2Index: Int
+      ): Int {
+        return o1Array[o1Index].compareTo(o2Array[o2Index])
+      }
+    })
+    assertThat(toSort).containsExactly(1, 2, 4)
+  }
+
+  @Test fun smallArray3BytesPerEntry1ByteKey() {
+    val toSort = byteArrayOf(2, 3, 3, 1, 5, 5, 4, 6, 6)
+
+    ByteArrayTimSort.sort(toSort, 3, object : ByteArrayComparator {
+      override fun compare(
+        entrySize: Int,
+        o1Array: ByteArray,
+        o1Index: Int,
+        o2Array: ByteArray,
+        o2Index: Int
+      ): Int {
+        // Sort based on first byte
+        return o1Array[o1Index * entrySize].compareTo(o2Array[o2Index * entrySize])
+      }
+    })
+    assertThat(toSort).containsExactly(1, 5, 5, 2, 3, 3, 4, 6, 6)
+  }
+
+  @Test fun largeRandomArray8BytesPerEntry4BytesKey() {
+    val entryCount = 10000
+    val entrySize = 8
+    val random = Random(Int.MIN_VALUE)
+    val librarySorted = random.nextBytes(entryCount * entrySize)
+
+    class Entry(val eightBytes: ByteArray) : Comparable<Entry> {
+      override fun compareTo(other: Entry): Int {
+        val compared = readInt(eightBytes, 0).compareTo(readInt(other.eightBytes, 0))
+        if (compared == 0){
+          return readInt(eightBytes, 4).compareTo(readInt(other.eightBytes, 4))
+        }
+        return compared
+      }
+    }
+
+    val androidSorted = arrayOfNulls<Entry>(entryCount)
+    for (i in 0 until entryCount) {
+      val index = i * entrySize
+      androidSorted[i] = Entry(librarySorted.copyOfRange(index, index + entrySize))
+    }
+    androidSorted.sort()
+    val androidSortedAsBytes = ByteArray(entryCount * entrySize)
+
+    for (i in 0 until entryCount) {
+        System.arraycopy(
+            androidSorted[i]!!.eightBytes, 0, androidSortedAsBytes, i * entrySize, entrySize
+        )
+    }
+
+    ByteArrayTimSort.sort(librarySorted, entrySize, object : ByteArrayComparator {
+      override fun compare(
+        entrySize: Int,
+        o1Array: ByteArray,
+        o1Index: Int,
+        o2Array: ByteArray,
+        o2Index: Int
+      ): Int {
+        val compared = readInt(o1Array, o1Index * entrySize).compareTo(readInt(o2Array, o2Index * entrySize))
+        if (compared == 0) {
+          return readInt(o1Array, o1Index * entrySize + 4).compareTo(readInt(o2Array, o2Index * entrySize + 4))
+        }
+        return compared
+      }
+    })
+
+    assertThat(librarySorted.asList()).isEqualTo(androidSortedAsBytes.asList())
+  }
+
+  fun readInt(
+    array: ByteArray,
+    index: Int
+  ): Int {
+    var pos = index
+    return (array[pos++] and 0xff shl 24
+        or (array[pos++] and 0xff shl 16)
+        or (array[pos++] and 0xff shl 8)
+        or (array[pos] and 0xff))
+  }
+
+  @Suppress("NOTHING_TO_INLINE") // Syntactic sugar.
+  private inline infix fun Byte.and(other: Int): Int = toInt() and other
+
+}
\ No newline at end of file
diff --git a/shark-graph/src/test/java/shark/SortedBytesMapTest.kt b/shark-graph/src/test/java/shark/SortedBytesMapTest.kt
new file mode 100644
index 00000000..a089564a
--- /dev/null
+++ b/shark-graph/src/test/java/shark/SortedBytesMapTest.kt
@@ -0,0 +1,204 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Test
+import shark.internal.UnsortedByteEntries
+import java.util.Arrays
+import kotlin.random.Random
+
+class SortedBytesMapTest {
+
+  @Test fun writeAndReadLongValue() {
+    val unsortedEntries = UnsortedByteEntries(bytesPerValue = 8, longIdentifiers = false)
+    unsortedEntries.append(1)
+        .apply {
+          writeLong(Long.MIN_VALUE)
+        }
+
+    val array = unsortedEntries.moveToSortedMap()[1]!!
+    assertThat(array.readLong()).isEqualTo(Long.MIN_VALUE)
+  }
+
+  @Test fun writeAndReadTruncatedLongValue() {
+    val maxUnsigned3Bytes = 0x00000FFFL
+    val unsortedMap = UnsortedByteEntries(bytesPerValue = 3, longIdentifiers = false)
+    unsortedMap.append(1)
+        .apply {
+          writeTruncatedLong(maxUnsigned3Bytes, 3)
+        }
+
+    val array = unsortedMap.moveToSortedMap()[1]!!
+    assertThat(array.readTruncatedLong(3)).isEqualTo(maxUnsigned3Bytes)
+  }
+
+  @Test fun fourEntriesWithLongKey1ByteValueSorted() {
+    val unsortedEntries = UnsortedByteEntries(bytesPerValue = 1, longIdentifiers = true)
+    unsortedEntries.append(42)
+        .apply {
+          writeByte(4)
+        }
+    unsortedEntries.append(0)
+        .apply {
+          writeByte(3)
+        }
+    unsortedEntries.append(3)
+        .apply {
+          writeByte(20)
+        }
+    unsortedEntries.append(Long.MAX_VALUE)
+        .apply {
+          writeByte(127)
+        }
+    val sortedEntries = unsortedEntries.moveToSortedMap()
+        .entrySequence()
+        .toList()
+
+    assertThat(sortedEntries.map { it.first }).containsExactly(0, 3, 42, Long.MAX_VALUE)
+    assertThat(
+        sortedEntries.map {
+          byteArrayOf(
+              it.second.readByte()
+          )
+        }).containsExactly(
+        byteArrayOf(3), byteArrayOf(20), byteArrayOf(4),
+        byteArrayOf(127)
+    )
+  }
+
+  @Test fun fourEntriesWithLongKey3ByteValueSorted() {
+    val unsortedMap = UnsortedByteEntries(bytesPerValue = 3, longIdentifiers = true)
+    unsortedMap.append(42)
+        .apply {
+          writeByte(4)
+          writeByte(2)
+          writeByte(0)
+        }
+    unsortedMap.append(0)
+        .apply {
+          writeByte(3)
+          writeByte(2)
+          writeByte(1)
+        }
+    unsortedMap.append(3)
+        .apply {
+          writeByte(20)
+          writeByte(52)
+          writeByte(-17)
+        }
+    unsortedMap.append(Long.MAX_VALUE)
+        .apply {
+          writeByte(127)
+          writeByte(0)
+          writeByte(-128)
+        }
+    val sortedEntries = unsortedMap.moveToSortedMap()
+        .entrySequence()
+        .toList()
+
+    assertThat(sortedEntries.map { it.first }).containsExactly(0, 3, 42, Long.MAX_VALUE)
+    assertThat(
+        sortedEntries.map {
+          byteArrayOf(
+              it.second.readByte(), it.second.readByte(), it.second.readByte()
+          )
+        }).containsExactly(
+        byteArrayOf(3, 2, 1), byteArrayOf(20, 52, -17), byteArrayOf(4, 2, 0),
+        byteArrayOf(127, 0, -128)
+    )
+  }
+
+  class Entry(
+    val key: Long,
+    val value: ByteArray
+  ) : Comparable<Entry> {
+    override fun compareTo(other: Entry): Int = key.compareTo(other.key)
+    override fun equals(other: Any?): Boolean {
+      if (this === other) return true
+      if (javaClass != other?.javaClass) return false
+
+      other as Entry
+
+      if (key != other.key) return false
+      if (!value.contentEquals(other.value)) return false
+
+      return true
+    }
+
+    override fun toString(): String {
+      return "Entry(key=$key, value=${Arrays.toString(value)})"
+    }
+
+  }
+
+  @Test fun largeRandomArrayIntKey3ByteValueSorted() {
+    val random = Random(Long.MAX_VALUE)
+
+    val bytesPerValue = 3
+    val longIdentifiers = false
+
+    val sourceEntryArray = Array(10000) {
+      Entry(random.nextInt().toLong(), random.nextBytes(bytesPerValue))
+    }
+
+    sortAndCompare(bytesPerValue, longIdentifiers, sourceEntryArray)
+  }
+
+  @Test fun largeRandomArrayLongKey3ByteValueSorted() {
+    val random = Random(42)
+
+    val bytesPerValue = 3
+    val longIdentifiers = true
+
+    val sourceEntryArray = Array(10000) {
+      Entry(random.nextLong(), random.nextBytes(bytesPerValue))
+    }
+
+    sortAndCompare(bytesPerValue, longIdentifiers, sourceEntryArray)
+  }
+
+  @Test fun largeRandomArrayLongKey7ByteValueSorted() {
+    val random = Random(Long.MIN_VALUE)
+
+    val bytesPerValue = 7
+    val longIdentifiers = true
+
+    val sourceEntryArray = Array(10000) {
+      Entry(random.nextLong(), random.nextBytes(bytesPerValue))
+    }
+
+    sortAndCompare(bytesPerValue, longIdentifiers, sourceEntryArray)
+  }
+
+  private fun sortAndCompare(
+    bytesPerValue: Int,
+    longIdentifiers: Boolean,
+    sourceEntryArray: Array<Entry>
+  ) {
+    val unsortedEntries =
+      UnsortedByteEntries(bytesPerValue = bytesPerValue, longIdentifiers = longIdentifiers)
+
+    sourceEntryArray.forEach { entry ->
+      val subArray = unsortedEntries.append(entry.key)
+      entry.value.forEach { subArray.writeByte(it) }
+    }
+
+    val sortedMap = unsortedEntries.moveToSortedMap()
+    sourceEntryArray.sort()
+
+    val sortedEntryArray = sortedMap.entrySequence()
+        .map {
+          val key = it.first
+          val value = it.second
+
+          val bytes = mutableListOf<Byte>()
+          for (i in 0 until bytesPerValue) {
+            bytes += value.readByte()
+          }
+          Entry(key, bytes.toByteArray())
+        }
+        .toList()
+        .toTypedArray()
+
+    assertThat(sortedEntryArray).isEqualTo(sourceEntryArray)
+  }
+}
diff --git a/shark-hprof/build.gradle b/shark-hprof/build.gradle
index 9cb23d77..5698b219 100644
--- a/shark-hprof/build.gradle
+++ b/shark-hprof/build.gradle
@@ -14,5 +14,4 @@ dependencies {
   testImplementation deps.junit
 }
 
-apply from: rootProject.file('gradle/checkstyle.gradle')
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/shark-hprof/src/main/java/shark/Hprof.kt b/shark-hprof/src/main/java/shark/Hprof.kt
index 84a7e4b3..ecfc7952 100644
--- a/shark-hprof/src/main/java/shark/Hprof.kt
+++ b/shark-hprof/src/main/java/shark/Hprof.kt
@@ -3,6 +3,7 @@ package shark
 import okio.BufferedSource
 import okio.buffer
 import okio.source
+import shark.Hprof.Companion.open
 import java.io.Closeable
 import java.io.File
 import java.nio.channels.FileChannel
@@ -18,30 +19,30 @@ class Hprof private constructor(
   /** Unix timestamp at which the heap was dumped. */
   val heapDumpTimestamp: Long,
   /** Version of the opened hprof, which is tied to the runtime where the heap was dumped. */
-  val hprofVersion: HprofVersion
+  val hprofVersion: HprofVersion,
+  /**
+   * Length of the hprof file, in bytes.
+   */
+  val fileLength: Long
 ) : Closeable {
 
-  private var lastReaderByteReadCount = reader.byteReadCount
-  private var lastKnownPosition = reader.byteReadCount
-
   override fun close() {
     source.close()
   }
 
   /**
    * Moves [reader] to a new position in the hprof file. This is transparent to the reader, and
-   * will not reset [HprofReader.byteReadCount].
+   * will not reset [HprofReader.position].
    */
   fun moveReaderTo(newPosition: Long) {
-    val currentPosition = lastKnownPosition + (reader.byteReadCount - lastReaderByteReadCount)
+    val currentPosition = reader.position
 
     if (currentPosition == newPosition) {
       return
     }
     source.buffer.clear()
     channel.position(newPosition)
-    lastReaderByteReadCount = reader.byteReadCount
-    lastKnownPosition = newPosition
+    reader.position = newPosition
   }
 
   /**
@@ -56,14 +57,16 @@ class Hprof private constructor(
 
   companion object {
     private val supportedVersions = HprofVersion.values()
-        .map { it.versionString to it }.toMap()
+        .map { it.versionString to it }
+        .toMap()
 
     /**
      * Reads the headers of the provided [hprofFile] and returns an opened [Hprof]. Don't forget
      * to call [close] once done.
      */
     fun open(hprofFile: File): Hprof {
-      if (hprofFile.length() == 0L) {
+      val fileLength = hprofFile.length()
+      if (fileLength == 0L) {
         throw IllegalArgumentException("Hprof file is 0 byte length")
       }
       val inputStream = hprofFile.inputStream()
@@ -91,7 +94,7 @@ class Hprof private constructor(
       val reader = HprofReader(source, identifierByteSize, byteReadCount)
 
       return Hprof(
-          channel, source, reader, heapDumpTimestamp, hprofVersion
+          channel, source, reader, heapDumpTimestamp, hprofVersion, fileLength
       )
     }
   }
diff --git a/shark-hprof/src/main/java/shark/HprofReader.kt b/shark-hprof/src/main/java/shark/HprofReader.kt
index b67be040..4b126963 100644
--- a/shark-hprof/src/main/java/shark/HprofReader.kt
+++ b/shark-hprof/src/main/java/shark/HprofReader.kt
@@ -25,8 +25,11 @@ import shark.HprofRecord.HeapDumpRecord.ObjectRecord
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassSkipContentRecord
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceSkipContentRecord
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArraySkipContentRecord
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
@@ -36,6 +39,7 @@ import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.Fl
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
 import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArraySkipContentRecord
 import shark.HprofRecord.LoadClassRecord
 import shark.HprofRecord.StackFrameRecord
 import shark.HprofRecord.StackTraceRecord
@@ -70,6 +74,7 @@ import kotlin.reflect.KClass
  * The Android Hprof format differs in some ways from that reference. This parser implementation
  * is largely adapted from https://android.googlesource.com/platform/tools/base/+/studio-master-dev/perflib/src/main/java/com/android/tools/perflib
  */
+@Suppress("LargeClass", "TooManyFunctions")
 class HprofReader constructor(
   private var source: BufferedSource,
   /**
@@ -81,31 +86,29 @@ class HprofReader constructor(
   /**
    * How many bytes have already been read from [source] when this [HprofReader] is created.
    */
-  val startByteReadCount: Long = 0L
+  val startPosition: Long = 0L
 ) {
 
   /**
-   * Starts at [startByteReadCount] and increases as [HprofReader] reads bytes. This is useful
+   * Starts at [startPosition] and increases as [HprofReader] reads bytes. This is useful
    * for tracking the position of content in the backing [source]. This never resets.
    */
-  var byteReadCount = startByteReadCount
-    private set
+  var position = startPosition
+    internal set
 
   private val typeSizes =
     PrimitiveType.byteSizeByHprofType + (PrimitiveType.REFERENCE_HPROF_TYPE to identifierByteSize)
 
   /**
    * Reads all hprof records from [source].
-   * Assumes the [reader] was just created, with a source that currently points to the start
-   * position of hprof records.
+   * Assumes the [reader] was has a source that currently points to the start position of hprof
+   * records.
    */
+  @Suppress("ComplexMethod", "LongMethod")
   fun readHprofRecords(
     recordTypes: Set<KClass<out HprofRecord>>,
     listener: OnHprofRecordListener
   ) {
-    require(byteReadCount == startByteReadCount) {
-      "readHprofRecords() should only be called on a unused HprofReader instance"
-    }
     val readAllRecords = HprofRecord::class in recordTypes
     val readStringRecord = readAllRecords || StringRecord::class in recordTypes
     val readLoadClassRecord = readAllRecords || LoadClassRecord::class in recordTypes
@@ -121,11 +124,15 @@ class HprofReader constructor(
     val readAllObjectRecords = readAllHeapDumpRecords || ObjectRecord::class in recordTypes
 
     val readClassDumpRecord = readAllObjectRecords || ClassDumpRecord::class in recordTypes
+    val readClassSkipContentRecord = ClassSkipContentRecord::class in recordTypes
     val readInstanceDumpRecord = readAllObjectRecords || InstanceDumpRecord::class in recordTypes
+    val readInstanceSkipContentRecord = InstanceSkipContentRecord::class in recordTypes
     val readObjectArrayDumpRecord =
       readAllObjectRecords || ObjectArrayDumpRecord::class in recordTypes
+    val readObjectArraySkipContentRecord = ObjectArraySkipContentRecord::class in recordTypes
     val readPrimitiveArrayDumpRecord =
       readAllObjectRecords || PrimitiveArrayDumpRecord::class in recordTypes
+    val readPrimitiveArraySkipContentRecord = PrimitiveArraySkipContentRecord::class in recordTypes
 
     val intByteSize = INT.byteSize
 
@@ -142,7 +149,7 @@ class HprofReader constructor(
       when (tag) {
         STRING_IN_UTF8 -> {
           if (readStringRecord) {
-            val recordPosition = byteReadCount
+            val recordPosition = position
             val id = readId()
             val stringLength = length - identifierByteSize
             val string = readUtf8(stringLength)
@@ -154,7 +161,7 @@ class HprofReader constructor(
         }
         LOAD_CLASS -> {
           if (readLoadClassRecord) {
-            val recordPosition = byteReadCount
+            val recordPosition = position
             val classSerialNumber = readInt()
             val id = readId()
             val stackTraceSerialNumber = readInt()
@@ -172,7 +179,7 @@ class HprofReader constructor(
         }
         STACK_FRAME -> {
           if (readStackFrameRecord) {
-            val recordPosition = byteReadCount
+            val recordPosition = position
             val record = StackFrameRecord(
                 id = readId(),
                 methodNameStringId = readId(),
@@ -188,7 +195,7 @@ class HprofReader constructor(
         }
         STACK_TRACE -> {
           if (readStackTraceRecord) {
-            val recordPosition = byteReadCount
+            val recordPosition = position
             val stackTraceSerialNumber = readInt()
             val threadSerialNumber = readInt()
             val frameCount = readInt()
@@ -204,15 +211,15 @@ class HprofReader constructor(
           }
         }
         HEAP_DUMP, HEAP_DUMP_SEGMENT -> {
-          val heapDumpStart = byteReadCount
+          val heapDumpStart = position
           var previousTag = 0
-          while (byteReadCount - heapDumpStart < length) {
+          while (position - heapDumpStart < length) {
             val heapDumpTag = readUnsignedByte()
 
             when (heapDumpTag) {
               ROOT_UNKNOWN -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val record = GcRootRecord(gcRoot = Unknown(id = readId()))
                   listener.onHprofRecord(recordPosition, record)
                 } else {
@@ -221,7 +228,7 @@ class HprofReader constructor(
               }
               ROOT_JNI_GLOBAL -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord =
                     GcRootRecord(gcRoot = JniGlobal(id = readId(), jniGlobalRefId = readId()))
                   listener.onHprofRecord(recordPosition, gcRootRecord)
@@ -232,7 +239,7 @@ class HprofReader constructor(
 
               ROOT_JNI_LOCAL -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(
                       gcRoot = JniLocal(
                           id = readId(), threadSerialNumber = readInt(), frameNumber = readInt()
@@ -246,7 +253,7 @@ class HprofReader constructor(
 
               ROOT_JAVA_FRAME -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(
                       gcRoot = JavaFrame(
                           id = readId(), threadSerialNumber = readInt(), frameNumber = readInt()
@@ -260,7 +267,7 @@ class HprofReader constructor(
 
               ROOT_NATIVE_STACK -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(
                       gcRoot = NativeStack(id = readId(), threadSerialNumber = readInt())
                   )
@@ -272,7 +279,7 @@ class HprofReader constructor(
 
               ROOT_STICKY_CLASS -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(
                       gcRoot = StickyClass(id = readId())
                   )
@@ -285,7 +292,7 @@ class HprofReader constructor(
               // An object that was referenced from an active thread block.
               ROOT_THREAD_BLOCK -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(
                       gcRoot = ThreadBlock(id = readId(), threadSerialNumber = readInt())
                   )
@@ -297,7 +304,7 @@ class HprofReader constructor(
 
               ROOT_MONITOR_USED -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(
                       gcRoot = MonitorUsed(id = readId())
                   )
@@ -309,7 +316,7 @@ class HprofReader constructor(
 
               ROOT_THREAD_OBJECT -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(
                       gcRoot = ThreadObject(
                           id = readId(),
@@ -325,7 +332,7 @@ class HprofReader constructor(
 
               ROOT_INTERNED_STRING -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(gcRoot = InternedString(id = readId()))
                   listener.onHprofRecord(recordPosition, gcRootRecord)
                 } else {
@@ -335,7 +342,7 @@ class HprofReader constructor(
 
               ROOT_FINALIZING -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(
                       gcRoot = Finalizing(id = readId())
                   )
@@ -347,7 +354,7 @@ class HprofReader constructor(
 
               ROOT_DEBUGGER -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(
                       gcRoot = Debugger(id = readId())
                   )
@@ -359,7 +366,7 @@ class HprofReader constructor(
 
               ROOT_REFERENCE_CLEANUP -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(
                       gcRoot = ReferenceCleanup(id = readId())
                   )
@@ -371,7 +378,7 @@ class HprofReader constructor(
 
               ROOT_VM_INTERNAL -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(
                       gcRoot = VmInternal(id = readId())
                   )
@@ -383,7 +390,7 @@ class HprofReader constructor(
 
               ROOT_JNI_MONITOR -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(
                       gcRoot = JniMonitor(
                           id = readId(), stackTraceSerialNumber = readInt(),
@@ -398,7 +405,7 @@ class HprofReader constructor(
 
               ROOT_UNREACHABLE -> {
                 if (readGcRootRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val gcRootRecord = GcRootRecord(
                       gcRoot = Unreachable(id = readId())
                   )
@@ -408,42 +415,65 @@ class HprofReader constructor(
                 }
               }
               CLASS_DUMP -> {
-                if (readClassDumpRecord) {
-                  val recordPosition = byteReadCount
-                  val record = readClassDumpRecord()
-                  listener.onHprofRecord(recordPosition, record)
-                } else {
-                  skipClassDumpRecord()
+                when {
+                  readClassDumpRecord -> {
+                    val recordPosition = position
+                    val record = readClassDumpRecord()
+                    listener.onHprofRecord(recordPosition, record)
+                  }
+                  readClassSkipContentRecord -> {
+                    val recordPosition = position
+                    val record = readClassSkipContentRecord()
+                    listener.onHprofRecord(recordPosition, record)
+                  }
+                  else -> skipClassDumpRecord()
                 }
               }
-
               INSTANCE_DUMP -> {
-                if (readInstanceDumpRecord) {
-                  val recordPosition = byteReadCount
-                  val instanceDumpRecord = readInstanceDumpRecord()
-                  listener.onHprofRecord(recordPosition, instanceDumpRecord)
-                } else {
-                  skipInstanceDumpRecord()
+                when {
+                  readInstanceDumpRecord -> {
+                    val recordPosition = position
+                    val record = readInstanceDumpRecord()
+                    listener.onHprofRecord(recordPosition, record)
+                  }
+                  readInstanceSkipContentRecord -> {
+                    val recordPosition = position
+                    val record = readInstanceSkipContentRecord()
+                    listener.onHprofRecord(recordPosition, record)
+                  }
+                  else -> skipInstanceDumpRecord()
                 }
               }
 
               OBJECT_ARRAY_DUMP -> {
-                if (readObjectArrayDumpRecord) {
-                  val recordPosition = byteReadCount
-                  val arrayRecord = readObjectArrayDumpRecord()
-                  listener.onHprofRecord(recordPosition, arrayRecord)
-                } else {
-                  skipObjectArrayDumpRecord()
+                when {
+                  readObjectArrayDumpRecord -> {
+                    val recordPosition = position
+                    val arrayRecord = readObjectArrayDumpRecord()
+                    listener.onHprofRecord(recordPosition, arrayRecord)
+                  }
+                  readObjectArraySkipContentRecord -> {
+                    val recordPosition = position
+                    val arrayRecord = readObjectArraySkipContentRecord()
+                    listener.onHprofRecord(recordPosition, arrayRecord)
+                  }
+                  else -> skipObjectArrayDumpRecord()
                 }
               }
 
               PRIMITIVE_ARRAY_DUMP -> {
-                if (readPrimitiveArrayDumpRecord) {
-                  val recordPosition = byteReadCount
-                  val record = readPrimitiveArrayDumpRecord()
-                  listener.onHprofRecord(recordPosition, record)
-                } else {
-                  skipPrimitiveArrayDumpRecord()
+                when {
+                  readPrimitiveArrayDumpRecord -> {
+                    val recordPosition = position
+                    val record = readPrimitiveArrayDumpRecord()
+                    listener.onHprofRecord(recordPosition, record)
+                  }
+                  readPrimitiveArraySkipContentRecord -> {
+                    val recordPosition = position
+                    val record = readPrimitiveArraySkipContentRecord()
+                    listener.onHprofRecord(recordPosition, record)
+                  }
+                  else -> skipPrimitiveArrayDumpRecord()
                 }
               }
 
@@ -453,7 +483,7 @@ class HprofReader constructor(
 
               HEAP_DUMP_INFO -> {
                 if (readHeapDumpInfoRecord) {
-                  val recordPosition = byteReadCount
+                  val recordPosition = position
                   val record = readHeapDumpInfoRecord()
                   listener.onHprofRecord(recordPosition, record)
                 } else {
@@ -469,7 +499,7 @@ class HprofReader constructor(
         }
         HEAP_DUMP_END -> {
           if (readHeapDumpEndRecord) {
-            val recordPosition = byteReadCount
+            val recordPosition = position
             val record = HeapDumpEndRecord
             listener.onHprofRecord(recordPosition, record)
           }
@@ -498,6 +528,22 @@ class HprofReader constructor(
     )
   }
 
+  /**
+   * Reads an instance record after a instance dump tag, skipping its content.
+   */
+  fun readInstanceSkipContentRecord(): InstanceSkipContentRecord {
+    val id = readId()
+    val stackTraceSerialNumber = readInt()
+    val classId = readId()
+    val remainingBytesInInstance = readInt()
+    skip(remainingBytesInInstance)
+    return InstanceSkipContentRecord(
+        id = id,
+        stackTraceSerialNumber = stackTraceSerialNumber,
+        classId = classId
+    )
+  }
+
   /**
    * Reads a full class record after a class dump tag.
    */
@@ -565,6 +611,66 @@ class HprofReader constructor(
     )
   }
 
+  /**
+   * Reads a class record after a class dump tag, skipping its content.
+   */
+  fun readClassSkipContentRecord(): ClassSkipContentRecord {
+    val id = readId()
+    // stack trace serial number
+    val stackTraceSerialNumber = readInt()
+    val superclassId = readId()
+    // class loader object ID
+    val classLoaderId = readId()
+    // signers object ID
+    val signersId = readId()
+    // protection domain object ID
+    val protectionDomainId = readId()
+    // reserved
+    readId()
+    // reserved
+    readId()
+
+    // instance size (in bytes)
+    // Useful to compute retained size
+    val instanceSize = readInt()
+
+    // Skip over the constant pool
+    val constantPoolCount = readUnsignedShort()
+    for (i in 0 until constantPoolCount) {
+      // constant pool index
+      skip(SHORT_SIZE)
+      skip(typeSize(readUnsignedByte()))
+    }
+
+    val staticFieldCount = readUnsignedShort()
+    for (i in 0 until staticFieldCount) {
+      skip(identifierByteSize)
+      val type = readUnsignedByte()
+      skip(
+          if (type == PrimitiveType.REFERENCE_HPROF_TYPE) {
+            identifierByteSize
+          } else {
+            PrimitiveType.byteSizeByHprofType.getValue(type)
+          }
+      )
+    }
+
+    val fieldCount = readUnsignedShort()
+    // Each field takes id + byte.
+    skip((identifierByteSize + 1) * fieldCount)
+    return ClassSkipContentRecord(
+        id = id,
+        stackTraceSerialNumber = stackTraceSerialNumber,
+        superclassId = superclassId,
+        classLoaderId = classLoaderId,
+        signersId = signersId,
+        protectionDomainId = protectionDomainId,
+        instanceSize = instanceSize,
+        staticFieldCount = staticFieldCount,
+        fieldCount = fieldCount
+    )
+  }
+
   /**
    * Reads a full primitive array record after a primitive array dump tag.
    */
@@ -602,6 +708,19 @@ class HprofReader constructor(
     }
   }
 
+  /**
+   * Reads a primitive array record after a primitive array dump tag, skipping its content.
+   */
+  fun readPrimitiveArraySkipContentRecord(): PrimitiveArraySkipContentRecord {
+    val id = readId()
+    val stackTraceSerialNumber = readInt()
+    // length
+    val arrayLength = readInt()
+    val type = PrimitiveType.primitiveTypeByHprofType.getValue(readUnsignedByte())
+    skip(arrayLength * type.byteSize)
+    return PrimitiveArraySkipContentRecord(id, stackTraceSerialNumber, arrayLength, type)
+  }
+
   /**
    * Reads a full object array record after a object array dump tag.
    */
@@ -621,6 +740,25 @@ class HprofReader constructor(
     )
   }
 
+  /**
+   * Reads an object array record after a object array dump tag, skipping its content.
+   */
+  fun readObjectArraySkipContentRecord(
+  ): ObjectArraySkipContentRecord {
+    val id = readId()
+    // stack trace serial number
+    val stackTraceSerialNumber = readInt()
+    val arrayLength = readInt()
+    val arrayClassId = readId()
+    skip(identifierByteSize * arrayLength)
+    return ObjectArraySkipContentRecord(
+        id = id,
+        stackTraceSerialNumber = stackTraceSerialNumber,
+        arrayClassId = arrayClassId,
+        size = arrayLength
+    )
+  }
+
   /**
    * Reads a value in the heap dump, which can be a reference or a primitive type.
    */
@@ -644,12 +782,12 @@ class HprofReader constructor(
   }
 
   private fun readShort(): Short {
-    byteReadCount += SHORT_SIZE
+    position += SHORT_SIZE
     return source.readShort()
   }
 
   private fun readInt(): Int {
-    byteReadCount += INT_SIZE
+    position += INT_SIZE
     return source.readInt()
   }
 
@@ -669,7 +807,7 @@ class HprofReader constructor(
     byteCount: Int,
     charset: Charset
   ): String {
-    byteReadCount += byteCount
+    position += byteCount
     return source.readString(byteCount.toLong(), charset)
   }
 
@@ -694,29 +832,29 @@ class HprofReader constructor(
   }
 
   private fun readLong(): Long {
-    byteReadCount += LONG_SIZE
+    position += LONG_SIZE
     return source.readLong()
   }
 
   private fun exhausted() = source.exhausted()
 
   private fun skip(byteCount: Long) {
-    byteReadCount += byteCount
+    position += byteCount
     return source.skip(byteCount)
   }
 
   private fun readByte(): Byte {
-    byteReadCount += BYTE_SIZE
+    position += BYTE_SIZE
     return source.readByte()
   }
 
   private fun readBoolean(): Boolean {
-    byteReadCount += BOOLEAN_SIZE
+    position += BOOLEAN_SIZE
     return source.readByte().toInt() != 0
   }
 
   private fun readByteArray(byteCount: Int): ByteArray {
-    byteReadCount += byteCount
+    position += byteCount
     return source.readByteArray(byteCount.toLong())
   }
 
@@ -744,7 +882,7 @@ class HprofReader constructor(
   }
 
   private fun readUtf8(byteCount: Long): String {
-    byteReadCount += byteCount
+    position += byteCount
     return source.readUtf8(byteCount)
   }
 
@@ -761,7 +899,7 @@ class HprofReader constructor(
   }
 
   private fun skip(byteCount: Int) {
-    byteReadCount += byteCount
+    position += byteCount
     return source.skip(byteCount.toLong())
   }
 
@@ -773,7 +911,8 @@ class HprofReader constructor(
 
   private fun skipClassDumpRecord() {
     skip(
-        identifierByteSize + INT_SIZE + identifierByteSize + identifierByteSize + identifierByteSize + identifierByteSize + identifierByteSize + identifierByteSize + INT_SIZE
+        identifierByteSize + INT_SIZE + identifierByteSize + identifierByteSize + identifierByteSize +
+            identifierByteSize + identifierByteSize + identifierByteSize + INT_SIZE
     )
     // Skip over the constant pool
     val constantPoolCount = readUnsignedShort()
diff --git a/shark-hprof/src/main/java/shark/HprofRecord.kt b/shark-hprof/src/main/java/shark/HprofRecord.kt
index 5009a3cc..66cb0656 100644
--- a/shark-hprof/src/main/java/shark/HprofRecord.kt
+++ b/shark-hprof/src/main/java/shark/HprofRecord.kt
@@ -73,6 +73,22 @@ sealed class HprofRecord {
         )
       }
 
+      /**
+       * This isn't a real record type as found in the heap dump. It's an alternative to
+       * [ClassDumpRecord] for when you don't need the class content.
+       */
+      class ClassSkipContentRecord(
+        val id: Long,
+        val stackTraceSerialNumber: Int,
+        val superclassId: Long,
+        val classLoaderId: Long,
+        val signersId: Long,
+        val protectionDomainId: Long,
+        val instanceSize: Int,
+        val staticFieldCount: Int,
+        val fieldCount: Int
+      ) : ObjectRecord()
+
       class InstanceDumpRecord(
         val id: Long,
         val stackTraceSerialNumber: Int,
@@ -83,6 +99,16 @@ sealed class HprofRecord {
         val fieldValues: ByteArray
       ) : ObjectRecord()
 
+      /**
+       * This isn't a real record type as found in the heap dump. It's an alternative to
+       * [InstanceDumpRecord] for when you don't need the instance content.
+       */
+      class InstanceSkipContentRecord(
+        val id: Long,
+        val stackTraceSerialNumber: Int,
+        val classId: Long
+      ) : ObjectRecord()
+
       class ObjectArrayDumpRecord(
         val id: Long,
         val stackTraceSerialNumber: Int,
@@ -91,11 +117,16 @@ sealed class HprofRecord {
       ) : ObjectRecord()
 
       /**
-       * Note: we could move the arrays to the parent class as a ByteString or ByteArray
-       * and then each subtype can create a new array of the right type if needed.
-       * However, experimenting with live parsing has shown that we never to read arrays except
-       * when we want to display leak trace information, in which case we do need the data.
+       * This isn't a real record type as found in the heap dump. It's an alternative to
+       * [ObjectArrayDumpRecord] for when you don't need the array content.
        */
+      class ObjectArraySkipContentRecord(
+        val id: Long,
+        val stackTraceSerialNumber: Int,
+        val arrayClassId: Long,
+        val size: Int
+      ) : ObjectRecord()
+
       sealed class PrimitiveArrayDumpRecord : ObjectRecord() {
         abstract val id: Long
         abstract val stackTraceSerialNumber: Int
@@ -173,6 +204,17 @@ sealed class HprofRecord {
             get() = array.size
         }
       }
+
+      /**
+       * This isn't a real record type as found in the heap dump. It's an alternative to
+       * [PrimitiveArrayDumpRecord] for when you don't need the array content.
+       */
+      class PrimitiveArraySkipContentRecord(
+        val id: Long,
+        val stackTraceSerialNumber: Int,
+        val size: Int,
+        val type: PrimitiveType
+      ) : ObjectRecord()
     }
 
     class HeapDumpInfoRecord(
diff --git a/shark-hprof/src/main/java/shark/HprofWriter.kt b/shark-hprof/src/main/java/shark/HprofWriter.kt
index 983f670d..cae40126 100644
--- a/shark-hprof/src/main/java/shark/HprofWriter.kt
+++ b/shark-hprof/src/main/java/shark/HprofWriter.kt
@@ -65,6 +65,7 @@ import java.io.File
  *
  * Call [open] to create an instance, [write] to add instances and [close] when you're done.
  */
+@Suppress("TooManyFunctions")
 class HprofWriter private constructor(
   private val sink: BufferedSink,
   val identifierByteSize: Int,
@@ -117,6 +118,7 @@ class HprofWriter private constructor(
     }
   }
 
+  @Suppress("LongMethod")
   private fun BufferedSink.write(record: HprofRecord) {
     when (record) {
       is StringRecord -> {
diff --git a/shark-hprof/src/main/java/shark/PrimitiveType.kt b/shark-hprof/src/main/java/shark/PrimitiveType.kt
index 8c39f497..62794fc0 100644
--- a/shark-hprof/src/main/java/shark/PrimitiveType.kt
+++ b/shark-hprof/src/main/java/shark/PrimitiveType.kt
@@ -29,5 +29,7 @@ enum class PrimitiveType(
     const val REFERENCE_HPROF_TYPE = 2
 
     val byteSizeByHprofType = values().map { it.hprofType to it.byteSize }.toMap()
+
+    val primitiveTypeByHprofType = values().map { it.hprofType to it }.toMap()
   }
 }
\ No newline at end of file
diff --git a/shark-log/build.gradle b/shark-log/build.gradle
index 6655f74f..d1cd98c6 100644
--- a/shark-log/build.gradle
+++ b/shark-log/build.gradle
@@ -8,5 +8,4 @@ dependencies {
   implementation deps.kotlin.stdlib
 }
 
-apply from: rootProject.file('gradle/checkstyle.gradle')
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
diff --git a/shark/build.gradle b/shark/build.gradle
index a9040a90..c4eb5b85 100644
--- a/shark/build.gradle
+++ b/shark/build.gradle
@@ -14,5 +14,4 @@ dependencies {
   testImplementation deps.okio
 }
 
-apply from: rootProject.file('gradle/checkstyle.gradle')
 apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/shark/src/main/java/shark/HeapAnalyzer.kt b/shark/src/main/java/shark/HeapAnalyzer.kt
index 18e80db5..0702cb28 100644
--- a/shark/src/main/java/shark/HeapAnalyzer.kt
+++ b/shark/src/main/java/shark/HeapAnalyzer.kt
@@ -59,6 +59,7 @@ import java.util.concurrent.TimeUnit.NANOSECONDS
 /**
  * Analyzes heap dumps to look for leaks.
  */
+@Suppress("TooManyFunctions")
 class HeapAnalyzer constructor(
   private val listener: OnAnalysisProgressListener
 ) {
@@ -490,6 +491,7 @@ class HeapAnalyzer constructor(
     return status to reason
   }
 
+  @Suppress("LongParameterList")
   private fun buildLeakElement(
     graph: HeapGraph,
     node: ReferencePathNode,
diff --git a/shark/src/main/java/shark/internal/PathFinder.kt b/shark/src/main/java/shark/internal/PathFinder.kt
index 096ddedf..834a7007 100644
--- a/shark/src/main/java/shark/internal/PathFinder.kt
+++ b/shark/src/main/java/shark/internal/PathFinder.kt
@@ -57,6 +57,7 @@ import java.util.LinkedHashMap
  * identified as "to visit last" and then visiting them as needed if no path is
  * found.
  */
+@Suppress("TooManyFunctions")
 internal class PathFinder(
   private val graph: HeapGraph,
   private val listener: OnAnalysisProgressListener,
@@ -233,6 +234,7 @@ internal class PathFinder(
   private fun State.enqueueGcRoots() {
     val gcRoots = sortedGcRoots()
 
+    val threadNames = mutableMapOf<HeapInstance, String>()
     val threadsBySerialNumber = mutableMapOf<Int, Pair<HeapInstance, ThreadObject>>()
     gcRoots.forEach { (objectRecord, gcRoot) ->
       if (computeRetainedHeapSize) {
@@ -247,7 +249,11 @@ internal class PathFinder(
           val (threadInstance, threadRoot) = threadsBySerialNumber.getValue(
               gcRoot.threadSerialNumber
           )
-          val threadName = threadInstance[Thread::class, "name"]?.value?.readAsJavaString()
+          val threadName = threadNames[threadInstance] ?: {
+            val name = threadInstance[Thread::class, "name"]?.value?.readAsJavaString()?:""
+            threadNames[threadInstance] = name
+            name
+          }()
           val referenceMatcher = threadNameReferenceMatchers[threadName]
 
           if (referenceMatcher !is IgnoredReferenceMatcher) {
@@ -436,6 +442,7 @@ internal class PathFinder(
     }
   }
 
+  @Suppress("ReturnCount")
   private fun State.enqueue(
     node: ReferencePathNode
   ) {
@@ -540,6 +547,7 @@ internal class PathFinder(
     }
   }
 
+  @Suppress("ComplexCondition")
   private fun State.updateDominator(
     parent: Long,
     instance: Long,
