diff --git a/README.md b/README.md
index 67d8cced..3150132a 100644
--- a/README.md
+++ b/README.md
@@ -1,375 +1,580 @@
-# ğŸ¤ LeakCanary
+å¤§æ¦‚ä¸€å¹´ä»¥å‰ï¼Œå†™è¿‡ä¸€ç¯‡ [LeakCanary æºç è§£æ](https://juejin.im/post/5a9d46d2f265da237d0280a3) ï¼Œå½“æ—¶æ˜¯åŸºäº `1.5.4` ç‰ˆæœ¬è¿›è¡Œåˆ†æçš„ ã€‚Square å…¬å¸åœ¨ä»Šå¹´å››æœˆä»½å‘å¸ƒäº†å…¨æ–°çš„ `2.0` ç‰ˆæœ¬ï¼Œå®Œå…¨ä½¿ç”¨ Kotlin è¿›è¡Œé‡æ„ï¼Œæ ¸å¿ƒåŸç†å¹¶æ²¡æœ‰å¤ªå¤§å˜åŒ–ï¼Œä½†æ˜¯åšäº†ä¸€å®šçš„æ€§èƒ½ä¼˜åŒ–ã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œå°±è®©æˆ‘ä»¬é€šè¿‡æºç æ¥çœ‹çœ‹ `2.0` ç‰ˆæœ¬å‘ç”Ÿäº†å“ªäº›å˜åŒ–ã€‚æœ¬æ–‡ä¸ä¼šè¿‡å¤šçš„åˆ†ææºç ç»†èŠ‚ï¼Œè¯¦ç»†ç»†èŠ‚å¯ä»¥é˜…è¯»æˆ‘ä¹‹å‰åŸºäº `1.5.4` ç‰ˆæœ¬å†™çš„æ–‡ç« ï¼Œä¸¤ä¸ªç‰ˆæœ¬åœ¨åŸç†æ–¹é¢å¹¶æ²¡æœ‰å¤ªå¤§å˜åŒ–ã€‚
 
-A memory leak detection library for Android.
+> å«æ³¨é‡Š fork ç‰ˆæœ¬ [LeakCanary](https://github.com/lulululbj/leakcanary) æºç 
 
-*â€œA small leak will sink a great ship.â€* - Benjamin Franklin
+## ä½¿ç”¨
 
-<p align="center">
-<img src="https://github.com/square/leakcanary/wiki/assets/screenshot-2.0.png"/>
-</p>
+é¦–å…ˆæ¥å¯¹æ¯”ä¸€ä¸‹ä¸¤ä¸ªç‰ˆæœ¬çš„ä½¿ç”¨æ–¹å¼ã€‚
 
-## Getting started
+### 1.5.4 ç‰ˆæœ¬
 
-Add LeakCanary to `build.gradle`:
+åœ¨è€ç‰ˆæœ¬ä¸­ï¼Œæˆ‘ä»¬éœ€è¦æ·»åŠ å¦‚ä¸‹ä¾èµ–ï¼š
 
-```gradle
+```
 dependencies {
-  // debugImplementation because LeakCanary should only run in debug builds.
-  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-2'
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:1.5.4'
+  releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:1.5.4'
 }
 ```
 
-**That's it, there is no code change needed!** LeakCanary will automatically show a notification when a memory leak is detected in debug builds.
-
-What's next?
-* Learn the [Fundamentals](#fundamentals)
-* Try the [code recipes](#code-recipes)
-* Read the [FAQ](#faq)
-* Watch [recorded presentations](https://github.com/square/leakcanary/wiki/Recorded-Presentations)
-* Read [blog articles](https://github.com/square/leakcanary/wiki/Blog-Articles)
+`leakcanary-android-no-op` åº“åœ¨ `release` ç‰ˆæœ¬ä¸­ä½¿ç”¨ï¼Œå…¶ä¸­æ˜¯æ²¡æœ‰ä»»ä½•é€»è¾‘ä»£ç çš„ã€‚
 
-Note: **LeakCanary 2 is in alpha**.
-* Check out the [migration guide](https://github.com/square/leakcanary/wiki/Migrating-to-LeakCanary-2.0).
-* Here is the [change log](https://github.com/square/leakcanary/blob/master/CHANGELOG.md#version-20-alpha-2-2019-05-21).
-* To set up LeakCanary 1.6, go to the [1.6 Readme](https://github.com/square/leakcanary/blob/master/README-1.6.md).
+ç„¶åéœ€è¦åœ¨è‡ªå·±çš„ `Application` ä¸­è¿›è¡Œåˆå§‹åŒ–ã€‚
 
-## Fundamentals
+```java
+public class ExampleApplication extends Application {
 
-### What is a memory leak?
+  @Override public void onCreate() {
+    super.onCreate();
+    if (LeakCanary.isInAnalyzerProcess(this)) {
+      // This process is dedicated to LeakCanary for heap analysis.
+      // You should not init your app in this process.
+      return;
+    }
+    LeakCanary.install(this);
+    // Normal app init code...
+  }
+}
+```
 
-In a Java based runtime, a memory leak is a programming error that causes an application to keep a reference to an object that is no longer needed. As a result, the memory allocated for that object cannot be reclaimed, eventually leading to an OutOfMemoryError crash.
+`LeakCanary.install()` æ‰§è¡Œåï¼Œå°±ä¼šæ„å»º `RefWatcher` å¯¹è±¡ï¼Œå¼€å§‹ç›‘å¬ `Activity.onDestroy()` å›è°ƒ, é€šè¿‡ `RefWatcher.watch()` ç›‘æµ‹ Activity å¼•ç”¨çš„æ³„éœ²æƒ…å†µã€‚å‘ç°å†…å­˜æ³„éœ²ä¹‹åè¿›è¡Œ `heap dump` ï¼Œåˆ©ç”¨  `Square` å…¬å¸çš„å¦ä¸€ä¸ªåº“ [haha](https://github.com/square/haha)ï¼ˆå·²åºŸå¼ƒï¼‰æ¥åˆ†æ heap dump æ–‡ä»¶ï¼Œæ‰¾åˆ°å¼•ç”¨é“¾ä¹‹åé€šçŸ¥ç”¨æˆ·ã€‚è¿™ä¸€å¥—åŸç†åœ¨æ–°ç‰ˆæœ¬ä¸­è¿˜æ˜¯æ²¡å˜çš„ã€‚
 
-For example, an Android activity instance is no longer needed after its `onDestroy()` method is called, and storing a reference to that activity in a static field would prevent it from being garbage collected.
+### 2.0 ç‰ˆæœ¬
 
-### Why should I use LeakCanary?
+æ–°ç‰ˆæœ¬çš„ä½¿ç”¨æ›´åŠ æ–¹ä¾¿äº†ï¼Œä½ åªéœ€è¦åœ¨ `build.gradle` æ–‡ä»¶ä¸­æ·»åŠ å¦‚ä¸‹ä¾èµ–ï¼š
 
-Memory leaks are very common in Android apps. OutOfMemoryError (OOM) is the top crash for most apps on the play store, however that's usually not counted correctly. When memory is low the OOM can be thrown from anywhere in your code, which means every OOM has a different stacktrace and they're counted as different crashes.
+```
+debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-2'
+```
 
-When we first enabled LeakCanary in the Square Point Of Sale app, we were able to find and fix several leaks and reduced the OutOfMemoryError crash rate by **94%**.
+æ˜¯çš„ï¼Œä½ æ²¡çœ‹è¿‡ï¼Œè¿™æ ·å°±å¯ä»¥äº†ã€‚ä½ è‚¯å®šä¼šæœ‰ä¸€ä¸ªç–‘é—®ï¼Œé‚£å®ƒæ˜¯å¦‚ä½•åˆå§‹åŒ–çš„å‘¢ï¼Ÿæˆ‘åˆšçœ‹åˆ°è¿™ä¸ªä½¿ç”¨æ–‡æ¡£çš„æ—¶å€™ï¼ŒåŒæ ·ä¹Ÿæœ‰è¿™ä¸ªç–‘é—®ã€‚å½“ä½ çœ‹çœ‹æºç ä¹‹åå°±ä¸€ç›®äº†ç„¶äº†ã€‚æˆ‘å…ˆä¸è§£é‡Šï¼Œçœ‹ä¸€ä¸‹æºç ä¸­çš„ `LeakSentryInstaller` è¿™ä¸ªç±»ï¼š
 
-### How does LeakCanary work?
+```kotlin
+/**
+ * Content providers are loaded before the application class is created. [LeakSentryInstaller] is
+ * used to install [leaksentry.LeakSentry] on application start.
+ *
+ * Content Provider åœ¨ Application åˆ›å»ºä¹‹å‰è¢«è‡ªåŠ¨åŠ è½½ï¼Œå› æ­¤æ— éœ€ç”¨æˆ·æ‰‹åŠ¨åœ¨ onCrate() ä¸­è¿›è¡Œåˆå§‹åŒ–
+ */
+internal class LeakSentryInstaller : ContentProvider() {
+
+  override fun onCreate(): Boolean {
+    CanaryLog.logger = DefaultCanaryLog()
+    val application = context!!.applicationContext as Application
+    InternalLeakSentry.install(application) // è¿›è¡Œåˆå§‹åŒ–å·¥ä½œï¼Œæ ¸å¿ƒ
+    return true
+  }
 
-* The library automatically watches destroyed activities and destroyed fragments using weak references. You can also watch any instance that is no longer needed, e.g. a detached view.
-* If the weak references aren't cleared, after waiting 5 seconds and running the GC, the watched instances are considered *retained*, and potentially leaking.
-* When the number of retained instances reaches a threshold, LeakCanary dumps the Java heap into a `.hprof` file stored on the file system. The default threshold is 5 retained instances when the app is visible, 1 otherwise.
-* LeakCanary parses the `.hprof` file and finds the chain of references that prevents retained instances from being garbage collected (**leak trace**). A leak trace is technically the *shortest strong reference path from GC Roots to retained instances*, but that's a mouthful.
-* Once the leak trace is determined, LeakCanary uses its built in knowledge of the Android framework to deduct which instances in the leak trace are leaking. You can help LeakCanary by providing **Reachability inspectors** tailored to your own app.
-* Using the reachability information, LeakCanary narrows down the reference chain to a sub chain of possible leak causes, and displays the result. Leaks are grouped by identical sub chain.
+  override fun query(
+    uri: Uri,
+    strings: Array<String>?,
+    s: String?,
+    strings1: Array<String>?,
+    s1: String?
+  ): Cursor? {
+    return null
+  }
 
-### How do I fix a memory leak?
-To fix a memory leak, you need to look at the sub chain of possible leak causes and find which reference is causing the leak, i.e. which reference should have been cleared at the time of the leak. LeakCanary highlights with a red underline wave the references that are the possible causes of the leak.
+  override fun getType(uri: Uri): String? {
+    return null
+  }
 
-If you cannot figure out a leak, **please do not file an issue**. Instead, create a [Stack Overflow question](http://stackoverflow.com/questions/tagged/leakcanary) using the *leakcanary* tag.
+  override fun insert(
+    uri: Uri,
+    contentValues: ContentValues?
+  ): Uri? {
+    return null
+  }
 
-### LeakCanary artifacts
+  override fun delete(
+    uri: Uri,
+    s: String?,
+    strings: Array<String>?
+  ): Int {
+    return 0
+  }
 
-LeakCanary is released as several distinct libraries:
+  override fun update(
+    uri: Uri,
+    contentValues: ContentValues?,
+    s: String?,
+    strings: Array<String>?
+  ): Int {
+    return 0
+  }
+}
+```
 
-* LeakSentry
-  * Detects retained instances.
-  * Suitable for release builds.
-  * Artifact id: `com.squareup.leakcanary:leaksentry`.
-* LeakCanary
-  * Dumps the heap and analyzes it.
-  * Currently only suitable for debug builds.
-  * Depends on LeakSentry.
-  * Artifact id: `com.squareup.leakcanary:leakcanary-android`.
-* LeakCanary for Instrumentation tests
-  * Fails tests if a leak is detected
-  * Only suitable for Instrumentation tests
-  * Configures LeakCanary to wait for the end of tests before dumping the heap.
-  * Artifact id: `com.squareup.leakcanary:leakcanary-android-instrumentation`.
-  * See [Running LeakCanary in instrumentation tests](#running-leakcanary-in-instrumentation-tests)
+çœ‹åˆ°è¿™ä¸ªç±»ä½ åº”è¯¥ä¹Ÿæ˜ç™½äº†ã€‚LeakCanary åˆ©ç”¨ `ContentProvier` è¿›è¡Œäº†åˆå§‹åŒ–ã€‚`ContentProvier` ä¸€èˆ¬ä¼šåœ¨ `Application` è¢«åˆ›å»ºä¹‹å‰è¢«åŠ è½½ï¼ŒLeakCanary åœ¨å…¶ `onCreate()` æ–¹æ³•ä¸­è°ƒç”¨äº† `InternalLeakSentry.install(application)` è¿›è¡Œåˆå§‹åŒ–ã€‚è¿™åº”è¯¥æ˜¯æˆ‘ç¬¬ä¸€æ¬¡çœ‹åˆ°ç¬¬ä¸‰æ–¹åº“è¿™ä¹ˆè¿›è¡Œåˆå§‹åŒ–ã€‚è¿™çš„ç¡®æ˜¯æ–¹ä¾¿äº†å¼€å‘è€…ï¼Œä½†æ˜¯ä»”ç»†æƒ³æƒ³å¼Šç«¯è¿˜æ˜¯å¾ˆå¤§çš„ï¼Œå¦‚æœæ‰€æœ‰ç¬¬ä¸‰æ–¹åº“éƒ½è¿™ä¹ˆå¹²ï¼Œå¼€å‘è€…å°±æ²¡æ³•æ§åˆ¶åº”ç”¨å¯åŠ¨æ—¶é—´äº†ã€‚å¾ˆå¤šå¼€å‘è€…ä¸ºäº†åŠ å¿«åº”ç”¨å¯åŠ¨é€Ÿåº¦ï¼Œéƒ½ä¸‹äº†å¾ˆå¤§å¿ƒè¡€ï¼ŒåŒ…æ‹¬æŒ‰éœ€å»¶è¿Ÿåˆå§‹åŒ–ç¬¬ä¸‰æ–¹åº“ã€‚ä½†åœ¨ LeakCanary ä¸­ï¼Œè¿™ä¸ªé—®é¢˜å¹¶ä¸å­˜åœ¨ï¼Œå› ä¸ºå®ƒæœ¬èº«å°±æ˜¯ä¸€ä¸ªåªåœ¨ debug ç‰ˆæœ¬ä¸­ä½¿ç”¨çš„åº“ï¼Œå¹¶ä¸ä¼šå¯¹ release ç‰ˆæœ¬æœ‰ä»»ä½•å½±å“ã€‚
 
-## Code Recipes
+## æºç è§£æ
 
-If you think a recipe might be missing or you're not sure that what you're trying to achieve is possible with the current APIs, please [file an issue](https://github.com/square/leakcanary/issues/new/choose). Your feedback help us make LeakCanary better for the entire community.
+å‰é¢æåˆ°äº† `InternalLeakSentry.install()` å°±æ˜¯æ ¸å¿ƒçš„åˆå§‹åŒ–å·¥ä½œï¼Œå…¶åœ°ä½å°±å’Œ 1.5.4 ç‰ˆæœ¬ä¸­çš„ `LeakCanary.install()` ä¸€æ ·ã€‚ä¸‹é¢å°±ä» `install()` æ–¹æ³•å¼€å§‹ï¼Œèµ°è¿› `LeakCanary 2.0` ä¸€æ¢ç©¶ç«Ÿã€‚
 
-### Configuring LeakSentry
+### 1. LeakCanary.install()
 
-LeakSentry can be configured by replacing `LeakSentry.config`:
 ```kotlin
-class DebugExampleApplication : ExampleApplication() {
-
-  override fun onCreate() {
-    super.onCreate()
-    LeakSentry.config = LeakSentry.config.copy(watchFragmentViews = false)
-  }
+fun install(application: Application) {
+    CanaryLog.d("Installing LeakSentry")
+    checkMainThread() // åªèƒ½åœ¨ä¸»çº¿ç¨‹è°ƒç”¨ï¼Œå¦åˆ™ä¼šæŠ›å‡ºå¼‚å¸¸
+    if (this::application.isInitialized) {
+      return
+    }
+    InternalLeakSentry.application = application
+
+    val configProvider = { LeakSentry.config }
+    ActivityDestroyWatcher.install( // ç›‘å¬ Activity.onDestroy()ï¼Œè§ 1.1
+        application, refWatcher, configProvider
+    )
+    FragmentDestroyWatcher.install( // ç›‘å¬ Fragment.onDestroy()ï¼Œè§ 1.2
+        application, refWatcher, configProvider
+    )
+    listener.onLeakSentryInstalled(application) // è§ 1.3
 }
 ```
 
-### Configuring LeakCanary
+`install()` æ–¹æ³•ä¸»è¦åšäº†ä¸‰ä»¶äº‹:
+
+* æ³¨å†Œ `Activity.onDestroy()` ç›‘å¬
+* æ³¨å†Œ `Fragment.onDestroy()` ç›‘å¬
+* ç›‘å¬å®Œæˆåè¿›è¡Œä¸€äº›åˆå§‹åŒ–å·¥ä½œ
 
-LeakCanary can be configured by replacing `LeakCanary.config`:
+ä¾æ¬¡çœ‹ä¸€çœ‹ã€‚
+
+#### 1.1 ActivityDestroyWatcher.install()
+
+`ActivityDestroyWatcher` ç±»çš„æºç å¾ˆç®€å•ï¼š
 
 ```kotlin
-disableLeakCanaryButton.setOnClickListener {
-  LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
+internal class ActivityDestroyWatcher private constructor(
+  private val refWatcher: RefWatcher,
+  private val configProvider: () -> Config
+) {
+
+  private val lifecycleCallbacks = object : ActivityLifecycleCallbacksAdapter() {
+    override fun onActivityDestroyed(activity: Activity) {
+      if (configProvider().watchActivities) {
+        refWatcher.watch(activity) // ç›‘å¬åˆ° onDestroy() ä¹‹åï¼Œé€šè¿‡ refWatcher ç›‘æµ‹ Activity
+      }
+    }
+  }
+
+  companion object {
+    fun install(
+      application: Application,
+      refWatcher: RefWatcher,
+      configProvider: () -> Config
+    ) {
+      val activityDestroyWatcher =
+        ActivityDestroyWatcher(refWatcher, configProvider)
+      // æ³¨å†Œ Activity ç”Ÿå‘½å‘¨æœŸç›‘å¬
+      application.registerActivityLifecycleCallbacks(activityDestroyWatcher.lifecycleCallbacks)
+    }
+  }
 }
 ```
 
-### Watching objects with a lifecycle
+`install()` æ–¹æ³•ä¸­æ³¨å†Œäº† Activity ç”Ÿå‘½å‘¨æœŸç›‘å¬ï¼Œåœ¨ç›‘å¬åˆ° `onDestroy()` æ—¶ï¼Œè°ƒç”¨ `RefWatcher.watch()` æ–¹æ³•å¼€å§‹ç›‘æµ‹ Activityã€‚
+
+#### 1.2 FragmentDestroyWatcher.install()
 
-In your application, you may have other objects with a lifecycle, such as fragments, services, Dagger components, etc. Use `LeakSentry.refWatcher` to watch instances that should be garbage collected:
+`FragmentDestroyWatcher` æ˜¯ä¸€ä¸ªæ¥å£ï¼Œå®ƒæœ‰ä¸¤ä¸ªå®ç°ç±» `AndroidOFragmentDestroyWatcher` å’Œ `SupportFragmentDestroyWatcher`ã€‚
 
 ```kotlin
-class MyService : Service {
+internal interface FragmentDestroyWatcher {
+
+  fun watchFragments(activity: Activity)
+
+  companion object {
+
+    private const val SUPPORT_FRAGMENT_CLASS_NAME = "androidx.fragment.app.Fragment"
+
+    fun install(
+      application: Application,
+      refWatcher: RefWatcher,
+      configProvider: () -> LeakSentry.Config
+    ) {
+      val fragmentDestroyWatchers = mutableListOf<FragmentDestroyWatcher>()
+
+      if (SDK_INT >= O) { // >= 26ï¼Œä½¿ç”¨ AndroidOFragmentDestroyWatcher
+        fragmentDestroyWatchers.add(
+            AndroidOFragmentDestroyWatcher(refWatcher, configProvider)
+        )
+      }
+
+      if (classAvailable(
+              SUPPORT_FRAGMENT_CLASS_NAME
+          )
+      ) {
+        fragmentDestroyWatchers.add( // androidx ä½¿ç”¨ SupportFragmentDestroyWatcher
+            SupportFragmentDestroyWatcher(refWatcher, configProvider)
+        )
+      }
 
-  // ...
+      if (fragmentDestroyWatchers.size == 0) {
+        return
+      }
 
-  override fun onDestroy() {
-    super.onDestroy()
-    LeakSentry.refWatcher.watch(this)
+      application.registerActivityLifecycleCallbacks(object : ActivityLifecycleCallbacksAdapter() {
+        override fun onActivityCreated(
+          activity: Activity,
+          savedInstanceState: Bundle?
+        ) {
+          for (watcher in fragmentDestroyWatchers) {
+            watcher.watchFragments(activity)
+          }
+        }
+      })
+    }
+
+    private fun classAvailable(className: String): Boolean {
+      return try {
+        Class.forName(className)
+        true
+      } catch (e: ClassNotFoundException) {
+        false
+      }
+    }
   }
 }
 ```
 
-### Counting retained instances in production
+å¦‚æœæˆ‘æ²¡è®°é”™çš„è¯ï¼Œ`1.5.4` æ˜¯ä¸ç›‘æµ‹ Fragment çš„æ³„éœ²çš„ã€‚è€Œ `2.0` ç‰ˆæœ¬æä¾›äº†å¯¹ `Android O` ä»¥åŠ `androidx` ç‰ˆæœ¬ä¸­çš„ Fragment çš„å†…å­˜æ³„éœ²æ£€æµ‹ã€‚ `AndroidOFragmentDestroyWatcher` å’Œ `SupportFragmentDestroyWatcher` çš„å®ç°ä»£ç å…¶å®æ˜¯ä¸€è‡´çš„ï¼ŒAndroid O åŠä»¥åï¼Œandroidx éƒ½å…·å¤‡å¯¹ Fragment ç”Ÿå‘½å‘¨æœŸçš„ç›‘å¬åŠŸèƒ½ã€‚ä»¥ `AndroidOFragmentDestroyWatcher` ä¸ºä¾‹ï¼Œç®€å•çœ‹ä¸€ä¸‹å®ƒçš„å®ç°ã€‚
 
-`com.squareup.leakcanary:leakcanary-android` should only be used in debug builds. It depends on `com.squareup.leakcanary:leaksentry` which you can use in production to track and count retained instances.
+```kotlin
+@RequiresApi(Build.VERSION_CODES.O) //
+internal class AndroidOFragmentDestroyWatcher(
+  private val refWatcher: RefWatcher,
+  private val configProvider: () -> Config
+) : FragmentDestroyWatcher {
+
+  private val fragmentLifecycleCallbacks = object : FragmentManager.FragmentLifecycleCallbacks() {
+
+    override fun onFragmentViewDestroyed(
+      fm: FragmentManager,
+      fragment: Fragment
+    ) {
+      val view = fragment.view
+      if (view != null && configProvider().watchFragmentViews) {
+        refWatcher.watch(view)
+      }
+    }
 
-In your `build.gradle`:
+    override fun onFragmentDestroyed(
+      fm: FragmentManager,
+      fragment: Fragment
+    ) {
+      if (configProvider().watchFragments) {
+        refWatcher.watch(fragment)
+      }
+    }
+  }
 
-```gradle
-dependencies {
-  implementation 'com.squareup.leakcanary:leaksentry:2.0-alpha-2'
+  override fun watchFragments(activity: Activity) {
+    val fragmentManager = activity.fragmentManager
+    fragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, true)
+  }
 }
 ```
 
-In your leak reporting code:
-```kotlin
-val retainedInstanceCount = LeakSentry.refWatcher.retainedKeys.size
-```
+åŒæ ·ï¼Œè¿˜æ˜¯ä½¿ç”¨ `RefWatcher.watch()` æ–¹æ³•æ¥è¿›è¡Œç›‘æµ‹ã€‚
 
-### Running LeakCanary in instrumentation tests
+#### 1.3 listener.onLeakSentryInstalled()
 
-Add the `leakcanary-android-instrumentation` dependency to your instrumentation tests:
+`onLeakSentryInstalled()` å›è°ƒä¸­ä¼šåˆå§‹åŒ–ä¸€äº›æ£€æµ‹å†…å­˜æ³„éœ²è¿‡ç¨‹ä¸­éœ€è¦çš„å¯¹è±¡ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
 
-```
-androidTestImplementation "com.squareup.leakcanary:leakcanary-android-instrumentation:${leakCanaryVersion}"
-```
+```kotlin
+override fun onLeakSentryInstalled(application: Application) {
+    this.application = application
 
-Add the dedicated run listener to `defaultConfig` in your `build.gradle`:
+    val heapDumper = AndroidHeapDumper(application, leakDirectoryProvider) // ç”¨äº heap dump
 
-```
-android {
-  defaultConfig {
-    // ...
+    val gcTrigger = GcTrigger.Default // ç”¨äºæ‰‹åŠ¨è°ƒç”¨ GC
 
-    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
-    testInstrumentationRunnerArgument "listener", "leakcanary.FailTestOnLeakRunListener"
-  }
+    val configProvider = { LeakCanary.config } // é…ç½®é¡¹
+
+    val handlerThread = HandlerThread(LEAK_CANARY_THREAD_NAME)
+    handlerThread.start()
+    val backgroundHandler = Handler(handlerThread.looper) // å‘èµ·å†…å­˜æ³„æ¼æ£€æµ‹çš„çº¿ç¨‹
+
+    heapDumpTrigger = HeapDumpTrigger(
+        application, backgroundHandler, LeakSentry.refWatcher, gcTrigger, heapDumper, configProvider
+    )
+    application.registerVisibilityListener { applicationVisible ->
+      this.applicationVisible = applicationVisible
+      heapDumpTrigger.onApplicationVisibilityChanged(applicationVisible)
+    }
+    addDynamicShortcut(application)
 }
 ```
 
-Run the instrumentation tests:
+å¯¹è€ç‰ˆæœ¬ä»£ç ç†Ÿæ‚‰çš„åŒå­¦ï¼Œçœ‹åˆ°è¿™äº›å¯¹è±¡åº”è¯¥å¾ˆç†Ÿæ‚‰ã€‚
 
-```
-./gradlew leakcanary-sample:connectedCheck
-```
+* `heapDumper` ç”¨äºç¡®è®¤å†…å­˜æ³„æ¼ä¹‹åè¿›è¡Œ heap dump å·¥ä½œã€‚
+* `gcTrigger` ç”¨äºå‘ç°å¯èƒ½çš„å†…å­˜æ³„æ¼ä¹‹åæ‰‹åŠ¨è°ƒç”¨ GC ç¡®è®¤æ˜¯å¦çœŸçš„ä¸ºå†…å­˜æ³„éœ²ã€‚
 
-You can extend `FailTestOnLeakRunListener` to customize the behavior.
+è¿™ä¸¤ä¸ªå¯¹è±¡æ˜¯ LeakCanary æ£€æµ‹å†…å­˜æ³„æ¼çš„æ ¸å¿ƒã€‚åé¢ä¼šè¿›è¡Œè¯¦ç»†åˆ†æã€‚
 
-### Icon and label
+åˆ°è¿™é‡Œï¼Œæ•´ä¸ª LeakCanary çš„åˆå§‹åŒ–å·¥ä½œå°±å®Œæˆäº†ã€‚ä¸ 1.5.4 ç‰ˆæœ¬ä¸åŒçš„æ˜¯ï¼Œæ–°ç‰ˆæœ¬å¢åŠ äº†å¯¹ Fragment ä»¥åŠ androidx çš„æ”¯æŒã€‚å½“å‘ç”Ÿ `Activity.onDestroy()` ï¼Œ`Fragment.onFragmentViewDestroyed()` , `Fragment.onFragmentDestroyed()` ä¸‰è€…ä¹‹ä¸€æ—¶ï¼Œ`RefWatcher` å°±å¼€å§‹å·¥ä½œäº†ï¼Œè°ƒç”¨å…¶ `watch()` æ–¹æ³•å¼€å§‹æ£€æµ‹å¼•ç”¨æ˜¯å¦æ³„éœ²ã€‚
 
-The activity that displays leaks comes with a default icon and label, which you can change by providing `R.mipmap.leak_canary_icon` and `R.string.leak_canary_display_activity_label` in your app:
+### 2. RefWatcher.watch()
 
-```
-res/
-  mipmap-hdpi/
-    leak_canary_icon.png
-  mipmap-mdpi/
-    leak_canary_icon.png
-  mipmap-xhdpi/
-    leak_canary_icon.png
-  mipmap-xxhdpi/
-    leak_canary_icon.png
-  mipmap-xxxhdpi/
-    leak_canary_icon.png
-   mipmap-anydpi-v26/
-     leak_canary_icon.xml
-```
+åœ¨çœ‹æºç ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹å‡ ä¸ªåé¢ä¼šä½¿ç”¨åˆ°çš„é˜Ÿåˆ—ã€‚
 
-```xml
-<?xml version="1.0" encoding="utf-8"?>
-<resources>
-  <string name="leak_canary_display_activity_label">MyLeaks</string>
-</resources>
+```kotlin
+  /**
+   * References passed to [watch] that haven't made it to [retainedReferences] yet.
+   * watch() æ–¹æ³•ä¼ è¿›æ¥çš„å¼•ç”¨ï¼Œå°šæœªåˆ¤å®šä¸ºæ³„éœ²
+   */
+  private val watchedReferences = mutableMapOf<String, KeyedWeakReference>()
+  /**
+   * References passed to [watch] that we have determined to be retained longer than they should
+   * have been.
+   * watch() æ–¹æ³•ä¼ è¿›æ¥çš„å¼•ç”¨ï¼Œå·²ç»è¢«åˆ¤å®šä¸ºæ³„éœ²
+   */
+  private val retainedReferences = mutableMapOf<String, KeyedWeakReference>()
+  private val queue = ReferenceQueue<Any>() // å¼•ç”¨é˜Ÿåˆ—ï¼Œé…åˆå¼±å¼•ç”¨ä½¿ç”¨
 ```
 
-### Uploading to a server
+é€šè¿‡ `watch()` æ–¹æ³•ä¼ å…¥çš„å¼•ç”¨éƒ½ä¼šä¿å­˜åœ¨ `watchedReferences` ä¸­ï¼Œè¢«åˆ¤å®šæ³„éœ²ä¹‹åä¿å­˜åœ¨ `retainedReferences` ä¸­ã€‚æ³¨æ„ï¼Œè¿™é‡Œçš„åˆ¤å®šè¿‡ç¨‹ä¸æ­¢ä¼šå‘ç”Ÿä¸€æ¬¡ï¼Œå·²ç»è¿›å…¥é˜Ÿåˆ— `retainedReferences` çš„å¼•ç”¨ä»æœ‰å¯èƒ½è¢«ç§»é™¤ã€‚`queue` æ˜¯ä¸€ä¸ª `ReferenceQueue` å¼•ç”¨é˜Ÿåˆ—ï¼Œé…åˆå¼±å¼•ç”¨ä½¿ç”¨ï¼Œè¿™é‡Œè®°ä½ä¸€å¥è¯ï¼š
+
+> å¼±å¼•ç”¨ä¸€æ—¦å˜å¾—å¼±å¯è¾¾ï¼Œå°±ä¼šç«‹å³å…¥é˜Ÿã€‚è¿™å°†åœ¨ finalization æˆ–è€… GC ä¹‹å‰å‘ç”Ÿã€‚
 
-You can change the default behavior to upload the analysis result to a server of your choosing.
+ä¹Ÿå°±æ˜¯è¯´ï¼Œä¼šè¢« GC å›æ”¶çš„å¯¹è±¡å¼•ç”¨ï¼Œä¼šä¿å­˜åœ¨é˜Ÿåˆ— `queue` ä¸­ã€‚
 
-Create a custom `AnalysisResultListener` that delegates to the default: 
+å›å¤´å†æ¥çœ‹çœ‹ `watch()` æ–¹æ³•çš„æºç ã€‚
 
 ```kotlin
-class LeakUploader : AnalysisResultListener {
-  override fun invoke(
-    application: Application,
-    heapAnalysis: HeapAnalysis
+  @Synchronized fun watch(
+    watchedReference: Any,
+    referenceName: String
   ) {
-    TODO("Upload heap analysis to server")
+    if (!isEnabled()) {
+      return
+    }
+    removeWeaklyReachableReferences() // ç§»é™¤é˜Ÿåˆ—ä¸­å°†è¦è¢« GC çš„å¼•ç”¨ï¼Œè§ 2.1
+    val key = UUID.randomUUID()
+        .toString()
+    val watchUptimeMillis = clock.uptimeMillis()
+    val reference = // æ„å»ºå½“å‰å¼•ç”¨çš„å¼±å¼•ç”¨å¯¹è±¡ï¼Œå¹¶å…³è”å¼•ç”¨é˜Ÿåˆ— queue
+      KeyedWeakReference(watchedReference, key, referenceName, watchUptimeMillis, queue)
+    if (referenceName != "") {
+      CanaryLog.d(
+          "Watching instance of %s named %s with key %s", reference.className,
+          referenceName, key
+      )
+    } else {
+      CanaryLog.d(
+          "Watching instance of %s with key %s", reference.className, key
+      )
+    }
 
-    // Delegate to default behavior (notification and saving result)
-    DefaultAnalysisResultListener(application, heapAnalysis)
+    watchedReferences[key] = reference // å°†å¼•ç”¨å­˜å…¥ watchedReferences
+    checkRetainedExecutor.execute {
+      moveToRetained(key) // å¦‚æœå½“å‰å¼•ç”¨æœªè¢«ç§»é™¤ï¼Œä»åœ¨ watchedReferences  é˜Ÿåˆ—ä¸­ï¼Œ
+                          // è¯´æ˜ä»æœªè¢« GCï¼Œç§»å…¥ retainedReferences é˜Ÿåˆ—ä¸­,æš‚æ—¶æ ‡è®°ä¸ºæ³„éœ²
+                          // è§ 2.2
+    }
   }
-}
 ```
 
-Set `analysisResultListener` on the LeakCanary config:
+é€»è¾‘è¿˜æ˜¯æ¯”è¾ƒæ¸…æ™°çš„ï¼Œé¦–å…ˆä¼šè°ƒç”¨ `removeWeaklyReachableReferences()` æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•åœ¨æ•´ä¸ªè¿‡ç¨‹ä¸­ä¼šå¤šæ¬¡è°ƒç”¨ã€‚å…¶ä½œç”¨æ˜¯ç§»é™¤ `watchedReferences` ä¸­å°†è¢« GC çš„å¼•ç”¨ã€‚
 
-```kotlin
-class DebugExampleApplication : ExampleApplication() {
+#### 2.1 removeWeaklyReachableReferences()
 
-  override fun onCreate() {
-    super.onCreate()
-    LeakCanary.config = LeakCanary.config.copy(analysisResultListener = LeakUploader())
+```kotlin
+  private fun removeWeaklyReachableReferences() {
+    // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
+    // reachable. This is before finalization or garbage collection has actually happened.
+    // å¼±å¼•ç”¨ä¸€æ—¦å˜å¾—å¼±å¯è¾¾ï¼Œå°±ä¼šç«‹å³å…¥é˜Ÿã€‚è¿™å°†åœ¨ finalization æˆ–è€… GC ä¹‹å‰å‘ç”Ÿã€‚
+    var ref: KeyedWeakReference?
+    do {
+      ref = queue.poll() as KeyedWeakReference? // é˜Ÿåˆ— queue ä¸­çš„å¯¹è±¡éƒ½æ˜¯ä¼šè¢« GC çš„
+      if (ref != null) {
+        val removedRef = watchedReferences.remove(ref.key)
+        if (removedRef == null) {
+          retainedReferences.remove(ref.key)
+        }
+        // ç§»é™¤ watchedReferences é˜Ÿåˆ—ä¸­çš„ä¼šè¢« GC çš„ ref å¯¹è±¡ï¼Œå‰©ä¸‹çš„å°±æ˜¯å¯èƒ½æ³„éœ²çš„å¯¹è±¡
+      }
+    } while (ref != null)
   }
-}
 ```
 
+æ•´ä¸ªè¿‡ç¨‹ä¸­ä¼šå¤šæ¬¡è°ƒç”¨ï¼Œä»¥ç¡®ä¿å°†å·²ç»å…¥é˜Ÿ `queue` çš„å°†è¢« GC çš„å¯¹è±¡å¼•ç”¨ç§»é™¤æ‰ï¼Œé¿å…æ— è°“çš„ heap dump æ“ä½œã€‚è€Œä»åœ¨ `watchedReferences` é˜Ÿåˆ—ä¸­çš„å¼•ç”¨ï¼Œåˆ™å¯èƒ½å·²ç»æ³„éœ²ï¼Œç§»åˆ°é˜Ÿåˆ— `retainedReferences` ä¸­ï¼Œè¿™å°±æ˜¯ `moveToRetained()` æ–¹æ³•çš„é€»è¾‘ã€‚ä»£ç å¦‚ä¸‹ï¼š
 
-### Identifying 3rd party leaks as "won't fix"
+#### 2.2 moveToRetained()
 
-Set `exclusionsFactory` on the LeakCanary config to a `ExclusionsFactory` that delegates to the default one and then and add custom exclusions:
+```kotlin
+  @Synchronized private fun moveToRetained(key: String) {
+    removeWeaklyReachableReferences() // å†æ¬¡è°ƒç”¨ï¼Œé˜²æ­¢é—æ¼
+    val retainedRef = watchedReferences.remove(key)
+    if (retainedRef != null) {
+      retainedReferences[key] = retainedRef
+      onReferenceRetained()
+    }
+  }
+```
+
+è¿™é‡Œçš„ `onReferenceRetained()` æœ€åä¼šå›è°ƒåˆ° `InternalLeakCanary.kt` ä¸­ã€‚
 
 ```kotlin
-class DebugExampleApplication : ExampleApplication() {
-
-  override fun onCreate() {
-    super.onCreate()
-    LeakCanary.config = LeakCanary.config.copy(exclusionsFactory = { hprofParser ->
-      val defaultFactory = AndroidExcludedRefs.exclusionsFactory(AndroidExcludedRefs.appDefaults)
-      val appDefaults = defaultFactory(hprofParser)
-      val customExclusion = Exclusion(
-          type = StaticFieldExclusion("com.thirdparty.SomeSingleton", "sContext"),
-          status = Exclusion.Status.WONT_FIX_LEAK,
-          reason = "SomeSingleton in library X has a static field leaking a context."
-      )
-      appDefaults + customExclusion
-    })
+  override fun onReferenceRetained() {
+    if (this::heapDumpTrigger.isInitialized) {
+      heapDumpTrigger.onReferenceRetained()
+    }
   }
-}
 ```
 
-### Identifying leaking instances and labeling instances
+è°ƒç”¨äº† `HeapDumpTrigger` çš„ `onReferenceRetained()` æ–¹æ³•ã€‚
 
 ```kotlin
-class DebugExampleApplication : ExampleApplication() {
+  fun onReferenceRetained() {
+    scheduleRetainedInstanceCheck("found new instance retained")
+  }
 
-  override fun onCreate() {
-    super.onCreate()
-    val customLabeler: Labeler = { parser, node ->
-      listOf("Heap dump object id is ${node.instance}")
+    private fun scheduleRetainedInstanceCheck(reason: String) {
+    if (checkScheduled) {
+      return
     }
-    val labelers = AndroidLabelers.defaultAndroidLabelers(this) + customLabeler
-
-    val customInspector: LeakInspector = { parser, node ->
-      with(parser) {
-        if (node.instance.objectRecord.isInstanceOf("com.example.MySingleton")) {
-          LeakNodeStatus.notLeaking("MySingleton is a singleton")
-        } else LeakNodeStatus.unknown()
-      }
+    checkScheduled = true
+    backgroundHandler.post {
+      checkScheduled = false
+      checkRetainedInstances(reason) // æ£€æµ‹æ³„éœ²å®ä¾‹
     }
-    val leakInspectors = AndroidLeakInspectors.defaultAndroidInspectors() + customInspector
-
-    LeakCanary.config = LeakCanary.config.copy(labelers = labelers, leakInspectors = leakInspectors)
   }
-}
 ```
 
-## FAQ
-
-### Can a leak be caused by the Android SDK?
+`checkRetainedInstances()` æ–¹æ³•æ˜¯ç¡®å®šæ³„éœ²çš„æœ€åä¸€ä¸ªæ–¹æ³•äº†ã€‚è¿™é‡Œä¼šç¡®è®¤å¼•ç”¨æ˜¯å¦çœŸçš„æ³„éœ²ï¼Œå¦‚æœçœŸçš„æ³„éœ²ï¼Œåˆ™å‘èµ· heap dumpï¼Œåˆ†æ dump æ–‡ä»¶ï¼Œæ‰¾åˆ°å¼•ç”¨é“¾ï¼Œæœ€åé€šçŸ¥ç”¨æˆ·ã€‚æ•´ä½“æµç¨‹å’Œè€ç‰ˆæœ¬æ˜¯ä¸€è‡´çš„ï¼Œä½†åœ¨ä¸€äº›ç»†èŠ‚å¤„ç†ï¼Œä»¥åŠ dump æ–‡ä»¶çš„åˆ†æä¸Šæœ‰æ‰€åŒºåˆ«ã€‚ä¸‹é¢è¿˜æ˜¯é€šè¿‡æºç æ¥çœ‹çœ‹è¿™äº›åŒºåˆ«ã€‚
 
-Yes. There are a number of known memory leaks that have been fixed over time in AOSP as well as in manufacturer implementations. When such a leak occurs, there is little you can do as an app developer to fix it. For that reason, LeakCanary has a built-in list of known Android leaks to ignore: [AndroidExcludedRefs.kt](https://github.com/square/leakcanary/blob/master/leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt).
-
-If you find a new one, please [create an issue](https://github.com/square/leakcanary/issues/new/choose) and follow these steps:
+```kotlin
+  private fun checkRetainedInstances(reason: String) {
+    CanaryLog.d("Checking retained instances because %s", reason)
+    val config = configProvider()
+    // A tick will be rescheduled when this is turned back on.
+    if (!config.dumpHeap) {
+      return
+    }
 
-1. Provide the entire leak trace information (reference key, device, etc), and use backticks (`) for formatting.
-2. Read the AOSP source for that version of Android, and try to figure out why it happens. You can easily navigate through SDK versions [android/platform_frameworks_base](https://github.com/android/platform_frameworks_base).
-3. Check if it happens on the latest version of Android, and otherwise use blame to find when it was fixed.
-4. If it's still happening, build a simple repro case
-5. File an issue on [b.android.com](http://b.android.com) with the leak trace and the repro case
-6. Create a PR in LeakCanary to update `AndroidExcludedRefs.kt`. Optional: if you find a hack to clear that leak on previous versions of Android, feel free to document it.
+    var retainedKeys = refWatcher.retainedKeys
 
-### How do I share a leak trace?
+    // å½“å‰æ³„éœ²å®ä¾‹ä¸ªæ•°å°äº 5 ä¸ªï¼Œä¸è¿›è¡Œ heap dump
+    if (checkRetainedCount(retainedKeys, config.retainedVisibleThreshold)) return
 
-* Go to the leak screen, click the overflow menu and select *Share Info*.
-* You can also find the leak trace in Logcat.
+    if (!config.dumpHeapWhenDebugging && DebuggerControl.isDebuggerAttached) {
+      showRetainedCountWithDebuggerAttached(retainedKeys.size)
+      scheduleRetainedInstanceCheck("debugger was attached", WAIT_FOR_DEBUG_MILLIS)
+      CanaryLog.d(
+          "Not checking for leaks while the debugger is attached, will retry in %d ms",
+          WAIT_FOR_DEBUG_MILLIS
+      )
+      return
+    }
 
-### How can I dig beyond the leak trace?
+    // å¯èƒ½å­˜åœ¨è¢«è§‚å¯Ÿçš„å¼•ç”¨å°†è¦å˜å¾—å¼±å¯è¾¾ï¼Œä½†æ˜¯è¿˜æœªå…¥é˜Ÿå¼•ç”¨é˜Ÿåˆ—ã€‚
+    // è¿™æ—¶å€™åº”è¯¥ä¸»åŠ¨è°ƒç”¨ä¸€æ¬¡ GCï¼Œå¯èƒ½å¯ä»¥é¿å…ä¸€æ¬¡ heap dump
+    gcTrigger.runGc()
 
-Sometimes the leak trace isn't enough and you need to dig into a heap dump with [MAT](http://eclipse.org/mat/) or [YourKit](https://www.yourkit.com/).
+    retainedKeys = refWatcher.retainedKeys
 
-* Go to a heap analysis screen, click the overflow menu and select *Share Heap Dump*.
+    if (checkRetainedCount(retainedKeys, config.retainedVisibleThreshold)) return
 
-Here's how you can find the leaking instance in the heap dump:
+    HeapDumpMemoryStore.setRetainedKeysForHeapDump(retainedKeys)
 
-1. Look for all instances of `leakcanary.KeyedWeakReference`
-2. For each of these, look at the `key` field.
-3. Find the `KeyedWeakReference` that has a `key` field equal to the reference key reported by LeakCanary.
-4. The `referent` field of that `KeyedWeakReference` is your leaking object.
-5. From then on, the matter is in your hands. A good start is to look at the shortest path to GC Roots (excluding weak references).
+    CanaryLog.d("Found %d retained references, dumping the heap", retainedKeys.size)
+    HeapDumpMemoryStore.heapDumpUptimeMillis = SystemClock.uptimeMillis()
+    dismissNotification()
+    val heapDumpFile = heapDumper.dumpHeap() // AndroidHeapDumper
+    if (heapDumpFile == null) {
+      CanaryLog.d("Failed to dump heap, will retry in %d ms", WAIT_AFTER_DUMP_FAILED_MILLIS)
+      scheduleRetainedInstanceCheck("failed to dump heap", WAIT_AFTER_DUMP_FAILED_MILLIS)
+      showRetainedCountWithHeapDumpFailed(retainedKeys.size)
+      return
+    }
 
-### How many methods does LeakCanary add?
+    refWatcher.removeRetainedKeys(retainedKeys) // ç§»é™¤å·²ç» heap dump çš„ retainedKeys
 
-**0**. LeakCanary is a debug only library.
+    HeapAnalyzerService.runAnalysis(application, heapDumpFile) // åˆ†æ heap dump æ–‡ä»¶
+  }
+```
 
-### How do I use the SNAPSHOT version?
+é¦–å…ˆè°ƒç”¨ `checkRetainedCount()` å‡½æ•°åˆ¤æ–­å½“å‰æ³„éœ²å®ä¾‹ä¸ªæ•°å¦‚æœå°äº 5 ä¸ªï¼Œä»…ä»…åªæ˜¯ç»™ç”¨æˆ·ä¸€ä¸ªé€šçŸ¥ï¼Œä¸ä¼šè¿›è¡Œ heap dump æ“ä½œï¼Œå¹¶åœ¨ 5s åå†æ¬¡å‘èµ·æ£€æµ‹ã€‚è¿™æ˜¯å’Œè€ç‰ˆæœ¬ä¸€ä¸ªä¸åŒçš„åœ°æ–¹ã€‚
 
-Update your dependencies to the latest SNAPSHOT (see [build.gradle](https://github.com/square/leakcanary/blob/master/build.gradle)):
+```kotlin
+  private fun checkRetainedCount(
+    retainedKeys: Set<String>,
+    retainedVisibleThreshold: Int // é»˜è®¤ä¸º 5 ä¸ª
+  ): Boolean {
+    if (retainedKeys.isEmpty()) {
+      CanaryLog.d("No retained instances")
+      dismissNotification()
+      return true
+    }
 
-```gradle
- dependencies {
-   debugCompile 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-3-SNAPSHOT'
- }
+    if (retainedKeys.size < retainedVisibleThreshold) {
+      if (applicationVisible || applicationInvisibleLessThanWatchPeriod) {
+        CanaryLog.d(
+            "Found %d retained instances, which is less than the visible threshold of %d",
+            retainedKeys.size,
+            retainedVisibleThreshold
+        )
+        // é€šçŸ¥ç”¨æˆ· "App visible, waiting until 5 retained instances"
+        showRetainedCountBelowThresholdNotification(retainedKeys.size, retainedVisibleThreshold)
+        scheduleRetainedInstanceCheck( // 5s åå†æ¬¡å‘èµ·æ£€æµ‹
+            "Showing retained instance notification", WAIT_FOR_INSTANCE_THRESHOLD_MILLIS
+        )
+        return true
+      }
+    }
+    return false
+  }
 ```
 
-Add Sonatype's `snapshots` repository:
+å½“é›†é½ 5 ä¸ªæ³„éœ²å®ä¾‹ä¹‹åï¼Œä¹Ÿå¹¶ä¸ä¼šç«‹é©¬è¿›è¡Œ heap dumpã€‚è€Œæ˜¯å…ˆæ‰‹åŠ¨è°ƒç”¨ä¸€æ¬¡ GCã€‚å½“ç„¶ä¸æ˜¯ä½¿ç”¨ `System.gc()`ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
 
-```
-  repositories {
-    mavenCentral()
-    maven {
-      url 'https://oss.sonatype.org/content/repositories/snapshots/'
+```kotlin
+  object Default : GcTrigger {
+    override fun runGc() {
+      // Code taken from AOSP FinalizationTest:
+      // https://android.googlesource.com/platform/libcore/+/master/support/src/test/java/libcore/
+      // java/lang/ref/FinalizationTester.java
+      // System.gc() does not garbage collect every time. Runtime.gc() is
+      // more likely to perform a gc.
+      Runtime.getRuntime()
+          .gc()
+      enqueueReferences()
+      System.runFinalization()
     }
-  }
 ```
 
-Status of the snapshot build: [![Build Status](https://travis-ci.org/square/leakcanary.svg?branch=master)](https://travis-ci.org/square/leakcanary)
+é‚£ä¹ˆï¼Œä¸ºä»€ä¹ˆè¦è¿›è¡Œè¿™æ¬¡ GC å‘¢ï¼Ÿå¯èƒ½å­˜åœ¨è¢«è§‚å¯Ÿçš„å¼•ç”¨å°†è¦å˜å¾—å¼±å¯è¾¾ï¼Œä½†æ˜¯è¿˜æœªå…¥é˜Ÿå¼•ç”¨é˜Ÿåˆ—çš„æƒ…å†µã€‚è¿™æ—¶å€™åº”è¯¥ä¸»åŠ¨è°ƒç”¨ä¸€æ¬¡ GCï¼Œå¯èƒ½å¯ä»¥é¿å…ä¸€æ¬¡é¢å¤–çš„ heap dump ã€‚GC ä¹‹åå†æ¬¡è°ƒç”¨ `checkRetainedCount()` åˆ¤æ–­æ³„éœ²å®ä¾‹ä¸ªæ•°ã€‚å¦‚æœæ­¤æ—¶ä»ç„¶æ»¡è¶³æ¡ä»¶ï¼Œå°±è¦å‘èµ· heap dump æ“ä½œäº†ã€‚å…·ä½“é€»è¾‘åœ¨ `AndroidHeapDumper.dumpHeap()` æ–¹æ³•ä¸­ï¼Œæ ¸å¿ƒæ–¹æ³•å°±æ˜¯ä¸‹é¢è¿™å¥ä»£ç ï¼š
 
-### Who's behind LeakCanary?
+```kotlin
+Debug.dumpHprofData(heapDumpFile.absolutePath)
+```
 
-LeakCanary was created and open sourced by [@pyricau](https://github.com/pyricau), with [many contributions](https://github.com/square/leakcanary/graphs/contributors) from the community.
+ç”Ÿæˆ heap dump æ–‡ä»¶ä¹‹åï¼Œè¦åˆ é™¤å·²ç»å¤„ç†è¿‡çš„å¼•ç”¨ï¼Œ
 
-### Why is it called LeakCanary?
+```
+refWatcher.removeRetainedKeys(retainedKeys)
+```
 
-The name **LeakCanary** is a reference to the expression [canary in a coal mine](http://en.wiktionary.org/wiki/canary_in_a_coal_mine), because LeakCanary is a sentinel used to detect risks by providing advance warning of a danger. Props to [@edenman](https://github.com/edenman) for suggesting it!
+æœ€åå¯åŠ¨ä¸€ä¸ªå‰å°æœåŠ¡ `HeapAnalyzerService` æ¥åˆ†æ heap dump æ–‡ä»¶ã€‚è€ç‰ˆæœ¬ä¸­æ˜¯ä½¿ç”¨ Square è‡ªå·±çš„ haha åº“æ¥è§£æçš„ï¼Œè¿™ä¸ªåº“å·²ç»åºŸå¼ƒäº†ï¼ŒSquare å®Œå…¨é‡å†™äº†è§£æåº“ï¼Œä¸»è¦é€»è¾‘éƒ½åœ¨ moudle `leakcanary-analyzer` ä¸­ã€‚è¿™éƒ¨åˆ†æˆ‘è¿˜æ²¡æœ‰é˜…è¯»ï¼Œå°±ä¸åœ¨è¿™é‡Œåˆ†æäº†ã€‚å¯¹äºæ–°çš„è§£æå™¨ï¼Œå®˜ç½‘æ˜¯è¿™æ ·ä»‹ç»çš„ï¼š
 
-### Who made the logo?
+> Uses 90% less memory and 6 times faster than the prior heap parser.
 
-* [@pyricau](https://github.com/pyricau) quickly made the [first version](https://github.com/square/leakcanary/blob/f0cc04dfbf3cca92a669f0d250034d410eb05816/assets/icon_512.png) of the logo. It was based on cliparts from [Android Asset Studio](http://romannurik.github.io/AndroidAssetStudio/icons-generic.html), mixed with the selection from a photo of a Canary. The exclamation mark means danger, the shield stands for protection, and the bird, well, is a canary.
-* [@romainguy](https://github.com/romainguy) turned the ugly logo into [a nice vector asset](https://github.com/square/leakcanary/pull/36).
-* [@flickator](https://github.com/flickator) designed [a much nicer logo](https://github.com/square/leakcanary/pull/1269) for LeakCanary 2.0!
+å‡å°‘äº† 90% çš„å†…å­˜å ç”¨ï¼Œè€Œä¸”æ¯”åŸæ¥å¿«äº† 6 å€ã€‚åé¢æœ‰æ—¶é—´å•ç‹¬æ¥åˆ†æä¸€ä¸‹è¿™ä¸ªè§£æåº“ã€‚
 
-<p align="center">
-<img src="https://github.com/square/leakcanary/wiki/assets/logo-2.0.png" />
-</p>
+åé¢çš„è¿‡ç¨‹å°±ä¸å†èµ˜è¿°äº†ï¼Œé€šè¿‡è§£æåº“æ‰¾åˆ°æœ€çŸ­ GC Roots å¼•ç”¨è·¯å¾„ï¼Œç„¶åå±•ç¤ºç»™ç”¨æˆ·ã€‚
 
-## License
+## æ€»ç»“
 
-    Copyright 2015 Square, Inc.
+é€šè¯»å®Œæºç ï¼ŒLeakCanary 2 è¿˜æ˜¯å¸¦æ¥äº†å¾ˆå¤šçš„ä¼˜åŒ–ã€‚ä¸è€ç‰ˆæœ¬ç›¸æ¯”ï¼Œä¸»è¦æœ‰ä»¥ä¸‹ä¸åŒï¼š
 
-    Licensed under the Apache License, Version 2.0 (the "License");
-    you may not use this file except in compliance with the License.
-    You may obtain a copy of the License at
+* ç™¾åˆ†ä¹‹ç™¾ä½¿ç”¨ Kotlin é‡å†™
+* è‡ªåŠ¨åˆå§‹åŒ–ï¼Œæ— éœ€ç”¨æˆ·æ‰‹åŠ¨å†æ·»åŠ åˆå§‹åŒ–ä»£ç 
+* æ”¯æŒ fragmentï¼Œæ”¯æŒ androidx
+* å½“æ³„éœ²å¼•ç”¨åˆ°è¾¾ 5 ä¸ªæ—¶æ‰ä¼šå‘èµ· heap dump
+* å…¨æ–°çš„ heap parserï¼Œå‡å°‘ 90% å†…å­˜å ç”¨ï¼Œæå‡ 6 å€é€Ÿåº¦
 
-       http://www.apache.org/licenses/LICENSE-2.0
 
-    Unless required by applicable law or agreed to in writing, software
-    distributed under the License is distributed on an "AS IS" BASIS,
-    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-    See the License for the specific language governing permissions and
-    limitations under the License.
diff --git a/README_origin.md b/README_origin.md
new file mode 100644
index 00000000..67d8cced
--- /dev/null
+++ b/README_origin.md
@@ -0,0 +1,375 @@
+# ğŸ¤ LeakCanary
+
+A memory leak detection library for Android.
+
+*â€œA small leak will sink a great ship.â€* - Benjamin Franklin
+
+<p align="center">
+<img src="https://github.com/square/leakcanary/wiki/assets/screenshot-2.0.png"/>
+</p>
+
+## Getting started
+
+Add LeakCanary to `build.gradle`:
+
+```gradle
+dependencies {
+  // debugImplementation because LeakCanary should only run in debug builds.
+  debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-2'
+}
+```
+
+**That's it, there is no code change needed!** LeakCanary will automatically show a notification when a memory leak is detected in debug builds.
+
+What's next?
+* Learn the [Fundamentals](#fundamentals)
+* Try the [code recipes](#code-recipes)
+* Read the [FAQ](#faq)
+* Watch [recorded presentations](https://github.com/square/leakcanary/wiki/Recorded-Presentations)
+* Read [blog articles](https://github.com/square/leakcanary/wiki/Blog-Articles)
+
+Note: **LeakCanary 2 is in alpha**.
+* Check out the [migration guide](https://github.com/square/leakcanary/wiki/Migrating-to-LeakCanary-2.0).
+* Here is the [change log](https://github.com/square/leakcanary/blob/master/CHANGELOG.md#version-20-alpha-2-2019-05-21).
+* To set up LeakCanary 1.6, go to the [1.6 Readme](https://github.com/square/leakcanary/blob/master/README-1.6.md).
+
+## Fundamentals
+
+### What is a memory leak?
+
+In a Java based runtime, a memory leak is a programming error that causes an application to keep a reference to an object that is no longer needed. As a result, the memory allocated for that object cannot be reclaimed, eventually leading to an OutOfMemoryError crash.
+
+For example, an Android activity instance is no longer needed after its `onDestroy()` method is called, and storing a reference to that activity in a static field would prevent it from being garbage collected.
+
+### Why should I use LeakCanary?
+
+Memory leaks are very common in Android apps. OutOfMemoryError (OOM) is the top crash for most apps on the play store, however that's usually not counted correctly. When memory is low the OOM can be thrown from anywhere in your code, which means every OOM has a different stacktrace and they're counted as different crashes.
+
+When we first enabled LeakCanary in the Square Point Of Sale app, we were able to find and fix several leaks and reduced the OutOfMemoryError crash rate by **94%**.
+
+### How does LeakCanary work?
+
+* The library automatically watches destroyed activities and destroyed fragments using weak references. You can also watch any instance that is no longer needed, e.g. a detached view.
+* If the weak references aren't cleared, after waiting 5 seconds and running the GC, the watched instances are considered *retained*, and potentially leaking.
+* When the number of retained instances reaches a threshold, LeakCanary dumps the Java heap into a `.hprof` file stored on the file system. The default threshold is 5 retained instances when the app is visible, 1 otherwise.
+* LeakCanary parses the `.hprof` file and finds the chain of references that prevents retained instances from being garbage collected (**leak trace**). A leak trace is technically the *shortest strong reference path from GC Roots to retained instances*, but that's a mouthful.
+* Once the leak trace is determined, LeakCanary uses its built in knowledge of the Android framework to deduct which instances in the leak trace are leaking. You can help LeakCanary by providing **Reachability inspectors** tailored to your own app.
+* Using the reachability information, LeakCanary narrows down the reference chain to a sub chain of possible leak causes, and displays the result. Leaks are grouped by identical sub chain.
+
+### How do I fix a memory leak?
+To fix a memory leak, you need to look at the sub chain of possible leak causes and find which reference is causing the leak, i.e. which reference should have been cleared at the time of the leak. LeakCanary highlights with a red underline wave the references that are the possible causes of the leak.
+
+If you cannot figure out a leak, **please do not file an issue**. Instead, create a [Stack Overflow question](http://stackoverflow.com/questions/tagged/leakcanary) using the *leakcanary* tag.
+
+### LeakCanary artifacts
+
+LeakCanary is released as several distinct libraries:
+
+* LeakSentry
+  * Detects retained instances.
+  * Suitable for release builds.
+  * Artifact id: `com.squareup.leakcanary:leaksentry`.
+* LeakCanary
+  * Dumps the heap and analyzes it.
+  * Currently only suitable for debug builds.
+  * Depends on LeakSentry.
+  * Artifact id: `com.squareup.leakcanary:leakcanary-android`.
+* LeakCanary for Instrumentation tests
+  * Fails tests if a leak is detected
+  * Only suitable for Instrumentation tests
+  * Configures LeakCanary to wait for the end of tests before dumping the heap.
+  * Artifact id: `com.squareup.leakcanary:leakcanary-android-instrumentation`.
+  * See [Running LeakCanary in instrumentation tests](#running-leakcanary-in-instrumentation-tests)
+
+## Code Recipes
+
+If you think a recipe might be missing or you're not sure that what you're trying to achieve is possible with the current APIs, please [file an issue](https://github.com/square/leakcanary/issues/new/choose). Your feedback help us make LeakCanary better for the entire community.
+
+### Configuring LeakSentry
+
+LeakSentry can be configured by replacing `LeakSentry.config`:
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    LeakSentry.config = LeakSentry.config.copy(watchFragmentViews = false)
+  }
+}
+```
+
+### Configuring LeakCanary
+
+LeakCanary can be configured by replacing `LeakCanary.config`:
+
+```kotlin
+disableLeakCanaryButton.setOnClickListener {
+  LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
+}
+```
+
+### Watching objects with a lifecycle
+
+In your application, you may have other objects with a lifecycle, such as fragments, services, Dagger components, etc. Use `LeakSentry.refWatcher` to watch instances that should be garbage collected:
+
+```kotlin
+class MyService : Service {
+
+  // ...
+
+  override fun onDestroy() {
+    super.onDestroy()
+    LeakSentry.refWatcher.watch(this)
+  }
+}
+```
+
+### Counting retained instances in production
+
+`com.squareup.leakcanary:leakcanary-android` should only be used in debug builds. It depends on `com.squareup.leakcanary:leaksentry` which you can use in production to track and count retained instances.
+
+In your `build.gradle`:
+
+```gradle
+dependencies {
+  implementation 'com.squareup.leakcanary:leaksentry:2.0-alpha-2'
+}
+```
+
+In your leak reporting code:
+```kotlin
+val retainedInstanceCount = LeakSentry.refWatcher.retainedKeys.size
+```
+
+### Running LeakCanary in instrumentation tests
+
+Add the `leakcanary-android-instrumentation` dependency to your instrumentation tests:
+
+```
+androidTestImplementation "com.squareup.leakcanary:leakcanary-android-instrumentation:${leakCanaryVersion}"
+```
+
+Add the dedicated run listener to `defaultConfig` in your `build.gradle`:
+
+```
+android {
+  defaultConfig {
+    // ...
+
+    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
+    testInstrumentationRunnerArgument "listener", "leakcanary.FailTestOnLeakRunListener"
+  }
+}
+```
+
+Run the instrumentation tests:
+
+```
+./gradlew leakcanary-sample:connectedCheck
+```
+
+You can extend `FailTestOnLeakRunListener` to customize the behavior.
+
+### Icon and label
+
+The activity that displays leaks comes with a default icon and label, which you can change by providing `R.mipmap.leak_canary_icon` and `R.string.leak_canary_display_activity_label` in your app:
+
+```
+res/
+  mipmap-hdpi/
+    leak_canary_icon.png
+  mipmap-mdpi/
+    leak_canary_icon.png
+  mipmap-xhdpi/
+    leak_canary_icon.png
+  mipmap-xxhdpi/
+    leak_canary_icon.png
+  mipmap-xxxhdpi/
+    leak_canary_icon.png
+   mipmap-anydpi-v26/
+     leak_canary_icon.xml
+```
+
+```xml
+<?xml version="1.0" encoding="utf-8"?>
+<resources>
+  <string name="leak_canary_display_activity_label">MyLeaks</string>
+</resources>
+```
+
+### Uploading to a server
+
+You can change the default behavior to upload the analysis result to a server of your choosing.
+
+Create a custom `AnalysisResultListener` that delegates to the default: 
+
+```kotlin
+class LeakUploader : AnalysisResultListener {
+  override fun invoke(
+    application: Application,
+    heapAnalysis: HeapAnalysis
+  ) {
+    TODO("Upload heap analysis to server")
+
+    // Delegate to default behavior (notification and saving result)
+    DefaultAnalysisResultListener(application, heapAnalysis)
+  }
+}
+```
+
+Set `analysisResultListener` on the LeakCanary config:
+
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    LeakCanary.config = LeakCanary.config.copy(analysisResultListener = LeakUploader())
+  }
+}
+```
+
+
+### Identifying 3rd party leaks as "won't fix"
+
+Set `exclusionsFactory` on the LeakCanary config to a `ExclusionsFactory` that delegates to the default one and then and add custom exclusions:
+
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    LeakCanary.config = LeakCanary.config.copy(exclusionsFactory = { hprofParser ->
+      val defaultFactory = AndroidExcludedRefs.exclusionsFactory(AndroidExcludedRefs.appDefaults)
+      val appDefaults = defaultFactory(hprofParser)
+      val customExclusion = Exclusion(
+          type = StaticFieldExclusion("com.thirdparty.SomeSingleton", "sContext"),
+          status = Exclusion.Status.WONT_FIX_LEAK,
+          reason = "SomeSingleton in library X has a static field leaking a context."
+      )
+      appDefaults + customExclusion
+    })
+  }
+}
+```
+
+### Identifying leaking instances and labeling instances
+
+```kotlin
+class DebugExampleApplication : ExampleApplication() {
+
+  override fun onCreate() {
+    super.onCreate()
+    val customLabeler: Labeler = { parser, node ->
+      listOf("Heap dump object id is ${node.instance}")
+    }
+    val labelers = AndroidLabelers.defaultAndroidLabelers(this) + customLabeler
+
+    val customInspector: LeakInspector = { parser, node ->
+      with(parser) {
+        if (node.instance.objectRecord.isInstanceOf("com.example.MySingleton")) {
+          LeakNodeStatus.notLeaking("MySingleton is a singleton")
+        } else LeakNodeStatus.unknown()
+      }
+    }
+    val leakInspectors = AndroidLeakInspectors.defaultAndroidInspectors() + customInspector
+
+    LeakCanary.config = LeakCanary.config.copy(labelers = labelers, leakInspectors = leakInspectors)
+  }
+}
+```
+
+## FAQ
+
+### Can a leak be caused by the Android SDK?
+
+Yes. There are a number of known memory leaks that have been fixed over time in AOSP as well as in manufacturer implementations. When such a leak occurs, there is little you can do as an app developer to fix it. For that reason, LeakCanary has a built-in list of known Android leaks to ignore: [AndroidExcludedRefs.kt](https://github.com/square/leakcanary/blob/master/leakcanary-android-core/src/main/java/leakcanary/AndroidExcludedRefs.kt).
+
+If you find a new one, please [create an issue](https://github.com/square/leakcanary/issues/new/choose) and follow these steps:
+
+1. Provide the entire leak trace information (reference key, device, etc), and use backticks (`) for formatting.
+2. Read the AOSP source for that version of Android, and try to figure out why it happens. You can easily navigate through SDK versions [android/platform_frameworks_base](https://github.com/android/platform_frameworks_base).
+3. Check if it happens on the latest version of Android, and otherwise use blame to find when it was fixed.
+4. If it's still happening, build a simple repro case
+5. File an issue on [b.android.com](http://b.android.com) with the leak trace and the repro case
+6. Create a PR in LeakCanary to update `AndroidExcludedRefs.kt`. Optional: if you find a hack to clear that leak on previous versions of Android, feel free to document it.
+
+### How do I share a leak trace?
+
+* Go to the leak screen, click the overflow menu and select *Share Info*.
+* You can also find the leak trace in Logcat.
+
+### How can I dig beyond the leak trace?
+
+Sometimes the leak trace isn't enough and you need to dig into a heap dump with [MAT](http://eclipse.org/mat/) or [YourKit](https://www.yourkit.com/).
+
+* Go to a heap analysis screen, click the overflow menu and select *Share Heap Dump*.
+
+Here's how you can find the leaking instance in the heap dump:
+
+1. Look for all instances of `leakcanary.KeyedWeakReference`
+2. For each of these, look at the `key` field.
+3. Find the `KeyedWeakReference` that has a `key` field equal to the reference key reported by LeakCanary.
+4. The `referent` field of that `KeyedWeakReference` is your leaking object.
+5. From then on, the matter is in your hands. A good start is to look at the shortest path to GC Roots (excluding weak references).
+
+### How many methods does LeakCanary add?
+
+**0**. LeakCanary is a debug only library.
+
+### How do I use the SNAPSHOT version?
+
+Update your dependencies to the latest SNAPSHOT (see [build.gradle](https://github.com/square/leakcanary/blob/master/build.gradle)):
+
+```gradle
+ dependencies {
+   debugCompile 'com.squareup.leakcanary:leakcanary-android:2.0-alpha-3-SNAPSHOT'
+ }
+```
+
+Add Sonatype's `snapshots` repository:
+
+```
+  repositories {
+    mavenCentral()
+    maven {
+      url 'https://oss.sonatype.org/content/repositories/snapshots/'
+    }
+  }
+```
+
+Status of the snapshot build: [![Build Status](https://travis-ci.org/square/leakcanary.svg?branch=master)](https://travis-ci.org/square/leakcanary)
+
+### Who's behind LeakCanary?
+
+LeakCanary was created and open sourced by [@pyricau](https://github.com/pyricau), with [many contributions](https://github.com/square/leakcanary/graphs/contributors) from the community.
+
+### Why is it called LeakCanary?
+
+The name **LeakCanary** is a reference to the expression [canary in a coal mine](http://en.wiktionary.org/wiki/canary_in_a_coal_mine), because LeakCanary is a sentinel used to detect risks by providing advance warning of a danger. Props to [@edenman](https://github.com/edenman) for suggesting it!
+
+### Who made the logo?
+
+* [@pyricau](https://github.com/pyricau) quickly made the [first version](https://github.com/square/leakcanary/blob/f0cc04dfbf3cca92a669f0d250034d410eb05816/assets/icon_512.png) of the logo. It was based on cliparts from [Android Asset Studio](http://romannurik.github.io/AndroidAssetStudio/icons-generic.html), mixed with the selection from a photo of a Canary. The exclamation mark means danger, the shield stands for protection, and the bird, well, is a canary.
+* [@romainguy](https://github.com/romainguy) turned the ugly logo into [a nice vector asset](https://github.com/square/leakcanary/pull/36).
+* [@flickator](https://github.com/flickator) designed [a much nicer logo](https://github.com/square/leakcanary/pull/1269) for LeakCanary 2.0!
+
+<p align="center">
+<img src="https://github.com/square/leakcanary/wiki/assets/logo-2.0.png" />
+</p>
+
+## License
+
+    Copyright 2015 Square, Inc.
+
+    Licensed under the Apache License, Version 2.0 (the "License");
+    you may not use this file except in compliance with the License.
+    You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+    Unless required by applicable law or agreed to in writing, software
+    distributed under the License is distributed on an "AS IS" BASIS,
+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+    See the License for the specific language governing permissions and
+    limitations under the License.
