diff --git a/docs/fundamentals.md b/docs/fundamentals.md
index 8c76ccba..952c7db2 100644
--- a/docs/fundamentals.md
+++ b/docs/fundamentals.md
@@ -24,7 +24,7 @@ When we first enabled LeakCanary in the Square Point Of Sale app, we were able t
 
 ### Detecting retained instances
 
-The foundation of LeakCanary is a library called LeakSentry. LeakSentry hooks into the Android lifecycle to automatically detect when activities and fragments are destroyed and should be garbage collected. These destroyed instances are passed to a `RefWatcher`, which holds weak references to them. You can also watch any instance that is no longer needed, e.g. a detached view, a destroyed presenter, etc.
+The foundation of LeakCanary is a library called Object Watcher Android. It hooks into the Android lifecycle to automatically detect when activities and fragments are destroyed and should be garbage collected. These destroyed instances are passed to an `ObjectWatcher`, which holds weak references to them. You can also watch any instance that is no longer needed, e.g. a detached view, a destroyed presenter, etc.
 
 If the weak references aren't cleared after waiting 5 seconds and running the garbage collector, the watched instances are considered *retained*, and potentially leaking.
 
@@ -206,16 +206,23 @@ If you cannot figure out a leak, **please do not file an issue**. Instead, creat
 
 ## LeakCanary artifacts
 
-LeakCanary is released as several distinct libraries:
+LeakCanary is released as several libraries:
 
-* LeakSentry
-    * Detects retained instances.
+* Shark
+    * The heap analyzer that powers LeakCanary.
+    * See [Shark](shark.md) for details.
+* ObjectWatcher
+    * Used to watch retained objects and check if they become weakly reachable.
     * Suitable for release builds.
-    * Artifact id: `com.squareup.leakcanary:leaksentry`.
+    * Artifact id: `com.squareup.leakcanary:object-watcher`.
+* ObjectWatcher Android
+    * Automatically detects retained destroyed activities and fragments.
+    * Suitable for release builds.
+    * Artifact id: `com.squareup.leakcanary:object-watcher-android`.
 * LeakCanary
     * Dumps the heap and analyzes it.
     * Currently only suitable for debug builds.
-    * Depends on LeakSentry.
+    * Depends on ObjectWatcher Android.
     * Artifact id: `com.squareup.leakcanary:leakcanary-android`.
 * LeakCanary for Instrumentation tests
     * Fails tests if a leak is detected.
@@ -223,3 +230,6 @@ LeakCanary is released as several distinct libraries:
     * Configures LeakCanary to wait for the end of tests before dumping the heap.
     * Artifact id: `com.squareup.leakcanary:leakcanary-android-instrumentation`.
     * See [Running LeakCanary in instrumentation tests](recipes.md#running-leakcanary-in-instrumentation-tests).
+* LeakCanary Android separate process
+	* Enables running LeakCanary separately from the main app process.
+	* Artifact id: `com.squareup.leakcanary:leakcanary-android-process` (as a replacement for `com.squareup.leakcanary:leakcanary-android`).
diff --git a/docs/recipes.md b/docs/recipes.md
index 2c31ea67..36123a1d 100644
--- a/docs/recipes.md
+++ b/docs/recipes.md
@@ -2,15 +2,15 @@
 
 If you think a recipe might be missing or you're not sure that what you're trying to achieve is possible with the current APIs, please [file an issue](https://github.com/square/leakcanary/issues/new/choose). Your feedback help us make LeakCanary better for the entire community.
 
-## Configuring LeakSentry
+## Configuring ObjectWatcher Android
 
-LeakSentry can be configured by replacing `LeakSentry.config`:
+ObjectWatcher Android can be configured by replacing `AppWatcher.config`:
 ```kotlin
 class DebugExampleApplication : ExampleApplication() {
 
   override fun onCreate() {
     super.onCreate()
-    LeakSentry.config = LeakSentry.config.copy(watchFragmentViews = false)
+    AppWatcher.config = AppWatcher.config.copy(watchFragmentViews = false)
   }
 }
 ```
@@ -27,7 +27,7 @@ disableLeakCanaryButton.setOnClickListener {
 
 ## Watching objects with a lifecycle
 
-In your application, you may have other objects with a lifecycle, such as fragments, services, Dagger components, etc. Use `LeakSentry.refWatcher` to watch instances that should be garbage collected:
+In your application, you may have other objects with a lifecycle, such as fragments, services, Dagger components, etc. Use `AppWatcher.objectWatcher` to watch instances that should be garbage collected:
 
 ```kotlin
 class MyService : Service {
@@ -36,26 +36,26 @@ class MyService : Service {
 
   override fun onDestroy() {
     super.onDestroy()
-    LeakSentry.refWatcher.watch(this)
+    AppWatcher.objectWatcher.watch(this)
   }
 }
 ```
 
 ## Counting retained instances in production
 
-`com.squareup.leakcanary:leakcanary-android` should only be used in debug builds. It depends on `com.squareup.leakcanary:leaksentry` which you can use in production to track and count retained instances.
+`com.squareup.leakcanary:leakcanary-android` should only be used in debug builds. It depends on `com.squareup.leakcanary:object-watcher-android` which you can use in production to track and count retained instances.
 
 In your `build.gradle`:
 
 ```gradle
 dependencies {
-  implementation 'com.squareup.leakcanary:leaksentry:2.0-alpha-2'
+  implementation 'com.squareup.leakcanary:object-watcher-android:2.0-alpha-2'
 }
 ```
 
 In your leak reporting code:
 ```kotlin
-val retainedInstanceCount = LeakSentry.refWatcher.retainedKeys.size
+val retainedInstanceCount = AppWatcher.objectWatcher.retainedKeys.size
 ```
 
 ## Running LeakCanary in instrumentation tests
diff --git a/docs/shark.md b/docs/shark.md
new file mode 100644
index 00000000..05100c72
--- /dev/null
+++ b/docs/shark.md
@@ -0,0 +1,83 @@
+# Shark ðŸ¦ˆ
+
+<!-- Made with http://patorjk.com/text-color-fader/ -->
+**Shark**: **<span style="color:#c757bc;">S</span><span style="color:#c858b7;">m</span><span style="color:#ca5ab2;">a</span><span style="color:#cb5bad;">r</span><span style="color:#cc5ca9;">t</span><span style="color:#ce5ea4;"> </span><span style="color:#cf5f9f;">H</span><span style="color:#d0609a;">e</span><span style="color:#d26295;">a</span><span style="color:#d36390;">p</span><span style="color:#d4658c;"> </span><span style="color:#d66687;">A</span><span style="color:#d76782;">n</span><span style="color:#d8697d;">a</span><span style="color:#da6a78;">l</span><span style="color:#db6b73;">y</span><span style="color:#dc6d6f;">s</span><span style="color:#de6e6a;">i</span><span style="color:#df6f65;">s</span><span style="color:#e07160;"> </span><span style="color:#e1725b;">R</span><span style="color:#e37356;">e</span><span style="color:#e47552;">p</span><span style="color:#e5764d;">o</span><span style="color:#e77748;">r</span><span style="color:#e87943;">t</span><span style="color:#e97a3e;">s</span><span style="color:#eb7b39;"> </span><span style="color:#ec7d35;">f</span><span style="color:#ed7e30;">o</span><span style="color:#ef802b;">r</span><span style="color:#f08126;"> </span><span style="color:#f18221;">K</span><span style="color:#f3841c;">o</span><span style="color:#f48518;">t</span><span style="color:#f58613;">l</span><span style="color:#f7880e;">i</span><span style="color:#f88909;">n</span>**
+
+<p align="center">
+<img src="https://github.com/square/leakcanary/wiki/assets/shark.png" />
+</p>
+
+Shark is the heap analyzer that powers LeakCanary. It's a standalone heap analyzer Kotlin library that can run in Java and Android VMs at **high speed** with a **low memory footprint**. It can analyze both Android and Java VM hprof files.
+
+Shark is released as several distinct libraries:
+
+* `Shark Hprof`: Read and write records in hprof files
+* `Shark Graph`: Navigate the heap object graph
+* `Shark`: Generate heap analysis reports
+* `Shark Android`: Generate Android tailored heap analysis reports
+
+Shark is also released as a CLI tool, `Shark CLI`.
+
+## Example usage
+
+### Reading records in a hprof file with shark-hprof
+
+```kotlin
+// Prints all class and field names
+Hprof.open(heapDumpFile)
+    .use { hprof ->
+      hprof.reader.readHprofRecords(
+          recordTypes = setOf(StringRecord::class),
+          listener = OnHprofRecordListener { position, record ->
+            println((record as StringRecord).string)
+          })
+    }
+```
+
+### Navigating the heap object graph with shark-graph
+
+```kotlin
+// Prints all thread names
+Hprof.open(heapDumpFile)
+    .use { hprof ->
+      val heapGraph = HeapGraph.indexHprof(hprof)
+      val threadClass = heapGraph.findClassByName("java.lang.Thread")!!
+      val threadNames: Sequence<String> = threadClass.instances.map { instance ->
+        val nameField = instance["java.lang.Thread", "name"]!!
+        nameField.value.readAsJavaString()!!
+      }
+      threadNames.forEach { println(it) }
+    }
+```
+
+### Generating a heap analysis report with shark
+
+```kotlin
+val heapAnalyzer = HeapAnalyzer(AnalyzerProgressListener.NONE)
+val analysis = heapAnalyzer.checkForLeaks(
+    heapDumpFile = heapDumpFile,
+    leakFinders = listOf(ObjectInspector { _, reporter ->
+      reporter.whenInstanceOf("com.example.ThingWithLifecycle") { instance ->
+        val field = instance["com.example.ThingWithLifecycle", "destroyed"]!!
+        val destroyed = field.value.asBoolean!!
+        if (destroyed) {
+          reportLeaking(reason = "ThingWithLifecycle.destroyed = true")
+        }
+      }
+    })
+)
+println(analysis)
+```
+
+### Generating an Android heap analysis report with shark-android
+
+
+```kotlin
+val heapAnalyzer = HeapAnalyzer(AnalyzerProgressListener.NONE)
+val analysis = heapAnalyzer.checkForLeaks(
+    heapDumpFile = heapDumpFile,
+    referenceMatchers = AndroidReferenceMatchers.appDefaults,
+    objectInspectors = AndroidObjectInspectors.appDefaults
+)
+println(analysis)
+```
diff --git a/leakcanary-analyzer/gradle.properties b/leakcanary-analyzer/gradle.properties
deleted file mode 100644
index ed79fc10..00000000
--- a/leakcanary-analyzer/gradle.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-POM_ARTIFACT_ID=leakcanary-analyzer
-POM_NAME=LeakCanary Analyzer
-POM_PACKAGING=jar
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AnalyzerProgressListener.kt b/leakcanary-analyzer/src/main/java/leakcanary/AnalyzerProgressListener.kt
deleted file mode 100644
index 709ad51e..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/AnalyzerProgressListener.kt
+++ /dev/null
@@ -1,27 +0,0 @@
-package leakcanary
-
-/**
- * Used to report progress by the [HeapAnalyzer].
- */
-interface AnalyzerProgressListener {
-
-  // These steps are defined in the order in which they occur.
-  enum class Step {
-    PARSING_HEAP_DUMP,
-    FINDING_LEAKING_INSTANCES,
-    FINDING_PATHS_TO_LEAKING_INSTANCES,
-    FINDING_DOMINATORS,
-    COMPUTING_NATIVE_RETAINED_SIZE,
-    COMPUTING_RETAINED_SIZE,
-    BUILDING_LEAK_TRACES,
-  }
-
-  fun onProgressUpdate(step: Step)
-
-  companion object {
-    val NONE = object : AnalyzerProgressListener {
-      override fun onProgressUpdate(step: Step) {
-      }
-    }
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AndroidBuildMirror.kt b/leakcanary-analyzer/src/main/java/leakcanary/AndroidBuildMirror.kt
deleted file mode 100644
index 9fb23b53..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/AndroidBuildMirror.kt
+++ /dev/null
@@ -1,26 +0,0 @@
-package leakcanary
-
-/**
- * Caches values from the android.os.Build class in the heap dump.
- */
-class AndroidBuildMirror(
-  /**
-   * Value of android.os.Build.MANUFACTURER
-   */
-  val manufacturer: String,
-  /**
-   * Value of android.os.Build.VERSION.SDK_INT
-   */
-  val sdkInt: Int
-)
-
-val HprofGraph.androidBuildMirror: AndroidBuildMirror
-  get() {
-    return context.getOrPut(AndroidBuildMirror::class.java.name) {
-      val buildClass = findClassByClassName("android.os.Build")!!
-      val versionClass = findClassByClassName("android.os.Build\$VERSION")!!
-      val manufacturer = buildClass["MANUFACTURER"]!!.value.readAsJavaString()!!
-      val sdkInt = versionClass["SDK_INT"]!!.value.asInt!!
-      AndroidBuildMirror(manufacturer, sdkInt)
-    }
-  }
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AppSingletonInspector.kt b/leakcanary-analyzer/src/main/java/leakcanary/AppSingletonInspector.kt
deleted file mode 100644
index f68b3a55..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/AppSingletonInspector.kt
+++ /dev/null
@@ -1,24 +0,0 @@
-package leakcanary
-
-import leakcanary.GraphObjectRecord.GraphInstanceRecord
-
-/**
- * Inspector that automatically marks instances of the provided class names as not leaking
- * because they're app wide singletons.
- */
-class AppSingletonInspector(private vararg val singletonClasses: String) : ObjectInspector {
-  override fun inspect(
-    graph: HprofGraph,
-    reporter: ObjectReporter
-  ) {
-    if (reporter.objectRecord is GraphInstanceRecord) {
-      reporter.objectRecord.instanceClass
-          .classHierarchy
-          .forEach { classRecord ->
-            if (classRecord.name in singletonClasses) {
-              reporter.reportNotLeaking("${classRecord.name} is an app singleton")
-            }
-          }
-    }
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt b/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt
deleted file mode 100644
index f9f25588..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysis.kt
+++ /dev/null
@@ -1,87 +0,0 @@
-package leakcanary
-
-import leakcanary.Leak.ApplicationLeak
-import leakcanary.Leak.LibraryLeak
-import leakcanary.ReferenceMatcher.LibraryLeakReferenceMatcher
-import leakcanary.internal.createSHA1Hash
-import java.io.File
-import java.io.Serializable
-
-sealed class HeapAnalysis : Serializable {
-  abstract val heapDumpFile: File
-  abstract val createdAtTimeMillis: Long
-  /** Total time spent analyzing the heap.  */
-  abstract val analysisDurationMillis: Long
-}
-
-data class HeapAnalysisFailure(
-  override val heapDumpFile: File,
-  override val createdAtTimeMillis: Long,
-  override val analysisDurationMillis: Long,
-  val exception: HeapAnalysisException
-) : HeapAnalysis()
-
-data class HeapAnalysisSuccess(
-  override val heapDumpFile: File,
-  override val createdAtTimeMillis: Long,
-  override val analysisDurationMillis: Long,
-  val applicationLeaks: List<ApplicationLeak>,
-  val libraryLeaks: List<LibraryLeak>
-) : HeapAnalysis() {
-  val allLeaks: List<Leak>
-    get() = applicationLeaks + libraryLeaks
-}
-
-sealed class Leak : Serializable {
-  /**
-   * Class name of the leaking instance.
-   * The class name format is the same as what would be returned by [Class.getName].
-   */
-  abstract val className: String
-
-  /**
-   * Shortest path from GC roots to the leaking object.
-   */
-  abstract val leakTrace: LeakTrace
-  /**
-   * The number of bytes which would be freed if all references to the leaking object were
-   * released. Null if the retained heap size was not computed.
-   */
-  abstract val retainedHeapSize: Int?
-
-  val groupHash
-    get() = createGroupHash()
-
-  val classSimpleName: String
-    get() {
-      val separator = className.lastIndexOf('.')
-      return if (separator == -1) className else className.substring(separator + 1)
-    }
-
-  abstract fun createGroupHash(): String
-
-  data class LibraryLeak(
-    override val className: String,
-    override val leakTrace: LeakTrace,
-    override val retainedHeapSize: Int?,
-    val pattern: ReferencePattern,
-    val description: String
-  ) : Leak() {
-    override fun createGroupHash() = pattern.toString().createSHA1Hash()
-  }
-
-  data class ApplicationLeak(
-    override val className: String,
-    override val leakTrace: LeakTrace,
-    override val retainedHeapSize: Int?
-  ) : Leak() {
-    override fun createGroupHash(): String {
-      return leakTrace.leakCauses
-          .joinToString(separator = "") { element ->
-            val referenceName = element.reference!!.groupingName
-            element.className + referenceName
-          }
-          .createSHA1Hash()
-    }
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/ReferenceMatcher.kt b/leakcanary-analyzer/src/main/java/leakcanary/ReferenceMatcher.kt
deleted file mode 100644
index 8233c3c0..00000000
--- a/leakcanary-analyzer/src/main/java/leakcanary/ReferenceMatcher.kt
+++ /dev/null
@@ -1,36 +0,0 @@
-package leakcanary
-
-/**
- * Used to pattern match known patterns of references in the heap, either to ignore them
- * ([IgnoredReferenceMatcher]) or to mark them as library leaks ([LibraryLeakReferenceMatcher]).
- */
-sealed class ReferenceMatcher {
-
-  /** The pattern that references will be matched against. */
-  abstract val pattern: ReferencePattern
-
-  /**
-   * [LibraryLeakReferenceMatcher] should be used to match references in library code that are
-   * known to create leaks and are beyond your control. The shortest path finder will only go
-   * through matching references after it has exhausted references that don't match, prioritizing
-   * finding an application leak over a known library leak. Library leaks will be reported as
-   * [Leak.LibraryLeak] instead of [Leak.ApplicationLeak].
-   */
-  data class LibraryLeakReferenceMatcher(
-    override val pattern: ReferencePattern,
-    val description: String = "",
-    /**
-     * Whether the identified leak may exist in the provided [HprofGraph]. Defaults to true. If
-     * the heap dump comes from a VM that runs a different version of the library that doesn't
-     * have the leak, then this should return false.
-     */
-    val patternApplies: (HprofGraph) -> Boolean = { true }
-  ) : ReferenceMatcher()
-
-  /**
-   * [IgnoredReferenceMatcher] should be used to match references that cannot ever create leaks. The
-   * shortest path finder will never go through matching references.
-   */
-  class IgnoredReferenceMatcher(override val pattern: ReferencePattern) : ReferenceMatcher()
-
-}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/JvmHprofParsingTest.kt b/leakcanary-analyzer/src/test/java/leakcanary/internal/JvmHprofParsingTest.kt
deleted file mode 100644
index 07856ea4..00000000
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/JvmHprofParsingTest.kt
+++ /dev/null
@@ -1,42 +0,0 @@
-package leakcanary.internal
-
-import leakcanary.HprofGraph
-import org.assertj.core.api.Assertions.assertThat
-import org.junit.Rule
-import org.junit.Test
-import org.junit.rules.TemporaryFolder
-import java.io.File
-import kotlin.reflect.KClass
-
-class JvmHprofParsingTest {
-
-  @get:Rule
-  var testFolder = TemporaryFolder()
-
-  @Test fun dumpHeapAndReadString() {
-    val hprofFolder = testFolder.newFolder()
-    val hprofFile = File(hprofFolder, "jvm_heap.hprof")
-
-    JvmTestHeapDumper.dumpHeap(hprofFile.absolutePath)
-
-    val (graph, closeable) = HprofGraph.readHprof(hprofFile)
-
-    closeable.use {
-      val testInstances = graph.instances
-          .filter { it.className == JvmHprofParsingTest::class.name }
-          .toList()
-
-      assertThat(testInstances).hasSize(1)
-      val test = testInstances[0]
-      val folderPath = test[JvmHprofParsingTest::class.name, "testFolder"]!!
-          .valueAsInstance!![TemporaryFolder::class.name, "folder"]!!
-          .valueAsInstance!![File::class.name, "path"]!!
-          .value.readAsJavaString()!!
-
-      assertThat(folderPath).isEqualTo(testFolder.root.path)
-    }
-  }
-}
-
-private val KClass<out Any>.name: String
-  get() = this.java.name
\ No newline at end of file
diff --git a/leakcanary-android-core/build.gradle b/leakcanary-android-core/build.gradle
index a854cfee..4ab7a345 100644
--- a/leakcanary-android-core/build.gradle
+++ b/leakcanary-android-core/build.gradle
@@ -2,9 +2,9 @@ apply plugin: 'com.android.library'
 apply plugin: 'kotlin-android'
 
 dependencies {
-  api project(':leakcanary-analyzer')
-  api project(':leakcanary-leaksentry')
-  api project(':leakcanary-fragments-androidx')
+  api project(':shark-android')
+  api project(':leakcanary-object-watcher-android')
+  api project(':leakcanary-object-watcher-android-androidx')
 
   implementation deps.kotlin.stdlib
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt b/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt
index f0fae9e4..bb7dd5b6 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/DefaultOnHeapAnalyzedListener.kt
@@ -12,6 +12,10 @@ import leakcanary.internal.activity.screen.GroupListScreen
 import leakcanary.internal.activity.screen.HeapAnalysisFailureScreen
 import leakcanary.internal.activity.screen.HeapAnalysisListScreen
 import leakcanary.internal.activity.screen.HeapAnalysisSuccessScreen
+import shark.HeapAnalysis
+import shark.HeapAnalysisFailure
+import shark.HeapAnalysisSuccess
+import shark.SharkLog
 
 /**
  * Default [OnHeapAnalyzedListener] implementation, which will store the analysis to disk and
@@ -21,7 +25,7 @@ class DefaultOnHeapAnalyzedListener(private val application: Application) : OnHe
 
   override fun onHeapAnalyzed(heapAnalysis: HeapAnalysis) {
     // TODO better log that include leakcanary version, exclusions, etc.
-    CanaryLog.d("%s", heapAnalysis)
+    SharkLog.d("%s", heapAnalysis)
 
     val (id, groupProjections) = LeaksDbHelper(application)
         .writableDatabase.use { db ->
diff --git a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
index 732fff3b..d2174f6d 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/LeakCanary.kt
@@ -1,12 +1,17 @@
 package leakcanary
 
 import android.content.Intent
-import leakcanary.ReferenceMatcher.IgnoredReferenceMatcher
-import leakcanary.ReferenceMatcher.LibraryLeakReferenceMatcher
+import leakcanary.LeakCanary.config
 import leakcanary.internal.InternalLeakCanary
+import shark.AndroidObjectInspectors
+import shark.AndroidReferenceMatchers
+import shark.ObjectInspector
+import shark.ReferenceMatcher
+import shark.IgnoredReferenceMatcher
+import shark.LibraryLeakReferenceMatcher
 
 /**
- * The entry point API for LeakCanary. LeakCanary builds on top of [LeakSentry]. LeakSentry
+ * The entry point API for LeakCanary. LeakCanary builds on top of [AppWatcher]. AppWatcher
  * notifies LeakCanary of retained instances, which in turns dumps the heap, analyses it and
  * publishes the results.
  *
@@ -44,7 +49,7 @@ object LeakCanary {
      * be fixed.
      *
      * When the app becomes invisible, LeakCanary dumps the heap after
-     * [LeakSentry.Config.watchDurationMillis] ms.
+     * [AppWatcher.Config.watchDurationMillis] ms.
      *
      * The app is considered visible if it has at least one activity in started state.
      *
@@ -62,7 +67,7 @@ object LeakCanary {
      * When adding your own custom [LibraryLeakReferenceMatcher] instances, you'll most
      * likely want to set [LibraryLeakReferenceMatcher.patternApplies] with a filter that checks
      * for the Android OS version and manufacturer. The build information can be obtained by calling
-     * [HprofGraph.androidBuildMirror].
+     * [shark.AndroidBuildMirror.fromHeapGraph].
      *
      * Defaults to [AndroidReferenceMatchers.appDefaults]
      */
@@ -71,7 +76,7 @@ object LeakCanary {
     /**
      * List of [ObjectInspector] that provide LeakCanary with insights about objects found in the
      * heap. You can create your own [ObjectInspector] implementations, and also add
-     * a [AppSingletonInspector] instance created with the list of internal singletons.
+     * a [shark.AppSingletonInspector] instance created with the list of internal singletons.
      *
      * Defaults to [AndroidObjectInspectors.appDefaults]
      */
@@ -94,8 +99,8 @@ object LeakCanary {
      * associated to Java objects (e.g. Android bitmaps).
      *
      * Computing the retained heap size can slow down the analysis because it requires navigating
-     * from GC roots through the entire object graph, whereas [HeapAnalyzer] would otherwise stop
-     * as soon as all leaking instances are found.
+     * from GC roots through the entire object graph, whereas [shark.HeapAnalyzer] would otherwise
+     * stop as soon as all leaking instances are found.
      *
      * Defaults to true.
      */
@@ -141,7 +146,7 @@ object LeakCanary {
    * ```
    */
   @Volatile
-  var config: Config = if (LeakSentry.isInstalled) Config() else InternalLeakCanary.noInstallConfig
+  var config: Config = if (AppWatcher.isInstalled) Config() else InternalLeakCanary.noInstallConfig
 
   /**
    * Returns a new [Intent] that can be used to programmatically launch the leak display activity.
@@ -150,7 +155,7 @@ object LeakCanary {
 
   /**
    * Immediately triggers a heap dump and analysis, if there is at least one retained instance
-   * tracked by [LeakSentry.objectWatcher]. If there are no retained instances then the heap will not
+   * tracked by [AppWatcher.objectWatcher]. If there are no retained instances then the heap will not
    * be dumped and a notification will be shown instead.
    */
   fun dumpHeap() = InternalLeakCanary.onDumpHeapReceived()
diff --git a/leakcanary-android-core/src/main/java/leakcanary/OnHeapAnalyzedListener.kt b/leakcanary-android-core/src/main/java/leakcanary/OnHeapAnalyzedListener.kt
index 50d552cf..fe95de38 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/OnHeapAnalyzedListener.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/OnHeapAnalyzedListener.kt
@@ -1,7 +1,8 @@
 package leakcanary
 
-import leakcanary.ObjectInspector.Companion.invoke
 import leakcanary.OnHeapAnalyzedListener.Companion.invoke
+import shark.HeapAnalysis
+import shark.ObjectInspector.Companion.invoke
 
 /**
  * Listener set in [LeakCanary.Config] and called by LeakCanary on a background thread when the
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
index 0c417b48..0c2828f3 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/AndroidHeapDumper.kt
@@ -30,9 +30,9 @@ import android.view.LayoutInflater
 import android.view.View
 import android.widget.Toast
 import com.squareup.leakcanary.core.R
-import leakcanary.CanaryLog
 import leakcanary.internal.InternalLeakCanary.noOpDelegate
 import leakcanary.internal.NotificationType.LEAKCANARY_LOW
+import shark.SharkLog
 import java.io.File
 import java.util.concurrent.TimeUnit.SECONDS
 
@@ -68,7 +68,7 @@ internal class AndroidHeapDumper(
     showToast(waitingForToast)
 
     if (!waitingForToast.wait(5, SECONDS)) {
-      CanaryLog.d("Did not dump heap, too much time waiting for Toast.")
+      SharkLog.d("Did not dump heap, too much time waiting for Toast.")
       return null
     }
 
@@ -87,13 +87,13 @@ internal class AndroidHeapDumper(
     return try {
       Debug.dumpHprofData(heapDumpFile.absolutePath)
       if (heapDumpFile.length() == 0L) {
-        CanaryLog.d("Dumped heap file is 0 byte length")
+        SharkLog.d("Dumped heap file is 0 byte length")
         null
       } else {
         heapDumpFile
       }
     } catch (e: Exception) {
-      CanaryLog.d(e, "Could not dump heap")
+      SharkLog.d(e, "Could not dump heap")
       // Abort heap dump
       null
     } finally {
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
index 239544b9..059da4fc 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/DisplayLeakAdapter.kt
@@ -25,12 +25,6 @@ import android.view.ViewGroup
 import android.widget.BaseAdapter
 import android.widget.TextView
 import com.squareup.leakcanary.core.R
-import leakcanary.LeakNodeStatus.LEAKING
-import leakcanary.LeakNodeStatus.NOT_LEAKING
-import leakcanary.LeakNodeStatus.UNKNOWN
-import leakcanary.LeakTrace
-import leakcanary.LeakTraceElement
-import leakcanary.LeakTraceElement.Type.STATIC_FIELD
 import leakcanary.internal.DisplayLeakConnectorView.Type
 import leakcanary.internal.DisplayLeakConnectorView.Type.END
 import leakcanary.internal.DisplayLeakConnectorView.Type.END_FIRST_UNREACHABLE
@@ -46,6 +40,12 @@ import leakcanary.internal.DisplayLeakConnectorView.Type.START_LAST_REACHABLE
 import leakcanary.internal.activity.db.LeakingInstanceTable.InstanceProjection
 import leakcanary.internal.navigation.getColorCompat
 import leakcanary.internal.navigation.inflate
+import shark.LeakNodeStatus.LEAKING
+import shark.LeakNodeStatus.NOT_LEAKING
+import shark.LeakNodeStatus.UNKNOWN
+import shark.LeakTrace
+import shark.LeakTraceElement
+import shark.LeakTraceElement.Type.STATIC_FIELD
 
 @Suppress("DEPRECATION")
 internal class DisplayLeakAdapter constructor(
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
index 324c68dd..bd311184 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapAnalyzerService.kt
@@ -20,11 +20,11 @@ import android.content.Intent
 import android.os.Build.VERSION.SDK_INT
 import android.os.Process
 import com.squareup.leakcanary.core.R
-import leakcanary.AnalyzerProgressListener
-import leakcanary.AndroidObjectInspectors
-import leakcanary.CanaryLog
-import leakcanary.HeapAnalyzer
 import leakcanary.LeakCanary
+import shark.OnAnalysisProgressListener
+import shark.HeapAnalyzer
+import shark.ObjectInspectors
+import shark.SharkLog
 import java.io.File
 
 /**
@@ -34,11 +34,11 @@ internal class HeapAnalyzerService : ForegroundService(
     HeapAnalyzerService::class.java.simpleName,
     R.string.leak_canary_notification_analysing,
     R.id.leak_canary_notification_analyzing_heap
-), AnalyzerProgressListener {
+), OnAnalysisProgressListener {
 
   override fun onHandleIntentInForeground(intent: Intent?) {
     if (intent == null) {
-      CanaryLog.d("HeapAnalyzerService received a null intent, ignoring.")
+      SharkLog.d("HeapAnalyzerService received a null intent, ignoring.")
       return
     }
     // Since we're running in the main process we should be careful not to impact it.
@@ -61,16 +61,16 @@ internal class HeapAnalyzerService : ForegroundService(
       heapAnalyzer.checkForLeaks(
           heapDumpFile, config.referenceMatchers, config.computeRetainedHeapSize, config.objectInspectors,
           if (config.useExperimentalLeakFinders) config.objectInspectors else listOf(
-              AndroidObjectInspectors.KEYED_WEAK_REFERENCE
+              ObjectInspectors.KEYED_WEAK_REFERENCE
           )
       )
 
     config.onHeapAnalyzedListener.onHeapAnalyzed(heapAnalysis)
   }
 
-  override fun onProgressUpdate(step: AnalyzerProgressListener.Step) {
-    val percent = (100f * step.ordinal / AnalyzerProgressListener.Step.values().size).toInt()
-    CanaryLog.d("Analysis in progress, working on: %s", step.name)
+  override fun onAnalysisProgress(step: OnAnalysisProgressListener.Step) {
+    val percent = (100f * step.ordinal / shark.OnAnalysisProgressListener.Step.values().size).toInt()
+    SharkLog.d("Analysis in progress, working on: %s", step.name)
     val lowercase = step.name.replace("_", " ")
         .toLowerCase()
     val message = lowercase.substring(0, 1).toUpperCase() + lowercase.substring(1)
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
index 8183afbc..846e068e 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/HeapDumpTrigger.kt
@@ -7,15 +7,15 @@ import android.content.Context
 import android.os.Handler
 import android.os.SystemClock
 import com.squareup.leakcanary.core.R
-import leakcanary.CanaryLog
 import leakcanary.GcTrigger
 import leakcanary.KeyedWeakReference
 import leakcanary.LeakCanary.Config
-import leakcanary.LeakSentry
+import leakcanary.AppWatcher
 import leakcanary.ObjectWatcher
 import leakcanary.internal.NotificationReceiver.Action.CANCEL_NOTIFICATION
 import leakcanary.internal.NotificationReceiver.Action.DUMP_HEAP
 import leakcanary.internal.NotificationType.LEAKCANARY_LOW
+import shark.SharkLog
 
 internal class HeapDumpTrigger(
   private val application: Application,
@@ -54,7 +54,7 @@ internal class HeapDumpTrigger(
   private val applicationInvisibleLessThanWatchPeriod: Boolean
     get() {
       val applicationInvisibleAt = applicationInvisibleAt
-      return applicationInvisibleAt != -1L && SystemClock.uptimeMillis() - applicationInvisibleAt < LeakSentry.config.watchDurationMillis
+      return applicationInvisibleAt != -1L && SystemClock.uptimeMillis() - applicationInvisibleAt < AppWatcher.config.watchDurationMillis
     }
 
   @Volatile
@@ -65,7 +65,7 @@ internal class HeapDumpTrigger(
       applicationInvisibleAt = -1L
     } else {
       applicationInvisibleAt = SystemClock.uptimeMillis()
-      scheduleRetainedObjectCheck("app became invisible", LeakSentry.config.watchDurationMillis)
+      scheduleRetainedObjectCheck("app became invisible", AppWatcher.config.watchDurationMillis)
     }
   }
 
@@ -77,10 +77,10 @@ internal class HeapDumpTrigger(
     val config = configProvider()
     // A tick will be rescheduled when this is turned back on.
     if (!config.dumpHeap) {
-      CanaryLog.d("No checking for retained object: LeakCanary.Config.dumpHeap is false")
+      SharkLog.d("No checking for retained object: LeakCanary.Config.dumpHeap is false")
       return
     }
-    CanaryLog.d("Checking retained object because %s", reason)
+    SharkLog.d("Checking retained object because %s", reason)
 
     var retainedReferenceCount = objectWatcher.retainedObjectCount
 
@@ -94,20 +94,20 @@ internal class HeapDumpTrigger(
     if (!config.dumpHeapWhenDebugging && DebuggerControl.isDebuggerAttached) {
       showRetainedCountWithDebuggerAttached(retainedReferenceCount)
       scheduleRetainedObjectCheck("debugger was attached", WAIT_FOR_DEBUG_MILLIS)
-      CanaryLog.d(
+      SharkLog.d(
           "Not checking for leaks while the debugger is attached, will retry in %d ms",
           WAIT_FOR_DEBUG_MILLIS
       )
       return
     }
 
-    CanaryLog.d("Found %d retained references, dumping the heap", retainedReferenceCount)
+    SharkLog.d("Found %d retained references, dumping the heap", retainedReferenceCount)
     val heapDumpUptimeMillis = SystemClock.uptimeMillis()
     KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis
     dismissRetainedCountNotification()
     val heapDumpFile = heapDumper.dumpHeap()
     if (heapDumpFile == null) {
-      CanaryLog.d("Failed to dump heap, will retry in %d ms", WAIT_AFTER_DUMP_FAILED_MILLIS)
+      SharkLog.d("Failed to dump heap, will retry in %d ms", WAIT_AFTER_DUMP_FAILED_MILLIS)
       scheduleRetainedObjectCheck("failed to dump heap", WAIT_AFTER_DUMP_FAILED_MILLIS)
       showRetainedCountWithHeapDumpFailed(retainedReferenceCount)
       return
@@ -124,7 +124,7 @@ internal class HeapDumpTrigger(
       gcTrigger.runGc()
       val retainedReferenceCount = objectWatcher.retainedObjectCount
       if (retainedReferenceCount == 0) {
-        CanaryLog.d("No retained objects after GC")
+        SharkLog.d("No retained objects after GC")
         @Suppress("DEPRECATION")
         val builder = Notification.Builder(application)
             .setContentTitle(
@@ -152,11 +152,11 @@ internal class HeapDumpTrigger(
 
       val heapDumpUptimeMillis = SystemClock.uptimeMillis()
       KeyedWeakReference.heapDumpUptimeMillis = heapDumpUptimeMillis
-      CanaryLog.d("Dumping the heap because user tapped notification")
+      SharkLog.d("Dumping the heap because user tapped notification")
 
       val heapDumpFile = heapDumper.dumpHeap()
       if (heapDumpFile == null) {
-        CanaryLog.d("Failed to dump heap")
+        SharkLog.d("Failed to dump heap")
         showRetainedCountWithHeapDumpFailed(retainedReferenceCount)
         return@post
       }
@@ -173,7 +173,7 @@ internal class HeapDumpTrigger(
     val countChanged = lastDisplayedRetainedObjectCount != retainedKeysCount
     lastDisplayedRetainedObjectCount = retainedKeysCount
     if (retainedKeysCount == 0) {
-      CanaryLog.d("No retained objects")
+      SharkLog.d("No retained objects")
       if (countChanged) {
         showNoMoreRetainedObjectNotification()
       }
@@ -182,7 +182,7 @@ internal class HeapDumpTrigger(
 
     if (retainedKeysCount < retainedVisibleThreshold) {
       if (applicationVisible || applicationInvisibleLessThanWatchPeriod) {
-        CanaryLog.d(
+        SharkLog.d(
             "Found %d retained objects, which is less than the visible threshold of %d",
             retainedKeysCount,
             retainedVisibleThreshold
@@ -199,7 +199,7 @@ internal class HeapDumpTrigger(
 
   private fun scheduleRetainedObjectCheck(reason: String) {
     if (checkScheduled) {
-      CanaryLog.d("Already scheduled retained check, ignoring ($reason)")
+      SharkLog.d("Already scheduled retained check, ignoring ($reason)")
       return
     }
     checkScheduled = true
@@ -214,7 +214,7 @@ internal class HeapDumpTrigger(
     delayMillis: Long
   ) {
     if (checkScheduled) {
-      CanaryLog.d("Already scheduled retained check, ignoring ($reason)")
+      SharkLog.d("Already scheduled retained check, ignoring ($reason)")
       return
     }
     checkScheduled = true
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
index 6c0470a8..bd5ed793 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/InternalLeakCanary.kt
@@ -12,13 +12,13 @@ import android.os.Build.VERSION_CODES
 import android.os.Handler
 import android.os.HandlerThread
 import com.squareup.leakcanary.core.R
-import leakcanary.CanaryLog
 import leakcanary.GcTrigger
 import leakcanary.LeakCanary
 import leakcanary.LeakCanary.Config
-import leakcanary.LeakSentry
+import leakcanary.AppWatcher
 import leakcanary.OnObjectRetainedListener
 import leakcanary.internal.activity.LeakActivity
+import shark.SharkLog
 import java.lang.reflect.InvocationHandler
 import java.lang.reflect.Proxy
 import java.util.concurrent.atomic.AtomicReference
@@ -53,6 +53,8 @@ internal object InternalLeakCanary : (Application) -> Unit, OnObjectRetainedList
   override fun invoke(application: Application) {
     this.application = application
 
+    AppWatcher.objectWatcher.addOnObjectRetainedListener(this)
+
     val heapDumper = AndroidHeapDumper(application, leakDirectoryProvider)
 
     val gcTrigger = GcTrigger.Default
@@ -64,7 +66,7 @@ internal object InternalLeakCanary : (Application) -> Unit, OnObjectRetainedList
     val backgroundHandler = Handler(handlerThread.looper)
 
     heapDumpTrigger = HeapDumpTrigger(
-        application, backgroundHandler, LeakSentry.objectWatcher, gcTrigger, heapDumper, configProvider
+        application, backgroundHandler, AppWatcher.objectWatcher, gcTrigger, heapDumper, configProvider
     )
     application.registerVisibilityListener { applicationVisible ->
       this.applicationVisible = applicationVisible
@@ -97,7 +99,7 @@ internal object InternalLeakCanary : (Application) -> Unit, OnObjectRetainedList
       }
 
       if (runningInInstrumentationTests) {
-        CanaryLog.d("Instrumentation test detected, setting LeakCanary.Config.dumpHeap to false")
+        SharkLog.d("Instrumentation test detected, setting LeakCanary.Config.dumpHeap to false")
         LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
       }
     }
@@ -199,7 +201,7 @@ internal object InternalLeakCanary : (Application) -> Unit, OnObjectRetainedList
     try {
       shortcutManager.addDynamicShortcuts(listOf(shortcut))
     } catch (ignored: Throwable) {
-      CanaryLog.d(
+      SharkLog.d(
           ignored,
           "Could not add dynamic shortcut. " +
               "shortcutCount=$shortcutCount, " +
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
index d569f833..352012de 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/LeakDirectoryProvider.kt
@@ -24,8 +24,8 @@ import android.os.Build.VERSION_CODES.M
 import android.os.Environment
 import android.os.Environment.DIRECTORY_DOWNLOADS
 import com.squareup.leakcanary.core.R
-import leakcanary.CanaryLog
 import leakcanary.internal.NotificationType.LEAKCANARY_LOW
+import shark.SharkLog
 import java.io.File
 import java.io.FilenameFilter
 import java.text.SimpleDateFormat
@@ -73,17 +73,17 @@ internal class LeakDirectoryProvider constructor(
     if (!directoryWritableAfterMkdirs(storageDirectory)) {
       if (!hasStoragePermission()) {
         if (requestExternalStoragePermission()) {
-          CanaryLog.d("WRITE_EXTERNAL_STORAGE permission not granted, requesting")
+          SharkLog.d("WRITE_EXTERNAL_STORAGE permission not granted, requesting")
           requestWritePermissionNotification()
         } else {
-          CanaryLog.d("WRITE_EXTERNAL_STORAGE permission not granted, ignoring")
+          SharkLog.d("WRITE_EXTERNAL_STORAGE permission not granted, ignoring")
         }
       } else {
         val state = Environment.getExternalStorageState()
         if (Environment.MEDIA_MOUNTED != state) {
-          CanaryLog.d("External storage not mounted, state: %s", state)
+          SharkLog.d("External storage not mounted, state: %s", state)
         } else {
-          CanaryLog.d(
+          SharkLog.d(
               "Could not create heap dump directory in external storage: [%s]",
               storageDirectory.absolutePath
           )
@@ -92,7 +92,7 @@ internal class LeakDirectoryProvider constructor(
       // Fallback to app storage.
       storageDirectory = appStorageDirectory()
       if (!directoryWritableAfterMkdirs(storageDirectory)) {
-        CanaryLog.d(
+        SharkLog.d(
             "Could not create heap dump directory in app storage: [%s]",
             storageDirectory.absolutePath
         )
@@ -116,7 +116,7 @@ internal class LeakDirectoryProvider constructor(
         filesDeletedClearDirectory += path
       }
       if (!deleted) {
-        CanaryLog.d("Could not delete file %s", file.path)
+        SharkLog.d("Could not delete file %s", file.path)
       }
     }
   }
@@ -183,7 +183,7 @@ internal class LeakDirectoryProvider constructor(
 
     val filesToRemove = hprofFiles.size - maxStoredHeapDumps
     if (filesToRemove > 0) {
-      CanaryLog.d("Removing %d heap dumps", filesToRemove)
+      SharkLog.d("Removing %d heap dumps", filesToRemove)
       // Sort with oldest modified first.
       hprofFiles.sortWith(Comparator { lhs, rhs ->
         java.lang.Long.valueOf(lhs.lastModified())
@@ -195,7 +195,7 @@ internal class LeakDirectoryProvider constructor(
         if (deleted) {
           filesDeletedTooOld += path
         } else {
-          CanaryLog.d("Could not delete old hprof file %s", hprofFiles[i].path)
+          SharkLog.d("Could not delete old hprof file %s", hprofFiles[i].path)
         }
       }
     }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationReceiver.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationReceiver.kt
index f7e7f86c..e20c7ea4 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationReceiver.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/NotificationReceiver.kt
@@ -4,9 +4,9 @@ import android.app.PendingIntent
 import android.content.BroadcastReceiver
 import android.content.Context
 import android.content.Intent
-import leakcanary.CanaryLog
 import leakcanary.internal.NotificationReceiver.Action.CANCEL_NOTIFICATION
 import leakcanary.internal.NotificationReceiver.Action.DUMP_HEAP
+import shark.SharkLog
 
 internal class NotificationReceiver : BroadcastReceiver() {
 
@@ -27,7 +27,7 @@ internal class NotificationReceiver : BroadcastReceiver() {
         // Do nothing, the notification has auto cancel true.
       }
       else -> {
-        CanaryLog.d("NotificationReceiver received unknown intent action for $intent")
+        SharkLog.d("NotificationReceiver received unknown intent action for $intent")
       }
     }
   }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakActivity.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakActivity.kt
index bd1ba2e0..fca9f664 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakActivity.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/LeakActivity.kt
@@ -7,13 +7,13 @@ import android.net.Uri
 import android.os.AsyncTask
 import android.os.Bundle
 import com.squareup.leakcanary.core.R
-import leakcanary.CanaryLog
 import leakcanary.internal.HeapAnalyzerService
 import leakcanary.internal.InternalLeakCanary
 import leakcanary.internal.activity.db.Db
 import leakcanary.internal.activity.screen.GroupListScreen
 import leakcanary.internal.navigation.NavigatingActivity
 import leakcanary.internal.navigation.Screen
+import shark.SharkLog
 import java.io.FileInputStream
 import java.io.IOException
 
@@ -47,7 +47,7 @@ internal class LeakActivity : NavigatingActivity() {
     resultCode: Int,
     returnIntent: Intent?
   ) {
-    CanaryLog.d(
+    SharkLog.d(
         "Got activity result with requestCode=$requestCode resultCode=$resultCode returnIntent=$returnIntent"
     )
     if (requestCode == FILE_REQUEST_CODE && resultCode == RESULT_OK && returnIntent != null) {
@@ -77,7 +77,7 @@ internal class LeakActivity : NavigatingActivity() {
             }
       }
     } catch (e: IOException) {
-      CanaryLog.d(e, "Could not imported Hprof file")
+      SharkLog.d(e, "Could not imported Hprof file")
     }
   }
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
index 4f4d02ab..c28c42c8 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/HeapAnalysisTable.kt
@@ -4,15 +4,15 @@ import android.content.ContentValues
 import android.content.Context
 import android.database.sqlite.SQLiteDatabase
 import android.os.AsyncTask
-import leakcanary.CanaryLog
-import leakcanary.HeapAnalysis
-import leakcanary.HeapAnalysisFailure
-import leakcanary.HeapAnalysisSuccess
-import leakcanary.internal.Serializables
 import leakcanary.internal.InternalLeakCanary
 import leakcanary.internal.LeakDirectoryProvider
+import leakcanary.internal.Serializables
 import leakcanary.internal.toByteArray
 import org.intellij.lang.annotations.Language
+import shark.HeapAnalysis
+import shark.HeapAnalysisFailure
+import shark.HeapAnalysisSuccess
+import shark.SharkLog
 import java.io.File
 
 internal object HeapAnalysisTable {
@@ -127,7 +127,7 @@ internal object HeapAnalysisTable {
         if (heapDumpDeleted) {
           LeakDirectoryProvider.filesDeletedRemoveLeak += path
         } else {
-          CanaryLog.d("Could not delete heap dump file %s", heapDumpFile.path)
+          SharkLog.d("Could not delete heap dump file %s", heapDumpFile.path)
         }
       }
     }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
index a557df8a..72fac8d8 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeakingInstanceTable.kt
@@ -2,15 +2,15 @@ package leakcanary.internal.activity.db
 
 import android.content.ContentValues
 import android.database.sqlite.SQLiteDatabase
-import leakcanary.LeakTrace
-import leakcanary.LeakTraceElement
-import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
-import leakcanary.Leak
-import leakcanary.Leak.LibraryLeak
 import leakcanary.internal.Serializables
-import leakcanary.internal.utils.to
 import leakcanary.internal.toByteArray
+import leakcanary.internal.utils.to
 import org.intellij.lang.annotations.Language
+import shark.Leak
+import shark.LibraryLeak
+import shark.LeakTrace
+import shark.LeakTraceElement
+import shark.LeakTraceElement.Type.ARRAY_ENTRY
 
 internal object LeakingInstanceTable {
 
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
index 4b1abaaa..dafa91ec 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/db/LeaksDbHelper.kt
@@ -26,6 +26,6 @@ internal class LeaksDbHelper(context: Context) : SQLiteOpenHelper(
 
   companion object {
     // Last updated for next after 2.0-alpha-3
-    private const val VERSION = 13
+    private const val VERSION = 15
   }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupScreen.kt
index 3fb28ebb..08d7c0d5 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/GroupScreen.kt
@@ -5,7 +5,6 @@ import android.view.ViewGroup
 import android.widget.ListView
 import com.squareup.leakcanary.core.R
 import com.squareup.leakcanary.core.R.plurals
-import leakcanary.LeakTrace
 import leakcanary.internal.DisplayLeakAdapter
 import leakcanary.internal.activity.db.LeakingInstanceTable
 import leakcanary.internal.activity.db.LeakingInstanceTable.InstanceProjection
@@ -14,6 +13,7 @@ import leakcanary.internal.navigation.Screen
 import leakcanary.internal.navigation.activity
 import leakcanary.internal.navigation.goTo
 import leakcanary.internal.navigation.inflate
+import shark.LeakTrace
 
 internal class GroupScreen(private val groupHash: String) : Screen() {
   override fun createView(container: ViewGroup) =
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisFailureScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisFailureScreen.kt
index e058a835..211e95e6 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisFailureScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisFailureScreen.kt
@@ -5,7 +5,6 @@ import android.view.ViewGroup
 import android.widget.TextView
 import com.squareup.leakcanary.core.BuildConfig
 import com.squareup.leakcanary.core.R
-import leakcanary.HeapAnalysisFailure
 import leakcanary.internal.activity.db.HeapAnalysisTable
 import leakcanary.internal.activity.db.executeOnDb
 import leakcanary.internal.activity.share
@@ -15,6 +14,7 @@ import leakcanary.internal.navigation.activity
 import leakcanary.internal.navigation.goBack
 import leakcanary.internal.navigation.inflate
 import leakcanary.internal.navigation.onCreateOptionsMenu
+import shark.HeapAnalysisFailure
 
 internal class HeapAnalysisFailureScreen(
   private val analysisId: Long
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt
index 058a4412..546a1d63 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapAnalysisSuccessScreen.kt
@@ -6,7 +6,6 @@ import android.view.ViewGroup
 import android.widget.ListView
 import android.widget.TextView
 import com.squareup.leakcanary.core.R
-import leakcanary.HeapAnalysisSuccess
 import leakcanary.internal.activity.db.HeapAnalysisTable
 import leakcanary.internal.activity.db.LeakingInstanceTable
 import leakcanary.internal.activity.db.LeakingInstanceTable.HeapAnalysisGroupProjection
@@ -19,6 +18,7 @@ import leakcanary.internal.navigation.goBack
 import leakcanary.internal.navigation.goTo
 import leakcanary.internal.navigation.inflate
 import leakcanary.internal.navigation.onCreateOptionsMenu
+import shark.HeapAnalysisSuccess
 
 internal class HeapAnalysisSuccessScreen(
   private val analysisId: Long
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
index dfafa8f4..4cc1d5bb 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HeapDumpRenderer.kt
@@ -11,29 +11,28 @@ import android.graphics.Paint.Style.FILL
 import android.graphics.Paint.Style.STROKE
 import android.graphics.Rect
 import com.squareup.leakcanary.core.R
-import leakcanary.HprofPushRecordsParser
-import leakcanary.HprofPushRecordsParser.OnRecordListener
-import leakcanary.Record
-import leakcanary.Record.HeapDumpEndRecord
-import leakcanary.Record.HeapDumpRecord.GcRootRecord
-import leakcanary.Record.HeapDumpRecord.HeapDumpInfoRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
-import leakcanary.Record.LoadClassRecord
-import leakcanary.Record.StackTraceRecord
-import leakcanary.Record.StringRecord
 import leakcanary.internal.navigation.getColorCompat
+import shark.Hprof
+import shark.HprofRecord
+import shark.HprofRecord.HeapDumpEndRecord
+import shark.HprofRecord.HeapDumpRecord.GcRootRecord
+import shark.HprofRecord.HeapDumpRecord.HeapDumpInfoRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import shark.HprofRecord.LoadClassRecord
+import shark.HprofRecord.StackTraceRecord
+import shark.HprofRecord.StringRecord
+import shark.OnHprofRecordListener
 import java.io.File
-import kotlin.reflect.KClass
 
 internal object HeapDumpRenderer {
 
@@ -58,7 +57,7 @@ internal object HeapDumpRenderer {
     sourceBytesPerPixel: Int
   ): Bitmap = with(HasDensity(context.resources)) {
     val recordPositions = mutableListOf<Pair<Int, Long>>()
-    var currentRecord: Record? = null
+    var currentRecord: HprofRecord? = null
 
     val otherColor = context.getColorCompat(R.color.leak_canary_heap_other)
     val stackTraceColor = context.getColorCompat(R.color.leak_canary_heap_stack_trace)
@@ -99,190 +98,183 @@ internal object HeapDumpRenderer {
     val zygoteHeapColor = context.getColorCompat(R.color.leak_canary_heap_zygote)
     val stringColor = context.getColorCompat(R.color.leak_canary_heap_instance_string)
 
-    val parser = HprofPushRecordsParser()
     var lastPosition = 0L
-    parser.readHprofRecords(heapDumpFile, setOf(object : OnRecordListener {
-      override fun recordTypes(): Set<KClass<out Record>> = setOf(Record::class)
 
-      val hprofStringCache = mutableMapOf<Long, String>()
-      val classNames = mutableMapOf<Long, Long>()
-
-      override fun onTypeSizesAvailable(typeSizes: Map<Int, Int>) {
-      }
-
-      override fun onRecord(
-        position: Long,
-        record: Record
-      ) {
-        lastPosition = position
-        when (record) {
-          is StringRecord -> {
-            hprofStringCache[record.id] = record.string
-          }
-          is LoadClassRecord -> {
-            classNames[record.id] = record.classNameStringId
-          }
-        }
-        val localCurrentRecord = currentRecord
-        when {
-          localCurrentRecord is HeapDumpInfoRecord -> {
-            val colorForHeapInfo =
-              when (hprofStringCache[localCurrentRecord.heapNameStringId]) {
-                // The primary heap on which your app allocates memory.
-                "app" -> appHeapColor
-                // The system boot image, containing classes that are preloaded during boot time.
-                // Allocations here are guaranteed to never move or go away.
-                "image" -> imageHeapColor
-                // The copy-on-write heap where an app process is forked from in the Android system.
-                "zygote" -> zygoteHeapColor
-                // JNI heap: The heap that shows where Java Native Interface (JNI) references are allocated and released.
-                // default heap: When no heap is specified by the system
-                else -> otherColor
+    Hprof.open(heapDumpFile)
+        .use { hprof ->
+          val hprofStringCache = mutableMapOf<Long, String>()
+          val classNames = mutableMapOf<Long, Long>()
+          hprof.reader.readHprofRecords(
+              setOf(HprofRecord::class), OnHprofRecordListener { position, record ->
+            lastPosition = position
+            when (record) {
+              is StringRecord -> {
+                hprofStringCache[record.id] = record.string
               }
-            recordPositions.add(colorForHeapInfo to position)
-            currentRecord = record
-          }
-          localCurrentRecord is InstanceDumpRecord
-              && hprofStringCache[classNames[localCurrentRecord.classId]] == "java.lang.String"
-              && (record !is InstanceDumpRecord || hprofStringCache[classNames[record.classId]]
-              != "java.lang.String")
-          -> {
-            recordPositions.add(stringColor to position)
-            currentRecord = record
-          }
-          currentRecord == null -> {
-            recordPositions.add(otherColor to position)
-            currentRecord = record
-          }
-          currentRecord!!::class != record::class -> {
-            recordPositions.add(colors.getValue(currentRecord!!::class) to position)
-            currentRecord = record
-          }
-        }
-      }
-    })).close()
-    val heapLength = lastPosition
+              is LoadClassRecord -> {
+                classNames[record.id] = record.classNameStringId
+              }
+            }
+            val localCurrentRecord = currentRecord
+            when {
+              localCurrentRecord is HeapDumpInfoRecord -> {
+                val colorForHeapInfo =
+                  when (hprofStringCache[localCurrentRecord.heapNameStringId]) {
+                    // The primary heap on which your app allocates memory.
+                    "app" -> appHeapColor
+                    // The system boot image, containing classes that are preloaded during boot time.
+                    // Allocations here are guaranteed to never move or go away.
+                    "image" -> imageHeapColor
+                    // The copy-on-write heap where an app process is forked from in the Android system.
+                    "zygote" -> zygoteHeapColor
+                    // JNI heap: The heap that shows where Java Native Interface (JNI) references are allocated and released.
+                    // default heap: When no heap is specified by the system
+                    else -> otherColor
+                  }
+                recordPositions.add(colorForHeapInfo to position)
+                currentRecord = record
+              }
+              localCurrentRecord is InstanceDumpRecord
+                  && hprofStringCache[classNames[localCurrentRecord.classId]] == "java.lang.String"
+                  && (record !is InstanceDumpRecord || hprofStringCache[classNames[record.classId]]
+                  != "java.lang.String")
+              -> {
+                recordPositions.add(stringColor to position)
+                currentRecord = record
+              }
+              currentRecord == null -> {
+                recordPositions.add(otherColor to position)
+                currentRecord = record
+              }
+              currentRecord!!::class != record::class -> {
+                recordPositions.add(colors.getValue(currentRecord!!::class) to position)
+                currentRecord = record
+              }
+            }
+          })
+          val heapLength = lastPosition
 
-    val width = sourceWidth
-    var height: Int
-    val bytesPerPixel: Double
+          val width = sourceWidth
+          var height: Int
+          val bytesPerPixel: Double
 
-    if (sourceBytesPerPixel > 0) {
-      bytesPerPixel = sourceBytesPerPixel.toDouble()
-      height = Math.ceil((heapLength / bytesPerPixel) / width)
-          .toInt()
-    } else {
-      height = sourceHeight
-      bytesPerPixel = heapLength * 1.0 / (width * height)
-    }
+          if (sourceBytesPerPixel > 0) {
+            bytesPerPixel = sourceBytesPerPixel.toDouble()
+            height = Math.ceil((heapLength / bytesPerPixel) / width)
+                .toInt()
+          } else {
+            height = sourceHeight
+            bytesPerPixel = heapLength * 1.0 / (width * height)
+          }
 
-    val bitmap: Bitmap =
-      Bitmap.createBitmap(width, height, ARGB_8888)
+          val bitmap: Bitmap =
+            Bitmap.createBitmap(width, height, ARGB_8888)
 
-    val canvas = Canvas(bitmap)
+          val canvas = Canvas(bitmap)
 
-    val legend = mapOf(
-        "Hprof string" to hprofStringColor,
-        "Class name" to loadClassColor,
-        "App heap" to appHeapColor,
-        "Image heap" to imageHeapColor,
-        "Zygote heap" to zygoteHeapColor,
-        "Other heap" to otherColor,
-        "Class content" to classDumpColor,
-        "Instance" to instanceColor,
-        "String" to stringColor,
-        "Object array" to objectArrayColor,
-        "Boolean array" to booleanArrayColor,
-        "Char array" to charArrayColor,
-        "Float array" to floatArrayColor,
-        "Double array" to doubleArrayColor,
-        "Byte array" to byteArrayColor,
-        "Short array" to shortArrayColor,
-        "Int array" to intArrayColor,
-        "Long array" to longArrayColor,
-        "Stack trace" to stackTraceColor,
-        "Heap End" to otherColor
-    )
+          val legend = mapOf(
+              "Hprof string" to hprofStringColor,
+              "Class name" to loadClassColor,
+              "App heap" to appHeapColor,
+              "Image heap" to imageHeapColor,
+              "Zygote heap" to zygoteHeapColor,
+              "Other heap" to otherColor,
+              "Class content" to classDumpColor,
+              "Instance" to instanceColor,
+              "String" to stringColor,
+              "Object array" to objectArrayColor,
+              "Boolean array" to booleanArrayColor,
+              "Char array" to charArrayColor,
+              "Float array" to floatArrayColor,
+              "Double array" to doubleArrayColor,
+              "Byte array" to byteArrayColor,
+              "Short array" to shortArrayColor,
+              "Int array" to intArrayColor,
+              "Long array" to longArrayColor,
+              "Stack trace" to stackTraceColor,
+              "Heap End" to otherColor
+          )
 
-    val legendTextPaint = Paint(Paint.ANTI_ALIAS_FLAG)
+          val legendTextPaint = Paint(Paint.ANTI_ALIAS_FLAG)
 
-    legendTextPaint.color = Color.WHITE
-    legendTextPaint.style = FILL
-    canvas.drawPaint(legendTextPaint)
+          legendTextPaint.color = Color.WHITE
+          legendTextPaint.style = FILL
+          canvas.drawPaint(legendTextPaint)
 
-    val legendSquareFillPaint = Paint()
-    legendSquareFillPaint.style = FILL
-    val legendSquareStrokePaint = Paint()
-    legendSquareStrokePaint.style = STROKE
-    legendSquareStrokePaint.strokeWidth = 0.8f.dp
-    legendSquareStrokePaint.color = Color.BLACK
+          val legendSquareFillPaint = Paint()
+          legendSquareFillPaint.style = FILL
+          val legendSquareStrokePaint = Paint()
+          legendSquareStrokePaint.style = STROKE
+          legendSquareStrokePaint.strokeWidth = 0.8f.dp
+          legendSquareStrokePaint.color = Color.BLACK
 
-    legendTextPaint.color = Color.BLACK
-    legendTextPaint.textSize = 16.dp
+          legendTextPaint.color = Color.BLACK
+          legendTextPaint.textSize = 16.dp
 
-    val metrics = legendTextPaint.fontMetrics
-    val textHeight = metrics.descent - metrics.ascent
+          val metrics = legendTextPaint.fontMetrics
+          val textHeight = metrics.descent - metrics.ascent
 
-    val xBounds = Rect()
-    legendTextPaint.getTextBounds("x", 0, 1, xBounds)
-    val squareSize = xBounds.height()
-    val squarePaddingTop = (textHeight - squareSize) / 2
-    val squareToTextPadding = 4.dp
-    val blockToBlockPadding = 8.dp
+          val xBounds = Rect()
+          legendTextPaint.getTextBounds("x", 0, 1, xBounds)
+          val squareSize = xBounds.height()
+          val squarePaddingTop = (textHeight - squareSize) / 2
+          val squareToTextPadding = 4.dp
+          val blockToBlockPadding = 8.dp
 
-    var maxTextWidth = 0f
-    for (name in legend.keys) {
-      maxTextWidth = Math.max(maxTextWidth, legendTextPaint.measureText(name))
-    }
+          var maxTextWidth = 0f
+          for (name in legend.keys) {
+            maxTextWidth = Math.max(maxTextWidth, legendTextPaint.measureText(name))
+          }
 
-    val padding = 8.dp
-    var blockLeft = padding
-    var blockTop = padding
-    val legendWidth = width - 2 * padding
-    for ((name, color) in legend) {
-      if (blockLeft + squareSize + squareToTextPadding + maxTextWidth > legendWidth) {
-        blockLeft = padding
-        blockTop += textHeight
-      }
+          val padding = 8.dp
+          var blockLeft = padding
+          var blockTop = padding
+          val legendWidth = width - 2 * padding
+          for ((name, color) in legend) {
+            if (blockLeft + squareSize + squareToTextPadding + maxTextWidth > legendWidth) {
+              blockLeft = padding
+              blockTop += textHeight
+            }
 
-      legendSquareFillPaint.color = color
-      canvas.drawRect(
-          blockLeft, blockTop + squarePaddingTop, blockLeft + squareSize,
-          blockTop + squarePaddingTop + squareSize,
-          legendSquareFillPaint
-      )
-      canvas.drawRect(
-          blockLeft, blockTop + squarePaddingTop, blockLeft + squareSize,
-          blockTop + squarePaddingTop + squareSize,
-          legendSquareStrokePaint
-      )
-      blockLeft += squareSize + squareToTextPadding
-      canvas.drawText(name, blockLeft, blockTop - metrics.ascent, legendTextPaint)
-      blockLeft += maxTextWidth
-      blockLeft += blockToBlockPadding
-    }
-    val legendHeight = blockTop + textHeight + padding
-    val source = Rect(0, 0, width, legendHeight.toInt())
-    val destination = Rect(0, (height - legendHeight).toInt(), width, height)
-    canvas.drawBitmap(bitmap, source, destination, null)
-    height -= legendHeight.toInt()
+            legendSquareFillPaint.color = color
+            canvas.drawRect(
+                blockLeft, blockTop + squarePaddingTop, blockLeft + squareSize,
+                blockTop + squarePaddingTop + squareSize,
+                legendSquareFillPaint
+            )
+            canvas.drawRect(
+                blockLeft, blockTop + squarePaddingTop, blockLeft + squareSize,
+                blockTop + squarePaddingTop + squareSize,
+                legendSquareStrokePaint
+            )
+            blockLeft += squareSize + squareToTextPadding
+            canvas.drawText(name, blockLeft, blockTop - metrics.ascent, legendTextPaint)
+            blockLeft += maxTextWidth
+            blockLeft += blockToBlockPadding
+          }
+          val legendHeight = blockTop + textHeight + padding
+          val source = Rect(0, 0, width, legendHeight.toInt())
+          val destination = Rect(0, (height - legendHeight).toInt(), width, height)
+          canvas.drawBitmap(bitmap, source, destination, null)
+          height -= legendHeight.toInt()
 
-    val pixelPaint = Paint()
-    pixelPaint.style = FILL
+          val pixelPaint = Paint()
+          pixelPaint.style = FILL
 
-    var recordIndex = 0
-    for (y in 0 until height) {
-      for (x in 0 until width) {
-        val bitmapPosition = y * width + x
-        val heapPosition = (bitmapPosition * bytesPerPixel).toInt()
-        while (heapPosition > recordPositions[recordIndex].second && recordIndex < recordPositions.lastIndex) {
-          recordIndex++
+          var recordIndex = 0
+          for (y in 0 until height) {
+            for (x in 0 until width) {
+              val bitmapPosition = y * width + x
+              val heapPosition = (bitmapPosition * bytesPerPixel).toInt()
+              while (heapPosition > recordPositions[recordIndex].second && recordIndex < recordPositions.lastIndex) {
+                recordIndex++
+              }
+              pixelPaint.color = recordPositions[recordIndex].first
+              canvas.drawPoint(x.toFloat(), y.toFloat(), pixelPaint)
+            }
+          }
+          return bitmap
         }
-        pixelPaint.color = recordPositions[recordIndex].first
-        canvas.drawPoint(x.toFloat(), y.toFloat(), pixelPaint)
-      }
-    }
-    return bitmap
-  }
 
+  }
 }
\ No newline at end of file
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt
index ef8fdb22..edb1dc26 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/HprofExplorerScreen.kt
@@ -10,36 +10,37 @@ import android.widget.ListView
 import android.widget.TextView
 import android.widget.Toast
 import com.squareup.leakcanary.core.R
-import leakcanary.GraphField
-import leakcanary.GraphHeapValue
-import leakcanary.GraphObjectRecord.GraphClassRecord
-import leakcanary.GraphObjectRecord.GraphInstanceRecord
-import leakcanary.GraphObjectRecord.GraphObjectArrayRecord
-import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
-import leakcanary.HeapValue.BooleanValue
-import leakcanary.HeapValue.ByteValue
-import leakcanary.HeapValue.CharValue
-import leakcanary.HeapValue.DoubleValue
-import leakcanary.HeapValue.FloatValue
-import leakcanary.HeapValue.IntValue
-import leakcanary.HeapValue.LongValue
-import leakcanary.HeapValue.ObjectReference
-import leakcanary.HeapValue.ShortValue
-import leakcanary.HprofGraph
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
 import leakcanary.internal.activity.db.Io
 import leakcanary.internal.activity.db.executeOnIo
 import leakcanary.internal.activity.ui.SimpleListAdapter
 import leakcanary.internal.navigation.Screen
 import leakcanary.internal.navigation.activity
 import leakcanary.internal.navigation.inflate
+import shark.HeapClassField
+import shark.HprofHeapGraph
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HeapObject.HeapObjectArray
+import shark.HeapObject.HeapPrimitiveArray
+import shark.HeapValue
+import shark.Hprof
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import shark.ValueHolder.BooleanHolder
+import shark.ValueHolder.ByteHolder
+import shark.ValueHolder.CharHolder
+import shark.ValueHolder.DoubleHolder
+import shark.ValueHolder.FloatHolder
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.ValueHolder.ReferenceHolder
+import shark.ValueHolder.ShortHolder
 import java.io.Closeable
 import java.io.File
 
@@ -64,9 +65,9 @@ internal class HprofExplorerScreen(
       })
 
       executeOnIo {
-        val pair = HprofGraph.readHprof(heapDumpFile)
-        val graph = pair.first
-        closeable = pair.second
+        val hprof = Hprof.open(heapDumpFile)
+        closeable = hprof
+        val graph = HprofHeapGraph.indexHprof(hprof)
         updateUi {
           container.activity.title =
             resources.getString(R.string.leak_canary_options_menu_explore_heap_dump)
@@ -124,7 +125,7 @@ internal class HprofExplorerScreen(
   private fun View.showClass(
     titleView: TextView,
     listView: ListView,
-    selectedClass: GraphClassRecord
+    selectedClass: HeapClass
   ) {
     executeOnIo {
       val className = selectedClass.name
@@ -161,12 +162,12 @@ internal class HprofExplorerScreen(
   private fun View.showInstance(
     titleView: TextView,
     listView: ListView,
-    instance: GraphInstanceRecord
+    instance: HeapInstance
   ) {
     executeOnIo {
       val fields = instance.readFields()
           .fieldsAsString()
-      val className = instance.className
+      val className = instance.instanceClassName
       updateUi {
         titleView.text = "Instance @${instance.objectId} of class $className"
         listView.adapter = SimpleListAdapter(
@@ -187,11 +188,11 @@ internal class HprofExplorerScreen(
   private fun View.showObjectArray(
     titleView: TextView,
     listView: ListView,
-    instance: GraphObjectArrayRecord
+    instance: HeapObjectArray
   ) {
     executeOnIo {
       val elements = instance.readElements()
-          .mapIndexed { index: Int, element: GraphHeapValue ->
+          .mapIndexed { index: Int, element: HeapValue ->
             element to "[$index] = ${element.heapValueAsString()}"
           }
           .toList()
@@ -217,7 +218,7 @@ internal class HprofExplorerScreen(
   private fun View.showPrimitiveArray(
     titleView: TextView,
     listView: ListView,
-    instance: GraphPrimitiveArrayRecord
+    instance: HeapPrimitiveArray
   ) {
     executeOnIo {
       val (type, values) = when (val record = instance.readRecord()) {
@@ -248,65 +249,65 @@ internal class HprofExplorerScreen(
   private fun View.onHeapValueClicked(
     titleView: TextView,
     listView: ListView,
-    graphHeapValue: GraphHeapValue
+    heapValue: HeapValue
   ) {
-    if (graphHeapValue.isNonNullReference) {
-      when (val objectRecord = graphHeapValue.asObject!!) {
-        is GraphInstanceRecord -> {
+    if (heapValue.isNonNullReference) {
+      when (val objectRecord = heapValue.asObject!!) {
+        is HeapInstance -> {
           showInstance(titleView, listView, objectRecord)
         }
-        is GraphClassRecord -> {
+        is HeapClass -> {
           showClass(titleView, listView, objectRecord)
         }
-        is GraphObjectArrayRecord -> {
+        is HeapObjectArray -> {
           showObjectArray(titleView, listView, objectRecord)
         }
-        is GraphPrimitiveArrayRecord -> {
+        is HeapPrimitiveArray -> {
           showPrimitiveArray(titleView, listView, objectRecord)
         }
       }
     }
   }
 
-  private fun Sequence<GraphField>.fieldsAsString(): List<Pair<GraphField, String>> {
+  private fun Sequence<HeapClassField>.fieldsAsString(): List<Pair<HeapClassField, String>> {
     return map { field ->
-      field to "${field.classRecord.simpleName}.${field.name} = ${field.value.heapValueAsString()}"
+      field to "${field.declaringClass.simpleName}.${field.name} = ${field.value.heapValueAsString()}"
     }
         .toList()
   }
 
-  private fun GraphHeapValue.heapValueAsString(): String {
-    return when (val heapValue = actual) {
-      is ObjectReference -> {
+  private fun HeapValue.heapValueAsString(): String {
+    return when (val heapValue = holder) {
+      is ReferenceHolder -> {
         if (isNullReference) {
           "null"
         } else {
           when (val objectRecord = asObject!!) {
-            is GraphInstanceRecord -> {
+            is HeapInstance -> {
               if (objectRecord instanceOf "java.lang.String") {
-                "${objectRecord.className}@${heapValue.value} \"${objectRecord.readAsJavaString()!!}\""
+                "${objectRecord.instanceClassName}@${heapValue.value} \"${objectRecord.readAsJavaString()!!}\""
               } else {
-                "${objectRecord.className}@${heapValue.value}"
+                "${objectRecord.instanceClassName}@${heapValue.value}"
               }
             }
-            is GraphClassRecord -> {
+            is HeapClass -> {
               "Class ${objectRecord.name}"
             }
-            is GraphObjectArrayRecord -> {
+            is HeapObjectArray -> {
               objectRecord.arrayClassName
             }
-            is GraphPrimitiveArrayRecord -> objectRecord.arrayClassName
+            is HeapPrimitiveArray -> objectRecord.arrayClassName
           }
         }
       }
-      is BooleanValue -> "boolean ${heapValue.value}"
-      is CharValue -> "char ${heapValue.value}"
-      is FloatValue -> "float ${heapValue.value}"
-      is DoubleValue -> "double ${heapValue.value}"
-      is ByteValue -> "byte ${heapValue.value}"
-      is ShortValue -> "short ${heapValue.value}"
-      is IntValue -> "int ${heapValue.value}"
-      is LongValue -> "long ${heapValue.value}"
+      is BooleanHolder -> "boolean ${heapValue.value}"
+      is CharHolder -> "char ${heapValue.value}"
+      is FloatHolder -> "float ${heapValue.value}"
+      is DoubleHolder -> "double ${heapValue.value}"
+      is ByteHolder -> "byte ${heapValue.value}"
+      is ShortHolder -> "short ${heapValue.value}"
+      is IntHolder -> "int ${heapValue.value}"
+      is LongHolder -> "long ${heapValue.value}"
     }
 
   }
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt
index dd12dedb..3a1bacac 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/LeakingInstanceScreen.kt
@@ -6,8 +6,6 @@ import android.view.View
 import android.view.ViewGroup
 import android.widget.ListView
 import com.squareup.leakcanary.core.R
-import leakcanary.Leak
-import leakcanary.Leak.LibraryLeak
 import leakcanary.internal.DisplayLeakAdapter
 import leakcanary.internal.activity.db.LeakingInstanceTable
 import leakcanary.internal.activity.db.executeOnDb
@@ -20,6 +18,8 @@ import leakcanary.internal.navigation.activity
 import leakcanary.internal.navigation.goTo
 import leakcanary.internal.navigation.inflate
 import leakcanary.internal.navigation.onCreateOptionsMenu
+import shark.Leak
+import shark.LibraryLeak
 import java.io.Serializable
 
 internal class LeakingInstanceScreen private constructor(
diff --git a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt
index e07fecbb..3ac4c927 100644
--- a/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt
+++ b/leakcanary-android-core/src/main/java/leakcanary/internal/activity/screen/RenderHeapDumpScreen.kt
@@ -12,7 +12,6 @@ import android.view.ViewTreeObserver.OnGlobalLayoutListener
 import android.widget.ImageView
 import android.widget.Toast
 import com.squareup.leakcanary.core.R
-import leakcanary.CanaryLog
 import leakcanary.internal.InternalLeakCanary
 import leakcanary.internal.LeakCanaryFileProvider
 import leakcanary.internal.activity.db.executeOnIo
@@ -20,6 +19,7 @@ import leakcanary.internal.navigation.Screen
 import leakcanary.internal.navigation.activity
 import leakcanary.internal.navigation.inflate
 import leakcanary.internal.navigation.onCreateOptionsMenu
+import shark.SharkLog
 import java.io.File
 import java.io.FileOutputStream
 import java.io.IOException
@@ -91,7 +91,7 @@ internal class RenderHeapDumpScreen(
                   val imageFile = File(storageDir, "${heapDumpFile.name}.png")
                   val saved = savePng(imageFile, bitmap)
                   if (saved) {
-                    CanaryLog.d("Png saved at $imageFile")
+                    SharkLog.d("Png saved at $imageFile")
                     imageFile.setReadable(true, false)
                     val imageUri = LeakCanaryFileProvider.getUriForFile(
                         activity,
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
index f99e738e..404ea845 100644
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/FragmentLeakTest.kt
@@ -25,12 +25,12 @@ class FragmentLeakTest {
   )
 
   @Before fun setUp() {
-    LeakSentry.objectWatcher
+    AppWatcher.objectWatcher
         .clearWatchedObjects()
   }
 
   @After fun tearDown() {
-    LeakSentry.objectWatcher
+    AppWatcher.objectWatcher
         .clearWatchedObjects()
   }
 
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt
index b168ee2a..c74a112f 100644
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/InstrumentationLeakDetectorTest.kt
@@ -13,18 +13,18 @@ import java.util.Date
 class InstrumentationLeakDetectorTest {
 
   @Before fun setUp() {
-    LeakSentry.objectWatcher
+    AppWatcher.objectWatcher
         .clearWatchedObjects()
   }
 
   @After fun tearDown() {
-    LeakSentry.objectWatcher
+    AppWatcher.objectWatcher
         .clearWatchedObjects()
   }
 
   @Test fun detectsLeak() {
     leaking = Date()
-    val refWatcher = LeakSentry.objectWatcher
+    val refWatcher = AppWatcher.objectWatcher
     refWatcher.watch(leaking)
     assertLeak(Date::class.java)
   }
diff --git a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt
index f295e947..96c2b0c6 100644
--- a/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt
+++ b/leakcanary-android-instrumentation/src/androidTest/java/leakcanary/TestUtils.kt
@@ -2,13 +2,13 @@ package leakcanary
 
 import leakcanary.InstrumentationLeakDetector.Result.AnalysisPerformed
 import leakcanary.InstrumentationLeakDetector.Result.NoAnalysis
+import shark.HeapAnalysisSuccess
 
 object TestUtils {
   fun assertLeak(expectedLeakClass: Class<*>) {
     val leakDetector = InstrumentationLeakDetector()
-    val result = leakDetector.detectLeaks()
 
-    val heapAnalysis = when (result) {
+    val heapAnalysis = when (val result = leakDetector.detectLeaks()) {
       is NoAnalysis -> throw AssertionError("Expected analysis to be performed")
       is AnalysisPerformed -> result.heapAnalysis
     }
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt
index b8d14966..9e65515a 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/FailTestOnLeakRunListener.kt
@@ -26,6 +26,10 @@ import org.junit.runner.Description
 import org.junit.runner.Result
 import org.junit.runner.notification.Failure
 import org.junit.runner.notification.RunListener
+import shark.HeapAnalysis
+import shark.HeapAnalysisFailure
+import shark.HeapAnalysisSuccess
+import shark.SharkLog
 
 /**
  *
@@ -81,7 +85,7 @@ open class FailTestOnLeakRunListener : RunListener() {
 
   override fun testFinished(description: Description) {
     detectLeaks()
-    LeakSentry.objectWatcher.clearWatchedObjects()
+    AppWatcher.objectWatcher.clearWatchedObjects()
   }
 
   override fun testRunStarted(description: Description) {
@@ -92,7 +96,7 @@ open class FailTestOnLeakRunListener : RunListener() {
 
   private fun detectLeaks() {
     if (skipLeakDetectionReason != null) {
-      CanaryLog.d("Skipping leak detection because the test %s", skipLeakDetectionReason)
+      SharkLog.d("Skipping leak detection because the test %s", skipLeakDetectionReason)
       skipLeakDetectionReason = null
       return
     }
diff --git a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
index 276ac33f..9f250f32 100644
--- a/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
+++ b/leakcanary-android-instrumentation/src/main/java/leakcanary/InstrumentationLeakDetector.kt
@@ -19,9 +19,16 @@ import android.os.Debug
 import android.os.SystemClock
 import androidx.test.platform.app.InstrumentationRegistry.getInstrumentation
 import leakcanary.GcTrigger.Default.runGc
+import leakcanary.InstrumentationLeakDetector.Companion.updateConfig
 import leakcanary.InstrumentationLeakDetector.Result.AnalysisPerformed
 import leakcanary.InstrumentationLeakDetector.Result.NoAnalysis
 import org.junit.runner.notification.RunListener
+import shark.HeapAnalysis
+import shark.HeapAnalysisException
+import shark.HeapAnalysisFailure
+import shark.HeapAnalyzer
+import shark.ObjectInspectors
+import shark.SharkLog
 import java.io.File
 
 /**
@@ -29,7 +36,7 @@ import java.io.File
  *
  * To use it, you need to:
  *
- *  - Call [updateConfig] so that [LeakSentry] will watch objects and [LeakCanary] will not dump
+ *  - Call [updateConfig] so that [AppWatcher] will watch objects and [LeakCanary] will not dump
  *  the heap on retained objects
  *  - Add an instrumentation test listener (e.g. [FailTestOnLeakRunListener]) that will invoke
  * [detectLeaks].
@@ -90,10 +97,10 @@ class InstrumentationLeakDetector {
    */
   fun detectLeaks(): Result {
     val leakDetectionTime = SystemClock.uptimeMillis()
-    val watchDurationMillis = LeakSentry.config.watchDurationMillis
+    val watchDurationMillis = AppWatcher.config.watchDurationMillis
     val instrumentation = getInstrumentation()
     val context = instrumentation.targetContext
-    val refWatcher = LeakSentry.objectWatcher
+    val refWatcher = AppWatcher.objectWatcher
 
     if (!refWatcher.hasWatchedObjects) {
       return NoAnalysis
@@ -144,7 +151,7 @@ class InstrumentationLeakDetector {
     try {
       Debug.dumpHprofData(heapDumpFile.absolutePath)
     } catch (exception: Exception) {
-      CanaryLog.d(exception, "Could not dump heap")
+      SharkLog.d(exception, "Could not dump heap")
       return AnalysisPerformed(
           HeapAnalysisFailure(
               heapDumpFile, analysisDurationMillis = 0,
@@ -156,7 +163,7 @@ class InstrumentationLeakDetector {
 
     refWatcher.clearObjectsWatchedBefore(heapDumpUptimeMillis)
 
-    val listener = AnalyzerProgressListener.NONE
+    val listener = shark.OnAnalysisProgressListener.NO_OP
 
     val heapAnalyzer = HeapAnalyzer(listener)
     val heapAnalysis = heapAnalyzer.checkForLeaks(
@@ -164,11 +171,11 @@ class InstrumentationLeakDetector {
         config.computeRetainedHeapSize,
         config.objectInspectors,
         if (config.useExperimentalLeakFinders) config.objectInspectors else listOf(
-            AndroidObjectInspectors.KEYED_WEAK_REFERENCE
+            ObjectInspectors.KEYED_WEAK_REFERENCE
         )
     )
 
-    CanaryLog.d("Heap Analysis:\n%s", heapAnalysis)
+    SharkLog.d("Heap Analysis:\n%s", heapAnalysis)
 
     return AnalysisPerformed(heapAnalysis)
   }
@@ -176,13 +183,13 @@ class InstrumentationLeakDetector {
   companion object {
 
     /**
-     * Configures [LeakSentry] to watch objects and [LeakCanary] to not dump the heap on retained
+     * Configures [AppWatcher] to watch objects and [LeakCanary] to not dump the heap on retained
      * objects so that instrumentation tests run smoothly, and we can look for leaks at the end of
      * a test. This is automatically called by [FailTestOnLeakRunListener] when the tests start
      * running.
      */
     fun updateConfig() {
-      LeakSentry.config = LeakSentry.config.copy(enabled = true)
+      AppWatcher.config = AppWatcher.config.copy(enabled = true)
       LeakCanary.config = LeakCanary.config.copy(dumpHeap = false)
     }
   }
diff --git a/leakcanary-android-process/src/main/java/leakcanary/LeakCanaryProcess.kt b/leakcanary-android-process/src/main/java/leakcanary/LeakCanaryProcess.kt
index 45610207..edfd6257 100644
--- a/leakcanary-android-process/src/main/java/leakcanary/LeakCanaryProcess.kt
+++ b/leakcanary-android-process/src/main/java/leakcanary/LeakCanaryProcess.kt
@@ -7,6 +7,7 @@ import android.content.Context
 import android.content.pm.PackageInfo
 import android.content.pm.PackageManager
 import android.content.pm.ServiceInfo
+import shark.SharkLog
 
 /**
  * Used to determine whether the current process is the LeakCanary analyzer process. By depending
@@ -52,7 +53,7 @@ object LeakCanaryProcess {
     try {
       packageInfo = packageManager.getPackageInfo(context.packageName, PackageManager.GET_SERVICES)
     } catch (e: Exception) {
-      CanaryLog.d(e, "Could not get package info for %s", context.packageName)
+      SharkLog.d(e, "Could not get package info for %s", context.packageName)
       return false
     }
 
@@ -69,10 +70,10 @@ object LeakCanaryProcess {
     }
 
     if (serviceInfo.processName == null) {
-      CanaryLog.d("Did not expect service %s to have a null process name", serviceClass)
+      SharkLog.d("Did not expect service %s to have a null process name", serviceClass)
       return false
     } else if (serviceInfo.processName == mainProcess) {
-      CanaryLog.d(
+      SharkLog.d(
           "Did not expect service %s to run in main process %s", serviceClass, mainProcess
       )
       // Technically we are in the service process, but we're not in the service dedicated process.
@@ -87,7 +88,7 @@ object LeakCanaryProcess {
       runningProcesses = activityManager.runningAppProcesses
     } catch (exception: SecurityException) {
       // https://github.com/square/leakcanary/issues/948
-      CanaryLog.d("Could not get running app processes %d", exception)
+      SharkLog.d("Could not get running app processes %d", exception)
       return false
     }
 
@@ -100,7 +101,7 @@ object LeakCanaryProcess {
       }
     }
     if (myProcess == null) {
-      CanaryLog.d("Could not find running process for %d", myPid)
+      SharkLog.d("Could not find running process for %d", myPid)
       return false
     }
 
diff --git a/leakcanary-sample/build.gradle b/leakcanary-android-sample/build.gradle
similarity index 100%
rename from leakcanary-sample/build.gradle
rename to leakcanary-android-sample/build.gradle
diff --git a/leakcanary-leaksentry/src/androidTest/AndroidManifest.xml b/leakcanary-android-sample/src/androidTest/AndroidManifest.xml
similarity index 100%
rename from leakcanary-leaksentry/src/androidTest/AndroidManifest.xml
rename to leakcanary-android-sample/src/androidTest/AndroidManifest.xml
diff --git a/leakcanary-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt b/leakcanary-android-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt
similarity index 100%
rename from leakcanary-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt
rename to leakcanary-android-sample/src/androidTest/java/leakcanary/tests/TuPeuxPasTest.kt
diff --git a/leakcanary-sample/src/main/AndroidManifest.xml b/leakcanary-android-sample/src/main/AndroidManifest.xml
similarity index 100%
rename from leakcanary-sample/src/main/AndroidManifest.xml
rename to leakcanary-android-sample/src/main/AndroidManifest.xml
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt b/leakcanary-android-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt
similarity index 100%
rename from leakcanary-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt
rename to leakcanary-android-sample/src/main/java/com/example/leakcanary/ExampleApplication.kt
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/LeakingSingleton.kt b/leakcanary-android-sample/src/main/java/com/example/leakcanary/LeakingSingleton.kt
similarity index 100%
rename from leakcanary-sample/src/main/java/com/example/leakcanary/LeakingSingleton.kt
rename to leakcanary-android-sample/src/main/java/com/example/leakcanary/LeakingSingleton.kt
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/LeakingThread.kt b/leakcanary-android-sample/src/main/java/com/example/leakcanary/LeakingThread.kt
similarity index 100%
rename from leakcanary-sample/src/main/java/com/example/leakcanary/LeakingThread.kt
rename to leakcanary-android-sample/src/main/java/com/example/leakcanary/LeakingThread.kt
diff --git a/leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.kt b/leakcanary-android-sample/src/main/java/com/example/leakcanary/MainActivity.kt
similarity index 100%
rename from leakcanary-sample/src/main/java/com/example/leakcanary/MainActivity.kt
rename to leakcanary-android-sample/src/main/java/com/example/leakcanary/MainActivity.kt
diff --git a/leakcanary-sample/src/main/res/layout/main_activity.xml b/leakcanary-android-sample/src/main/res/layout/main_activity.xml
similarity index 100%
rename from leakcanary-sample/src/main/res/layout/main_activity.xml
rename to leakcanary-android-sample/src/main/res/layout/main_activity.xml
diff --git a/leakcanary-sample/src/main/res/mipmap-hdpi/ic_launcher.png b/leakcanary-android-sample/src/main/res/mipmap-hdpi/ic_launcher.png
similarity index 100%
rename from leakcanary-sample/src/main/res/mipmap-hdpi/ic_launcher.png
rename to leakcanary-android-sample/src/main/res/mipmap-hdpi/ic_launcher.png
diff --git a/leakcanary-sample/src/main/res/mipmap-mdpi/ic_launcher.png b/leakcanary-android-sample/src/main/res/mipmap-mdpi/ic_launcher.png
similarity index 100%
rename from leakcanary-sample/src/main/res/mipmap-mdpi/ic_launcher.png
rename to leakcanary-android-sample/src/main/res/mipmap-mdpi/ic_launcher.png
diff --git a/leakcanary-sample/src/main/res/mipmap-xhdpi/ic_launcher.png b/leakcanary-android-sample/src/main/res/mipmap-xhdpi/ic_launcher.png
similarity index 100%
rename from leakcanary-sample/src/main/res/mipmap-xhdpi/ic_launcher.png
rename to leakcanary-android-sample/src/main/res/mipmap-xhdpi/ic_launcher.png
diff --git a/leakcanary-sample/src/main/res/mipmap-xxhdpi/ic_launcher.png b/leakcanary-android-sample/src/main/res/mipmap-xxhdpi/ic_launcher.png
similarity index 100%
rename from leakcanary-sample/src/main/res/mipmap-xxhdpi/ic_launcher.png
rename to leakcanary-android-sample/src/main/res/mipmap-xxhdpi/ic_launcher.png
diff --git a/leakcanary-sample/src/main/res/mipmap-xxxhdpi/ic_launcher.png b/leakcanary-android-sample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
similarity index 100%
rename from leakcanary-sample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
rename to leakcanary-android-sample/src/main/res/mipmap-xxxhdpi/ic_launcher.png
diff --git a/leakcanary-sample/src/main/res/values/strings.xml b/leakcanary-android-sample/src/main/res/values/strings.xml
similarity index 100%
rename from leakcanary-sample/src/main/res/values/strings.xml
rename to leakcanary-android-sample/src/main/res/values/strings.xml
diff --git a/leakcanary-cli/gradle.properties b/leakcanary-cli/gradle.properties
deleted file mode 100644
index 0f3d503e..00000000
--- a/leakcanary-cli/gradle.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-POM_ARTIFACT_ID=leakcanary-cli
-POM_NAME=LeakCanary Command Line Interface
-POM_PACKAGING=jar
diff --git a/leakcanary-fragments-androidx/gradle.properties b/leakcanary-fragments-androidx/gradle.properties
deleted file mode 100644
index 54f53098..00000000
--- a/leakcanary-fragments-androidx/gradle.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-POM_ARTIFACT_ID=leakcanary-fragments-androidx
-POM_NAME=LeakCanary Android X fragments support
-POM_PACKAGING=aar
diff --git a/leakcanary-haha/gradle.properties b/leakcanary-haha/gradle.properties
deleted file mode 100644
index b7629a2c..00000000
--- a/leakcanary-haha/gradle.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-POM_ARTIFACT_ID=leakcanary-haha
-POM_NAME=LeakCanary Headless Android Heap Analyzer
-POM_PACKAGING=jar
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphField.kt b/leakcanary-haha/src/main/java/leakcanary/GraphField.kt
deleted file mode 100644
index 882db9f2..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/GraphField.kt
+++ /dev/null
@@ -1,51 +0,0 @@
-package leakcanary
-
-import leakcanary.GraphObjectRecord.GraphClassRecord
-import leakcanary.GraphObjectRecord.GraphInstanceRecord
-import leakcanary.GraphObjectRecord.GraphObjectArrayRecord
-import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
-
-/**
- * Represents a static field or an instance field.
- */
-class GraphField(
-  /**
-   * The class this field was declared in.
-   */
-  val classRecord: GraphClassRecord,
-  /**
-   * Name of the field
-   */
-  val name: String,
-  /**
-   * Value of the field. Also see shorthands [valueAsClass], [valueAsInstance],
-   * [valueAsObjectArray], [valueAsPrimitiveArray].
-   */
-  val value: GraphHeapValue
-) {
-
-  /**
-   * Return a [GraphClassRecord] is [value] references a class, and null otherwise.
-   */
-  val valueAsClass: GraphClassRecord?
-    get() = value.asObject?.asClass
-
-  /**
-   * Return a [GraphInstanceRecord] is [value] references an instance, and null otherwise.
-   */
-  val valueAsInstance: GraphInstanceRecord?
-    get() = value.asObject?.asInstance
-
-  /**
-   * Return a [GraphObjectArrayRecord] is [value] references an object array, and null otherwise.
-   */
-  val valueAsObjectArray: GraphObjectArrayRecord?
-    get() = value.asObject?.asObjectArray
-
-  /**
-   * Return a [GraphPrimitiveArrayRecord] is [value] references a primitive array, and null
-   * otherwise.
-   */
-  val valueAsPrimitiveArray: GraphPrimitiveArrayRecord?
-    get() = value.asObject?.asPrimitiveArray
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt b/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt
deleted file mode 100644
index 6cf1eb15..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/GraphHeapValue.kt
+++ /dev/null
@@ -1,69 +0,0 @@
-package leakcanary
-
-import leakcanary.HeapValue.BooleanValue
-import leakcanary.HeapValue.ByteValue
-import leakcanary.HeapValue.CharValue
-import leakcanary.HeapValue.DoubleValue
-import leakcanary.HeapValue.FloatValue
-import leakcanary.HeapValue.IntValue
-import leakcanary.HeapValue.LongValue
-import leakcanary.HeapValue.ObjectReference
-import leakcanary.HeapValue.ShortValue
-
-/**
- * Represents a value in the heap dump, which can be an object reference or
- * a primitive type. Provides navigation capabilities.
- */
-class GraphHeapValue(
-  private val graph: HprofGraph,
-  val actual: HeapValue
-) {
-  val asBoolean: Boolean?
-    get() = if (actual is BooleanValue) actual.value else null
-
-  val asChar: Char?
-    get() = if (actual is CharValue) actual.value else null
-
-  val asFloat: Float?
-    get() = if (actual is FloatValue) actual.value else null
-
-  val asDouble: Double?
-    get() = if (actual is DoubleValue) actual.value else null
-
-  val asByte: Byte?
-    get() = if (actual is ByteValue) actual.value else null
-
-  val asShort: Short?
-    get() = if (actual is ShortValue) actual.value else null
-
-  val asInt: Int?
-    get() = if (actual is IntValue) actual.value else null
-
-  val asLong: Long?
-    get() = if (actual is LongValue) actual.value else null
-
-  val asObjectId: Long?
-    get() = if (actual is ObjectReference) actual.value else null
-
-  val asNonNullObjectId: Long?
-    get() = if (actual is ObjectReference && !actual.isNull) actual.value else null
-
-  val isNullReference: Boolean
-    get() = actual is ObjectReference && actual.isNull
-
-  val isNonNullReference: Boolean
-    get() = actual is ObjectReference && !actual.isNull
-
-  val asObject: GraphObjectRecord?
-    get() {
-      return if (actual is ObjectReference && !actual.isNull) {
-        return graph.findObjectByObjectId(actual.value)
-      } else {
-        null
-      }
-    }
-
-  fun readAsJavaString(): String? {
-    return asObject?.asInstance?.readAsJavaString()
-  }
-}
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt b/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt
deleted file mode 100644
index 43a7c540..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/GraphObjectRecord.kt
+++ /dev/null
@@ -1,332 +0,0 @@
-package leakcanary
-
-import leakcanary.HeapValue.ObjectReference
-import leakcanary.PrimitiveType.BOOLEAN
-import leakcanary.PrimitiveType.BYTE
-import leakcanary.PrimitiveType.CHAR
-import leakcanary.PrimitiveType.DOUBLE
-import leakcanary.PrimitiveType.FLOAT
-import leakcanary.PrimitiveType.INT
-import leakcanary.PrimitiveType.LONG
-import leakcanary.PrimitiveType.SHORT
-import leakcanary.Record.HeapDumpRecord.ObjectRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
-import leakcanary.internal.IndexedObject.IndexedClass
-import leakcanary.internal.IndexedObject.IndexedInstance
-import leakcanary.internal.IndexedObject.IndexedObjectArray
-import leakcanary.internal.IndexedObject.IndexedPrimitiveArray
-import java.nio.charset.Charset
-import kotlin.reflect.KClass
-
-/**
- * Represents an object in the heap dump and provides navigation capabilities.
- */
-sealed class GraphObjectRecord {
-
-  abstract val graph: HprofGraph
-
-  abstract val objectId: Long
-
-  abstract fun readRecord(): ObjectRecord
-
-  val asClass: GraphClassRecord?
-    get() = if (this is GraphClassRecord) this else null
-
-  val asInstance: GraphInstanceRecord?
-    get() = if (this is GraphInstanceRecord) this else null
-
-  val asObjectArray: GraphObjectArrayRecord?
-    get() = if (this is GraphObjectArrayRecord) this else null
-
-  val asPrimitiveArray: GraphPrimitiveArrayRecord?
-    get() = if (this is GraphPrimitiveArrayRecord) this else null
-
-  /**
-   * Represents a class in the heap dump and provides navigation capabilities.
-   */
-  class GraphClassRecord internal constructor(
-    override val graph: HprofGraph,
-    private val indexedObject: IndexedClass,
-    override val objectId: Long
-  ) : GraphObjectRecord() {
-
-    override fun readRecord(): ClassDumpRecord {
-      return graph.readClassDumpRecord(objectId, indexedObject)
-    }
-
-    val name: String
-      get() = graph.className(objectId)
-
-    val simpleName: String
-      get() {
-        val className = this.name
-        val separator = className.lastIndexOf('.')
-        return if (separator == -1) {
-          className
-        } else {
-          className.substring(separator + 1)
-        }
-      }
-
-    val instanceSize: Int
-      get() = indexedObject.instanceSize
-
-    val superClass: GraphClassRecord?
-      get() {
-        if (indexedObject.superClassId == HeapValue.NULL_REFERENCE) return null
-        return graph.findObjectByObjectId(indexedObject.superClassId) as GraphClassRecord
-      }
-
-    val classHierarchy: Sequence<GraphClassRecord>
-      get() = generateSequence(this) { it.superClass }
-
-    val directInstances: Sequence<GraphInstanceRecord>
-      get() = graph.instances.filter { it.indexedObject.classId == objectId }
-
-    fun readStaticFields(): Sequence<GraphField> {
-      return readRecord().staticFields.asSequence()
-          .map { fieldRecord ->
-            GraphField(
-                this, graph.staticFieldName(fieldRecord), GraphHeapValue(graph, fieldRecord.value)
-            )
-          }
-    }
-
-    operator fun get(fieldName: String): GraphField? {
-      for (fieldRecord in readRecord().staticFields) {
-        if (graph.staticFieldName(fieldRecord) == fieldName) {
-          return GraphField(
-              this, graph.staticFieldName(fieldRecord), GraphHeapValue(graph, fieldRecord.value)
-          )
-        }
-      }
-      return null
-    }
-
-    override fun toString(): String {
-      return "record of class $name"
-    }
-  }
-
-  /**
-   * Represents an instance in the heap dump and provides navigation capabilities.
-   */
-  class GraphInstanceRecord internal constructor(
-    override val graph: HprofGraph,
-    internal val indexedObject: IndexedInstance,
-    override val objectId: Long,
-    val isPrimitiveWrapper: Boolean
-  ) : GraphObjectRecord() {
-
-    val size
-      get() = instanceClass.instanceSize
-
-    override fun readRecord(): InstanceDumpRecord {
-      return graph.readInstanceDumpRecord(objectId, indexedObject)
-    }
-
-    infix fun instanceOf(className: String): Boolean {
-      var currentClassId = indexedObject.classId
-      while (currentClassId != HeapValue.NULL_REFERENCE) {
-        if (graph.className(currentClassId) == className) {
-          return true
-        }
-
-        val currentClassRecord = graph.readObjectRecord(currentClassId) as ClassDumpRecord
-        currentClassId = currentClassRecord.superClassId
-      }
-      return false
-    }
-
-    infix fun instanceOf(expectedClass: KClass<*>) =
-      this instanceOf expectedClass.java.name
-
-    operator fun get(
-      declaringClass: KClass<out Any>,
-      fieldName: String
-    ): GraphField? {
-      return get(declaringClass.java.name, fieldName)
-    }
-
-    operator fun get(
-      declaringClassName: String,
-      fieldName: String
-    ): GraphField? {
-      return readFields().firstOrNull { field -> field.classRecord.name == declaringClassName && field.name == fieldName }
-    }
-
-    val className: String
-      get() = graph.className(indexedObject.classId)
-
-    val classSimpleName: String
-      get() {
-        val className = this.className
-        val separator = className.lastIndexOf('.')
-        return if (separator == -1) {
-          className
-        } else {
-          className.substring(separator + 1)
-        }
-      }
-
-    val instanceClass: GraphClassRecord
-      get() {
-        return graph.findObjectByObjectId(indexedObject.classId) as GraphClassRecord
-      }
-
-    fun readFields(): Sequence<GraphField> {
-      val fieldReader by lazy {
-        graph.createFieldValuesReader(readRecord())
-      }
-      return instanceClass.classHierarchy
-          .map { classRecord ->
-            classRecord.readRecord()
-                .fields.asSequence()
-                .map { fieldRecord ->
-                  val fieldName = graph.fieldName(fieldRecord)
-                  val fieldValue = fieldReader.readValue(fieldRecord)
-                  GraphField(classRecord, fieldName, GraphHeapValue(graph, fieldValue))
-                }
-          }
-          .flatten()
-    }
-
-    fun readAsJavaString(): String? {
-      if (className != "java.lang.String") {
-        return null
-      }
-
-      // JVM strings don't have a count field.
-      val count = this["java.lang.String", "count"]?.value?.asInt
-      if (count == 0) {
-        return ""
-      }
-
-      // Prior to API 26 String.value was a char array.
-      // Since API 26 String.value is backed by native code. The vast majority of strings in a
-      // heap dump are backed by a byte array, but we still find a few backed by a char array.
-      when (val valueRecord =
-        this["java.lang.String", "value"]!!.value.asObject!!.readRecord()) {
-        is CharArrayDump -> {
-          // < API 23
-          // As of Marshmallow, substrings no longer share their parent strings' char arrays
-          // eliminating the need for String.offset
-          // https://android-review.googlesource.com/#/c/83611/
-          val offset = this["java.lang.String", "offset"]?.value?.asInt
-
-          val chars = if (count != null && offset != null) {
-            // Handle heap dumps where all primitive arrays have been replaced with empty arrays,
-            // e.g. with HprofPrimitiveArrayStripper
-            val toIndex = if (offset + count > valueRecord.array.size) {
-              valueRecord.array.size
-            } else offset + count
-            valueRecord.array.copyOfRange(offset, toIndex)
-          } else {
-            valueRecord.array
-          }
-          return String(chars)
-        }
-        is ByteArrayDump -> {
-          return String(valueRecord.array, Charset.forName("UTF-8"))
-        }
-        else -> throw UnsupportedOperationException(
-            "'value' field ${this["java.lang.String", "value"]!!.value} was expected to be either" +
-                " a char or byte array in string instance with id $objectId"
-        )
-      }
-    }
-
-    override fun toString(): String {
-      return "instance @$objectId of $className"
-    }
-  }
-
-  /**
-   * Represents an object array in the heap dump and provides navigation capabilities.
-   */
-  class GraphObjectArrayRecord internal constructor(
-    override val graph: HprofGraph,
-    private val indexedObject: IndexedObjectArray,
-    override val objectId: Long,
-    val isPrimitiveWrapperArray: Boolean
-  ) : GraphObjectRecord() {
-
-    val arrayClassName: String
-      get() = graph.className(indexedObject.arrayClassId)
-
-    fun readSize(): Int {
-      return readRecord().elementIds.size * graph.idSize
-    }
-
-    override fun readRecord(): ObjectArrayDumpRecord {
-      return graph.readObjectArrayDumpRecord(objectId, indexedObject)
-    }
-
-    fun readElements(): Sequence<GraphHeapValue> {
-      return readRecord().elementIds.asSequence()
-          .map { GraphHeapValue(graph, ObjectReference(it)) }
-    }
-
-    override fun toString(): String {
-      return "object array @$objectId of $arrayClassName"
-    }
-  }
-
-  /**
-   * Represents a primitive array in the heap dump and provides navigation capabilities.
-   */
-  class GraphPrimitiveArrayRecord internal constructor(
-    override val graph: HprofGraph,
-    private val indexedObject: IndexedPrimitiveArray,
-    override val objectId: Long
-  ) : GraphObjectRecord() {
-
-    fun readSize(): Int {
-      return when (val record = readRecord()) {
-        is BooleanArrayDump -> record.array.size * HprofReader.BOOLEAN_SIZE
-        is CharArrayDump -> record.array.size * HprofReader.CHAR_SIZE
-        is FloatArrayDump -> record.array.size * HprofReader.FLOAT_SIZE
-        is DoubleArrayDump -> record.array.size * HprofReader.DOUBLE_SIZE
-        is ByteArrayDump -> record.array.size * HprofReader.BYTE_SIZE
-        is ShortArrayDump -> record.array.size * HprofReader.SHORT_SIZE
-        is IntArrayDump -> record.array.size * HprofReader.INT_SIZE
-        is LongArrayDump -> record.array.size * HprofReader.LONG_SIZE
-      }
-    }
-
-    val primitiveType: PrimitiveType
-      get() = indexedObject.primitiveType
-
-    val arrayClassName: String
-      get() = when (primitiveType) {
-        BOOLEAN -> "boolean[]"
-        CHAR -> "char[]"
-        FLOAT -> "float[]"
-        DOUBLE -> "double[]"
-        BYTE -> "byte[]"
-        SHORT -> "short[]"
-        INT -> "int[]"
-        LONG -> "long[]"
-      }
-
-    override fun readRecord(): PrimitiveArrayDumpRecord {
-      return graph.readPrimitiveArrayDumpRecord(objectId, indexedObject)
-    }
-
-    override fun toString(): String {
-      return "primitive array @$objectId of $arrayClassName"
-    }
-  }
-
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HeapValue.kt b/leakcanary-haha/src/main/java/leakcanary/HeapValue.kt
deleted file mode 100644
index bf7208dd..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/HeapValue.kt
+++ /dev/null
@@ -1,27 +0,0 @@
-package leakcanary
-
-import leakcanary.HeapValue.ObjectReference
-
-/**
- * A value in the heap dump, which can be an [ObjectReference] or
- * a primitive type.
- */
-sealed class HeapValue {
-  data class ObjectReference(val value: Long) : HeapValue() {
-    val isNull
-      get() = value == NULL_REFERENCE
-  }
-
-  data class BooleanValue(val value: Boolean) : HeapValue()
-  data class CharValue(val value: Char) : HeapValue()
-  data class FloatValue(val value: Float) : HeapValue()
-  data class DoubleValue(val value: Double) : HeapValue()
-  data class ByteValue(val value: Byte) : HeapValue()
-  data class ShortValue(val value: Short) : HeapValue()
-  data class IntValue(val value: Int) : HeapValue()
-  data class LongValue(val value: Long) : HeapValue()
-
-  companion object {
-    const val NULL_REFERENCE = 0L
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt b/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
deleted file mode 100644
index fd8fe4f5..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/HprofGraph.kt
+++ /dev/null
@@ -1,261 +0,0 @@
-package leakcanary
-
-import leakcanary.GraphObjectRecord.GraphClassRecord
-import leakcanary.GraphObjectRecord.GraphInstanceRecord
-import leakcanary.GraphObjectRecord.GraphObjectArrayRecord
-import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
-import leakcanary.HprofPushRecordsParser.OnRecordListener
-import leakcanary.Record.HeapDumpRecord.ObjectRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
-import leakcanary.internal.FieldValuesReader
-import leakcanary.internal.HprofInMemoryIndex
-import leakcanary.internal.IndexedObject
-import leakcanary.internal.IndexedObject.IndexedClass
-import leakcanary.internal.IndexedObject.IndexedInstance
-import leakcanary.internal.IndexedObject.IndexedObjectArray
-import leakcanary.internal.IndexedObject.IndexedPrimitiveArray
-import leakcanary.internal.LruCache
-import okio.Buffer
-import java.io.Closeable
-import java.io.File
-
-/**
- * Enables navigation through the Hprof graph of objects.
- */
-class HprofGraph internal constructor(
-  private val reader: SeekableHprofReader,
-  private val index: HprofInMemoryIndex
-) {
-
-  /**
-   * In memory store that can be used to store objects this [HprofGraph] instance.
-   */
-  val context = GraphContext()
-
-  /**
-   * All GC roots which type matches the set passed to [HprofInMemoryIndex.createOnRecordListener].
-   */
-  val gcRoots: List<GcRoot>
-    get() = index.gcRoots()
-
-  /**
-   * Sequence of all objects in the heap dump.
-   *
-   * This sequence does not trigger any IO reads.
-   */
-  val objects: Sequence<GraphObjectRecord>
-    get() {
-      return index.indexedObjectSequence()
-          .map {
-            wrapIndexedObject(it.second, it.first)
-          }
-    }
-
-  /**
-   * Sequence of all classes in the heap dump.
-   *
-   * This sequence does not trigger any IO reads.
-   */
-  val classes: Sequence<GraphClassRecord>
-    get() {
-      return index.indexedClassSequence()
-          .map {
-            val objectId = it.first
-            val indexedObject = it.second
-            GraphClassRecord(this, indexedObject, objectId)
-          }
-    }
-
-  /**
-   * Sequence of all instances in the heap dump.
-   *
-   * This sequence does not trigger any IO reads.
-   */
-  val instances: Sequence<GraphInstanceRecord>
-    get() {
-      return index.indexedInstanceSequence()
-          .map {
-            val objectId = it.first
-            val indexedObject = it.second
-            val isPrimitiveWrapper = index.primitiveWrapperTypes.contains(indexedObject.classId)
-            GraphInstanceRecord(this, indexedObject, objectId, isPrimitiveWrapper)
-          }
-    }
-
-  internal val idSize
-    get() = index.idSize
-
-  // LRU cache size of 3000 is a sweet spot to balance hits vs memory usage.
-  // This is based on running InstrumentationLeakDetectorTest a bunch of time on a
-  // Pixel 2 XL API 28. Hit count was ~120K, miss count ~290K
-  private val objectCache = LruCache<Long, ObjectRecord>(3000)
-
-  /**
-   * Returns the [GraphObjectRecord] corresponding to the provided [objectId], and throws
-   * [IllegalArgumentException] otherwise.
-   */
-  fun findObjectByObjectId(objectId: Long): GraphObjectRecord {
-    return wrapIndexedObject(index.indexedObject(objectId), objectId)
-  }
-
-  /**
-   * Returns the [GraphClassRecord] corresponding to the provided [className], or null if the
-   * class cannot be found.
-   */
-  fun findClassByClassName(className: String): GraphClassRecord? {
-    val classId = index.classId(className)
-    return if (classId == null) {
-      null
-    } else {
-      return findObjectByObjectId(classId) as GraphClassRecord
-    }
-  }
-
-  /**
-   * Returns true if the provided [objectId] exists in the heap dump.
-   */
-  fun objectExists(objectId: Long): Boolean {
-    return index.objectIdIsIndexed(objectId)
-  }
-
-  /**
-   * Returns the byte size of the provided [hprofType].
-   *
-   * Note: this API may be removed eventually.
-   */
-  fun sizeOfFieldType(hprofType: Int) = index.sizeOfFieldType(hprofType)
-
-  internal fun fieldName(fieldRecord: FieldRecord): String {
-    return index.hprofStringById(fieldRecord.nameStringId)
-  }
-
-  internal fun staticFieldName(fieldRecord: StaticFieldRecord): String {
-    return index.hprofStringById(fieldRecord.nameStringId)
-  }
-
-  internal fun createFieldValuesReader(record: InstanceDumpRecord): FieldValuesReader {
-    val buffer = Buffer()
-    buffer.write(record.fieldValues)
-
-    val reader = HprofReader(buffer, 0, index.idSize)
-
-    return object : FieldValuesReader {
-      override fun readValue(field: FieldRecord): HeapValue {
-        return reader.readValue(field.type)
-      }
-    }
-  }
-
-  internal fun readObjectRecord(objectId: Long): ObjectRecord {
-    return when (val indexedObject = index.indexedObject(objectId)) {
-      is IndexedInstance -> readInstanceDumpRecord(objectId, indexedObject)
-      is IndexedClass -> readClassDumpRecord(objectId, indexedObject)
-      is IndexedObjectArray -> readObjectArrayDumpRecord(objectId, indexedObject)
-      is IndexedPrimitiveArray -> readPrimitiveArrayDumpRecord(objectId, indexedObject)
-    }
-  }
-
-  internal fun className(classId: Long): String {
-    return index.className(classId)
-  }
-
-  internal fun readObjectArrayDumpRecord(
-    objectId: Long,
-    indexedObject: IndexedObjectArray
-  ): ObjectArrayDumpRecord {
-    return readObjectRecord(objectId, indexedObject) {
-      reader.readObjectArrayDumpRecord()
-    }
-  }
-
-  internal fun readPrimitiveArrayDumpRecord(
-    objectId: Long,
-    indexedObject: IndexedPrimitiveArray
-  ): PrimitiveArrayDumpRecord {
-    return readObjectRecord(objectId, indexedObject) {
-      reader.readPrimitiveArrayDumpRecord()
-    }
-  }
-
-  internal fun readClassDumpRecord(
-    objectId: Long,
-    indexedObject: IndexedClass
-  ): ClassDumpRecord {
-    return readObjectRecord(objectId, indexedObject) {
-      reader.readClassDumpRecord()
-    }
-  }
-
-  internal fun readInstanceDumpRecord(
-    objectId: Long,
-    indexedObject: IndexedInstance
-  ): InstanceDumpRecord {
-    return readObjectRecord(objectId, indexedObject) {
-      reader.readInstanceDumpRecord()
-    }
-  }
-
-  private fun <T : ObjectRecord> readObjectRecord(
-    objectId: Long,
-    indexedObject: IndexedObject,
-    readBlock: () -> T
-  ): T {
-    val objectRecordOrNull = objectCache[objectId]
-    @Suppress("UNCHECKED_CAST")
-    if (objectRecordOrNull != null) {
-      return objectRecordOrNull as T
-    }
-    reader.moveTo(indexedObject.position)
-    return readBlock().apply { objectCache.put(objectId, this) }
-  }
-
-  private fun wrapIndexedObject(
-    indexedObject: IndexedObject,
-    objectId: Long
-  ): GraphObjectRecord {
-    return when (indexedObject) {
-      is IndexedClass -> GraphClassRecord(this, indexedObject, objectId)
-      is IndexedInstance -> {
-        val isPrimitiveWrapper = index.primitiveWrapperTypes.contains(indexedObject.classId)
-        GraphInstanceRecord(this, indexedObject, objectId, isPrimitiveWrapper)
-      }
-      is IndexedObjectArray -> {
-        val isPrimitiveWrapperArray =
-          index.primitiveWrapperTypes.contains(indexedObject.arrayClassId)
-        GraphObjectArrayRecord(this, indexedObject, objectId, isPrimitiveWrapperArray)
-      }
-      is IndexedPrimitiveArray -> GraphPrimitiveArrayRecord(this, indexedObject, objectId)
-    }
-  }
-
-  companion object {
-    fun readHprof(
-      heapDump: File,
-      vararg onRecordListeners: OnRecordListener
-    ): Pair<HprofGraph, Closeable> {
-      val indexListener = HprofInMemoryIndex.createOnRecordListener()
-
-      val parser = HprofPushRecordsParser()
-
-      val reader = parser.readHprofRecords(heapDump, setOf(indexListener) + onRecordListeners)
-
-      val hprofGraph = HprofGraph(reader, indexListener.buildIndex())
-
-      return hprofGraph to reader
-    }
-  }
-
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofPrimitiveArrayStripper.kt b/leakcanary-haha/src/main/java/leakcanary/HprofPrimitiveArrayStripper.kt
deleted file mode 100644
index 2dd8758f..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/HprofPrimitiveArrayStripper.kt
+++ /dev/null
@@ -1,88 +0,0 @@
-package leakcanary
-
-import leakcanary.HprofPushRecordsParser.OnRecordListener
-import leakcanary.Record.HeapDumpEndRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
-import java.io.File
-import kotlin.reflect.KClass
-
-/**
- * Transforms a Hprof to all primitive arrays, which can be useful to remove PII.
- */
-class HprofPrimitiveArrayStripper {
-
-  fun stripPrimitiveArrays(
-    inputHprofFile: File,
-    outputHprofFile: File = File(
-        inputHprofFile.parent, inputHprofFile.name.replace(
-        ".hprof", "-stripped.hprof"
-    ).let { if (it != inputHprofFile.name) it else inputHprofFile.name + "-stripped" })
-  ): File {
-    val parser = HprofPushRecordsParser()
-
-    lateinit var writer: HprofWriter
-
-    parser.readHprofRecords(inputHprofFile, setOf(object : OnRecordListener {
-
-      override fun recordTypes(): Set<KClass<out Record>> = setOf(Record::class)
-
-      override fun onTypeSizesAvailable(typeSizes: Map<Int, Int>) {
-        writer =
-          HprofWriter.open(outputHprofFile, idSize = typeSizes.getValue(HprofReader.OBJECT_TYPE))
-      }
-
-      override fun onRecord(
-        position: Long,
-        record: Record
-      ) {
-
-        // HprofWriter automatically emits HeapDumpEndRecord, because it flushes
-        // all continuous heap dump sub records as one heap dump record.
-        if (record is HeapDumpEndRecord) {
-          return
-        }
-        writer.write(
-            when (record) {
-              is BooleanArrayDump -> BooleanArrayDump(
-                  record.id, record.stackTraceSerialNumber, booleanArrayOf()
-              )
-              is CharArrayDump -> CharArrayDump(
-                  record.id, record.stackTraceSerialNumber, charArrayOf()
-              )
-              is FloatArrayDump -> FloatArrayDump(
-                  record.id, record.stackTraceSerialNumber, floatArrayOf()
-              )
-              is DoubleArrayDump -> DoubleArrayDump(
-                  record.id, record.stackTraceSerialNumber, doubleArrayOf()
-              )
-              is ByteArrayDump -> ByteArrayDump(
-                  record.id, record.stackTraceSerialNumber, byteArrayOf()
-              )
-              is ShortArrayDump -> ShortArrayDump(
-                  record.id, record.stackTraceSerialNumber, shortArrayOf()
-              )
-              is IntArrayDump -> IntArrayDump(
-                  record.id, record.stackTraceSerialNumber, intArrayOf()
-              )
-              is LongArrayDump -> LongArrayDump(
-                  record.id, record.stackTraceSerialNumber, longArrayOf()
-              )
-              else -> {
-                record
-              }
-            }
-        )
-      }
-    })).close()
-    writer.close()
-    return outputHprofFile
-  }
-
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofPushRecordsParser.kt b/leakcanary-haha/src/main/java/leakcanary/HprofPushRecordsParser.kt
deleted file mode 100644
index c6e1403a..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/HprofPushRecordsParser.kt
+++ /dev/null
@@ -1,673 +0,0 @@
-package leakcanary
-
-import leakcanary.GcRoot.Debugger
-import leakcanary.GcRoot.Finalizing
-import leakcanary.GcRoot.InternedString
-import leakcanary.GcRoot.JavaFrame
-import leakcanary.GcRoot.JniGlobal
-import leakcanary.GcRoot.JniLocal
-import leakcanary.GcRoot.JniMonitor
-import leakcanary.GcRoot.MonitorUsed
-import leakcanary.GcRoot.NativeStack
-import leakcanary.GcRoot.ReferenceCleanup
-import leakcanary.GcRoot.StickyClass
-import leakcanary.GcRoot.ThreadBlock
-import leakcanary.GcRoot.ThreadObject
-import leakcanary.GcRoot.Unknown
-import leakcanary.GcRoot.Unreachable
-import leakcanary.GcRoot.VmInternal
-import leakcanary.HprofReader.Companion.INT_SIZE
-import leakcanary.HprofReader.Companion.LONG_SIZE
-import leakcanary.Record.HeapDumpEndRecord
-import leakcanary.Record.HeapDumpRecord
-import leakcanary.Record.HeapDumpRecord.GcRootRecord
-import leakcanary.Record.HeapDumpRecord.HeapDumpInfoRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
-import leakcanary.Record.LoadClassRecord
-import leakcanary.Record.StackFrameRecord
-import leakcanary.Record.StackTraceRecord
-import leakcanary.Record.StringRecord
-import okio.buffer
-import okio.source
-import java.io.File
-import kotlin.reflect.KClass
-
-/**
- * A streaming push heap dump parser.
- *
- * Expected usage: call [readHprofRecords] once, which will go read through the entire heap dump
- * and notify the provided listeners of records found.
- *
- * This class is not thread safe, should be used from a single thread.
- *
- * Binary Dump Format reference: http://hg.openjdk.java.net/jdk6/jdk6/jdk/raw-file/tip/src/share/demo/jvmti/hprof/manual.html#mozTocId848088
- *
- * The Android Hprof format differs in some ways from that reference. This parser implementation
- * is largely adapted from https://android.googlesource.com/platform/tools/base/+/studio-master-dev/perflib/src/main/java/com/android/tools/perflib
- */
-class HprofPushRecordsParser {
-
-  interface OnRecordListener {
-    fun recordTypes(): Set<KClass<out Record>>
-
-    fun onTypeSizesAvailable(typeSizes: Map<Int, Int>)
-
-    fun onRecord(
-      position: Long,
-      record: Record
-    )
-  }
-
-  fun readHprofRecords(
-    heapDump: File,
-    listeners: Set<OnRecordListener>
-  ): SeekableHprofReader {
-    if (heapDump.length() == 0L) {
-      throw IllegalArgumentException("Heap dump file is 0 byte length")
-    }
-    val inputStream = heapDump.inputStream()
-    val channel = inputStream.channel
-    val source = inputStream.source()
-        .buffer()
-
-    val endOfVersionString = source.indexOf(0)
-    val version = source.readUtf8(endOfVersionString)
-    require(version in supportedVersions) {
-      "Unsupported Hprof version [$version] not in supported list $supportedVersions"
-    }
-    // Skip the 0 at the end of the version string.
-    source.skip(1)
-    val idSize = source.readInt()
-    val startPosition = endOfVersionString + 1 + 4
-
-    val reader = SeekableHprofReader(channel, source, startPosition, idSize)
-
-    listeners.forEach { it.onTypeSizesAvailable(reader.typeSizes) }
-
-    reader.readHprofRecords(listeners)
-    return reader
-  }
-
-  private fun SeekableHprofReader.readHprofRecords(listeners: Set<OnRecordListener>) {
-
-    val readStringRecord = mutableSetOf<OnRecordListener>()
-    val readLoadClassRecord = mutableSetOf<OnRecordListener>()
-    val readStackFrameRecord = mutableSetOf<OnRecordListener>()
-    val readStackTraceRecord = mutableSetOf<OnRecordListener>()
-    val readGcRootRecord = mutableSetOf<OnRecordListener>()
-    val readClassDumpRecord = mutableSetOf<OnRecordListener>()
-    val readInstanceDumpRecord = mutableSetOf<OnRecordListener>()
-    val readObjectArrayDumpRecord = mutableSetOf<OnRecordListener>()
-    val readPrimitiveArrayDumpRecord = mutableSetOf<OnRecordListener>()
-    val readHeapDumpInfoRecord = mutableSetOf<OnRecordListener>()
-    val readHeapDumpEnd = mutableSetOf<OnRecordListener>()
-
-    for (listener in listeners) {
-      val config = listener.recordTypes()
-      config.forEach { recordClass ->
-        when (recordClass) {
-          Record::class -> {
-            readStringRecord += listener
-            readLoadClassRecord += listener
-            readStackFrameRecord += listener
-            readStackTraceRecord += listener
-            readGcRootRecord += listener
-            readClassDumpRecord += listener
-            readInstanceDumpRecord += listener
-            readObjectArrayDumpRecord += listener
-            readPrimitiveArrayDumpRecord += listener
-            readHeapDumpInfoRecord += listener
-            readHeapDumpEnd += listener
-          }
-          StringRecord::class -> {
-            readStringRecord += listener
-          }
-          LoadClassRecord::class -> {
-            readLoadClassRecord += listener
-          }
-          HeapDumpEndRecord::class -> {
-            readHeapDumpEnd += listener
-          }
-          StackFrameRecord::class -> {
-            readStackFrameRecord += listener
-          }
-          StackTraceRecord::class -> {
-            readStackTraceRecord += listener
-          }
-          HeapDumpRecord::class -> {
-            readGcRootRecord += listener
-            readClassDumpRecord += listener
-            readInstanceDumpRecord += listener
-            readObjectArrayDumpRecord += listener
-            readPrimitiveArrayDumpRecord += listener
-            readHeapDumpInfoRecord += listener
-          }
-          GcRootRecord::class -> {
-            readGcRootRecord += listener
-          }
-          ObjectRecord::class -> {
-            readClassDumpRecord += listener
-            readInstanceDumpRecord += listener
-            readObjectArrayDumpRecord += listener
-            readPrimitiveArrayDumpRecord += listener
-          }
-          ClassDumpRecord::class -> {
-            readClassDumpRecord += listener
-          }
-          InstanceDumpRecord::class -> {
-            readInstanceDumpRecord += listener
-          }
-          ObjectArrayDumpRecord::class -> {
-            readObjectArrayDumpRecord += listener
-          }
-          PrimitiveArrayDumpRecord::class -> {
-            readPrimitiveArrayDumpRecord += listener
-          }
-          HeapDumpInfoRecord::class -> {
-            readHeapDumpInfoRecord += listener
-          }
-        }
-      }
-    }
-
-    // heap dump timestamp
-    skip(LONG_SIZE)
-
-    while (!exhausted()) {
-      // type of the record
-      val tag = readUnsignedByte()
-
-      // number of microseconds since the time stamp in the header
-      skip(INT_SIZE)
-
-      // number of bytes that follow and belong to this record
-      val length = readUnsignedInt()
-
-      when (tag) {
-        STRING_IN_UTF8 -> {
-          if (readStringRecord.isNotEmpty()) {
-            val recordPosition = position
-            val id = readId()
-            val stringLength = length - idSize
-            val string = readUtf8(stringLength)
-            val record = StringRecord(id, string)
-            readStringRecord.forEach { it.onRecord(recordPosition, record) }
-          } else {
-            skip(length)
-          }
-        }
-        LOAD_CLASS -> {
-          if (readLoadClassRecord.isNotEmpty()) {
-            val recordPosition = position
-            val classSerialNumber = readInt()
-            val id = readId()
-            val stackTraceSerialNumber = readInt()
-            val classNameStringId = readId()
-            val record = LoadClassRecord(
-                classSerialNumber = classSerialNumber,
-                id = id,
-                stackTraceSerialNumber = stackTraceSerialNumber,
-                classNameStringId = classNameStringId
-            )
-            readLoadClassRecord.forEach {
-              it.onRecord(recordPosition, record)
-            }
-          } else {
-            skip(length)
-          }
-        }
-        STACK_FRAME -> {
-          if (readStackFrameRecord.isNotEmpty()) {
-            val recordPosition = position
-            val record = StackFrameRecord(
-                id = readId(),
-                methodNameStringId = readId(),
-                methodSignatureStringId = readId(),
-                sourceFileNameStringId = readId(),
-                classSerialNumber = readInt(),
-                lineNumber = readInt()
-            )
-            readStackFrameRecord.forEach {
-              it.onRecord(recordPosition, record)
-            }
-          } else {
-            skip(length)
-          }
-        }
-        STACK_TRACE -> {
-          if (readStackTraceRecord.isNotEmpty()) {
-            val recordPosition = position
-            val stackTraceSerialNumber = readInt()
-            val threadSerialNumber = readInt()
-            val frameCount = readInt()
-            val stackFrameIds = readIdArray(frameCount)
-            val record = StackTraceRecord(
-                stackTraceSerialNumber = stackTraceSerialNumber,
-                threadSerialNumber = threadSerialNumber,
-                stackFrameIds = stackFrameIds
-            )
-            readStackTraceRecord.forEach {
-              it.onRecord(recordPosition, record)
-            }
-          } else {
-            skip(length)
-          }
-        }
-        HEAP_DUMP, HEAP_DUMP_SEGMENT -> {
-          val heapDumpStart = position
-          var previousTag = 0
-          while (position - heapDumpStart < length) {
-            val heapDumpTag = readUnsignedByte()
-
-            when (heapDumpTag) {
-              ROOT_UNKNOWN -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val record = GcRootRecord(gcRoot = Unknown(id = readId()))
-                  readGcRootRecord.forEach { it.onRecord(recordPosition, record) }
-                } else {
-                  skip(idSize)
-                }
-              }
-              ROOT_JNI_GLOBAL -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord =
-                    GcRootRecord(gcRoot = JniGlobal(id = readId(), jniGlobalRefId = readId()))
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize + idSize)
-                }
-              }
-
-              ROOT_JNI_LOCAL -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(
-                      gcRoot = JniLocal(
-                          id = readId(), threadSerialNumber = readInt(), frameNumber = readInt()
-                      )
-                  )
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize + INT_SIZE + INT_SIZE)
-                }
-              }
-
-              ROOT_JAVA_FRAME -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(
-                      gcRoot = JavaFrame(
-                          id = readId(), threadSerialNumber = readInt(), frameNumber = readInt()
-                      )
-                  )
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize + INT_SIZE + INT_SIZE)
-                }
-              }
-
-              ROOT_NATIVE_STACK -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(
-                      gcRoot = NativeStack(id = readId(), threadSerialNumber = readInt())
-                  )
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize + INT_SIZE)
-                }
-              }
-
-              ROOT_STICKY_CLASS -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(
-                      gcRoot = StickyClass(id = readId())
-                  )
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize)
-                }
-              }
-
-              // An object that was referenced from an active thread block.
-              ROOT_THREAD_BLOCK -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(
-                      gcRoot = ThreadBlock(id = readId(), threadSerialNumber = readInt())
-                  )
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize + INT_SIZE)
-                }
-              }
-
-              ROOT_MONITOR_USED -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(
-                      gcRoot = MonitorUsed(id = readId())
-                  )
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize)
-                }
-              }
-
-              ROOT_THREAD_OBJECT -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(
-                      gcRoot = ThreadObject(
-                          id = readId(),
-                          threadSerialNumber = readInt(),
-                          stackTraceSerialNumber = readInt()
-                      )
-                  )
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize + INT_SIZE + INT_SIZE)
-                }
-              }
-
-              ROOT_INTERNED_STRING -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(gcRoot = InternedString(id = readId()))
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize)
-                }
-              }
-
-              ROOT_FINALIZING -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(
-                      gcRoot = Finalizing(id = readId())
-                  )
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize)
-                }
-              }
-
-              ROOT_DEBUGGER -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(
-                      gcRoot = Debugger(id = readId())
-                  )
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize)
-                }
-              }
-
-              ROOT_REFERENCE_CLEANUP -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(
-                      gcRoot = ReferenceCleanup(id = readId())
-                  )
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize)
-                }
-              }
-
-              ROOT_VM_INTERNAL -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(
-                      gcRoot = VmInternal(id = readId())
-                  )
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize)
-                }
-              }
-
-              ROOT_JNI_MONITOR -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(
-                      gcRoot = JniMonitor(
-                          id = readId(), stackTraceSerialNumber = readInt(),
-                          stackDepth = readInt()
-                      )
-                  )
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize + INT_SIZE + INT_SIZE)
-                }
-              }
-
-              ROOT_UNREACHABLE -> {
-                if (readGcRootRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val gcRootRecord = GcRootRecord(
-                      gcRoot = Unreachable(id = readId())
-                  )
-                  readGcRootRecord.forEach {
-                    it.onRecord(
-                        recordPosition, gcRootRecord
-                    )
-                  }
-                } else {
-                  skip(idSize)
-                }
-              }
-              CLASS_DUMP -> {
-                if (readClassDumpRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val record = readClassDumpRecord()
-                  readClassDumpRecord.forEach {
-                    it.onRecord(recordPosition, record)
-                  }
-                } else {
-                  skipClassDumpRecord()
-                }
-              }
-
-              INSTANCE_DUMP -> {
-                if (readInstanceDumpRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val instanceDumpRecord = readInstanceDumpRecord()
-                  readInstanceDumpRecord.forEach {
-                    it.onRecord(recordPosition, instanceDumpRecord)
-                  }
-                } else {
-                  skipInstanceDumpRecord()
-                }
-              }
-
-              OBJECT_ARRAY_DUMP -> {
-                if (readObjectArrayDumpRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val arrayRecord = readObjectArrayDumpRecord()
-                  readObjectArrayDumpRecord.forEach {
-                    it.onRecord(recordPosition, arrayRecord)
-                  }
-                } else {
-                  skipObjectArrayDumpRecord()
-                }
-              }
-
-              PRIMITIVE_ARRAY_DUMP -> {
-                if (readPrimitiveArrayDumpRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val record = readPrimitiveArrayDumpRecord()
-                  readPrimitiveArrayDumpRecord.forEach {
-                    it.onRecord(recordPosition, record)
-                  }
-                } else {
-                  skipPrimitiveArrayDumpRecord()
-                }
-              }
-
-              PRIMITIVE_ARRAY_NODATA -> {
-                throw UnsupportedOperationException("PRIMITIVE_ARRAY_NODATA cannot be parsed")
-              }
-
-              HEAP_DUMP_INFO -> {
-                if (readHeapDumpInfoRecord.isNotEmpty()) {
-                  val recordPosition = position
-                  val record = readHeapDumpInfoRecord()
-                  readHeapDumpInfoRecord.forEach {
-                    it.onRecord(recordPosition, record)
-                  }
-                } else {
-                  skipHeapDumpInfoRecord()
-                }
-              }
-              else -> throw IllegalStateException(
-                  "Unknown tag $heapDumpTag after $previousTag"
-              )
-            }
-            previousTag = heapDumpTag
-          }
-        }
-        HEAP_DUMP_END -> {
-          if (readHeapDumpEnd.isNotEmpty()) {
-            val recordPosition = position
-            val record = HeapDumpEndRecord
-            readHeapDumpEnd.forEach {
-              it.onRecord(recordPosition, record)
-            }
-          }
-        }
-        else -> {
-          skip(length)
-        }
-      }
-    }
-  }
-
-  enum class HprofVersion(val versionString: String) {
-    JDK1_2_BETA3("JAVA PROFILE 1.0"),
-    JDK1_2_BETA4("JAVA PROFILE 1.0.1"),
-    JDK_6("JAVA PROFILE 1.0.2"),
-    ANDROID("JAVA PROFILE 1.0.3")
-  }
-
-  companion object {
-
-    private val supportedVersions = HprofVersion.values()
-        .map { it.versionString }
-
-    internal const val STRING_IN_UTF8 = 0x01
-    internal const val LOAD_CLASS = 0x02
-    internal const val UNLOAD_CLASS = 0x03
-    internal const val STACK_FRAME = 0x04
-    internal const val STACK_TRACE = 0x05
-    internal const val ALLOC_SITES = 0x06
-    internal const val HEAP_SUMMARY = 0x07
-    // TODO Maybe parse this?
-    internal const val START_THREAD = 0x0a
-    internal const val END_THREAD = 0x0b
-    internal const val HEAP_DUMP = 0x0c
-    internal const val HEAP_DUMP_SEGMENT = 0x1c
-    internal const val HEAP_DUMP_END = 0x2c
-    internal const val CPU_SAMPLES = 0x0d
-    internal const val CONTROL_SETTINGS = 0x0e
-    internal const val ROOT_UNKNOWN = 0xff
-    internal const val ROOT_JNI_GLOBAL = 0x01
-    internal const val ROOT_JNI_LOCAL = 0x02
-    internal const val ROOT_JAVA_FRAME = 0x03
-    internal const val ROOT_NATIVE_STACK = 0x04
-    internal const val ROOT_STICKY_CLASS = 0x05
-    internal const val ROOT_THREAD_BLOCK = 0x06
-    internal const val ROOT_MONITOR_USED = 0x07
-    internal const val ROOT_THREAD_OBJECT = 0x08
-    internal const val CLASS_DUMP = 0x20
-    internal const val INSTANCE_DUMP = 0x21
-    internal const val OBJECT_ARRAY_DUMP = 0x22
-    internal const val PRIMITIVE_ARRAY_DUMP = 0x23
-
-    /**
-     * Android format addition
-     *
-     * Specifies information about which heap certain objects came from. When a sub-tag of this type
-     * appears in a HPROF_HEAP_DUMP or HPROF_HEAP_DUMP_SEGMENT record, entries that follow it will
-     * be associated with the specified heap.  The HEAP_DUMP_INFO data is reset at the end of the
-     * HEAP_DUMP[_SEGMENT].  Multiple HEAP_DUMP_INFO entries may appear in a single
-     * HEAP_DUMP[_SEGMENT].
-     *
-     * Format: u1: Tag value (0xFE) u4: heap ID ID: heap name string ID
-     */
-    internal const val HEAP_DUMP_INFO = 0xfe
-    internal const val ROOT_INTERNED_STRING = 0x89
-    internal const val ROOT_FINALIZING = 0x8a
-    internal const val ROOT_DEBUGGER = 0x8b
-    internal const val ROOT_REFERENCE_CLEANUP = 0x8c
-    internal const val ROOT_VM_INTERNAL = 0x8d
-    internal const val ROOT_JNI_MONITOR = 0x8e
-    internal const val ROOT_UNREACHABLE = 0x90
-    internal const val PRIMITIVE_ARRAY_NODATA = 0xc3
-  }
-
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofReader.kt b/leakcanary-haha/src/main/java/leakcanary/HprofReader.kt
deleted file mode 100644
index 10946040..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/HprofReader.kt
+++ /dev/null
@@ -1,413 +0,0 @@
-package leakcanary
-
-import leakcanary.HeapValue.BooleanValue
-import leakcanary.HeapValue.ByteValue
-import leakcanary.HeapValue.CharValue
-import leakcanary.HeapValue.DoubleValue
-import leakcanary.HeapValue.FloatValue
-import leakcanary.HeapValue.IntValue
-import leakcanary.HeapValue.LongValue
-import leakcanary.HeapValue.ObjectReference
-import leakcanary.HeapValue.ShortValue
-import leakcanary.Record.HeapDumpRecord.HeapDumpInfoRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
-import okio.BufferedSource
-import java.io.Closeable
-import java.nio.charset.Charset
-
-/**
- * Reads hprof content from an Okio [BufferedSource].
- *
- * Not thread safe, should be used from a single thread.
- */
-open class HprofReader constructor(
-  protected var source: BufferedSource,
-  protected val startPosition: Long,
-  val idSize: Int
-): Closeable {
-  override fun close() {
-    source.close()
-  }
-
-  var position: Long = startPosition
-    protected set
-
-  val isOpen
-    get() = source.isOpen
-
-  val typeSizes = mapOf(
-      // object
-      OBJECT_TYPE to idSize,
-      BOOLEAN_TYPE to BOOLEAN_SIZE,
-      CHAR_TYPE to CHAR_SIZE,
-      FLOAT_TYPE to FLOAT_SIZE,
-      DOUBLE_TYPE to DOUBLE_SIZE,
-      BYTE_TYPE to BYTE_SIZE,
-      SHORT_TYPE to SHORT_SIZE,
-      INT_TYPE to INT_SIZE,
-      LONG_TYPE to LONG_SIZE
-  )
-
-  fun readValue(type: Int): HeapValue {
-    return when (type) {
-      OBJECT_TYPE -> ObjectReference(readId())
-      BOOLEAN_TYPE -> BooleanValue(readBoolean())
-      CHAR_TYPE -> CharValue(readChar())
-      FLOAT_TYPE -> FloatValue(readFloat())
-      DOUBLE_TYPE -> DoubleValue(readDouble())
-      BYTE_TYPE -> ByteValue(readByte())
-      SHORT_TYPE -> ShortValue(readShort())
-      INT_TYPE -> IntValue(readInt())
-      LONG_TYPE -> LongValue(readLong())
-      else -> throw IllegalStateException("Unknown type $type")
-    }
-  }
-
-  fun typeSize(type: Int): Int {
-    return typeSizes.getValue(type)
-  }
-
-  fun readShort(): Short {
-    position += SHORT_SIZE
-    return source.readShort()
-  }
-
-  fun readInt(): Int {
-    position += INT_SIZE
-    return source.readInt()
-  }
-
-  fun readIdArray(arrayLength: Int): LongArray {
-    return LongArray(arrayLength) { readId() }
-  }
-
-  fun readBooleanArray(arrayLength: Int): BooleanArray {
-    return BooleanArray(arrayLength) { readByte().toInt() != 0 }
-  }
-
-  fun readCharArray(arrayLength: Int): CharArray {
-    return readString(CHAR_SIZE * arrayLength, Charsets.UTF_16BE).toCharArray()
-  }
-
-  fun readString(
-    byteCount: Int,
-    charset: Charset
-  ): String {
-    position += byteCount
-    return source.readString(byteCount.toLong(), charset)
-  }
-
-  fun readFloatArray(arrayLength: Int): FloatArray {
-    return FloatArray(arrayLength) { readFloat() }
-  }
-
-  fun readDoubleArray(arrayLength: Int): DoubleArray {
-    return DoubleArray(arrayLength) { readDouble() }
-  }
-
-  fun readShortArray(arrayLength: Int): ShortArray {
-    return ShortArray(arrayLength) { readShort() }
-  }
-
-  fun readIntArray(arrayLength: Int): IntArray {
-    return IntArray(arrayLength) { readInt() }
-  }
-
-  fun readLongArray(arrayLength: Int): LongArray {
-    return LongArray(arrayLength) { readLong() }
-  }
-
-  fun readLong(): Long {
-    position += LONG_SIZE
-    return source.readLong()
-  }
-
-  fun exhausted() = source.exhausted()
-
-  open fun skip(byteCount: Long) {
-    position += byteCount
-    return source.skip(byteCount)
-  }
-
-  fun readByte(): Byte {
-    position += BYTE_SIZE
-    return source.readByte()
-  }
-
-  fun readBoolean(): Boolean {
-    position += BOOLEAN_SIZE
-    return source.readByte().toInt() != 0
-  }
-
-  fun readByteArray(byteCount: Int): ByteArray {
-    position += byteCount
-    return source.readByteArray(byteCount.toLong())
-  }
-
-  fun readChar(): Char {
-    return readString(CHAR_SIZE, Charsets.UTF_16BE)[0]
-  }
-
-  fun readFloat(): Float {
-    return Float.fromBits(readInt())
-  }
-
-  fun readDouble(): Double {
-    return Double.fromBits(readLong())
-  }
-
-  fun readId(): Long {
-    // As long as we don't interpret IDs, reading signed values here is fine.
-    return when (idSize) {
-      1 -> readByte().toLong()
-      2 -> readShort().toLong()
-      4 -> readInt().toLong()
-      8 -> readLong()
-      else -> throw IllegalArgumentException("ID Length must be 1, 2, 4, or 8")
-    }
-  }
-
-  fun readUtf8(byteCount: Long): String {
-    position += byteCount
-    return source.readUtf8(byteCount)
-  }
-
-  fun readUnsignedInt(): Long {
-    return readInt().toLong() and INT_MASK
-  }
-
-  fun readUnsignedByte(): Int {
-    return readByte().toInt() and BYTE_MASK
-  }
-
-  fun readUnsignedShort(): Int {
-    return readShort().toInt() and 0xFFFF
-  }
-
-  fun skip(byteCount: Int) {
-    position += byteCount
-    return source.skip(byteCount.toLong())
-  }
-
-  fun readInstanceDumpRecord(): InstanceDumpRecord {
-    val id = readId()
-    val stackTraceSerialNumber = readInt()
-    val classId = readId()
-    val remainingBytesInInstance = readInt()
-    val fieldValues = readByteArray(remainingBytesInInstance)
-    return InstanceDumpRecord(
-        id = id,
-        stackTraceSerialNumber = stackTraceSerialNumber,
-        classId = classId,
-        fieldValues = fieldValues
-    )
-  }
-
-  fun readClassDumpRecord(): ClassDumpRecord {
-    val id = readId()
-    // stack trace serial number
-    val stackTraceSerialNumber = readInt()
-    val superClassId = readId()
-    // class loader object ID
-    val classLoaderId = readId()
-    // signers object ID
-    val signersId = readId()
-    // protection domain object ID
-    val protectionDomainId = readId()
-    // reserved
-    readId()
-    // reserved
-    readId()
-
-    // instance size (in bytes)
-    // Useful to compute retained size
-    val instanceSize = readInt()
-
-    // Skip over the constant pool
-    val constantPoolCount = readUnsignedShort()
-    for (i in 0 until constantPoolCount) {
-      // constant pool index
-      skip(SHORT_SIZE)
-      skip(typeSize(readUnsignedByte()))
-    }
-
-    val staticFieldCount = readUnsignedShort()
-    val staticFields = ArrayList<StaticFieldRecord>(staticFieldCount)
-    for (i in 0 until staticFieldCount) {
-
-      val nameStringId = readId()
-      val type = readUnsignedByte()
-      val value = readValue(type)
-
-      staticFields.add(
-          StaticFieldRecord(
-              nameStringId = nameStringId,
-              type = type,
-              value = value
-          )
-      )
-    }
-
-    val fieldCount = readUnsignedShort()
-    val fields = ArrayList<FieldRecord>(fieldCount)
-    for (i in 0 until fieldCount) {
-      fields.add(FieldRecord(nameStringId = readId(), type = readUnsignedByte()))
-    }
-
-    return ClassDumpRecord(
-        id = id,
-        stackTraceSerialNumber = stackTraceSerialNumber,
-        superClassId = superClassId,
-        classLoaderId = classLoaderId,
-        signersId = signersId,
-        protectionDomainId = protectionDomainId,
-        instanceSize = instanceSize,
-        staticFields = staticFields,
-        fields = fields
-    )
-  }
-
-  fun skipInstanceDumpRecord() {
-    skip(idSize + INT_SIZE + idSize)
-    val remainingBytesInInstance = readInt()
-    skip(remainingBytesInInstance)
-  }
-
-  fun skipClassDumpRecord() {
-    skip(
-        idSize + INT_SIZE + idSize + idSize + idSize + idSize + idSize + idSize + INT_SIZE
-    )
-    // Skip over the constant pool
-    val constantPoolCount = readUnsignedShort()
-    for (i in 0 until constantPoolCount) {
-      // constant pool index
-      skip(SHORT_SIZE)
-      skip(typeSize(readUnsignedByte()))
-    }
-
-    val staticFieldCount = readUnsignedShort()
-
-    for (i in 0 until staticFieldCount) {
-      skip(idSize)
-      val type = readUnsignedByte()
-      skip(typeSize(type))
-    }
-
-    val fieldCount = readUnsignedShort()
-    skip(fieldCount * (idSize + BYTE_SIZE))
-  }
-
-  fun readObjectArrayDumpRecord(
-  ): ObjectArrayDumpRecord {
-    val id = readId()
-    // stack trace serial number
-    val stackTraceSerialNumber = readInt()
-    val arrayLength = readInt()
-    val arrayClassId = readId()
-    val elementIds = readIdArray(arrayLength)
-    return ObjectArrayDumpRecord(
-        id = id,
-        stackTraceSerialNumber = stackTraceSerialNumber,
-        arrayClassId = arrayClassId,
-        elementIds = elementIds
-    )
-  }
-
-  fun skipObjectArrayDumpRecord() {
-    skip(idSize + INT_SIZE)
-    val arrayLength = readInt()
-    skip(idSize + arrayLength * idSize)
-  }
-
-  fun readPrimitiveArrayDumpRecord(): PrimitiveArrayDumpRecord {
-    val id = readId()
-    val stackTraceSerialNumber = readInt()
-    // length
-    val arrayLength = readInt()
-    val type = readUnsignedByte()
-    return when (type) {
-      BOOLEAN_TYPE -> BooleanArrayDump(
-          id, stackTraceSerialNumber, readBooleanArray(arrayLength)
-      )
-      CHAR_TYPE -> CharArrayDump(
-          id, stackTraceSerialNumber, readCharArray(arrayLength)
-      )
-      FLOAT_TYPE -> FloatArrayDump(
-          id, stackTraceSerialNumber, readFloatArray(arrayLength)
-      )
-      DOUBLE_TYPE -> DoubleArrayDump(
-          id, stackTraceSerialNumber, readDoubleArray(arrayLength)
-      )
-      BYTE_TYPE -> ByteArrayDump(
-          id, stackTraceSerialNumber, readByteArray(arrayLength)
-      )
-      SHORT_TYPE -> ShortArrayDump(
-          id, stackTraceSerialNumber, readShortArray(arrayLength)
-      )
-      INT_TYPE -> IntArrayDump(
-          id, stackTraceSerialNumber, readIntArray(arrayLength)
-      )
-      LONG_TYPE -> LongArrayDump(
-          id, stackTraceSerialNumber, readLongArray(arrayLength)
-      )
-      else -> throw IllegalStateException("Unexpected type $type")
-    }
-  }
-
-  fun skipPrimitiveArrayDumpRecord() {
-    skip(idSize + INT_SIZE)
-    val arrayLength = readInt()
-    val type = readUnsignedByte()
-    skip(idSize + arrayLength * typeSize(type))
-  }
-
-  fun readHeapDumpInfoRecord(): HeapDumpInfoRecord {
-    val heapId = readInt()
-    return HeapDumpInfoRecord(heapId = heapId, heapNameStringId = readId())
-  }
-
-  fun skipHeapDumpInfoRecord() {
-    skip(idSize + idSize)
-  }
-
-  val tagPositionAfterReadingId
-    get() = position - (idSize + BYTE_SIZE)
-
-  companion object {
-    const val BOOLEAN_SIZE = 1
-    const val CHAR_SIZE = 2
-    const val FLOAT_SIZE = 4
-    const val DOUBLE_SIZE = 8
-    const val BYTE_SIZE = 1
-    const val SHORT_SIZE = 2
-    const val INT_SIZE = 4
-    const val LONG_SIZE = 8
-
-    const val OBJECT_TYPE = 2
-    const val BOOLEAN_TYPE = 4
-    const val CHAR_TYPE = 5
-    const val FLOAT_TYPE = 6
-    const val DOUBLE_TYPE = 7
-    const val BYTE_TYPE = 8
-    const val SHORT_TYPE = 9
-    const val INT_TYPE = 10
-    const val LONG_TYPE = 11
-
-    const val INT_MASK = 0xffffffffL
-    const val BYTE_MASK = 0xff
-  }
-
-}
diff --git a/leakcanary-haha/src/main/java/leakcanary/PrimitiveType.kt b/leakcanary-haha/src/main/java/leakcanary/PrimitiveType.kt
deleted file mode 100644
index f809124d..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/PrimitiveType.kt
+++ /dev/null
@@ -1,12 +0,0 @@
-package leakcanary
-
-enum class PrimitiveType {
-  BOOLEAN,
-  CHAR,
-  FLOAT,
-  DOUBLE,
-  BYTE,
-  SHORT,
-  INT,
-  LONG
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/SeekableHprofReader.kt b/leakcanary-haha/src/main/java/leakcanary/SeekableHprofReader.kt
deleted file mode 100644
index ba68cd27..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/SeekableHprofReader.kt
+++ /dev/null
@@ -1,28 +0,0 @@
-package leakcanary
-
-import okio.BufferedSource
-import java.nio.channels.FileChannel
-
-/**
- * A [HprofReader] that can be moved ([moveTo]) to a new position.
- */
-class SeekableHprofReader(
-  private val channel: FileChannel,
-  source: BufferedSource,
-  startPosition: Long,
-  idSize: Int
-) : HprofReader(source, startPosition, idSize) {
-
-  fun moveTo(newPosition: Long) {
-    if (position == newPosition) {
-      return
-    }
-    source.buffer.clear()
-    channel.position(newPosition)
-    position = newPosition
-  }
-
-  fun reset() {
-    moveTo(startPosition)
-  }
-}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/FieldValuesReader.kt b/leakcanary-haha/src/main/java/leakcanary/internal/FieldValuesReader.kt
deleted file mode 100644
index eb3ca46c..00000000
--- a/leakcanary-haha/src/main/java/leakcanary/internal/FieldValuesReader.kt
+++ /dev/null
@@ -1,8 +0,0 @@
-package leakcanary.internal
-
-import leakcanary.HeapValue
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
-
-internal interface FieldValuesReader {
-  fun readValue(field: FieldRecord): HeapValue
-}
\ No newline at end of file
diff --git a/leakcanary-leaksentry/gradle.properties b/leakcanary-leaksentry/gradle.properties
deleted file mode 100644
index a0b9bd2c..00000000
--- a/leakcanary-leaksentry/gradle.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-POM_ARTIFACT_ID=leaksentry
-POM_NAME=LeakSentry
-POM_PACKAGING=aar
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt b/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt
deleted file mode 100644
index 36507b5f..00000000
--- a/leakcanary-leaksentry/src/main/java/leakcanary/LeakSentry.kt
+++ /dev/null
@@ -1,82 +0,0 @@
-package leakcanary
-
-import android.app.Application
-import leakcanary.internal.InternalLeakSentry
-import java.util.concurrent.TimeUnit
-
-/**
- * The entry point API for LeakSentry. LeakSentry is in charge of detecting retained objects.
- *
- * LeakSentry can be configured by updating [config]. You can ask LeakSentry to watch any object
- * that you expect to be unreachable by calling [ObjectWatcher.watch] on [objectWatcher].
- */
-object LeakSentry {
-
-  data class Config(
-    /**
-     * Whether LeakSentry should watch objects (by keeping weak references to them).
-     *
-     * Default to true in debuggable builds and false is non debuggable builds.
-     */
-    val enabled: Boolean = InternalLeakSentry.isDebuggableBuild,
-
-    /**
-     * Whether LeakSentry should automatically watch destroyed activity instances.
-     *
-     * Defaults to true.
-     */
-    val watchActivities: Boolean = true,
-
-    /**
-     * Whether LeakSentry should automatically watch destroyed fragment instances.
-     *
-     * Defaults to true.
-     */
-    val watchFragments: Boolean = true,
-
-    /**
-     * Whether LeakSentry should automatically watch destroyed fragment view instances.
-     *
-     * Defaults to true.
-     */
-    val watchFragmentViews: Boolean = true,
-
-    /**
-     * How long to wait before reporting a watched object as retained.
-     *
-     * Default to 5 seconds.
-     */
-    val watchDurationMillis: Long = TimeUnit.SECONDS.toMillis(5)
-  )
-
-  /**
-   * The current LeakSentry configuration. Can be updated at any time, usually by replacing it with
-   * a mutated copy, e.g.:
-   *
-   * ```
-   * LeakCanary.config = LeakCanary.config.copy(enabled = false)
-   * ```
-   */
-  @Volatile
-  var config: Config = if (isInstalled) Config() else Config(enabled = false)
-
-  /**
-   * The [ObjectWatcher] used by LeakSentry to detect retained objects.
-   */
-  val objectWatcher
-    get() = InternalLeakSentry.objectWatcher
-
-  /** @see [manualInstall] */
-  val isInstalled
-    get() = InternalLeakSentry.isInstalled
-
-  /**
-   * [LeakSentry] is automatically installed on main process start by
-   * [leakcanary.internal.LeakSentryInstaller] which is registered in the AndroidManifest.xml of
-   * your app. If you disabled [leakcanary.internal.LeakSentryInstaller] or you need LeakSentry
-   * or LeakCanary to run outside of the main process then you can call this method to install
-   * [LeakSentry].
-   */
-  fun manualInstall(application: Application) = InternalLeakSentry.install(application)
-
-}
\ No newline at end of file
diff --git a/leakcanary-log/gradle.properties b/leakcanary-log/gradle.properties
deleted file mode 100644
index d14febb2..00000000
--- a/leakcanary-log/gradle.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-POM_ARTIFACT_ID=leakcanary-log
-POM_NAME=LeakCanary Log
-POM_PACKAGING=jar
diff --git a/leakcanary-fragments-androidx/build.gradle b/leakcanary-object-watcher-android-androidx/build.gradle
similarity index 91%
rename from leakcanary-fragments-androidx/build.gradle
rename to leakcanary-object-watcher-android-androidx/build.gradle
index 3e2f7a90..ba51c308 100644
--- a/leakcanary-fragments-androidx/build.gradle
+++ b/leakcanary-object-watcher-android-androidx/build.gradle
@@ -2,7 +2,7 @@ apply plugin: 'com.android.library'
 apply plugin: 'kotlin-android'
 
 dependencies {
-  api project(':leakcanary-leaksentry')
+  api project(':leakcanary-object-watcher-android')
 
   implementation deps.kotlin.stdlib
   // Optional dependency
diff --git a/leakcanary-object-watcher-android-androidx/gradle.properties b/leakcanary-object-watcher-android-androidx/gradle.properties
new file mode 100644
index 00000000..2a0b9c8f
--- /dev/null
+++ b/leakcanary-object-watcher-android-androidx/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-object-watcher-android-androidx
+POM_NAME=LeakCanary Object Watcher for Android extension: Android X fragments support
+POM_PACKAGING=aar
diff --git a/leakcanary-fragments-androidx/src/main/AndroidManifest.xml b/leakcanary-object-watcher-android-androidx/src/main/AndroidManifest.xml
similarity index 100%
rename from leakcanary-fragments-androidx/src/main/AndroidManifest.xml
rename to leakcanary-object-watcher-android-androidx/src/main/AndroidManifest.xml
diff --git a/leakcanary-fragments-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt b/leakcanary-object-watcher-android-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
similarity index 98%
rename from leakcanary-fragments-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
rename to leakcanary-object-watcher-android-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
index a7bae01a..8ce9f73a 100644
--- a/leakcanary-fragments-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
+++ b/leakcanary-object-watcher-android-androidx/src/main/java/leakcanary/internal/AndroidXFragmentDestroyWatcher.kt
@@ -19,7 +19,7 @@ import android.app.Activity
 import androidx.fragment.app.Fragment
 import androidx.fragment.app.FragmentActivity
 import androidx.fragment.app.FragmentManager
-import leakcanary.LeakSentry.Config
+import leakcanary.AppWatcher.Config
 import leakcanary.ObjectWatcher
 
 internal class AndroidXFragmentDestroyWatcher(
diff --git a/leakcanary-leaksentry/build.gradle b/leakcanary-object-watcher-android/build.gradle
similarity index 93%
rename from leakcanary-leaksentry/build.gradle
rename to leakcanary-object-watcher-android/build.gradle
index 97ffdfca..18fda0be 100644
--- a/leakcanary-leaksentry/build.gradle
+++ b/leakcanary-object-watcher-android/build.gradle
@@ -2,7 +2,7 @@ apply plugin: 'com.android.library'
 apply plugin: 'kotlin-android'
 
 dependencies {
-  api project(':leakcanary-watcher')
+  api project(':leakcanary-object-watcher')
 
   implementation deps.kotlin.stdlib
 }
diff --git a/leakcanary-object-watcher-android/gradle.properties b/leakcanary-object-watcher-android/gradle.properties
new file mode 100644
index 00000000..30530624
--- /dev/null
+++ b/leakcanary-object-watcher-android/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-object-watcher-android
+POM_NAME=LeakCanary Object Watcher for Android
+POM_PACKAGING=aar
diff --git a/leakcanary-sample/src/androidTest/AndroidManifest.xml b/leakcanary-object-watcher-android/src/androidTest/AndroidManifest.xml
similarity index 100%
rename from leakcanary-sample/src/androidTest/AndroidManifest.xml
rename to leakcanary-object-watcher-android/src/androidTest/AndroidManifest.xml
diff --git a/leakcanary-leaksentry/src/main/AndroidManifest.xml b/leakcanary-object-watcher-android/src/main/AndroidManifest.xml
similarity index 71%
rename from leakcanary-leaksentry/src/main/AndroidManifest.xml
rename to leakcanary-object-watcher-android/src/main/AndroidManifest.xml
index 3b42b180..c11c5661 100644
--- a/leakcanary-leaksentry/src/main/AndroidManifest.xml
+++ b/leakcanary-object-watcher-android/src/main/AndroidManifest.xml
@@ -1,12 +1,12 @@
 <?xml version="1.0" encoding="utf-8"?>
 <manifest
     xmlns:android="http://schemas.android.com/apk/res/android"
-    package="com.squareup.leakcanary.leaksentry"
+    package="com.squareup.leakcanary.objectwatcher"
     >
 
   <application>
     <provider
-        android:name="leakcanary.internal.LeakSentryInstaller"
+        android:name="leakcanary.internal.AppWatcherInstaller"
         android:authorities="${applicationId}.leak-sentry-installer"
         android:exported="false"/>
   </application>
diff --git a/leakcanary-object-watcher-android/src/main/java/leakcanary/AppWatcher.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/AppWatcher.kt
new file mode 100644
index 00000000..0aa035a5
--- /dev/null
+++ b/leakcanary-object-watcher-android/src/main/java/leakcanary/AppWatcher.kt
@@ -0,0 +1,84 @@
+package leakcanary
+
+import android.app.Application
+import leakcanary.AppWatcher.config
+import leakcanary.AppWatcher.objectWatcher
+import leakcanary.internal.InternalAppWatcher
+import java.util.concurrent.TimeUnit
+
+/**
+ * The entry point API for using [ObjectWatcher] in an Android app. [AppWatcher.objectWatcher] is
+ * in charge of detecting retained objects, and [AppWatcher] is auto configured on app start to
+ * pass it activity and fragment instances. Call [ObjectWatcher.watch] on [objectWatcher] to
+ * watch any other object that you expect to be unreachable.
+ */
+object AppWatcher {
+
+  data class Config(
+    /**
+     * Whether AppWatcher should watch objects (by keeping weak references to them).
+     *
+     * Default to true in debuggable builds and false is non debuggable builds.
+     */
+    val enabled: Boolean = InternalAppWatcher.isDebuggableBuild,
+
+    /**
+     * Whether AppWatcher should automatically watch destroyed activity instances.
+     *
+     * Defaults to true.
+     */
+    val watchActivities: Boolean = true,
+
+    /**
+     * Whether AppWatcher should automatically watch destroyed fragment instances.
+     *
+     * Defaults to true.
+     */
+    val watchFragments: Boolean = true,
+
+    /**
+     * Whether AppWatcher should automatically watch destroyed fragment view instances.
+     *
+     * Defaults to true.
+     */
+    val watchFragmentViews: Boolean = true,
+
+    /**
+     * How long to wait before reporting a watched object as retained.
+     *
+     * Default to 5 seconds.
+     */
+    val watchDurationMillis: Long = TimeUnit.SECONDS.toMillis(5)
+  )
+
+  /**
+   * The current AppWatcher configuration. Can be updated at any time, usually by replacing it with
+   * a mutated copy, e.g.:
+   *
+   * ```
+   * LeakCanary.config = LeakCanary.config.copy(enabled = false)
+   * ```
+   */
+  @Volatile
+  var config: Config = if (isInstalled) Config() else Config(enabled = false)
+
+  /**
+   * The [ObjectWatcher] used by AppWatcher to detect retained objects.
+   */
+  val objectWatcher
+    get() = InternalAppWatcher.objectWatcher
+
+  /** @see [manualInstall] */
+  val isInstalled
+    get() = InternalAppWatcher.isInstalled
+
+  /**
+   * [AppWatcher] is automatically installed on main process start by
+   * [leakcanary.internal.AppWatcherInstaller] which is registered in the AndroidManifest.xml of
+   * your app. If you disabled [leakcanary.internal.AppWatcherInstaller] or you need AppWatcher
+   * or LeakCanary to run outside of the main process then you can call this method to install
+   * [AppWatcher].
+   */
+  fun manualInstall(application: Application) = InternalAppWatcher.install(application)
+
+}
\ No newline at end of file
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
similarity index 94%
rename from leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
rename to leakcanary-object-watcher-android/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
index 87b4fd97..f2984ec7 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
+++ b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/ActivityDestroyWatcher.kt
@@ -17,9 +17,9 @@ package leakcanary.internal
 
 import android.app.Activity
 import android.app.Application
-import leakcanary.LeakSentry.Config
+import leakcanary.AppWatcher.Config
 import leakcanary.ObjectWatcher
-import leakcanary.internal.InternalLeakSentry.noOpDelegate
+import leakcanary.internal.InternalAppWatcher.noOpDelegate
 
 internal class ActivityDestroyWatcher private constructor(
   private val objectWatcher: ObjectWatcher,
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
similarity index 97%
rename from leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
rename to leakcanary-object-watcher-android/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
index 02e1bbc1..7c48562a 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
+++ b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/AndroidOFragmentDestroyWatcher.kt
@@ -21,7 +21,7 @@ import android.annotation.SuppressLint
 import android.app.Activity
 import android.app.Fragment
 import android.app.FragmentManager
-import leakcanary.LeakSentry.Config
+import leakcanary.AppWatcher.Config
 import leakcanary.ObjectWatcher
 
 @SuppressLint("NewApi")
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryInstaller.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/AppWatcherInstaller.kt
similarity index 78%
rename from leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryInstaller.kt
rename to leakcanary-object-watcher-android/src/main/java/leakcanary/internal/AppWatcherInstaller.kt
index 84cf968b..325e21ae 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/LeakSentryInstaller.kt
+++ b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/AppWatcherInstaller.kt
@@ -5,18 +5,18 @@ import android.content.ContentProvider
 import android.content.ContentValues
 import android.database.Cursor
 import android.net.Uri
-import leakcanary.CanaryLog
+import shark.SharkLog
 
 /**
- * Content providers are loaded before the application class is created. [LeakSentryInstaller] is
- * used to install [leaksentry.LeakSentry] on application start.
+ * Content providers are loaded before the application class is created. [AppWatcherInstaller] is
+ * used to install [leakcanary.AppWatcher] on application start.
  */
-internal class LeakSentryInstaller : ContentProvider() {
+internal class AppWatcherInstaller : ContentProvider() {
 
   override fun onCreate(): Boolean {
-    CanaryLog.logger = DefaultCanaryLog()
+    SharkLog.logger = DefaultCanaryLog()
     val application = context!!.applicationContext as Application
-    InternalLeakSentry.install(application)
+    InternalAppWatcher.install(application)
     return true
   }
 
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/DefaultCanaryLog.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
similarity index 95%
rename from leakcanary-leaksentry/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
rename to leakcanary-object-watcher-android/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
index 673fc587..e9c09d52 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
+++ b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/DefaultCanaryLog.kt
@@ -1,7 +1,7 @@
 package leakcanary.internal
 
 import android.util.Log
-import leakcanary.CanaryLog.Logger
+import shark.SharkLog.Logger
 
 internal class DefaultCanaryLog : Logger {
 
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
similarity index 95%
rename from leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
rename to leakcanary-object-watcher-android/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
index dee5d5ed..9b4059c2 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
+++ b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/FragmentDestroyWatcher.kt
@@ -20,9 +20,9 @@ import android.app.Application
 import android.os.Build.VERSION.SDK_INT
 import android.os.Build.VERSION_CODES.O
 import android.os.Bundle
-import leakcanary.LeakSentry
+import leakcanary.AppWatcher
 import leakcanary.ObjectWatcher
-import leakcanary.internal.InternalLeakSentry.noOpDelegate
+import leakcanary.internal.InternalAppWatcher.noOpDelegate
 
 /**
  * Internal class used to watch for fragments leaks.
@@ -36,7 +36,7 @@ internal object FragmentDestroyWatcher {
   fun install(
     application: Application,
     objectWatcher: ObjectWatcher,
-    configProvider: () -> LeakSentry.Config
+    configProvider: () -> AppWatcher.Config
   ) {
     val fragmentDestroyWatchers = mutableListOf<(Activity) -> Unit>()
 
diff --git a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/InternalAppWatcher.kt
similarity index 76%
rename from leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
rename to leakcanary-object-watcher-android/src/main/java/leakcanary/internal/InternalAppWatcher.kt
index 2578e825..e1eacd94 100644
--- a/leakcanary-leaksentry/src/main/java/leakcanary/internal/InternalLeakSentry.kt
+++ b/leakcanary-object-watcher-android/src/main/java/leakcanary/internal/InternalAppWatcher.kt
@@ -5,22 +5,21 @@ import android.content.pm.ApplicationInfo
 import android.os.Handler
 import android.os.Looper
 import android.os.SystemClock
-import leakcanary.CanaryLog
 import leakcanary.Clock
-import leakcanary.LeakSentry
-import leakcanary.OnObjectRetainedListener
+import leakcanary.AppWatcher
 import leakcanary.ObjectWatcher
+import leakcanary.OnObjectRetainedListener
+import shark.SharkLog
 import java.lang.reflect.InvocationHandler
 import java.lang.reflect.Proxy
 import java.util.concurrent.Executor
 
-internal object InternalLeakSentry {
+internal object InternalAppWatcher {
 
   val isInstalled
     get() = ::application.isInitialized
 
-  private val onLeakSentryInstalled: (Application) -> Unit
-  private val ON_OBJECT_RETAINED_LISTENER: OnObjectRetainedListener
+  private val onAppWatcherInstalled: (Application) -> Unit
 
   val isDebuggableBuild by lazy {
     (application.applicationInfo.flags and ApplicationInfo.FLAG_DEBUGGABLE) != 0
@@ -45,32 +44,30 @@ internal object InternalLeakSentry {
       NoLeakCanary
     }
     @kotlin.Suppress("UNCHECKED_CAST")
-    onLeakSentryInstalled = internalLeakCanary as (Application) -> Unit
-    ON_OBJECT_RETAINED_LISTENER = internalLeakCanary as OnObjectRetainedListener
+    onAppWatcherInstalled = internalLeakCanary as (Application) -> Unit
   }
 
   private val checkRetainedExecutor = Executor {
-    mainHandler.postDelayed(it, LeakSentry.config.watchDurationMillis)
+    mainHandler.postDelayed(it, AppWatcher.config.watchDurationMillis)
   }
   val objectWatcher = ObjectWatcher(
       clock = clock,
       checkRetainedExecutor = checkRetainedExecutor,
-      onObjectRetainedListener = ON_OBJECT_RETAINED_LISTENER,
-      isEnabled = { LeakSentry.config.enabled }
+      isEnabled = { AppWatcher.config.enabled }
   )
 
   fun install(application: Application) {
-    CanaryLog.d("Installing LeakSentry")
+    SharkLog.d("Installing AppWatcher")
     checkMainThread()
     if (this::application.isInitialized) {
       return
     }
-    InternalLeakSentry.application = application
+    InternalAppWatcher.application = application
 
-    val configProvider = { LeakSentry.config }
+    val configProvider = { AppWatcher.config }
     ActivityDestroyWatcher.install(application, objectWatcher, configProvider)
     FragmentDestroyWatcher.install(application, objectWatcher, configProvider)
-    onLeakSentryInstalled(application)
+    onAppWatcherInstalled(application)
   }
 
   inline fun <reified T : Any> noOpDelegate(): T {
diff --git a/leakcanary-watcher/build.gradle b/leakcanary-object-watcher/build.gradle
similarity index 92%
rename from leakcanary-watcher/build.gradle
rename to leakcanary-object-watcher/build.gradle
index 984bad02..e61c3f3c 100644
--- a/leakcanary-watcher/build.gradle
+++ b/leakcanary-object-watcher/build.gradle
@@ -6,7 +6,7 @@ targetCompatibility = JavaVersion.VERSION_1_7
 
 dependencies {
   implementation deps.kotlin.stdlib
-  api project(':leakcanary-log')
+  api project(':shark-log')
 
   testImplementation deps.assertj_core
   testImplementation deps.junit
diff --git a/leakcanary-object-watcher/gradle.properties b/leakcanary-object-watcher/gradle.properties
new file mode 100644
index 00000000..16794121
--- /dev/null
+++ b/leakcanary-object-watcher/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=leakcanary-object-watcher
+POM_NAME=LeakCanary Object Watcher
+POM_PACKAGING=jar
diff --git a/leakcanary-watcher/src/main/java/leakcanary/Clock.kt b/leakcanary-object-watcher/src/main/java/leakcanary/Clock.kt
similarity index 100%
rename from leakcanary-watcher/src/main/java/leakcanary/Clock.kt
rename to leakcanary-object-watcher/src/main/java/leakcanary/Clock.kt
diff --git a/leakcanary-watcher/src/main/java/leakcanary/GcTrigger.kt b/leakcanary-object-watcher/src/main/java/leakcanary/GcTrigger.kt
similarity index 100%
rename from leakcanary-watcher/src/main/java/leakcanary/GcTrigger.kt
rename to leakcanary-object-watcher/src/main/java/leakcanary/GcTrigger.kt
diff --git a/leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt b/leakcanary-object-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
similarity index 98%
rename from leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
rename to leakcanary-object-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
index 8a63e2b4..e6137c30 100644
--- a/leakcanary-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
+++ b/leakcanary-object-watcher/src/main/java/leakcanary/KeyedWeakReference.kt
@@ -27,7 +27,6 @@ import java.lang.ref.WeakReference
  * [heapDumpUptimeMillis] should be set with the current time from [Clock.uptimeMillis] right
  * before dumping the heap, so that we can later determine how long an object was retained.
  */
-@Suppress("unused")
 class KeyedWeakReference(
   referent: Any,
   val key: String,
diff --git a/leakcanary-watcher/src/main/java/leakcanary/ObjectWatcher.kt b/leakcanary-object-watcher/src/main/java/leakcanary/ObjectWatcher.kt
similarity index 89%
rename from leakcanary-watcher/src/main/java/leakcanary/ObjectWatcher.kt
rename to leakcanary-object-watcher/src/main/java/leakcanary/ObjectWatcher.kt
index ffb469ca..77326949 100644
--- a/leakcanary-watcher/src/main/java/leakcanary/ObjectWatcher.kt
+++ b/leakcanary-object-watcher/src/main/java/leakcanary/ObjectWatcher.kt
@@ -15,6 +15,7 @@
  */
 package leakcanary
 
+import shark.SharkLog
 import java.lang.ref.ReferenceQueue
 import java.util.UUID
 import java.util.concurrent.Executor
@@ -35,13 +36,14 @@ import java.util.concurrent.Executor
 class ObjectWatcher constructor(
   private val clock: Clock,
   private val checkRetainedExecutor: Executor,
-  private val onObjectRetainedListener: OnObjectRetainedListener,
   /**
    * Calls to [watch] will be ignored when [isEnabled] returns false
    */
   private val isEnabled: () -> Boolean = { true }
 ) {
 
+  private val onObjectRetainedListeners = mutableSetOf<OnObjectRetainedListener>()
+
   /**
    * References passed to [watch].
    */
@@ -99,6 +101,14 @@ class ObjectWatcher constructor(
       return instances
     }
 
+  @Synchronized fun addOnObjectRetainedListener(listener: OnObjectRetainedListener) {
+    onObjectRetainedListeners.add(listener)
+  }
+
+  @Synchronized fun removeOnObjectRetainedListener(listener: OnObjectRetainedListener) {
+    onObjectRetainedListeners.remove(listener)
+  }
+
   /**
    * Identical to [watch] with an empty string reference name.
    */
@@ -124,9 +134,10 @@ class ObjectWatcher constructor(
     val watchUptimeMillis = clock.uptimeMillis()
     val reference =
       KeyedWeakReference(watchedObject, key, name, watchUptimeMillis, queue)
-    CanaryLog.d(
+    SharkLog.d(
         "Watching %s with key %s",
-        ((if (watchedObject is Class<*>) watchedObject.toString() else "instance of ${watchedObject.javaClass.name}") + if (name.isNotEmpty()) " named $name" else ""), key
+        ((if (watchedObject is Class<*>) watchedObject.toString() else "instance of ${watchedObject.javaClass.name}") + if (name.isNotEmpty()) " named $name" else ""),
+        key
     )
 
     watchedObjects[key] = reference
@@ -140,7 +151,8 @@ class ObjectWatcher constructor(
    * [clock] [Clock.uptimeMillis])
    */
   @Synchronized fun clearObjectsWatchedBefore(heapDumpUptimeMillis: Long) {
-    val weakRefsToRemove = watchedObjects.filter { it.value.watchUptimeMillis <= heapDumpUptimeMillis }
+    val weakRefsToRemove =
+      watchedObjects.filter { it.value.watchUptimeMillis <= heapDumpUptimeMillis }
     weakRefsToRemove.values.forEach { it.clear() }
     watchedObjects.keys.removeAll(weakRefsToRemove.keys)
   }
@@ -158,7 +170,7 @@ class ObjectWatcher constructor(
     val retainedRef = watchedObjects[key]
     if (retainedRef != null) {
       retainedRef.retainedUptimeMillis = clock.uptimeMillis()
-      onObjectRetainedListener.onObjectRetained()
+      onObjectRetainedListeners.forEach { it.onObjectRetained() }
     }
   }
 
diff --git a/leakcanary-object-watcher/src/main/java/leakcanary/OnObjectRetainedListener.kt b/leakcanary-object-watcher/src/main/java/leakcanary/OnObjectRetainedListener.kt
new file mode 100644
index 00000000..89f43aeb
--- /dev/null
+++ b/leakcanary-object-watcher/src/main/java/leakcanary/OnObjectRetainedListener.kt
@@ -0,0 +1,33 @@
+package leakcanary
+
+/**
+ * Listener used by [ObjectWatcher] to report retained objects.
+ */
+interface OnObjectRetainedListener {
+
+  /**
+   * A watched object became retained.
+   */
+  fun onObjectRetained()
+
+  companion object {
+    /**
+     * Utility function to create a [OnObjectRetainedListener] from the passed in [block] lambda
+     * instead of using the anonymous `object : OnObjectRetainedListener` syntax.
+     *
+     * Usage:
+     *
+     * ```kotlin
+     * val listener = OnObjectRetainedListener {
+     *
+     * }
+     * ```
+     */
+    inline operator fun invoke(crossinline block: () -> Unit): OnObjectRetainedListener =
+      object : OnObjectRetainedListener {
+        override fun onObjectRetained() {
+          block()
+        }
+      }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-watcher/src/test/java/leakcanary/ObjectWatcherTest.kt b/leakcanary-object-watcher/src/test/java/leakcanary/ObjectWatcherTest.kt
similarity index 82%
rename from leakcanary-watcher/src/test/java/leakcanary/ObjectWatcherTest.kt
rename to leakcanary-object-watcher/src/test/java/leakcanary/ObjectWatcherTest.kt
index 614122a3..42bd88b0 100644
--- a/leakcanary-watcher/src/test/java/leakcanary/ObjectWatcherTest.kt
+++ b/leakcanary-object-watcher/src/test/java/leakcanary/ObjectWatcherTest.kt
@@ -7,10 +7,6 @@ import java.util.concurrent.Executor
 
 class ObjectWatcherTest {
 
-  private val onInstanceRetained = object: OnObjectRetainedListener {
-    override fun onObjectRetained() {}
-  }
-
   private val checkRetainedExecutor: Executor = Executor {
     it.run()
   }
@@ -19,7 +15,7 @@ class ObjectWatcherTest {
     override fun uptimeMillis(): Long {
       return time
     }
-  }, checkRetainedExecutor, onInstanceRetained)
+  }, checkRetainedExecutor).apply { addOnObjectRetainedListener(OnObjectRetainedListener {}) }
   var time: Long = 0
 
   var ref: Any? = Any()
diff --git a/leakcanary-watcher/gradle.properties b/leakcanary-watcher/gradle.properties
deleted file mode 100644
index cbcadeeb..00000000
--- a/leakcanary-watcher/gradle.properties
+++ /dev/null
@@ -1,3 +0,0 @@
-POM_ARTIFACT_ID=leakcanary-watcher
-POM_NAME=LeakCanary Watcher
-POM_PACKAGING=jar
\ No newline at end of file
diff --git a/leakcanary-watcher/src/main/java/leakcanary/OnObjectRetainedListener.kt b/leakcanary-watcher/src/main/java/leakcanary/OnObjectRetainedListener.kt
deleted file mode 100644
index 17412172..00000000
--- a/leakcanary-watcher/src/main/java/leakcanary/OnObjectRetainedListener.kt
+++ /dev/null
@@ -1,12 +0,0 @@
-package leakcanary
-
-/**
- * Listener used by [ObjectWatcher] to report retained objects.
- */
-interface OnObjectRetainedListener {
-
-  /**
-   * A watched object became retained.
-   */
-  fun onObjectRetained()
-}
\ No newline at end of file
diff --git a/mkdocs.yml b/mkdocs.yml
index 9a8ca1dc..8fdce2f0 100644
--- a/mkdocs.yml
+++ b/mkdocs.yml
@@ -45,16 +45,20 @@ nav:
   - 'Fundamentals': fundamentals.md
   - 'Code recipes': recipes.md
   - 'FAQ': faq.md
+  - 'Shark': shark.md
   - 'Stack Overflow â': https://stackoverflow.com/questions/tagged/leakcanary?sort=active
-  - 'API reference':
+  - 'LeakCanary API':
     - 'LeakCanary': api/leakcanary-android-core/leakcanary/index.md
-    - 'LeakSentry': api/leakcanary-leaksentry/leakcanary/index.md
+    - 'ObjectWatcher Android': api/leakcanary-object-watcher-android/leakcanary/index.md
     - 'Extension: Instrumentation tests': api/leakcanary-android-instrumentation/leakcanary/index.md
     - 'Extension: Separate process': api/leakcanary-android-process/leakcanary/index.md
-    - 'Core: RefWatcher': api/leakcanary-watcher/leakcanary/index.md
-    - 'Core: Heap Analyzer': api/leakcanary-analyzer/leakcanary/index.md
-    - 'Core: Hprof Parser': api/leakcanary-haha/leakcanary/index.md
-    - 'Core: Logs': api/leakcanary-log/leakcanary/index.md
+    - 'Core: ObjectWatcher': api/leakcanary-object-watcher/leakcanary/index.md
+  - 'Shark API':
+    - 'Shark': api/shark/shark/index.md
+    - 'Extension: Shark Android': api/shark-android/shark/index.md
+    - 'Core: Graph': api/shark-graph/shark/index.md
+    - 'Core: Hprof': api/shark-hprof/shark/index.md
+    - 'Core: Logs': api/shark-log/shark/index.md
   - 'Change Log': changelog.md
   - 'Support': support.md
   - 'Upgrading to LeakCanary 2': upgrading-to-leakcanary-2.0.md
diff --git a/settings.gradle b/settings.gradle
index 3fddcaea..fd798995 100644
--- a/settings.gradle
+++ b/settings.gradle
@@ -1,12 +1,14 @@
-include ':leakcanary-analyzer'
 include ':leakcanary-android'
 include ':leakcanary-android-core'
 include ':leakcanary-android-instrumentation'
 include ':leakcanary-android-process'
-include ':leakcanary-cli'
-include ':leakcanary-fragments-androidx'
-include ':leakcanary-haha'
-include ':leakcanary-leaksentry'
-include ':leakcanary-log'
-include ':leakcanary-sample'
-include ':leakcanary-watcher'
\ No newline at end of file
+include ':leakcanary-android-sample'
+include ':leakcanary-object-watcher'
+include ':leakcanary-object-watcher-android'
+include ':leakcanary-object-watcher-android-androidx'
+include ':shark'
+include ':shark-android'
+include ':shark-cli'
+include ':shark-graph'
+include ':shark-hprof'
+include ':shark-log'
diff --git a/leakcanary-analyzer/build.gradle b/shark-android/build.gradle
similarity index 73%
rename from leakcanary-analyzer/build.gradle
rename to shark-android/build.gradle
index c3ae9ff5..61694414 100644
--- a/leakcanary-analyzer/build.gradle
+++ b/shark-android/build.gradle
@@ -5,8 +5,7 @@ sourceCompatibility = JavaVersion.VERSION_1_7
 targetCompatibility = JavaVersion.VERSION_1_7
 
 dependencies {
-  api project(':leakcanary-watcher')
-  api project(':leakcanary-haha')
+  api project(':shark')
 
   implementation deps.kotlin.stdlib
 
diff --git a/shark-android/gradle.properties b/shark-android/gradle.properties
new file mode 100644
index 00000000..e2aa8623
--- /dev/null
+++ b/shark-android/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=shark-android
+POM_NAME=Shark for Android heaps
+POM_PACKAGING=jar
diff --git a/shark-android/src/main/java/shark/AndroidBuildMirror.kt b/shark-android/src/main/java/shark/AndroidBuildMirror.kt
new file mode 100644
index 00000000..3c4ac5bb
--- /dev/null
+++ b/shark-android/src/main/java/shark/AndroidBuildMirror.kt
@@ -0,0 +1,31 @@
+package shark
+
+/**
+ * Caches values from the android.os.Build class in the heap dump.
+ * Retrieve a cached instances via [fromHeapGraph].
+ */
+class AndroidBuildMirror(
+  /**
+   * Value of android.os.Build.MANUFACTURER
+   */
+  val manufacturer: String,
+  /**
+   * Value of android.os.Build.VERSION.SDK_INT
+   */
+  val sdkInt: Int
+) {
+  companion object {
+    /**
+     * @see AndroidBuildMirror
+     */
+    fun fromHeapGraph(graph: HeapGraph): AndroidBuildMirror {
+      return graph.context.getOrPut(AndroidBuildMirror::class.java.name) {
+        val buildClass = graph.findClassByName("android.os.Build")!!
+        val versionClass = graph.findClassByName("android.os.Build\$VERSION")!!
+        val manufacturer = buildClass["MANUFACTURER"]!!.value.readAsJavaString()!!
+        val sdkInt = versionClass["SDK_INT"]!!.value.asInt!!
+        AndroidBuildMirror(manufacturer, sdkInt)
+      }
+    }
+  }
+}
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AndroidObjectInspectors.kt b/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
similarity index 67%
rename from leakcanary-analyzer/src/main/java/leakcanary/AndroidObjectInspectors.kt
rename to shark-android/src/main/java/shark/AndroidObjectInspectors.kt
index f8a24f40..fd9c4863 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/AndroidObjectInspectors.kt
+++ b/shark-android/src/main/java/shark/AndroidObjectInspectors.kt
@@ -13,12 +13,10 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package leakcanary
+package shark
 
-import leakcanary.GraphObjectRecord.GraphClassRecord
-import leakcanary.GraphObjectRecord.GraphInstanceRecord
-import leakcanary.internal.KeyedWeakReferenceMirror
-import kotlin.reflect.KClass
+import shark.AndroidObjectInspectors.Companion.appDefaults
+import shark.HeapObject.HeapInstance
 
 /**
  * A set of default [ObjectInspector]s that knows about common AOSP and library
@@ -36,62 +34,8 @@ import kotlin.reflect.KClass
  */
 enum class AndroidObjectInspectors : ObjectInspector {
 
-  KEYED_WEAK_REFERENCE {
-    override fun inspect(
-      graph: HprofGraph,
-      reporter: ObjectReporter
-    ) {
-      val references: List<KeyedWeakReferenceMirror> =
-        graph.context.getOrPut(KEYED_WEAK_REFERENCE.name) {
-          val keyedWeakReferenceClass = graph.findClassByClassName("leakcanary.KeyedWeakReference")
-
-          val heapDumpUptimeMillis = if (keyedWeakReferenceClass == null) {
-            null
-          } else {
-            keyedWeakReferenceClass["heapDumpUptimeMillis"]?.value?.asLong
-          }
-
-          if (heapDumpUptimeMillis == null) {
-            CanaryLog.d(
-                "${KeyedWeakReference::class.java.name}.heapDumpUptimeMillis field not found, " +
-                    "this must be a heap dump from an older version of LeakCanary."
-            )
-          }
-
-          val addedToContext: List<KeyedWeakReferenceMirror> = graph.instances
-              .filter { instance ->
-                val className = instance.className
-                className == "leakcanary.KeyedWeakReference" || className == "com.squareup.leakcanary.KeyedWeakReference"
-              }
-              .map { KeyedWeakReferenceMirror.fromInstance(it, heapDumpUptimeMillis) }
-              .filter { it.hasReferent }
-              .toList()
-          graph.context[KEYED_WEAK_REFERENCE.name] = addedToContext
-          addedToContext
-        }
-
-      val objectId = reporter.objectRecord.objectId
-      references.forEach { ref ->
-        if (ref.referent.value == objectId) {
-          reporter.reportLeaking("ObjectWatcher was watching this")
-          reporter.addLabel("key = ${ref.key}")
-          if (ref.name.isNotEmpty()) {
-            reporter.addLabel("name = ${ref.name}")
-          }
-          if (ref.watchDurationMillis != null) {
-            reporter.addLabel("watchDurationMillis = ${ref.watchDurationMillis}")
-          }
-          if (ref.retainedDurationMillis != null) {
-            reporter.addLabel("retainedDurationMillis = ${ref.retainedDurationMillis}")
-          }
-        }
-      }
-    }
-  },
-
   VIEW {
     override fun inspect(
-      graph: HprofGraph,
       reporter: ObjectReporter
     ) {
       reporter.whenInstanceOf("android.view.View") { instance ->
@@ -106,21 +50,23 @@ enum class AndroidObjectInspectors : ObjectInspector {
 
         val activityContext = mContext.unwrapActivityContext()
         if (activityContext == null) {
-          addLabel("mContext instance of ${mContext.className}, not wrapping activity")
+          addLabel("mContext instance of ${mContext.instanceClassName}, not wrapping activity")
         } else {
           val activityDescription =
             " with mDestroyed = " + (activityContext["android.app.Activity", "mDestroyed"]?.value?.asBoolean?.toString()
                 ?: "UNKNOWN")
           if (activityContext == mContext) {
-            addLabel("mContext instance of ${activityContext.className} $activityDescription")
+            addLabel(
+                "mContext instance of ${activityContext.instanceClassName} $activityDescription"
+            )
           } else {
             addLabel(
-                "mContext instance of ${mContext.className}, wrapping activity ${activityContext.className} $activityDescription"
+                "mContext instance of ${mContext.instanceClassName}, wrapping activity ${activityContext.instanceClassName} $activityDescription"
             )
           }
         }
 
-        addLabel("mContext = ${mContext.className}")
+        addLabel("mContext = ${mContext.instanceClassName}")
 
         if (activityContext != null && activityContext["android.app.Activity", "mDestroyed"]?.value?.asBoolean == true) {
           reportLeaking("View.mContext references a destroyed activity")
@@ -162,7 +108,6 @@ enum class AndroidObjectInspectors : ObjectInspector {
 
   ACTIVITY {
     override fun inspect(
-      graph: HprofGraph,
       reporter: ObjectReporter
     ) {
       reporter.whenInstanceOf("android.app.Activity") { instance ->
@@ -184,7 +129,6 @@ enum class AndroidObjectInspectors : ObjectInspector {
 
   CONTEXT_WRAPPER {
     override fun inspect(
-      graph: HprofGraph,
       reporter: ObjectReporter
     ) {
       reporter.whenInstanceOf("android.content.ContextWrapper") { instance ->
@@ -196,13 +140,13 @@ enum class AndroidObjectInspectors : ObjectInspector {
             if (mDestroyed != null) {
               if (mDestroyed.value.asBoolean!!) {
                 reportLeaking(
-                    "${instance.classSimpleName} wraps an Activity with Activity.mDestroyed true"
+                    "${instance.instanceClassSimpleName} wraps an Activity with Activity.mDestroyed true"
                 )
               } else {
                 // We can't assume it's not leaking, because this context might have a shorter lifecycle
                 // than the activity. So we'll just add a label.
                 addLabel(
-                    "${instance.classSimpleName} wraps an Activity with Activity.mDestroyed false"
+                    "${instance.instanceClassSimpleName} wraps an Activity with Activity.mDestroyed false"
                 )
               }
             }
@@ -214,7 +158,6 @@ enum class AndroidObjectInspectors : ObjectInspector {
 
   DIALOG {
     override fun inspect(
-      graph: HprofGraph,
       reporter: ObjectReporter
     ) {
       reporter.whenInstanceOf("android.app.Dialog") { instance ->
@@ -230,7 +173,6 @@ enum class AndroidObjectInspectors : ObjectInspector {
 
   APPLICATION {
     override fun inspect(
-      graph: HprofGraph,
       reporter: ObjectReporter
     ) {
       reporter.whenInstanceOf("android.app.Application") {
@@ -241,7 +183,6 @@ enum class AndroidObjectInspectors : ObjectInspector {
 
   INPUT_METHOD_MANAGER {
     override fun inspect(
-      graph: HprofGraph,
       reporter: ObjectReporter
     ) {
       reporter.whenInstanceOf("android.view.inputmethod.InputMethodManager") {
@@ -250,31 +191,8 @@ enum class AndroidObjectInspectors : ObjectInspector {
     }
   },
 
-  CLASSLOADER {
-    override fun inspect(
-      graph: HprofGraph,
-      reporter: ObjectReporter
-    ) {
-      reporter.whenInstanceOf(ClassLoader::class) {
-        reportNotLeaking("A ClassLoader is never leaking")
-      }
-    }
-  },
-
-  CLASS {
-    override fun inspect(
-      graph: HprofGraph,
-      reporter: ObjectReporter
-    ) {
-      if (reporter.objectRecord is GraphClassRecord) {
-        reporter.reportNotLeaking("a class is never leaking")
-      }
-    }
-  },
-
   FRAGMENT {
     override fun inspect(
-      graph: HprofGraph,
       reporter: ObjectReporter
     ) {
       reporter.whenInstanceOf("android.app.Fragment") { instance ->
@@ -294,7 +212,6 @@ enum class AndroidObjectInspectors : ObjectInspector {
 
   SUPPORT_FRAGMENT {
     override fun inspect(
-      graph: HprofGraph,
       reporter: ObjectReporter
     ) {
       reporter.whenInstanceOf("android.support.v4.app.Fragment") { instance ->
@@ -314,7 +231,6 @@ enum class AndroidObjectInspectors : ObjectInspector {
 
   ANDROIDX_FRAGMENT {
     override fun inspect(
-      graph: HprofGraph,
       reporter: ObjectReporter
     ) {
       reporter.whenInstanceOf("androidx.fragment.app.Fragment") { instance ->
@@ -334,7 +250,6 @@ enum class AndroidObjectInspectors : ObjectInspector {
 
   MESSAGE_QUEUE {
     override fun inspect(
-      graph: HprofGraph,
       reporter: ObjectReporter
     ) {
       reporter.whenInstanceOf("android.os.MessageQueue") { instance ->
@@ -353,7 +268,6 @@ enum class AndroidObjectInspectors : ObjectInspector {
 
   MORTAR_PRESENTER {
     override fun inspect(
-      graph: HprofGraph,
       reporter: ObjectReporter
     ) {
       reporter.whenInstanceOf("mortar.Presenter") { instance ->
@@ -370,7 +284,6 @@ enum class AndroidObjectInspectors : ObjectInspector {
 
   COORDINATOR {
     override fun inspect(
-      graph: HprofGraph,
       reporter: ObjectReporter
     ) {
       reporter.whenInstanceOf("com.squareup.coordinators.Coordinator") { instance ->
@@ -384,44 +297,8 @@ enum class AndroidObjectInspectors : ObjectInspector {
     }
   },
 
-  ANONYMOUS_CLASS {
-    override fun inspect(
-      graph: HprofGraph,
-      reporter: ObjectReporter
-    ) {
-      if (reporter.objectRecord is GraphInstanceRecord) {
-        val classRecord = reporter.objectRecord.instanceClass
-        if (classRecord.name.matches(HeapAnalyzer.ANONYMOUS_CLASS_NAME_PATTERN_REGEX)) {
-          val parentClassRecord = classRecord.superClass!!
-          if (parentClassRecord.name == "java.lang.Object") {
-            try {
-              // This is an anonymous class implementing an interface. The API does not give access
-              // to the interfaces implemented by the class. We check if it's in the class path and
-              // use that instead.
-              val actualClass = Class.forName(classRecord.name)
-              val interfaces = actualClass.interfaces
-              reporter.addLabel(
-                  if (interfaces.isNotEmpty()) {
-                    val implementedInterface = interfaces[0]
-                    "Anonymous class implementing ${implementedInterface.name}"
-                  } else {
-                    "Anonymous subclass of java.lang.Object"
-                  }
-              )
-            } catch (ignored: ClassNotFoundException) {
-            }
-          } else {
-            // Makes it easier to figure out which anonymous class we're looking at.
-            reporter.addLabel("Anonymous subclass of ${parentClassRecord.name}")
-          }
-        }
-      }
-    }
-  },
-
-  THREAD {
+  MAIN_THREAD {
     override fun inspect(
-      graph: HprofGraph,
       reporter: ObjectReporter
     ) {
       reporter.whenInstanceOf(Thread::class) { instance ->
@@ -429,14 +306,12 @@ enum class AndroidObjectInspectors : ObjectInspector {
         if (threadName == "main") {
           reportNotLeaking("the main thread always runs")
         }
-        addLabel("Thread name: '$threadName'")
       }
     }
   },
 
   WINDOW {
     override fun inspect(
-      graph: HprofGraph,
       reporter: ObjectReporter
     ) {
       reporter.whenInstanceOf("android.view.Window") { instance ->
@@ -453,7 +328,6 @@ enum class AndroidObjectInspectors : ObjectInspector {
 
   TOAST {
     override fun inspect(
-      graph: HprofGraph,
       reporter: ObjectReporter
     ) {
       reporter.whenInstanceOf("android.widget.Toast") { instance ->
@@ -481,42 +355,20 @@ enum class AndroidObjectInspectors : ObjectInspector {
     /** @see AndroidObjectInspectors */
     val appDefaults: List<ObjectInspector>
       get() {
-        return values().toList()
+        return values().toList() + ObjectInspectors.jdkDefaults
       }
   }
 }
 
-private infix fun GraphField.describedWithValue(valueDescription: String): String {
-  return "${classRecord.simpleName}#$name is $valueDescription"
-}
-
-/**
- * Runs [block] if [ObjectReporter.objectRecord] is an instance of [expectedClass].
- */
-inline fun ObjectReporter.whenInstanceOf(
-  expectedClass: KClass<out Any>,
-  action: ObjectReporter.(GraphInstanceRecord) -> Unit
-) {
-  whenInstanceOf(expectedClass.java.name, action)
-}
-
-/**
- * Runs [block] if [ObjectReporter.objectRecord] is an instance of [expectedClassName].
- */
-inline fun ObjectReporter.whenInstanceOf(
-  expectedClassName: String,
-  block: ObjectReporter.(GraphInstanceRecord) -> Unit
-) {
-  if (objectRecord is GraphInstanceRecord && objectRecord instanceOf expectedClassName) {
-    block(objectRecord)
-  }
+private infix fun HeapClassField.describedWithValue(valueDescription: String): String {
+  return "${declaringClass.simpleName}#$name is $valueDescription"
 }
 
 /**
- * Recursively unwraps `this` [GraphInstanceRecord] as a ContextWrapper until an Activity is found in which case it is
+ * Recursively unwraps `this` [HeapInstance] as a ContextWrapper until an Activity is found in which case it is
  * returned. Returns null if no activity was found.
  */
-fun GraphInstanceRecord.unwrapActivityContext(): GraphInstanceRecord? {
+fun HeapInstance.unwrapActivityContext(): HeapInstance? {
   if (this instanceOf "android.app.Activity") {
     return this
   }
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/AndroidReferenceMatchers.kt b/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt
similarity index 98%
rename from leakcanary-analyzer/src/main/java/leakcanary/AndroidReferenceMatchers.kt
rename to shark-android/src/main/java/shark/AndroidReferenceMatchers.kt
index 0da17501..aa01addd 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/AndroidReferenceMatchers.kt
+++ b/shark-android/src/main/java/shark/AndroidReferenceMatchers.kt
@@ -13,15 +13,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package leakcanary
-
-import leakcanary.AndroidReferenceMatchers.Companion.appDefaults
-import leakcanary.AndroidReferenceMatchers.Companion.buildKnownReferences
-import leakcanary.ReferenceMatcher.IgnoredReferenceMatcher
-import leakcanary.ReferenceMatcher.LibraryLeakReferenceMatcher
-import leakcanary.ReferencePattern.InstanceFieldPattern
-import leakcanary.ReferencePattern.JavaLocalPattern
-import leakcanary.ReferencePattern.StaticFieldPattern
+package shark
+
+import shark.AndroidReferenceMatchers.Companion.appDefaults
+import shark.AndroidReferenceMatchers.Companion.buildKnownReferences
+import shark.IgnoredReferenceMatcher
+import shark.LibraryLeakReferenceMatcher
+import shark.ReferencePattern.InstanceFieldPattern
+import shark.ReferencePattern.JavaLocalPattern
+import shark.ReferencePattern.StaticFieldPattern
 import java.lang.ref.PhantomReference
 import java.lang.ref.SoftReference
 import java.lang.ref.WeakReference
@@ -928,7 +928,7 @@ enum class AndroidReferenceMatchers {
       references: MutableList<ReferenceMatcher>
     ) {
       references += ignoredInstanceField(WeakReference::class.java.name, "referent")
-      references += ignoredInstanceField(KeyedWeakReference::class.java.name, "referent")
+      references += ignoredInstanceField("leakcanary.KeyedWeakReference", "referent")
       references += ignoredInstanceField(SoftReference::class.java.name, "referent")
       references += ignoredInstanceField(PhantomReference::class.java.name, "referent")
       references += ignoredInstanceField("java.lang.ref.Finalizer", "prev")
@@ -1039,6 +1039,7 @@ enum class AndroidReferenceMatchers {
 
     /**
      * Creates a [LibraryLeakReferenceMatcher] that matches a [StaticFieldPattern].
+     * [description] should convey what we know about this library leak.
      */
     fun staticFieldLeak(
       className: String,
@@ -1051,6 +1052,7 @@ enum class AndroidReferenceMatchers {
 
     /**
      * Creates a [LibraryLeakReferenceMatcher] that matches a [InstanceFieldPattern].
+     * [description] should convey what we know about this library leak.
      */
     fun instanceFieldLeak(
       className: String,
@@ -1070,7 +1072,7 @@ enum class AndroidReferenceMatchers {
           pattern = referencePattern,
           description = description,
           patternApplies = { graph ->
-            graph.androidBuildMirror.patternApplies()
+            AndroidBuildMirror.fromHeapGraph(graph).patternApplies()
           }
       )
     }
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt b/shark-android/src/test/java/shark/LegacyHprofTest.kt
similarity index 82%
rename from leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt
rename to shark-android/src/test/java/shark/LegacyHprofTest.kt
index 81d9cfc3..c3d88fc2 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LegacyHprofTest.kt
+++ b/shark-android/src/test/java/shark/LegacyHprofTest.kt
@@ -1,10 +1,5 @@
-package leakcanary.internal
+package shark
 
-import leakcanary.AndroidReferenceMatchers
-import leakcanary.AndroidObjectInspectors
-import leakcanary.HeapAnalysis
-import leakcanary.HeapAnalysisSuccess
-import leakcanary.HprofPrimitiveArrayStripper
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Test
 import java.io.File
@@ -66,17 +61,15 @@ class LegacyHprofTest {
     val classLoader = Thread.currentThread()
         .contextClassLoader
     val url = classLoader.getResource(fileName)
-    val hprofFile = File(url.path)
-    return hprofFile
+    return File(url.path)
   }
 
   private fun analyzeHprof(hprofFile: File): HeapAnalysisSuccess {
-    val analysis = hprofFile.checkForLeaks<HeapAnalysis>(
-        objectInspectors = AndroidObjectInspectors.appDefaults,
-        referenceMatchers = AndroidReferenceMatchers.appDefaults
+    val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
+    val analysis = heapAnalyzer.checkForLeaks(
+        hprofFile, AndroidReferenceMatchers.appDefaults, false, AndroidObjectInspectors.appDefaults
     )
-    print(analysis)
+    println(analysis)
     return analysis as HeapAnalysisSuccess
   }
-
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/resources/gc_root_in_non_primary_heap.hprof b/shark-android/src/test/resources/gc_root_in_non_primary_heap.hprof
similarity index 100%
rename from leakcanary-analyzer/src/test/resources/gc_root_in_non_primary_heap.hprof
rename to shark-android/src/test/resources/gc_root_in_non_primary_heap.hprof
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask_m.hprof b/shark-android/src/test/resources/leak_asynctask_m.hprof
similarity index 100%
rename from leakcanary-analyzer/src/test/resources/leak_asynctask_m.hprof
rename to shark-android/src/test/resources/leak_asynctask_m.hprof
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask_o.hprof b/shark-android/src/test/resources/leak_asynctask_o.hprof
similarity index 100%
rename from leakcanary-analyzer/src/test/resources/leak_asynctask_o.hprof
rename to shark-android/src/test/resources/leak_asynctask_o.hprof
diff --git a/leakcanary-analyzer/src/test/resources/leak_asynctask_pre_m.hprof b/shark-android/src/test/resources/leak_asynctask_pre_m.hprof
similarity index 100%
rename from leakcanary-analyzer/src/test/resources/leak_asynctask_pre_m.hprof
rename to shark-android/src/test/resources/leak_asynctask_pre_m.hprof
diff --git a/shark-cli/2019-07-22_13-53-07_572-com.example.leakcanary.hprof b/shark-cli/2019-07-22_13-53-07_572-com.example.leakcanary.hprof
new file mode 100644
index 00000000..456bc75d
Binary files /dev/null and b/shark-cli/2019-07-22_13-53-07_572-com.example.leakcanary.hprof differ
diff --git a/leakcanary-cli/build.gradle b/shark-cli/build.gradle
similarity index 78%
rename from leakcanary-cli/build.gradle
rename to shark-cli/build.gradle
index a2833274..16b662c3 100644
--- a/leakcanary-cli/build.gradle
+++ b/shark-cli/build.gradle
@@ -6,12 +6,12 @@ sourceCompatibility = JavaVersion.VERSION_1_7
 targetCompatibility = JavaVersion.VERSION_1_7
 
 dependencies {
-  api project(':leakcanary-analyzer')
+  api project(':shark-android')
 
   implementation deps.kotlin.stdlib
 }
 
-def mainClass = 'leakcanary.MainKt'
+def mainClass = 'shark.MainKt'
 
 application {
   mainClassName = mainClass
diff --git a/shark-cli/gradle.properties b/shark-cli/gradle.properties
new file mode 100644
index 00000000..8f2712b1
--- /dev/null
+++ b/shark-cli/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=shark-cli
+POM_NAME=Shark Command Line Interface
+POM_PACKAGING=jar
diff --git a/leakcanary-cli/src/main/java/leakcanary/CLILogger.kt b/shark-cli/src/main/java/shark/CLILogger.kt
similarity index 93%
rename from leakcanary-cli/src/main/java/leakcanary/CLILogger.kt
rename to shark-cli/src/main/java/shark/CLILogger.kt
index 59b328d4..ba5732e4 100644
--- a/leakcanary-cli/src/main/java/leakcanary/CLILogger.kt
+++ b/shark-cli/src/main/java/shark/CLILogger.kt
@@ -1,6 +1,6 @@
-package leakcanary
+package shark
 
-import leakcanary.CanaryLog.Logger
+import shark.SharkLog.Logger
 import java.io.PrintWriter
 import java.io.StringWriter
 
diff --git a/leakcanary-cli/src/main/java/leakcanary/Main.kt b/shark-cli/src/main/java/shark/Main.kt
similarity index 82%
rename from leakcanary-cli/src/main/java/leakcanary/Main.kt
rename to shark-cli/src/main/java/shark/Main.kt
index 9d5569d2..6db5d618 100644
--- a/leakcanary-cli/src/main/java/leakcanary/Main.kt
+++ b/shark-cli/src/main/java/shark/Main.kt
@@ -1,6 +1,6 @@
-package leakcanary
+package shark
 
-import leakcanary.AnalyzerProgressListener.Step
+import shark.OnAnalysisProgressListener.Step
 import java.io.File
 import java.text.SimpleDateFormat
 import java.util.Date
@@ -8,7 +8,7 @@ import java.util.Locale
 import java.util.concurrent.TimeUnit.SECONDS
 
 fun main(args: Array<String>) {
-  CanaryLog.logger = CLILogger()
+  SharkLog.logger = CLILogger()
   when {
     args.size == 2 && args[0] == "analyze-process" -> {
       val heapDumpFile = dumpHeap(args[1])
@@ -24,7 +24,7 @@ fun main(args: Array<String>) {
 fun printHelp() {
   val workingDirectory = File(System.getProperty("user.dir"))
 
-  CanaryLog.d(
+  SharkLog.d(
       """
     LeakCanary CLI
     Running in directory $workingDirectory
@@ -61,7 +61,7 @@ private fun dumpHeap(packageName: String): File {
   val (processName, processId) = if (matchingProcesses.size == 1) {
     matchingProcesses[0]
   } else if (matchingProcesses.isEmpty()) {
-    CanaryLog.d("No process matching \"$packageName\"")
+    SharkLog.d("No process matching \"$packageName\"")
     System.exit(1)
     throw RuntimeException("System exiting with error")
   } else {
@@ -69,7 +69,7 @@ private fun dumpHeap(packageName: String): File {
     if (matchingExactly != null) {
       matchingExactly
     } else {
-      CanaryLog.d(
+      SharkLog.d(
           "More than one process matches \"$packageName\" but none matches exactly: ${matchingProcesses.map { it.first }}"
       )
       System.exit(1)
@@ -84,25 +84,27 @@ private fun dumpHeap(packageName: String): File {
 
   val heapDumpDevicePath = "/data/local/tmp/$heapDumpFileName"
 
-  CanaryLog.d(
+  SharkLog.d(
       "Dumping heap for process \"$processName\" with pid $processId to $heapDumpDevicePath"
   )
 
-  runCommand(workingDirectory, "adb", "shell", "am", "dumpheap", processId, heapDumpDevicePath)
+  runCommand(
+      workingDirectory, "adb", "shell", "am", "dumpheap", processId, heapDumpDevicePath
+  )
 
   // Dump heap takes time but adb returns immediately.
   Thread.sleep(5000)
 
-  CanaryLog.d("Pulling $heapDumpDevicePath")
+  SharkLog.d("Pulling $heapDumpDevicePath")
 
   val pullResult = runCommand(workingDirectory, "adb", "pull", heapDumpDevicePath)
-  CanaryLog.d(pullResult)
-  CanaryLog.d("Removing $heapDumpDevicePath")
+  SharkLog.d(pullResult)
+  SharkLog.d("Removing $heapDumpDevicePath")
 
   runCommand(workingDirectory, "adb", "shell", "rm", heapDumpDevicePath)
 
   val heapDumpFile = File(workingDirectory, heapDumpFileName)
-  CanaryLog.d("Pulled heap dump to $heapDumpFile")
+  SharkLog.d("Pulled heap dump to $heapDumpFile")
 
   return heapDumpFile
 }
@@ -124,26 +126,24 @@ private fun runCommand(
 }
 
 private fun analyze(heapDumpFile: File) {
-  val listener = object : AnalyzerProgressListener {
-    override fun onProgressUpdate(step: Step) {
-      CanaryLog.d(step.name)
-    }
+  val listener = OnAnalysisProgressListener { step ->
+    SharkLog.d(step.name)
   }
 
   val heapAnalyzer = HeapAnalyzer(listener)
-  CanaryLog.d("Analyzing heap dump $heapDumpFile")
+  SharkLog.d("Analyzing heap dump $heapDumpFile")
   val heapAnalysis = heapAnalyzer.checkForLeaks(
       heapDumpFile, AndroidReferenceMatchers.appDefaults, true,
       AndroidObjectInspectors.appDefaults
   )
 
-  CanaryLog.d(heapAnalysis.toString())
+  SharkLog.d(heapAnalysis.toString())
 }
 
 private fun stripHprof(heapDumpFile: File) {
-  CanaryLog.d("Stripping primitive arrays in heap dump $heapDumpFile")
+  SharkLog.d("Stripping primitive arrays in heap dump $heapDumpFile")
   val stripper = HprofPrimitiveArrayStripper()
   val outputFile = stripper.stripPrimitiveArrays(heapDumpFile)
-  CanaryLog.d("Stripped primitive arrays to $outputFile")
+  SharkLog.d("Stripped primitive arrays to $outputFile")
 }
 
diff --git a/leakcanary-haha/build.gradle b/shark-graph/build.gradle
similarity index 79%
rename from leakcanary-haha/build.gradle
rename to shark-graph/build.gradle
index ee1d5a52..122838ce 100644
--- a/leakcanary-haha/build.gradle
+++ b/shark-graph/build.gradle
@@ -5,7 +5,7 @@ sourceCompatibility = JavaVersion.VERSION_1_7
 targetCompatibility = JavaVersion.VERSION_1_7
 
 dependencies {
-  api project(':leakcanary-log')
+  api project(':shark-hprof')
 
   implementation deps.kotlin.stdlib
   implementation deps.okio
diff --git a/shark-graph/gradle.properties b/shark-graph/gradle.properties
new file mode 100644
index 00000000..0049f0e5
--- /dev/null
+++ b/shark-graph/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=shark-graph
+POM_NAME=Shark Graph
+POM_PACKAGING=jar
diff --git a/leakcanary-haha/src/main/java/leakcanary/GraphContext.kt b/shark-graph/src/main/java/shark/GraphContext.kt
similarity index 95%
rename from leakcanary-haha/src/main/java/leakcanary/GraphContext.kt
rename to shark-graph/src/main/java/shark/GraphContext.kt
index 3fed69d6..63952f1a 100644
--- a/leakcanary-haha/src/main/java/leakcanary/GraphContext.kt
+++ b/shark-graph/src/main/java/shark/GraphContext.kt
@@ -1,7 +1,7 @@
-package leakcanary
+package shark
 
 /**
- * In memory store that can be used to store objects in a given [HprofGraph] instance.
+ * In memory store that can be used to store objects in a given [HeapGraph] instance.
  * This is a simple [MutableMap] of [String] to [Any], but with unsafe generics access.
  */
 class GraphContext {
diff --git a/shark-graph/src/main/java/shark/HeapClassField.kt b/shark-graph/src/main/java/shark/HeapClassField.kt
new file mode 100644
index 00000000..9d7b4b5d
--- /dev/null
+++ b/shark-graph/src/main/java/shark/HeapClassField.kt
@@ -0,0 +1,51 @@
+package shark
+
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HeapObject.HeapObjectArray
+import shark.HeapObject.HeapPrimitiveArray
+
+/**
+ * Represents a static field or an instance field.
+ */
+class HeapClassField(
+  /**
+   * The class this field was declared in.
+   */
+  val declaringClass: HeapClass,
+  /**
+   * Name of the field
+   */
+  val name: String,
+  /**
+   * Value of the field. Also see shorthands [valueAsClass], [valueAsInstance],
+   * [valueAsObjectArray], [valueAsPrimitiveArray].
+   */
+  val value: HeapValue
+) {
+
+  /**
+   * Return a [HeapClass] is [value] references a class, and null otherwise.
+   */
+  val valueAsClass: HeapClass?
+    get() = value.asObject?.asClass
+
+  /**
+   * Return a [HeapInstance] is [value] references an instance, and null otherwise.
+   */
+  val valueAsInstance: HeapInstance?
+    get() = value.asObject?.asInstance
+
+  /**
+   * Return a [HeapObjectArray] is [value] references an object array, and null otherwise.
+   */
+  val valueAsObjectArray: HeapObjectArray?
+    get() = value.asObject?.asObjectArray
+
+  /**
+   * Return a [HeapPrimitiveArray] is [value] references a primitive array, and null
+   * otherwise.
+   */
+  val valueAsPrimitiveArray: HeapPrimitiveArray?
+    get() = value.asObject?.asPrimitiveArray
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/HeapGraph.kt b/shark-graph/src/main/java/shark/HeapGraph.kt
new file mode 100644
index 00000000..908aa376
--- /dev/null
+++ b/shark-graph/src/main/java/shark/HeapGraph.kt
@@ -0,0 +1,55 @@
+package shark
+
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+
+/**
+ * Enables navigation through the heap graph of objects.
+ */
+interface HeapGraph {
+  val identifierByteSize: Int
+  /**
+   * In memory store that can be used to store objects this [HeapGraph] instance.
+   */
+  val context: GraphContext
+  /**
+   * All GC roots which type matches types known to this heap graph.
+   */
+  val gcRoots: List<GcRoot>
+  /**
+   * Sequence of all objects in the heap dump.
+   *
+   * This sequence does not trigger any IO reads.
+   */
+  val objects: Sequence<HeapObject>
+  /**
+   * Sequence of all classes in the heap dump.
+   *
+   * This sequence does not trigger any IO reads.
+   */
+  val classes: Sequence<HeapClass>
+  /**
+   * Sequence of all instances in the heap dump.
+   *
+   * This sequence does not trigger any IO reads.
+   */
+  val instances: Sequence<HeapInstance>
+
+  /**
+   * Returns the [HeapObject] corresponding to the provided [objectId], and throws
+   * [IllegalArgumentException] otherwise.
+   */
+  @Throws(IllegalArgumentException::class)
+  fun findObjectById(objectId: Long): HeapObject
+
+  /**
+   * Returns the [HeapClass] corresponding to the provided [className], or null if the
+   * class cannot be found.
+   */
+  fun findClassByName(className: String): HeapClass?
+
+  /**
+   * Returns true if the provided [objectId] exists in the heap dump.
+   */
+  fun objectExists(objectId: Long): Boolean
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/HeapObject.kt b/shark-graph/src/main/java/shark/HeapObject.kt
new file mode 100644
index 00000000..e7bd9778
--- /dev/null
+++ b/shark-graph/src/main/java/shark/HeapObject.kt
@@ -0,0 +1,565 @@
+package shark
+
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import shark.PrimitiveType.BOOLEAN
+import shark.PrimitiveType.BYTE
+import shark.PrimitiveType.CHAR
+import shark.PrimitiveType.DOUBLE
+import shark.PrimitiveType.FLOAT
+import shark.PrimitiveType.INT
+import shark.PrimitiveType.LONG
+import shark.PrimitiveType.SHORT
+import shark.ValueHolder.ReferenceHolder
+import shark.internal.IndexedObject.IndexedClass
+import shark.internal.IndexedObject.IndexedInstance
+import shark.internal.IndexedObject.IndexedObjectArray
+import shark.internal.IndexedObject.IndexedPrimitiveArray
+import java.nio.charset.Charset
+import kotlin.reflect.KClass
+
+/**
+ * An object in the heap dump.
+ */
+sealed class HeapObject {
+
+  /**
+   * The graph of objects in the heap, which you can use to navigate the heap.
+   */
+
+  abstract val graph: HeapGraph
+
+  /**
+   * The heap identifier of this object.
+   */
+  abstract val objectId: Long
+
+  /**
+   * Reads and returns the underlying [ObjectRecord].
+   *
+   * This may trigger IO reads.
+   */
+  abstract fun readRecord(): ObjectRecord
+
+  /**
+   * This [HeapObject] as a [HeapClass] if it is one, or null otherwise
+   */
+  val asClass: HeapClass?
+    get() = if (this is HeapClass) this else null
+
+  /**
+   * This [HeapObject] as a [HeapInstance] if it is one, or null otherwise
+   */
+  val asInstance: HeapInstance?
+    get() = if (this is HeapInstance) this else null
+
+  /**
+   * This [HeapObject] as a [HeapObjectArray] if it is one, or null otherwise
+   */
+  val asObjectArray: HeapObjectArray?
+    get() = if (this is HeapObjectArray) this else null
+
+  /**
+   * This [HeapObject] as a [HeapPrimitiveArray] if it is one, or null otherwise
+   */
+  val asPrimitiveArray: HeapPrimitiveArray?
+    get() = if (this is HeapPrimitiveArray) this else null
+
+  /**
+   * A class in the heap dump.
+   */
+  class HeapClass internal constructor(
+    private val hprofGraph: HprofHeapGraph,
+    private val indexedObject: IndexedClass,
+    override val objectId: Long
+  ) : HeapObject() {
+    override val graph: HeapGraph
+      get() = hprofGraph
+
+    /**
+     * The name of this class, identical to [Class.getName].
+     */
+    val name: String
+      get() = hprofGraph.className(objectId)
+
+    /**
+     * Returns [name] stripped of any string content before the last period (included).
+     */
+    val simpleName: String
+      get() = classSimpleName(name)
+
+    /**
+     * The total byte size of fields for instances of this class, as registered in the class dump.
+     * This includes the size of fields from superclasses.
+     *
+     * @see readFieldsByteSize
+     */
+    val instanceByteSize: Int
+      get() = indexedObject.instanceSize
+
+    /**
+     * The total byte size of fields for instances of this class, computed as the sum of the
+     * individual size of each field of this class. This does not include the size of fields from
+     * superclasses.
+     *
+     * This may trigger IO reads.
+     *
+     * @see instanceByteSize
+     */
+    fun readFieldsByteSize(): Int {
+      return readRecord()
+          .fields.sumBy {
+        if (it.type == PrimitiveType.REFERENCE_HPROF_TYPE) {
+          hprofGraph.identifierByteSize
+        } else PrimitiveType.byteSizeByHprofType.getValue(it.type)
+      }
+    }
+
+    /**
+     * The [HeapClass] representing the superclass of this [HeapClass]. If this [HeapClass]
+     * represents either the [Object] class or a primitive type, then
+     * null is returned. If this [HeapClass] represents an array class then the
+     * [HeapClass] object representing the [Object] class is returned.
+     */
+    val superclass: HeapClass?
+      get() {
+        if (indexedObject.superclassId == ValueHolder.NULL_REFERENCE) return null
+        return hprofGraph.findObjectById(indexedObject.superclassId) as HeapClass
+      }
+
+    /**
+     * The class hierarchy starting at this class (included) and ending at the [Object] class
+     * (included).
+     */
+    val classHierarchy: Sequence<HeapClass>
+      get() = generateSequence(this) { it.superclass }
+
+    /**
+     * All the subclasses (direct and indirect) of this class,
+     * in the order they were recorded in the heap dump.
+     */
+    val subclasses: Sequence<HeapClass>
+      get() = hprofGraph.classes.filter { it subclassOf this }
+
+    /**
+     * Returns true if [subclass] is a sub class of this [HeapClass].
+     */
+    infix fun superclassOf(subclass: HeapClass): Boolean {
+      return subclass.classHierarchy.any { it.objectId == objectId }
+    }
+
+    /**
+     * Returns true if [superclass] is a superclass of this [HeapClass].
+     */
+    infix fun subclassOf(superclass: HeapClass): Boolean {
+      return classHierarchy.any { it.objectId == superclass.objectId }
+    }
+
+    /**
+     * All instances of this class, including instances of subclasses of this class.
+     */
+    val instances: Sequence<HeapInstance>
+      get() = hprofGraph.instances.filter { it instanceOf this }
+
+    /**
+     * All direct instances of this class, ie excluding any instance of subclasses of this class.
+     */
+    val directInstances: Sequence<HeapInstance>
+      get() = hprofGraph.instances.filter { it.indexedObject.classId == objectId }
+
+    /**
+     * Reads and returns the underlying [ClassDumpRecord].
+     *
+     * This may trigger IO reads.
+     */
+    override fun readRecord(): ClassDumpRecord {
+      return hprofGraph.readClassDumpRecord(objectId, indexedObject)
+    }
+
+    /**
+     * The static fields of this class, as a sequence of [HeapClassField].
+     *
+     * This may trigger IO reads.
+     */
+    fun readStaticFields(): Sequence<HeapClassField> {
+      return readRecord().staticFields.asSequence()
+          .map { fieldRecord ->
+            HeapClassField(
+                this, hprofGraph.staticFieldName(fieldRecord),
+                HeapValue(hprofGraph, fieldRecord.value)
+            )
+          }
+    }
+
+    /**
+     * Returns a [HeapClassField] object that reflects the specified declared
+     * field of the class represented by this [HeapClass] object, or null if this field does not
+     * exist. The [name] parameter specifies the simple name of the desired field.
+     *
+     * Also available as a convenience operator: [get]
+     *
+     * This may trigger IO reads.
+     */
+    fun readStaticField(fieldName: String): HeapClassField? {
+      for (fieldRecord in readRecord().staticFields) {
+        if (hprofGraph.staticFieldName(fieldRecord) == fieldName) {
+          return HeapClassField(
+              this, hprofGraph.staticFieldName(fieldRecord),
+              HeapValue(hprofGraph, fieldRecord.value)
+          )
+        }
+      }
+      return null
+    }
+
+    /**
+     * @see readStaticField
+     */
+    operator fun get(fieldName: String) = readStaticField(fieldName)
+
+    override fun toString(): String {
+      return "class $name"
+    }
+  }
+
+  /**
+   * An instance in the heap dump.
+   */
+  class HeapInstance internal constructor(
+    private val hprofGraph: HprofHeapGraph,
+    internal val indexedObject: IndexedInstance,
+    override val objectId: Long,
+    /**
+     * Whether this is an instance of a primitive wrapper type.
+     */
+    val isPrimitiveWrapper: Boolean
+  ) : HeapObject() {
+
+    override val graph: HeapGraph
+      get() = hprofGraph
+
+    /**
+     * @see HeapClass.instanceByteSize
+     */
+    val byteSize
+      get() = instanceClass.instanceByteSize
+
+    /**
+     * The name of the class of this instance, identical to [Class.getName].
+     */
+    val instanceClassName: String
+      get() = hprofGraph.className(indexedObject.classId)
+
+    /**
+     * Returns [instanceClassName] stripped of any string content before the last period (included).
+     */
+    val instanceClassSimpleName: String
+      get() = classSimpleName(instanceClassName)
+
+    /**
+     * The class of this instance.
+     */
+    val instanceClass: HeapClass
+      get() = hprofGraph.findObjectById(indexedObject.classId) as HeapClass
+
+    /**
+     * Reads and returns the underlying [InstanceDumpRecord].
+     *
+     * This may trigger IO reads.
+     */
+    override fun readRecord(): InstanceDumpRecord {
+      return hprofGraph.readInstanceDumpRecord(objectId, indexedObject)
+    }
+
+    /**
+     * Returns true if this is an instance of the class named [className] or an instance of a
+     * subclass of that class.
+     */
+    infix fun instanceOf(className: String): Boolean =
+      instanceClass.classHierarchy.any { it.name == className }
+
+    /**
+     * Returns true if this is an instance of [expectedClass] or an instance of a subclass of that
+     * class.
+     */
+    infix fun instanceOf(expectedClass: KClass<*>) =
+      this instanceOf expectedClass.java.name
+
+    /**
+     * Returns true if this is an instance of [expectedClass] or an instance of a subclass of that
+     * class.
+     */
+    infix fun instanceOf(expectedClass: HeapClass) =
+      instanceClass.classHierarchy.any { it.objectId == expectedClass.objectId }
+
+    /**
+     * @see readField
+     */
+    fun readField(
+      declaringClass: KClass<out Any>,
+      fieldName: String
+    ): HeapClassField? {
+      return readField(declaringClass.java.name, fieldName)
+    }
+
+    /**
+     * Returns a [HeapClassField] object that reflects the specified declared
+     * field of the instance represented by this [HeapInstance] object, or null if this field does
+     * not exist. The [declaringClassName] specifies the class in which the desired field is
+     * declared, and the [fieldName] parameter specifies the simple name of the desired field.
+     *
+     * Also available as a convenience operator: [get]
+     *
+     * This may trigger IO reads.
+     */
+    fun readField(
+      declaringClassName: String,
+      fieldName: String
+    ): HeapClassField? {
+      return readFields().firstOrNull { field -> field.declaringClass.name == declaringClassName && field.name == fieldName }
+    }
+
+    /**
+     * @see readField
+     */
+    operator fun get(
+      declaringClass: KClass<out Any>,
+      fieldName: String
+    ): HeapClassField? {
+      return readField(declaringClass, fieldName)
+    }
+
+    /**
+     * @see readField
+     */
+    operator fun get(
+      declaringClassName: String,
+      fieldName: String
+    ) = readField(declaringClassName, fieldName)
+
+    /**
+     * The fields of this instance, as a sequence of [HeapClassField].
+     *
+     * This may trigger IO reads.
+     */
+    fun readFields(): Sequence<HeapClassField> {
+      val fieldReader by lazy {
+        hprofGraph.createFieldValuesReader(readRecord())
+      }
+      return instanceClass.classHierarchy
+          .map { heapClass ->
+            heapClass.readRecord()
+                .fields.asSequence()
+                .map { fieldRecord ->
+                  val fieldName = hprofGraph.fieldName(fieldRecord)
+                  val fieldValue = fieldReader.readValue(fieldRecord)
+                  HeapClassField(heapClass, fieldName, HeapValue(hprofGraph, fieldValue))
+                }
+          }
+          .flatten()
+    }
+
+    /**
+     * If this [HeapInstance] is an instance of the [String] class, returns a [String] instance
+     * with content that matches the string in the heap dump. Otherwise returns null.
+     *
+     * This may trigger IO reads.
+     */
+    fun readAsJavaString(): String? {
+      if (instanceClassName != "java.lang.String") {
+        return null
+      }
+
+      // JVM strings don't have a count field.
+      val count = this["java.lang.String", "count"]?.value?.asInt
+      if (count == 0) {
+        return ""
+      }
+
+      // Prior to API 26 String.value was a char array.
+      // Since API 26 String.value is backed by native code. The vast majority of strings in a
+      // heap dump are backed by a byte array, but we still find a few backed by a char array.
+      when (val valueRecord =
+        this["java.lang.String", "value"]!!.value.asObject!!.readRecord()) {
+        is CharArrayDump -> {
+          // < API 23
+          // As of Marshmallow, substrings no longer share their parent strings' char arrays
+          // eliminating the need for String.offset
+          // https://android-review.googlesource.com/#/c/83611/
+          val offset = this["java.lang.String", "offset"]?.value?.asInt
+
+          val chars = if (count != null && offset != null) {
+            // Handle heap dumps where all primitive arrays have been replaced with empty arrays,
+            // e.g. with HprofPrimitiveArrayStripper
+            val toIndex = if (offset + count > valueRecord.array.size) {
+              valueRecord.array.size
+            } else offset + count
+            valueRecord.array.copyOfRange(offset, toIndex)
+          } else {
+            valueRecord.array
+          }
+          return String(chars)
+        }
+        is ByteArrayDump -> {
+          return String(valueRecord.array, Charset.forName("UTF-8"))
+        }
+        else -> throw UnsupportedOperationException(
+            "'value' field ${this["java.lang.String", "value"]!!.value} was expected to be either" +
+                " a char or byte array in string instance with id $objectId"
+        )
+      }
+    }
+
+    override fun toString(): String {
+      return "instance @$objectId of $instanceClassName"
+    }
+  }
+
+  /**
+   * An object array in the heap dump.
+   */
+  class HeapObjectArray internal constructor(
+    private val hprofGraph: HprofHeapGraph,
+    private val indexedObject: IndexedObjectArray,
+    override val objectId: Long,
+    val isPrimitiveWrapperArray: Boolean
+  ) : HeapObject() {
+
+    override val graph: HeapGraph
+      get() = hprofGraph
+
+    /**
+     * The name of the class of this array, identical to [Class.getName].
+     */
+    val arrayClassName: String
+      get() = hprofGraph.className(indexedObject.arrayClassId)
+
+    /**
+     * Returns [arrayClassName] stripped of any string content before the last period (included).
+     */
+    val arrayClassSimpleName: String
+      get() = classSimpleName(arrayClassName)
+
+    /**
+     * The class of this array.
+     */
+    val arrayClass: HeapClass
+      get() = hprofGraph.findObjectById(indexedObject.arrayClassId) as HeapClass
+
+    /**
+     * The total byte shallow size of elements in this array.
+     */
+    fun readByteSize(): Int {
+      return readRecord().elementIds.size * hprofGraph.identifierByteSize
+    }
+
+    /**
+     * Reads and returns the underlying [ObjectArrayDumpRecord].
+     *
+     * This may trigger IO reads.
+     */
+    override fun readRecord(): ObjectArrayDumpRecord {
+      return hprofGraph.readObjectArrayDumpRecord(objectId, indexedObject)
+    }
+
+    /**
+     * The elements in this array, as a sequence of [HeapValue].
+     *
+     * This may trigger IO reads.
+     */
+    fun readElements(): Sequence<HeapValue> {
+      return readRecord().elementIds.asSequence()
+          .map { HeapValue(hprofGraph, ReferenceHolder(it)) }
+    }
+
+    override fun toString(): String {
+      return "object array @$objectId of $arrayClassName"
+    }
+  }
+
+  /**
+   * A primitive array in the heap dump.
+   */
+  class HeapPrimitiveArray internal constructor(
+    private val hprofGraph: HprofHeapGraph,
+    private val indexedObject: IndexedPrimitiveArray,
+    override val objectId: Long
+  ) : HeapObject() {
+
+    override val graph: HeapGraph
+      get() = hprofGraph
+
+    /**
+     * The total byte shallow size of elements in this array.
+     */
+    fun readByteSize(): Int {
+      return when (val record = readRecord()) {
+        is BooleanArrayDump -> record.array.size * PrimitiveType.BOOLEAN.byteSize
+        is CharArrayDump -> record.array.size * PrimitiveType.CHAR.byteSize
+        is FloatArrayDump -> record.array.size * PrimitiveType.FLOAT.byteSize
+        is DoubleArrayDump -> record.array.size * PrimitiveType.DOUBLE.byteSize
+        is ByteArrayDump -> record.array.size * PrimitiveType.BYTE.byteSize
+        is ShortArrayDump -> record.array.size * PrimitiveType.SHORT.byteSize
+        is IntArrayDump -> record.array.size * PrimitiveType.INT.byteSize
+        is LongArrayDump -> record.array.size * PrimitiveType.LONG.byteSize
+      }
+    }
+
+    /**
+     * The [PrimitiveType] of elements in this array.
+     */
+    val primitiveType: PrimitiveType
+      get() = indexedObject.primitiveType
+
+    /**
+     * The name of the class of this array, identical to [Class.getName].
+     */
+    val arrayClassName: String
+      get() = when (primitiveType) {
+        BOOLEAN -> "boolean[]"
+        CHAR -> "char[]"
+        FLOAT -> "float[]"
+        DOUBLE -> "double[]"
+        BYTE -> "byte[]"
+        SHORT -> "short[]"
+        INT -> "int[]"
+        LONG -> "long[]"
+      }
+
+    /**
+     * Reads and returns the underlying [PrimitiveArrayDumpRecord].
+     *
+     * This may trigger IO reads.
+     */
+    override fun readRecord(): PrimitiveArrayDumpRecord {
+      return hprofGraph.readPrimitiveArrayDumpRecord(objectId, indexedObject)
+    }
+
+    override fun toString(): String {
+      return "primitive array @$objectId of $arrayClassName"
+    }
+  }
+
+  companion object {
+    private fun classSimpleName(className: String): String {
+      val separator = className.lastIndexOf('.')
+      return if (separator == -1) {
+        className
+      } else {
+        className.substring(separator + 1)
+      }
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/HeapValue.kt b/shark-graph/src/main/java/shark/HeapValue.kt
new file mode 100644
index 00000000..ef2e2d15
--- /dev/null
+++ b/shark-graph/src/main/java/shark/HeapValue.kt
@@ -0,0 +1,124 @@
+package shark
+
+import shark.HeapObject.HeapInstance
+import shark.ValueHolder.BooleanHolder
+import shark.ValueHolder.ByteHolder
+import shark.ValueHolder.CharHolder
+import shark.ValueHolder.DoubleHolder
+import shark.ValueHolder.FloatHolder
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.ValueHolder.ReferenceHolder
+import shark.ValueHolder.ShortHolder
+
+/**
+ * Represents a value in the heap dump, which can be an object reference or
+ * a primitive type.
+ */
+class HeapValue(
+  /**
+   * The graph of objects in the heap, which you can use to navigate the heap.
+   */
+  val graph: HeapGraph,
+  /**
+   * Holds the actual value that this [HeapValue] represents.
+   */
+  val holder: ValueHolder
+) {
+
+  /**
+   * This [HeapValue] as a [Boolean] if it represents one, or null otherwise.
+   */
+  val asBoolean: Boolean?
+    get() = if (holder is BooleanHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as a [Char] if it represents one, or null otherwise.
+   */
+  val asChar: Char?
+    get() = if (holder is CharHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as a [Float] if it represents one, or null otherwise.
+   */
+  val asFloat: Float?
+    get() = if (holder is FloatHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as a [Double] if it represents one, or null otherwise.
+   */
+  val asDouble: Double?
+    get() = if (holder is DoubleHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as a [Byte] if it represents one, or null otherwise.
+   */
+  val asByte: Byte?
+    get() = if (holder is ByteHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as a [Short] if it represents one, or null otherwise.
+   */
+  val asShort: Short?
+    get() = if (holder is ShortHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as an [Int] if it represents one, or null otherwise.
+   */
+  val asInt: Int?
+    get() = if (holder is IntHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as a [Long] if it represents one, or null otherwise.
+   */
+  val asLong: Long?
+    get() = if (holder is LongHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as a [Long] if it represents an object reference, or null otherwise.
+   */
+  val asObjectId: Long?
+    get() = if (holder is ReferenceHolder) holder.value else null
+
+  /**
+   * This [HeapValue] as a [Long] if it represents a non null object reference, or null otherwise.
+   */
+  val asNonNullObjectId: Long?
+    get() = if (holder is ReferenceHolder && !holder.isNull) holder.value else null
+
+  /**
+   * True is this [HeapValue] represents a null object reference, false otherwise.
+   */
+  val isNullReference: Boolean
+    get() = holder is ReferenceHolder && holder.isNull
+
+  /**
+   * True is this [HeapValue] represents a non null object reference, false otherwise.
+   */
+  val isNonNullReference: Boolean
+    get() = holder is ReferenceHolder && !holder.isNull
+
+  /**
+   * The [HeapObject] referenced by this [HeapValue] if it represents a non null object reference,
+   * or null otherwise.
+   */
+  val asObject: HeapObject?
+    get() {
+      return if (holder is ReferenceHolder && !holder.isNull) {
+        return graph.findObjectById(holder.value)
+      } else {
+        null
+      }
+    }
+
+  /**
+   * If this [HeapValue] if it represents a non null object reference to an instance of the
+   * [String] class, returns a [String] instance with content that matches the string in the heap
+   * dump. Otherwise returns null.
+   *
+   * This may trigger IO reads.
+   */
+  fun readAsJavaString(): String? {
+    return asObject?.asInstance?.readAsJavaString()
+  }
+}
diff --git a/shark-graph/src/main/java/shark/HprofHeapGraph.kt b/shark-graph/src/main/java/shark/HprofHeapGraph.kt
new file mode 100644
index 00000000..c99f8c7f
--- /dev/null
+++ b/shark-graph/src/main/java/shark/HprofHeapGraph.kt
@@ -0,0 +1,192 @@
+package shark
+
+import okio.Buffer
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HeapObject.HeapObjectArray
+import shark.HeapObject.HeapPrimitiveArray
+import shark.HprofHeapGraph.Companion.indexHprof
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import shark.internal.FieldValuesReader
+import shark.internal.HprofInMemoryIndex
+import shark.internal.IndexedObject
+import shark.internal.IndexedObject.IndexedClass
+import shark.internal.IndexedObject.IndexedInstance
+import shark.internal.IndexedObject.IndexedObjectArray
+import shark.internal.IndexedObject.IndexedPrimitiveArray
+import shark.internal.LruCache
+
+/**
+ * A [HeapGraph] that reads from an indexed [Hprof]. Create a new instance with [indexHprof].
+ */
+class HprofHeapGraph internal constructor(
+  private val hprof: Hprof,
+  private val index: HprofInMemoryIndex
+) : HeapGraph {
+
+  override val identifierByteSize: Int get() = hprof.reader.identifierByteSize
+
+  override val context = GraphContext()
+
+  override val gcRoots: List<GcRoot>
+    get() = index.gcRoots()
+
+  override val objects: Sequence<HeapObject>
+    get() {
+      return index.indexedObjectSequence()
+          .map {
+            wrapIndexedObject(it.second, it.first)
+          }
+    }
+
+  override val classes: Sequence<HeapClass>
+    get() {
+      return index.indexedClassSequence()
+          .map {
+            val objectId = it.first
+            val indexedObject = it.second
+            HeapClass(this, indexedObject, objectId)
+          }
+    }
+
+  override val instances: Sequence<HeapInstance>
+    get() {
+      return index.indexedInstanceSequence()
+          .map {
+            val objectId = it.first
+            val indexedObject = it.second
+            val isPrimitiveWrapper = index.primitiveWrapperTypes.contains(indexedObject.classId)
+            HeapInstance(this, indexedObject, objectId, isPrimitiveWrapper)
+          }
+    }
+
+  // LRU cache size of 3000 is a sweet spot to balance hits vs memory usage.
+  // This is based on running InstrumentationLeakDetectorTest a bunch of time on a
+  // Pixel 2 XL API 28. Hit count was ~120K, miss count ~290K
+  private val objectCache = LruCache<Long, ObjectRecord>(3000)
+
+  override fun findObjectById(objectId: Long): HeapObject {
+    return wrapIndexedObject(index.indexedObject(objectId), objectId)
+  }
+
+  override fun findClassByName(className: String): HeapClass? {
+    val classId = index.classId(className)
+    return if (classId == null) {
+      null
+    } else {
+      return findObjectById(classId) as HeapClass
+    }
+  }
+
+  override fun objectExists(objectId: Long): Boolean {
+    return index.objectIdIsIndexed(objectId)
+  }
+
+  internal fun fieldName(fieldRecord: FieldRecord): String {
+    return index.hprofStringById(fieldRecord.nameStringId)
+  }
+
+  internal fun staticFieldName(fieldRecord: StaticFieldRecord): String {
+    return index.hprofStringById(fieldRecord.nameStringId)
+  }
+
+  internal fun createFieldValuesReader(record: InstanceDumpRecord): FieldValuesReader {
+    val buffer = Buffer()
+    buffer.write(record.fieldValues)
+
+    val reader = HprofReader(buffer, identifierByteSize)
+
+    return object : FieldValuesReader {
+      override fun readValue(field: FieldRecord): ValueHolder {
+        return reader.readValue(field.type)
+      }
+    }
+  }
+
+  internal fun className(classId: Long): String {
+    return index.className(classId)
+  }
+
+  internal fun readObjectArrayDumpRecord(
+    objectId: Long,
+    indexedObject: IndexedObjectArray
+  ): ObjectArrayDumpRecord {
+    return readObjectRecord(objectId, indexedObject) {
+      hprof.reader.readObjectArrayDumpRecord()
+    }
+  }
+
+  internal fun readPrimitiveArrayDumpRecord(
+    objectId: Long,
+    indexedObject: IndexedPrimitiveArray
+  ): PrimitiveArrayDumpRecord {
+    return readObjectRecord(objectId, indexedObject) {
+      hprof.reader.readPrimitiveArrayDumpRecord()
+    }
+  }
+
+  internal fun readClassDumpRecord(
+    objectId: Long,
+    indexedObject: IndexedClass
+  ): ClassDumpRecord {
+    return readObjectRecord(objectId, indexedObject) {
+      hprof.reader.readClassDumpRecord()
+    }
+  }
+
+  internal fun readInstanceDumpRecord(
+    objectId: Long,
+    indexedObject: IndexedInstance
+  ): InstanceDumpRecord {
+    return readObjectRecord(objectId, indexedObject) {
+      hprof.reader.readInstanceDumpRecord()
+    }
+  }
+
+  private fun <T : ObjectRecord> readObjectRecord(
+    objectId: Long,
+    indexedObject: IndexedObject,
+    readBlock: () -> T
+  ): T {
+    val objectRecordOrNull = objectCache[objectId]
+    @Suppress("UNCHECKED_CAST")
+    if (objectRecordOrNull != null) {
+      return objectRecordOrNull as T
+    }
+    hprof.moveReaderTo(indexedObject.position)
+    return readBlock().apply { objectCache.put(objectId, this) }
+  }
+
+  private fun wrapIndexedObject(
+    indexedObject: IndexedObject,
+    objectId: Long
+  ): HeapObject {
+    return when (indexedObject) {
+      is IndexedClass -> HeapClass(this, indexedObject, objectId)
+      is IndexedInstance -> {
+        val isPrimitiveWrapper = index.primitiveWrapperTypes.contains(indexedObject.classId)
+        HeapInstance(this, indexedObject, objectId, isPrimitiveWrapper)
+      }
+      is IndexedObjectArray -> {
+        val isPrimitiveWrapperArray =
+          index.primitiveWrapperTypes.contains(indexedObject.arrayClassId)
+        HeapObjectArray(this, indexedObject, objectId, isPrimitiveWrapperArray)
+      }
+      is IndexedPrimitiveArray -> HeapPrimitiveArray(this, indexedObject, objectId)
+    }
+  }
+
+  companion object {
+    fun indexHprof(hprof: Hprof): HeapGraph {
+      val index = HprofInMemoryIndex.createReadingHprof(hprof.reader)
+      return HprofHeapGraph(hprof, index)
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/shark-graph/src/main/java/shark/internal/FieldValuesReader.kt b/shark-graph/src/main/java/shark/internal/FieldValuesReader.kt
new file mode 100644
index 00000000..794b3bfe
--- /dev/null
+++ b/shark-graph/src/main/java/shark/internal/FieldValuesReader.kt
@@ -0,0 +1,8 @@
+package shark.internal
+
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+import shark.ValueHolder
+
+internal interface FieldValuesReader {
+  fun readValue(field: FieldRecord): ValueHolder
+}
\ No newline at end of file
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/HprofInMemoryIndex.kt b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
similarity index 58%
rename from leakcanary-haha/src/main/java/leakcanary/internal/HprofInMemoryIndex.kt
rename to shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
index a4e915a4..2b6976a8 100644
--- a/leakcanary-haha/src/main/java/leakcanary/internal/HprofInMemoryIndex.kt
+++ b/shark-graph/src/main/java/shark/internal/HprofInMemoryIndex.kt
@@ -1,38 +1,38 @@
-package leakcanary.internal
-
-import leakcanary.GcRoot
-import leakcanary.GcRoot.JavaFrame
-import leakcanary.GcRoot.JniGlobal
-import leakcanary.GcRoot.JniLocal
-import leakcanary.GcRoot.JniMonitor
-import leakcanary.GcRoot.MonitorUsed
-import leakcanary.GcRoot.NativeStack
-import leakcanary.GcRoot.StickyClass
-import leakcanary.GcRoot.ThreadBlock
-import leakcanary.GcRoot.ThreadObject
-import leakcanary.HprofPushRecordsParser.OnRecordListener
-import leakcanary.HprofReader
-import leakcanary.PrimitiveType
-import leakcanary.Record
-import leakcanary.Record.HeapDumpRecord.GcRootRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
-import leakcanary.Record.LoadClassRecord
-import leakcanary.Record.StringRecord
-import leakcanary.internal.IndexedObject.IndexedClass
-import leakcanary.internal.IndexedObject.IndexedInstance
-import leakcanary.internal.IndexedObject.IndexedObjectArray
-import leakcanary.internal.IndexedObject.IndexedPrimitiveArray
+package shark.internal
+
+import shark.GcRoot
+import shark.GcRoot.JavaFrame
+import shark.GcRoot.JniGlobal
+import shark.GcRoot.JniLocal
+import shark.GcRoot.JniMonitor
+import shark.GcRoot.MonitorUsed
+import shark.GcRoot.NativeStack
+import shark.GcRoot.StickyClass
+import shark.GcRoot.ThreadBlock
+import shark.GcRoot.ThreadObject
+import shark.HprofReader
+import shark.HprofRecord
+import shark.HprofRecord.HeapDumpRecord.GcRootRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import shark.HprofRecord.LoadClassRecord
+import shark.HprofRecord.StringRecord
+import shark.OnHprofRecordListener
+import shark.PrimitiveType
+import shark.internal.IndexedObject.IndexedClass
+import shark.internal.IndexedObject.IndexedInstance
+import shark.internal.IndexedObject.IndexedObjectArray
+import shark.internal.IndexedObject.IndexedPrimitiveArray
 import kotlin.reflect.KClass
 
 /**
@@ -43,13 +43,8 @@ internal class HprofInMemoryIndex private constructor(
   private val classNames: LongToLongSparseArray,
   private val objectIndex: LongToObjectSparseArray<IndexedObject>,
   private val gcRoots: List<GcRoot>,
-  private val typeSizes: Map<Int, Int>,
   val primitiveWrapperTypes: Set<Long>
 ) {
-  val idSize: Int
-    get() = typeSizes.getValue(HprofReader.OBJECT_TYPE)
-
-  fun sizeOfFieldType(hprofType: Int): Int = typeSizes.getValue(hprofType)
 
   fun hprofStringById(id: Long): String {
     return hprofStringCache[id] ?: throw IllegalArgumentException("Hprof string $id not in cache")
@@ -96,9 +91,9 @@ internal class HprofInMemoryIndex private constructor(
     return objectIndex[objectId] != null
   }
 
-  class Builder(
+  private class Builder(
     private val indexedGcRootsTypes: Set<KClass<out GcRoot>>
-  ) : OnRecordListener {
+  ) : OnHprofRecordListener {
     /**
      * Map of string id to string
      * This currently keeps all the hprof strings that we could care about: class names,
@@ -119,7 +114,8 @@ internal class HprofInMemoryIndex private constructor(
      * Object id to [IndexedObject].
      * The id can be for classes instances, classes, object arrays and primitive arrays
      */
-    private val objectIndex = LongToObjectSparseArray<IndexedObject>(250000)
+    private val objectIndex =
+      LongToObjectSparseArray<IndexedObject>(250000)
 
     /**
      * Class ids for primitive wrapper types
@@ -133,30 +129,10 @@ internal class HprofInMemoryIndex private constructor(
 
     private val gcRoots = mutableListOf<GcRoot>()
 
-    private lateinit var typeSizes: Map<Int, Int>
-    private var consumed = false
-
-    override fun recordTypes(): Set<KClass<out Record>> = setOf(
-        StringRecord::class,
-        LoadClassRecord::class,
-        ClassDumpRecord::class,
-        InstanceDumpRecord::class,
-        ObjectArrayDumpRecord::class,
-        PrimitiveArrayDumpRecord::class,
-        GcRootRecord::class
-    )
-
-    override fun onTypeSizesAvailable(typeSizes: Map<Int, Int>) {
-      this.typeSizes = typeSizes
-    }
-
-    override fun onRecord(
+    override fun onHprofRecord(
       position: Long,
-      record: Record
+      record: HprofRecord
     ) {
-      if (consumed) {
-        throw IllegalStateException("This builder instance already produced a HprofInMemoryIndex")
-      }
       when (record) {
         is StringRecord -> {
           if (PRIMITIVE_WRAPPER_TYPES.contains(record.string)) {
@@ -178,7 +154,7 @@ internal class HprofInMemoryIndex private constructor(
           }
         }
         is ClassDumpRecord -> {
-          objectIndex[record.id] = IndexedClass(position, record.superClassId, record.instanceSize)
+          objectIndex[record.id] = IndexedClass(position, record.superclassId, record.instanceSize)
         }
         is InstanceDumpRecord -> {
           objectIndex[record.id] = IndexedInstance(position, record.classId)
@@ -203,11 +179,9 @@ internal class HprofInMemoryIndex private constructor(
     }
 
     fun buildIndex(): HprofInMemoryIndex {
-      consumed = true
       // Passing references to avoid copying the underlying data structures.
       return HprofInMemoryIndex(
           hprofStringCache, classNames, objectIndex, gcRoots,
-          typeSizes,
           primitiveWrapperTypes
       )
     }
@@ -222,36 +196,45 @@ internal class HprofInMemoryIndex private constructor(
         Int::class.java.name, Long::class.java.name
     )
 
-    fun createOnRecordListener(
-      indexedGcRootTypes: Set<KClass<out GcRoot>> = setOf(
-          JniGlobal::class,
-          JavaFrame::class,
-          JniLocal::class,
-          MonitorUsed::class,
-          NativeStack::class,
-          StickyClass::class,
-          ThreadBlock::class,
-          // ThreadObject points to threads, which we need to find the thread that a JavaLocalPattern
-          // belongs to
-          ThreadObject::class,
-          JniMonitor::class
-          /*
-          Not included here:
-
-          VmInternal: Ignoring because we've got 150K of it, but is this the right thing
-          to do? What's VmInternal exactly? History does not go further than
-          https://android.googlesource.com/platform/dalvik2/+/refs/heads/master/hit/src/com/android/hit/HprofParser.java#77
-          We should log to figure out what objects VmInternal points to.
-
-          ReferenceCleanup: We used to keep it, but the name doesn't seem like it should create a leak.
-
-          Unknown: it's unknown, should we care?
-
-          We definitely don't care about those for leak finding: InternedString, Finalizing, Debugger, Unreachable
-           */
+    fun createReadingHprof(reader: HprofReader, indexedGcRootTypes: Set<KClass<out GcRoot>> = setOf(
+        JniGlobal::class,
+        JavaFrame::class,
+        JniLocal::class,
+        MonitorUsed::class,
+        NativeStack::class,
+        StickyClass::class,
+        ThreadBlock::class,
+        // ThreadObject points to threads, which we need to find the thread that a JavaLocalPattern
+        // belongs to
+        ThreadObject::class,
+        JniMonitor::class
+        /*
+        Not included here:
+
+        VmInternal: Ignoring because we've got 150K of it, but is this the right thing
+        to do? What's VmInternal exactly? History does not go further than
+        https://android.googlesource.com/platform/dalvik2/+/refs/heads/master/hit/src/com/android/hit/HprofParser.java#77
+        We should log to figure out what objects VmInternal points to.
+
+        ReferenceCleanup: We used to keep it, but the name doesn't seem like it should create a leak.
+
+        Unknown: it's unknown, should we care?
+
+        We definitely don't care about those for leak finding: InternedString, Finalizing, Debugger, Unreachable
+         */
+    )): HprofInMemoryIndex {
+      val recordTypes = setOf(
+          StringRecord::class,
+          LoadClassRecord::class,
+          ClassDumpRecord::class,
+          InstanceDumpRecord::class,
+          ObjectArrayDumpRecord::class,
+          PrimitiveArrayDumpRecord::class,
+          GcRootRecord::class
       )
-    ): Builder {
-      return Builder(indexedGcRootTypes)
+      val indexBuilderListener = Builder(indexedGcRootTypes)
+      reader.readHprofRecords(recordTypes, indexBuilderListener)
+      return indexBuilderListener.buildIndex()
     }
 
   }
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/IndexedObject.kt b/shark-graph/src/main/java/shark/internal/IndexedObject.kt
similarity index 88%
rename from leakcanary-haha/src/main/java/leakcanary/internal/IndexedObject.kt
rename to shark-graph/src/main/java/shark/internal/IndexedObject.kt
index 925fe8f1..007beb80 100644
--- a/leakcanary-haha/src/main/java/leakcanary/internal/IndexedObject.kt
+++ b/shark-graph/src/main/java/shark/internal/IndexedObject.kt
@@ -1,13 +1,13 @@
-package leakcanary.internal
+package shark.internal
 
-import leakcanary.PrimitiveType
+import shark.PrimitiveType
 
 internal sealed class IndexedObject {
   abstract val position: Long
 
   class IndexedClass(
     override val position: Long,
-    val superClassId: Long,
+    val superclassId: Long,
     val instanceSize: Int
   ) : IndexedObject()
 
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/LongToIntSparseArray.kt b/shark-graph/src/main/java/shark/internal/LongToIntSparseArray.kt
similarity index 62%
rename from leakcanary-haha/src/main/java/leakcanary/internal/LongToIntSparseArray.kt
rename to shark-graph/src/main/java/shark/internal/LongToIntSparseArray.kt
index 4f701ae1..e4ac75f9 100644
--- a/leakcanary-haha/src/main/java/leakcanary/internal/LongToIntSparseArray.kt
+++ b/shark-graph/src/main/java/shark/internal/LongToIntSparseArray.kt
@@ -1,10 +1,26 @@
-package leakcanary.internal
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package shark.internal
 
-import leakcanary.internal.SparseArrayUtils.appendInt
-import leakcanary.internal.SparseArrayUtils.appendLong
-import leakcanary.internal.SparseArrayUtils.binarySearch
-import leakcanary.internal.SparseArrayUtils.insertInt
-import leakcanary.internal.SparseArrayUtils.insertLong
+import shark.internal.SparseArrayUtils.appendInt
+import shark.internal.SparseArrayUtils.appendLong
+import shark.internal.SparseArrayUtils.binarySearch
+import shark.internal.SparseArrayUtils.insertInt
+import shark.internal.SparseArrayUtils.insertLong
 
 /**
  * Same as [LongToLongSparseArray] but long to int instead.
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/LongToLongSparseArray.kt b/shark-graph/src/main/java/shark/internal/LongToLongSparseArray.kt
similarity index 69%
rename from leakcanary-haha/src/main/java/leakcanary/internal/LongToLongSparseArray.kt
rename to shark-graph/src/main/java/shark/internal/LongToLongSparseArray.kt
index 4a9dd23c..0c165cac 100644
--- a/leakcanary-haha/src/main/java/leakcanary/internal/LongToLongSparseArray.kt
+++ b/shark-graph/src/main/java/shark/internal/LongToLongSparseArray.kt
@@ -1,8 +1,24 @@
-package leakcanary.internal
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package shark.internal
 
-import leakcanary.internal.SparseArrayUtils.appendLong
-import leakcanary.internal.SparseArrayUtils.binarySearch
-import leakcanary.internal.SparseArrayUtils.insertLong
+import shark.internal.SparseArrayUtils.appendLong
+import shark.internal.SparseArrayUtils.binarySearch
+import shark.internal.SparseArrayUtils.insertLong
 
 /**
  * Based on android.util.LongSparseArray, but with several tweaks:
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/LongToObjectSparseArray.kt b/shark-graph/src/main/java/shark/internal/LongToObjectSparseArray.kt
similarity index 60%
rename from leakcanary-haha/src/main/java/leakcanary/internal/LongToObjectSparseArray.kt
rename to shark-graph/src/main/java/shark/internal/LongToObjectSparseArray.kt
index 3c36482a..e7452bf6 100644
--- a/leakcanary-haha/src/main/java/leakcanary/internal/LongToObjectSparseArray.kt
+++ b/shark-graph/src/main/java/shark/internal/LongToObjectSparseArray.kt
@@ -1,10 +1,26 @@
-package leakcanary.internal
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package shark.internal
 
-import leakcanary.internal.SparseArrayUtils.appendLong
-import leakcanary.internal.SparseArrayUtils.appendObject
-import leakcanary.internal.SparseArrayUtils.binarySearch
-import leakcanary.internal.SparseArrayUtils.insertLong
-import leakcanary.internal.SparseArrayUtils.insertObject
+import shark.internal.SparseArrayUtils.appendLong
+import shark.internal.SparseArrayUtils.appendObject
+import shark.internal.SparseArrayUtils.binarySearch
+import shark.internal.SparseArrayUtils.insertLong
+import shark.internal.SparseArrayUtils.insertObject
 
 /**
  * Same as [LongToLongSparseArray] but long to object instead.
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/LongToStringSparseArray.kt b/shark-graph/src/main/java/shark/internal/LongToStringSparseArray.kt
similarity index 60%
rename from leakcanary-haha/src/main/java/leakcanary/internal/LongToStringSparseArray.kt
rename to shark-graph/src/main/java/shark/internal/LongToStringSparseArray.kt
index 67ec9435..b17d9531 100644
--- a/leakcanary-haha/src/main/java/leakcanary/internal/LongToStringSparseArray.kt
+++ b/shark-graph/src/main/java/shark/internal/LongToStringSparseArray.kt
@@ -1,10 +1,26 @@
-package leakcanary.internal
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package shark.internal
 
-import leakcanary.internal.SparseArrayUtils.appendLong
-import leakcanary.internal.SparseArrayUtils.appendString
-import leakcanary.internal.SparseArrayUtils.binarySearch
-import leakcanary.internal.SparseArrayUtils.insertLong
-import leakcanary.internal.SparseArrayUtils.insertString
+import shark.internal.SparseArrayUtils.appendLong
+import shark.internal.SparseArrayUtils.appendString
+import shark.internal.SparseArrayUtils.binarySearch
+import shark.internal.SparseArrayUtils.insertLong
+import shark.internal.SparseArrayUtils.insertString
 
 /**
  * Same as [LongToLongSparseArray] but long to string instead.
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/LruCache.kt b/shark-graph/src/main/java/shark/internal/LruCache.kt
similarity index 98%
rename from leakcanary-haha/src/main/java/leakcanary/internal/LruCache.kt
rename to shark-graph/src/main/java/shark/internal/LruCache.kt
index 46d81d9b..aae02c72 100644
--- a/leakcanary-haha/src/main/java/leakcanary/internal/LruCache.kt
+++ b/shark-graph/src/main/java/shark/internal/LruCache.kt
@@ -1,4 +1,4 @@
-package leakcanary.internal
+package shark.internal
 
 import java.util.LinkedHashMap
 import kotlin.collections.MutableMap.MutableEntry
diff --git a/leakcanary-haha/src/main/java/leakcanary/internal/SparseArrayUtils.kt b/shark-graph/src/main/java/shark/internal/SparseArrayUtils.kt
similarity index 87%
rename from leakcanary-haha/src/main/java/leakcanary/internal/SparseArrayUtils.kt
rename to shark-graph/src/main/java/shark/internal/SparseArrayUtils.kt
index 8a3e0557..a23a5ab5 100644
--- a/leakcanary-haha/src/main/java/leakcanary/internal/SparseArrayUtils.kt
+++ b/shark-graph/src/main/java/shark/internal/SparseArrayUtils.kt
@@ -1,4 +1,20 @@
-package leakcanary.internal
+/*
+ * Copyright (C) 2009 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package shark.internal
 
 internal object SparseArrayUtils {
 
diff --git a/leakcanary-haha/src/test/java/leakcanary/HprofPrimitiveArrayStripperTest.kt b/shark-graph/src/test/java/shark/HprofPrimitiveArrayStripperTest.kt
similarity index 71%
rename from leakcanary-haha/src/test/java/leakcanary/HprofPrimitiveArrayStripperTest.kt
rename to shark-graph/src/test/java/shark/HprofPrimitiveArrayStripperTest.kt
index bc5b33fa..cb2b9fb4 100644
--- a/leakcanary-haha/src/test/java/leakcanary/HprofPrimitiveArrayStripperTest.kt
+++ b/shark-graph/src/test/java/shark/HprofPrimitiveArrayStripperTest.kt
@@ -1,14 +1,14 @@
-package leakcanary
+package shark
 
-import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
-import leakcanary.PrimitiveType.BOOLEAN
-import leakcanary.PrimitiveType.CHAR
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TemporaryFolder
+import shark.HeapObject.HeapPrimitiveArray
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.PrimitiveType.BOOLEAN
+import shark.PrimitiveType.CHAR
 import java.io.File
 
 class HprofPrimitiveArrayStripperTest {
@@ -34,7 +34,7 @@ class HprofPrimitiveArrayStripperTest {
 
     strippedFile.readHprof { graph ->
       val booleanArrays = graph.objects
-          .filter { it is GraphPrimitiveArrayRecord && it.primitiveType == BOOLEAN }
+          .filter { it is HeapPrimitiveArray && it.primitiveType == BOOLEAN }
           .map { it.readRecord() as BooleanArrayDump }
           .toList()
       assertThat(booleanArrays).hasSize(1)
@@ -42,7 +42,7 @@ class HprofPrimitiveArrayStripperTest {
       assertThat(booleanArrays[0].array).isEmpty()
 
       val charArrays = graph.objects
-          .filter { it is GraphPrimitiveArrayRecord && it.primitiveType == CHAR }
+          .filter { it is HeapPrimitiveArray && it.primitiveType == CHAR }
           .map { it.readRecord() as CharArrayDump }
           .toList()
       assertThat(charArrays).hasSize(1)
@@ -52,7 +52,7 @@ class HprofPrimitiveArrayStripperTest {
   }
 
   private fun File.writeRecords(
-    records: List<Record>
+    records: List<HprofRecord>
   ) {
     HprofWriter.open(this)
         .use { writer ->
@@ -62,11 +62,11 @@ class HprofPrimitiveArrayStripperTest {
         }
   }
 
-  fun File.readHprof(block: (HprofGraph) -> Unit) {
-    val (graph, closeable) = HprofGraph.readHprof(this)
-    closeable.use {
-      block(graph)
-    }
+  fun File.readHprof(block: (HeapGraph) -> Unit) {
+    Hprof.open(this)
+        .use { hprof ->
+          block(HprofHeapGraph.indexHprof(hprof))
+        }
   }
 
 }
\ No newline at end of file
diff --git a/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt b/shark-graph/src/test/java/shark/HprofWriterTest.kt
similarity index 73%
rename from leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt
rename to shark-graph/src/test/java/shark/HprofWriterTest.kt
index 5544321f..68ff199f 100644
--- a/leakcanary-haha/src/test/java/leakcanary/HprofWriterTest.kt
+++ b/shark-graph/src/test/java/shark/HprofWriterTest.kt
@@ -1,16 +1,16 @@
-package leakcanary
+package shark
 
-import leakcanary.HeapValue.ObjectReference
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-import leakcanary.Record.LoadClassRecord
-import leakcanary.Record.StringRecord
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TemporaryFolder
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.HprofRecord.LoadClassRecord
+import shark.HprofRecord.StringRecord
+import shark.ValueHolder.ReferenceHolder
 import java.io.File
 
 class HprofWriterTest {
@@ -30,7 +30,9 @@ class HprofWriterTest {
     hprofFile.writeRecords(records)
 
     hprofFile.readHprof { graph ->
-      val treasureChestClass = graph.findClassByClassName(TREASURE_CHEST_CLASS_NAME)!!
+      val treasureChestClass = graph.findClassByName(
+          TREASURE_CHEST_CLASS_NAME
+      )!!
       val baguetteInstance =
         treasureChestClass[CONTENT_FIELD_NAME]!!.value.asObject!!.asInstance!!
 
@@ -40,11 +42,14 @@ class HprofWriterTest {
     }
   }
 
-  private fun createRecords(): List<Record> {
+  private fun createRecords(): List<HprofRecord> {
     val magicWandClassName = StringRecord(id, MAGIC_WAND_CLASS_NAME)
     val baguetteClassName = StringRecord(id, BAGUETTE_CLASS_NAME)
     val answerFieldName = StringRecord(id, ANSWER_FIELD_NAME)
-    val treasureChestClassName = StringRecord(id, TREASURE_CHEST_CLASS_NAME)
+    val treasureChestClassName = StringRecord(
+        id,
+        TREASURE_CHEST_CLASS_NAME
+    )
     val contentFieldName = StringRecord(id, CONTENT_FIELD_NAME)
     val loadMagicWandClass = LoadClassRecord(1, id, 1, magicWandClassName.id)
     val loadBaguetteClass = LoadClassRecord(1, id, 1, baguetteClassName.id)
@@ -52,7 +57,7 @@ class HprofWriterTest {
     val magicWandClassDump = ClassDumpRecord(
         id = loadMagicWandClass.id,
         stackTraceSerialNumber = 1,
-        superClassId = 0,
+        superclassId = 0,
         classLoaderId = 0,
         signersId = 0,
         protectionDomainId = 0,
@@ -63,13 +68,13 @@ class HprofWriterTest {
     val baguetteClassDump = ClassDumpRecord(
         id = loadBaguetteClass.id,
         stackTraceSerialNumber = 1,
-        superClassId = loadMagicWandClass.id,
+        superclassId = loadMagicWandClass.id,
         classLoaderId = 0,
         signersId = 0,
         protectionDomainId = 0,
         instanceSize = 0,
         staticFields = emptyList(),
-        fields = listOf(FieldRecord(answerFieldName.id, HprofReader.INT_TYPE))
+        fields = listOf(FieldRecord(answerFieldName.id, PrimitiveType.INT.hprofType))
     )
 
     val baguetteInstanceDump = InstanceDumpRecord(
@@ -82,15 +87,15 @@ class HprofWriterTest {
     val treasureChestClassDump = ClassDumpRecord(
         id = loadTreasureChestClass.id,
         stackTraceSerialNumber = 1,
-        superClassId = 0,
+        superclassId = 0,
         classLoaderId = 0,
         signersId = 0,
         protectionDomainId = 0,
         instanceSize = 0,
         staticFields = listOf(
             StaticFieldRecord(
-                contentFieldName.id, HprofReader.OBJECT_TYPE,
-                ObjectReference(baguetteInstanceDump.id)
+                contentFieldName.id, PrimitiveType.REFERENCE_HPROF_TYPE,
+                ReferenceHolder(baguetteInstanceDump.id)
             )
         ),
         fields = emptyList()
@@ -105,7 +110,7 @@ class HprofWriterTest {
   }
 
   private fun File.writeRecords(
-    records: List<Record>
+    records: List<HprofRecord>
   ) {
     HprofWriter.open(this)
         .use { writer ->
@@ -115,11 +120,11 @@ class HprofWriterTest {
         }
   }
 
-  fun File.readHprof(block: (HprofGraph) -> Unit) {
-    val (graph, closeable) = HprofGraph.readHprof(this)
-    closeable.use {
-      block(graph)
-    }
+  fun File.readHprof(block: (HeapGraph) -> Unit) {
+    Hprof.open(this)
+        .use { hprof ->
+          block(HprofHeapGraph.indexHprof(hprof))
+        }
   }
 
   companion object {
diff --git a/shark-graph/src/test/java/shark/JvmHprofParsingTest.kt b/shark-graph/src/test/java/shark/JvmHprofParsingTest.kt
new file mode 100644
index 00000000..61d203a9
--- /dev/null
+++ b/shark-graph/src/test/java/shark/JvmHprofParsingTest.kt
@@ -0,0 +1,41 @@
+package shark
+
+import org.assertj.core.api.Assertions.assertThat
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TemporaryFolder
+import java.io.File
+import kotlin.reflect.KClass
+
+class JvmHprofParsingTest {
+
+  @get:Rule
+  var testFolder = TemporaryFolder()
+
+  @Test fun dumpHeapAndReadString() {
+    val hprofFolder = testFolder.newFolder()
+    val hprofFile = File(hprofFolder, "jvm_heap.hprof")
+
+    JvmTestHeapDumper.dumpHeap(hprofFile.absolutePath)
+
+    Hprof.open(hprofFile)
+        .use { hprof ->
+          val graph = HprofHeapGraph.indexHprof(hprof)
+          val testInstances = graph.instances
+              .filter { it.instanceClassName == JvmHprofParsingTest::class.name }
+              .toList()
+
+          assertThat(testInstances).hasSize(1)
+          val test = testInstances[0]
+          val folderPath = test[JvmHprofParsingTest::class.name, "testFolder"]!!
+              .valueAsInstance!![TemporaryFolder::class.name, "folder"]!!
+              .valueAsInstance!![File::class.name, "path"]!!
+              .value.readAsJavaString()!!
+
+          assertThat(folderPath).isEqualTo(testFolder.root.path)
+        }
+  }
+}
+
+private val KClass<out Any>.name: String
+  get() = this.java.name
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/JvmTestHeapDumper.kt b/shark-graph/src/test/java/shark/JvmTestHeapDumper.kt
similarity index 94%
rename from leakcanary-analyzer/src/test/java/leakcanary/internal/JvmTestHeapDumper.kt
rename to shark-graph/src/test/java/shark/JvmTestHeapDumper.kt
index df505e71..58e4d498 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/JvmTestHeapDumper.kt
+++ b/shark-graph/src/test/java/shark/JvmTestHeapDumper.kt
@@ -1,4 +1,4 @@
-package leakcanary.internal
+package shark
 
 import com.sun.management.HotSpotDiagnosticMXBean
 import java.lang.management.ManagementFactory
diff --git a/shark-hprof/build.gradle b/shark-hprof/build.gradle
new file mode 100644
index 00000000..9cb23d77
--- /dev/null
+++ b/shark-hprof/build.gradle
@@ -0,0 +1,18 @@
+apply plugin: 'java-library'
+apply plugin: 'kotlin'
+
+sourceCompatibility = JavaVersion.VERSION_1_7
+targetCompatibility = JavaVersion.VERSION_1_7
+
+dependencies {
+  api project(':shark-log')
+
+  implementation deps.kotlin.stdlib
+  implementation deps.okio
+
+  testImplementation deps.assertj_core
+  testImplementation deps.junit
+}
+
+apply from: rootProject.file('gradle/checkstyle.gradle')
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/shark-hprof/gradle.properties b/shark-hprof/gradle.properties
new file mode 100644
index 00000000..585cfc8d
--- /dev/null
+++ b/shark-hprof/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=shark-hprof
+POM_NAME=Shark Hprof
+POM_PACKAGING=jar
diff --git a/leakcanary-haha/src/main/java/leakcanary/GcRoot.kt b/shark-hprof/src/main/java/shark/GcRoot.kt
similarity index 86%
rename from leakcanary-haha/src/main/java/leakcanary/GcRoot.kt
rename to shark-hprof/src/main/java/shark/GcRoot.kt
index 01f2e243..4745c2cd 100644
--- a/leakcanary-haha/src/main/java/leakcanary/GcRoot.kt
+++ b/shark-hprof/src/main/java/shark/GcRoot.kt
@@ -1,7 +1,7 @@
-package leakcanary
+package shark
 
 /**
- * A GcRoot as identified by [Record.HeapDumpRecord.GcRootRecord] in the heap dump.
+ * A GcRoot as identified by [HprofRecord.HeapDumpRecord.GcRootRecord] in the heap dump.
  */
 sealed class GcRoot {
 
@@ -28,6 +28,7 @@ sealed class GcRoot {
    */
   class JniLocal(
     override val id: Long,
+    /** Corresponds to [ThreadObject.threadSerialNumber] */
     val threadSerialNumber: Int,
     /**
      * frame number in stack trace (-1 for empty)
@@ -40,6 +41,7 @@ sealed class GcRoot {
    */
   class JavaFrame(
     override val id: Long,
+    /** Corresponds to [ThreadObject.threadSerialNumber] */
     val threadSerialNumber: Int,
     /**
      * frame number in stack trace (-1 for empty)
@@ -53,7 +55,8 @@ sealed class GcRoot {
   class NativeStack(
     override val id: Long,
     /**
-     * Thread is sometimes not found, see:
+     * Corresponds to [ThreadObject.threadSerialNumber]
+     * Note: the corresponding thread is sometimes not found, see:
      * https://issuetracker.google.com/issues/122713143
      */
     val threadSerialNumber: Int
@@ -66,6 +69,7 @@ sealed class GcRoot {
 
   class ThreadBlock(
     override val id: Long,
+    /** Corresponds to [ThreadObject.threadSerialNumber] */
     val threadSerialNumber: Int
   ) : GcRoot()
 
diff --git a/shark-hprof/src/main/java/shark/Hprof.kt b/shark-hprof/src/main/java/shark/Hprof.kt
new file mode 100644
index 00000000..84a7e4b3
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/Hprof.kt
@@ -0,0 +1,99 @@
+package shark
+
+import okio.BufferedSource
+import okio.buffer
+import okio.source
+import java.io.Closeable
+import java.io.File
+import java.nio.channels.FileChannel
+
+/**
+ * An opened Hprof file which can be read via [reader]. Open a new hprof with [open], and don't
+ * forget to call [close] once done.
+ */
+class Hprof private constructor(
+  private val channel: FileChannel,
+  private val source: BufferedSource,
+  val reader: HprofReader,
+  /** Unix timestamp at which the heap was dumped. */
+  val heapDumpTimestamp: Long,
+  /** Version of the opened hprof, which is tied to the runtime where the heap was dumped. */
+  val hprofVersion: HprofVersion
+) : Closeable {
+
+  private var lastReaderByteReadCount = reader.byteReadCount
+  private var lastKnownPosition = reader.byteReadCount
+
+  override fun close() {
+    source.close()
+  }
+
+  /**
+   * Moves [reader] to a new position in the hprof file. This is transparent to the reader, and
+   * will not reset [HprofReader.byteReadCount].
+   */
+  fun moveReaderTo(newPosition: Long) {
+    val currentPosition = lastKnownPosition + (reader.byteReadCount - lastReaderByteReadCount)
+
+    if (currentPosition == newPosition) {
+      return
+    }
+    source.buffer.clear()
+    channel.position(newPosition)
+    lastReaderByteReadCount = reader.byteReadCount
+    lastKnownPosition = newPosition
+  }
+
+  /**
+   * Supported hprof versions
+   */
+  enum class HprofVersion(val versionString: String) {
+    JDK1_2_BETA3("JAVA PROFILE 1.0"),
+    JDK1_2_BETA4("JAVA PROFILE 1.0.1"),
+    JDK_6("JAVA PROFILE 1.0.2"),
+    ANDROID("JAVA PROFILE 1.0.3")
+  }
+
+  companion object {
+    private val supportedVersions = HprofVersion.values()
+        .map { it.versionString to it }.toMap()
+
+    /**
+     * Reads the headers of the provided [hprofFile] and returns an opened [Hprof]. Don't forget
+     * to call [close] once done.
+     */
+    fun open(hprofFile: File): Hprof {
+      if (hprofFile.length() == 0L) {
+        throw IllegalArgumentException("Hprof file is 0 byte length")
+      }
+      val inputStream = hprofFile.inputStream()
+      val channel = inputStream.channel
+      val source = inputStream.source()
+          .buffer()
+
+      val endOfVersionString = source.indexOf(0)
+      val versionName = source.readUtf8(endOfVersionString)
+
+      val hprofVersion = supportedVersions[versionName]
+
+      require(hprofVersion != null) {
+        "Unsupported Hprof version [$versionName] not in supported list ${supportedVersions.keys}"
+      }
+      // Skip the 0 at the end of the version string.
+      source.skip(1)
+      val identifierByteSize = source.readInt()
+
+      // heap dump timestamp
+      val heapDumpTimestamp = source.readLong()
+
+      val byteReadCount = endOfVersionString + 1 + 4 + 8
+
+      val reader = HprofReader(source, identifierByteSize, byteReadCount)
+
+      return Hprof(
+          channel, source, reader, heapDumpTimestamp, hprofVersion
+      )
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/shark-hprof/src/main/java/shark/HprofPrimitiveArrayStripper.kt b/shark-hprof/src/main/java/shark/HprofPrimitiveArrayStripper.kt
new file mode 100644
index 00000000..752cb2dc
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/HprofPrimitiveArrayStripper.kt
@@ -0,0 +1,85 @@
+package shark
+
+import shark.HprofRecord.HeapDumpEndRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import java.io.File
+
+/**
+ * Converts a Hprof file to another file with all primitive arrays replaces with empty arrays,
+ * which can be useful to remove PII.
+ */
+class HprofPrimitiveArrayStripper {
+
+  /**
+   * @see HprofPrimitiveArrayStripper
+   */
+  fun stripPrimitiveArrays(
+    inputHprofFile: File,
+    /**
+     * Optional output file. Defaults to a file in the same directory as [inputHprofFile], with
+     * the same name and "-stripped" prepended before the ".hprof" extension. If the file extension
+     * is not ".hprof", then "-stripped" is added at the end of the file.
+     */
+    outputHprofFile: File = File(
+        inputHprofFile.parent, inputHprofFile.name.replace(
+        ".hprof", "-stripped.hprof"
+    ).let { if (it != inputHprofFile.name) it else inputHprofFile.name + "-stripped" })
+  ): File {
+    Hprof.open(inputHprofFile)
+        .use { hprof ->
+          val reader = hprof.reader
+          HprofWriter.open(outputHprofFile, identifierByteSize = reader.identifierByteSize)
+              .use { writer ->
+                reader.readHprofRecords(setOf(HprofRecord::class),
+                    OnHprofRecordListener { _,
+                      record ->
+                      // HprofWriter automatically emits HeapDumpEndRecord, because it flushes
+                      // all continuous heap dump sub records as one heap dump record.
+                      if (record is HeapDumpEndRecord) {
+                        return@OnHprofRecordListener
+                      }
+                      writer.write(
+                          when (record) {
+                            is BooleanArrayDump -> BooleanArrayDump(
+                                record.id, record.stackTraceSerialNumber, booleanArrayOf()
+                            )
+                            is CharArrayDump -> CharArrayDump(
+                                record.id, record.stackTraceSerialNumber, charArrayOf()
+                            )
+                            is FloatArrayDump -> FloatArrayDump(
+                                record.id, record.stackTraceSerialNumber, floatArrayOf()
+                            )
+                            is DoubleArrayDump -> DoubleArrayDump(
+                                record.id, record.stackTraceSerialNumber, doubleArrayOf()
+                            )
+                            is ByteArrayDump -> ByteArrayDump(
+                                record.id, record.stackTraceSerialNumber, byteArrayOf()
+                            )
+                            is ShortArrayDump -> ShortArrayDump(
+                                record.id, record.stackTraceSerialNumber, shortArrayOf()
+                            )
+                            is IntArrayDump -> IntArrayDump(
+                                record.id, record.stackTraceSerialNumber, intArrayOf()
+                            )
+                            is LongArrayDump -> LongArrayDump(
+                                record.id, record.stackTraceSerialNumber, longArrayOf()
+                            )
+                            else -> {
+                              record
+                            }
+                          }
+                      )
+                    })
+              }
+        }
+    return outputHprofFile
+  }
+
+}
\ No newline at end of file
diff --git a/shark-hprof/src/main/java/shark/HprofReader.kt b/shark-hprof/src/main/java/shark/HprofReader.kt
new file mode 100644
index 00000000..b67be040
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/HprofReader.kt
@@ -0,0 +1,893 @@
+package shark
+
+import okio.BufferedSource
+import shark.GcRoot.Debugger
+import shark.GcRoot.Finalizing
+import shark.GcRoot.InternedString
+import shark.GcRoot.JavaFrame
+import shark.GcRoot.JniGlobal
+import shark.GcRoot.JniLocal
+import shark.GcRoot.JniMonitor
+import shark.GcRoot.MonitorUsed
+import shark.GcRoot.NativeStack
+import shark.GcRoot.ReferenceCleanup
+import shark.GcRoot.StickyClass
+import shark.GcRoot.ThreadBlock
+import shark.GcRoot.ThreadObject
+import shark.GcRoot.Unknown
+import shark.GcRoot.Unreachable
+import shark.GcRoot.VmInternal
+import shark.HprofRecord.HeapDumpEndRecord
+import shark.HprofRecord.HeapDumpRecord
+import shark.HprofRecord.HeapDumpRecord.GcRootRecord
+import shark.HprofRecord.HeapDumpRecord.HeapDumpInfoRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import shark.HprofRecord.LoadClassRecord
+import shark.HprofRecord.StackFrameRecord
+import shark.HprofRecord.StackTraceRecord
+import shark.HprofRecord.StringRecord
+import shark.PrimitiveType.BOOLEAN
+import shark.PrimitiveType.BYTE
+import shark.PrimitiveType.CHAR
+import shark.PrimitiveType.DOUBLE
+import shark.PrimitiveType.FLOAT
+import shark.PrimitiveType.INT
+import shark.PrimitiveType.LONG
+import shark.PrimitiveType.SHORT
+import shark.ValueHolder.BooleanHolder
+import shark.ValueHolder.ByteHolder
+import shark.ValueHolder.CharHolder
+import shark.ValueHolder.DoubleHolder
+import shark.ValueHolder.FloatHolder
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.ValueHolder.ReferenceHolder
+import shark.ValueHolder.ShortHolder
+import java.nio.charset.Charset
+import kotlin.reflect.KClass
+
+/**
+ * Reads hprof content from an Okio [BufferedSource].
+ *
+ * Not thread safe, should be used from a single thread.
+ *
+ * Binary Dump Format reference: http://hg.openjdk.java.net/jdk6/jdk6/jdk/raw-file/tip/src/share/demo/jvmti/hprof/manual.html#mozTocId848088
+ *
+ * The Android Hprof format differs in some ways from that reference. This parser implementation
+ * is largely adapted from https://android.googlesource.com/platform/tools/base/+/studio-master-dev/perflib/src/main/java/com/android/tools/perflib
+ */
+class HprofReader constructor(
+  private var source: BufferedSource,
+  /**
+   * Size of Hprof identifiers. Identifiers are used to represent UTF8 strings, objects,
+   * stack traces, etc. They can have the same size as host pointers or sizeof(void*), but are not
+   * required to be.
+   */
+  val identifierByteSize: Int,
+  /**
+   * How many bytes have already been read from [source] when this [HprofReader] is created.
+   */
+  val startByteReadCount: Long = 0L
+) {
+
+  /**
+   * Starts at [startByteReadCount] and increases as [HprofReader] reads bytes. This is useful
+   * for tracking the position of content in the backing [source]. This never resets.
+   */
+  var byteReadCount = startByteReadCount
+    private set
+
+  private val typeSizes =
+    PrimitiveType.byteSizeByHprofType + (PrimitiveType.REFERENCE_HPROF_TYPE to identifierByteSize)
+
+  /**
+   * Reads all hprof records from [source].
+   * Assumes the [reader] was just created, with a source that currently points to the start
+   * position of hprof records.
+   */
+  fun readHprofRecords(
+    recordTypes: Set<KClass<out HprofRecord>>,
+    listener: OnHprofRecordListener
+  ) {
+    require(byteReadCount == startByteReadCount) {
+      "readHprofRecords() should only be called on a unused HprofReader instance"
+    }
+    val readAllRecords = HprofRecord::class in recordTypes
+    val readStringRecord = readAllRecords || StringRecord::class in recordTypes
+    val readLoadClassRecord = readAllRecords || LoadClassRecord::class in recordTypes
+    val readHeapDumpEndRecord = readAllRecords || HeapDumpEndRecord::class in recordTypes
+    val readStackFrameRecord = readAllRecords || StackFrameRecord::class in recordTypes
+    val readStackTraceRecord = readAllRecords || StackTraceRecord::class in recordTypes
+
+    val readAllHeapDumpRecords = readAllRecords || HeapDumpRecord::class in recordTypes
+
+    val readGcRootRecord = readAllHeapDumpRecords || GcRootRecord::class in recordTypes
+    val readHeapDumpInfoRecord = readAllRecords || HeapDumpInfoRecord::class in recordTypes
+
+    val readAllObjectRecords = readAllHeapDumpRecords || ObjectRecord::class in recordTypes
+
+    val readClassDumpRecord = readAllObjectRecords || ClassDumpRecord::class in recordTypes
+    val readInstanceDumpRecord = readAllObjectRecords || InstanceDumpRecord::class in recordTypes
+    val readObjectArrayDumpRecord =
+      readAllObjectRecords || ObjectArrayDumpRecord::class in recordTypes
+    val readPrimitiveArrayDumpRecord =
+      readAllObjectRecords || PrimitiveArrayDumpRecord::class in recordTypes
+
+    val intByteSize = INT.byteSize
+
+    while (!exhausted()) {
+      // type of the record
+      val tag = readUnsignedByte()
+
+      // number of microseconds since the time stamp in the header
+      skip(intByteSize)
+
+      // number of bytes that follow and belong to this record
+      val length = readUnsignedInt()
+
+      when (tag) {
+        STRING_IN_UTF8 -> {
+          if (readStringRecord) {
+            val recordPosition = byteReadCount
+            val id = readId()
+            val stringLength = length - identifierByteSize
+            val string = readUtf8(stringLength)
+            val record = StringRecord(id, string)
+            listener.onHprofRecord(recordPosition, record)
+          } else {
+            skip(length)
+          }
+        }
+        LOAD_CLASS -> {
+          if (readLoadClassRecord) {
+            val recordPosition = byteReadCount
+            val classSerialNumber = readInt()
+            val id = readId()
+            val stackTraceSerialNumber = readInt()
+            val classNameStringId = readId()
+            val record = LoadClassRecord(
+                classSerialNumber = classSerialNumber,
+                id = id,
+                stackTraceSerialNumber = stackTraceSerialNumber,
+                classNameStringId = classNameStringId
+            )
+            listener.onHprofRecord(recordPosition, record)
+          } else {
+            skip(length)
+          }
+        }
+        STACK_FRAME -> {
+          if (readStackFrameRecord) {
+            val recordPosition = byteReadCount
+            val record = StackFrameRecord(
+                id = readId(),
+                methodNameStringId = readId(),
+                methodSignatureStringId = readId(),
+                sourceFileNameStringId = readId(),
+                classSerialNumber = readInt(),
+                lineNumber = readInt()
+            )
+            listener.onHprofRecord(recordPosition, record)
+          } else {
+            skip(length)
+          }
+        }
+        STACK_TRACE -> {
+          if (readStackTraceRecord) {
+            val recordPosition = byteReadCount
+            val stackTraceSerialNumber = readInt()
+            val threadSerialNumber = readInt()
+            val frameCount = readInt()
+            val stackFrameIds = readIdArray(frameCount)
+            val record = StackTraceRecord(
+                stackTraceSerialNumber = stackTraceSerialNumber,
+                threadSerialNumber = threadSerialNumber,
+                stackFrameIds = stackFrameIds
+            )
+            listener.onHprofRecord(recordPosition, record)
+          } else {
+            skip(length)
+          }
+        }
+        HEAP_DUMP, HEAP_DUMP_SEGMENT -> {
+          val heapDumpStart = byteReadCount
+          var previousTag = 0
+          while (byteReadCount - heapDumpStart < length) {
+            val heapDumpTag = readUnsignedByte()
+
+            when (heapDumpTag) {
+              ROOT_UNKNOWN -> {
+                if (readGcRootRecord) {
+                  val recordPosition = byteReadCount
+                  val record = GcRootRecord(gcRoot = Unknown(id = readId()))
+                  listener.onHprofRecord(recordPosition, record)
+                } else {
+                  skip(identifierByteSize)
+                }
+              }
+              ROOT_JNI_GLOBAL -> {
+                if (readGcRootRecord) {
+                  val recordPosition = byteReadCount
+                  val gcRootRecord =
+                    GcRootRecord(gcRoot = JniGlobal(id = readId(), jniGlobalRefId = readId()))
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize + identifierByteSize)
+                }
+              }
+
+              ROOT_JNI_LOCAL -> {
+                if (readGcRootRecord) {
+                  val recordPosition = byteReadCount
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = JniLocal(
+                          id = readId(), threadSerialNumber = readInt(), frameNumber = readInt()
+                      )
+                  )
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize + intByteSize + intByteSize)
+                }
+              }
+
+              ROOT_JAVA_FRAME -> {
+                if (readGcRootRecord) {
+                  val recordPosition = byteReadCount
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = JavaFrame(
+                          id = readId(), threadSerialNumber = readInt(), frameNumber = readInt()
+                      )
+                  )
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize + intByteSize + intByteSize)
+                }
+              }
+
+              ROOT_NATIVE_STACK -> {
+                if (readGcRootRecord) {
+                  val recordPosition = byteReadCount
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = NativeStack(id = readId(), threadSerialNumber = readInt())
+                  )
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize + intByteSize)
+                }
+              }
+
+              ROOT_STICKY_CLASS -> {
+                if (readGcRootRecord) {
+                  val recordPosition = byteReadCount
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = StickyClass(id = readId())
+                  )
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize)
+                }
+              }
+
+              // An object that was referenced from an active thread block.
+              ROOT_THREAD_BLOCK -> {
+                if (readGcRootRecord) {
+                  val recordPosition = byteReadCount
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = ThreadBlock(id = readId(), threadSerialNumber = readInt())
+                  )
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize + intByteSize)
+                }
+              }
+
+              ROOT_MONITOR_USED -> {
+                if (readGcRootRecord) {
+                  val recordPosition = byteReadCount
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = MonitorUsed(id = readId())
+                  )
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize)
+                }
+              }
+
+              ROOT_THREAD_OBJECT -> {
+                if (readGcRootRecord) {
+                  val recordPosition = byteReadCount
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = ThreadObject(
+                          id = readId(),
+                          threadSerialNumber = readInt(),
+                          stackTraceSerialNumber = readInt()
+                      )
+                  )
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize + intByteSize + intByteSize)
+                }
+              }
+
+              ROOT_INTERNED_STRING -> {
+                if (readGcRootRecord) {
+                  val recordPosition = byteReadCount
+                  val gcRootRecord = GcRootRecord(gcRoot = InternedString(id = readId()))
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize)
+                }
+              }
+
+              ROOT_FINALIZING -> {
+                if (readGcRootRecord) {
+                  val recordPosition = byteReadCount
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = Finalizing(id = readId())
+                  )
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize)
+                }
+              }
+
+              ROOT_DEBUGGER -> {
+                if (readGcRootRecord) {
+                  val recordPosition = byteReadCount
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = Debugger(id = readId())
+                  )
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize)
+                }
+              }
+
+              ROOT_REFERENCE_CLEANUP -> {
+                if (readGcRootRecord) {
+                  val recordPosition = byteReadCount
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = ReferenceCleanup(id = readId())
+                  )
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize)
+                }
+              }
+
+              ROOT_VM_INTERNAL -> {
+                if (readGcRootRecord) {
+                  val recordPosition = byteReadCount
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = VmInternal(id = readId())
+                  )
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize)
+                }
+              }
+
+              ROOT_JNI_MONITOR -> {
+                if (readGcRootRecord) {
+                  val recordPosition = byteReadCount
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = JniMonitor(
+                          id = readId(), stackTraceSerialNumber = readInt(),
+                          stackDepth = readInt()
+                      )
+                  )
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize + intByteSize + intByteSize)
+                }
+              }
+
+              ROOT_UNREACHABLE -> {
+                if (readGcRootRecord) {
+                  val recordPosition = byteReadCount
+                  val gcRootRecord = GcRootRecord(
+                      gcRoot = Unreachable(id = readId())
+                  )
+                  listener.onHprofRecord(recordPosition, gcRootRecord)
+                } else {
+                  skip(identifierByteSize)
+                }
+              }
+              CLASS_DUMP -> {
+                if (readClassDumpRecord) {
+                  val recordPosition = byteReadCount
+                  val record = readClassDumpRecord()
+                  listener.onHprofRecord(recordPosition, record)
+                } else {
+                  skipClassDumpRecord()
+                }
+              }
+
+              INSTANCE_DUMP -> {
+                if (readInstanceDumpRecord) {
+                  val recordPosition = byteReadCount
+                  val instanceDumpRecord = readInstanceDumpRecord()
+                  listener.onHprofRecord(recordPosition, instanceDumpRecord)
+                } else {
+                  skipInstanceDumpRecord()
+                }
+              }
+
+              OBJECT_ARRAY_DUMP -> {
+                if (readObjectArrayDumpRecord) {
+                  val recordPosition = byteReadCount
+                  val arrayRecord = readObjectArrayDumpRecord()
+                  listener.onHprofRecord(recordPosition, arrayRecord)
+                } else {
+                  skipObjectArrayDumpRecord()
+                }
+              }
+
+              PRIMITIVE_ARRAY_DUMP -> {
+                if (readPrimitiveArrayDumpRecord) {
+                  val recordPosition = byteReadCount
+                  val record = readPrimitiveArrayDumpRecord()
+                  listener.onHprofRecord(recordPosition, record)
+                } else {
+                  skipPrimitiveArrayDumpRecord()
+                }
+              }
+
+              PRIMITIVE_ARRAY_NODATA -> {
+                throw UnsupportedOperationException("PRIMITIVE_ARRAY_NODATA cannot be parsed")
+              }
+
+              HEAP_DUMP_INFO -> {
+                if (readHeapDumpInfoRecord) {
+                  val recordPosition = byteReadCount
+                  val record = readHeapDumpInfoRecord()
+                  listener.onHprofRecord(recordPosition, record)
+                } else {
+                  skipHeapDumpInfoRecord()
+                }
+              }
+              else -> throw IllegalStateException(
+                  "Unknown tag $heapDumpTag after $previousTag"
+              )
+            }
+            previousTag = heapDumpTag
+          }
+        }
+        HEAP_DUMP_END -> {
+          if (readHeapDumpEndRecord) {
+            val recordPosition = byteReadCount
+            val record = HeapDumpEndRecord
+            listener.onHprofRecord(recordPosition, record)
+          }
+        }
+        else -> {
+          skip(length)
+        }
+      }
+    }
+  }
+
+  /**
+   * Reads a full instance record after a instance dump tag.
+   */
+  fun readInstanceDumpRecord(): InstanceDumpRecord {
+    val id = readId()
+    val stackTraceSerialNumber = readInt()
+    val classId = readId()
+    val remainingBytesInInstance = readInt()
+    val fieldValues = readByteArray(remainingBytesInInstance)
+    return InstanceDumpRecord(
+        id = id,
+        stackTraceSerialNumber = stackTraceSerialNumber,
+        classId = classId,
+        fieldValues = fieldValues
+    )
+  }
+
+  /**
+   * Reads a full class record after a class dump tag.
+   */
+  fun readClassDumpRecord(): ClassDumpRecord {
+    val id = readId()
+    // stack trace serial number
+    val stackTraceSerialNumber = readInt()
+    val superclassId = readId()
+    // class loader object ID
+    val classLoaderId = readId()
+    // signers object ID
+    val signersId = readId()
+    // protection domain object ID
+    val protectionDomainId = readId()
+    // reserved
+    readId()
+    // reserved
+    readId()
+
+    // instance size (in bytes)
+    // Useful to compute retained size
+    val instanceSize = readInt()
+
+    // Skip over the constant pool
+    val constantPoolCount = readUnsignedShort()
+    for (i in 0 until constantPoolCount) {
+      // constant pool index
+      skip(SHORT_SIZE)
+      skip(typeSize(readUnsignedByte()))
+    }
+
+    val staticFieldCount = readUnsignedShort()
+    val staticFields = ArrayList<StaticFieldRecord>(staticFieldCount)
+    for (i in 0 until staticFieldCount) {
+
+      val nameStringId = readId()
+      val type = readUnsignedByte()
+      val value = readValue(type)
+
+      staticFields.add(
+          StaticFieldRecord(
+              nameStringId = nameStringId,
+              type = type,
+              value = value
+          )
+      )
+    }
+
+    val fieldCount = readUnsignedShort()
+    val fields = ArrayList<FieldRecord>(fieldCount)
+    for (i in 0 until fieldCount) {
+      fields.add(FieldRecord(nameStringId = readId(), type = readUnsignedByte()))
+    }
+
+    return ClassDumpRecord(
+        id = id,
+        stackTraceSerialNumber = stackTraceSerialNumber,
+        superclassId = superclassId,
+        classLoaderId = classLoaderId,
+        signersId = signersId,
+        protectionDomainId = protectionDomainId,
+        instanceSize = instanceSize,
+        staticFields = staticFields,
+        fields = fields
+    )
+  }
+
+  /**
+   * Reads a full primitive array record after a primitive array dump tag.
+   */
+  fun readPrimitiveArrayDumpRecord(): PrimitiveArrayDumpRecord {
+    val id = readId()
+    val stackTraceSerialNumber = readInt()
+    // length
+    val arrayLength = readInt()
+    return when (val type = readUnsignedByte()) {
+      BOOLEAN_TYPE -> BooleanArrayDump(
+          id, stackTraceSerialNumber, readBooleanArray(arrayLength)
+      )
+      CHAR_TYPE -> CharArrayDump(
+          id, stackTraceSerialNumber, readCharArray(arrayLength)
+      )
+      FLOAT_TYPE -> FloatArrayDump(
+          id, stackTraceSerialNumber, readFloatArray(arrayLength)
+      )
+      DOUBLE_TYPE -> DoubleArrayDump(
+          id, stackTraceSerialNumber, readDoubleArray(arrayLength)
+      )
+      BYTE_TYPE -> ByteArrayDump(
+          id, stackTraceSerialNumber, readByteArray(arrayLength)
+      )
+      SHORT_TYPE -> ShortArrayDump(
+          id, stackTraceSerialNumber, readShortArray(arrayLength)
+      )
+      INT_TYPE -> IntArrayDump(
+          id, stackTraceSerialNumber, readIntArray(arrayLength)
+      )
+      LONG_TYPE -> LongArrayDump(
+          id, stackTraceSerialNumber, readLongArray(arrayLength)
+      )
+      else -> throw IllegalStateException("Unexpected type $type")
+    }
+  }
+
+  /**
+   * Reads a full object array record after a object array dump tag.
+   */
+  fun readObjectArrayDumpRecord(
+  ): ObjectArrayDumpRecord {
+    val id = readId()
+    // stack trace serial number
+    val stackTraceSerialNumber = readInt()
+    val arrayLength = readInt()
+    val arrayClassId = readId()
+    val elementIds = readIdArray(arrayLength)
+    return ObjectArrayDumpRecord(
+        id = id,
+        stackTraceSerialNumber = stackTraceSerialNumber,
+        arrayClassId = arrayClassId,
+        elementIds = elementIds
+    )
+  }
+
+  /**
+   * Reads a value in the heap dump, which can be a reference or a primitive type.
+   */
+  fun readValue(type: Int): ValueHolder {
+    return when (type) {
+      PrimitiveType.REFERENCE_HPROF_TYPE -> ReferenceHolder(readId())
+      BOOLEAN_TYPE -> BooleanHolder(readBoolean())
+      CHAR_TYPE -> CharHolder(readChar())
+      FLOAT_TYPE -> FloatHolder(readFloat())
+      DOUBLE_TYPE -> DoubleHolder(readDouble())
+      BYTE_TYPE -> ByteHolder(readByte())
+      SHORT_TYPE -> ShortHolder(readShort())
+      INT_TYPE -> IntHolder(readInt())
+      LONG_TYPE -> LongHolder(readLong())
+      else -> throw IllegalStateException("Unknown type $type")
+    }
+  }
+
+  private fun typeSize(type: Int): Int {
+    return typeSizes.getValue(type)
+  }
+
+  private fun readShort(): Short {
+    byteReadCount += SHORT_SIZE
+    return source.readShort()
+  }
+
+  private fun readInt(): Int {
+    byteReadCount += INT_SIZE
+    return source.readInt()
+  }
+
+  private fun readIdArray(arrayLength: Int): LongArray {
+    return LongArray(arrayLength) { readId() }
+  }
+
+  private fun readBooleanArray(arrayLength: Int): BooleanArray {
+    return BooleanArray(arrayLength) { readByte().toInt() != 0 }
+  }
+
+  private fun readCharArray(arrayLength: Int): CharArray {
+    return readString(CHAR_SIZE * arrayLength, Charsets.UTF_16BE).toCharArray()
+  }
+
+  private fun readString(
+    byteCount: Int,
+    charset: Charset
+  ): String {
+    byteReadCount += byteCount
+    return source.readString(byteCount.toLong(), charset)
+  }
+
+  private fun readFloatArray(arrayLength: Int): FloatArray {
+    return FloatArray(arrayLength) { readFloat() }
+  }
+
+  private fun readDoubleArray(arrayLength: Int): DoubleArray {
+    return DoubleArray(arrayLength) { readDouble() }
+  }
+
+  private fun readShortArray(arrayLength: Int): ShortArray {
+    return ShortArray(arrayLength) { readShort() }
+  }
+
+  private fun readIntArray(arrayLength: Int): IntArray {
+    return IntArray(arrayLength) { readInt() }
+  }
+
+  private fun readLongArray(arrayLength: Int): LongArray {
+    return LongArray(arrayLength) { readLong() }
+  }
+
+  private fun readLong(): Long {
+    byteReadCount += LONG_SIZE
+    return source.readLong()
+  }
+
+  private fun exhausted() = source.exhausted()
+
+  private fun skip(byteCount: Long) {
+    byteReadCount += byteCount
+    return source.skip(byteCount)
+  }
+
+  private fun readByte(): Byte {
+    byteReadCount += BYTE_SIZE
+    return source.readByte()
+  }
+
+  private fun readBoolean(): Boolean {
+    byteReadCount += BOOLEAN_SIZE
+    return source.readByte().toInt() != 0
+  }
+
+  private fun readByteArray(byteCount: Int): ByteArray {
+    byteReadCount += byteCount
+    return source.readByteArray(byteCount.toLong())
+  }
+
+  private fun readChar(): Char {
+    return readString(CHAR_SIZE, Charsets.UTF_16BE)[0]
+  }
+
+  private fun readFloat(): Float {
+    return Float.fromBits(readInt())
+  }
+
+  private fun readDouble(): Double {
+    return Double.fromBits(readLong())
+  }
+
+  private fun readId(): Long {
+    // As long as we don't interpret IDs, reading signed values here is fine.
+    return when (identifierByteSize) {
+      1 -> readByte().toLong()
+      2 -> readShort().toLong()
+      4 -> readInt().toLong()
+      8 -> readLong()
+      else -> throw IllegalArgumentException("ID Length must be 1, 2, 4, or 8")
+    }
+  }
+
+  private fun readUtf8(byteCount: Long): String {
+    byteReadCount += byteCount
+    return source.readUtf8(byteCount)
+  }
+
+  private fun readUnsignedInt(): Long {
+    return readInt().toLong() and INT_MASK
+  }
+
+  private fun readUnsignedByte(): Int {
+    return readByte().toInt() and BYTE_MASK
+  }
+
+  private fun readUnsignedShort(): Int {
+    return readShort().toInt() and 0xFFFF
+  }
+
+  private fun skip(byteCount: Int) {
+    byteReadCount += byteCount
+    return source.skip(byteCount.toLong())
+  }
+
+  private fun skipInstanceDumpRecord() {
+    skip(identifierByteSize + INT_SIZE + identifierByteSize)
+    val remainingBytesInInstance = readInt()
+    skip(remainingBytesInInstance)
+  }
+
+  private fun skipClassDumpRecord() {
+    skip(
+        identifierByteSize + INT_SIZE + identifierByteSize + identifierByteSize + identifierByteSize + identifierByteSize + identifierByteSize + identifierByteSize + INT_SIZE
+    )
+    // Skip over the constant pool
+    val constantPoolCount = readUnsignedShort()
+    for (i in 0 until constantPoolCount) {
+      // constant pool index
+      skip(SHORT_SIZE)
+      skip(typeSize(readUnsignedByte()))
+    }
+
+    val staticFieldCount = readUnsignedShort()
+
+    for (i in 0 until staticFieldCount) {
+      skip(identifierByteSize)
+      val type = readUnsignedByte()
+      skip(typeSize(type))
+    }
+
+    val fieldCount = readUnsignedShort()
+    skip(fieldCount * (identifierByteSize + BYTE_SIZE))
+  }
+
+  private fun skipObjectArrayDumpRecord() {
+    skip(identifierByteSize + INT_SIZE)
+    val arrayLength = readInt()
+    skip(identifierByteSize + arrayLength * identifierByteSize)
+  }
+
+  private fun skipPrimitiveArrayDumpRecord() {
+    skip(identifierByteSize + INT_SIZE)
+    val arrayLength = readInt()
+    val type = readUnsignedByte()
+    skip(identifierByteSize + arrayLength * typeSize(type))
+  }
+
+  private fun readHeapDumpInfoRecord(): HeapDumpInfoRecord {
+    val heapId = readInt()
+    return HeapDumpInfoRecord(heapId = heapId, heapNameStringId = readId())
+  }
+
+  private fun skipHeapDumpInfoRecord() {
+    skip(identifierByteSize + identifierByteSize)
+  }
+
+  companion object {
+    private val BOOLEAN_SIZE = BOOLEAN.byteSize
+    private val CHAR_SIZE = CHAR.byteSize
+    private val FLOAT_SIZE = FLOAT.byteSize
+    private val DOUBLE_SIZE = DOUBLE.byteSize
+    private val BYTE_SIZE = BYTE.byteSize
+    private val SHORT_SIZE = SHORT.byteSize
+    private val INT_SIZE = PrimitiveType.INT.byteSize
+    private val LONG_SIZE = LONG.byteSize
+
+    private val BOOLEAN_TYPE = BOOLEAN.hprofType
+    private val CHAR_TYPE = CHAR.hprofType
+    private val FLOAT_TYPE = FLOAT.hprofType
+    private val DOUBLE_TYPE = DOUBLE.hprofType
+    private val BYTE_TYPE = BYTE.hprofType
+    private val SHORT_TYPE = SHORT.hprofType
+    private val INT_TYPE = PrimitiveType.INT.hprofType
+    private val LONG_TYPE = LONG.hprofType
+
+    private const val INT_MASK = 0xffffffffL
+    private const val BYTE_MASK = 0xff
+
+    internal const val STRING_IN_UTF8 = 0x01
+    internal const val LOAD_CLASS = 0x02
+    internal const val UNLOAD_CLASS = 0x03
+    internal const val STACK_FRAME = 0x04
+    internal const val STACK_TRACE = 0x05
+    internal const val ALLOC_SITES = 0x06
+    internal const val HEAP_SUMMARY = 0x07
+    // TODO Maybe parse this?
+    internal const val START_THREAD = 0x0a
+    internal const val END_THREAD = 0x0b
+    internal const val HEAP_DUMP = 0x0c
+    internal const val HEAP_DUMP_SEGMENT = 0x1c
+    internal const val HEAP_DUMP_END = 0x2c
+    internal const val CPU_SAMPLES = 0x0d
+    internal const val CONTROL_SETTINGS = 0x0e
+    internal const val ROOT_UNKNOWN = 0xff
+    internal const val ROOT_JNI_GLOBAL = 0x01
+    internal const val ROOT_JNI_LOCAL = 0x02
+    internal const val ROOT_JAVA_FRAME = 0x03
+    internal const val ROOT_NATIVE_STACK = 0x04
+    internal const val ROOT_STICKY_CLASS = 0x05
+    internal const val ROOT_THREAD_BLOCK = 0x06
+    internal const val ROOT_MONITOR_USED = 0x07
+    internal const val ROOT_THREAD_OBJECT = 0x08
+    internal const val CLASS_DUMP = 0x20
+    internal const val INSTANCE_DUMP = 0x21
+    internal const val OBJECT_ARRAY_DUMP = 0x22
+    internal const val PRIMITIVE_ARRAY_DUMP = 0x23
+
+    /**
+     * Android format addition
+     *
+     * Specifies information about which heap certain objects came from. When a sub-tag of this type
+     * appears in a HPROF_HEAP_DUMP or HPROF_HEAP_DUMP_SEGMENT record, entries that follow it will
+     * be associated with the specified heap.  The HEAP_DUMP_INFO data is reset at the end of the
+     * HEAP_DUMP[_SEGMENT].  Multiple HEAP_DUMP_INFO entries may appear in a single
+     * HEAP_DUMP[_SEGMENT].
+     *
+     * Format: u1: Tag value (0xFE) u4: heap ID ID: heap name string ID
+     */
+    internal const val HEAP_DUMP_INFO = 0xfe
+    internal const val ROOT_INTERNED_STRING = 0x89
+    internal const val ROOT_FINALIZING = 0x8a
+    internal const val ROOT_DEBUGGER = 0x8b
+    internal const val ROOT_REFERENCE_CLEANUP = 0x8c
+    internal const val ROOT_VM_INTERNAL = 0x8d
+    internal const val ROOT_JNI_MONITOR = 0x8e
+    internal const val ROOT_UNREACHABLE = 0x90
+    internal const val PRIMITIVE_ARRAY_NODATA = 0xc3
+  }
+
+}
diff --git a/leakcanary-haha/src/main/java/leakcanary/Record.kt b/shark-hprof/src/main/java/shark/HprofRecord.kt
similarity index 90%
rename from leakcanary-haha/src/main/java/leakcanary/Record.kt
rename to shark-hprof/src/main/java/shark/HprofRecord.kt
index 85fa9a09..5009a3cc 100644
--- a/leakcanary-haha/src/main/java/leakcanary/Record.kt
+++ b/shark-hprof/src/main/java/shark/HprofRecord.kt
@@ -1,22 +1,26 @@
-package leakcanary
+package shark
 
 /**
  * A Hprof record. These data structure map 1:1 with how records are written in hprof files.
  */
-sealed class Record {
+sealed class HprofRecord {
   class StringRecord(
     val id: Long,
     val string: String
-  ) : Record()
+  ) : HprofRecord()
 
   class LoadClassRecord(
     val classSerialNumber: Int,
     val id: Long,
     val stackTraceSerialNumber: Int,
     val classNameStringId: Long
-  ) : Record()
+  ) : HprofRecord()
 
-  object HeapDumpEndRecord : Record()
+  /**
+   * Terminates a series of heap dump segments. Concatenation of heap dump segments equals a
+   * heap dump.
+   */
+  object HeapDumpEndRecord : HprofRecord()
 
   class StackFrameRecord(
     val id: Long,
@@ -32,15 +36,15 @@ sealed class Record {
      * -3 native method (Not implemented)
      */
     val lineNumber: Int
-  ) : Record()
+  ) : HprofRecord()
 
   class StackTraceRecord(
     val stackTraceSerialNumber: Int,
     val threadSerialNumber: Int,
     val stackFrameIds: LongArray
-  ) : Record()
+  ) : HprofRecord()
 
-  sealed class HeapDumpRecord : Record() {
+  sealed class HeapDumpRecord : HprofRecord() {
     class GcRootRecord(
       val gcRoot: GcRoot
     ) : HeapDumpRecord()
@@ -49,7 +53,7 @@ sealed class Record {
       class ClassDumpRecord(
         val id: Long,
         val stackTraceSerialNumber: Int,
-        val superClassId: Long,
+        val superclassId: Long,
         val classLoaderId: Long,
         val signersId: Long,
         val protectionDomainId: Long,
@@ -60,7 +64,7 @@ sealed class Record {
         data class StaticFieldRecord(
           val nameStringId: Long,
           val type: Int,
-          val value: HeapValue
+          val value: ValueHolder
         )
 
         data class FieldRecord(
@@ -73,6 +77,9 @@ sealed class Record {
         val id: Long,
         val stackTraceSerialNumber: Int,
         val classId: Long,
+        /**
+         * Instance field values (this class, followed by super class, etc)
+         */
         val fieldValues: ByteArray
       ) : ObjectRecord()
 
diff --git a/leakcanary-haha/src/main/java/leakcanary/HprofWriter.kt b/shark-hprof/src/main/java/shark/HprofWriter.kt
similarity index 57%
rename from leakcanary-haha/src/main/java/leakcanary/HprofWriter.kt
rename to shark-hprof/src/main/java/shark/HprofWriter.kt
index f9828f74..983f670d 100644
--- a/leakcanary-haha/src/main/java/leakcanary/HprofWriter.kt
+++ b/shark-hprof/src/main/java/shark/HprofWriter.kt
@@ -1,52 +1,62 @@
-package leakcanary
+package shark
 
-import leakcanary.GcRoot.Debugger
-import leakcanary.GcRoot.Finalizing
-import leakcanary.GcRoot.InternedString
-import leakcanary.GcRoot.JavaFrame
-import leakcanary.GcRoot.JniGlobal
-import leakcanary.GcRoot.JniLocal
-import leakcanary.GcRoot.JniMonitor
-import leakcanary.GcRoot.MonitorUsed
-import leakcanary.GcRoot.NativeStack
-import leakcanary.GcRoot.ReferenceCleanup
-import leakcanary.GcRoot.StickyClass
-import leakcanary.GcRoot.ThreadBlock
-import leakcanary.GcRoot.ThreadObject
-import leakcanary.GcRoot.Unknown
-import leakcanary.GcRoot.Unreachable
-import leakcanary.GcRoot.VmInternal
-import leakcanary.HeapValue.BooleanValue
-import leakcanary.HeapValue.ByteValue
-import leakcanary.HeapValue.CharValue
-import leakcanary.HeapValue.DoubleValue
-import leakcanary.HeapValue.FloatValue
-import leakcanary.HeapValue.IntValue
-import leakcanary.HeapValue.LongValue
-import leakcanary.HeapValue.ObjectReference
-import leakcanary.HeapValue.ShortValue
-import leakcanary.Record.HeapDumpEndRecord
-import leakcanary.Record.HeapDumpRecord.GcRootRecord
-import leakcanary.Record.HeapDumpRecord.HeapDumpInfoRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
-import leakcanary.Record.LoadClassRecord
-import leakcanary.Record.StackTraceRecord
-import leakcanary.Record.StringRecord
 import okio.Buffer
 import okio.BufferedSink
 import okio.buffer
 import okio.sink
+import shark.GcRoot.Debugger
+import shark.GcRoot.Finalizing
+import shark.GcRoot.InternedString
+import shark.GcRoot.JavaFrame
+import shark.GcRoot.JniGlobal
+import shark.GcRoot.JniLocal
+import shark.GcRoot.JniMonitor
+import shark.GcRoot.MonitorUsed
+import shark.GcRoot.NativeStack
+import shark.GcRoot.ReferenceCleanup
+import shark.GcRoot.StickyClass
+import shark.GcRoot.ThreadBlock
+import shark.GcRoot.ThreadObject
+import shark.GcRoot.Unknown
+import shark.GcRoot.Unreachable
+import shark.GcRoot.VmInternal
+import shark.Hprof.HprofVersion
+import shark.HprofRecord.HeapDumpEndRecord
+import shark.HprofRecord.HeapDumpRecord.GcRootRecord
+import shark.HprofRecord.HeapDumpRecord.HeapDumpInfoRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.BooleanArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ByteArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.DoubleArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.FloatArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.IntArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.LongArrayDump
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.ShortArrayDump
+import shark.HprofRecord.LoadClassRecord
+import shark.HprofRecord.StackTraceRecord
+import shark.HprofRecord.StringRecord
+import shark.HprofWriter.Companion.open
+import shark.PrimitiveType.BOOLEAN
+import shark.PrimitiveType.BYTE
+import shark.PrimitiveType.CHAR
+import shark.PrimitiveType.DOUBLE
+import shark.PrimitiveType.FLOAT
+import shark.PrimitiveType.INT
+import shark.PrimitiveType.LONG
+import shark.PrimitiveType.SHORT
+import shark.ValueHolder.BooleanHolder
+import shark.ValueHolder.ByteHolder
+import shark.ValueHolder.CharHolder
+import shark.ValueHolder.DoubleHolder
+import shark.ValueHolder.FloatHolder
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.ValueHolder.ReferenceHolder
+import shark.ValueHolder.ShortHolder
 import java.io.Closeable
 import java.io.File
 
@@ -57,25 +67,66 @@ import java.io.File
  */
 class HprofWriter private constructor(
   private val sink: BufferedSink,
-  val idSize: Int
+  val identifierByteSize: Int,
+  val hprofVersion: HprofVersion
 ) : Closeable {
 
   private val workBuffer = Buffer()
 
-  fun write(record: Record) {
+  /**
+   * Appends a [HprofRecord] to the heap dump. If [record] is a [HprofRecord.HeapDumpRecord] then
+   * it will not be written to an in memory buffer and written to file only when the next a record
+   * that is not a [HprofRecord.HeapDumpRecord] is written or when [close] is called.
+   */
+  fun write(record: HprofRecord) {
     sink.write(record)
   }
 
-  private fun BufferedSink.write(record: Record) {
+  /**
+   * Helper method for creating a [ByteArray] for [InstanceDumpRecord.fieldValues] from a
+   * list of [ValueHolder].
+   */
+  fun valuesToBytes(values: List<ValueHolder>): ByteArray {
+    val valuesBuffer = Buffer()
+    values.forEach { value ->
+        valuesBuffer.writeValue(value)
+    }
+    return valuesBuffer.readByteArray()
+  }
+
+  /**
+   * Flushes to disk all [HprofRecord.HeapDumpRecord] that are currently written to the in memory
+   * buffer, then closes the file.
+   */
+  override fun close() {
+    sink.flushHeapBuffer()
+    sink.close()
+  }
+
+  private fun BufferedSink.writeValue(wrapper: ValueHolder) {
+    when (wrapper) {
+      is ReferenceHolder -> writeId(wrapper.value)
+      is BooleanHolder -> writeBoolean(wrapper.value)
+      is CharHolder -> write(charArrayOf(wrapper.value))
+      is FloatHolder -> writeFloat(wrapper.value)
+      is DoubleHolder -> writeDouble(wrapper.value)
+      is ByteHolder -> writeByte(wrapper.value.toInt())
+      is ShortHolder -> writeShort(wrapper.value.toInt())
+      is IntHolder -> writeInt(wrapper.value)
+      is LongHolder -> writeLong(wrapper.value)
+    }
+  }
+
+  private fun BufferedSink.write(record: HprofRecord) {
     when (record) {
       is StringRecord -> {
-        writeNonHeapRecord(HprofPushRecordsParser.STRING_IN_UTF8) {
+        writeNonHeapRecord(HprofReader.STRING_IN_UTF8) {
           writeId(record.id)
           writeUtf8(record.string)
         }
       }
       is LoadClassRecord -> {
-        writeNonHeapRecord(HprofPushRecordsParser.LOAD_CLASS) {
+        writeNonHeapRecord(HprofReader.LOAD_CLASS) {
           writeInt(record.classSerialNumber)
           writeId(record.id)
           writeInt(record.stackTraceSerialNumber)
@@ -83,7 +134,7 @@ class HprofWriter private constructor(
         }
       }
       is StackTraceRecord -> {
-        writeNonHeapRecord(HprofPushRecordsParser.STACK_TRACE) {
+        writeNonHeapRecord(HprofReader.STACK_TRACE) {
           writeInt(record.stackTraceSerialNumber)
           writeInt(record.threadSerialNumber)
           writeInt(record.stackFrameIds.size)
@@ -94,80 +145,80 @@ class HprofWriter private constructor(
         with(workBuffer) {
           when (val gcRoot = record.gcRoot) {
             is Unknown -> {
-              writeByte(HprofPushRecordsParser.ROOT_UNKNOWN)
+              writeByte(HprofReader.ROOT_UNKNOWN)
               writeId(gcRoot.id)
             }
             is JniGlobal -> {
               writeByte(
-                  HprofPushRecordsParser.ROOT_JNI_GLOBAL
+                  HprofReader.ROOT_JNI_GLOBAL
               )
               writeId(gcRoot.id)
               writeId(gcRoot.jniGlobalRefId)
             }
             is JniLocal -> {
-              writeByte(HprofPushRecordsParser.ROOT_JNI_LOCAL)
+              writeByte(HprofReader.ROOT_JNI_LOCAL)
               writeId(gcRoot.id)
               writeInt(gcRoot.threadSerialNumber)
               writeInt(gcRoot.frameNumber)
             }
             is JavaFrame -> {
-              writeByte(HprofPushRecordsParser.ROOT_JAVA_FRAME)
+              writeByte(HprofReader.ROOT_JAVA_FRAME)
               writeId(gcRoot.id)
               writeInt(gcRoot.threadSerialNumber)
               writeInt(gcRoot.frameNumber)
             }
             is NativeStack -> {
-              writeByte(HprofPushRecordsParser.ROOT_NATIVE_STACK)
+              writeByte(HprofReader.ROOT_NATIVE_STACK)
               writeId(gcRoot.id)
               writeInt(gcRoot.threadSerialNumber)
             }
             is StickyClass -> {
-              writeByte(HprofPushRecordsParser.ROOT_STICKY_CLASS)
+              writeByte(HprofReader.ROOT_STICKY_CLASS)
               writeId(gcRoot.id)
             }
             is ThreadBlock -> {
-              writeByte(HprofPushRecordsParser.ROOT_THREAD_BLOCK)
+              writeByte(HprofReader.ROOT_THREAD_BLOCK)
               writeId(gcRoot.id)
               writeInt(gcRoot.threadSerialNumber)
             }
             is MonitorUsed -> {
-              writeByte(HprofPushRecordsParser.ROOT_MONITOR_USED)
+              writeByte(HprofReader.ROOT_MONITOR_USED)
               writeId(gcRoot.id)
             }
             is ThreadObject -> {
-              writeByte(HprofPushRecordsParser.ROOT_THREAD_OBJECT)
+              writeByte(HprofReader.ROOT_THREAD_OBJECT)
               writeId(gcRoot.id)
               writeInt(gcRoot.threadSerialNumber)
               writeInt(gcRoot.stackTraceSerialNumber)
             }
             is ReferenceCleanup -> {
-              writeByte(HprofPushRecordsParser.ROOT_REFERENCE_CLEANUP)
+              writeByte(HprofReader.ROOT_REFERENCE_CLEANUP)
               writeId(gcRoot.id)
             }
             is VmInternal -> {
-              writeByte(HprofPushRecordsParser.ROOT_VM_INTERNAL)
+              writeByte(HprofReader.ROOT_VM_INTERNAL)
               writeId(gcRoot.id)
             }
             is JniMonitor -> {
-              writeByte(HprofPushRecordsParser.ROOT_JNI_MONITOR)
+              writeByte(HprofReader.ROOT_JNI_MONITOR)
               writeId(gcRoot.id)
               writeInt(gcRoot.stackTraceSerialNumber)
               writeInt(gcRoot.stackDepth)
             }
             is InternedString -> {
-              writeByte(HprofPushRecordsParser.ROOT_INTERNED_STRING)
+              writeByte(HprofReader.ROOT_INTERNED_STRING)
               writeId(gcRoot.id)
             }
             is Finalizing -> {
-              writeByte(HprofPushRecordsParser.ROOT_FINALIZING)
+              writeByte(HprofReader.ROOT_FINALIZING)
               writeId(gcRoot.id)
             }
             is Debugger -> {
-              writeByte(HprofPushRecordsParser.ROOT_DEBUGGER)
+              writeByte(HprofReader.ROOT_DEBUGGER)
               writeId(gcRoot.id)
             }
             is Unreachable -> {
-              writeByte(HprofPushRecordsParser.ROOT_UNREACHABLE)
+              writeByte(HprofReader.ROOT_UNREACHABLE)
               writeId(gcRoot.id)
             }
           }
@@ -175,10 +226,10 @@ class HprofWriter private constructor(
       }
       is ClassDumpRecord -> {
         with(workBuffer) {
-          writeByte(HprofPushRecordsParser.CLASS_DUMP)
+          writeByte(HprofReader.CLASS_DUMP)
           writeId(record.id)
           writeInt(record.stackTraceSerialNumber)
-          writeId(record.superClassId)
+          writeId(record.superclassId)
           writeId(record.classLoaderId)
           writeId(record.signersId)
           writeId(record.protectionDomainId)
@@ -205,7 +256,7 @@ class HprofWriter private constructor(
       }
       is InstanceDumpRecord -> {
         with(workBuffer) {
-          writeByte(HprofPushRecordsParser.INSTANCE_DUMP)
+          writeByte(HprofReader.INSTANCE_DUMP)
           writeId(record.id)
           writeInt(record.stackTraceSerialNumber)
           writeId(record.classId)
@@ -215,7 +266,7 @@ class HprofWriter private constructor(
       }
       is ObjectArrayDumpRecord -> {
         with(workBuffer) {
-          writeByte(HprofPushRecordsParser.OBJECT_ARRAY_DUMP)
+          writeByte(HprofReader.OBJECT_ARRAY_DUMP)
           writeId(record.id)
           writeInt(record.stackTraceSerialNumber)
           writeInt(record.elementIds.size)
@@ -225,49 +276,49 @@ class HprofWriter private constructor(
       }
       is PrimitiveArrayDumpRecord -> {
         with(workBuffer) {
-          writeByte(HprofPushRecordsParser.PRIMITIVE_ARRAY_DUMP)
+          writeByte(HprofReader.PRIMITIVE_ARRAY_DUMP)
           writeId(record.id)
           writeInt(record.stackTraceSerialNumber)
 
           when (record) {
             is BooleanArrayDump -> {
               writeInt(record.array.size)
-              writeByte(HprofReader.BOOLEAN_TYPE)
+              writeByte(BOOLEAN.hprofType)
               write(record.array)
             }
             is CharArrayDump -> {
               writeInt(record.array.size)
-              writeByte(HprofReader.CHAR_TYPE)
+              writeByte(CHAR.hprofType)
               write(record.array)
             }
             is FloatArrayDump -> {
               writeInt(record.array.size)
-              writeByte(HprofReader.FLOAT_TYPE)
+              writeByte(FLOAT.hprofType)
               write(record.array)
             }
             is DoubleArrayDump -> {
               writeInt(record.array.size)
-              writeByte(HprofReader.DOUBLE_TYPE)
+              writeByte(DOUBLE.hprofType)
               write(record.array)
             }
             is ByteArrayDump -> {
               writeInt(record.array.size)
-              writeByte(HprofReader.BYTE_TYPE)
+              writeByte(BYTE.hprofType)
               write(record.array)
             }
             is ShortArrayDump -> {
               writeInt(record.array.size)
-              writeByte(HprofReader.SHORT_TYPE)
+              writeByte(SHORT.hprofType)
               write(record.array)
             }
             is IntArrayDump -> {
               writeInt(record.array.size)
-              writeByte(HprofReader.INT_TYPE)
+              writeByte(INT.hprofType)
               write(record.array)
             }
             is LongArrayDump -> {
               writeInt(record.array.size)
-              writeByte(HprofReader.LONG_TYPE)
+              writeByte(LONG.hprofType)
               write(record.array)
             }
           }
@@ -275,7 +326,7 @@ class HprofWriter private constructor(
       }
       is HeapDumpInfoRecord -> {
         with(workBuffer) {
-          writeByte(HprofPushRecordsParser.HEAP_DUMP_INFO)
+          writeByte(HprofReader.HEAP_DUMP_INFO)
           writeInt(record.heapId)
           writeId(record.heapNameStringId)
         }
@@ -286,20 +337,6 @@ class HprofWriter private constructor(
     }
   }
 
-  fun BufferedSink.writeValue(wrapper: HeapValue) {
-    when (wrapper) {
-      is ObjectReference -> writeId(wrapper.value)
-      is BooleanValue -> writeBoolean(wrapper.value)
-      is CharValue -> write(charArrayOf(wrapper.value))
-      is FloatValue -> writeFloat(wrapper.value)
-      is DoubleValue -> writeDouble(wrapper.value)
-      is ByteValue -> writeByte(wrapper.value.toInt())
-      is ShortValue -> writeShort(wrapper.value.toInt())
-      is IntValue -> writeInt(wrapper.value)
-      is LongValue -> writeLong(wrapper.value)
-    }
-  }
-
   private fun BufferedSink.writeDouble(value: Double) {
     writeLong(value.toBits())
   }
@@ -356,9 +393,9 @@ class HprofWriter private constructor(
 
   private fun BufferedSink.flushHeapBuffer() {
     if (workBuffer.size > 0) {
-      writeTagHeader(HprofPushRecordsParser.HEAP_DUMP, workBuffer.size)
+      writeTagHeader(HprofReader.HEAP_DUMP, workBuffer.size)
       writeAll(workBuffer)
-      writeTagHeader(HprofPushRecordsParser.HEAP_DUMP_END, 0)
+      writeTagHeader(HprofReader.HEAP_DUMP_END, 0)
     }
   }
 
@@ -373,7 +410,7 @@ class HprofWriter private constructor(
   }
 
   private fun BufferedSink.writeId(id: Long) {
-    when (idSize) {
+    when (identifierByteSize) {
       1 -> writeByte(id.toInt())
       2 -> writeShort(id.toInt())
       4 -> writeInt(id.toInt())
@@ -382,28 +419,30 @@ class HprofWriter private constructor(
     }
   }
 
-  override fun close() {
-    sink.flushHeapBuffer()
-    sink.close()
-  }
-
   companion object {
+    /**
+     * Opens a new file for writing hprof records. Don't forget to call [close] once done.
+     */
     fun open(
       hprofFile: File,
-      idSize: Int = 4
+      /**
+       * Size of Hprof identifiers. Identifiers are used to represent UTF8 strings, objects,
+       * stack traces, etc. They can have the same size as host pointers or sizeof(void*), but are
+       * not required to be.
+       */
+      identifierByteSize: Int = 4,
+      /** Version of the opened hprof, which is tied to the runtime where the heap was dumped. */
+      hprofVersion: HprofVersion = HprofVersion.ANDROID
     ): HprofWriter {
-
       val sink = hprofFile.outputStream()
           .sink()
           .buffer()
-
-      val hprofVersion = "JAVA PROFILE 1.0.3"
-      sink.writeUtf8(hprofVersion)
+      sink.writeUtf8(hprofVersion.versionString)
       sink.writeByte(0)
-      sink.writeInt(idSize)
+      sink.writeInt(identifierByteSize)
       val heapDumpTimestamp = System.currentTimeMillis()
       sink.writeLong(heapDumpTimestamp)
-      return HprofWriter(sink, idSize)
+      return HprofWriter(sink, identifierByteSize, hprofVersion)
     }
   }
 }
\ No newline at end of file
diff --git a/shark-hprof/src/main/java/shark/OnHprofRecordListener.kt b/shark-hprof/src/main/java/shark/OnHprofRecordListener.kt
new file mode 100644
index 00000000..c613e3f2
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/OnHprofRecordListener.kt
@@ -0,0 +1,40 @@
+package shark
+
+/**
+ * Listener passed in to [HprofReader.readHprofRecords], gets notified for each [HprofRecord]
+ * found in the heap dump which types is in the set of the recordTypes parameter passed to
+ * [HprofReader.readHprofRecords].
+ */
+interface OnHprofRecordListener {
+  fun onHprofRecord(
+    /**
+     * The position of the record in the underlying hprof file.
+     */
+    position: Long,
+    record: HprofRecord
+  )
+
+  companion object {
+    /**
+     * Utility function to create a [OnHprofRecordListener] from the passed in [block] lambda
+     * instead of using the anonymous `object : OnHprofRecordListener` syntax.
+     *
+     * Usage:
+     *
+     * ```kotlin
+     * val listener = OnHprofRecordListener { position, record ->
+     *
+     * }
+     * ```
+     */
+    inline operator fun invoke(crossinline block: (Long, HprofRecord) -> Unit): OnHprofRecordListener =
+      object : OnHprofRecordListener {
+        override fun onHprofRecord(
+          position: Long,
+          record: HprofRecord
+        ) {
+          block(position, record)
+        }
+      }
+  }
+}
\ No newline at end of file
diff --git a/shark-hprof/src/main/java/shark/PrimitiveType.kt b/shark-hprof/src/main/java/shark/PrimitiveType.kt
new file mode 100644
index 00000000..8c39f497
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/PrimitiveType.kt
@@ -0,0 +1,33 @@
+package shark
+
+/**
+ * A primitive type in the prof.
+ */
+enum class PrimitiveType(
+  /**
+   * The hprof defined "basic type".
+   */
+  val hprofType: Int,
+  /**
+   * The size in bytes for each value of that type.
+   */
+  val byteSize: Int
+) {
+  BOOLEAN(4, 1),
+  CHAR(5, 2),
+  FLOAT(6, 4),
+  DOUBLE(7, 8),
+  BYTE(8, 1),
+  SHORT(9, 2),
+  INT(10, 4),
+  LONG(11, 8);
+
+  companion object {
+    /**
+     * The hprof defined "basic type" for references.
+     */
+    const val REFERENCE_HPROF_TYPE = 2
+
+    val byteSizeByHprofType = values().map { it.hprofType to it.byteSize }.toMap()
+  }
+}
\ No newline at end of file
diff --git a/shark-hprof/src/main/java/shark/ValueHolder.kt b/shark-hprof/src/main/java/shark/ValueHolder.kt
new file mode 100644
index 00000000..ed53c436
--- /dev/null
+++ b/shark-hprof/src/main/java/shark/ValueHolder.kt
@@ -0,0 +1,27 @@
+package shark
+
+import shark.ValueHolder.ReferenceHolder
+
+/**
+ * A value in the heap dump, which can be a [ReferenceHolder] or
+ * a primitive type.
+ */
+sealed class ValueHolder {
+  data class ReferenceHolder(val value: Long) : ValueHolder() {
+    val isNull
+      get() = value == NULL_REFERENCE
+  }
+
+  data class BooleanHolder(val value: Boolean) : ValueHolder()
+  data class CharHolder(val value: Char) : ValueHolder()
+  data class FloatHolder(val value: Float) : ValueHolder()
+  data class DoubleHolder(val value: Double) : ValueHolder()
+  data class ByteHolder(val value: Byte) : ValueHolder()
+  data class ShortHolder(val value: Short) : ValueHolder()
+  data class IntHolder(val value: Int) : ValueHolder()
+  data class LongHolder(val value: Long) : ValueHolder()
+
+  companion object {
+    const val NULL_REFERENCE = 0L
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-log/build.gradle b/shark-log/build.gradle
similarity index 100%
rename from leakcanary-log/build.gradle
rename to shark-log/build.gradle
diff --git a/shark-log/gradle.properties b/shark-log/gradle.properties
new file mode 100644
index 00000000..319b4dfc
--- /dev/null
+++ b/shark-log/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=shark-log
+POM_NAME=Shark Log
+POM_PACKAGING=jar
diff --git a/leakcanary-log/src/main/java/leakcanary/CanaryLog.kt b/shark-log/src/main/java/shark/SharkLog.kt
similarity index 86%
rename from leakcanary-log/src/main/java/leakcanary/CanaryLog.kt
rename to shark-log/src/main/java/shark/SharkLog.kt
index cb2ab6e7..b0efe8d1 100644
--- a/leakcanary-log/src/main/java/leakcanary/CanaryLog.kt
+++ b/shark-log/src/main/java/shark/SharkLog.kt
@@ -1,12 +1,12 @@
-package leakcanary
+package shark
 
 /**
- * Central Logger for all LeakCanary artifacts. Set [logger] to change where these logs go.
+ * Central Logger for all Shark artifacts. Set [logger] to change where these logs go.
  */
-object CanaryLog {
+object SharkLog {
 
   /**
-   * @see CanaryLog
+   * @see SharkLog
    */
   interface Logger {
 
diff --git a/shark/build.gradle b/shark/build.gradle
new file mode 100644
index 00000000..a9040a90
--- /dev/null
+++ b/shark/build.gradle
@@ -0,0 +1,18 @@
+apply plugin: 'java-library'
+apply plugin: 'kotlin'
+
+sourceCompatibility = JavaVersion.VERSION_1_7
+targetCompatibility = JavaVersion.VERSION_1_7
+
+dependencies {
+  api project(':shark-graph')
+
+  implementation deps.kotlin.stdlib
+
+  testImplementation deps.assertj_core
+  testImplementation deps.junit
+  testImplementation deps.okio
+}
+
+apply from: rootProject.file('gradle/checkstyle.gradle')
+apply from: rootProject.file('gradle/gradle-mvn-push.gradle')
\ No newline at end of file
diff --git a/shark/gradle.properties b/shark/gradle.properties
new file mode 100644
index 00000000..0053d064
--- /dev/null
+++ b/shark/gradle.properties
@@ -0,0 +1,3 @@
+POM_ARTIFACT_ID=shark
+POM_NAME=Shark
+POM_PACKAGING=jar
diff --git a/shark/src/main/java/shark/AppSingletonInspector.kt b/shark/src/main/java/shark/AppSingletonInspector.kt
new file mode 100644
index 00000000..80ecf84b
--- /dev/null
+++ b/shark/src/main/java/shark/AppSingletonInspector.kt
@@ -0,0 +1,23 @@
+package shark
+
+import shark.HeapObject.HeapInstance
+
+/**
+ * Inspector that automatically marks instances of the provided class names as not leaking
+ * because they're app wide singletons.
+ */
+class AppSingletonInspector(private vararg val singletonClasses: String) : ObjectInspector {
+  override fun inspect(
+    reporter: ObjectReporter
+  ) {
+    if (reporter.heapObject is HeapInstance) {
+      reporter.heapObject.instanceClass
+          .classHierarchy
+          .forEach { heapClass ->
+            if (heapClass.name in singletonClasses) {
+              reporter.reportNotLeaking("${heapClass.name} is an app singleton")
+            }
+          }
+    }
+  }
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/HeapAnalysis.kt b/shark/src/main/java/shark/HeapAnalysis.kt
new file mode 100644
index 00000000..8aeb101d
--- /dev/null
+++ b/shark/src/main/java/shark/HeapAnalysis.kt
@@ -0,0 +1,146 @@
+package shark
+
+import shark.internal.createSHA1Hash
+import java.io.File
+import java.io.Serializable
+
+/**
+ * The result of an analysis performed by [HeapAnalyzer], either a [HeapAnalysisSuccess] or a
+ * [HeapAnalysisFailure]. This class is serializable however there are no guarantees of forward
+ * compatibility.
+ */
+sealed class HeapAnalysis : Serializable {
+  /**
+   * The hprof file that was analyzed.
+   */
+  abstract val heapDumpFile: File
+
+  /**
+   * The [System.currentTimeMillis] when this [HeapAnalysis] instance was created.
+   */
+  abstract val createdAtTimeMillis: Long
+
+  /**
+   * Total time spent analyzing the heap.
+   */
+  abstract val analysisDurationMillis: Long
+}
+
+/**
+ * The analysis performed by [HeapAnalyzer] did not complete successfully.
+ */
+data class HeapAnalysisFailure(
+  override val heapDumpFile: File,
+  override val createdAtTimeMillis: Long,
+  override val analysisDurationMillis: Long,
+  /**
+   * An exception wrapping the actual exception that was thrown.
+   */
+  val exception: HeapAnalysisException
+) : HeapAnalysis()
+
+/**
+ * The result of a successful heap analysis performed by [HeapAnalyzer].
+ */
+data class HeapAnalysisSuccess(
+  override val heapDumpFile: File,
+  override val createdAtTimeMillis: Long,
+  override val analysisDurationMillis: Long,
+  /**
+   * The list of [ApplicationLeak] found in the heap dump by [HeapAnalyzer].
+   */
+  val applicationLeaks: List<ApplicationLeak>,
+  /**
+   * The list of [LibraryLeak] found in the heap dump by [HeapAnalyzer].
+   */
+  val libraryLeaks: List<LibraryLeak>
+) : HeapAnalysis() {
+  /**
+   * The list of [Leak] found in the heap dump by [HeapAnalyzer], ie all [applicationLeaks] and
+   * all [libraryLeaks] in one list.
+   */
+  val allLeaks: List<Leak>
+    get() = applicationLeaks + libraryLeaks
+}
+
+/**
+ * A leak found by [HeapAnalyzer], either an [ApplicationLeak] or a [LibraryLeak].
+ */
+sealed class Leak : Serializable {
+  /**
+   * Class name of the leaking object.
+   * The class name format is the same as what would be returned by [Class.getName].
+   */
+  abstract val className: String
+
+  /**
+   * Shortest path from GC roots to the leaking object.
+   */
+  abstract val leakTrace: LeakTrace
+
+  /**
+   * The number of bytes which would be freed if all references to the leaking object were
+   * released. Null if the retained heap size was not computed.
+   */
+  abstract val retainedHeapByteSize: Int?
+
+  /**
+   * A unique SHA1 hash that represents this group of leaks.
+   *
+   * For [ApplicationLeak] this is based on [LeakTrace.leakCauses] and for [LibraryLeak] this is
+   * based on [LibraryLeak.pattern].
+   */
+  val groupHash
+    get() = createGroupHash()
+
+  /**
+   * Returns [className] stripped of any string content before the last period (included).
+   */
+  val classSimpleName: String
+    get() {
+      val separator = className.lastIndexOf('.')
+      return if (separator == -1) className else className.substring(separator + 1)
+    }
+
+  protected abstract fun createGroupHash(): String
+}
+
+/**
+ * A leak found by [HeapAnalyzer], where the only path to the leaking object required going
+ * through a reference matched by [pattern], as provided to a [LibraryLeakReferenceMatcher]
+ * instance. This is a known leak in library code that is beyond your control.
+ */
+data class LibraryLeak(
+  override val className: String,
+  override val leakTrace: LeakTrace,
+  override val retainedHeapByteSize: Int?,
+  /**
+   * The pattern that matched one of the references in [leakTrace], as provided to a
+   * [LibraryLeakReferenceMatcher] instance.
+   */
+  val pattern: ReferencePattern,
+  /**
+   * A description that conveys what we know about this library leak.
+   */
+  val description: String
+) : Leak() {
+  override fun createGroupHash() = pattern.toString().createSHA1Hash()
+}
+
+/**
+ * A leak found by [HeapAnalyzer] in your application.
+ */
+data class ApplicationLeak(
+  override val className: String,
+  override val leakTrace: LeakTrace,
+  override val retainedHeapByteSize: Int?
+) : Leak() {
+  override fun createGroupHash(): String {
+    return leakTrace.leakCauses
+        .joinToString(separator = "") { element ->
+          val referenceName = element.reference!!.groupingName
+          element.className + referenceName
+        }
+        .createSHA1Hash()
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysisException.kt b/shark/src/main/java/shark/HeapAnalysisException.kt
similarity index 93%
rename from leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysisException.kt
rename to shark/src/main/java/shark/HeapAnalysisException.kt
index 313fafde..5a1205a2 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalysisException.kt
+++ b/shark/src/main/java/shark/HeapAnalysisException.kt
@@ -1,4 +1,4 @@
-package leakcanary
+package shark
 
 import java.io.PrintWriter
 import java.io.StringWriter
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt b/shark/src/main/java/shark/HeapAnalyzer.kt
similarity index 79%
rename from leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
rename to shark/src/main/java/shark/HeapAnalyzer.kt
index 0f0cf088..08599d46 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/HeapAnalyzer.kt
+++ b/shark/src/main/java/shark/HeapAnalyzer.kt
@@ -13,46 +13,44 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package leakcanary
-
-import leakcanary.AnalyzerProgressListener.Step.BUILDING_LEAK_TRACES
-import leakcanary.AnalyzerProgressListener.Step.COMPUTING_NATIVE_RETAINED_SIZE
-import leakcanary.AnalyzerProgressListener.Step.COMPUTING_RETAINED_SIZE
-import leakcanary.AnalyzerProgressListener.Step.FINDING_LEAKING_INSTANCES
-import leakcanary.AnalyzerProgressListener.Step.PARSING_HEAP_DUMP
-import leakcanary.GcRoot.JavaFrame
-import leakcanary.GcRoot.JniGlobal
-import leakcanary.GcRoot.JniLocal
-import leakcanary.GcRoot.JniMonitor
-import leakcanary.GcRoot.MonitorUsed
-import leakcanary.GcRoot.NativeStack
-import leakcanary.GcRoot.ReferenceCleanup
-import leakcanary.GcRoot.StickyClass
-import leakcanary.GcRoot.ThreadBlock
-import leakcanary.GcRoot.ThreadObject
-import leakcanary.GraphObjectRecord.GraphClassRecord
-import leakcanary.GraphObjectRecord.GraphInstanceRecord
-import leakcanary.GraphObjectRecord.GraphObjectArrayRecord
-import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
-import leakcanary.HeapAnalyzer.TrieNode.LeafNode
-import leakcanary.HeapAnalyzer.TrieNode.ParentNode
-import leakcanary.Leak.ApplicationLeak
-import leakcanary.Leak.LibraryLeak
-import leakcanary.LeakNodeStatus.LEAKING
-import leakcanary.LeakNodeStatus.NOT_LEAKING
-import leakcanary.LeakNodeStatus.UNKNOWN
-import leakcanary.LeakTraceElement.Holder.ARRAY
-import leakcanary.LeakTraceElement.Holder.CLASS
-import leakcanary.LeakTraceElement.Holder.OBJECT
-import leakcanary.LeakTraceElement.Holder.THREAD
-import leakcanary.internal.ReferencePathNode
-import leakcanary.internal.ReferencePathNode.ChildNode
-import leakcanary.internal.ReferencePathNode.ChildNode.LibraryLeakNode
-import leakcanary.internal.ReferencePathNode.RootNode
-import leakcanary.internal.ShortestPathFinder
-import leakcanary.internal.ShortestPathFinder.Results
-import leakcanary.internal.hppc.LongLongScatterMap
-import leakcanary.internal.lastSegment
+package shark
+
+import shark.OnAnalysisProgressListener.Step.BUILDING_LEAK_TRACES
+import shark.OnAnalysisProgressListener.Step.COMPUTING_NATIVE_RETAINED_SIZE
+import shark.OnAnalysisProgressListener.Step.COMPUTING_RETAINED_SIZE
+import shark.OnAnalysisProgressListener.Step.FINDING_LEAKING_INSTANCES
+import shark.OnAnalysisProgressListener.Step.PARSING_HEAP_DUMP
+import shark.GcRoot.JavaFrame
+import shark.GcRoot.JniGlobal
+import shark.GcRoot.JniLocal
+import shark.GcRoot.JniMonitor
+import shark.GcRoot.MonitorUsed
+import shark.GcRoot.NativeStack
+import shark.GcRoot.ReferenceCleanup
+import shark.GcRoot.StickyClass
+import shark.GcRoot.ThreadBlock
+import shark.GcRoot.ThreadObject
+import shark.HeapAnalyzer.TrieNode.LeafNode
+import shark.HeapAnalyzer.TrieNode.ParentNode
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HeapObject.HeapObjectArray
+import shark.HeapObject.HeapPrimitiveArray
+import shark.LeakNodeStatus.LEAKING
+import shark.LeakNodeStatus.NOT_LEAKING
+import shark.LeakNodeStatus.UNKNOWN
+import shark.LeakTraceElement.Holder.ARRAY
+import shark.LeakTraceElement.Holder.CLASS
+import shark.LeakTraceElement.Holder.OBJECT
+import shark.LeakTraceElement.Holder.THREAD
+import shark.internal.ReferencePathNode
+import shark.internal.ReferencePathNode.ChildNode
+import shark.internal.ReferencePathNode.ChildNode.LibraryLeakNode
+import shark.internal.ReferencePathNode.RootNode
+import shark.internal.ShortestPathFinder
+import shark.internal.ShortestPathFinder.Results
+import shark.internal.hppc.LongLongScatterMap
+import shark.internal.lastSegment
 import java.io.File
 import java.util.ArrayList
 import java.util.LinkedHashMap
@@ -62,12 +60,12 @@ import java.util.concurrent.TimeUnit.NANOSECONDS
  * Analyzes heap dumps to look for leaks.
  */
 class HeapAnalyzer constructor(
-  private val listener: AnalyzerProgressListener
+  private val listener: OnAnalysisProgressListener
 ) {
 
   /**
-   * Searches the heap dump for a [KeyedWeakReference] instance with the corresponding key,
-   * and then computes the shortest strong reference path from that instance to the GC roots.
+   * Searches the heap dump for leaking instances and then computes the shortest strong reference
+   * path from those instances to the GC roots.
    */
   fun checkForLeaks(
     heapDumpFile: File,
@@ -87,11 +85,10 @@ class HeapAnalyzer constructor(
     }
 
     try {
-      listener.onProgressUpdate(PARSING_HEAP_DUMP)
-      val (graph, hprofCloseable) = HprofGraph.readHprof(heapDumpFile)
-
-      hprofCloseable.use {
-        listener.onProgressUpdate(FINDING_LEAKING_INSTANCES)
+      listener.onAnalysisProgress(PARSING_HEAP_DUMP)
+      Hprof.open(heapDumpFile).use { hprof ->
+        val graph = HprofHeapGraph.indexHprof(hprof)
+        listener.onAnalysisProgress(FINDING_LEAKING_INSTANCES)
 
         val leakingInstanceObjectIds = findLeakingInstances(graph, leakFinders)
 
@@ -124,14 +121,14 @@ class HeapAnalyzer constructor(
   }
 
   private fun findLeakingInstances(
-    graph: HprofGraph,
+    graph: HeapGraph,
     objectInspectors: List<ObjectInspector>
   ): Set<Long> {
     return graph.objects
         .filter { objectRecord ->
           val reporter = ObjectReporter(objectRecord)
           objectInspectors.forEach { inspector ->
-            inspector.inspect(graph, reporter)
+            inspector.inspect(reporter)
           }
           reporter.leakingStatuses.isNotEmpty()
         }
@@ -140,7 +137,7 @@ class HeapAnalyzer constructor(
   }
 
   private fun findShortestPaths(
-    graph: HprofGraph,
+    graph: HeapGraph,
     referenceMatchers: List<ReferenceMatcher>,
     leakingInstanceObjectIds: Set<Long>,
     computeDominators: Boolean
@@ -228,11 +225,11 @@ class HeapAnalyzer constructor(
   }
 
   private fun computeRetainedSizes(
-    graph: HprofGraph,
+    graph: HeapGraph,
     results: List<ReferencePathNode>,
     dominatedInstances: LongLongScatterMap
   ): List<Int> {
-    listener.onProgressUpdate(COMPUTING_NATIVE_RETAINED_SIZE)
+    listener.onAnalysisProgress(COMPUTING_NATIVE_RETAINED_SIZE)
 
     // Map of Object id to native size as tracked by NativeAllocationRegistry$CleanerThunk
     val nativeSizes = mutableMapOf<Long, Int>().withDefault { 0 }
@@ -247,7 +244,7 @@ class HeapAnalyzer constructor(
     // the CleanerThunk. The hprof does not include the native bytes pointed to.
 
     graph.instances
-        .filter { it.className == "sun.misc.Cleaner" }
+        .filter { it.instanceClassName == "sun.misc.Cleaner" }
         .forEach { cleaner ->
           val thunkField = cleaner["sun.misc.Cleaner", "thunk"]
           val thunkId = thunkField?.value?.asNonNullObjectId
@@ -255,12 +252,12 @@ class HeapAnalyzer constructor(
             cleaner["java.lang.ref.Reference", "referent"]?.value?.asNonNullObjectId
           if (thunkId != null && referentId != null) {
             val thunkRecord = thunkField.value.asObject
-            if (thunkRecord is GraphInstanceRecord && thunkRecord instanceOf "libcore.util.NativeAllocationRegistry\$CleanerThunk") {
+            if (thunkRecord is HeapInstance && thunkRecord instanceOf "libcore.util.NativeAllocationRegistry\$CleanerThunk") {
               val allocationRegistryIdField =
                 thunkRecord["libcore.util.NativeAllocationRegistry\$CleanerThunk", "this\$0"]
               if (allocationRegistryIdField != null && allocationRegistryIdField.value.isNonNullReference) {
                 val allocationRegistryRecord = allocationRegistryIdField.value.asObject
-                if (allocationRegistryRecord is GraphInstanceRecord && allocationRegistryRecord instanceOf "libcore.util.NativeAllocationRegistry") {
+                if (allocationRegistryRecord is HeapInstance && allocationRegistryRecord instanceOf "libcore.util.NativeAllocationRegistry") {
                   var nativeSize = nativeSizes.getValue(referentId)
                   nativeSize += allocationRegistryRecord["libcore.util.NativeAllocationRegistry", "size"]?.value?.asLong?.toInt()
                       ?: 0
@@ -271,7 +268,7 @@ class HeapAnalyzer constructor(
           }
         }
 
-    listener.onProgressUpdate(COMPUTING_RETAINED_SIZE)
+    listener.onAnalysisProgress(COMPUTING_RETAINED_SIZE)
 
     val sizeByDominator = LinkedHashMap<Long, Int>().withDefault { 0 }
 
@@ -280,12 +277,11 @@ class HeapAnalyzer constructor(
     results.forEach { pathNode ->
       val leakingInstanceObjectId = pathNode.instance
       leakingInstanceIds.add(leakingInstanceObjectId)
-      val instanceRecord = graph.findObjectByObjectId(leakingInstanceObjectId).asInstance!!
-      val classRecord = instanceRecord.instanceClass
+      val instanceRecord = graph.findObjectById(leakingInstanceObjectId).asInstance!!
+      val heapClass = instanceRecord.instanceClass
       var retainedSize = sizeByDominator.getValue(leakingInstanceObjectId)
 
-      retainedSize += classRecord.readRecord()
-          .instanceSize
+      retainedSize += heapClass.instanceByteSize
       sizeByDominator[leakingInstanceObjectId] = retainedSize
     }
 
@@ -295,11 +291,11 @@ class HeapAnalyzer constructor(
       if (instanceId !in leakingInstanceIds) {
         val currentSize = sizeByDominator.getValue(dominatorId)
         val nativeSize = nativeSizes.getValue(instanceId)
-        val shallowSize = when (val objectRecord = graph.findObjectByObjectId(instanceId)) {
-          is GraphInstanceRecord -> objectRecord.size
-          is GraphObjectArrayRecord -> objectRecord.readSize()
-          is GraphPrimitiveArrayRecord -> objectRecord.readSize()
-          is GraphClassRecord -> throw IllegalStateException(
+        val shallowSize = when (val objectRecord = graph.findObjectById(instanceId)) {
+          is HeapInstance -> objectRecord.byteSize
+          is HeapObjectArray -> objectRecord.readByteSize()
+          is HeapPrimitiveArray -> objectRecord.readByteSize()
+          is HeapClass -> throw IllegalStateException(
               "Unexpected class record $objectRecord"
           )
         }
@@ -335,10 +331,10 @@ class HeapAnalyzer constructor(
   private fun buildLeakTraces(
     objectInspectors: List<ObjectInspector>,
     shortestPathsToLeakingInstances: List<ReferencePathNode>,
-    graph: HprofGraph,
+    graph: HeapGraph,
     retainedSizes: List<Int>?
   ): Pair<List<ApplicationLeak>, List<LibraryLeak>> {
-    listener.onProgressUpdate(BUILDING_LEAK_TRACES)
+    listener.onAnalysisProgress(BUILDING_LEAK_TRACES)
 
     val applicationLeaks = mutableListOf<ApplicationLeak>()
     val libraryLeaks = mutableListOf<LibraryLeak>()
@@ -359,7 +355,7 @@ class HeapAnalyzer constructor(
         buildLeakTrace(graph, objectInspectors, rootNode, shortestChildPath)
 
       val className =
-        recordClassName(graph.findObjectByObjectId(pathNode.instance))
+        recordClassName(graph.findObjectById(pathNode.instance))
 
       val firstLibraryLeakNode =
         shortestChildPath.firstOrNull { it is LibraryLeakNode } as LibraryLeakNode?
@@ -377,7 +373,7 @@ class HeapAnalyzer constructor(
   }
 
   private fun buildLeakTrace(
-    graph: HprofGraph,
+    graph: HeapGraph,
     objectInspectors: List<ObjectInspector>,
     rootNode: RootNode,
     shortestChildPath: List<ChildNode>
@@ -386,13 +382,13 @@ class HeapAnalyzer constructor(
     shortestPath.add(0, rootNode)
 
     val leakReporters = shortestPath.map {
-      ObjectReporter(graph.findObjectByObjectId(it.instance))
+      ObjectReporter(graph.findObjectById(it.instance))
     }
 
     // Looping on inspectors first to get more cache hits.
     objectInspectors.forEach { inspector ->
       leakReporters.forEach { reporter ->
-        inspector.inspect(graph, reporter)
+        inspector.inspect(reporter)
       }
     }
 
@@ -451,7 +447,7 @@ class HeapAnalyzer constructor(
     }
 
     val simpleClassNames = leakReporters.map { reporter ->
-      recordClassName(reporter.objectRecord).lastSegment('.')
+      recordClassName(reporter.heapObject).lastSegment('.')
     }
 
     // First and last are always known.
@@ -517,7 +513,7 @@ class HeapAnalyzer constructor(
   }
 
   private fun buildLeakElement(
-    graph: HprofGraph,
+    graph: HeapGraph,
     node: ReferencePathNode,
     reference: LeakReference?,
     labels: List<String>,
@@ -525,13 +521,13 @@ class HeapAnalyzer constructor(
   ): LeakTraceElement {
     val objectId = node.instance
 
-    val graphRecord = graph.findObjectByObjectId(objectId)
+    val graphRecord = graph.findObjectById(objectId)
 
     val className = recordClassName(graphRecord)
 
-    val holderType = if (graphRecord is GraphClassRecord) {
+    val holderType = if (graphRecord is HeapClass) {
       CLASS
-    } else if (graphRecord is GraphObjectArrayRecord || graphRecord is GraphPrimitiveArrayRecord) {
+    } else if (graphRecord is HeapObjectArray || graphRecord is HeapPrimitiveArray) {
       ARRAY
     } else {
       val instanceRecord = graphRecord.asInstance!!
@@ -545,22 +541,17 @@ class HeapAnalyzer constructor(
   }
 
   private fun recordClassName(
-    graphRecord: GraphObjectRecord
+    heap: HeapObject
   ): String {
-    return when (graphRecord) {
-      is GraphClassRecord -> graphRecord.name
-      is GraphInstanceRecord -> graphRecord.className
-      is GraphObjectArrayRecord -> graphRecord.arrayClassName
-      is GraphPrimitiveArrayRecord -> graphRecord.arrayClassName
+    return when (heap) {
+      is HeapClass -> heap.name
+      is HeapInstance -> heap.instanceClassName
+      is HeapObjectArray -> heap.arrayClassName
+      is HeapPrimitiveArray -> heap.arrayClassName
     }
   }
 
   private fun since(analysisStartNanoTime: Long): Long {
     return NANOSECONDS.toMillis(System.nanoTime() - analysisStartNanoTime)
   }
-
-  companion object {
-    private const val ANONYMOUS_CLASS_NAME_PATTERN = "^.+\\$\\d+$"
-    internal val ANONYMOUS_CLASS_NAME_PATTERN_REGEX = ANONYMOUS_CLASS_NAME_PATTERN.toRegex()
-  }
 }
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakNodeStatus.kt b/shark/src/main/java/shark/LeakNodeStatus.kt
similarity index 96%
rename from leakcanary-analyzer/src/main/java/leakcanary/LeakNodeStatus.kt
rename to shark/src/main/java/shark/LeakNodeStatus.kt
index 526ef11f..fe81dd2f 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakNodeStatus.kt
+++ b/shark/src/main/java/shark/LeakNodeStatus.kt
@@ -1,4 +1,4 @@
-package leakcanary
+package shark
 
 import java.io.Serializable
 
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakReference.kt b/shark/src/main/java/shark/LeakReference.kt
similarity index 82%
rename from leakcanary-analyzer/src/main/java/leakcanary/LeakReference.kt
rename to shark/src/main/java/shark/LeakReference.kt
index 1673d2d4..58124214 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakReference.kt
+++ b/shark/src/main/java/shark/LeakReference.kt
@@ -13,13 +13,13 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package leakcanary
+package shark
 
-import leakcanary.LeakTraceElement.Type
-import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
-import leakcanary.LeakTraceElement.Type.INSTANCE_FIELD
-import leakcanary.LeakTraceElement.Type.LOCAL
-import leakcanary.LeakTraceElement.Type.STATIC_FIELD
+import shark.LeakTraceElement.Type
+import shark.LeakTraceElement.Type.ARRAY_ENTRY
+import shark.LeakTraceElement.Type.INSTANCE_FIELD
+import shark.LeakTraceElement.Type.LOCAL
+import shark.LeakTraceElement.Type.STATIC_FIELD
 import java.io.Serializable
 
 /**
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakTrace.kt b/shark/src/main/java/shark/LeakTrace.kt
similarity index 70%
rename from leakcanary-analyzer/src/main/java/leakcanary/LeakTrace.kt
rename to shark/src/main/java/shark/LeakTrace.kt
index a12d5238..bb3b9bfd 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakTrace.kt
+++ b/shark/src/main/java/shark/LeakTrace.kt
@@ -1,13 +1,13 @@
-package leakcanary
+package shark
 
-import leakcanary.LeakNodeStatus.NOT_LEAKING
-import leakcanary.LeakNodeStatus.UNKNOWN
-import leakcanary.internal.renderToString
+import shark.LeakNodeStatus.NOT_LEAKING
+import shark.LeakNodeStatus.UNKNOWN
+import shark.internal.renderToString
 import java.io.Serializable
 
 /**
- * A chain of references that constitute the shortest strong reference path from a leaking instance
- * to the GC roots. Fixing the leak usually means breaking one of the references in that chain.
+ * A chain of references that constitute the shortest strong reference path from a GC root to the
+ * leaking object. Fixing the leak usually means breaking one of the references in that chain.
  */
 data class LeakTrace(
   val elements: List<LeakTraceElement>
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElement.kt b/shark/src/main/java/shark/LeakTraceElement.kt
similarity index 81%
rename from leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElement.kt
rename to shark/src/main/java/shark/LeakTraceElement.kt
index 41dafe75..bd49a814 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/LeakTraceElement.kt
+++ b/shark/src/main/java/shark/LeakTraceElement.kt
@@ -1,12 +1,13 @@
-package leakcanary
+package shark
 
-import leakcanary.internal.lastSegment
+import shark.internal.lastSegment
 import java.io.Serializable
 
 data class LeakTraceElement(
   /**
-   * Information about the reference that points to the next [LeakTraceElement] in the leak
-   * chain. Null if this is the last element in the leak trace, ie the leaking object.
+   * Information about the reference that points to the next [LeakTraceElement] in
+   * [LeakTrace.elements]. Null if this is the last element in the leak trace, ie the leaking
+   * object.
    */
   val reference: LeakReference?,
 
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/ObjectInspector.kt b/shark/src/main/java/shark/ObjectInspector.kt
similarity index 72%
rename from leakcanary-analyzer/src/main/java/leakcanary/ObjectInspector.kt
rename to shark/src/main/java/shark/ObjectInspector.kt
index f2724880..f0621504 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/ObjectInspector.kt
+++ b/shark/src/main/java/shark/ObjectInspector.kt
@@ -1,4 +1,6 @@
-package leakcanary
+package shark
+
+import shark.ObjectInspector.Companion.invoke
 
 /**
  * Provides LeakCanary with insights about objects (classes, instances and arrays) found in the
@@ -13,10 +15,7 @@ interface ObjectInspector {
   /**
    * @see [ObjectInspector]
    */
-  fun inspect(
-    graph: HprofGraph,
-    reporter: ObjectReporter
-  )
+  fun inspect(reporter: ObjectReporter)
 
   companion object {
     /**
@@ -26,18 +25,17 @@ interface ObjectInspector {
      * Usage:
      *
      * ```kotlin
-     * val inspector = ObjectInspector { graph, reporter ->
+     * val inspector = ObjectInspector { reporter ->
      *
      * }
      * ```
      */
-    inline operator fun invoke(crossinline block: (HprofGraph, ObjectReporter) -> Unit): ObjectInspector =
+    inline operator fun invoke(crossinline block: (ObjectReporter) -> Unit): ObjectInspector =
       object : ObjectInspector {
         override fun inspect(
-          graph: HprofGraph,
           reporter: ObjectReporter
         ) {
-          block(graph, reporter)
+          block(reporter)
         }
       }
   }
diff --git a/shark/src/main/java/shark/ObjectInspectors.kt b/shark/src/main/java/shark/ObjectInspectors.kt
new file mode 100644
index 00000000..af0d1a8d
--- /dev/null
+++ b/shark/src/main/java/shark/ObjectInspectors.kt
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2018 Square, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package shark
+
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.internal.KeyedWeakReferenceMirror
+
+/**
+ * A set of default [ObjectInspector]s that knows about common JDK objects.
+ */
+enum class ObjectInspectors : ObjectInspector {
+
+  KEYED_WEAK_REFERENCE {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      val graph = reporter.heapObject.graph
+      val references: List<KeyedWeakReferenceMirror> =
+        graph.context.getOrPut(KEYED_WEAK_REFERENCE.name) {
+          val keyedWeakReferenceClass = graph.findClassByName("leakcanary.KeyedWeakReference")
+
+          val heapDumpUptimeMillis = if (keyedWeakReferenceClass == null) {
+            null
+          } else {
+            keyedWeakReferenceClass["heapDumpUptimeMillis"]?.value?.asLong
+          }
+
+          if (heapDumpUptimeMillis == null) {
+            SharkLog.d(
+                "leakcanary.KeyedWeakReference.heapDumpUptimeMillis field not found, " +
+                    "this must be a heap dump from an older version of LeakCanary."
+            )
+          }
+
+          val addedToContext: List<KeyedWeakReferenceMirror> = graph.instances
+              .filter { instance ->
+                val className = instance.instanceClassName
+                className == "leakcanary.KeyedWeakReference" || className == "com.squareup.leakcanary.KeyedWeakReference"
+              }
+              .map { KeyedWeakReferenceMirror.fromInstance(it, heapDumpUptimeMillis) }
+              .filter { it.hasReferent }
+              .toList()
+          graph.context[KEYED_WEAK_REFERENCE.name] = addedToContext
+          addedToContext
+        }
+
+      val objectId = reporter.heapObject.objectId
+      references.forEach { ref ->
+        if (ref.referent.value == objectId) {
+          reporter.reportLeaking("ObjectWatcher was watching this")
+          reporter.addLabel("key = ${ref.key}")
+          if (ref.name.isNotEmpty()) {
+            reporter.addLabel("name = ${ref.name}")
+          }
+          if (ref.watchDurationMillis != null) {
+            reporter.addLabel("watchDurationMillis = ${ref.watchDurationMillis}")
+          }
+          if (ref.retainedDurationMillis != null) {
+            reporter.addLabel("retainedDurationMillis = ${ref.retainedDurationMillis}")
+          }
+        }
+      }
+    }
+  },
+
+  CLASSLOADER {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf(ClassLoader::class) {
+        reportNotLeaking("A ClassLoader is never leaking")
+      }
+    }
+  },
+
+  CLASS {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      if (reporter.heapObject is HeapClass) {
+        reporter.reportNotLeaking("a class is never leaking")
+      }
+    }
+  },
+
+  ANONYMOUS_CLASS {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      val heapObject = reporter.heapObject
+      if (heapObject is HeapInstance) {
+        val instanceClass = heapObject.instanceClass
+        if (instanceClass.name.matches(ANONYMOUS_CLASS_NAME_PATTERN_REGEX)) {
+          val parentClassRecord = instanceClass.superclass!!
+          if (parentClassRecord.name == "java.lang.Object") {
+            try {
+              // This is an anonymous class implementing an interface. The API does not give access
+              // to the interfaces implemented by the class. We check if it's in the class path and
+              // use that instead.
+              val actualClass = Class.forName(instanceClass.name)
+              val interfaces = actualClass.interfaces
+              reporter.addLabel(
+                  if (interfaces.isNotEmpty()) {
+                    val implementedInterface = interfaces[0]
+                    "Anonymous class implementing ${implementedInterface.name}"
+                  } else {
+                    "Anonymous subclass of java.lang.Object"
+                  }
+              )
+            } catch (ignored: ClassNotFoundException) {
+            }
+          } else {
+            // Makes it easier to figure out which anonymous class we're looking at.
+            reporter.addLabel("Anonymous subclass of ${parentClassRecord.name}")
+          }
+        }
+      }
+    }
+  },
+
+  THREAD {
+    override fun inspect(
+      reporter: ObjectReporter
+    ) {
+      reporter.whenInstanceOf(Thread::class) { instance ->
+        val threadName = instance[Thread::class, "name"]!!.value.readAsJavaString()
+        addLabel("Thread name: '$threadName'")
+      }
+    }
+  };
+
+  companion object {
+    private const val ANONYMOUS_CLASS_NAME_PATTERN = "^.+\\$\\d+$"
+    private val ANONYMOUS_CLASS_NAME_PATTERN_REGEX = ANONYMOUS_CLASS_NAME_PATTERN.toRegex()
+    /** @see ObjectInspectors */
+    val jdkDefaults: List<ObjectInspector>
+      get() {
+        return values().toList()
+      }
+  }
+}
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/ObjectReporter.kt b/shark/src/main/java/shark/ObjectReporter.kt
similarity index 67%
rename from leakcanary-analyzer/src/main/java/leakcanary/ObjectReporter.kt
rename to shark/src/main/java/shark/ObjectReporter.kt
index c98338ae..1a0e5a20 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/ObjectReporter.kt
+++ b/shark/src/main/java/shark/ObjectReporter.kt
@@ -1,13 +1,16 @@
-package leakcanary
+package shark
+
+import shark.HeapObject.HeapInstance
+import kotlin.reflect.KClass
 
 /**
- * Enables [ObjectInspector] implementations to provide insights on [objectRecord], which is
+ * Enables [ObjectInspector] implementations to provide insights on [heapObject], which is
  * an object (class, instance or array) found in the heap.
  *
  * A given [ObjectReporter] only maps to one object in the heap, but is shared to many
  * [ObjectInspector] implementations and accumulates insights.
  */
-class ObjectReporter internal constructor(val objectRecord: GraphObjectRecord) {
+class ObjectReporter internal constructor(val heapObject: HeapObject) {
 
   private val mutableLabels = mutableListOf<String>()
 
@@ -16,20 +19,20 @@ class ObjectReporter internal constructor(val objectRecord: GraphObjectRecord) {
   private val mutableNotLeakingStatuses = mutableListOf<LeakNodeStatusAndReason>()
 
   /**
-   * All labels added via [addLabel] for the [objectRecord] instance.
+   * All labels added via [addLabel] for the [heapObject] instance.
    */
   val labels: List<String>
     get() = mutableLabels
 
   /**
    * All leaking insights added via [reportLikelyLeaking], [reportLeaking] and [reportNotLeaking]
-   * for the [objectRecord] instance.
+   * for the [heapObject] instance.
    */
   val leakNodeStatuses: List<LeakNodeStatusAndReason>
     get() = mutableLeakingStatuses + mutableLikelyLeakingStatuses + mutableNotLeakingStatuses
 
   /**
-   * All leaking insights added via [reportLeaking] for the [objectRecord] instance.
+   * All leaking insights added via [reportLeaking] for the [heapObject] instance.
    */
   val leakingStatuses: List<LeakNodeStatusAndReason>
     get() = mutableLeakingStatuses
@@ -67,4 +70,28 @@ class ObjectReporter internal constructor(val objectRecord: GraphObjectRecord) {
     mutableNotLeakingStatuses += LeakNodeStatus.notLeaking(reason)
   }
 
+  /**
+   * Runs [block] if [ObjectReporter.heapObject] is an instance of [expectedClass].
+   */
+  fun whenInstanceOf(
+    expectedClass: KClass<out Any>,
+    block: ObjectReporter.(HeapInstance) -> Unit
+  ) {
+    whenInstanceOf(expectedClass.java.name, block)
+  }
+
+  /**
+   * Runs [block] if [ObjectReporter.heapObject] is an instance of [expectedClassName].
+   */
+  fun whenInstanceOf(
+    expectedClassName: String,
+    block: ObjectReporter.(HeapInstance) -> Unit
+  ) {
+    val heapObject = heapObject
+    if (heapObject is HeapInstance && heapObject instanceOf expectedClassName) {
+      block(heapObject)
+    }
+  }
+
+
 }
\ No newline at end of file
diff --git a/shark/src/main/java/shark/OnAnalysisProgressListener.kt b/shark/src/main/java/shark/OnAnalysisProgressListener.kt
new file mode 100644
index 00000000..93e76352
--- /dev/null
+++ b/shark/src/main/java/shark/OnAnalysisProgressListener.kt
@@ -0,0 +1,50 @@
+package shark
+
+/**
+ * Reports progress from the [HeapAnalyzer] as they occur, as [Step] values.
+ */
+interface OnAnalysisProgressListener {
+
+  // These steps are defined in the order in which they occur.
+  enum class Step {
+    PARSING_HEAP_DUMP,
+    FINDING_LEAKING_INSTANCES,
+    FINDING_PATHS_TO_LEAKING_INSTANCES,
+    FINDING_DOMINATORS,
+    COMPUTING_NATIVE_RETAINED_SIZE,
+    COMPUTING_RETAINED_SIZE,
+    BUILDING_LEAK_TRACES,
+  }
+
+  fun onAnalysisProgress(step: Step)
+
+  companion object {
+
+    /**
+     * A no-op [OnAnalysisProgressListener]
+     */
+    val NO_OP = object : OnAnalysisProgressListener {
+      override fun onAnalysisProgress(step: Step) {
+      }
+    }
+
+    /**
+     * Utility function to create a [OnAnalysisProgressListener] from the passed in [block] lambda
+     * instead of using the anonymous `object : OnAnalysisProgressListener` syntax.
+     *
+     * Usage:
+     *
+     * ```kotlin
+     * val listener = OnAnalysisProgressListener {
+     *
+     * }
+     * ```
+     */
+    inline operator fun invoke(crossinline block: (Step) -> Unit): OnAnalysisProgressListener =
+      object : OnAnalysisProgressListener {
+        override fun onAnalysisProgress(step: Step) {
+          block(step)
+        }
+      }
+  }
+}
\ No newline at end of file
diff --git a/shark/src/main/java/shark/ReferenceMatcher.kt b/shark/src/main/java/shark/ReferenceMatcher.kt
new file mode 100644
index 00000000..b758ae84
--- /dev/null
+++ b/shark/src/main/java/shark/ReferenceMatcher.kt
@@ -0,0 +1,39 @@
+package shark
+
+/**
+ * Used to pattern match known patterns of references in the heap, either to ignore them
+ * ([IgnoredReferenceMatcher]) or to mark them as library leaks ([LibraryLeakReferenceMatcher]).
+ */
+sealed class ReferenceMatcher {
+
+  /** The pattern that references will be matched against. */
+  abstract val pattern: ReferencePattern
+
+}
+
+/**
+ * [LibraryLeakReferenceMatcher] should be used to match references in library code that are
+ * known to create leaks and are beyond your control. The shortest path finder will only go
+ * through matching references after it has exhausted references that don't match, prioritizing
+ * finding an application leak over a known library leak. Library leaks will be reported as
+ * [LibraryLeak] instead of [ApplicationLeak].
+ */
+data class LibraryLeakReferenceMatcher(
+  override val pattern: ReferencePattern,
+  /**
+   * A description that conveys what we know about this library leak.
+   */
+  val description: String = "",
+  /**
+   * Whether the identified leak may exist in the provided [HeapGraph]. Defaults to true. If
+   * the heap dump comes from a VM that runs a different version of the library that doesn't
+   * have the leak, then this should return false.
+   */
+  val patternApplies: (HeapGraph) -> Boolean = { true }
+) : ReferenceMatcher()
+
+/**
+ * [IgnoredReferenceMatcher] should be used to match references that cannot ever create leaks. The
+ * shortest path finder will never go through matching references.
+ */
+class IgnoredReferenceMatcher(override val pattern: ReferencePattern) : ReferenceMatcher()
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/ReferencePattern.kt b/shark/src/main/java/shark/ReferencePattern.kt
similarity index 98%
rename from leakcanary-analyzer/src/main/java/leakcanary/ReferencePattern.kt
rename to shark/src/main/java/shark/ReferencePattern.kt
index f80a3c8d..9de31795 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/ReferencePattern.kt
+++ b/shark/src/main/java/shark/ReferencePattern.kt
@@ -1,4 +1,4 @@
-package leakcanary
+package shark
 
 import java.io.Serializable
 
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt b/shark/src/main/java/shark/internal/KeyedWeakReferenceMirror.kt
similarity index 80%
rename from leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
rename to shark/src/main/java/shark/internal/KeyedWeakReferenceMirror.kt
index 93b5bd20..8a3e3699 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/KeyedWeakReferenceMirror.kt
+++ b/shark/src/main/java/shark/internal/KeyedWeakReferenceMirror.kt
@@ -1,11 +1,11 @@
-package leakcanary.internal
+package shark.internal
 
-import leakcanary.GraphObjectRecord.GraphInstanceRecord
-import leakcanary.HeapValue
-import leakcanary.HeapValue.ObjectReference
+import shark.HeapObject.HeapInstance
+import shark.ValueHolder
+import shark.ValueHolder.ReferenceHolder
 
 internal class KeyedWeakReferenceMirror(
-  val referent: ObjectReference,
+  val referent: ReferenceHolder,
   val key: String,
     // The name field does not exist in pre 1.0 heap dumps.
   val name: String,
@@ -15,7 +15,7 @@ internal class KeyedWeakReferenceMirror(
   val retainedDurationMillis: Long?
 ) {
 
-  val hasReferent = referent.value != HeapValue.NULL_REFERENCE
+  val hasReferent = referent.value != ValueHolder.NULL_REFERENCE
 
   val isRetained = retainedDurationMillis == null || retainedDurationMillis != -1L
 
@@ -24,12 +24,12 @@ internal class KeyedWeakReferenceMirror(
     private const val UNKNOWN_LEGACY = "Unknown (legacy)"
 
     fun fromInstance(
-      weakRef: GraphInstanceRecord,
+      weakRef: HeapInstance,
       // Null for pre 2.0 alpha 3 heap dumps
       heapDumpUptimeMillis: Long?
     ): KeyedWeakReferenceMirror {
 
-      val keyWeakRefClassName = weakRef.className
+      val keyWeakRefClassName = weakRef.instanceClassName
       val watchDurationMillis = if (heapDumpUptimeMillis != null)
         heapDumpUptimeMillis - weakRef[keyWeakRefClassName, "watchUptimeMillis"]!!.value.asLong!!
       else null
@@ -45,7 +45,7 @@ internal class KeyedWeakReferenceMirror(
       return KeyedWeakReferenceMirror(
           watchDurationMillis = watchDurationMillis,
           retainedDurationMillis = retainedDurationMillis,
-          referent = weakRef["java.lang.ref.Reference", "referent"]!!.value.actual as ObjectReference,
+          referent = weakRef["java.lang.ref.Reference", "referent"]!!.value.holder as ReferenceHolder,
           key = keyString,
           name = name
       )
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt b/shark/src/main/java/shark/internal/LeakTraceRenderer.kt
similarity index 81%
rename from leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt
rename to shark/src/main/java/shark/internal/LeakTraceRenderer.kt
index b961d12c..915ef2ad 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/LeakTraceRenderer.kt
+++ b/shark/src/main/java/shark/internal/LeakTraceRenderer.kt
@@ -1,14 +1,14 @@
-package leakcanary.internal
+package shark.internal
 
-import leakcanary.LeakNodeStatus.LEAKING
-import leakcanary.LeakNodeStatus.NOT_LEAKING
-import leakcanary.LeakNodeStatus.UNKNOWN
-import leakcanary.LeakNodeStatusAndReason
-import leakcanary.LeakTrace
-import leakcanary.LeakTraceElement
-import leakcanary.LeakTraceElement.Holder.ARRAY
-import leakcanary.LeakTraceElement.Holder.THREAD
-import leakcanary.LeakTraceElement.Type.STATIC_FIELD
+import shark.LeakNodeStatus.LEAKING
+import shark.LeakNodeStatus.NOT_LEAKING
+import shark.LeakNodeStatus.UNKNOWN
+import shark.LeakNodeStatusAndReason
+import shark.LeakTrace
+import shark.LeakTraceElement
+import shark.LeakTraceElement.Holder.ARRAY
+import shark.LeakTraceElement.Holder.THREAD
+import shark.LeakTraceElement.Type.STATIC_FIELD
 import java.util.Locale
 
 internal fun LeakTrace.renderToString(): String {
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/ReferencePathNode.kt b/shark/src/main/java/shark/internal/ReferencePathNode.kt
similarity index 84%
rename from leakcanary-analyzer/src/main/java/leakcanary/internal/ReferencePathNode.kt
rename to shark/src/main/java/shark/internal/ReferencePathNode.kt
index 22a229c3..8505aef5 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/ReferencePathNode.kt
+++ b/shark/src/main/java/shark/internal/ReferencePathNode.kt
@@ -1,8 +1,8 @@
-package leakcanary.internal
+package shark.internal
 
-import leakcanary.GcRoot
-import leakcanary.LeakReference
-import leakcanary.ReferenceMatcher.LibraryLeakReferenceMatcher
+import shark.GcRoot
+import shark.LeakReference
+import shark.LibraryLeakReferenceMatcher
 
 internal sealed class ReferencePathNode {
   abstract val instance: Long
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt b/shark/src/main/java/shark/internal/ShortestPathFinder.kt
similarity index 79%
rename from leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
rename to shark/src/main/java/shark/internal/ShortestPathFinder.kt
index 8b1f4c5d..c02fd848 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/ShortestPathFinder.kt
+++ b/shark/src/main/java/shark/internal/ShortestPathFinder.kt
@@ -13,40 +13,39 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package leakcanary.internal
-
-import leakcanary.AnalyzerProgressListener
-import leakcanary.AnalyzerProgressListener.Step.FINDING_DOMINATORS
-import leakcanary.AnalyzerProgressListener.Step.FINDING_PATHS_TO_LEAKING_INSTANCES
-import leakcanary.CanaryLog
-import leakcanary.GcRoot
-import leakcanary.GcRoot.JavaFrame
-import leakcanary.GcRoot.ThreadObject
-import leakcanary.GraphObjectRecord
-import leakcanary.GraphObjectRecord.GraphClassRecord
-import leakcanary.GraphObjectRecord.GraphInstanceRecord
-import leakcanary.GraphObjectRecord.GraphObjectArrayRecord
-import leakcanary.GraphObjectRecord.GraphPrimitiveArrayRecord
-import leakcanary.HeapValue
-import leakcanary.HprofGraph
-import leakcanary.HprofReader
-import leakcanary.LeakReference
-import leakcanary.LeakTraceElement.Type.ARRAY_ENTRY
-import leakcanary.LeakTraceElement.Type.INSTANCE_FIELD
-import leakcanary.LeakTraceElement.Type.LOCAL
-import leakcanary.LeakTraceElement.Type.STATIC_FIELD
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
-import leakcanary.ReferenceMatcher
-import leakcanary.ReferenceMatcher.IgnoredReferenceMatcher
-import leakcanary.ReferenceMatcher.LibraryLeakReferenceMatcher
-import leakcanary.internal.ReferencePathNode.ChildNode.LibraryLeakNode
-import leakcanary.internal.ReferencePathNode.ChildNode.NormalNode
-import leakcanary.internal.ReferencePathNode.RootNode
-import leakcanary.ReferencePattern
-import leakcanary.ReferencePattern.InstanceFieldPattern
-import leakcanary.ReferencePattern.StaticFieldPattern
-import leakcanary.internal.hppc.LongLongScatterMap
-import leakcanary.internal.hppc.LongScatterSet
+package shark.internal
+
+import shark.OnAnalysisProgressListener.Step.FINDING_DOMINATORS
+import shark.OnAnalysisProgressListener.Step.FINDING_PATHS_TO_LEAKING_INSTANCES
+import shark.GcRoot
+import shark.GcRoot.JavaFrame
+import shark.GcRoot.ThreadObject
+import shark.HeapGraph
+import shark.HeapObject
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.HeapObject.HeapObjectArray
+import shark.HeapObject.HeapPrimitiveArray
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import shark.LeakReference
+import shark.LeakTraceElement.Type.ARRAY_ENTRY
+import shark.LeakTraceElement.Type.INSTANCE_FIELD
+import shark.LeakTraceElement.Type.LOCAL
+import shark.LeakTraceElement.Type.STATIC_FIELD
+import shark.PrimitiveType
+import shark.ReferenceMatcher
+import shark.IgnoredReferenceMatcher
+import shark.LibraryLeakReferenceMatcher
+import shark.ReferencePattern
+import shark.ReferencePattern.InstanceFieldPattern
+import shark.ReferencePattern.StaticFieldPattern
+import shark.SharkLog
+import shark.ValueHolder
+import shark.internal.ReferencePathNode.ChildNode.LibraryLeakNode
+import shark.internal.ReferencePathNode.ChildNode.NormalNode
+import shark.internal.ReferencePathNode.RootNode
+import shark.internal.hppc.LongLongScatterMap
+import shark.internal.hppc.LongScatterSet
 import java.util.ArrayDeque
 import java.util.Deque
 import java.util.LinkedHashMap
@@ -90,30 +89,26 @@ internal class ShortestPathFinder {
   )
 
   fun findPaths(
-    graph: HprofGraph,
+    graph: HeapGraph,
     referenceMatchers: List<ReferenceMatcher>,
     leakingInstanceObjectIds: Set<Long>,
     computeDominators: Boolean,
-    listener: AnalyzerProgressListener
+    listener: shark.OnAnalysisProgressListener
   ): Results {
 
-    listener.onProgressUpdate(FINDING_PATHS_TO_LEAKING_INSTANCES)
+    listener.onAnalysisProgress(FINDING_PATHS_TO_LEAKING_INSTANCES)
     clearState()
     this.leakingInstanceObjectIds = leakingInstanceObjectIds
 
-    val objectClass = graph.findClassByClassName("java.lang.Object")
+    val objectClass = graph.findClassByName("java.lang.Object")
     sizeOfObjectInstances = if (objectClass != null) {
-      // In Android 16 ClassDumpRecord.instanceSize can be 8 yet there are 0 fields.
-      // Better rely on our own computation of instance size.
-      // See #1374
-      val objectClassFieldSize = objectClass.readRecord()
-          .fields.sumBy {
-        graph.sizeOfFieldType(it.type)
-      }
+      // In Android 16 ClassDumpRecord.instanceSize for java.lang.Object can be 8 yet there are 0
+      // fields. This is likely because there is extra per instance data that isn't coming from
+      // fields in the Object class. See #1374
+      val objectClassFieldSize = objectClass.readFieldsByteSize()
 
       // shadow$_klass_ (object id) + shadow$_monitor_ (Int)
-      val sizeOfObjectOnArt =
-        graph.sizeOfFieldType(HprofReader.OBJECT_TYPE) + graph.sizeOfFieldType(HprofReader.INT_TYPE)
+      val sizeOfObjectOnArt = graph.identifierByteSize + PrimitiveType.INT.byteSize
       if (objectClassFieldSize == sizeOfObjectOnArt) {
         sizeOfObjectOnArt
       } else {
@@ -183,21 +178,21 @@ internal class ShortestPathFinder {
         // Found all refs, stop searching (unless computing retained size which stops on weak reachables)
         if (shortestPathsToLeakingInstances.size == leakingInstanceObjectIds.size) {
           if (computeDominators) {
-            listener.onProgressUpdate(FINDING_DOMINATORS)
+            listener.onAnalysisProgress(FINDING_DOMINATORS)
           } else {
             break@visitingQueue
           }
         }
       }
 
-      when (val graphRecord = graph.findObjectByObjectId(node.instance)) {
-        is GraphClassRecord -> visitClassRecord(
+      when (val graphRecord = graph.findObjectById(node.instance)) {
+        is HeapClass -> visitClassRecord(
             graph, graphRecord, node, staticFieldNameByClassName, computeDominators
         )
-        is GraphInstanceRecord -> visitInstanceRecord(
+        is HeapInstance -> visitInstanceRecord(
             graph, graphRecord, node, fieldNameByClassName, computeDominators
         )
-        is GraphObjectArrayRecord -> visitObjectArrayRecord(
+        is HeapObjectArray -> visitObjectArrayRecord(
             graph, graphRecord.readRecord(), node, computeDominators
         )
       }
@@ -227,13 +222,13 @@ internal class ShortestPathFinder {
   }
 
   private fun enqueueGcRoots(
-    graph: HprofGraph,
+    graph: HeapGraph,
     threadNameReferenceMatchers: Map<String, ReferenceMatcher>,
     computeDominators: Boolean
   ) {
     val gcRoots = sortedGcRoots(graph)
 
-    val threadsBySerialNumber = mutableMapOf<Int, Pair<GraphInstanceRecord, ThreadObject>>()
+    val threadsBySerialNumber = mutableMapOf<Int, Pair<HeapInstance, ThreadObject>>()
     gcRoots.forEach { (objectRecord, gcRoot) ->
       if (computeDominators) {
         undominateWithSkips(graph, gcRoot.id)
@@ -277,27 +272,27 @@ internal class ShortestPathFinder {
    * built before JavaFrames.
    */
   private fun sortedGcRoots(
-    graph: HprofGraph
-  ): List<Pair<GraphObjectRecord, GcRoot>> {
-    val rootClassName: (GraphObjectRecord) -> String = { graphObject ->
+    graph: HeapGraph
+  ): List<Pair<HeapObject, GcRoot>> {
+    val rootClassName: (HeapObject) -> String = { graphObject ->
       when (graphObject) {
-        is GraphClassRecord -> {
+        is HeapClass -> {
           graphObject.name
         }
-        is GraphInstanceRecord -> {
-          graphObject.className
+        is HeapInstance -> {
+          graphObject.instanceClassName
         }
-        is GraphObjectArrayRecord -> {
+        is HeapObjectArray -> {
           graphObject.arrayClassName
         }
-        is GraphPrimitiveArrayRecord -> {
+        is HeapPrimitiveArray -> {
           graphObject.arrayClassName
         }
       }
     }
 
     return graph.gcRoots
-        .map { graph.findObjectByObjectId(it.id) to it }
+        .map { graph.findObjectById(it.id) to it }
         .sortedWith(Comparator { (graphObject1, root1), (graphObject2, root2) ->
           // Sorting based on pattern name first. In reverse order so that ThreadObject is before JavaLocalPattern
           val gcRootTypeComparison = root2::class.java.name.compareTo(root1::class.java.name)
@@ -310,15 +305,15 @@ internal class ShortestPathFinder {
   }
 
   private fun visitClassRecord(
-    graph: HprofGraph,
-    classRecord: GraphClassRecord,
+    graph: HeapGraph,
+    heapClass: HeapClass,
     parent: ReferencePathNode,
     staticFieldNameByClassName: Map<String, Map<String, ReferenceMatcher>>,
     computeRetainedHeapSize: Boolean
   ) {
-    val ignoredStaticFields = staticFieldNameByClassName[classRecord.name] ?: emptyMap()
+    val ignoredStaticFields = staticFieldNameByClassName[heapClass.name] ?: emptyMap()
 
-    for (staticField in classRecord.readStaticFields()) {
+    for (staticField in heapClass.readStaticFields()) {
       if (!staticField.value.isNonNullReference) {
         continue
       }
@@ -354,15 +349,15 @@ internal class ShortestPathFinder {
   }
 
   private fun visitInstanceRecord(
-    graph: HprofGraph,
-    instanceRecord: GraphInstanceRecord,
+    graph: HeapGraph,
+    instance: HeapInstance,
     parent: ReferencePathNode,
     fieldNameByClassName: Map<String, Map<String, ReferenceMatcher>>,
     computeRetainedHeapSize: Boolean
   ) {
     val fieldReferenceMatchers = LinkedHashMap<String, ReferenceMatcher>()
 
-    instanceRecord.instanceClass.classHierarchy.forEach {
+    instance.instanceClass.classHierarchy.forEach {
       val referenceMatcherByField = fieldNameByClassName[it.name]
       if (referenceMatcherByField != null) {
         for ((fieldName, referenceMatcher) in referenceMatcherByField) {
@@ -373,7 +368,7 @@ internal class ShortestPathFinder {
       }
     }
 
-    val fieldNamesAndValues = instanceRecord.readFields()
+    val fieldNamesAndValues = instance.readFields()
         .toMutableList()
 
     fieldNamesAndValues.sortBy { it.name }
@@ -404,17 +399,17 @@ internal class ShortestPathFinder {
   }
 
   private fun visitObjectArrayRecord(
-    graph: HprofGraph,
+    graph: HeapGraph,
     record: ObjectArrayDumpRecord,
     parentNode: ReferencePathNode,
     computeRetainedHeapSize: Boolean
   ) {
     record.elementIds.filter { objectId ->
-      objectId != HeapValue.NULL_REFERENCE && graph.objectExists(objectId).apply {
+      objectId != ValueHolder.NULL_REFERENCE && graph.objectExists(objectId).apply {
         if (!this) {
           // dalvik.system.PathClassLoader.runtimeInternalObjects references objects which don't
           // otherwise exist in the heap dump.
-          CanaryLog.d("Invalid Hprof? Found unknown object id $objectId")
+          SharkLog.d("Invalid Hprof? Found unknown object id $objectId")
         }
       }
     }
@@ -431,10 +426,10 @@ internal class ShortestPathFinder {
   }
 
   private fun enqueue(
-    graph: HprofGraph,
+    graph: HeapGraph,
     node: ReferencePathNode
   ) {
-    if (node.instance == HeapValue.NULL_REFERENCE) {
+    if (node.instance == ValueHolder.NULL_REFERENCE) {
       return
     }
     if (visitedSet.contains(node.instance)) {
@@ -462,20 +457,20 @@ internal class ShortestPathFinder {
     val isLeakingInstance = node.instance in leakingInstanceObjectIds
 
     if (!isLeakingInstance) {
-      val skip = when (val graphObject = graph.findObjectByObjectId(node.instance)) {
-        is GraphClassRecord -> false
-        is GraphInstanceRecord ->
+      val skip = when (val graphObject = graph.findObjectById(node.instance)) {
+        is HeapClass -> false
+        is HeapInstance ->
           when {
             graphObject.isPrimitiveWrapper -> true
-            graphObject.className == "java.lang.String" -> true
-            graphObject.instanceClass.instanceSize <= sizeOfObjectInstances -> true
+            graphObject.instanceClassName == "java.lang.String" -> true
+            graphObject.instanceClass.instanceByteSize <= sizeOfObjectInstances -> true
             else -> false
           }
-        is GraphObjectArrayRecord -> when {
+        is HeapObjectArray -> when {
           graphObject.isPrimitiveWrapperArray -> true
           else -> false
         }
-        is GraphPrimitiveArrayRecord -> true
+        is HeapPrimitiveArray -> true
       }
       if (skip) {
         return
@@ -491,18 +486,18 @@ internal class ShortestPathFinder {
   }
 
   private fun updateDominatorWithSkips(
-    graph: HprofGraph,
+    graph: HeapGraph,
     parentObjectId: Long,
     objectId: Long
   ) {
 
-    when (val graphObject = graph.findObjectByObjectId(objectId)) {
-      is GraphClassRecord -> {
+    when (val graphObject = graph.findObjectById(objectId)) {
+      is HeapClass -> {
         undominate(objectId, false)
       }
-      is GraphInstanceRecord -> {
+      is HeapInstance -> {
         // String internal array is never enqueued
-        if (graphObject.className == "java.lang.String") {
+        if (graphObject.instanceClassName == "java.lang.String") {
           updateDominator(parentObjectId, objectId, true)
           val valueId = graphObject["java.lang.String", "value"]?.value?.asObjectId
           if (valueId != null) {
@@ -512,7 +507,7 @@ internal class ShortestPathFinder {
           updateDominator(parentObjectId, objectId, false)
         }
       }
-      is GraphObjectArrayRecord -> {
+      is HeapObjectArray -> {
         // Primitive wrapper array elements are never enqueued
         if (graphObject.isPrimitiveWrapperArray) {
           updateDominator(parentObjectId, objectId, true)
@@ -593,16 +588,16 @@ internal class ShortestPathFinder {
   }
 
   private fun undominateWithSkips(
-    graph: HprofGraph,
+    graph: HeapGraph,
     objectId: Long
   ) {
-    when (val graphObject = graph.findObjectByObjectId(objectId)) {
-      is GraphClassRecord -> {
+    when (val graphObject = graph.findObjectById(objectId)) {
+      is HeapClass -> {
         undominate(objectId, false)
       }
-      is GraphInstanceRecord -> {
+      is HeapInstance -> {
         // String internal array is never enqueued
-        if (graphObject.className == "java.lang.String") {
+        if (graphObject.instanceClassName == "java.lang.String") {
           undominate(objectId, true)
           val valueId = graphObject["java.lang.String", "value"]?.value?.asObjectId
           if (valueId != null) {
@@ -612,7 +607,7 @@ internal class ShortestPathFinder {
           undominate(objectId, false)
         }
       }
-      is GraphObjectArrayRecord -> {
+      is HeapObjectArray -> {
         // Primitive wrapper array elements are never enqueued
         if (graphObject.isPrimitiveWrapperArray) {
           undominate(objectId, true)
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/Strings.kt b/shark/src/main/java/shark/internal/Strings.kt
similarity index 97%
rename from leakcanary-analyzer/src/main/java/leakcanary/internal/Strings.kt
rename to shark/src/main/java/shark/internal/Strings.kt
index 366f852f..d562cb08 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/Strings.kt
+++ b/shark/src/main/java/shark/internal/Strings.kt
@@ -1,4 +1,4 @@
-package leakcanary.internal
+package shark.internal
 
 import java.nio.charset.Charset
 import java.security.MessageDigest
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/HHPC.kt b/shark/src/main/java/shark/internal/hppc/HHPC.kt
similarity index 73%
rename from leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/HHPC.kt
rename to shark/src/main/java/shark/internal/hppc/HHPC.kt
index 08357b54..01cebe29 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/HHPC.kt
+++ b/shark/src/main/java/shark/internal/hppc/HHPC.kt
@@ -1,4 +1,20 @@
-package leakcanary.internal.hppc
+/*
+ *  Copyright 2010-2013, Carrot Search s.c., Boznicza 11/56, Poznan, Poland
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package shark.internal.hppc
 
 import java.util.Locale
 
@@ -17,7 +33,6 @@ internal object HHPC {
   private const val MIN_HASH_ARRAY_LENGTH = 4
   private const val MAX_HASH_ARRAY_LENGTH = (-0x80000000).ushr(1)
 
-
   fun minBufferSize(
     elements: Int,
     loadFactor: Double
@@ -43,7 +58,6 @@ internal object HHPC {
     return length.toInt()
   }
 
-
   fun nextHighestPowerOfTwo(input: Long): Long {
     var v = input
     v--
@@ -57,7 +71,6 @@ internal object HHPC {
     return v
   }
 
-
   fun expandAtCount(
     arraySize: Int,
     loadFactor: Double
@@ -65,7 +78,6 @@ internal object HHPC {
     return Math.min(arraySize - 1, Math.ceil(arraySize * loadFactor).toInt())
   }
 
-
   fun nextBufferSize(
     arraySize: Int,
     elements: Int,
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/LongLongScatterMap.kt b/shark/src/main/java/shark/internal/hppc/LongLongScatterMap.kt
similarity index 91%
rename from leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/LongLongScatterMap.kt
rename to shark/src/main/java/shark/internal/hppc/LongLongScatterMap.kt
index 90e13d31..4d87fd83 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/LongLongScatterMap.kt
+++ b/shark/src/main/java/shark/internal/hppc/LongLongScatterMap.kt
@@ -1,4 +1,20 @@
-package leakcanary.internal.hppc
+/*
+ *  Copyright 2010-2013, Carrot Search s.c., Boznicza 11/56, Poznan, Poland
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package shark.internal.hppc
 
 import java.util.Locale
 
@@ -305,8 +321,8 @@ internal class LongLongScatterMap {
    * Shift all the slot-conflicting keys and values allocated to
    * (and including) `slot`.
    */
-  private fun shiftConflictingKeys(gapSlot: Int) {
-    var gapSlot = gapSlot
+  private fun shiftConflictingKeys(gapSlotArg: Int) {
+    var gapSlot = gapSlotArg
     val keys = this.keys
     val values = this.values
     val mask = this.mask
diff --git a/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/LongScatterSet.kt b/shark/src/main/java/shark/internal/hppc/LongScatterSet.kt
similarity index 86%
rename from leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/LongScatterSet.kt
rename to shark/src/main/java/shark/internal/hppc/LongScatterSet.kt
index 7a4034f2..a061da1e 100644
--- a/leakcanary-analyzer/src/main/java/leakcanary/internal/hppc/LongScatterSet.kt
+++ b/shark/src/main/java/shark/internal/hppc/LongScatterSet.kt
@@ -1,4 +1,20 @@
-package leakcanary.internal.hppc
+/*
+ *  Copyright 2010-2013, Carrot Search s.c., Boznicza 11/56, Poznan, Poland
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+package shark.internal.hppc
 
 import java.util.Locale
 
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt b/shark/src/test/java/shark/HeapAnalyzerTest.kt
similarity index 90%
rename from leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt
rename to shark/src/test/java/shark/HeapAnalyzerTest.kt
index e67c39f9..53bd1f5a 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapAnalyzerTest.kt
+++ b/shark/src/test/java/shark/HeapAnalyzerTest.kt
@@ -1,16 +1,13 @@
-package leakcanary.internal
-
-import leakcanary.GcRoot.ThreadObject
-import leakcanary.HeapAnalysis
-import leakcanary.HeapAnalysisSuccess
-import leakcanary.HeapValue.ObjectReference
-import leakcanary.LeakTraceElement.Type.LOCAL
-import leakcanary.Leak
+package shark
+
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TemporaryFolder
+import shark.GcRoot.ThreadObject
+import shark.LeakTraceElement.Type.LOCAL
+import shark.ValueHolder.ReferenceHolder
 import java.io.File
 
 class HeapAnalyzerTest {
@@ -113,10 +110,10 @@ class HeapAnalyzerTest {
   @Test fun threadFieldLeak() {
     hprofFile.dump {
       val threadClassId =
-        clazz(className = "java.lang.Thread", fields = listOf("name" to ObjectReference::class))
+        clazz(className = "java.lang.Thread", fields = listOf("name" to ReferenceHolder::class))
       val myThreadClassId = clazz(
-          className = "MyThread", superClassId = threadClassId,
-          fields = listOf("leaking" to ObjectReference::class)
+          className = "MyThread", superclassId = threadClassId,
+          fields = listOf("leaking" to ReferenceHolder::class)
       )
       val threadInstance =
         instance(myThreadClassId, listOf("Leaking" watchedInstance {}, string("Thread Name")))
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapDumps.kt b/shark/src/test/java/shark/HeapDumps.kt
similarity index 82%
rename from leakcanary-analyzer/src/test/java/leakcanary/internal/HeapDumps.kt
rename to shark/src/test/java/shark/HeapDumps.kt
index 7f6fac38..8c8988da 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/HeapDumps.kt
+++ b/shark/src/test/java/shark/HeapDumps.kt
@@ -1,16 +1,15 @@
-package leakcanary.internal
+package shark
 
-import leakcanary.GcRoot.JavaFrame
-import leakcanary.GcRoot.ThreadObject
-import leakcanary.HeapValue.BooleanValue
-import leakcanary.HeapValue.ObjectReference
-import leakcanary.HprofWriter
+import shark.GcRoot.JavaFrame
+import shark.GcRoot.ThreadObject
+import shark.ValueHolder.BooleanHolder
+import shark.ValueHolder.ReferenceHolder
 import java.io.File
 
 fun File.writeWeakReferenceCleared() {
   HprofWriter.open(this)
       .helper {
-        keyedWeakReference(ObjectReference(0))
+        keyedWeakReference(ReferenceHolder(0))
       }
 }
 
@@ -59,7 +58,7 @@ fun File.writeSinglePathsToCharArrays(values: List<String>) {
         clazz(
             className = "GcRoot",
             staticFields = listOf(
-                "arrays" to ObjectReference(
+                "arrays" to ReferenceHolder(
                     objectArray(clazz("char[][]"), arrays.toLongArray())
                 )
             )
@@ -74,7 +73,7 @@ fun File.writeTwoPathsToInstance() {
         val leaking = instance(clazz("Leaking"))
         keyedWeakReference(leaking)
         val hasLeaking = instance(
-            clazz("HasLeaking", fields = listOf("leaking" to ObjectReference::class)),
+            clazz("HasLeaking", fields = listOf("leaking" to ReferenceHolder::class)),
             fields = listOf(leaking)
         )
         clazz(
@@ -91,17 +90,17 @@ fun File.writeMultipleActivityLeaks(leakCount: Int) {
       .helper {
         val activityClassId = clazz(
             className = "android.app.Activity",
-            fields = listOf("mDestroyed" to BooleanValue::class)
+            fields = listOf("mDestroyed" to BooleanHolder::class)
         )
         val exampleActivityClassId = clazz(
-            superClassId = activityClassId,
+            superclassId = activityClassId,
             className = "com.example.ExampleActivity"
         )
         val activityArrayClassId = arrayClass("com.example.ExampleActivity")
 
-        val destroyedActivities = mutableListOf<ObjectReference>()
+        val destroyedActivities = mutableListOf<ReferenceHolder>()
         for (i in 1..leakCount) {
-          destroyedActivities.add(instance(exampleActivityClassId, listOf(BooleanValue(true))))
+          destroyedActivities.add(instance(exampleActivityClassId, listOf(BooleanHolder(true))))
         }
 
         clazz(
@@ -125,8 +124,8 @@ fun File.writeJavaLocalLeak(
 ) {
   dump {
     val threadClassId =
-      clazz(className = "java.lang.Thread", fields = listOf("name" to ObjectReference::class))
-    val myThreadClassId = clazz(className = threadClass, superClassId = threadClassId)
+      clazz(className = "java.lang.Thread", fields = listOf("name" to ReferenceHolder::class))
+    val myThreadClassId = clazz(className = threadClass, superclassId = threadClassId)
     val threadInstance = instance(myThreadClassId, listOf(string(threadName)))
     gcRoot(
         ThreadObject(
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt b/shark/src/test/java/shark/HprofWriterHelper.kt
similarity index 51%
rename from leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
rename to shark/src/test/java/shark/HprofWriterHelper.kt
index 90f77c3b..8f93245d 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/HprofWriterHelper.kt
+++ b/shark/src/test/java/shark/HprofWriterHelper.kt
@@ -1,29 +1,32 @@
-package leakcanary.internal
-
-import leakcanary.GcRoot
-import leakcanary.GcRoot.StickyClass
-import leakcanary.HeapValue
-import leakcanary.HeapValue.BooleanValue
-import leakcanary.HeapValue.ByteValue
-import leakcanary.HeapValue.CharValue
-import leakcanary.HeapValue.DoubleValue
-import leakcanary.HeapValue.FloatValue
-import leakcanary.HeapValue.IntValue
-import leakcanary.HeapValue.LongValue
-import leakcanary.HeapValue.ObjectReference
-import leakcanary.HeapValue.ShortValue
-import leakcanary.HprofReader
-import leakcanary.HprofWriter
-import leakcanary.Record.HeapDumpRecord.GcRootRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
-import leakcanary.Record.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
-import leakcanary.Record.LoadClassRecord
-import leakcanary.Record.StringRecord
-import okio.Buffer
+package shark
+
+import shark.GcRoot.StickyClass
+import shark.HprofRecord.HeapDumpRecord.GcRootRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.FieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ClassDumpRecord.StaticFieldRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.InstanceDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.ObjectArrayDumpRecord
+import shark.HprofRecord.HeapDumpRecord.ObjectRecord.PrimitiveArrayDumpRecord.CharArrayDump
+import shark.HprofRecord.LoadClassRecord
+import shark.HprofRecord.StringRecord
+import shark.PrimitiveType.BOOLEAN
+import shark.PrimitiveType.BYTE
+import shark.PrimitiveType.CHAR
+import shark.PrimitiveType.DOUBLE
+import shark.PrimitiveType.FLOAT
+import shark.PrimitiveType.INT
+import shark.PrimitiveType.LONG
+import shark.PrimitiveType.SHORT
+import shark.ValueHolder.BooleanHolder
+import shark.ValueHolder.ByteHolder
+import shark.ValueHolder.CharHolder
+import shark.ValueHolder.DoubleHolder
+import shark.ValueHolder.FloatHolder
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.ValueHolder.ReferenceHolder
+import shark.ValueHolder.ShortHolder
 import java.io.Closeable
 import java.io.File
 import java.util.UUID
@@ -45,58 +48,48 @@ class HprofWriterHelper constructor(
     get() =
       UUID(weakRefKeyRandom.nextLong(), weakRefKeyRandom.nextLong()).toString()
 
-  private val typeSizes = mapOf(
-      // object
-      HprofReader.OBJECT_TYPE to writer.idSize,
-      HprofReader.BOOLEAN_TYPE to HprofReader.BOOLEAN_SIZE,
-      HprofReader.CHAR_TYPE to HprofReader.CHAR_SIZE,
-      HprofReader.FLOAT_TYPE to HprofReader.FLOAT_SIZE,
-      HprofReader.DOUBLE_TYPE to HprofReader.DOUBLE_SIZE,
-      HprofReader.BYTE_TYPE to HprofReader.BYTE_SIZE,
-      HprofReader.SHORT_TYPE to HprofReader.SHORT_SIZE,
-      HprofReader.INT_TYPE to HprofReader.INT_SIZE,
-      HprofReader.LONG_TYPE to HprofReader.LONG_SIZE
-  )
+  private val typeSizes =
+    PrimitiveType.byteSizeByHprofType + (PrimitiveType.REFERENCE_HPROF_TYPE to writer.identifierByteSize)
 
   private val classDumps = mutableMapOf<Long, ClassDumpRecord>()
 
-  private val objectClassId = clazz(superClassId = 0, className = "java.lang.Object")
+  private val objectClassId = clazz(superclassId = 0, className = "java.lang.Object")
   private val objectArrayClassId = arrayClass("java.lang.Object")
   private val stringClassId = clazz(
       className = "java.lang.String", fields = listOf(
-      "value" to ObjectReference::class,
-      "count" to IntValue::class
+      "value" to ReferenceHolder::class,
+      "count" to IntHolder::class
   )
   )
 
   private val referenceClassId = clazz(
       className = "java.lang.ref.Reference",
       fields = listOf(
-          "referent" to ObjectReference::class
+          "referent" to ReferenceHolder::class
       )
   )
 
   private val weakReferenceClassId = clazz(
       className = "java.lang.ref.WeakReference",
-      superClassId = referenceClassId
+      superclassId = referenceClassId
   )
   private val keyedWeakReferenceClassId = clazz(
-      superClassId = weakReferenceClassId,
+      superclassId = weakReferenceClassId,
       className = "leakcanary.KeyedWeakReference",
-      staticFields = listOf("heapDumpUptimeMillis" to LongValue(30000)),
+      staticFields = listOf("heapDumpUptimeMillis" to LongHolder(30000)),
       fields = listOf(
-          "key" to ObjectReference::class,
-          "name" to ObjectReference::class,
-          "watchUptimeMillis" to LongValue::class,
-          "retainedUptimeMillis" to LongValue::class
+          "key" to ReferenceHolder::class,
+          "name" to ReferenceHolder::class,
+          "watchUptimeMillis" to LongHolder::class,
+          "retainedUptimeMillis" to LongHolder::class
       )
   )
 
   fun clazz(
     className: String,
-    superClassId: Long = -1L, // -1 defaults to java.lang.Object
-    staticFields: List<Pair<String, HeapValue>> = emptyList(),
-    fields: List<Pair<String, KClass<out HeapValue>>> = emptyList()
+    superclassId: Long = -1L, // -1 defaults to java.lang.Object
+    staticFields: List<Pair<String, ValueHolder>> = emptyList(),
+    fields: List<Pair<String, KClass<out ValueHolder>>> = emptyList()
   ): Long {
     val classNameRecord = StringRecord(id, className)
     writer.write(classNameRecord)
@@ -119,18 +112,18 @@ class HprofWriterHelper constructor(
       typeSizes.getValue(it.type)
     }
 
-    var nextUpId = if (superClassId == -1L) objectClassId else superClassId
+    var nextUpId = if (superclassId == -1L) objectClassId else superclassId
     while (nextUpId != 0L) {
       val nextUp = classDumps[nextUpId]!!
       instanceSize += nextUp.fields.sumBy {
         typeSizes.getValue(it.type)
       }
-      nextUpId = nextUp.superClassId
+      nextUpId = nextUp.superclassId
     }
     val classDump = ClassDumpRecord(
         id = loadClass.id,
         stackTraceSerialNumber = 1,
-        superClassId = if (superClassId == -1L) objectClassId else superClassId,
+        superclassId = if (superclassId == -1L) objectClassId else superclassId,
         classLoaderId = 0,
         signersId = 0,
         protectionDomainId = 0,
@@ -156,65 +149,59 @@ class HprofWriterHelper constructor(
 
   fun string(
     string: String
-  ): ObjectReference {
+  ): ReferenceHolder {
     return instance(
         stringClassId,
-        fields = listOf(string.charArrayDump, IntValue(string.length))
+        fields = listOf(string.charArrayDump, IntHolder(string.length))
     )
   }
 
   fun keyedWeakReference(
-    referentInstanceId: ObjectReference
-  ): ObjectReference {
+    referentInstanceId: ReferenceHolder
+  ): ReferenceHolder {
     val referenceKey = string(weakRefKey)
     return instance(
         classId = keyedWeakReferenceClassId,
         fields = listOf(
             referenceKey,
             string(""),
-            LongValue(5000),
-            LongValue(20000),
-            ObjectReference(referentInstanceId.value)
+            LongHolder(5000),
+            LongHolder(20000),
+            ReferenceHolder(referentInstanceId.value)
         )
     )
   }
 
   fun instance(
     classId: Long,
-    fields: List<HeapValue> = emptyList()
-  ): ObjectReference {
-    val fieldsBuffer = Buffer()
-    fields.forEach { value ->
-      with(writer) {
-        fieldsBuffer.writeValue(value)
-      }
-    }
+    fields: List<ValueHolder> = emptyList()
+  ): ReferenceHolder {
     val instanceDump = InstanceDumpRecord(
         id = id,
         stackTraceSerialNumber = 1,
         classId = classId,
-        fieldValues = fieldsBuffer.readByteArray()
+        fieldValues = writer.valuesToBytes(fields)
     )
     writer.write(instanceDump)
-    return ObjectReference(instanceDump.id)
+    return ReferenceHolder(instanceDump.id)
   }
 
   inner class InstanceAndClassDefinition {
-    val field = LinkedHashMap<String, HeapValue>()
-    val staticField = LinkedHashMap<String, HeapValue>()
+    val field = LinkedHashMap<String, ValueHolder>()
+    val staticField = LinkedHashMap<String, ValueHolder>()
   }
 
   inner class ClassDefinition {
-    val staticField = LinkedHashMap<String, HeapValue>()
+    val staticField = LinkedHashMap<String, ValueHolder>()
   }
 
-  infix fun String.watchedInstance(block: InstanceAndClassDefinition.() -> Unit): ObjectReference {
+  infix fun String.watchedInstance(block: InstanceAndClassDefinition.() -> Unit): ReferenceHolder {
     val instance = this.instance(block)
     keyedWeakReference(instance)
     return instance
   }
 
-  infix fun String.instance(block: InstanceAndClassDefinition.() -> Unit): ObjectReference {
+  infix fun String.instance(block: InstanceAndClassDefinition.() -> Unit): ReferenceHolder {
     val definition = InstanceAndClassDefinition()
     block(definition)
 
@@ -237,24 +224,24 @@ class HprofWriterHelper constructor(
     return clazz(this, staticFields = staticFields)
   }
 
-  val String.charArrayDump: ObjectReference
+  val String.charArrayDump: ReferenceHolder
     get() {
       val arrayDump = CharArrayDump(id, 1, toCharArray())
       writer.write(arrayDump)
-      return ObjectReference(arrayDump.id)
+      return ReferenceHolder(arrayDump.id)
     }
 
   fun objectArray(
-    vararg elements: ObjectReference
-  ): ObjectReference {
+    vararg elements: ReferenceHolder
+  ): ReferenceHolder {
     return objectArrayOf(objectArrayClassId, *elements)
   }
 
   fun objectArrayOf(
     classId: Long,
-    vararg elements: ObjectReference
-  ): ObjectReference {
-    return ObjectReference(objectArray(classId, elements.map { it.value }.toLongArray()))
+    vararg elements: ReferenceHolder
+  ): ReferenceHolder {
+    return ReferenceHolder(objectArray(classId, elements.map { it.value }.toLongArray()))
   }
 
   fun objectArray(
@@ -266,31 +253,31 @@ class HprofWriterHelper constructor(
     return arrayDump.id
   }
 
-  private fun typeOf(wrapper: HeapValue): Int {
+  private fun typeOf(wrapper: ValueHolder): Int {
     return when (wrapper) {
-      is ObjectReference -> HprofReader.OBJECT_TYPE
-      is BooleanValue -> HprofReader.BOOLEAN_TYPE
-      is CharValue -> HprofReader.CHAR_TYPE
-      is FloatValue -> HprofReader.FLOAT_TYPE
-      is DoubleValue -> HprofReader.DOUBLE_TYPE
-      is ByteValue -> HprofReader.BYTE_TYPE
-      is ShortValue -> HprofReader.SHORT_TYPE
-      is IntValue -> HprofReader.INT_TYPE
-      is LongValue -> HprofReader.LONG_TYPE
+      is ReferenceHolder -> PrimitiveType.REFERENCE_HPROF_TYPE
+      is BooleanHolder -> BOOLEAN.hprofType
+      is CharHolder -> CHAR.hprofType
+      is FloatHolder -> FLOAT.hprofType
+      is DoubleHolder -> DOUBLE.hprofType
+      is ByteHolder -> BYTE.hprofType
+      is ShortHolder -> SHORT.hprofType
+      is IntHolder -> INT.hprofType
+      is LongHolder -> LONG.hprofType
     }
   }
 
-  private fun typeOf(wrapperClass: KClass<out HeapValue>): Int {
+  private fun typeOf(wrapperClass: KClass<out ValueHolder>): Int {
     return when (wrapperClass) {
-      ObjectReference::class -> HprofReader.OBJECT_TYPE
-      BooleanValue::class -> HprofReader.BOOLEAN_TYPE
-      CharValue::class -> HprofReader.CHAR_TYPE
-      FloatValue::class -> HprofReader.FLOAT_TYPE
-      DoubleValue::class -> HprofReader.DOUBLE_TYPE
-      ByteValue::class -> HprofReader.BYTE_TYPE
-      ShortValue::class -> HprofReader.SHORT_TYPE
-      IntValue::class -> HprofReader.INT_TYPE
-      LongValue::class -> HprofReader.LONG_TYPE
+      ReferenceHolder::class -> PrimitiveType.REFERENCE_HPROF_TYPE
+      BooleanHolder::class -> BOOLEAN.hprofType
+      CharHolder::class -> CHAR.hprofType
+      FloatHolder::class -> FLOAT.hprofType
+      DoubleHolder::class -> DOUBLE.hprofType
+      ByteHolder::class -> BYTE.hprofType
+      ShortHolder::class -> SHORT.hprofType
+      IntHolder::class -> INT.hprofType
+      LongHolder::class -> LONG.hprofType
       else -> throw IllegalArgumentException("Unexpected class $wrapperClass")
     }
   }
@@ -301,9 +288,11 @@ class HprofWriterHelper constructor(
 }
 
 fun File.dump(block: HprofWriterHelper.() -> Unit) {
-  HprofWriterHelper(HprofWriter.open(this)).use(block)
+  HprofWriterHelper(HprofWriter.open(this))
+      .use(block)
 }
 
 fun HprofWriter.helper(block: HprofWriterHelper.() -> Unit) {
-  HprofWriterHelper(this).use(block)
+  HprofWriterHelper(this)
+      .use(block)
 }
\ No newline at end of file
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt b/shark/src/test/java/shark/LabelerTest.kt
similarity index 77%
rename from leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt
rename to shark/src/test/java/shark/LabelerTest.kt
index 5fe9984b..bf4776f3 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LabelerTest.kt
+++ b/shark/src/test/java/shark/LabelerTest.kt
@@ -1,11 +1,5 @@
-package leakcanary.internal
-
-import leakcanary.AndroidObjectInspectors
-import leakcanary.HeapAnalysisSuccess
-import leakcanary.HprofGraph
-import leakcanary.ObjectInspector
-import leakcanary.ObjectReporter
-import leakcanary.whenInstanceOf
+package shark
+
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
 import org.junit.Rule
@@ -27,9 +21,8 @@ class LabelerTest {
   @Test fun stringContentAsLabel() {
     hprofFile.writeSinglePathToString("World")
 
-    val labeler = object : ObjectInspector{
+    val labeler = object : ObjectInspector {
       override fun inspect(
-        graph: HprofGraph,
         reporter: ObjectReporter
       ) {
         reporter.whenInstanceOf("java.lang.String")  { instance ->
@@ -49,7 +42,7 @@ class LabelerTest {
     hprofFile.writeJavaLocalLeak(threadClass = "MyThread", threadName = "kroutine")
 
     val analysis =
-      hprofFile.checkForLeaks<HeapAnalysisSuccess>(objectInspectors = listOf(AndroidObjectInspectors.THREAD))
+      hprofFile.checkForLeaks<HeapAnalysisSuccess>(objectInspectors = listOf(ObjectInspectors.THREAD))
 
     val leak = analysis.applicationLeaks[0]
 
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt b/shark/src/test/java/shark/LeakStatusTest.kt
similarity index 91%
rename from leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt
rename to shark/src/test/java/shark/LeakStatusTest.kt
index 1b462ee8..060ea61a 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakStatusTest.kt
+++ b/shark/src/test/java/shark/LeakStatusTest.kt
@@ -1,20 +1,15 @@
-package leakcanary.internal
-
-import leakcanary.AndroidObjectInspectors
-import leakcanary.GraphObjectRecord.GraphClassRecord
-import leakcanary.GraphObjectRecord.GraphInstanceRecord
-import leakcanary.HeapAnalysisSuccess
-import leakcanary.HprofGraph
-import leakcanary.LeakNodeStatus.LEAKING
-import leakcanary.LeakNodeStatus.NOT_LEAKING
-import leakcanary.LeakNodeStatus.UNKNOWN
-import leakcanary.ObjectInspector
-import leakcanary.ObjectReporter
+package shark
+
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TemporaryFolder
+import shark.HeapObject.HeapClass
+import shark.HeapObject.HeapInstance
+import shark.LeakNodeStatus.LEAKING
+import shark.LeakNodeStatus.NOT_LEAKING
+import shark.LeakNodeStatus.UNKNOWN
 import java.io.File
 
 class LeakStatusTest {
@@ -32,7 +27,7 @@ class LeakStatusTest {
     hprofFile.writeSinglePathToInstance()
 
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-        objectInspectors = listOf(AndroidObjectInspectors.CLASS)
+        objectInspectors = listOf(ObjectInspectors.CLASS)
     )
 
     val leak = analysis.applicationLeaks[0]
@@ -193,7 +188,7 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          objectInspectors = listOf(leakingClass("GcRoot"), AndroidObjectInspectors.CLASS)
+          objectInspectors = listOf(leakingClass("GcRoot"), ObjectInspectors.CLASS)
       )
 
     val leak = analysis.applicationLeaks[0]
@@ -209,7 +204,7 @@ class LeakStatusTest {
 
     val analysis =
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
-          objectInspectors = listOf(notLeakingClass("GcRoot"), AndroidObjectInspectors.CLASS)
+          objectInspectors = listOf(notLeakingClass("GcRoot"), ObjectInspectors.CLASS)
       )
 
     println(analysis)
@@ -432,11 +427,10 @@ class LeakStatusTest {
   private fun notLeakingInstance(className: String): ObjectInspector {
     return object : ObjectInspector {
       override fun inspect(
-        graph: HprofGraph,
         reporter: ObjectReporter
       ) {
-        val record = reporter.objectRecord
-        if (record is GraphInstanceRecord && record.className == className) {
+        val record = reporter.heapObject
+        if (record is HeapInstance && record.instanceClassName == className) {
           reporter.reportNotLeaking("$className is not leaking")
         }
       }
@@ -446,11 +440,10 @@ class LeakStatusTest {
   private fun leakingInstance(className: String): ObjectInspector {
     return object : ObjectInspector {
       override fun inspect(
-        graph: HprofGraph,
         reporter: ObjectReporter
       ) {
-        val record = reporter.objectRecord
-        if (record is GraphInstanceRecord && record.className == className) {
+        val record = reporter.heapObject
+        if (record is HeapInstance && record.instanceClassName == className) {
           reporter.reportLeaking("$className is leaking")
         }
       }
@@ -460,11 +453,10 @@ class LeakStatusTest {
   private fun notLeakingClass(className: String): ObjectInspector {
     return object : ObjectInspector {
       override fun inspect(
-        graph: HprofGraph,
         reporter: ObjectReporter
       ) {
-        val record = reporter.objectRecord
-        if (record is GraphClassRecord && record.name == className) {
+        val record = reporter.heapObject
+        if (record is HeapClass && record.name == className) {
           reporter.reportNotLeaking("$className is not leaking")
         }
       }
@@ -474,11 +466,10 @@ class LeakStatusTest {
   private fun leakingClass(className: String): ObjectInspector {
     return object : ObjectInspector {
       override fun inspect(
-        graph: HprofGraph,
         reporter: ObjectReporter
       ) {
-        val record = reporter.objectRecord
-        if (record is GraphClassRecord && record.name == className) {
+        val record = reporter.heapObject
+        if (record is HeapClass && record.name == className) {
           reporter.reportLeaking("$className is leaking")
         }
       }
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt b/shark/src/test/java/shark/LeakTraceRendererTest.kt
similarity index 93%
rename from leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt
rename to shark/src/test/java/shark/LeakTraceRendererTest.kt
index 7ae61f68..85612ebe 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/LeakTraceRendererTest.kt
+++ b/shark/src/test/java/shark/LeakTraceRendererTest.kt
@@ -1,17 +1,13 @@
-package leakcanary.internal
-
-import leakcanary.HeapAnalysisSuccess
-import leakcanary.HprofGraph
-import leakcanary.ObjectInspector
-import leakcanary.ObjectReporter
-import leakcanary.ReferenceMatcher.LibraryLeakReferenceMatcher
-import leakcanary.ReferencePattern.InstanceFieldPattern
-import leakcanary.whenInstanceOf
+package shark
+
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TemporaryFolder
+import shark.LibraryLeakReferenceMatcher
+import shark.ReferencePattern.InstanceFieldPattern
+import shark.internal.renderToString
 import java.io.File
 
 class LeakTraceRendererTest {
@@ -64,7 +60,6 @@ class LeakTraceRendererTest {
       hprofFile.checkForLeaks<HeapAnalysisSuccess>(
           objectInspectors = listOf(object : ObjectInspector {
             override fun inspect(
-              graph: HprofGraph,
               reporter: ObjectReporter
             ) {
               reporter.whenInstanceOf("ClassB") {
@@ -100,7 +95,6 @@ class LeakTraceRendererTest {
     val analysis = hprofFile.checkForLeaks<HeapAnalysisSuccess>(
         objectInspectors = listOf(object : ObjectInspector {
           override fun inspect(
-            graph: HprofGraph,
             reporter: ObjectReporter
           ) {
             reporter.addLabel("Â¯\\_(ãƒ„)_/Â¯")
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/ReferenceMatcherTest.kt b/shark/src/test/java/shark/ReferenceMatcherTest.kt
similarity index 87%
rename from leakcanary-analyzer/src/test/java/leakcanary/internal/ReferenceMatcherTest.kt
rename to shark/src/test/java/shark/ReferenceMatcherTest.kt
index 828e14ee..a610a650 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/ReferenceMatcherTest.kt
+++ b/shark/src/test/java/shark/ReferenceMatcherTest.kt
@@ -1,17 +1,15 @@
-package leakcanary.internal
-
-import leakcanary.HeapAnalysisSuccess
-import leakcanary.KeyedWeakReference
-import leakcanary.ReferenceMatcher.IgnoredReferenceMatcher
-import leakcanary.ReferenceMatcher.LibraryLeakReferenceMatcher
-import leakcanary.ReferencePattern.InstanceFieldPattern
-import leakcanary.ReferencePattern.JavaLocalPattern
-import leakcanary.ReferencePattern.StaticFieldPattern
+package shark
+
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TemporaryFolder
+import shark.IgnoredReferenceMatcher
+import shark.LibraryLeakReferenceMatcher
+import shark.ReferencePattern.InstanceFieldPattern
+import shark.ReferencePattern.JavaLocalPattern
+import shark.ReferencePattern.StaticFieldPattern
 import java.io.File
 import java.lang.ref.WeakReference
 
@@ -101,7 +99,7 @@ class ReferenceMatcherTest {
                 pattern = InstanceFieldPattern(WeakReference::class.java.name, "referent")
             ),
             IgnoredReferenceMatcher(
-                pattern = InstanceFieldPattern(KeyedWeakReference::class.java.name, "referent")
+                pattern = InstanceFieldPattern("leakcanary.KeyedWeakReference", "referent")
             )
         )
     )
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/RetainedSizeTest.kt b/shark/src/test/java/shark/RetainedSizeTest.kt
similarity index 84%
rename from leakcanary-analyzer/src/test/java/leakcanary/internal/RetainedSizeTest.kt
rename to shark/src/test/java/shark/RetainedSizeTest.kt
index 5d2d4632..598c7531 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/RetainedSizeTest.kt
+++ b/shark/src/test/java/shark/RetainedSizeTest.kt
@@ -1,18 +1,14 @@
-package leakcanary.internal
-
-import leakcanary.HeapAnalysis
-import leakcanary.HeapAnalysisSuccess
-import leakcanary.HeapValue
-import leakcanary.HeapValue.IntValue
-import leakcanary.HeapValue.LongValue
-import leakcanary.HeapValue.ObjectReference
-import leakcanary.HeapValue.ShortValue
-import leakcanary.Leak
+package shark
+
 import org.assertj.core.api.Assertions.assertThat
 import org.junit.Before
 import org.junit.Rule
 import org.junit.Test
 import org.junit.rules.TemporaryFolder
+import shark.ValueHolder.IntHolder
+import shark.ValueHolder.LongHolder
+import shark.ValueHolder.ReferenceHolder
+import shark.ValueHolder.ShortHolder
 import java.io.File
 
 class RetainedSizeTest {
@@ -42,7 +38,7 @@ class RetainedSizeTest {
     hprofFile.dump {
       "GcRoot" clazz {
         staticField["shortestPath"] = "Leaking" watchedInstance {
-          field["answer"] = LongValue(42)
+          field["answer"] = LongHolder(42)
         }
       }
     }
@@ -88,7 +84,7 @@ class RetainedSizeTest {
       "GcRoot" clazz {
         staticField["shortestPath"] = "Leaking" watchedInstance {
           field["answer"] = "FortyTwo" instance {
-            field["number"] = IntValue(42)
+            field["number"] = IntHolder(42)
           }
         }
       }
@@ -105,7 +101,7 @@ class RetainedSizeTest {
       "GcRoot" clazz {
         staticField["shortestPath"] = "Leaking" watchedInstance {
           field["answer"] = "java.lang.Integer" instance {
-            field["value"] = IntValue(42)
+            field["value"] = IntHolder(42)
           }
         }
       }
@@ -119,7 +115,7 @@ class RetainedSizeTest {
 
   @Test fun leakingInstanceWithPrimitiveWrapperArray() {
     hprofFile.dump {
-      val intWrapperClass = clazz("java.lang.Integer", fields = listOf("value" to IntValue::class))
+      val intWrapperClass = clazz("java.lang.Integer", fields = listOf("value" to IntHolder::class))
 
       "GcRoot" clazz {
         staticField["shortestPath"] = "Leaking" watchedInstance {
@@ -127,11 +123,11 @@ class RetainedSizeTest {
               intWrapperClass,
               instance(
                   intWrapperClass,
-                  fields = listOf<HeapValue>(IntValue(4))
+                  fields = listOf<ValueHolder>(IntHolder(4))
               ),
               instance(
                   intWrapperClass,
-                  fields = listOf<HeapValue>(IntValue(2))
+                  fields = listOf<ValueHolder>(IntHolder(2))
               )
           )
         }
@@ -197,13 +193,13 @@ class RetainedSizeTest {
 
   @Test fun leakingInstanceWithSuperClass() {
     hprofFile.dump {
-      val parentClass = clazz("Parent", fields = listOf("value" to LongValue::class))
+      val parentClass = clazz("Parent", fields = listOf("value" to LongHolder::class))
       val childClass =
-        clazz("Child", superClassId = parentClass, fields = listOf("value" to IntValue::class))
+        clazz("Child", superclassId = parentClass, fields = listOf("value" to IntHolder::class))
 
       "GcRoot" clazz {
         staticField["shortestPath"] = "Leaking" watchedInstance {
-          field["answer"] = instance(childClass, listOf(LongValue(42), IntValue(42)))
+          field["answer"] = instance(childClass, listOf(LongHolder(42), IntHolder(42)))
         }
       }
     }
@@ -218,11 +214,11 @@ class RetainedSizeTest {
     hprofFile.dump {
       "GcRoot" clazz {
         staticField["shortestPath"] = "GrandParentLeaking" watchedInstance {
-          field["answer"] = ShortValue(42)
+          field["answer"] = ShortHolder(42)
           field["child"] = "ParentLeaking" watchedInstance {
-            field["answer"] = IntValue(42)
+            field["answer"] = IntHolder(42)
             field["child"] = "ChildLeaking" watchedInstance {
-              field["answer"] = LongValue(42)
+              field["answer"] = LongHolder(42)
             }
           }
         }
@@ -236,7 +232,7 @@ class RetainedSizeTest {
 
     assertThat(instance.className).isEqualTo("GrandParentLeaking")
     // 4 bytes per ref * 2 + short + int + long
-    assertThat(instance.retainedHeapSize).isEqualTo(22)
+    assertThat(instance.retainedHeapByteSize).isEqualTo(22)
   }
 
   @Test fun crossDominatedIsNotDominated() {
@@ -259,7 +255,7 @@ class RetainedSizeTest {
 
     retainedInstances.forEach { instance ->
       // 4 byte reference
-      assertThat(instance.retainedHeapSize).isEqualTo(4)
+      assertThat(instance.retainedHeapByteSize).isEqualTo(4)
     }
   }
 
@@ -271,22 +267,22 @@ class RetainedSizeTest {
 
     hprofFile.dump {
       val bitmap = "android.graphics.Bitmap" instance {
-        field["mWidth"] = IntValue(width)
-        field["mHeight"] = IntValue(height)
+        field["mWidth"] = IntHolder(width)
+        field["mHeight"] = IntHolder(height)
       }
 
       val referenceClass =
-        clazz("java.lang.ref.Reference", fields = listOf("referent" to ObjectReference::class))
+        clazz("java.lang.ref.Reference", fields = listOf("referent" to ReferenceHolder::class))
       val cleanerClass = clazz(
           "sun.misc.Cleaner", clazz("java.lang.ref.PhantomReference", referenceClass),
-          fields = listOf("thunk" to ObjectReference::class)
+          fields = listOf("thunk" to ReferenceHolder::class)
       )
 
       instance(
           cleanerClass,
           fields = listOf("libcore.util.NativeAllocationRegistry\$CleanerThunk" instance {
             field["this\$0"] = "libcore.util.NativeAllocationRegistry" instance {
-              field["size"] = LongValue(nativeBitmapSize.toLong())
+              field["size"] = LongHolder(nativeBitmapSize.toLong())
             }
           }, bitmap)
       )
@@ -313,7 +309,7 @@ class RetainedSizeTest {
 
   private fun firstRetainedSize(): Int {
     return retainedInstances()
-        .map { it.retainedHeapSize!! }
+        .map { it.retainedHeapByteSize!! }
         .first()
   }
 
diff --git a/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt b/shark/src/test/java/shark/TestUtil.kt
similarity index 74%
rename from leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
rename to shark/src/test/java/shark/TestUtil.kt
index f25f6e3c..3d450d9d 100644
--- a/leakcanary-analyzer/src/test/java/leakcanary/internal/TestUtil.kt
+++ b/shark/src/test/java/shark/TestUtil.kt
@@ -1,16 +1,7 @@
-package leakcanary.internal
+package shark
 
-import leakcanary.AnalyzerProgressListener
-import leakcanary.AndroidObjectInspectors
-import leakcanary.HeapAnalysis
-import leakcanary.HeapAnalysisFailure
-import leakcanary.HeapAnalyzer
-import leakcanary.KeyedWeakReference
-import leakcanary.ObjectInspector
-import leakcanary.ReferenceMatcher
-import leakcanary.ReferenceMatcher.IgnoredReferenceMatcher
-import leakcanary.ReferencePattern.InstanceFieldPattern
-import leakcanary.ReferencePattern.JavaLocalPattern
+import shark.ReferencePattern.InstanceFieldPattern
+import shark.ReferencePattern.JavaLocalPattern
 import java.io.File
 import java.lang.ref.PhantomReference
 import java.lang.ref.SoftReference
@@ -22,12 +13,12 @@ fun <T : HeapAnalysis> File.checkForLeaks(
   computeRetainedHeapSize: Boolean = false,
   referenceMatchers: List<ReferenceMatcher> = defaultReferenceMatchers
 ): T {
-  val inspectors = if (AndroidObjectInspectors.KEYED_WEAK_REFERENCE !in objectInspectors) {
-    objectInspectors + AndroidObjectInspectors.KEYED_WEAK_REFERENCE
+  val inspectors = if (ObjectInspectors.KEYED_WEAK_REFERENCE !in objectInspectors) {
+    objectInspectors + ObjectInspectors.KEYED_WEAK_REFERENCE
   } else {
     objectInspectors
   }
-  val heapAnalyzer = HeapAnalyzer(AnalyzerProgressListener.NONE)
+  val heapAnalyzer = HeapAnalyzer(OnAnalysisProgressListener.NO_OP)
   val result = heapAnalyzer.checkForLeaks(
       this, referenceMatchers, computeRetainedHeapSize, inspectors
   )
@@ -44,7 +35,7 @@ val defaultReferenceMatchers: List<ReferenceMatcher> =
       )
       ,
       IgnoredReferenceMatcher(
-          pattern = InstanceFieldPattern(KeyedWeakReference::class.java.name, "referent")
+          pattern = InstanceFieldPattern("leakcanary.KeyedWeakReference", "referent")
       )
       ,
       IgnoredReferenceMatcher(
