diff --git a/.gitignore b/.gitignore
index 34f57587..a026429f 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,11 @@
 #OSX
 .DS_Store
 target/
+
+.idea/
+*.iml
+
+#Gradle
+build/
+.gradle/
+local.properties
diff --git a/.travis.yml b/.travis.yml
new file mode 100644
index 00000000..22cec24d
--- /dev/null
+++ b/.travis.yml
@@ -0,0 +1,30 @@
+language: java
+jdk: oraclejdk7
+before_install:
+    # Install base Android SDK
+    - sudo apt-get update -qq
+    - if [ `uname -m` = x86_64 ]; then sudo apt-get install -qq --force-yes libgd2-xpm ia32-libs ia32-libs-multiarch; fi
+    - wget http://dl.google.com/android/android-sdk_r21.0.1-linux.tgz
+    - tar xzf android-sdk_r21.0.1-linux.tgz
+    - export ANDROID_HOME=$PWD/android-sdk-linux
+    - export PATH=${PATH}:${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools
+
+    # Install Android NDK
+    - wget http://dl.google.com/android/ndk/android-ndk-r8e-linux-x86_64.tar.bz2
+    - tar xjf android-ndk-r8e-linux-x86_64.tar.bz2
+    - export ANDROID_NDK_HOME=$PWD/android-ndk-r8e
+
+    # Install required Android components.
+    - echo y | android update sdk --filter platform-tools --no-ui --force > /dev/null
+    - echo y | android update sdk --filter tools --no-ui --force > /dev/null
+    - echo y | android update sdk --filter build-tools-17.0.0 --no-ui --force > /dev/null
+
+    - echo y | android update sdk --filter android-16 --no-ui --force > /dev/null
+    - echo y | android update sdk --filter android-17 --no-ui --force > /dev/null
+    - echo y | android update sdk --filter extra-android-support --no-ui --force > /dev/null
+
+    # setup properties (no real values, but needed for setup)
+    - echo "sonatypeRepo=http://doesnotmatter" > gradle.properties
+    - echo "sonatypeSnapshotRepo=http://doesnotmatter" >> gradle.properties
+    - echo "sonatypeUsername=doesnotmatter" >> gradle.properties
+    - echo "sonatypePassword=doesnotmatter" >> gradle.properties
\ No newline at end of file
diff --git a/README.md b/README.md
index 99ed7c21..a0dddf3f 100644
--- a/README.md
+++ b/README.md
@@ -1,4 +1,5 @@
 # GPUImage for Android
+[![Build Status](https://api.travis-ci.org/CyberAgent/android-gpuimage.png?branch=master,develop)](https://travis-ci.org/CyberAgent/android-gpuimage)
 
 Idea from: [iOS GPUImage framework](https://github.com/BradLarson/GPUImage)
 
diff --git a/build.gradle b/build.gradle
new file mode 100644
index 00000000..ee787e84
--- /dev/null
+++ b/build.gradle
@@ -0,0 +1,9 @@
+buildscript {
+    repositories {
+        mavenCentral()
+    }
+
+    dependencies {
+        classpath 'com.android.tools.build:gradle:0.5.+'
+    }
+}
\ No newline at end of file
diff --git a/gradle/wrapper/gradle-wrapper.jar b/gradle/wrapper/gradle-wrapper.jar
new file mode 100644
index 00000000..8c0fb64a
Binary files /dev/null and b/gradle/wrapper/gradle-wrapper.jar differ
diff --git a/gradle/wrapper/gradle-wrapper.properties b/gradle/wrapper/gradle-wrapper.properties
new file mode 100644
index 00000000..5c22dec0
--- /dev/null
+++ b/gradle/wrapper/gradle-wrapper.properties
@@ -0,0 +1,6 @@
+#Wed Apr 10 15:27:10 PDT 2013
+distributionBase=GRADLE_USER_HOME
+distributionPath=wrapper/dists
+zipStoreBase=GRADLE_USER_HOME
+zipStorePath=wrapper/dists
+distributionUrl=http\://services.gradle.org/distributions/gradle-1.6-bin.zip
diff --git a/gradlew b/gradlew
new file mode 100755
index 00000000..91a7e269
--- /dev/null
+++ b/gradlew
@@ -0,0 +1,164 @@
+#!/usr/bin/env bash
+
+##############################################################################
+##
+##  Gradle start up script for UN*X
+##
+##############################################################################
+
+# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+DEFAULT_JVM_OPTS=""
+
+APP_NAME="Gradle"
+APP_BASE_NAME=`basename "$0"`
+
+# Use the maximum available, or set MAX_FD != -1 to use that value.
+MAX_FD="maximum"
+
+warn ( ) {
+    echo "$*"
+}
+
+die ( ) {
+    echo
+    echo "$*"
+    echo
+    exit 1
+}
+
+# OS specific support (must be 'true' or 'false').
+cygwin=false
+msys=false
+darwin=false
+case "`uname`" in
+  CYGWIN* )
+    cygwin=true
+    ;;
+  Darwin* )
+    darwin=true
+    ;;
+  MINGW* )
+    msys=true
+    ;;
+esac
+
+# For Cygwin, ensure paths are in UNIX format before anything is touched.
+if $cygwin ; then
+    [ -n "$JAVA_HOME" ] && JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
+fi
+
+# Attempt to set APP_HOME
+# Resolve links: $0 may be a link
+PRG="$0"
+# Need this for relative symlinks.
+while [ -h "$PRG" ] ; do
+    ls=`ls -ld "$PRG"`
+    link=`expr "$ls" : '.*-> \(.*\)$'`
+    if expr "$link" : '/.*' > /dev/null; then
+        PRG="$link"
+    else
+        PRG=`dirname "$PRG"`"/$link"
+    fi
+done
+SAVED="`pwd`"
+cd "`dirname \"$PRG\"`/" >&-
+APP_HOME="`pwd -P`"
+cd "$SAVED" >&-
+
+CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar
+
+# Determine the Java command to use to start the JVM.
+if [ -n "$JAVA_HOME" ] ; then
+    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
+        # IBM's JDK on AIX uses strange locations for the executables
+        JAVACMD="$JAVA_HOME/jre/sh/java"
+    else
+        JAVACMD="$JAVA_HOME/bin/java"
+    fi
+    if [ ! -x "$JAVACMD" ] ; then
+        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+    fi
+else
+    JAVACMD="java"
+    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+
+Please set the JAVA_HOME variable in your environment to match the
+location of your Java installation."
+fi
+
+# Increase the maximum file descriptors if we can.
+if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
+    MAX_FD_LIMIT=`ulimit -H -n`
+    if [ $? -eq 0 ] ; then
+        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
+            MAX_FD="$MAX_FD_LIMIT"
+        fi
+        ulimit -n $MAX_FD
+        if [ $? -ne 0 ] ; then
+            warn "Could not set maximum file descriptor limit: $MAX_FD"
+        fi
+    else
+        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
+    fi
+fi
+
+# For Darwin, add options to specify how the application appears in the dock
+if $darwin; then
+    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
+fi
+
+# For Cygwin, switch paths to Windows format before running java
+if $cygwin ; then
+    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
+    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
+
+    # We build the pattern for arguments to be converted via cygpath
+    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
+    SEP=""
+    for dir in $ROOTDIRSRAW ; do
+        ROOTDIRS="$ROOTDIRS$SEP$dir"
+        SEP="|"
+    done
+    OURCYGPATTERN="(^($ROOTDIRS))"
+    # Add a user-defined pattern to the cygpath arguments
+    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
+        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
+    fi
+    # Now convert the arguments - kludge to limit ourselves to /bin/sh
+    i=0
+    for arg in "$@" ; do
+        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
+        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option
+
+        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
+            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
+        else
+            eval `echo args$i`="\"$arg\""
+        fi
+        i=$((i+1))
+    done
+    case $i in
+        (0) set -- ;;
+        (1) set -- "$args0" ;;
+        (2) set -- "$args0" "$args1" ;;
+        (3) set -- "$args0" "$args1" "$args2" ;;
+        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
+        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
+        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
+        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
+        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
+        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
+    esac
+fi
+
+# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
+function splitJvmOpts() {
+    JVM_OPTS=("$@")
+}
+eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
+JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"
+
+exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
diff --git a/gradlew.bat b/gradlew.bat
new file mode 100644
index 00000000..aec99730
--- /dev/null
+++ b/gradlew.bat
@@ -0,0 +1,90 @@
+@if "%DEBUG%" == "" @echo off
+@rem ##########################################################################
+@rem
+@rem  Gradle startup script for Windows
+@rem
+@rem ##########################################################################
+
+@rem Set local scope for the variables with windows NT shell
+if "%OS%"=="Windows_NT" setlocal
+
+@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
+set DEFAULT_JVM_OPTS=
+
+set DIRNAME=%~dp0
+if "%DIRNAME%" == "" set DIRNAME=.
+set APP_BASE_NAME=%~n0
+set APP_HOME=%DIRNAME%
+
+@rem Find java.exe
+if defined JAVA_HOME goto findJavaFromJavaHome
+
+set JAVA_EXE=java.exe
+%JAVA_EXE% -version >NUL 2>&1
+if "%ERRORLEVEL%" == "0" goto init
+
+echo.
+echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:findJavaFromJavaHome
+set JAVA_HOME=%JAVA_HOME:"=%
+set JAVA_EXE=%JAVA_HOME%/bin/java.exe
+
+if exist "%JAVA_EXE%" goto init
+
+echo.
+echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
+echo.
+echo Please set the JAVA_HOME variable in your environment to match the
+echo location of your Java installation.
+
+goto fail
+
+:init
+@rem Get command-line arguments, handling Windowz variants
+
+if not "%OS%" == "Windows_NT" goto win9xME_args
+if "%@eval[2+2]" == "4" goto 4NT_args
+
+:win9xME_args
+@rem Slurp the command line arguments.
+set CMD_LINE_ARGS=
+set _SKIP=2
+
+:win9xME_args_slurp
+if "x%~1" == "x" goto execute
+
+set CMD_LINE_ARGS=%*
+goto execute
+
+:4NT_args
+@rem Get arguments from the 4NT Shell from JP Software
+set CMD_LINE_ARGS=%$
+
+:execute
+@rem Setup the command line
+
+set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar
+
+@rem Execute Gradle
+"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%
+
+:end
+@rem End local scope for the variables with windows NT shell
+if "%ERRORLEVEL%"=="0" goto mainEnd
+
+:fail
+rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
+rem the _cmd.exe /c_ return code!
+if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
+exit /b 1
+
+:mainEnd
+if "%OS%"=="Windows_NT" endlocal
+
+:omega
diff --git a/library/build.gradle b/library/build.gradle
new file mode 100644
index 00000000..3e0fba53
--- /dev/null
+++ b/library/build.gradle
@@ -0,0 +1,115 @@
+apply plugin: 'android-library'
+apply plugin: 'maven'
+apply plugin: 'signing'
+
+version = "1.1.2-SNAPSHOT"
+group = "jp.co.cyberagent.android.gpuimage"
+
+configurations {
+    archives {
+        extendsFrom configurations.default
+    }
+}
+
+signing {
+    required { has("release") && gradle.taskGraph.hasTask("uploadArchives") }
+    sign configurations.archives
+}
+
+uploadArchives {
+    configuration = configurations.archives
+    repositories.mavenDeployer {
+        beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
+
+        repository(url: sonatypeRepo) {
+            authentication(userName: sonatypeUsername, password: sonatypePassword)
+        }
+        snapshotRepository(url: sonatypeSnapshotRepo) {
+            authentication(userName: sonatypeUsername, password: sonatypePassword)
+        }
+
+        pom.project {
+            artifactId 'gpuimage-library'
+            name 'GPUImage for Android Library'
+            packaging 'aar'
+            description 'Image filters for Android with OpenGL (based on GPUImage for iOS)'
+            url 'https://github.com/cyberagent/android-gpuimage/'
+
+            scm {
+                url 'scm:git@github.com:CyberAgent/android-gpuimage.git'
+                connection 'scm:git@github.com:CyberAgent/android-gpuimage.git'
+                developerConnection 'scm:git@github.com:CyberAgent/android-gpuimage.git'
+            }
+
+            licenses {
+                license {
+                    name 'The Apache Software License, Version 2.0'
+                    url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
+                    distribution 'repo'
+                }
+            }
+
+            developers {
+                developer {
+                    id 'pboos'
+                    name 'Patrick Boos'
+                    email 'patrickboos85@gmail.com'
+                }
+            }
+        }
+    }
+}
+
+android {
+    compileSdkVersion 17
+    buildToolsVersion "17.0.0"
+
+    sourceSets {
+        main {
+            manifest.srcFile 'AndroidManifest.xml'
+            java.srcDirs = ['src']
+            resources.srcDirs = ['src']
+            aidl.srcDirs = ['src']
+            renderscript.srcDirs = ['src']
+            res.srcDirs = ['res']
+            assets.srcDirs = ['assets']
+        }
+
+        instrumentTest.setRoot('tests')
+    }
+}
+
+//////////////
+// NDK Support
+//////////////
+task copyNativeLibs(type: Copy, dependsOn: 'buildNative') {
+    from(new File('libs')) { include '**/*.so' }
+    into new File(buildDir, 'native-libs')
+}
+
+tasks.withType(Compile) { compileTask -> compileTask.dependsOn copyNativeLibs }
+
+clean.dependsOn 'cleanCopyNativeLibs'
+
+tasks.withType(com.android.build.gradle.tasks.PackageApplication) { pkgTask ->
+    pkgTask.jniDir new File(buildDir, 'native-libs')
+}
+
+task buildNative(type: Exec) {
+    if (System.env.ANDROID_NDK_HOME != null) {
+        def ndkBuild = new File(System.env.ANDROID_NDK_HOME, 'ndk-build')
+        commandLine ndkBuild
+    } else {
+        doLast {
+            println '##################'
+            println 'Skipping NDK build'
+            println 'Reason: ANDROID_NDK_HOME not set.'
+            println '##################'
+        }
+    }
+}
+
+// UTF-8
+tasks.withType(Compile) {
+    options.encoding = 'UTF-8'
+}
\ No newline at end of file
diff --git a/library/jni/Application.mk b/library/jni/Application.mk
new file mode 100644
index 00000000..10662a35
--- /dev/null
+++ b/library/jni/Application.mk
@@ -0,0 +1,2 @@
+# Build both ARMv5TE and ARMv7-A machine code.
+APP_ABI := all
diff --git a/library/libs/armeabi-v7a/libgpuimage-library.so b/library/libs/armeabi-v7a/libgpuimage-library.so
new file mode 100755
index 00000000..6fcaab55
Binary files /dev/null and b/library/libs/armeabi-v7a/libgpuimage-library.so differ
diff --git a/library/libs/armeabi/libgpuimage-library.so b/library/libs/armeabi/libgpuimage-library.so
index ed495b75..1872c03d 100755
Binary files a/library/libs/armeabi/libgpuimage-library.so and b/library/libs/armeabi/libgpuimage-library.so differ
diff --git a/library/libs/mips/libgpuimage-library.so b/library/libs/mips/libgpuimage-library.so
new file mode 100755
index 00000000..73a349e4
Binary files /dev/null and b/library/libs/mips/libgpuimage-library.so differ
diff --git a/library/libs/x86/libgpuimage-library.so b/library/libs/x86/libgpuimage-library.so
new file mode 100755
index 00000000..931fb569
Binary files /dev/null and b/library/libs/x86/libgpuimage-library.so differ
diff --git a/library/pom.xml b/library/pom.xml
index 6816b883..85d3c401 100644
--- a/library/pom.xml
+++ b/library/pom.xml
@@ -9,7 +9,7 @@
     <parent>
         <groupId>jp.co.cyberagent.android.gpuimage</groupId>
         <artifactId>gpuimage-parent</artifactId>
-        <version>1.0.3</version>
+        <version>1.1.2-SNAPSHOT</version>
     </parent>
 
     <dependencies>
@@ -36,17 +36,9 @@
                             <goal>ndk-build</goal>
                         </goals>
                         <configuration>
-                            <!--
-                            Configure the plugin to remove all built artifacts from the libs/armeabi folder
-                            when the native build is complete
-                            -->
                             <clearNativeArtifacts>false</clearNativeArtifacts>
-                            <!--
-                            Configure the plugin to also attach the built, native, artifact from the libs/armeabi folder
-                            when the native build is complete.  This puts the artifact into the Maven repository
-                            -->
                             <attachNativeArtifacts>true</attachNativeArtifacts>
-                            <target>gpuimage-library</target>
+                            <target>all</target>
                         </configuration>
                     </execution>
                 </executions>
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
index 6eed85de..85812fcd 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImage.java
@@ -16,14 +16,6 @@
 
 package jp.co.cyberagent.android.gpuimage;
 
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.util.List;
-import java.util.concurrent.Semaphore;
-
-import jp.co.cyberagent.android.gpuimage.GPUImageRenderer.Rotation;
 import android.annotation.TargetApi;
 import android.app.ActivityManager;
 import android.content.Context;
@@ -46,28 +38,34 @@
 import android.view.Display;
 import android.view.WindowManager;
 
+import java.io.*;
+import java.net.URL;
+import java.util.List;
+import java.util.concurrent.Semaphore;
+
 /**
  * The main accessor for GPUImage functionality. This class helps to do common
  * tasks through a simple interface.
  */
-public class GPUImage {
+public class GPUImage {  
     private final Context mContext;
     private final GPUImageRenderer mRenderer;
     private GLSurfaceView mGlSurfaceView;
     private GPUImageFilter mFilter;
     private Bitmap mCurrentBitmap;
+    private ScaleType mScaleType = ScaleType.CENTER_CROP;
 
-    /**
-     * Instantiates a new GPUImage object.
+    /**    
+     * Instantiates a new GPUImage object.   
      * 
      * @param context the context
      */
-    public GPUImage(final Context context) {
+    public GPUImage(final Context context) {  
         if (!supportsOpenGLES2(context)) {
             throw new IllegalStateException("OpenGL ES 2.0 is not supported on this phone.");
         }
-
-        mContext = context;
+ 
+        mContext = context; 
         mFilter = new GPUImageFilter();
         mRenderer = new GPUImageRenderer(mFilter);
     }
@@ -83,9 +81,7 @@ private boolean supportsOpenGLES2(final Context context) {
                 context.getSystemService(Context.ACTIVITY_SERVICE);
         final ConfigurationInfo configurationInfo =
                 activityManager.getDeviceConfigurationInfo();
-        final boolean supportsEs2 = configurationInfo.reqGlEsVersion >=
-                0x20000;
-        return supportsEs2;
+        return configurationInfo.reqGlEsVersion >= 0x20000;
     }
 
     /**
@@ -148,7 +144,7 @@ public void setUpCamera(final Camera camera, final int degrees, final boolean fl
                 rotation = Rotation.ROTATION_270;
                 break;
         }
-        mRenderer.setRotation(rotation, flipHorizontal, flipVertical);
+        mRenderer.setRotationCamera(rotation, flipHorizontal, flipVertical);
     }
 
     @TargetApi(11)
@@ -174,12 +170,40 @@ public void setFilter(final GPUImageFilter filter) {
      * @param bitmap the new image
      */
     public void setImage(final Bitmap bitmap) {
-        setImage(bitmap, false);
         mCurrentBitmap = bitmap;
+        mRenderer.setImageBitmap(bitmap, false);
+        requestRender();
+    }
+
+    /**
+     * This sets the scale type of GPUImage. This has to be run before setting the image.
+     * If image is set and scale type changed, image needs to be reset.
+     *
+     * @param scaleType The new ScaleType
+     */
+    public void setScaleType(ScaleType scaleType) {
+        mScaleType = scaleType;
+        mRenderer.setScaleType(scaleType);
+        mRenderer.deleteImage();
+        mCurrentBitmap = null;
+        requestRender();
+    }
+
+    /**
+     * Sets the rotation of the displayed image.
+     *
+     * @param rotation new rotation
+     */
+    public void setRotation(Rotation rotation) {
+        mRenderer.setRotation(rotation);
     }
 
-    private void setImage(final Bitmap bitmap, final boolean recycle) {
-        mRenderer.setImageBitmap(bitmap, recycle);
+    /**
+     * Deletes the current image.
+     */
+    public void deleteImage() {
+        mRenderer.deleteImage();
+        mCurrentBitmap = null;
         requestRender();
     }
 
@@ -189,7 +213,7 @@ private void setImage(final Bitmap bitmap, final boolean recycle) {
      * @param uri the uri of the new image
      */
     public void setImage(final Uri uri) {
-        setImage(new File(getPath(uri)));
+        new LoadImageUriTask(this, uri).execute();
     }
 
     /**
@@ -198,7 +222,7 @@ public void setImage(final Uri uri) {
      * @param file the file of the new image
      */
     public void setImage(final File file) {
-        new LoadImageTask(this, file).run();
+        new LoadImageFileTask(this, file).execute();
     }
 
     private String getPath(final Uri uri) {
@@ -234,32 +258,35 @@ public Bitmap getBitmapWithFilterApplied() {
     public Bitmap getBitmapWithFilterApplied(final Bitmap bitmap) {
         if (mGlSurfaceView != null) {
             mRenderer.deleteImage();
-            final Semaphore lock = new Semaphore(0);
             mRenderer.runOnDraw(new Runnable() {
 
                 @Override
                 public void run() {
-                    mFilter.onDestroy();
-                    lock.release();
+                    synchronized(mFilter) {
+                        mFilter.destroy();
+                        mFilter.notify();
+                    }
                 }
             });
             requestRender();
-
-            try {
-                lock.acquire();
-            } catch (InterruptedException e) {
-                e.printStackTrace();
+            synchronized(mFilter) {
+                try {
+                    mFilter.wait();
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
             }
         }
 
         GPUImageRenderer renderer = new GPUImageRenderer(mFilter);
         renderer.setRotation(Rotation.NORMAL,
                 mRenderer.isFlippedHorizontally(), mRenderer.isFlippedVertically());
+        renderer.setScaleType(mScaleType);
         PixelBuffer buffer = new PixelBuffer(bitmap.getWidth(), bitmap.getHeight());
         buffer.setRenderer(renderer);
         renderer.setImageBitmap(bitmap, false);
         Bitmap result = buffer.getBitmap();
-        mFilter.onDestroy();
+        mFilter.destroy();
         renderer.deleteImage();
         buffer.destroy();
 
@@ -296,13 +323,16 @@ public static void getBitmapForMultipleFilters(final Bitmap bitmap,
         for (GPUImageFilter filter : filters) {
             renderer.setFilter(filter);
             listener.response(buffer.getBitmap());
-            filter.onDestroy();
+            filter.destroy();
         }
         renderer.deleteImage();
         buffer.destroy();
     }
 
     /**
+     * Deprecated: Please use
+     * {@link GPUImageView#saveToPictures(String, String, jp.co.cyberagent.android.gpuimage.GPUImageView.OnPictureSavedListener)}
+     *
      * Save current image with applied filter to Pictures. It will be stored on
      * the default Picture folder on the phone below the given folerName and
      * fileName. <br />
@@ -313,12 +343,16 @@ public static void getBitmapForMultipleFilters(final Bitmap bitmap,
      * @param fileName the file name
      * @param listener the listener
      */
+    @Deprecated
     public void saveToPictures(final String folderName, final String fileName,
             final OnPictureSavedListener listener) {
         saveToPictures(mCurrentBitmap, folderName, fileName, listener);
     }
 
     /**
+     * Deprecated: Please use
+     * {@link GPUImageView#saveToPictures(String, String, jp.co.cyberagent.android.gpuimage.GPUImageView.OnPictureSavedListener)}
+     *
      * Apply and save the given bitmap with applied filter to Pictures. It will
      * be stored on the default Picture folder on the phone below the given
      * folerName and fileName. <br />
@@ -330,11 +364,48 @@ public void saveToPictures(final String folderName, final String fileName,
      * @param fileName the file name
      * @param listener the listener
      */
+    @Deprecated
     public void saveToPictures(final Bitmap bitmap, final String folderName, final String fileName,
             final OnPictureSavedListener listener) {
         new SaveTask(bitmap, folderName, fileName, listener).execute();
     }
 
+    /**
+     * Runs the given Runnable on the OpenGL thread.
+     *
+     * @param runnable The runnable to be run on the OpenGL thread.
+     */
+    void runOnGLThread(Runnable runnable) {
+        mRenderer.runOnDrawEnd(runnable);
+    }
+
+    private int getOutputWidth() {
+        if (mRenderer != null && mRenderer.getFrameWidth() != 0) {
+            return mRenderer.getFrameWidth();
+        } else if (mCurrentBitmap != null) {
+            return mCurrentBitmap.getWidth();
+        } else {
+            WindowManager windowManager =
+                    (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
+            Display display = windowManager.getDefaultDisplay();
+            return display.getWidth();
+        }
+    }
+
+    private int getOutputHeight() {
+        if (mRenderer != null && mRenderer.getFrameHeight() != 0) {
+            return mRenderer.getFrameHeight();
+        } else if (mCurrentBitmap != null) {
+            return mCurrentBitmap.getHeight();
+        } else {
+            WindowManager windowManager =
+                    (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
+            Display display = windowManager.getDefaultDisplay();
+            return display.getHeight();
+        }
+    }
+
+    @Deprecated
     private class SaveTask extends AsyncTask<Void, Void, Void> {
 
         private final Bitmap mBitmap;
@@ -394,87 +465,211 @@ public void run() {
         void onPictureSaved(Uri uri);
     }
 
-    private class LoadImageTask implements Runnable {
+    private class LoadImageUriTask extends LoadImageTask {
+
+        private final Uri mUri;
+
+        public LoadImageUriTask(GPUImage gpuImage, Uri uri) {
+            super(gpuImage);
+            mUri = uri;
+        }
+
+        @Override
+        protected Bitmap decode(BitmapFactory.Options options) {
+            try {
+                InputStream inputStream;
+                if (mUri.getScheme().startsWith("http") || mUri.getScheme().startsWith("https")) {
+                    inputStream = new URL(mUri.toString()).openStream();
+                } else {
+                    inputStream = mContext.getContentResolver().openInputStream(mUri);
+                }
+                return BitmapFactory.decodeStream(inputStream, null, options);
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+            return null;
+        }
+
+        @Override
+        protected int getImageOrientation() throws IOException {
+            Cursor cursor = mContext.getContentResolver().query(mUri,
+                    new String[] { MediaStore.Images.ImageColumns.ORIENTATION }, null, null, null);
+
+            if (cursor == null || cursor.getCount() != 1) {
+                return 0;
+            }
+
+            cursor.moveToFirst();
+            int orientation = cursor.getInt(0);
+            cursor.close();
+            return orientation;
+        }
+    }
+
+    private class LoadImageFileTask extends LoadImageTask {
 
-        private final GPUImage mGPUImage;
         private final File mImageFile;
-        private final int mMaxWidth;
-        private final int mMaxHeight;
 
-        @SuppressWarnings("deprecation")
-        public LoadImageTask(final GPUImage gpuImage, final File file) {
+        public LoadImageFileTask(GPUImage gpuImage, File file) {
+            super(gpuImage);
             mImageFile = file;
+        }
+
+        @Override
+        protected Bitmap decode(BitmapFactory.Options options) {
+            return BitmapFactory.decodeFile(mImageFile.getAbsolutePath(), options);
+        }
+
+        @Override
+        protected int getImageOrientation() throws IOException {
+            ExifInterface exif = new ExifInterface(mImageFile.getAbsolutePath());
+            int orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, 1);
+            switch (orientation) {
+                case ExifInterface.ORIENTATION_NORMAL:
+                    return 0;
+                case ExifInterface.ORIENTATION_ROTATE_90:
+                    return 90;
+                case ExifInterface.ORIENTATION_ROTATE_180:
+                    return 180;
+                case ExifInterface.ORIENTATION_ROTATE_270:
+                    return 270;
+                default:
+                    return 0;
+            }
+        }
+    }
+
+    private abstract class LoadImageTask extends AsyncTask<Void, Void, Bitmap> {
+
+        private final GPUImage mGPUImage;
+        private int mOutputWidth;
+        private int mOutputHeight;
+
+        @SuppressWarnings("deprecation")
+        public LoadImageTask(final GPUImage gpuImage) {
             mGPUImage = gpuImage;
+        }
 
-            WindowManager windowManager =
-                    (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
-            Display display = windowManager.getDefaultDisplay();
-            mMaxWidth = display.getWidth();
-            mMaxHeight = display.getHeight();
+        @Override
+        protected Bitmap doInBackground(Void... params) {
+            if (mRenderer != null && mRenderer.getFrameWidth() == 0) {
+                try {
+                    synchronized (mRenderer.mSurfaceChangedWaiter) {
+                        mRenderer.mSurfaceChangedWaiter.wait(3000);
+                    }
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+            }
+            mOutputWidth = getOutputWidth();
+            mOutputHeight = getOutputHeight();
+            return loadResizedImage();
         }
 
         @Override
-        public void run() {
-            Bitmap bitmap = loadResizedImage(mImageFile);
+        protected void onPostExecute(Bitmap bitmap) {
+            super.onPostExecute(bitmap);
+            mGPUImage.deleteImage();
             mGPUImage.setImage(bitmap);
         }
 
-        private Bitmap loadResizedImage(final File imageFile) {
+        protected abstract Bitmap decode(BitmapFactory.Options options);
+
+        private Bitmap loadResizedImage() {
             BitmapFactory.Options options = new BitmapFactory.Options();
             options.inJustDecodeBounds = true;
-            BitmapFactory.decodeFile(imageFile.getAbsolutePath(), options);
+            decode(options);
             int scale = 1;
-            while (options.outWidth / scale > mMaxWidth || options.outHeight / scale > mMaxHeight) {
+            while (checkSize(options.outWidth / scale > mOutputWidth, options.outHeight / scale > mOutputHeight)) {
                 scale++;
             }
-            Bitmap bitmap = null;
-            Bitmap scaledBitmap = null;
-            if (scale > 1) {
-                scale--;
-                options = new BitmapFactory.Options();
-                options.inSampleSize = scale;
-                options.inPreferredConfig = Bitmap.Config.RGB_565;
-                options.inPurgeable = true;
-                options.inTempStorage = new byte[32 * 1024];
-                bitmap = BitmapFactory.decodeFile(imageFile.getAbsolutePath(), options);
-                if (bitmap == null) {
-                    return null;
-                }
 
-                // resize to desired dimensions
-                int width = bitmap.getWidth();
-                int height = bitmap.getHeight();
-                double newWidth;
-                double newHeight;
-                if ((double) width / mMaxWidth < (double) height / mMaxHeight) {
-                    newHeight = mMaxHeight;
-                    newWidth = (newHeight / height) * width;
-                } else {
-                    newWidth = mMaxWidth;
-                    newHeight = (newWidth / width) * height;
-                }
+            scale--;
+            if (scale < 1) {
+                scale = 1;
+            }
+            options = new BitmapFactory.Options();
+            options.inSampleSize = scale;
+            options.inPreferredConfig = Bitmap.Config.RGB_565;
+            options.inPurgeable = true;
+            options.inTempStorage = new byte[32 * 1024];
+            Bitmap bitmap = decode(options);
+            if (bitmap == null) {
+                return null;
+            }
+            bitmap = rotateImage(bitmap);
+            bitmap = scaleBitmap(bitmap);
+            return bitmap;
+        }
 
-                scaledBitmap = Bitmap.createScaledBitmap(bitmap, Math.round((float) newWidth),
-                        Math.round((float) newHeight), true);
+        private Bitmap scaleBitmap(Bitmap bitmap) {
+            // resize to desired dimensions
+            int width = bitmap.getWidth();
+            int height = bitmap.getHeight();
+            int[] newSize = getScaleSize(width, height);
+            Bitmap workBitmap = Bitmap.createScaledBitmap(bitmap, newSize[0], newSize[1], true);
+            if (workBitmap != bitmap) {
                 bitmap.recycle();
-                bitmap = scaledBitmap;
-
+                bitmap = workBitmap;
                 System.gc();
+            }
+
+            if (mScaleType == ScaleType.CENTER_CROP) {
+                // Crop it
+                int diffWidth = newSize[0] - mOutputWidth;
+                int diffHeight = newSize[1] - mOutputHeight;
+                workBitmap = Bitmap.createBitmap(bitmap, diffWidth / 2, diffHeight / 2,
+                        newSize[0] - diffWidth, newSize[1] - diffHeight);
+                if (workBitmap != bitmap) {
+                    bitmap.recycle();
+                    bitmap = workBitmap;
+                }
+            }
+
+            return bitmap;
+        }
+
+        /**
+         * Retrieve the scaling size for the image dependent on the ScaleType.<br />
+         * <br/>
+         * If CROP: sides are same size or bigger than output's sides<br />
+         * Else   : sides are same size or smaller than output's sides
+         */
+        private int[] getScaleSize(int width, int height) {
+            float newWidth;
+            float newHeight;
+
+            float withRatio = (float) width / mOutputWidth;
+            float heightRatio = (float) height / mOutputHeight;
+
+            boolean adjustWidth = mScaleType == ScaleType.CENTER_CROP
+                    ? withRatio > heightRatio : withRatio < heightRatio;
+
+            if (adjustWidth) {
+                newHeight = mOutputHeight;
+                newWidth = (newHeight / height) * width;
             } else {
-                bitmap = BitmapFactory.decodeFile(imageFile.getAbsolutePath());
+                newWidth = mOutputWidth;
+                newHeight = (newWidth / width) * height;
             }
+            return new int[]{Math.round(newWidth), Math.round(newHeight)};
+        }
 
-            return rotateImage(bitmap, imageFile);
+        private boolean checkSize(boolean widthBigger, boolean heightBigger) {
+            if (mScaleType == ScaleType.CENTER_CROP) {
+                return widthBigger && heightBigger;
+            } else {
+                return widthBigger || heightBigger;
+            }
         }
 
-        private Bitmap rotateImage(final Bitmap bitmap, final File fileWithExifInfo) {
+        private Bitmap rotateImage(final Bitmap bitmap) {
             if (bitmap == null) {
                 return null;
             }
             Bitmap rotatedBitmap = bitmap;
-            int orientation = 0;
             try {
-                orientation = getImageOrientation(fileWithExifInfo.getAbsolutePath());
+                int orientation = getImageOrientation();
                 if (orientation != 0) {
                     Matrix matrix = new Matrix();
                     matrix.postRotate(orientation);
@@ -488,25 +683,12 @@ private Bitmap rotateImage(final Bitmap bitmap, final File fileWithExifInfo) {
             return rotatedBitmap;
         }
 
-        private int getImageOrientation(final String file) throws IOException {
-            ExifInterface exif = new ExifInterface(file);
-            int orientation = exif.getAttributeInt(ExifInterface.TAG_ORIENTATION, 1);
-            switch (orientation) {
-                case ExifInterface.ORIENTATION_NORMAL:
-                    return 0;
-                case ExifInterface.ORIENTATION_ROTATE_90:
-                    return 90;
-                case ExifInterface.ORIENTATION_ROTATE_180:
-                    return 180;
-                case ExifInterface.ORIENTATION_ROTATE_270:
-                    return 270;
-                default:
-                    return 0;
-            }
-        }
+        protected abstract int getImageOrientation() throws IOException;
     }
 
     public interface ResponseListener<T> {
         void response(T item);
     }
+
+    public enum ScaleType { CENTER_INSIDE, CENTER_CROP }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageAddBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageAddBlendFilter.java
new file mode 100644
index 00000000..59dcb343
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageAddBlendFilter.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageAddBlendFilter extends GPUImageTwoInputFilter {
+    public static final String ADD_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2;\n" +
+            "\n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "   lowp vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "   lowp vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+            "\n" +
+            "   mediump float r;\n" +
+            "   if (overlay.r * base.a + base.r * overlay.a >= overlay.a * base.a) {\n" +
+            "     r = overlay.a * base.a + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n" +
+            "   } else {\n" +
+            "     r = overlay.r + base.r;\n" +
+            "   }\n" +
+            "\n" +
+            "   mediump float g;\n" +
+            "   if (overlay.g * base.a + base.g * overlay.a >= overlay.a * base.a) {\n" +
+            "     g = overlay.a * base.a + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n" +
+            "   } else {\n" +
+            "     g = overlay.g + base.g;\n" +
+            "   }\n" +
+            "\n" +
+            "   mediump float b;\n" +
+            "   if (overlay.b * base.a + base.b * overlay.a >= overlay.a * base.a) {\n" +
+            "     b = overlay.a * base.a + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n" +
+            "   } else {\n" +
+            "     b = overlay.b + base.b;\n" +
+            "   }\n" +
+            "\n" +
+            "   mediump float a = overlay.a + base.a - overlay.a * base.a;\n" +
+            "   \n" +
+            "   gl_FragColor = vec4(r, g, b, a);\n" +
+            " }";
+
+    public GPUImageAddBlendFilter() {
+        super(ADD_BLEND_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageAlphaBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageAlphaBlendFilter.java
new file mode 100644
index 00000000..753c24d6
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageAlphaBlendFilter.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+/**
+ * Mix ranges from 0.0 (only image 1) to 1.0 (only image 2), with 0.5 (half of either) as the normal level
+ */
+public class GPUImageAlphaBlendFilter extends GPUImageMixBlendFilter{
+    public static final String ALPHA_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2;\n" +
+            "\n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " \n" +
+            " uniform lowp float mixturePercent;\n" +
+            "\n" +
+            " void main()\n" +
+            " {\n" +
+            "   lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "   lowp vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+            "\n" +
+            "   gl_FragColor = vec4(mix(textureColor.rgb, textureColor2.rgb, textureColor2.a * mixturePercent), textureColor.a);\n" +
+            " }";
+
+    public GPUImageAlphaBlendFilter() {
+        super(ALPHA_BLEND_FRAGMENT_SHADER);
+    }
+
+    public GPUImageAlphaBlendFilter(float mix) {
+        super(ALPHA_BLEND_FRAGMENT_SHADER, mix);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBoxBlurFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBoxBlurFilter.java
new file mode 100644
index 00000000..4e681b3c
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBoxBlurFilter.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+/**
+ * A hardware-accelerated 9-hit box blur of an image
+ *
+ * scaling: for the size of the applied blur, default of 1.0
+ */
+public class GPUImageBoxBlurFilter extends GPUImageTwoPassTextureSamplingFilter {
+    public static final String VERTEX_SHADER =
+            "attribute vec4 position;\n" +
+                    "attribute vec2 inputTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform float texelWidthOffset; \n" +
+                    "uniform float texelHeightOffset; \n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepLeftTextureCoordinate;\n" +
+                    "varying vec2 twoStepsLeftTextureCoordinate;\n" +
+                    "varying vec2 oneStepRightTextureCoordinate;\n" +
+                    "varying vec2 twoStepsRightTextureCoordinate;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "gl_Position = position;\n" +
+                    "\n" +
+                    "vec2 firstOffset = vec2(1.5 * texelWidthOffset, 1.5 * texelHeightOffset);\n" +
+                    "vec2 secondOffset = vec2(3.5 * texelWidthOffset, 3.5 * texelHeightOffset);\n" +
+                    "\n" +
+                    "centerTextureCoordinate = inputTextureCoordinate;\n" +
+                    "oneStepLeftTextureCoordinate = inputTextureCoordinate - firstOffset;\n" +
+                    "twoStepsLeftTextureCoordinate = inputTextureCoordinate - secondOffset;\n" +
+                    "oneStepRightTextureCoordinate = inputTextureCoordinate + firstOffset;\n" +
+                    "twoStepsRightTextureCoordinate = inputTextureCoordinate + secondOffset;\n" +
+                    "}\n";
+
+    public static final String FRAGMENT_SHADER =
+            "precision highp float;\n" +
+                    "\n" +
+                    "uniform sampler2D inputImageTexture;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepLeftTextureCoordinate;\n" +
+                    "varying vec2 twoStepsLeftTextureCoordinate;\n" +
+                    "varying vec2 oneStepRightTextureCoordinate;\n" +
+                    "varying vec2 twoStepsRightTextureCoordinate;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "lowp vec4 fragmentColor = texture2D(inputImageTexture, centerTextureCoordinate) * 0.2;\n" +
+                    "fragmentColor += texture2D(inputImageTexture, oneStepLeftTextureCoordinate) * 0.2;\n" +
+                    "fragmentColor += texture2D(inputImageTexture, oneStepRightTextureCoordinate) * 0.2;\n" +
+                    "fragmentColor += texture2D(inputImageTexture, twoStepsLeftTextureCoordinate) * 0.2;\n" +
+                    "fragmentColor += texture2D(inputImageTexture, twoStepsRightTextureCoordinate) * 0.2;\n" +
+                    "\n" +
+                    "gl_FragColor = fragmentColor;\n" +
+                    "}\n";
+
+    private float blurSize = 1f;
+
+    /**
+     * Construct new BoxBlurFilter with default blur size of 1.0.
+     */
+    public GPUImageBoxBlurFilter() {
+        this(1f);
+    }
+
+
+    public GPUImageBoxBlurFilter(float blurSize) {
+        super(VERTEX_SHADER, FRAGMENT_SHADER, VERTEX_SHADER, FRAGMENT_SHADER);
+        this.blurSize = blurSize;
+    }
+
+    /**
+     * A scaling for the size of the applied blur, default of 1.0
+     *
+     * @param blurSize
+     */
+    public void setBlurSize(float blurSize) {
+        this.blurSize = blurSize;
+        runOnDraw(new Runnable() {
+            @Override
+            public void run() {
+                initTexelOffsets();
+            }
+        });
+    }
+
+    @Override
+    public float getVerticalTexelOffsetRatio() {
+        return blurSize;
+    }
+
+    @Override
+    public float getHorizontalTexelOffsetRatio() {
+        return blurSize;
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBrightnessFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBrightnessFilter.java
index 64a7c1ff..e528ee87 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBrightnessFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBrightnessFilter.java
@@ -37,7 +37,6 @@
 
     private int mBrightnessLocation;
     private float mBrightness;
-    private boolean mIsInitialized = false;
 
     public GPUImageBrightnessFilter() {
         this(0.0f);
@@ -52,14 +51,16 @@ public GPUImageBrightnessFilter(final float brightness) {
     public void onInit() {
         super.onInit();
         mBrightnessLocation = GLES20.glGetUniformLocation(getProgram(), "brightness");
-        mIsInitialized = true;
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
         setBrightness(mBrightness);
     }
 
     public void setBrightness(final float brightness) {
         mBrightness = brightness;
-        if (mIsInitialized) {
-            setFloat(mBrightnessLocation, mBrightness);
-        }
+        setFloat(mBrightnessLocation, mBrightness);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBulgeDistortionFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBulgeDistortionFilter.java
new file mode 100644
index 00000000..af49bedd
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageBulgeDistortionFilter.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.graphics.PointF;
+import android.opengl.GLES20;
+
+public class GPUImageBulgeDistortionFilter extends GPUImageFilter {
+    public static final String BULGE_FRAGMENT_SHADER = "" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "uniform highp float aspectRatio;\n" +
+            "uniform highp vec2 center;\n" +
+            "uniform highp float radius;\n" +
+            "uniform highp float scale;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "highp vec2 textureCoordinateToUse = vec2(textureCoordinate.x, (textureCoordinate.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n" +
+            "highp float dist = distance(center, textureCoordinateToUse);\n" +
+            "textureCoordinateToUse = textureCoordinate;\n" +
+            "\n" +
+            "if (dist < radius)\n" +
+            "{\n" +
+            "textureCoordinateToUse -= center;\n" +
+            "highp float percent = 1.0 - ((radius - dist) / radius) * scale;\n" +
+            "percent = percent * percent;\n" +
+            "\n" +
+            "textureCoordinateToUse = textureCoordinateToUse * percent;\n" +
+            "textureCoordinateToUse += center;\n" +
+            "}\n" +
+            "\n" +
+            "gl_FragColor = texture2D(inputImageTexture, textureCoordinateToUse );    \n" +
+            "}\n";
+
+    private float mScale;
+    private int mScaleLocation;
+    private float mRadius;
+    private int mRadiusLocation;
+    private PointF mCenter;
+    private int mCenterLocation;
+    private float mAspectRatio;
+    private int mAspectRatioLocation;
+
+    public GPUImageBulgeDistortionFilter() {
+        this(0.25f, 0.5f, new PointF(0.5f, 0.5f));
+    }
+
+    public GPUImageBulgeDistortionFilter(float radius, float scale, PointF center) {
+        super(NO_FILTER_VERTEX_SHADER, BULGE_FRAGMENT_SHADER);
+        mRadius = radius;
+        mScale = scale;
+        mCenter = center;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mScaleLocation = GLES20.glGetUniformLocation(getProgram(), "scale");
+        mRadiusLocation = GLES20.glGetUniformLocation(getProgram(), "radius");
+        mCenterLocation = GLES20.glGetUniformLocation(getProgram(), "center");
+        mAspectRatioLocation = GLES20.glGetUniformLocation(getProgram(), "aspectRatio");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setRadius(mRadius);
+        setScale(mScale);
+        setCenter(mCenter);
+    }
+
+    @Override
+    public void onOutputSizeChanged(int width, int height) {
+        mAspectRatio = (float) height / width;
+        setAspectRatio(mAspectRatio);
+        super.onOutputSizeChanged(width, height);
+    }
+
+    private void setAspectRatio(float aspectRatio) {
+        mAspectRatio = aspectRatio;
+        setFloat(mAspectRatioLocation, aspectRatio);
+    }
+
+    /**
+     * The radius of the distortion, ranging from 0.0 to 1.0, with a default of 0.25
+     *
+     * @param radius from 0.0 to 1.0, default 0.25
+     */
+    public void setRadius(float radius) {
+        mRadius = radius;
+        setFloat(mRadiusLocation, radius);
+    }
+
+    /**
+     * The amount of distortion to apply, from -1.0 to 1.0, with a default of 0.5
+     *
+     * @param scale from -1.0 to 1.0, default 0.5
+     */
+    public void setScale(float scale) {
+        mScale = scale;
+        setFloat(mScaleLocation, scale);
+    }
+
+    /**
+     * The center about which to apply the distortion, with a default of (0.5, 0.5)
+     *
+     * @param center default (0.5, 0.5)
+     */
+    public void setCenter(PointF center) {
+        mCenter = center;
+        setPoint(mCenterLocation, center);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCGAColorspaceFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCGAColorspaceFilter.java
new file mode 100644
index 00000000..52585956
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCGAColorspaceFilter.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageCGAColorspaceFilter extends GPUImageFilter {
+    public static final String CGACOLORSPACE_FRAGMENT_SHADER = "" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "highp vec2 sampleDivisor = vec2(1.0 / 200.0, 1.0 / 320.0);\n" +
+            "//highp vec4 colorDivisor = vec4(colorDepth);\n" +
+            "\n" +
+            "highp vec2 samplePos = textureCoordinate - mod(textureCoordinate, sampleDivisor);\n" +
+            "highp vec4 color = texture2D(inputImageTexture, samplePos );\n" +
+            "\n" +
+            "//gl_FragColor = texture2D(inputImageTexture, samplePos );\n" +
+            "mediump vec4 colorCyan = vec4(85.0 / 255.0, 1.0, 1.0, 1.0);\n" +
+            "mediump vec4 colorMagenta = vec4(1.0, 85.0 / 255.0, 1.0, 1.0);\n" +
+            "mediump vec4 colorWhite = vec4(1.0, 1.0, 1.0, 1.0);\n" +
+            "mediump vec4 colorBlack = vec4(0.0, 0.0, 0.0, 1.0);\n" +
+            "\n" +
+            "mediump vec4 endColor;\n" +
+            "highp float blackDistance = distance(color, colorBlack);\n" +
+            "highp float whiteDistance = distance(color, colorWhite);\n" +
+            "highp float magentaDistance = distance(color, colorMagenta);\n" +
+            "highp float cyanDistance = distance(color, colorCyan);\n" +
+            "\n" +
+            "mediump vec4 finalColor;\n" +
+            "\n" +
+            "highp float colorDistance = min(magentaDistance, cyanDistance);\n" +
+            "colorDistance = min(colorDistance, whiteDistance);\n" +
+            "colorDistance = min(colorDistance, blackDistance); \n" +
+            "\n" +
+            "if (colorDistance == blackDistance) {\n" +
+            "finalColor = colorBlack;\n" +
+            "} else if (colorDistance == whiteDistance) {\n" +
+            "finalColor = colorWhite;\n" +
+            "} else if (colorDistance == cyanDistance) {\n" +
+            "finalColor = colorCyan;\n" +
+            "} else {\n" +
+            "finalColor = colorMagenta;\n" +
+            "}\n" +
+            "\n" +
+            "gl_FragColor = finalColor;\n" +
+            "}\n";
+
+    public GPUImageCGAColorspaceFilter() {
+        super(NO_FILTER_VERTEX_SHADER, CGACOLORSPACE_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageChromaKeyBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageChromaKeyBlendFilter.java
new file mode 100644
index 00000000..c5adf8f4
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageChromaKeyBlendFilter.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+/**
+ * Selectively replaces a color in the first image with the second image
+ */
+public class GPUImageChromaKeyBlendFilter extends GPUImageTwoInputFilter {
+    public static final String CHROMA_KEY_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " \n" +
+            " highp float lum(lowp vec3 c) {\n" +
+            "     return dot(c, vec3(0.3, 0.59, 0.11));\n" +
+            " }\n" +
+            " \n" +
+            " lowp vec3 clipcolor(lowp vec3 c) {\n" +
+            "     highp float l = lum(c);\n" +
+            "     lowp float n = min(min(c.r, c.g), c.b);\n" +
+            "     lowp float x = max(max(c.r, c.g), c.b);\n" +
+            "     \n" +
+            "     if (n < 0.0) {\n" +
+            "         c.r = l + ((c.r - l) * l) / (l - n);\n" +
+            "         c.g = l + ((c.g - l) * l) / (l - n);\n" +
+            "         c.b = l + ((c.b - l) * l) / (l - n);\n" +
+            "     }\n" +
+            "     if (x > 1.0) {\n" +
+            "         c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n" +
+            "         c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n" +
+            "         c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n" +
+            "     }\n" +
+            "     \n" +
+            "     return c;\n" +
+            " }\n" +
+            "\n" +
+            " lowp vec3 setlum(lowp vec3 c, highp float l) {\n" +
+            "     highp float d = l - lum(c);\n" +
+            "     c = c + vec3(d);\n" +
+            "     return clipcolor(c);\n" +
+            " }\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "   highp vec4 baseColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "   highp vec4 overlayColor = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+            "\n" +
+            "     gl_FragColor = vec4(baseColor.rgb * (1.0 - overlayColor.a) + setlum(overlayColor.rgb, lum(baseColor.rgb)) * overlayColor.a, baseColor.a);\n" +
+            " }";
+
+    private int mThresholdSensitivityLocation;
+    private int mSmoothingLocation;
+    private int mColorToReplaceLocation;
+    private float mSmoothing = 0.1f;
+    private float mThresholdSensitivity = 0.3f;
+    private float[] mColorToReplace = new float[]{0.0f, 1.0f, 0.0f};
+
+    public GPUImageChromaKeyBlendFilter() {
+        super(CHROMA_KEY_BLEND_FRAGMENT_SHADER);
+
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mThresholdSensitivityLocation = GLES20.glGetUniformLocation(getProgram(), "thresholdSensitivity");
+        mSmoothingLocation = GLES20.glGetUniformLocation(getProgram(), "smoothing");
+        mColorToReplaceLocation = GLES20.glGetUniformLocation(getProgram(), "colorToReplace");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setSmoothing(mSmoothing);
+        setThresholdSensitivity(mThresholdSensitivity);
+        setColorToReplace(mColorToReplace[0], mColorToReplace[1], mColorToReplace[2]);
+    }
+
+    /**
+     * The degree of smoothing controls how gradually similar colors are replaced in the image
+     * The default value is 0.1
+     */
+    public void setSmoothing(final float smoothing) {
+        mSmoothing = smoothing;
+        setFloat(mSmoothingLocation, mSmoothing);
+    }
+
+    /**
+     * The threshold sensitivity controls how similar pixels need to be colored to be replaced
+     * The default value is 0.3
+     */
+    public void setThresholdSensitivity(final float thresholdSensitivity) {
+        mThresholdSensitivity = thresholdSensitivity;
+        setFloat(mThresholdSensitivityLocation, mThresholdSensitivity);
+    }
+
+    /** The color to be replaced is specified using individual red, green, and blue components (normalized to 1.0).
+     * The default is green: (0.0, 1.0, 0.0).
+     *
+     * @param redComponent Red component of color to be replaced
+     * @param greenComponent Green component of color to be replaced
+     * @param blueComponent Blue component of color to be replaced
+     */
+    public void setColorToReplace(float redComponent, float greenComponent, float blueComponent) {
+        mColorToReplace = new float[]{redComponent, greenComponent, blueComponent};
+        setFloatVec3(mColorToReplaceLocation, mColorToReplace);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBlendFilter.java
new file mode 100644
index 00000000..0f5de140
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBlendFilter.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageColorBlendFilter extends GPUImageTwoInputFilter {
+    public static final String COLOR_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " \n" +
+            " highp float lum(lowp vec3 c) {\n" +
+            "     return dot(c, vec3(0.3, 0.59, 0.11));\n" +
+            " }\n" +
+            " \n" +
+            " lowp vec3 clipcolor(lowp vec3 c) {\n" +
+            "     highp float l = lum(c);\n" +
+            "     lowp float n = min(min(c.r, c.g), c.b);\n" +
+            "     lowp float x = max(max(c.r, c.g), c.b);\n" +
+            "     \n" +
+            "     if (n < 0.0) {\n" +
+            "         c.r = l + ((c.r - l) * l) / (l - n);\n" +
+            "         c.g = l + ((c.g - l) * l) / (l - n);\n" +
+            "         c.b = l + ((c.b - l) * l) / (l - n);\n" +
+            "     }\n" +
+            "     if (x > 1.0) {\n" +
+            "         c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n" +
+            "         c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n" +
+            "         c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n" +
+            "     }\n" +
+            "     \n" +
+            "     return c;\n" +
+            " }\n" +
+            "\n" +
+            " lowp vec3 setlum(lowp vec3 c, highp float l) {\n" +
+            "     highp float d = l - lum(c);\n" +
+            "     c = c + vec3(d);\n" +
+            "     return clipcolor(c);\n" +
+            " }\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "   highp vec4 baseColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "   highp vec4 overlayColor = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+            "\n" +
+            "     gl_FragColor = vec4(baseColor.rgb * (1.0 - overlayColor.a) + setlum(overlayColor.rgb, lum(baseColor.rgb)) * overlayColor.a, baseColor.a);\n" +
+            " }";
+
+    public GPUImageColorBlendFilter() {
+        super(COLOR_BLEND_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBurnBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBurnBlendFilter.java
new file mode 100644
index 00000000..e3b5c42a
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorBurnBlendFilter.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageColorBurnBlendFilter extends GPUImageTwoInputFilter {
+    public static final String COLOR_BURN_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2;\n" +
+            "\n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "    mediump vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "    mediump vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+            "    mediump vec4 whiteColor = vec4(1.0);\n" +
+            "    gl_FragColor = whiteColor - (whiteColor - textureColor) / textureColor2;\n" +
+            " }";
+
+    public GPUImageColorBurnBlendFilter() {
+        super(COLOR_BURN_BLEND_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorDodgeBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorDodgeBlendFilter.java
new file mode 100644
index 00000000..702a3a98
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorDodgeBlendFilter.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageColorDodgeBlendFilter extends GPUImageTwoInputFilter {
+    public static final String COLOR_DODGE_BLEND_FRAGMENT_SHADER = "precision mediump float;\n" +
+            " \n" +
+            " varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "     vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+            "     \n" +
+            "     vec3 baseOverlayAlphaProduct = vec3(overlay.a * base.a);\n" +
+            "     vec3 rightHandProduct = overlay.rgb * (1.0 - base.a) + base.rgb * (1.0 - overlay.a);\n" +
+            "     \n" +
+            "     vec3 firstBlendColor = baseOverlayAlphaProduct + rightHandProduct;\n" +
+            "     vec3 overlayRGB = clamp((overlay.rgb / clamp(overlay.a, 0.01, 1.0)) * step(0.0, overlay.a), 0.0, 0.99);\n" +
+            "     \n" +
+            "     vec3 secondBlendColor = (base.rgb * overlay.a) / (1.0 - overlayRGB) + rightHandProduct;\n" +
+            "     \n" +
+            "     vec3 colorChoice = step((overlay.rgb * base.a + base.rgb * overlay.a), baseOverlayAlphaProduct);\n" +
+            "     \n" +
+            "     gl_FragColor = vec4(mix(firstBlendColor, secondBlendColor, colorChoice), 1.0);\n" +
+            " }";
+
+    public GPUImageColorDodgeBlendFilter() {
+        super(COLOR_DODGE_BLEND_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorInvertFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorInvertFilter.java
new file mode 100644
index 00000000..2d8df9b9
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorInvertFilter.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+/**
+ * Invert all the colors in the image.
+ */
+public class GPUImageColorInvertFilter extends GPUImageFilter {
+    public static final String COLOR_INVERT_FRAGMENT_SHADER = "" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "    lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "    \n" +
+            "    gl_FragColor = vec4((1.0 - textureColor.rgb), textureColor.w);\n" +
+            "}";
+
+    public GPUImageColorInvertFilter() {
+        super(NO_FILTER_VERTEX_SHADER, COLOR_INVERT_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorMatrixFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorMatrixFilter.java
index 08b8f919..59203c4d 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorMatrixFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageColorMatrixFilter.java
@@ -42,7 +42,6 @@
     private float[] mColorMatrix;
     private int mColorMatrixLocation;
     private int mIntensityLocation;
-    private boolean mIsInitialized = false;
 
     public GPUImageColorMatrixFilter() {
         this(1.0f, new float[] {
@@ -64,22 +63,22 @@ public void onInit() {
         super.onInit();
         mColorMatrixLocation = GLES20.glGetUniformLocation(getProgram(), "colorMatrix");
         mIntensityLocation = GLES20.glGetUniformLocation(getProgram(), "intensity");
-        mIsInitialized = true;
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
         setIntensity(mIntensity);
         setColorMatrix(mColorMatrix);
     }
 
     public void setIntensity(final float intensity) {
         mIntensity = intensity;
-        if (mIsInitialized) {
-            setFloat(mIntensityLocation, intensity);
-        }
+        setFloat(mIntensityLocation, intensity);
     }
 
     public void setColorMatrix(final float[] colorMatrix) {
         mColorMatrix = colorMatrix;
-        if (mIsInitialized) {
-            setUniformMatrix4f(mColorMatrixLocation, colorMatrix);
-        }
+        setUniformMatrix4f(mColorMatrixLocation, colorMatrix);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageContrastFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageContrastFilter.java
index 3a7ff9e2..76f4aa8e 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageContrastFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageContrastFilter.java
@@ -39,7 +39,6 @@
 
     private int mContrastLocation;
     private float mContrast;
-    private boolean mIsInitialized = false;
 
     public GPUImageContrastFilter() {
         this(1.2f);
@@ -54,14 +53,16 @@ public GPUImageContrastFilter(float contrast) {
     public void onInit() {
         super.onInit();
         mContrastLocation = GLES20.glGetUniformLocation(getProgram(), "contrast");
-        mIsInitialized = true;
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
         setContrast(mContrast);
     }
 
     public void setContrast(final float contrast) {
         mContrast = contrast;
-        if (mIsInitialized) {
-            setFloat(mContrastLocation, mContrast);
-        }
+        setFloat(mContrastLocation, mContrast);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCrosshatchFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCrosshatchFilter.java
new file mode 100644
index 00000000..04a3d4c7
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageCrosshatchFilter.java
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+/**
+ * crossHatchSpacing: The fractional width of the image to use as the spacing for the crosshatch. The default is 0.03.
+ * lineWidth: A relative width for the crosshatch lines. The default is 0.003.
+ */
+public class GPUImageCrosshatchFilter extends GPUImageFilter {
+    public static final String CROSSHATCH_FRAGMENT_SHADER = "" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "uniform highp float crossHatchSpacing;\n" +
+            "uniform highp float lineWidth;\n" +
+            "const highp vec3 W = vec3(0.2125, 0.7154, 0.0721);\n" +
+            "void main()\n" +
+            "{\n" +
+            "highp float luminance = dot(texture2D(inputImageTexture, textureCoordinate).rgb, W);\n" +
+            "lowp vec4 colorToDisplay = vec4(1.0, 1.0, 1.0, 1.0);\n" +
+            "if (luminance < 1.00)\n" +
+            "{\n" +
+            "if (mod(textureCoordinate.x + textureCoordinate.y, crossHatchSpacing) <= lineWidth)\n" +
+            "{\n" +
+            "colorToDisplay = vec4(0.0, 0.0, 0.0, 1.0);\n" +
+            "}\n" +
+            "}\n" +
+            "if (luminance < 0.75)\n" +
+            "{\n" +
+            "if (mod(textureCoordinate.x - textureCoordinate.y, crossHatchSpacing) <= lineWidth)\n" +
+            "{\n" +
+            "colorToDisplay = vec4(0.0, 0.0, 0.0, 1.0);\n" +
+            "}\n" +
+            "}\n" +
+            "if (luminance < 0.50)\n" +
+            "{\n" +
+            "if (mod(textureCoordinate.x + textureCoordinate.y - (crossHatchSpacing / 2.0), crossHatchSpacing) <= lineWidth)\n" +
+            "{\n" +
+            "colorToDisplay = vec4(0.0, 0.0, 0.0, 1.0);\n" +
+            "}\n" +
+            "}\n" +
+            "if (luminance < 0.3)\n" +
+            "{\n" +
+            "if (mod(textureCoordinate.x - textureCoordinate.y - (crossHatchSpacing / 2.0), crossHatchSpacing) <= lineWidth)\n" +
+            "{\n" +
+            "colorToDisplay = vec4(0.0, 0.0, 0.0, 1.0);\n" +
+            "}\n" +
+            "}\n" +
+            "gl_FragColor = colorToDisplay;\n" +
+            "}\n";
+
+    private float mCrossHatchSpacing;
+    private int mCrossHatchSpacingLocation;
+    private float mLineWidth;
+    private int mLineWidthLocation;
+
+    /**
+     * Using default values of crossHatchSpacing: 0.03f and lineWidth: 0.003f.
+     */
+    public GPUImageCrosshatchFilter() {
+        this(0.03f, 0.003f);
+    }
+
+    public GPUImageCrosshatchFilter(float crossHatchSpacing, float lineWidth) {
+        super(NO_FILTER_VERTEX_SHADER, CROSSHATCH_FRAGMENT_SHADER);
+        mCrossHatchSpacing = crossHatchSpacing;
+        mLineWidth = lineWidth;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mCrossHatchSpacingLocation = GLES20.glGetUniformLocation(getProgram(), "crossHatchSpacing");
+        mLineWidthLocation = GLES20.glGetUniformLocation(getProgram(), "lineWidth");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setCrossHatchSpacing(mCrossHatchSpacing);
+        setLineWidth(mLineWidth);
+    }
+
+    /**
+     * The fractional width of the image to use as the spacing for the crosshatch. The default is 0.03.
+     *
+     * @param crossHatchSpacing default 0.03
+     */
+    public void setCrossHatchSpacing(final float crossHatchSpacing) {
+        float singlePixelSpacing;
+        if (getOutputWidth() != 0) {
+            singlePixelSpacing = 1.0f / (float) getOutputWidth();
+        } else {
+            singlePixelSpacing = 1.0f / 2048.0f;
+        }
+
+        if (crossHatchSpacing < singlePixelSpacing) {
+            mCrossHatchSpacing = singlePixelSpacing;
+        } else {
+            mCrossHatchSpacing = crossHatchSpacing;
+        }
+
+        setFloat(mCrossHatchSpacingLocation, mCrossHatchSpacing);
+    }
+
+    /**
+     * A relative width for the crosshatch lines. The default is 0.003.
+     *
+     * @param lineWidth default 0.003
+     */
+    public void setLineWidth(final float lineWidth) {
+        mLineWidth = lineWidth;
+        setFloat(mLineWidthLocation, mLineWidth);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDarkenBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDarkenBlendFilter.java
new file mode 100644
index 00000000..385e8e3a
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDarkenBlendFilter.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageDarkenBlendFilter extends GPUImageTwoInputFilter {
+    public static final String DARKEN_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2;\n" +
+            "\n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "    lowp vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "    lowp vec4 overlayer = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+            "    \n" +
+            "    gl_FragColor = vec4(min(overlayer.rgb * base.a, base.rgb * overlayer.a) + overlayer.rgb * (1.0 - base.a) + base.rgb * (1.0 - overlayer.a), 1.0);\n" +
+            " }";
+
+    public GPUImageDarkenBlendFilter() {
+        super(DARKEN_BLEND_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDifferenceBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDifferenceBlendFilter.java
new file mode 100644
index 00000000..1a32cd0c
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDifferenceBlendFilter.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageDifferenceBlendFilter extends GPUImageTwoInputFilter {
+    public static final String DIFFERENCE_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2;\n" +
+            "\n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     mediump vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "     mediump vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+            "     gl_FragColor = vec4(abs(textureColor2.rgb - textureColor.rgb), textureColor.a);\n" +
+            " }";
+
+    public GPUImageDifferenceBlendFilter() {
+        super(DIFFERENCE_BLEND_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDilationFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDilationFilter.java
new file mode 100644
index 00000000..f6ce4e2f
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDilationFilter.java
@@ -0,0 +1,305 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+/**
+ * For each pixel, this sets it to the maximum value of the red channel in a rectangular neighborhood extending
+ * out dilationRadius pixels from the center.
+ * This extends out bright features, and is most commonly used with black-and-white thresholded images.
+ */
+public class GPUImageDilationFilter extends GPUImageTwoPassTextureSamplingFilter {
+    public static final String VERTEX_SHADER_1 =
+            "attribute vec4 position;\n" +
+                    "attribute vec2 inputTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform float texelWidthOffset; \n" +
+                    "uniform float texelHeightOffset; \n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "gl_Position = position;\n" +
+                    "\n" +
+                    "vec2 offset = vec2(texelWidthOffset, texelHeightOffset);\n" +
+                    "\n" +
+                    "centerTextureCoordinate = inputTextureCoordinate;\n" +
+                    "oneStepNegativeTextureCoordinate = inputTextureCoordinate - offset;\n" +
+                    "oneStepPositiveTextureCoordinate = inputTextureCoordinate + offset;\n" +
+                    "}\n";
+
+    public static final String VERTEX_SHADER_2 =
+            "attribute vec4 position;\n" +
+                    "attribute vec2 inputTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform float texelWidthOffset;\n" +
+                    "uniform float texelHeightOffset;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "varying vec2 twoStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 twoStepsNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "gl_Position = position;\n" +
+                    "\n" +
+                    "vec2 offset = vec2(texelWidthOffset, texelHeightOffset);\n" +
+                    "\n" +
+                    "centerTextureCoordinate = inputTextureCoordinate;\n" +
+                    "oneStepNegativeTextureCoordinate = inputTextureCoordinate - offset;\n" +
+                    "oneStepPositiveTextureCoordinate = inputTextureCoordinate + offset;\n" +
+                    "twoStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 2.0);\n" +
+                    "twoStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 2.0);\n" +
+                    "}\n";
+
+    public static final String VERTEX_SHADER_3 =
+            "attribute vec4 position;\n" +
+                    "attribute vec2 inputTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform float texelWidthOffset;\n" +
+                    "uniform float texelHeightOffset;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "varying vec2 twoStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 twoStepsNegativeTextureCoordinate;\n" +
+                    "varying vec2 threeStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 threeStepsNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "gl_Position = position;\n" +
+                    "\n" +
+                    "vec2 offset = vec2(texelWidthOffset, texelHeightOffset);\n" +
+                    "\n" +
+                    "centerTextureCoordinate = inputTextureCoordinate;\n" +
+                    "oneStepNegativeTextureCoordinate = inputTextureCoordinate - offset;\n" +
+                    "oneStepPositiveTextureCoordinate = inputTextureCoordinate + offset;\n" +
+                    "twoStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 2.0);\n" +
+                    "twoStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 2.0);\n" +
+                    "threeStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 3.0);\n" +
+                    "threeStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 3.0);\n" +
+                    "}\n";
+
+    public static final String VERTEX_SHADER_4 =
+
+            "attribute vec4 position;\n" +
+                    "attribute vec2 inputTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform float texelWidthOffset;\n" +
+                    "uniform float texelHeightOffset;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "varying vec2 twoStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 twoStepsNegativeTextureCoordinate;\n" +
+                    "varying vec2 threeStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 threeStepsNegativeTextureCoordinate;\n" +
+                    "varying vec2 fourStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 fourStepsNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "gl_Position = position;\n" +
+                    "\n" +
+                    "vec2 offset = vec2(texelWidthOffset, texelHeightOffset);\n" +
+                    "\n" +
+                    "centerTextureCoordinate = inputTextureCoordinate;\n" +
+                    "oneStepNegativeTextureCoordinate = inputTextureCoordinate - offset;\n" +
+                    "oneStepPositiveTextureCoordinate = inputTextureCoordinate + offset;\n" +
+                    "twoStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 2.0);\n" +
+                    "twoStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 2.0);\n" +
+                    "threeStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 3.0);\n" +
+                    "threeStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 3.0);\n" +
+                    "fourStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 4.0);\n" +
+                    "fourStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 4.0);\n" +
+                    "}\n";
+
+
+    public static final String FRAGMENT_SHADER_1 =
+            "precision lowp float;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform sampler2D inputImageTexture;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "float centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate).r;\n" +
+                    "float oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate).r;\n" +
+                    "float oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate).r;\n" +
+                    "\n" +
+                    "lowp float maxValue = max(centerIntensity, oneStepPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, oneStepNegativeIntensity);\n" +
+                    "\n" +
+                    "gl_FragColor = vec4(vec3(maxValue), 1.0);\n" +
+                    "}\n";
+
+    public static final String FRAGMENT_SHADER_2 =
+            "precision lowp float;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "varying vec2 twoStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 twoStepsNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform sampler2D inputImageTexture;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "float centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate).r;\n" +
+                    "float oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate).r;\n" +
+                    "float oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate).r;\n" +
+                    "float twoStepsPositiveIntensity = texture2D(inputImageTexture, twoStepsPositiveTextureCoordinate).r;\n" +
+                    "float twoStepsNegativeIntensity = texture2D(inputImageTexture, twoStepsNegativeTextureCoordinate).r;\n" +
+                    "\n" +
+                    "lowp float maxValue = max(centerIntensity, oneStepPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, oneStepNegativeIntensity);\n" +
+                    "maxValue = max(maxValue, twoStepsPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, twoStepsNegativeIntensity);\n" +
+                    "\n" +
+                    "gl_FragColor = vec4(vec3(maxValue), 1.0);\n" +
+                    "}\n";
+
+    public static final String FRAGMENT_SHADER_3 =
+            "precision lowp float;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "varying vec2 twoStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 twoStepsNegativeTextureCoordinate;\n" +
+                    "varying vec2 threeStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 threeStepsNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform sampler2D inputImageTexture;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "float centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate).r;\n" +
+                    "float oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate).r;\n" +
+                    "float oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate).r;\n" +
+                    "float twoStepsPositiveIntensity = texture2D(inputImageTexture, twoStepsPositiveTextureCoordinate).r;\n" +
+                    "float twoStepsNegativeIntensity = texture2D(inputImageTexture, twoStepsNegativeTextureCoordinate).r;\n" +
+                    "float threeStepsPositiveIntensity = texture2D(inputImageTexture, threeStepsPositiveTextureCoordinate).r;\n" +
+                    "float threeStepsNegativeIntensity = texture2D(inputImageTexture, threeStepsNegativeTextureCoordinate).r;\n" +
+                    "\n" +
+                    "lowp float maxValue = max(centerIntensity, oneStepPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, oneStepNegativeIntensity);\n" +
+                    "maxValue = max(maxValue, twoStepsPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, twoStepsNegativeIntensity);\n" +
+                    "maxValue = max(maxValue, threeStepsPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, threeStepsNegativeIntensity);\n" +
+                    "\n" +
+                    "gl_FragColor = vec4(vec3(maxValue), 1.0);\n" +
+                    "}\n";
+
+    public static final String FRAGMENT_SHADER_4 =
+            "precision lowp float;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "varying vec2 twoStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 twoStepsNegativeTextureCoordinate;\n" +
+                    "varying vec2 threeStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 threeStepsNegativeTextureCoordinate;\n" +
+                    "varying vec2 fourStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 fourStepsNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform sampler2D inputImageTexture;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "float centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate).r;\n" +
+                    "float oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate).r;\n" +
+                    "float oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate).r;\n" +
+                    "float twoStepsPositiveIntensity = texture2D(inputImageTexture, twoStepsPositiveTextureCoordinate).r;\n" +
+                    "float twoStepsNegativeIntensity = texture2D(inputImageTexture, twoStepsNegativeTextureCoordinate).r;\n" +
+                    "float threeStepsPositiveIntensity = texture2D(inputImageTexture, threeStepsPositiveTextureCoordinate).r;\n" +
+                    "float threeStepsNegativeIntensity = texture2D(inputImageTexture, threeStepsNegativeTextureCoordinate).r;\n" +
+                    "float fourStepsPositiveIntensity = texture2D(inputImageTexture, fourStepsPositiveTextureCoordinate).r;\n" +
+                    "float fourStepsNegativeIntensity = texture2D(inputImageTexture, fourStepsNegativeTextureCoordinate).r;\n" +
+                    "\n" +
+                    "lowp float maxValue = max(centerIntensity, oneStepPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, oneStepNegativeIntensity);\n" +
+                    "maxValue = max(maxValue, twoStepsPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, twoStepsNegativeIntensity);\n" +
+                    "maxValue = max(maxValue, threeStepsPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, threeStepsNegativeIntensity);\n" +
+                    "maxValue = max(maxValue, fourStepsPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, fourStepsNegativeIntensity);\n" +
+                    "\n" +
+                    "gl_FragColor = vec4(vec3(maxValue), 1.0);\n" +
+                    "}\n";
+
+
+    public GPUImageDilationFilter() {
+        this(1);
+    }
+
+    /**
+     * Acceptable values for dilationRadius, which sets the distance in pixels to sample out from the center,
+     * are 1, 2, 3, and 4.
+     *
+     * @param radius 1, 2, 3 or 4
+     */
+    public GPUImageDilationFilter(int radius) {
+        this(getVertexShader(radius), getFragmentShader(radius));
+    }
+
+    private GPUImageDilationFilter(String vertexShader, String fragmentShader) {
+        super(vertexShader, fragmentShader, vertexShader, fragmentShader);
+    }
+
+    private static String getVertexShader(int radius) {
+        switch (radius) {
+            case 0:
+            case 1:
+                return VERTEX_SHADER_1;
+            case 2:
+                return VERTEX_SHADER_2;
+            case 3:
+                return VERTEX_SHADER_3;
+            default:
+                return VERTEX_SHADER_4;
+        }
+    }
+
+    private static String getFragmentShader(int radius) {
+        switch (radius) {
+            case 0:
+            case 1:
+                return FRAGMENT_SHADER_1;
+            case 2:
+                return FRAGMENT_SHADER_2;
+            case 3:
+                return FRAGMENT_SHADER_3;
+            default:
+                return FRAGMENT_SHADER_4;
+        }
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDissolveBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDissolveBlendFilter.java
new file mode 100644
index 00000000..cd2880a6
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDissolveBlendFilter.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+/**
+ * Mix ranges from 0.0 (only image 1) to 1.0 (only image 2), with 0.5 (half of either) as the normal level
+ */
+public class GPUImageDissolveBlendFilter extends GPUImageMixBlendFilter{
+    public static final String DISSOLVE_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2;\n" +
+            "\n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " uniform lowp float mixturePercent;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "    lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "    lowp vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+            "    \n" +
+            "    gl_FragColor = mix(textureColor, textureColor2, mixturePercent);\n" +
+            " }";
+
+    public GPUImageDissolveBlendFilter() {
+        super(DISSOLVE_BLEND_FRAGMENT_SHADER);
+    }
+
+    public GPUImageDissolveBlendFilter(float mix) {
+        super(DISSOLVE_BLEND_FRAGMENT_SHADER, mix);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDivideBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDivideBlendFilter.java
new file mode 100644
index 00000000..179cd4ee
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageDivideBlendFilter.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageDivideBlendFilter extends GPUImageTwoInputFilter {
+    public static final String DIVIDE_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2;\n" +
+            "\n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "   mediump vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "   mediump vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+            "   \n" +
+            "   mediump float ra;\n" +
+            "   if (overlay.a == 0.0 || ((base.r / overlay.r) > (base.a / overlay.a)))\n" +
+            "     ra = overlay.a * base.a + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n" +
+            "   else\n" +
+            "     ra = (base.r * overlay.a * overlay.a) / overlay.r + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n" +
+            "   \n" +
+            "\n" +
+            "   mediump float ga;\n" +
+            "   if (overlay.a == 0.0 || ((base.g / overlay.g) > (base.a / overlay.a)))\n" +
+            "     ga = overlay.a * base.a + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n" +
+            "   else\n" +
+            "     ga = (base.g * overlay.a * overlay.a) / overlay.g + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n" +
+            "\n" +
+            "   \n" +
+            "   mediump float ba;\n" +
+            "   if (overlay.a == 0.0 || ((base.b / overlay.b) > (base.a / overlay.a)))\n" +
+            "     ba = overlay.a * base.a + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n" +
+            "   else\n" +
+            "     ba = (base.b * overlay.a * overlay.a) / overlay.b + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n" +
+            "\n" +
+            "   mediump float a = overlay.a + base.a - overlay.a * base.a;\n" +
+            "   \n" +
+            "   gl_FragColor = vec4(ra, ga, ba, a);\n" +
+            " }";
+
+    public GPUImageDivideBlendFilter() {
+        super(DIVIDE_BLEND_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageExclusionBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageExclusionBlendFilter.java
new file mode 100644
index 00000000..dcfc9346
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageExclusionBlendFilter.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageExclusionBlendFilter extends GPUImageTwoInputFilter {
+    public static final String EXCLUSION_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2;\n" +
+            "\n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     mediump vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "     mediump vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+            "     \n" +
+            "     //     Dca = (Sca.Da + Dca.Sa - 2.Sca.Dca) + Sca.(1 - Da) + Dca.(1 - Sa)\n" +
+            "     \n" +
+            "     gl_FragColor = vec4((overlay.rgb * base.a + base.rgb * overlay.a - 2.0 * overlay.rgb * base.rgb) + overlay.rgb * (1.0 - base.a) + base.rgb * (1.0 - overlay.a), base.a);\n" +
+            " }";
+
+    public GPUImageExclusionBlendFilter() {
+        super(EXCLUSION_BLEND_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageExposureFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageExposureFilter.java
new file mode 100644
index 00000000..de5de414
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageExposureFilter.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+/**
+ * exposure: The adjusted exposure (-10.0 - 10.0, with 0.0 as the default)
+ */
+public class GPUImageExposureFilter extends GPUImageFilter {
+    public static final String EXPOSURE_FRAGMENT_SHADER = "" +
+            " varying highp vec2 textureCoordinate;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform highp float exposure;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     highp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "     \n" +
+            "     gl_FragColor = vec4(textureColor.rgb * pow(2.0, exposure), textureColor.w);\n" +
+            " } ";
+
+    private int mExposureLocation;
+    private float mExposure;
+
+    public GPUImageExposureFilter() {
+        this(1.0f);
+    }
+
+    public GPUImageExposureFilter(final float exposure) {
+        super(NO_FILTER_VERTEX_SHADER, EXPOSURE_FRAGMENT_SHADER);
+        mExposure = exposure;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mExposureLocation = GLES20.glGetUniformLocation(getProgram(), "exposure");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setExposure(mExposure);
+    }
+
+    public void setExposure(final float exposure) {
+        mExposure = exposure;
+        setFloat(mExposureLocation, mExposure);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFalseColorFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFalseColorFilter.java
new file mode 100644
index 00000000..c815ad0f
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFalseColorFilter.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+public class GPUImageFalseColorFilter extends GPUImageFilter {
+    public static final String FALSECOLOR_FRAGMENT_SHADER = "" +
+            "precision lowp float;\n" +
+            "\n" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "uniform float intensity;\n" +
+            "uniform vec3 firstColor;\n" +
+            "uniform vec3 secondColor;\n" +
+            "\n" +
+            "const mediump vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "float luminance = dot(textureColor.rgb, luminanceWeighting);\n" +
+            "\n" +
+            "gl_FragColor = vec4( mix(firstColor.rgb, secondColor.rgb, luminance), textureColor.a);\n" +
+            "}\n";
+
+    private float[] mFirstColor;
+    private int mFirstColorLocation;
+    private float[] mSecondColor;
+    private int mSecondColorLocation;
+
+    public GPUImageFalseColorFilter() {
+        this(0f, 0f, 0.5f, 1f, 0f, 0f);
+    }
+
+    public GPUImageFalseColorFilter(float firstRed, float firstGreen, float firstBlue, float secondRed, float secondGreen, float secondBlue) {
+        this(new float[]{firstRed, firstGreen, firstBlue}, new float[]{secondRed, secondGreen, secondBlue});
+    }
+
+    public GPUImageFalseColorFilter(float[] firstColor, float[] secondColor) {
+        super(NO_FILTER_VERTEX_SHADER, FALSECOLOR_FRAGMENT_SHADER);
+        mFirstColor = firstColor;
+        mSecondColor = secondColor;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mFirstColorLocation = GLES20.glGetUniformLocation(getProgram(), "firstColor");
+        mSecondColorLocation = GLES20.glGetUniformLocation(getProgram(), "secondColor");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setFirstColor(mFirstColor);
+        setSecondColor(mSecondColor);
+    }
+
+    public void setFirstColor(final float[] firstColor) {
+        mFirstColor = firstColor;
+        setFloatVec3(mFirstColorLocation, firstColor);
+    }
+
+    public void setSecondColor(final float[] secondColor) {
+        mSecondColor = secondColor;
+        setFloatVec3(mSecondColorLocation, secondColor);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilter.java
index c8f7958a..7a8641aa 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilter.java
@@ -16,11 +16,15 @@
 
 package jp.co.cyberagent.android.gpuimage;
 
+import android.content.Context;
+import android.content.res.AssetManager;
+import android.graphics.PointF;
+import android.opengl.GLES20;
+
+import java.io.InputStream;
 import java.nio.FloatBuffer;
 import java.util.LinkedList;
 
-import android.opengl.GLES20;
-
 public class GPUImageFilter {
     public static final String NO_FILTER_VERTEX_SHADER = "" +
             "attribute vec4 position;\n" +
@@ -46,12 +50,12 @@
     private final LinkedList<Runnable> mRunOnDraw;
     private final String mVertexShader;
     private final String mFragmentShader;
-    private int mGLProgId;
-    private int mGLAttribPosition;
-    private int mGLUniformTexture;
-    private int mGLAttribTextureCoordinate;
-    private int mOutputWidth;
-    private int mOutputHeight;
+    protected int mGLProgId;
+    protected int mGLAttribPosition;
+    protected int mGLUniformTexture;
+    protected int mGLAttribTextureCoordinate;
+    protected int mOutputWidth;
+    protected int mOutputHeight;
     private boolean mIsInitialized;
 
     public GPUImageFilter() {
@@ -64,6 +68,12 @@ public GPUImageFilter(final String vertexShader, final String fragmentShader) {
         mFragmentShader = fragmentShader;
     }
 
+    public final void init() {
+        onInit();
+        mIsInitialized = true;
+        onInitialized();
+    }
+
     public void onInit() {
         mGLProgId = OpenGlUtils.loadProgram(mVertexShader, mFragmentShader);
         mGLAttribPosition = GLES20.glGetAttribLocation(mGLProgId, "position");
@@ -73,9 +83,16 @@ public void onInit() {
         mIsInitialized = true;
     }
 
-    public void onDestroy() {
-        GLES20.glDeleteProgram(mGLProgId);
+    public void onInitialized() {
+    }
+
+    public final void destroy() {
         mIsInitialized = false;
+        GLES20.glDeleteProgram(mGLProgId);
+        onDestroy();
+    }
+
+    public void onDestroy() {
     }
 
     public void onOutputSizeChanged(final int width, final int height) {
@@ -84,7 +101,7 @@ public void onOutputSizeChanged(final int width, final int height) {
     }
 
     public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
-            final FloatBuffer textureBuffer) {
+                       final FloatBuffer textureBuffer) {
         GLES20.glUseProgram(mGLProgId);
         runPendingOnDrawTasks();
         if (!mIsInitialized) {
@@ -103,12 +120,15 @@ public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
             GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId);
             GLES20.glUniform1i(mGLUniformTexture, 0);
         }
+        onDrawArraysPre();
         GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4);
         GLES20.glDisableVertexAttribArray(mGLAttribPosition);
         GLES20.glDisableVertexAttribArray(mGLAttribTextureCoordinate);
         GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);
     }
 
+    protected void onDrawArraysPre() {}
+
     protected void runPendingOnDrawTasks() {
         while (!mRunOnDraw.isEmpty()) {
             mRunOnDraw.removeFirst().run();
@@ -143,9 +163,17 @@ public int getUniformTexture() {
         return mGLUniformTexture;
     }
 
-    protected void setFloat(final int location, final float floatValue) {
+    protected void setInteger(final int location, final int intValue) {
         runOnDraw(new Runnable() {
+            @Override
+            public void run() {
+                GLES20.glUniform1i(location, intValue);
+            }
+        });
+    }
 
+    protected void setFloat(final int location, final float floatValue) {
+        runOnDraw(new Runnable() {
             @Override
             public void run() {
                 GLES20.glUniform1f(location, floatValue);
@@ -153,6 +181,55 @@ public void run() {
         });
     }
 
+    protected void setFloatVec2(final int location, final float[] arrayValue) {
+        runOnDraw(new Runnable() {
+            @Override
+            public void run() {
+                GLES20.glUniform2fv(location, 1, FloatBuffer.wrap(arrayValue));
+            }
+        });
+    }
+
+    protected void setFloatVec3(final int location, final float[] arrayValue) {
+        runOnDraw(new Runnable() {
+            @Override
+            public void run() {
+                GLES20.glUniform3fv(location, 1, FloatBuffer.wrap(arrayValue));
+            }
+        });
+    }
+
+    protected void setFloatVec4(final int location, final float[] arrayValue) {
+        runOnDraw(new Runnable() {
+            @Override
+            public void run() {
+                GLES20.glUniform4fv(location, 1, FloatBuffer.wrap(arrayValue));
+            }
+        });
+    }
+
+    protected void setFloatArray(final int location, final float[] arrayValue) {
+        runOnDraw(new Runnable() {
+            @Override
+            public void run() {
+                GLES20.glUniform1fv(location, arrayValue.length, FloatBuffer.wrap(arrayValue));
+            }
+        });
+    }
+
+    protected void setPoint(final int location, final PointF point) {
+        runOnDraw(new Runnable() {
+
+            @Override
+            public void run() {
+                float[] vec2 = new float[2];
+                vec2[0] = point.x;
+                vec2[1] = point.y;
+                GLES20.glUniform2fv(location, 1, vec2, 0);
+            }
+        });
+    }
+
     protected void setUniformMatrix3f(final int location, final float[] matrix) {
         runOnDraw(new Runnable() {
 
@@ -178,4 +255,24 @@ protected void runOnDraw(final Runnable runnable) {
             mRunOnDraw.addLast(runnable);
         }
     }
+
+    public static String loadShader(String file, Context context) {
+        try {
+            AssetManager assetManager = context.getAssets();
+            InputStream ims = assetManager.open(file);
+
+            String re = convertStreamToString(ims);
+            ims.close();
+            return re;
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+
+        return "";
+    }
+
+    public static String convertStreamToString(java.io.InputStream is) {
+        java.util.Scanner s = new java.util.Scanner(is).useDelimiter("\\A");
+        return s.hasNext() ? s.next() : "";
+    }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java
index 65e1e595..10ea41ca 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageFilterGroup.java
@@ -16,15 +16,18 @@
 
 package jp.co.cyberagent.android.gpuimage;
 
-import static jp.co.cyberagent.android.gpuimage.GPUImageRenderer.CUBE;
-import static jp.co.cyberagent.android.gpuimage.GPUImageRenderer.TEXTURE_NO_ROTATION;
+import android.annotation.SuppressLint;
+import android.opengl.GLES20;
+import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
 
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.nio.FloatBuffer;
+import java.util.ArrayList;
 import java.util.List;
 
-import android.opengl.GLES20;
+import static jp.co.cyberagent.android.gpuimage.GPUImageRenderer.CUBE;
+import static jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil.TEXTURE_NO_ROTATION;
 
 /**
  * Resembles a filter that consists of multiple filters applied after each
@@ -32,20 +35,35 @@
  */
 public class GPUImageFilterGroup extends GPUImageFilter {
 
-    private final List<GPUImageFilter> mFilters;
+    protected List<GPUImageFilter> mFilters;
+    protected List<GPUImageFilter> mMergedFilters;
     private int[] mFrameBuffers;
     private int[] mFrameBufferTextures;
 
     private final FloatBuffer mGLCubeBuffer;
     private final FloatBuffer mGLTextureBuffer;
+    private final FloatBuffer mGLTextureFlipBuffer;
+
+    /**
+     * Instantiates a new GPUImageFilterGroup with no filters.
+     */
+    public GPUImageFilterGroup() {
+        this(null);
+    }
 
     /**
      * Instantiates a new GPUImageFilterGroup with the given filters.
      *
      * @param filters the filters which represent this filter
      */
-    public GPUImageFilterGroup(final List<GPUImageFilter> filters) {
+    public GPUImageFilterGroup(List<GPUImageFilter> filters) {
         mFilters = filters;
+        if (mFilters == null) {
+            mFilters = new ArrayList<GPUImageFilter>();
+        } else {
+            updateMergedFilters();
+        }
+
         mGLCubeBuffer = ByteBuffer.allocateDirect(CUBE.length * 4)
                 .order(ByteOrder.nativeOrder())
                 .asFloatBuffer();
@@ -55,6 +73,20 @@ public GPUImageFilterGroup(final List<GPUImageFilter> filters) {
                 .order(ByteOrder.nativeOrder())
                 .asFloatBuffer();
         mGLTextureBuffer.put(TEXTURE_NO_ROTATION).position(0);
+
+        float[] flipTexture = TextureRotationUtil.getRotation(Rotation.NORMAL, false, true);
+        mGLTextureFlipBuffer = ByteBuffer.allocateDirect(flipTexture.length * 4)
+                .order(ByteOrder.nativeOrder())
+                .asFloatBuffer();
+        mGLTextureFlipBuffer.put(flipTexture).position(0);
+    }
+
+    public void addFilter(GPUImageFilter aFilter) {
+        if (aFilter == null) {
+            return;
+        }
+        mFilters.add(aFilter);
+        updateMergedFilters();
     }
 
     /*
@@ -65,7 +97,7 @@ public GPUImageFilterGroup(final List<GPUImageFilter> filters) {
     public void onInit() {
         super.onInit();
         for (GPUImageFilter filter : mFilters) {
-            filter.onInit();
+            filter.init();
         }
     }
 
@@ -77,7 +109,7 @@ public void onInit() {
     public void onDestroy() {
         destroyFramebuffers();
         for (GPUImageFilter filter : mFilters) {
-            filter.onDestroy();
+            filter.destroy();
         }
         super.onDestroy();
     }
@@ -105,33 +137,40 @@ public void onOutputSizeChanged(final int width, final int height) {
         if (mFrameBuffers != null) {
             destroyFramebuffers();
         }
-        mFrameBuffers = new int[mFilters.size() - 1];
-        mFrameBufferTextures = new int[mFilters.size() - 1];
 
-        for (int i = 0; i < mFilters.size() - 1; i++) {
+        int size = mFilters.size();
+        for (int i = 0; i < size; i++) {
             mFilters.get(i).onOutputSizeChanged(width, height);
-            GLES20.glGenFramebuffers(1, mFrameBuffers, i);
-            GLES20.glGenTextures(1, mFrameBufferTextures, i);
-            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mFrameBufferTextures[i]);
-            GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, width, height, 0,
-                    GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, null);
-            GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
-                    GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
-            GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
-                    GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
-            GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
-                    GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);
-            GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
-                    GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
-
-            GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, mFrameBuffers[i]);
-            GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER, GLES20.GL_COLOR_ATTACHMENT0,
-                    GLES20.GL_TEXTURE_2D, mFrameBufferTextures[i], 0);
-
-            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);
-            GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);
         }
-        mFilters.get(mFilters.size() - 1).onOutputSizeChanged(width, height);
+
+        if (mMergedFilters != null && mMergedFilters.size() > 0) {
+            size = mMergedFilters.size();
+            mFrameBuffers = new int[size - 1];
+            mFrameBufferTextures = new int[size - 1];
+
+            for (int i = 0; i < size - 1; i++) {
+                GLES20.glGenFramebuffers(1, mFrameBuffers, i);
+                GLES20.glGenTextures(1, mFrameBufferTextures, i);
+                GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mFrameBufferTextures[i]);
+                GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, width, height, 0,
+                        GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, null);
+                GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+                        GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
+                GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+                        GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
+                GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+                        GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);
+                GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
+                        GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
+
+                GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, mFrameBuffers[i]);
+                GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER, GLES20.GL_COLOR_ATTACHMENT0,
+                        GLES20.GL_TEXTURE_2D, mFrameBufferTextures[i], 0);
+
+                GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);
+                GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);
+            }
+        }
     }
 
     /*
@@ -139,24 +178,40 @@ public void onOutputSizeChanged(final int width, final int height) {
      * @see jp.co.cyberagent.android.gpuimage.GPUImageFilter#onDraw(int,
      * java.nio.FloatBuffer, java.nio.FloatBuffer)
      */
+    @SuppressLint("WrongCall")    
     @Override
     public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
-            final FloatBuffer textureBuffer) {
+                       final FloatBuffer textureBuffer) {
         runPendingOnDrawTasks();
         if (!isInitialized() || mFrameBuffers == null || mFrameBufferTextures == null) {
             return;
         }
-        int previousTexture = textureId;
-        for (int i = 0; i < mFilters.size() - 1; i++) {
-            GPUImageFilter filter = mFilters.get(i);
-            GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, mFrameBuffers[i]);
-            GLES20.glClearColor(0, 0, 0, 1);
-            filter.onDraw(previousTexture, mGLCubeBuffer, mGLTextureBuffer);
-            GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);
-            previousTexture = mFrameBufferTextures[i];
+        if (mMergedFilters != null) {
+            int size = mMergedFilters.size();
+            int previousTexture = textureId;
+            for (int i = 0; i < size; i++) {
+                GPUImageFilter filter = mMergedFilters.get(i);
+                boolean isNotLast = i < size - 1;
+                if (isNotLast) {
+                    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, mFrameBuffers[i]);
+                    GLES20.glClearColor(0, 0, 0, 0);
+                }
+
+                if (i == 0) {
+                    filter.onDraw(previousTexture, cubeBuffer, textureBuffer);
+                } else if (i == size - 1) {
+                    filter.onDraw(previousTexture, mGLCubeBuffer, (size % 2 == 0) ? mGLTextureFlipBuffer : mGLTextureBuffer);
+                } else {
+                    filter.onDraw(previousTexture, mGLCubeBuffer, mGLTextureBuffer);
+                }
+
+                if (isNotLast) {
+                    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);
+                    previousTexture = mFrameBufferTextures[i];
+                }
+            }
         }
-        mFilters.get(mFilters.size() - 1).onDraw(previousTexture, cubeBuffer, textureBuffer);
-    }
+     }
 
     /**
      * Gets the filters.
@@ -166,4 +221,33 @@ public void onDraw(final int textureId, final FloatBuffer cubeBuffer,
     public List<GPUImageFilter> getFilters() {
         return mFilters;
     }
+
+    public List<GPUImageFilter> getMergedFilters() {
+        return mMergedFilters;
+    }
+
+    public void updateMergedFilters() {
+        if (mFilters == null) {
+            return;
+        }
+
+        if (mMergedFilters == null) {
+            mMergedFilters = new ArrayList<GPUImageFilter>();
+        } else {
+            mMergedFilters.clear();
+        }
+
+        List<GPUImageFilter> filters;
+        for (GPUImageFilter filter : mFilters) {
+            if (filter instanceof GPUImageFilterGroup) {
+                ((GPUImageFilterGroup) filter).updateMergedFilters();
+                filters = ((GPUImageFilterGroup) filter).getMergedFilters();
+                if (filters == null || filters.isEmpty())
+                    continue;
+                mMergedFilters.addAll(filters);
+                continue;
+            }
+            mMergedFilters.add(filter);
+        }
+    }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGammaFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGammaFilter.java
index 375ab272..1f902d0f 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGammaFilter.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGammaFilter.java
@@ -37,7 +37,6 @@
 
     private int mGammaLocation;
     private float mGamma;
-    private boolean mIsInitialized = false;
 
     public GPUImageGammaFilter() {
         this(1.2f);
@@ -52,14 +51,16 @@ public GPUImageGammaFilter(final float gamma) {
     public void onInit() {
         super.onInit();
         mGammaLocation = GLES20.glGetUniformLocation(getProgram(), "gamma");
-        mIsInitialized = true;
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
         setGamma(mGamma);
     }
 
     public void setGamma(final float gamma) {
         mGamma = gamma;
-        if (mIsInitialized) {
-            setFloat(mGammaLocation, mGamma);
-        }
+        setFloat(mGammaLocation, mGamma);
     }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java
new file mode 100644
index 00000000..c912f73e
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGaussianBlurFilter.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+/**
+ * A more generalized 9x9 Gaussian blur filter
+ * blurSize value ranging from 0.0 on up, with a default of 1.0
+ */
+public class GPUImageGaussianBlurFilter extends GPUImageTwoPassTextureSamplingFilter {
+    public static final String VERTEX_SHADER =
+            "attribute vec4 position;\n" +
+                    "attribute vec4 inputTextureCoordinate;\n" +
+                    "\n" +
+                    "const int GAUSSIAN_SAMPLES = 9;\n" +
+                    "\n" +
+                    "uniform float texelWidthOffset;\n" +
+                    "uniform float texelHeightOffset;\n" +
+                    "\n" +
+                    "varying vec2 textureCoordinate;\n" +
+                    "varying vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "	gl_Position = position;\n" +
+                    "	textureCoordinate = inputTextureCoordinate.xy;\n" +
+                    "	\n" +
+                    "	// Calculate the positions for the blur\n" +
+                    "	int multiplier = 0;\n" +
+                    "	vec2 blurStep;\n" +
+                    "   vec2 singleStepOffset = vec2(texelHeightOffset, texelWidthOffset);\n" +
+                    "    \n" +
+                    "	for (int i = 0; i < GAUSSIAN_SAMPLES; i++)\n" +
+                    "   {\n" +
+                    "		multiplier = (i - ((GAUSSIAN_SAMPLES - 1) / 2));\n" +
+                    "       // Blur in x (horizontal)\n" +
+                    "       blurStep = float(multiplier) * singleStepOffset;\n" +
+                    "		blurCoordinates[i] = inputTextureCoordinate.xy + blurStep;\n" +
+                    "	}\n" +
+                    "}\n";
+
+    public static final String FRAGMENT_SHADER =
+            "uniform sampler2D inputImageTexture;\n" +
+                    "\n" +
+                    "const lowp int GAUSSIAN_SAMPLES = 9;\n" +
+                    "\n" +
+                    "varying highp vec2 textureCoordinate;\n" +
+                    "varying highp vec2 blurCoordinates[GAUSSIAN_SAMPLES];\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "	lowp vec3 sum = vec3(0.0);\n" +
+                    "   lowp vec4 fragColor=texture2D(inputImageTexture,textureCoordinate);\n" +
+                    "	\n" +
+                    "    sum += texture2D(inputImageTexture, blurCoordinates[0]).rgb * 0.05;\n" +
+                    "    sum += texture2D(inputImageTexture, blurCoordinates[1]).rgb * 0.09;\n" +
+                    "    sum += texture2D(inputImageTexture, blurCoordinates[2]).rgb * 0.12;\n" +
+                    "    sum += texture2D(inputImageTexture, blurCoordinates[3]).rgb * 0.15;\n" +
+                    "    sum += texture2D(inputImageTexture, blurCoordinates[4]).rgb * 0.18;\n" +
+                    "    sum += texture2D(inputImageTexture, blurCoordinates[5]).rgb * 0.15;\n" +
+                    "    sum += texture2D(inputImageTexture, blurCoordinates[6]).rgb * 0.12;\n" +
+                    "    sum += texture2D(inputImageTexture, blurCoordinates[7]).rgb * 0.09;\n" +
+                    "    sum += texture2D(inputImageTexture, blurCoordinates[8]).rgb * 0.05;\n" +
+                    "\n" +
+                    "	gl_FragColor = vec4(sum,fragColor.a);\n" +
+                    "}";
+
+    protected float mBlurSize = 1f;
+
+    public GPUImageGaussianBlurFilter() {
+        this(1f);
+    }
+
+    public GPUImageGaussianBlurFilter(float blurSize) {
+        super(VERTEX_SHADER, FRAGMENT_SHADER, VERTEX_SHADER, FRAGMENT_SHADER);
+        mBlurSize = blurSize;
+    }
+
+    @Override
+    public float getVerticalTexelOffsetRatio() {
+        return mBlurSize;
+    }
+
+    @Override
+    public float getHorizontalTexelOffsetRatio() {
+        return mBlurSize;
+    }
+
+    /**
+     * A multiplier for the blur size, ranging from 0.0 on up, with a default of 1.0
+     *
+     * @param blurSize from 0.0 on up, default 1.0
+     */
+    public void setBlurSize(float blurSize) {
+        mBlurSize = blurSize;
+        runOnDraw(new Runnable() {
+            @Override
+            public void run() {
+                initTexelOffsets();
+            }
+        });
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGlassSphereFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGlassSphereFilter.java
new file mode 100644
index 00000000..460019cc
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageGlassSphereFilter.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.graphics.PointF;
+import android.opengl.GLES20;
+
+public class GPUImageGlassSphereFilter extends GPUImageFilter {
+    public static final String SPHERE_FRAGMENT_SHADER = "" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "uniform highp vec2 center;\n" +
+            "uniform highp float radius;\n" +
+            "uniform highp float aspectRatio;\n" +
+            "uniform highp float refractiveIndex;\n" +
+            "// uniform vec3 lightPosition;\n" +
+            "const highp vec3 lightPosition = vec3(-0.5, 0.5, 1.0);\n" +
+            "const highp vec3 ambientLightPosition = vec3(0.0, 0.0, 1.0);\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "highp vec2 textureCoordinateToUse = vec2(textureCoordinate.x, (textureCoordinate.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n" +
+            "highp float distanceFromCenter = distance(center, textureCoordinateToUse);\n" +
+            "lowp float checkForPresenceWithinSphere = step(distanceFromCenter, radius);\n" +
+            "\n" +
+            "distanceFromCenter = distanceFromCenter / radius;\n" +
+            "\n" +
+            "highp float normalizedDepth = radius * sqrt(1.0 - distanceFromCenter * distanceFromCenter);\n" +
+            "highp vec3 sphereNormal = normalize(vec3(textureCoordinateToUse - center, normalizedDepth));\n" +
+            "\n" +
+            "highp vec3 refractedVector = 2.0 * refract(vec3(0.0, 0.0, -1.0), sphereNormal, refractiveIndex);\n" +
+            "refractedVector.xy = -refractedVector.xy;\n" +
+            "\n" +
+            "highp vec3 finalSphereColor = texture2D(inputImageTexture, (refractedVector.xy + 1.0) * 0.5).rgb;\n" +
+            "\n" +
+            "// Grazing angle lighting\n" +
+            "highp float lightingIntensity = 2.5 * (1.0 - pow(clamp(dot(ambientLightPosition, sphereNormal), 0.0, 1.0), 0.25));\n" +
+            "finalSphereColor += lightingIntensity;\n" +
+            "\n" +
+            "// Specular lighting\n" +
+            "lightingIntensity  = clamp(dot(normalize(lightPosition), sphereNormal), 0.0, 1.0);\n" +
+            "lightingIntensity  = pow(lightingIntensity, 15.0);\n" +
+            "finalSphereColor += vec3(0.8, 0.8, 0.8) * lightingIntensity;\n" +
+            "\n" +
+            "gl_FragColor = vec4(finalSphereColor, 1.0) * checkForPresenceWithinSphere;\n" +
+            "}\n";
+
+    private PointF mCenter;
+    private int mCenterLocation;
+    private float mRadius;
+    private int mRadiusLocation;
+    private float mAspectRatio;
+    private int mAspectRatioLocation;
+    private float mRefractiveIndex;
+    private int mRefractiveIndexLocation;
+
+    public GPUImageGlassSphereFilter() {
+        this(new PointF(0.5f, 0.5f), 0.25f, 0.71f);
+    }
+
+    public GPUImageGlassSphereFilter(PointF center, float radius, float refractiveIndex) {
+        super(NO_FILTER_VERTEX_SHADER, SPHERE_FRAGMENT_SHADER);
+        mCenter = center;
+        mRadius = radius;
+        mRefractiveIndex = refractiveIndex;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mCenterLocation = GLES20.glGetUniformLocation(getProgram(), "center");
+        mRadiusLocation = GLES20.glGetUniformLocation(getProgram(), "radius");
+        mAspectRatioLocation = GLES20.glGetUniformLocation(getProgram(), "aspectRatio");
+        mRefractiveIndexLocation = GLES20.glGetUniformLocation(getProgram(), "refractiveIndex");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setRadius(mRadius);
+        setCenter(mCenter);
+        setRefractiveIndex(mRefractiveIndex);
+    }
+
+    @Override
+    public void onOutputSizeChanged(int width, int height) {
+        mAspectRatio = (float) height / width;
+        setAspectRatio(mAspectRatio);
+        super.onOutputSizeChanged(width, height);
+    }
+
+    private void setAspectRatio(float aspectRatio) {
+        mAspectRatio = aspectRatio;
+        setFloat(mAspectRatioLocation, aspectRatio);
+    }
+
+    public void setRefractiveIndex(float refractiveIndex) {
+        mRefractiveIndex = refractiveIndex;
+        setFloat(mRefractiveIndexLocation, refractiveIndex);
+    }
+
+    public void setCenter(PointF center) {
+        mCenter = center;
+        setPoint(mCenterLocation, center);
+    }
+
+    public void setRadius(float radius) {
+        mRadius = radius;
+        setFloat(mRadiusLocation, radius);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHardLightBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHardLightBlendFilter.java
new file mode 100644
index 00000000..5bcb9c90
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHardLightBlendFilter.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageHardLightBlendFilter extends GPUImageTwoInputFilter {
+    public static final String HARD_LIGHT_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2;\n" +
+            "\n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            "\n" +
+            " const highp vec3 W = vec3(0.2125, 0.7154, 0.0721);\n" +
+            "\n" +
+            " void main()\n" +
+            " {\n" +
+            "     mediump vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "     mediump vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+            "\n" +
+            "     highp float ra;\n" +
+            "     if (2.0 * overlay.r < overlay.a) {\n" +
+            "         ra = 2.0 * overlay.r * base.r + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n" +
+            "     } else {\n" +
+            "         ra = overlay.a * base.a - 2.0 * (base.a - base.r) * (overlay.a - overlay.r) + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n" +
+            "     }\n" +
+            "     \n" +
+            "     highp float ga;\n" +
+            "     if (2.0 * overlay.g < overlay.a) {\n" +
+            "         ga = 2.0 * overlay.g * base.g + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n" +
+            "     } else {\n" +
+            "         ga = overlay.a * base.a - 2.0 * (base.a - base.g) * (overlay.a - overlay.g) + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n" +
+            "     }\n" +
+            "     \n" +
+            "     highp float ba;\n" +
+            "     if (2.0 * overlay.b < overlay.a) {\n" +
+            "         ba = 2.0 * overlay.b * base.b + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n" +
+            "     } else {\n" +
+            "         ba = overlay.a * base.a - 2.0 * (base.a - base.b) * (overlay.a - overlay.b) + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n" +
+            "     }\n" +
+            "     \n" +
+            "     gl_FragColor = vec4(ra, ga, ba, 1.0);\n" +
+            " }";
+
+    public GPUImageHardLightBlendFilter() {
+        super(HARD_LIGHT_BLEND_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHazeFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHazeFilter.java
new file mode 100644
index 00000000..bb230abc
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHazeFilter.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+/**
+ * The haze filter can be used to add or remove haze.
+ *
+ * This is similar to a UV filter.
+ */
+public class GPUImageHazeFilter extends GPUImageFilter {
+    public static final String HAZE_FRAGMENT_SHADER = "" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "uniform lowp float distance;\n" +
+            "uniform highp float slope;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "	//todo reconsider precision modifiers	 \n" +
+            "	 highp vec4 color = vec4(1.0);//todo reimplement as a parameter\n" +
+            "\n" +
+            "	 highp float  d = textureCoordinate.y * slope  +  distance; \n" +
+            "\n" +
+            "	 highp vec4 c = texture2D(inputImageTexture, textureCoordinate) ; // consider using unpremultiply\n" +
+            "\n" +
+            "	 c = (c - d * color) / (1.0 -d);\n" +
+            "\n" +
+            "	 gl_FragColor = c; //consider using premultiply(c);\n" +
+            "}\n";
+
+    private float mDistance;
+    private int mDistanceLocation;
+    private float mSlope;
+    private int mSlopeLocation;
+
+    public GPUImageHazeFilter() {
+        this(0.2f, 0.0f);
+    }
+
+    public GPUImageHazeFilter(float distance, float slope) {
+        super(NO_FILTER_VERTEX_SHADER, HAZE_FRAGMENT_SHADER);
+        mDistance = distance;
+        mSlope = slope;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mDistanceLocation = GLES20.glGetUniformLocation(getProgram(), "distance");
+        mSlopeLocation = GLES20.glGetUniformLocation(getProgram(), "slope");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setDistance(mDistance);
+        setSlope(mSlope);
+    }
+
+    /**
+     * Strength of the color applied. Default 0. Values between -.3 and .3 are best.
+     *
+     * @param distance -0.3 to 0.3 are best, default 0
+     */
+    public void setDistance(float distance) {
+        mDistance = distance;
+        setFloat(mDistanceLocation, distance);
+    }
+
+    /**
+     * Amount of color change. Default 0. Values between -.3 and .3 are best.
+     *
+     * @param slope -0.3 to 0.3 are best, default 0
+     */
+    public void setSlope(float slope) {
+        mSlope = slope;
+        setFloat(mSlopeLocation, slope);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHighlightShadowFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHighlightShadowFilter.java
new file mode 100644
index 00000000..878c508a
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHighlightShadowFilter.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+/**
+ * Adjusts the shadows and highlights of an image
+ * shadows: Increase to lighten shadows, from 0.0 to 1.0, with 0.0 as the default.
+ * highlights: Decrease to darken highlights, from 0.0 to 1.0, with 1.0 as the default.
+ */
+public class GPUImageHighlightShadowFilter extends GPUImageFilter {
+    public static final String HIGHLIGHT_SHADOW_FRAGMENT_SHADER = "" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " varying highp vec2 textureCoordinate;\n" +
+            "  \n" +
+            " uniform lowp float shadows;\n" +
+            " uniform lowp float highlights;\n" +
+            " \n" +
+            " const mediump vec3 luminanceWeighting = vec3(0.3, 0.3, 0.3);\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            " 	lowp vec4 source = texture2D(inputImageTexture, textureCoordinate);\n" +
+            " 	mediump float luminance = dot(source.rgb, luminanceWeighting);\n" +
+            " \n" +
+            " 	mediump float shadow = clamp((pow(luminance, 1.0/(shadows+1.0)) + (-0.76)*pow(luminance, 2.0/(shadows+1.0))) - luminance, 0.0, 1.0);\n" +
+            " 	mediump float highlight = clamp((1.0 - (pow(1.0-luminance, 1.0/(2.0-highlights)) + (-0.8)*pow(1.0-luminance, 2.0/(2.0-highlights)))) - luminance, -1.0, 0.0);\n" +
+            " 	lowp vec3 result = vec3(0.0, 0.0, 0.0) + ((luminance + shadow + highlight) - 0.0) * ((source.rgb - vec3(0.0, 0.0, 0.0))/(luminance - 0.0));\n" +
+            " \n" +
+            " 	gl_FragColor = vec4(result.rgb, source.a);\n" +
+            " }";
+
+    private int mShadowsLocation;
+    private float mShadows;
+    private int mHighlightsLocation;
+    private float mHighlights;
+
+    public GPUImageHighlightShadowFilter() {
+        this(0.0f, 1.0f);
+    }
+
+    public GPUImageHighlightShadowFilter(final float shadows, final float highlights) {
+        super(NO_FILTER_VERTEX_SHADER, HIGHLIGHT_SHADOW_FRAGMENT_SHADER);
+        mHighlights = highlights;
+        mShadows = shadows;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mHighlightsLocation = GLES20.glGetUniformLocation(getProgram(), "highlights");
+        mShadowsLocation = GLES20.glGetUniformLocation(getProgram(), "shadows");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setHighlights(mHighlights);
+        setShadows(mShadows);
+    }
+
+    public void setHighlights(final float highlights) {
+        mHighlights = highlights;
+        setFloat(mHighlightsLocation, mHighlights);
+    }
+    
+    public void setShadows(final float shadows) {
+        mShadows = shadows;
+        setFloat(mShadowsLocation, mShadows);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHueBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHueBlendFilter.java
new file mode 100644
index 00000000..3950901c
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHueBlendFilter.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageHueBlendFilter extends GPUImageTwoInputFilter {
+    public static final String HUE_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " \n" +
+            " highp float lum(lowp vec3 c) {\n" +
+            "     return dot(c, vec3(0.3, 0.59, 0.11));\n" +
+            " }\n" +
+            " \n" +
+            " lowp vec3 clipcolor(lowp vec3 c) {\n" +
+            "     highp float l = lum(c);\n" +
+            "     lowp float n = min(min(c.r, c.g), c.b);\n" +
+            "     lowp float x = max(max(c.r, c.g), c.b);\n" +
+            "     \n" +
+            "     if (n < 0.0) {\n" +
+            "         c.r = l + ((c.r - l) * l) / (l - n);\n" +
+            "         c.g = l + ((c.g - l) * l) / (l - n);\n" +
+            "         c.b = l + ((c.b - l) * l) / (l - n);\n" +
+            "     }\n" +
+            "     if (x > 1.0) {\n" +
+            "         c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n" +
+            "         c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n" +
+            "         c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n" +
+            "     }\n" +
+            "     \n" +
+            "     return c;\n" +
+            " }\n" +
+            " \n" +
+            " lowp vec3 setlum(lowp vec3 c, highp float l) {\n" +
+            "     highp float d = l - lum(c);\n" +
+            "     c = c + vec3(d);\n" +
+            "     return clipcolor(c);\n" +
+            " }\n" +
+            " \n" +
+            " highp float sat(lowp vec3 c) {\n" +
+            "     lowp float n = min(min(c.r, c.g), c.b);\n" +
+            "     lowp float x = max(max(c.r, c.g), c.b);\n" +
+            "     return x - n;\n" +
+            " }\n" +
+            " \n" +
+            " lowp float mid(lowp float cmin, lowp float cmid, lowp float cmax, highp float s) {\n" +
+            "     return ((cmid - cmin) * s) / (cmax - cmin);\n" +
+            " }\n" +
+            " \n" +
+            " lowp vec3 setsat(lowp vec3 c, highp float s) {\n" +
+            "     if (c.r > c.g) {\n" +
+            "         if (c.r > c.b) {\n" +
+            "             if (c.g > c.b) {\n" +
+            "                 /* g is mid, b is min */\n" +
+            "                 c.g = mid(c.b, c.g, c.r, s);\n" +
+            "                 c.b = 0.0;\n" +
+            "             } else {\n" +
+            "                 /* b is mid, g is min */\n" +
+            "                 c.b = mid(c.g, c.b, c.r, s);\n" +
+            "                 c.g = 0.0;\n" +
+            "             }\n" +
+            "             c.r = s;\n" +
+            "         } else {\n" +
+            "             /* b is max, r is mid, g is min */\n" +
+            "             c.r = mid(c.g, c.r, c.b, s);\n" +
+            "             c.b = s;\n" +
+            "             c.r = 0.0;\n" +
+            "         }\n" +
+            "     } else if (c.r > c.b) {\n" +
+            "         /* g is max, r is mid, b is min */\n" +
+            "         c.r = mid(c.b, c.r, c.g, s);\n" +
+            "         c.g = s;\n" +
+            "         c.b = 0.0;\n" +
+            "     } else if (c.g > c.b) {\n" +
+            "         /* g is max, b is mid, r is min */\n" +
+            "         c.b = mid(c.r, c.b, c.g, s);\n" +
+            "         c.g = s;\n" +
+            "         c.r = 0.0;\n" +
+            "     } else if (c.b > c.g) {\n" +
+            "         /* b is max, g is mid, r is min */\n" +
+            "         c.g = mid(c.r, c.g, c.b, s);\n" +
+            "         c.b = s;\n" +
+            "         c.r = 0.0;\n" +
+            "     } else {\n" +
+            "         c = vec3(0.0);\n" +
+            "     }\n" +
+            "     return c;\n" +
+            " }\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "   highp vec4 baseColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "   highp vec4 overlayColor = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+            "     \n" +
+            "     gl_FragColor = vec4(baseColor.rgb * (1.0 - overlayColor.a) + setlum(setsat(overlayColor.rgb, sat(baseColor.rgb)), lum(baseColor.rgb)) * overlayColor.a, baseColor.a);\n" +
+            " }";
+
+    public GPUImageHueBlendFilter() {
+        super(HUE_BLEND_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHueFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHueFilter.java
new file mode 100644
index 00000000..9fcf7939
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageHueFilter.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+public class GPUImageHueFilter extends GPUImageFilter {
+    public static final String HUE_FRAGMENT_SHADER = "" +
+      "precision highp float;\n" +
+      "varying highp vec2 textureCoordinate;\n" +
+      "\n" +
+      "uniform sampler2D inputImageTexture;\n" +
+      "uniform mediump float hueAdjust;\n" +
+      "const highp vec4 kRGBToYPrime = vec4 (0.299, 0.587, 0.114, 0.0);\n" +
+      "const highp vec4 kRGBToI = vec4 (0.595716, -0.274453, -0.321263, 0.0);\n" +
+      "const highp vec4 kRGBToQ = vec4 (0.211456, -0.522591, 0.31135, 0.0);\n" +
+      "\n" +
+      "const highp vec4 kYIQToR = vec4 (1.0, 0.9563, 0.6210, 0.0);\n" +
+      "const highp vec4 kYIQToG = vec4 (1.0, -0.2721, -0.6474, 0.0);\n" +
+      "const highp vec4 kYIQToB = vec4 (1.0, -1.1070, 1.7046, 0.0);\n" +
+      "\n" +
+      "void main ()\n" +
+      "{\n" +
+      "    // Sample the input pixel\n" +
+      "    highp vec4 color = texture2D(inputImageTexture, textureCoordinate);\n" +
+      "\n" +
+      "    // Convert to YIQ\n" +
+      "    highp float YPrime = dot (color, kRGBToYPrime);\n" +
+      "    highp float I = dot (color, kRGBToI);\n" +
+      "    highp float Q = dot (color, kRGBToQ);\n" +
+      "\n" +
+      "    // Calculate the hue and chroma\n" +
+      "    highp float hue = atan (Q, I);\n" +
+      "    highp float chroma = sqrt (I * I + Q * Q);\n" +
+      "\n" +
+      "    // Make the user's adjustments\n" +
+      "    hue += (-hueAdjust); //why negative rotation?\n" +
+      "\n" +
+      "    // Convert back to YIQ\n" +
+      "    Q = chroma * sin (hue);\n" +
+      "    I = chroma * cos (hue);\n" +
+      "\n" +
+      "    // Convert back to RGB\n" +
+      "    highp vec4 yIQ = vec4 (YPrime, I, Q, 0.0);\n" +
+      "    color.r = dot (yIQ, kYIQToR);\n" +
+      "    color.g = dot (yIQ, kYIQToG);\n" +
+      "    color.b = dot (yIQ, kYIQToB);\n" +
+      "\n" +
+      "    // Save the result\n" +
+      "    gl_FragColor = color;\n" +
+      "}\n";
+
+    private float mHue;
+    private int mHueLocation;
+
+    public GPUImageHueFilter() {
+        this(90.0f);
+    }
+
+    public GPUImageHueFilter(final float hue) {
+        super(NO_FILTER_VERTEX_SHADER, HUE_FRAGMENT_SHADER);
+        mHue = hue;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mHueLocation = GLES20.glGetUniformLocation(getProgram(), "hueAdjust");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setHue(mHue);
+    }
+
+    public void setHue(final float hue) {
+        mHue = hue;
+        float hueAdjust = (mHue % 360.0f) * (float) Math.PI / 180.0f;
+        setFloat(mHueLocation, hueAdjust);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageKuwaharaFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageKuwaharaFilter.java
new file mode 100644
index 00000000..6fc7f32b
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageKuwaharaFilter.java
@@ -0,0 +1,151 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+/**
+ * Kuwahara image abstraction, drawn from the work of Kyprianidis, et. al. in their publication
+ * "Anisotropic Kuwahara Filtering on the GPU" within the GPU Pro collection. This produces an oil-painting-like
+ * image, but it is extremely computationally expensive, so it can take seconds to render a frame on an iPad 2.
+ * This might be best used for still images.
+ */
+public class GPUImageKuwaharaFilter extends GPUImageFilter {
+    public static final String KUWAHARA_FRAGMENT_SHADER = "" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "uniform int radius;\n" +
+            "\n" +
+            "precision highp float;\n" +
+            "\n" +
+            "const vec2 src_size = vec2 (1.0 / 768.0, 1.0 / 1024.0);\n" +
+            "\n" +
+            "void main (void) \n" +
+            "{\n" +
+            "vec2 uv = textureCoordinate;\n" +
+            "float n = float((radius + 1) * (radius + 1));\n" +
+            "int i; int j;\n" +
+            "vec3 m0 = vec3(0.0); vec3 m1 = vec3(0.0); vec3 m2 = vec3(0.0); vec3 m3 = vec3(0.0);\n" +
+            "vec3 s0 = vec3(0.0); vec3 s1 = vec3(0.0); vec3 s2 = vec3(0.0); vec3 s3 = vec3(0.0);\n" +
+            "vec3 c;\n" +
+            "\n" +
+            "for (j = -radius; j <= 0; ++j)  {\n" +
+            "for (i = -radius; i <= 0; ++i)  {\n" +
+            "c = texture2D(inputImageTexture, uv + vec2(i,j) * src_size).rgb;\n" +
+            "m0 += c;\n" +
+            "s0 += c * c;\n" +
+            "}\n" +
+            "}\n" +
+            "\n" +
+            "for (j = -radius; j <= 0; ++j)  {\n" +
+            "for (i = 0; i <= radius; ++i)  {\n" +
+            "c = texture2D(inputImageTexture, uv + vec2(i,j) * src_size).rgb;\n" +
+            "m1 += c;\n" +
+            "s1 += c * c;\n" +
+            "}\n" +
+            "}\n" +
+            "\n" +
+            "for (j = 0; j <= radius; ++j)  {\n" +
+            "for (i = 0; i <= radius; ++i)  {\n" +
+            "c = texture2D(inputImageTexture, uv + vec2(i,j) * src_size).rgb;\n" +
+            "m2 += c;\n" +
+            "s2 += c * c;\n" +
+            "}\n" +
+            "}\n" +
+            "\n" +
+            "for (j = 0; j <= radius; ++j)  {\n" +
+            "for (i = -radius; i <= 0; ++i)  {\n" +
+            "c = texture2D(inputImageTexture, uv + vec2(i,j) * src_size).rgb;\n" +
+            "m3 += c;\n" +
+            "s3 += c * c;\n" +
+            "}\n" +
+            "}\n" +
+            "\n" +
+            "\n" +
+            "float min_sigma2 = 1e+2;\n" +
+            "m0 /= n;\n" +
+            "s0 = abs(s0 / n - m0 * m0);\n" +
+            "\n" +
+            "float sigma2 = s0.r + s0.g + s0.b;\n" +
+            "if (sigma2 < min_sigma2) {\n" +
+            "min_sigma2 = sigma2;\n" +
+            "gl_FragColor = vec4(m0, 1.0);\n" +
+            "}\n" +
+            "\n" +
+            "m1 /= n;\n" +
+            "s1 = abs(s1 / n - m1 * m1);\n" +
+            "\n" +
+            "sigma2 = s1.r + s1.g + s1.b;\n" +
+            "if (sigma2 < min_sigma2) {\n" +
+            "min_sigma2 = sigma2;\n" +
+            "gl_FragColor = vec4(m1, 1.0);\n" +
+            "}\n" +
+            "\n" +
+            "m2 /= n;\n" +
+            "s2 = abs(s2 / n - m2 * m2);\n" +
+            "\n" +
+            "sigma2 = s2.r + s2.g + s2.b;\n" +
+            "if (sigma2 < min_sigma2) {\n" +
+            "min_sigma2 = sigma2;\n" +
+            "gl_FragColor = vec4(m2, 1.0);\n" +
+            "}\n" +
+            "\n" +
+            "m3 /= n;\n" +
+            "s3 = abs(s3 / n - m3 * m3);\n" +
+            "\n" +
+            "sigma2 = s3.r + s3.g + s3.b;\n" +
+            "if (sigma2 < min_sigma2) {\n" +
+            "min_sigma2 = sigma2;\n" +
+            "gl_FragColor = vec4(m3, 1.0);\n" +
+            "}\n" +
+            "}\n";
+
+    private int mRadius;
+    private int mRadiusLocation;
+
+    public GPUImageKuwaharaFilter() {
+        this(3);
+    }
+
+    public GPUImageKuwaharaFilter(int radius) {
+        super(NO_FILTER_VERTEX_SHADER, KUWAHARA_FRAGMENT_SHADER);
+        mRadius = radius;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mRadiusLocation = GLES20.glGetUniformLocation(getProgram(), "radius");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setRadius(mRadius);
+    }
+
+    /**
+     * The radius to sample from when creating the brush-stroke effect, with a default of 3.
+     * The larger the radius, the slower the filter.
+     *
+     * @param radius default 3
+     */
+    public void setRadius(final int radius) {
+        mRadius = radius;
+        setInteger(mRadiusLocation, radius);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLaplacianFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLaplacianFilter.java
new file mode 100644
index 00000000..d320f64d
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLaplacianFilter.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+public class GPUImageLaplacianFilter extends GPUImage3x3TextureSamplingFilter {
+    public static final String LAPLACIAN_FRAGMENT_SHADER = "" +
+            "precision highp float;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "uniform mediump mat3 convolutionMatrix;\n" +
+            "\n" +
+            "varying vec2 textureCoordinate;\n" +
+            "varying vec2 leftTextureCoordinate;\n" +
+            "varying vec2 rightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 topTextureCoordinate;\n" +
+            "varying vec2 topLeftTextureCoordinate;\n" +
+            "varying vec2 topRightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 bottomTextureCoordinate;\n" +
+            "varying vec2 bottomLeftTextureCoordinate;\n" +
+            "varying vec2 bottomRightTextureCoordinate;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "mediump vec3 bottomColor = texture2D(inputImageTexture, bottomTextureCoordinate).rgb;\n" +
+            "mediump vec3 bottomLeftColor = texture2D(inputImageTexture, bottomLeftTextureCoordinate).rgb;\n" +
+            "mediump vec3 bottomRightColor = texture2D(inputImageTexture, bottomRightTextureCoordinate).rgb;\n" +
+            "mediump vec4 centerColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "mediump vec3 leftColor = texture2D(inputImageTexture, leftTextureCoordinate).rgb;\n" +
+            "mediump vec3 rightColor = texture2D(inputImageTexture, rightTextureCoordinate).rgb;\n" +
+            "mediump vec3 topColor = texture2D(inputImageTexture, topTextureCoordinate).rgb;\n" +
+            "mediump vec3 topRightColor = texture2D(inputImageTexture, topRightTextureCoordinate).rgb;\n" +
+            "mediump vec3 topLeftColor = texture2D(inputImageTexture, topLeftTextureCoordinate).rgb;\n" +
+            "\n" +
+            "mediump vec3 resultColor = topLeftColor * convolutionMatrix[0][0] + topColor * convolutionMatrix[0][1] + topRightColor * convolutionMatrix[0][2];\n" +
+            "resultColor += leftColor * convolutionMatrix[1][0] + centerColor.rgb * convolutionMatrix[1][1] + rightColor * convolutionMatrix[1][2];\n" +
+            "resultColor += bottomLeftColor * convolutionMatrix[2][0] + bottomColor * convolutionMatrix[2][1] + bottomRightColor * convolutionMatrix[2][2];\n" +
+            "\n" +
+            "// Normalize the results to allow for negative gradients in the 0.0-1.0 colorspace\n" +
+            "resultColor = resultColor + 0.5;\n" +
+            "\n" +
+            "gl_FragColor = vec4(resultColor, centerColor.a);\n" +
+            "}\n";
+
+    private float[] mConvolutionKernel;
+    private int mUniformConvolutionMatrix;
+
+    public GPUImageLaplacianFilter() {
+        this(new float[]{
+                0.5f, 1.0f, 0.5f,
+                1.0f, -6.0f, 1.0f,
+                0.5f, 1.0f, 0.5f
+        });
+    }
+
+    private GPUImageLaplacianFilter(final float[] convolutionKernel) {
+        super(LAPLACIAN_FRAGMENT_SHADER);
+        mConvolutionKernel = convolutionKernel;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mUniformConvolutionMatrix = GLES20.glGetUniformLocation(getProgram(), "convolutionMatrix");
+        setConvolutionKernel(mConvolutionKernel);
+    }
+
+    private void setConvolutionKernel(final float[] convolutionKernel) {
+        mConvolutionKernel = convolutionKernel;
+        setUniformMatrix3f(mUniformConvolutionMatrix, mConvolutionKernel);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLightenBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLightenBlendFilter.java
new file mode 100644
index 00000000..77399cb1
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLightenBlendFilter.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageLightenBlendFilter extends GPUImageTwoInputFilter {
+    public static final String LIGHTEN_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2;\n" +
+            "\n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "    lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "    lowp vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+            "    \n" +
+            "    gl_FragColor = max(textureColor, textureColor2);\n" +
+            " }";
+
+    public GPUImageLightenBlendFilter() {
+        super(LIGHTEN_BLEND_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLinearBurnBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLinearBurnBlendFilter.java
new file mode 100644
index 00000000..2623b528
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLinearBurnBlendFilter.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageLinearBurnBlendFilter extends GPUImageTwoInputFilter {
+    public static final String LINEAR_BURN_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     mediump vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "     mediump vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+            "     \n" +
+            "     gl_FragColor = vec4(clamp(textureColor.rgb + textureColor2.rgb - vec3(1.0), vec3(0.0), vec3(1.0)), textureColor.a);\n" +
+            " }";
+
+    public GPUImageLinearBurnBlendFilter() {
+        super(LINEAR_BURN_BLEND_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLookupFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLookupFilter.java
new file mode 100644
index 00000000..b9cfa2be
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLookupFilter.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageLookupFilter extends GPUImageTwoInputFilter {
+
+    public static final String LOOKUP_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2; // TODO: This is not used\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2; // lookup texture\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "     \n" +
+            "     mediump float blueColor = textureColor.b * 63.0;\n" +
+            "     \n" +
+            "     mediump vec2 quad1;\n" +
+            "     quad1.y = floor(floor(blueColor) / 8.0);\n" +
+            "     quad1.x = floor(blueColor) - (quad1.y * 8.0);\n" +
+            "     \n" +
+            "     mediump vec2 quad2;\n" +
+            "     quad2.y = floor(ceil(blueColor) / 8.0);\n" +
+            "     quad2.x = ceil(blueColor) - (quad2.y * 8.0);\n" +
+            "     \n" +
+            "     highp vec2 texPos1;\n" +
+            "     texPos1.x = (quad1.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n" +
+            "     texPos1.y = (quad1.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g);\n" +
+            "     \n" +
+            "     highp vec2 texPos2;\n" +
+            "     texPos2.x = (quad2.x * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.r);\n" +
+            "     texPos2.y = (quad2.y * 0.125) + 0.5/512.0 + ((0.125 - 1.0/512.0) * textureColor.g);\n" +
+            "     \n" +
+            "     lowp vec4 newColor1 = texture2D(inputImageTexture2, texPos1);\n" +
+            "     lowp vec4 newColor2 = texture2D(inputImageTexture2, texPos2);\n" +
+            "     \n" +
+            "     lowp vec4 newColor = mix(newColor1, newColor2, fract(blueColor));\n" +
+            "     gl_FragColor = vec4(newColor.rgb, textureColor.w);\n" +
+            " }";
+
+
+    public GPUImageLookupFilter() {
+        super(LOOKUP_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLuminosityBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLuminosityBlendFilter.java
new file mode 100644
index 00000000..85e7bfda
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageLuminosityBlendFilter.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageLuminosityBlendFilter extends GPUImageTwoInputFilter {
+    public static final String LUMINOSITY_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " \n" +
+            " highp float lum(lowp vec3 c) {\n" +
+            "     return dot(c, vec3(0.3, 0.59, 0.11));\n" +
+            " }\n" +
+            " \n" +
+            " lowp vec3 clipcolor(lowp vec3 c) {\n" +
+            "     highp float l = lum(c);\n" +
+            "     lowp float n = min(min(c.r, c.g), c.b);\n" +
+            "     lowp float x = max(max(c.r, c.g), c.b);\n" +
+            "     \n" +
+            "     if (n < 0.0) {\n" +
+            "         c.r = l + ((c.r - l) * l) / (l - n);\n" +
+            "         c.g = l + ((c.g - l) * l) / (l - n);\n" +
+            "         c.b = l + ((c.b - l) * l) / (l - n);\n" +
+            "     }\n" +
+            "     if (x > 1.0) {\n" +
+            "         c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n" +
+            "         c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n" +
+            "         c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n" +
+            "     }\n" +
+            "     \n" +
+            "     return c;\n" +
+            " }\n" +
+            " \n" +
+            " lowp vec3 setlum(lowp vec3 c, highp float l) {\n" +
+            "     highp float d = l - lum(c);\n" +
+            "     c = c + vec3(d);\n" +
+            "     return clipcolor(c);\n" +
+            " }\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "   highp vec4 baseColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "   highp vec4 overlayColor = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+            "     \n" +
+            "     gl_FragColor = vec4(baseColor.rgb * (1.0 - overlayColor.a) + setlum(baseColor.rgb, lum(overlayColor.rgb)) * overlayColor.a, baseColor.a);\n" +
+            " }";
+
+    public GPUImageLuminosityBlendFilter() {
+        super(LUMINOSITY_BLEND_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMixBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMixBlendFilter.java
new file mode 100644
index 00000000..7bf68859
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMixBlendFilter.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+public class GPUImageMixBlendFilter extends GPUImageTwoInputFilter {
+
+    private int mMixLocation;
+    private float mMix;
+
+    public GPUImageMixBlendFilter(String fragmentShader) {
+        this(fragmentShader, 0.5f);
+    }
+
+    public GPUImageMixBlendFilter(String fragmentShader, float mix) {
+        super(fragmentShader);
+        mMix = mix;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mMixLocation = GLES20.glGetUniformLocation(getProgram(), "mixturePercent");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setMix(mMix);
+    }
+
+    /**
+     * @param mix ranges from 0.0 (only image 1) to 1.0 (only image 2), with 0.5 (half of either) as the normal level
+     */
+    public void setMix(final float mix) {
+        mMix = mix;
+        setFloat(mMixLocation, mMix);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMonochromeFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMonochromeFilter.java
new file mode 100644
index 00000000..e426a340
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMonochromeFilter.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+/**
+ * Converts the image to a single-color version, based on the luminance of each pixel
+ * intensity: The degree to which the specific color replaces the normal image color (0.0 - 1.0, with 1.0 as the default)
+ * color: The color to use as the basis for the effect, with (0.6, 0.45, 0.3, 1.0) as the default.
+ */
+public class GPUImageMonochromeFilter extends GPUImageFilter {
+    public static final String MONOCHROME_FRAGMENT_SHADER = "" +
+            " precision lowp float;\n" +
+            "  \n" +
+            "  varying highp vec2 textureCoordinate;\n" +
+            "  \n" +
+            "  uniform sampler2D inputImageTexture;\n" +
+            "  uniform float intensity;\n" +
+            "  uniform vec3 filterColor;\n" +
+            "  \n" +
+            "  const mediump vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);\n" +
+            "  \n" +
+            "  void main()\n" +
+            "  {\n" +
+            " 	//desat, then apply overlay blend\n" +
+            " 	lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            " 	float luminance = dot(textureColor.rgb, luminanceWeighting);\n" +
+            " 	\n" +
+            " 	lowp vec4 desat = vec4(vec3(luminance), 1.0);\n" +
+            " 	\n" +
+            " 	//overlay\n" +
+            " 	lowp vec4 outputColor = vec4(\n" +
+            "                                  (desat.r < 0.5 ? (2.0 * desat.r * filterColor.r) : (1.0 - 2.0 * (1.0 - desat.r) * (1.0 - filterColor.r))),\n" +
+            "                                  (desat.g < 0.5 ? (2.0 * desat.g * filterColor.g) : (1.0 - 2.0 * (1.0 - desat.g) * (1.0 - filterColor.g))),\n" +
+            "                                  (desat.b < 0.5 ? (2.0 * desat.b * filterColor.b) : (1.0 - 2.0 * (1.0 - desat.b) * (1.0 - filterColor.b))),\n" +
+            "                                  1.0\n" +
+            "                                  );\n" +
+            " 	\n" +
+            " 	//which is better, or are they equal?\n" +
+            " 	gl_FragColor = vec4( mix(textureColor.rgb, outputColor.rgb, intensity), textureColor.a);\n" +
+            "  }";
+
+    private int mIntensityLocation;
+    private float mIntensity;
+    private int mFilterColorLocation;
+    private float[] mColor;
+
+    public GPUImageMonochromeFilter() {
+        this(1.0f, new float[] {0.6f, 0.45f, 0.3f, 1.0f});
+    }
+
+    public GPUImageMonochromeFilter(final float intensity, final float[] color) {
+        super(NO_FILTER_VERTEX_SHADER, MONOCHROME_FRAGMENT_SHADER);
+        mIntensity = intensity;
+        mColor = color;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mIntensityLocation = GLES20.glGetUniformLocation(getProgram(), "intensity");
+        mFilterColorLocation = GLES20.glGetUniformLocation(getProgram(), "filterColor");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setIntensity(1.0f);
+        setColor(new float[]{ 0.6f, 0.45f, 0.3f, 1.f });
+    }
+
+    public void setIntensity(final float intensity) {
+        mIntensity = intensity;
+        setFloat(mIntensityLocation, mIntensity);
+    }
+    
+    public void setColor(final float[] color) {
+        mColor = color;
+        setColorRed(mColor[0], mColor[1], mColor[2]);
+        
+    }
+    
+    public void setColorRed(final float red, final float green, final float blue) {
+        setFloatVec3(mFilterColorLocation, new float[]{ red, green, blue });
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMultiplyBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMultiplyBlendFilter.java
new file mode 100644
index 00000000..1e002e36
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageMultiplyBlendFilter.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageMultiplyBlendFilter extends GPUImageTwoInputFilter {
+    public static final String MULTIPLY_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2;\n" +
+            "\n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     lowp vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "     lowp vec4 overlayer = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+            "          \n" +
+            "     gl_FragColor = overlayer * base + overlayer * (1.0 - base.a) + base * (1.0 - overlayer.a);\n" +
+            " }";
+
+    public GPUImageMultiplyBlendFilter() {
+        super(MULTIPLY_BLEND_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNonMaximumSuppressionFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNonMaximumSuppressionFilter.java
new file mode 100644
index 00000000..a6f5af48
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNonMaximumSuppressionFilter.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageNonMaximumSuppressionFilter extends GPUImage3x3TextureSamplingFilter {
+    public static final String NMS_FRAGMENT_SHADER = "" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "varying highp vec2 leftTextureCoordinate;\n" +
+            "varying highp vec2 rightTextureCoordinate;\n" +
+            "\n" +
+            "varying highp vec2 topTextureCoordinate;\n" +
+            "varying highp vec2 topLeftTextureCoordinate;\n" +
+            "varying highp vec2 topRightTextureCoordinate;\n" +
+            "\n" +
+            "varying highp vec2 bottomTextureCoordinate;\n" +
+            "varying highp vec2 bottomLeftTextureCoordinate;\n" +
+            "varying highp vec2 bottomRightTextureCoordinate;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "lowp float bottomColor = texture2D(inputImageTexture, bottomTextureCoordinate).r;\n" +
+            "lowp float bottomLeftColor = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n" +
+            "lowp float bottomRightColor = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n" +
+            "lowp vec4 centerColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "lowp float leftColor = texture2D(inputImageTexture, leftTextureCoordinate).r;\n" +
+            "lowp float rightColor = texture2D(inputImageTexture, rightTextureCoordinate).r;\n" +
+            "lowp float topColor = texture2D(inputImageTexture, topTextureCoordinate).r;\n" +
+            "lowp float topRightColor = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n" +
+            "lowp float topLeftColor = texture2D(inputImageTexture, topLeftTextureCoordinate).r;\n" +
+            "\n" +
+            "// Use a tiebreaker for pixels to the left and immediately above this one\n" +
+            "lowp float multiplier = 1.0 - step(centerColor.r, topColor);\n" +
+            "multiplier = multiplier * 1.0 - step(centerColor.r, topLeftColor);\n" +
+            "multiplier = multiplier * 1.0 - step(centerColor.r, leftColor);\n" +
+            "multiplier = multiplier * 1.0 - step(centerColor.r, bottomLeftColor);\n" +
+            "\n" +
+            "lowp float maxValue = max(centerColor.r, bottomColor);\n" +
+            "maxValue = max(maxValue, bottomRightColor);\n" +
+            "maxValue = max(maxValue, rightColor);\n" +
+            "maxValue = max(maxValue, topRightColor);\n" +
+            "\n" +
+            "gl_FragColor = vec4((centerColor.rgb * step(maxValue, centerColor.r) * multiplier), 1.0);\n" +
+            "}\n";
+
+    public GPUImageNonMaximumSuppressionFilter() {
+        super(NMS_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNormalBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNormalBlendFilter.java
new file mode 100644
index 00000000..a886bd40
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageNormalBlendFilter.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+/**
+ * This equation is a simplification of the general blending equation. It assumes the destination color is opaque, and therefore drops the destination color's alpha term.
+ *
+ * D = C1 * C1a + C2 * C2a * (1 - C1a)
+ * where D is the resultant color, C1 is the color of the first element, C1a is the alpha of the first element, C2 is the second element color, C2a is the alpha of the second element. The destination alpha is calculated with:
+ *
+ * Da = C1a + C2a * (1 - C1a)
+ * The resultant color is premultiplied with the alpha. To restore the color to the unmultiplied values, just divide by Da, the resultant alpha.
+ *
+ * http://stackoverflow.com/questions/1724946/blend-mode-on-a-transparent-and-semi-transparent-background
+ *
+ * For some reason Photoshop behaves
+ * D = C1 + C2 * C2a * (1 - C1a)
+ */
+public class GPUImageNormalBlendFilter extends GPUImageTwoInputFilter {
+    public static final String NORMAL_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     lowp vec4 c2 = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "\t lowp vec4 c1 = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+            "     \n" +
+            "     lowp vec4 outputColor;\n" +
+            "     \n" +
+            "     outputColor.r = c1.r + c2.r * c2.a * (1.0 - c1.a);\n" +
+            "\n" +
+            "     outputColor.g = c1.g + c2.g * c2.a * (1.0 - c1.a);\n" +
+            "     \n" +
+            "     outputColor.b = c1.b + c2.b * c2.a * (1.0 - c1.a);\n" +
+            "     \n" +
+            "     outputColor.a = c1.a + c2.a * (1.0 - c1.a);\n" +
+            "     \n" +
+            "     gl_FragColor = outputColor;\n" +
+            " }";
+
+    public GPUImageNormalBlendFilter() {
+        super(NORMAL_BLEND_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageOpacityFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageOpacityFilter.java
new file mode 100644
index 00000000..55f198d1
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageOpacityFilter.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+/**
+ * Adjusts the alpha channel of the incoming image
+ * opacity: The value to multiply the incoming alpha channel for each pixel by (0.0 - 1.0, with 1.0 as the default)
+*/
+public class GPUImageOpacityFilter extends GPUImageFilter {
+    public static final String OPACITY_FRAGMENT_SHADER = "" +
+            "  varying highp vec2 textureCoordinate;\n" +
+            "  \n" +
+            "  uniform sampler2D inputImageTexture;\n" +
+            "  uniform lowp float opacity;\n" +
+            "  \n" +
+            "  void main()\n" +
+            "  {\n" +
+            "      lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "      \n" +
+            "      gl_FragColor = vec4(textureColor.rgb, textureColor.a * opacity);\n" +
+            "  }\n";
+
+    private int mOpacityLocation;
+    private float mOpacity;
+
+    public GPUImageOpacityFilter() {
+        this(1.0f);
+    }
+
+    public GPUImageOpacityFilter(final float opacity) {
+        super(NO_FILTER_VERTEX_SHADER, OPACITY_FRAGMENT_SHADER);
+        mOpacity = opacity;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mOpacityLocation = GLES20.glGetUniformLocation(getProgram(), "opacity");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setOpacity(mOpacity);
+    }
+
+    public void setOpacity(final float opacity) {
+        mOpacity = opacity;
+        setFloat(mOpacityLocation, mOpacity);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageOverlayBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageOverlayBlendFilter.java
new file mode 100644
index 00000000..4dba4200
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageOverlayBlendFilter.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageOverlayBlendFilter extends GPUImageTwoInputFilter {
+    public static final String OVERLAY_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2;\n" +
+            "\n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     mediump vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "     mediump vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+            "     \n" +
+            "     mediump float ra;\n" +
+            "     if (2.0 * base.r < base.a) {\n" +
+            "         ra = 2.0 * overlay.r * base.r + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n" +
+            "     } else {\n" +
+            "         ra = overlay.a * base.a - 2.0 * (base.a - base.r) * (overlay.a - overlay.r) + overlay.r * (1.0 - base.a) + base.r * (1.0 - overlay.a);\n" +
+            "     }\n" +
+            "     \n" +
+            "     mediump float ga;\n" +
+            "     if (2.0 * base.g < base.a) {\n" +
+            "         ga = 2.0 * overlay.g * base.g + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n" +
+            "     } else {\n" +
+            "         ga = overlay.a * base.a - 2.0 * (base.a - base.g) * (overlay.a - overlay.g) + overlay.g * (1.0 - base.a) + base.g * (1.0 - overlay.a);\n" +
+            "     }\n" +
+            "     \n" +
+            "     mediump float ba;\n" +
+            "     if (2.0 * base.b < base.a) {\n" +
+            "         ba = 2.0 * overlay.b * base.b + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n" +
+            "     } else {\n" +
+            "         ba = overlay.a * base.a - 2.0 * (base.a - base.b) * (overlay.a - overlay.b) + overlay.b * (1.0 - base.a) + base.b * (1.0 - overlay.a);\n" +
+            "     }\n" +
+            "     \n" +
+            "     gl_FragColor = vec4(ra, ga, ba, 1.0);\n" +
+            " }";
+
+    public GPUImageOverlayBlendFilter() {
+        super(OVERLAY_BLEND_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImagePixelationFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImagePixelationFilter.java
new file mode 100644
index 00000000..c0ec15d1
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImagePixelationFilter.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+/**
+ * Applies a grayscale effect to the image.
+ */
+public class GPUImagePixelationFilter extends GPUImageFilter {
+    public static final String PIXELATION_FRAGMENT_SHADER = "" +
+            "precision highp float;\n" +
+
+            "varying vec2 textureCoordinate;\n" +
+
+            "uniform float imageWidthFactor;\n" +
+            "uniform float imageHeightFactor;\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "uniform float pixel;\n" +
+
+            "void main()\n" +
+            "{\n" +
+            "  vec2 uv  = textureCoordinate.xy;\n" +
+            "  float dx = pixel * imageWidthFactor;\n" +
+            "  float dy = pixel * imageHeightFactor;\n" +
+            "  vec2 coord = vec2(dx * floor(uv.x / dx), dy * floor(uv.y / dy));\n" +
+            "  vec3 tc = texture2D(inputImageTexture, coord).xyz;\n" +
+            "  gl_FragColor = vec4(tc, 1.0);\n" +
+            "}";
+
+    private int mImageWidthFactorLocation;
+    private int mImageHeightFactorLocation;
+    private float mPixel;
+    private int mPixelLocation;
+    
+    public GPUImagePixelationFilter() {
+        super(NO_FILTER_VERTEX_SHADER, PIXELATION_FRAGMENT_SHADER);
+        mPixel = 1.0f;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mImageWidthFactorLocation = GLES20.glGetUniformLocation(getProgram(), "imageWidthFactor");
+        mImageHeightFactorLocation = GLES20.glGetUniformLocation(getProgram(), "imageHeightFactor");
+        mPixelLocation = GLES20.glGetUniformLocation(getProgram(), "pixel");
+        setPixel(mPixel);
+    }
+
+    @Override
+    public void onOutputSizeChanged(final int width, final int height) {
+        super.onOutputSizeChanged(width, height);
+        setFloat(mImageWidthFactorLocation, 1.0f / width);
+        setFloat(mImageHeightFactorLocation, 1.0f / height);
+    }
+
+    public void setPixel(final float pixel) {
+      mPixel = pixel;
+      setFloat(mPixelLocation, mPixel);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRGBDilationFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRGBDilationFilter.java
new file mode 100644
index 00000000..2d5e28c7
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRGBDilationFilter.java
@@ -0,0 +1,301 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+/**
+ * For each pixel, this sets it to the maximum value of each color channel in a rectangular neighborhood extending
+ * out dilationRadius pixels from the center.
+ * This extends out brighter colors, and can be used for abstraction of color images.
+ */
+public class GPUImageRGBDilationFilter extends GPUImageTwoPassTextureSamplingFilter {
+    public static final String VERTEX_SHADER_1 =
+            "attribute vec4 position;\n" +
+                    "attribute vec2 inputTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform float texelWidthOffset; \n" +
+                    "uniform float texelHeightOffset; \n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "gl_Position = position;\n" +
+                    "\n" +
+                    "vec2 offset = vec2(texelWidthOffset, texelHeightOffset);\n" +
+                    "\n" +
+                    "centerTextureCoordinate = inputTextureCoordinate;\n" +
+                    "oneStepNegativeTextureCoordinate = inputTextureCoordinate - offset;\n" +
+                    "oneStepPositiveTextureCoordinate = inputTextureCoordinate + offset;\n" +
+                    "}\n";
+
+    public static final String VERTEX_SHADER_2 =
+            "attribute vec4 position;\n" +
+                    "attribute vec2 inputTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform float texelWidthOffset;\n" +
+                    "uniform float texelHeightOffset;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "varying vec2 twoStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 twoStepsNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "gl_Position = position;\n" +
+                    "\n" +
+                    "vec2 offset = vec2(texelWidthOffset, texelHeightOffset);\n" +
+                    "\n" +
+                    "centerTextureCoordinate = inputTextureCoordinate;\n" +
+                    "oneStepNegativeTextureCoordinate = inputTextureCoordinate - offset;\n" +
+                    "oneStepPositiveTextureCoordinate = inputTextureCoordinate + offset;\n" +
+                    "twoStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 2.0);\n" +
+                    "twoStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 2.0);\n" +
+                    "}\n";
+
+    public static final String VERTEX_SHADER_3 =
+            "attribute vec4 position;\n" +
+                    "attribute vec2 inputTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform float texelWidthOffset;\n" +
+                    "uniform float texelHeightOffset;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "varying vec2 twoStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 twoStepsNegativeTextureCoordinate;\n" +
+                    "varying vec2 threeStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 threeStepsNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "gl_Position = position;\n" +
+                    "\n" +
+                    "vec2 offset = vec2(texelWidthOffset, texelHeightOffset);\n" +
+                    "\n" +
+                    "centerTextureCoordinate = inputTextureCoordinate;\n" +
+                    "oneStepNegativeTextureCoordinate = inputTextureCoordinate - offset;\n" +
+                    "oneStepPositiveTextureCoordinate = inputTextureCoordinate + offset;\n" +
+                    "twoStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 2.0);\n" +
+                    "twoStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 2.0);\n" +
+                    "threeStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 3.0);\n" +
+                    "threeStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 3.0);\n" +
+                    "}\n";
+
+    public static final String VERTEX_SHADER_4 =
+            "attribute vec4 position;\n" +
+                    "attribute vec2 inputTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform float texelWidthOffset;\n" +
+                    "uniform float texelHeightOffset;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "varying vec2 twoStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 twoStepsNegativeTextureCoordinate;\n" +
+                    "varying vec2 threeStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 threeStepsNegativeTextureCoordinate;\n" +
+                    "varying vec2 fourStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 fourStepsNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "gl_Position = position;\n" +
+                    "\n" +
+                    "vec2 offset = vec2(texelWidthOffset, texelHeightOffset);\n" +
+                    "\n" +
+                    "centerTextureCoordinate = inputTextureCoordinate;\n" +
+                    "oneStepNegativeTextureCoordinate = inputTextureCoordinate - offset;\n" +
+                    "oneStepPositiveTextureCoordinate = inputTextureCoordinate + offset;\n" +
+                    "twoStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 2.0);\n" +
+                    "twoStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 2.0);\n" +
+                    "threeStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 3.0);\n" +
+                    "threeStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 3.0);\n" +
+                    "fourStepsNegativeTextureCoordinate = inputTextureCoordinate - (offset * 4.0);\n" +
+                    "fourStepsPositiveTextureCoordinate = inputTextureCoordinate + (offset * 4.0);\n" +
+                    "}\n";
+
+
+    public static final String FRAGMENT_SHADER_1 =
+            "precision highp float;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform sampler2D inputImageTexture;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "lowp vec4 centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate);\n" +
+                    "lowp vec4 oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate);\n" +
+                    "lowp vec4 oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate);\n" +
+                    "\n" +
+                    "lowp vec4 maxValue = max(centerIntensity, oneStepPositiveIntensity);\n" +
+                    "\n" +
+                    "gl_FragColor = max(maxValue, oneStepNegativeIntensity);\n" +
+                    "}\n";
+
+    public static final String FRAGMENT_SHADER_2 =
+            "precision highp float;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "varying vec2 twoStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 twoStepsNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform sampler2D inputImageTexture;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "lowp vec4 centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate);\n" +
+                    "lowp vec4 oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate);\n" +
+                    "lowp vec4 oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate);\n" +
+                    "lowp vec4 twoStepsPositiveIntensity = texture2D(inputImageTexture, twoStepsPositiveTextureCoordinate);\n" +
+                    "lowp vec4 twoStepsNegativeIntensity = texture2D(inputImageTexture, twoStepsNegativeTextureCoordinate);\n" +
+                    "\n" +
+                    "lowp vec4 maxValue = max(centerIntensity, oneStepPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, oneStepNegativeIntensity);\n" +
+                    "maxValue = max(maxValue, twoStepsPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, twoStepsNegativeIntensity);\n" +
+                    "\n" +
+                    "gl_FragColor = max(maxValue, twoStepsNegativeIntensity);\n" +
+                    "}\n";
+
+    public static final String FRAGMENT_SHADER_3 =
+            "precision highp float;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "varying vec2 twoStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 twoStepsNegativeTextureCoordinate;\n" +
+                    "varying vec2 threeStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 threeStepsNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform sampler2D inputImageTexture;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "lowp vec4 centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate);\n" +
+                    "lowp vec4 oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate);\n" +
+                    "lowp vec4 oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate);\n" +
+                    "lowp vec4 twoStepsPositiveIntensity = texture2D(inputImageTexture, twoStepsPositiveTextureCoordinate);\n" +
+                    "lowp vec4 twoStepsNegativeIntensity = texture2D(inputImageTexture, twoStepsNegativeTextureCoordinate);\n" +
+                    "lowp vec4 threeStepsPositiveIntensity = texture2D(inputImageTexture, threeStepsPositiveTextureCoordinate);\n" +
+                    "lowp vec4 threeStepsNegativeIntensity = texture2D(inputImageTexture, threeStepsNegativeTextureCoordinate);\n" +
+                    "\n" +
+                    "lowp vec4 maxValue = max(centerIntensity, oneStepPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, oneStepNegativeIntensity);\n" +
+                    "maxValue = max(maxValue, twoStepsPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, twoStepsNegativeIntensity);\n" +
+                    "maxValue = max(maxValue, threeStepsPositiveIntensity);\n" +
+                    "\n" +
+                    "gl_FragColor = max(maxValue, threeStepsNegativeIntensity);\n" +
+                    "}\n";
+
+    public static final String FRAGMENT_SHADER_4 =
+            "precision highp float;\n" +
+                    "\n" +
+                    "varying vec2 centerTextureCoordinate;\n" +
+                    "varying vec2 oneStepPositiveTextureCoordinate;\n" +
+                    "varying vec2 oneStepNegativeTextureCoordinate;\n" +
+                    "varying vec2 twoStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 twoStepsNegativeTextureCoordinate;\n" +
+                    "varying vec2 threeStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 threeStepsNegativeTextureCoordinate;\n" +
+                    "varying vec2 fourStepsPositiveTextureCoordinate;\n" +
+                    "varying vec2 fourStepsNegativeTextureCoordinate;\n" +
+                    "\n" +
+                    "uniform sampler2D inputImageTexture;\n" +
+                    "\n" +
+                    "void main()\n" +
+                    "{\n" +
+                    "lowp vec4 centerIntensity = texture2D(inputImageTexture, centerTextureCoordinate);\n" +
+                    "lowp vec4 oneStepPositiveIntensity = texture2D(inputImageTexture, oneStepPositiveTextureCoordinate);\n" +
+                    "lowp vec4 oneStepNegativeIntensity = texture2D(inputImageTexture, oneStepNegativeTextureCoordinate);\n" +
+                    "lowp vec4 twoStepsPositiveIntensity = texture2D(inputImageTexture, twoStepsPositiveTextureCoordinate);\n" +
+                    "lowp vec4 twoStepsNegativeIntensity = texture2D(inputImageTexture, twoStepsNegativeTextureCoordinate);\n" +
+                    "lowp vec4 threeStepsPositiveIntensity = texture2D(inputImageTexture, threeStepsPositiveTextureCoordinate);\n" +
+                    "lowp vec4 threeStepsNegativeIntensity = texture2D(inputImageTexture, threeStepsNegativeTextureCoordinate);\n" +
+                    "lowp vec4 fourStepsPositiveIntensity = texture2D(inputImageTexture, fourStepsPositiveTextureCoordinate);\n" +
+                    "lowp vec4 fourStepsNegativeIntensity = texture2D(inputImageTexture, fourStepsNegativeTextureCoordinate);\n" +
+                    "\n" +
+                    "lowp vec4 maxValue = max(centerIntensity, oneStepPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, oneStepNegativeIntensity);\n" +
+                    "maxValue = max(maxValue, twoStepsPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, twoStepsNegativeIntensity);\n" +
+                    "maxValue = max(maxValue, threeStepsPositiveIntensity);\n" +
+                    "maxValue = max(maxValue, threeStepsNegativeIntensity);\n" +
+                    "maxValue = max(maxValue, fourStepsPositiveIntensity);\n" +
+                    "\n" +
+                    "gl_FragColor = max(maxValue, fourStepsNegativeIntensity);\n" +
+                    "}\n";
+
+
+    public GPUImageRGBDilationFilter() {
+        this(1);
+    }
+
+    /**
+     * Acceptable values for dilationRadius, which sets the distance in pixels to sample out
+     * from the center, are 1, 2, 3, and 4.
+     *
+     * @param radius 1, 2, 3 or 4
+     */
+    public GPUImageRGBDilationFilter(int radius) {
+        this(getVertexShader(radius), getFragmentShader(radius));
+    }
+
+    private GPUImageRGBDilationFilter(String vertexShader, String fragmentShader) {
+        super(vertexShader, fragmentShader, vertexShader, fragmentShader);
+    }
+
+    private static String getVertexShader(int radius) {
+        switch (radius) {
+            case 0:
+            case 1:
+                return VERTEX_SHADER_1;
+            case 2:
+                return VERTEX_SHADER_2;
+            case 3:
+                return VERTEX_SHADER_3;
+            default:
+                return VERTEX_SHADER_4;
+        }
+    }
+
+    private static String getFragmentShader(int radius) {
+        switch (radius) {
+            case 0:
+            case 1:
+                return FRAGMENT_SHADER_1;
+            case 2:
+                return FRAGMENT_SHADER_2;
+            case 3:
+                return FRAGMENT_SHADER_3;
+            default:
+                return FRAGMENT_SHADER_4;
+        }
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRGBFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRGBFilter.java
new file mode 100644
index 00000000..f0af18cb
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRGBFilter.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+/**
+ * Adjusts the individual RGB channels of an image
+ * red: Normalized values by which each color channel is multiplied. The range is from 0.0 up, with 1.0 as the default.
+ * green:
+ * blue:
+ */
+public class GPUImageRGBFilter extends GPUImageFilter {
+    public static final String RGB_FRAGMENT_SHADER = "" +
+    		"  varying highp vec2 textureCoordinate;\n" +
+    		"  \n" +
+    		"  uniform sampler2D inputImageTexture;\n" +
+    		"  uniform highp float red;\n" +
+    		"  uniform highp float green;\n" +
+    		"  uniform highp float blue;\n" +
+    		"  \n" +
+    		"  void main()\n" +
+    		"  {\n" +
+    		"      highp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+    		"      \n" +
+    		"      gl_FragColor = vec4(textureColor.r * red, textureColor.g * green, textureColor.b * blue, 1.0);\n" +
+    		"  }\n";
+
+    private int mRedLocation;
+    private float mRed;
+    private int mGreenLocation;
+    private float mGreen;
+    private int mBlueLocation;
+    private float mBlue;
+    private boolean mIsInitialized = false;
+
+    public GPUImageRGBFilter() {
+        this(1.0f, 1.0f, 1.0f);
+    }
+
+    public GPUImageRGBFilter(final float red, final float green, final float blue) {
+        super(NO_FILTER_VERTEX_SHADER, RGB_FRAGMENT_SHADER);
+        mRed = red;
+        mGreen = green;
+        mBlue = blue;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mRedLocation = GLES20.glGetUniformLocation(getProgram(), "red");
+        mGreenLocation = GLES20.glGetUniformLocation(getProgram(), "green");
+        mBlueLocation = GLES20.glGetUniformLocation(getProgram(), "blue");
+        mIsInitialized = true;
+        setRed(mRed);
+        setGreen(mGreen);
+        setBlue(mBlue);
+    }
+
+    public void setRed(final float red) {
+        mRed = red;
+        if (mIsInitialized) {
+            setFloat(mRedLocation, mRed);
+        }
+    }
+    
+    public void setGreen(final float green) {
+        mGreen = green;
+        if (mIsInitialized) {
+            setFloat(mGreenLocation, mGreen);
+        }
+    }
+    
+    public void setBlue(final float blue) {
+        mBlue = blue;
+        if (mIsInitialized) {
+            setFloat(mBlueLocation, mBlue);
+        }
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
index 473d3111..9565b71c 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageRenderer.java
@@ -16,17 +16,6 @@
 
 package jp.co.cyberagent.android.gpuimage;
 
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.ByteOrder;
-import java.nio.FloatBuffer;
-import java.nio.IntBuffer;
-import java.util.LinkedList;
-import java.util.Queue;
-
-import javax.microedition.khronos.egl.EGLConfig;
-import javax.microedition.khronos.opengles.GL10;
-
 import android.annotation.TargetApi;
 import android.graphics.Bitmap;
 import android.graphics.Canvas;
@@ -37,44 +26,34 @@
 import android.opengl.GLES20;
 import android.opengl.GLSurfaceView.Renderer;
 
+import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
+
+import javax.microedition.khronos.egl.EGLConfig;
+import javax.microedition.khronos.opengles.GL10;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.FloatBuffer;
+import java.nio.IntBuffer;
+import java.util.LinkedList;
+import java.util.Queue;
+
+import static jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil.TEXTURE_NO_ROTATION;
+
 @TargetApi(11)
 public class GPUImageRenderer implements Renderer, PreviewCallback {
     public static final int NO_IMAGE = -1;
     static final float CUBE[] = {
-            -1.0f, 1.0f,
-            1.0f, 1.0f,
             -1.0f, -1.0f,
             1.0f, -1.0f,
-    };
-
-    static final float TEXTURE_NO_ROTATION[] = {
-            0.0f, 1.0f,
-            1.0f, 1.0f,
-            0.0f, 0.0f,
-            1.0f, 0.0f,
-    };
-
-    private static final float TEXTURE_ROTATED_90[] = {
-            1.0f, 1.0f,
-            1.0f, 0.0f,
-            0.0f, 1.0f,
-            0.0f, 0.0f,
-    };
-    private static final float TEXTURE_ROTATED_180[] = {
-            1.0f, 0.0f,
-            0.0f, 0.0f,
-            1.0f, 1.0f,
-            0.0f, 1.0f,
-    };
-    private static final float TEXTURE_ROTATED_270[] = {
-            0.0f, 0.0f,
-            0.0f, 1.0f,
-            1.0f, 0.0f,
+            -1.0f, 1.0f,
             1.0f, 1.0f,
     };
 
     private GPUImageFilter mFilter;
 
+    public final Object mSurfaceChangedWaiter = new Object();
+
     private int mGLTextureId = NO_IMAGE;
     private SurfaceTexture mSurfaceTexture = null;
     private final FloatBuffer mGLCubeBuffer;
@@ -88,13 +67,16 @@
     private int mAddedPadding;
 
     private final Queue<Runnable> mRunOnDraw;
+    private final Queue<Runnable> mRunOnDrawEnd;
     private Rotation mRotation;
     private boolean mFlipHorizontal;
     private boolean mFlipVertical;
+    private GPUImage.ScaleType mScaleType = GPUImage.ScaleType.CENTER_CROP;
 
     public GPUImageRenderer(final GPUImageFilter filter) {
         mFilter = filter;
         mRunOnDraw = new LinkedList<Runnable>();
+        mRunOnDrawEnd = new LinkedList<Runnable>();
 
         mGLCubeBuffer = ByteBuffer.allocateDirect(CUBE.length * 4)
                 .order(ByteOrder.nativeOrder())
@@ -111,7 +93,7 @@ public GPUImageRenderer(final GPUImageFilter filter) {
     public void onSurfaceCreated(final GL10 unused, final EGLConfig config) {
         GLES20.glClearColor(0, 0, 0, 1);
         GLES20.glDisable(GLES20.GL_DEPTH_TEST);
-        mFilter.onInit();
+        mFilter.init();
     }
 
     @Override
@@ -121,22 +103,31 @@ public void onSurfaceChanged(final GL10 gl, final int width, final int height) {
         GLES20.glViewport(0, 0, width, height);
         GLES20.glUseProgram(mFilter.getProgram());
         mFilter.onOutputSizeChanged(width, height);
+        adjustImageScaling();
+        synchronized (mSurfaceChangedWaiter) {
+            mSurfaceChangedWaiter.notifyAll();
+        }
     }
 
     @Override
     public void onDrawFrame(final GL10 gl) {
         GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);
-        synchronized (mRunOnDraw) {
-            while (!mRunOnDraw.isEmpty()) {
-                mRunOnDraw.poll().run();
-            }
-        }
+        runAll(mRunOnDraw);
         mFilter.onDraw(mGLTextureId, mGLCubeBuffer, mGLTextureBuffer);
-        if (false || mSurfaceTexture != null) {
+        runAll(mRunOnDrawEnd);
+        if (mSurfaceTexture != null) {
             mSurfaceTexture.updateTexImage();
         }
     }
 
+    private void runAll(Queue<Runnable> queue) {
+        synchronized (queue) {
+            while (!queue.isEmpty()) {
+                queue.poll().run();
+            }
+        }
+    }
+
     @Override
     public void onPreviewFrame(final byte[] data, final Camera camera) {
         final Size previewSize = camera.getParameters().getPreviewSize();
@@ -188,9 +179,9 @@ public void run() {
                 final GPUImageFilter oldFilter = mFilter;
                 mFilter = filter;
                 if (oldFilter != null) {
-                    oldFilter.onDestroy();
+                    oldFilter.destroy();
                 }
-                mFilter.onInit();
+                mFilter.init();
                 GLES20.glUseProgram(mFilter.getProgram());
                 mFilter.onOutputSizeChanged(mOutputWidth, mOutputHeight);
             }
@@ -202,7 +193,7 @@ public void deleteImage() {
 
             @Override
             public void run() {
-                GLES20.glDeleteTextures(1, new int[] {
+                GLES20.glDeleteTextures(1, new int[]{
                         mGLTextureId
                 }, 0);
                 mGLTextureId = NO_IMAGE;
@@ -215,6 +206,10 @@ public void setImageBitmap(final Bitmap bitmap) {
     }
 
     public void setImageBitmap(final Bitmap bitmap, final boolean recycle) {
+        if (bitmap == null) {
+            return;
+        }
+
         runOnDraw(new Runnable() {
 
             @Override
@@ -243,6 +238,10 @@ public void run() {
         });
     }
 
+    public void setScaleType(GPUImage.ScaleType scaleType) {
+        mScaleType = scaleType;
+    }
+
     protected int getFrameWidth() {
         return mOutputWidth;
     }
@@ -261,75 +260,58 @@ private void adjustImageScaling() {
 
         float ratio1 = outputWidth / mImageWidth;
         float ratio2 = outputHeight / mImageHeight;
-        float ratioMin = Math.min(ratio1, ratio2);
-        mImageWidth = Math.round(mImageWidth * ratioMin);
-        mImageHeight = Math.round(mImageHeight * ratioMin);
-
-        float ratioWidth = 1.0f;
-        float ratioHeight = 1.0f;
-        if (mImageWidth != outputWidth) {
-            ratioWidth = mImageWidth / outputWidth;
-        } else if (mImageHeight != outputHeight) {
-            ratioHeight = mImageHeight / outputHeight;
+        float ratioMax = Math.max(ratio1, ratio2);
+        int imageWidthNew = Math.round(mImageWidth * ratioMax);
+        int imageHeightNew = Math.round(mImageHeight * ratioMax);
+
+        float ratioWidth = imageWidthNew / outputWidth;
+        float ratioHeight = imageHeightNew / outputHeight;
+
+        float[] cube = CUBE;
+        float[] textureCords = TextureRotationUtil.getRotation(mRotation, mFlipHorizontal, mFlipVertical);
+        if (mScaleType == GPUImage.ScaleType.CENTER_CROP) {
+            float distHorizontal = (1 - 1 / ratioWidth) / 2;
+            float distVertical = (1 - 1 / ratioHeight) / 2;
+            textureCords = new float[]{
+                    addDistance(textureCords[0], distHorizontal), addDistance(textureCords[1], distVertical),
+                    addDistance(textureCords[2], distHorizontal), addDistance(textureCords[3], distVertical),
+                    addDistance(textureCords[4], distHorizontal), addDistance(textureCords[5], distVertical),
+                    addDistance(textureCords[6], distHorizontal), addDistance(textureCords[7], distVertical),
+            };
+        } else {
+            cube = new float[]{
+                    CUBE[0] / ratioHeight, CUBE[1] / ratioWidth,
+                    CUBE[2] / ratioHeight, CUBE[3] / ratioWidth,
+                    CUBE[4] / ratioHeight, CUBE[5] / ratioWidth,
+                    CUBE[6] / ratioHeight, CUBE[7] / ratioWidth,
+            };
         }
 
-        // for some reason we need to do minus on the right side. Otherwise it
-        // is always flipped vertically
-        float cube[] = {
-                CUBE[0] * ratioWidth, -CUBE[1] * ratioHeight,
-                CUBE[2] * ratioWidth, -CUBE[3] * ratioHeight,
-                CUBE[4] * ratioWidth, -CUBE[5] * ratioHeight,
-                CUBE[6] * ratioWidth, -CUBE[7] * ratioHeight,
-        };
         mGLCubeBuffer.clear();
         mGLCubeBuffer.put(cube).position(0);
+        mGLTextureBuffer.clear();
+        mGLTextureBuffer.put(textureCords).position(0);
     }
 
-    public enum Rotation {
-        NORMAL, ROTATION_90, ROTATION_180, ROTATION_270
+    private float addDistance(float coordinate, float distance) {
+        return coordinate == 0.0f ? distance : 1 - distance;
     }
 
-    public void setRotation(final Rotation rotation, final boolean flipHorizontal,
+    public void setRotationCamera(final Rotation rotation, final boolean flipHorizontal,
             final boolean flipVertical) {
+        setRotation(rotation, flipVertical, flipHorizontal);
+    }
+
+    public void setRotation(final Rotation rotation) {
         mRotation = rotation;
+        adjustImageScaling();
+    }
+
+    public void setRotation(final Rotation rotation,
+                            final boolean flipHorizontal, final boolean flipVertical) {
         mFlipHorizontal = flipHorizontal;
         mFlipVertical = flipVertical;
-
-        float[] rotatedTex = null;
-        switch (rotation) {
-            case ROTATION_90:
-                rotatedTex = TEXTURE_ROTATED_90;
-                break;
-            case ROTATION_180:
-                rotatedTex = TEXTURE_ROTATED_180;
-                break;
-            case ROTATION_270:
-                rotatedTex = TEXTURE_ROTATED_270;
-                break;
-            case NORMAL:
-            default:
-                rotatedTex = TEXTURE_NO_ROTATION;
-                break;
-        }
-        if (flipHorizontal) {
-            rotatedTex = new float[] {
-                    rotatedTex[0], flip(rotatedTex[1]),
-                    rotatedTex[2], flip(rotatedTex[3]),
-                    rotatedTex[4], flip(rotatedTex[5]),
-                    rotatedTex[6], flip(rotatedTex[7]),
-            };
-        }
-        if (flipVertical) {
-            rotatedTex = new float[] {
-                    flip(rotatedTex[0]), rotatedTex[1],
-                    flip(rotatedTex[2]), rotatedTex[3],
-                    flip(rotatedTex[4]), rotatedTex[5],
-                    flip(rotatedTex[6]), rotatedTex[7],
-            };
-        }
-
-        mGLTextureBuffer.clear();
-        mGLTextureBuffer.put(rotatedTex).position(0);
+        setRotation(rotation);
     }
 
     public Rotation getRotation() {
@@ -344,16 +326,15 @@ public boolean isFlippedVertically() {
         return mFlipVertical;
     }
 
-    private float flip(final float i) {
-        if (i == 0.0f) {
-            return 1.0f;
-        }
-        return 0.0f;
-    }
-
     protected void runOnDraw(final Runnable runnable) {
         synchronized (mRunOnDraw) {
             mRunOnDraw.add(runnable);
         }
     }
+
+    protected void runOnDrawEnd(final Runnable runnable) {
+        synchronized (mRunOnDrawEnd) {
+            mRunOnDrawEnd.add(runnable);
+        }
+    }
 }
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSaturationBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSaturationBlendFilter.java
new file mode 100644
index 00000000..1c0f90d6
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSaturationBlendFilter.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageSaturationBlendFilter extends GPUImageTwoInputFilter {
+    public static final String SATURATION_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " \n" +
+            " highp float lum(lowp vec3 c) {\n" +
+            "     return dot(c, vec3(0.3, 0.59, 0.11));\n" +
+            " }\n" +
+            " \n" +
+            " lowp vec3 clipcolor(lowp vec3 c) {\n" +
+            "     highp float l = lum(c);\n" +
+            "     lowp float n = min(min(c.r, c.g), c.b);\n" +
+            "     lowp float x = max(max(c.r, c.g), c.b);\n" +
+            "     \n" +
+            "     if (n < 0.0) {\n" +
+            "         c.r = l + ((c.r - l) * l) / (l - n);\n" +
+            "         c.g = l + ((c.g - l) * l) / (l - n);\n" +
+            "         c.b = l + ((c.b - l) * l) / (l - n);\n" +
+            "     }\n" +
+            "     if (x > 1.0) {\n" +
+            "         c.r = l + ((c.r - l) * (1.0 - l)) / (x - l);\n" +
+            "         c.g = l + ((c.g - l) * (1.0 - l)) / (x - l);\n" +
+            "         c.b = l + ((c.b - l) * (1.0 - l)) / (x - l);\n" +
+            "     }\n" +
+            "     \n" +
+            "     return c;\n" +
+            " }\n" +
+            " \n" +
+            " lowp vec3 setlum(lowp vec3 c, highp float l) {\n" +
+            "     highp float d = l - lum(c);\n" +
+            "     c = c + vec3(d);\n" +
+            "     return clipcolor(c);\n" +
+            " }\n" +
+            " \n" +
+            " highp float sat(lowp vec3 c) {\n" +
+            "     lowp float n = min(min(c.r, c.g), c.b);\n" +
+            "     lowp float x = max(max(c.r, c.g), c.b);\n" +
+            "     return x - n;\n" +
+            " }\n" +
+            " \n" +
+            " lowp float mid(lowp float cmin, lowp float cmid, lowp float cmax, highp float s) {\n" +
+            "     return ((cmid - cmin) * s) / (cmax - cmin);\n" +
+            " }\n" +
+            " \n" +
+            " lowp vec3 setsat(lowp vec3 c, highp float s) {\n" +
+            "     if (c.r > c.g) {\n" +
+            "         if (c.r > c.b) {\n" +
+            "             if (c.g > c.b) {\n" +
+            "                 /* g is mid, b is min */\n" +
+            "                 c.g = mid(c.b, c.g, c.r, s);\n" +
+            "                 c.b = 0.0;\n" +
+            "             } else {\n" +
+            "                 /* b is mid, g is min */\n" +
+            "                 c.b = mid(c.g, c.b, c.r, s);\n" +
+            "                 c.g = 0.0;\n" +
+            "             }\n" +
+            "             c.r = s;\n" +
+            "         } else {\n" +
+            "             /* b is max, r is mid, g is min */\n" +
+            "             c.r = mid(c.g, c.r, c.b, s);\n" +
+            "             c.b = s;\n" +
+            "             c.r = 0.0;\n" +
+            "         }\n" +
+            "     } else if (c.r > c.b) {\n" +
+            "         /* g is max, r is mid, b is min */\n" +
+            "         c.r = mid(c.b, c.r, c.g, s);\n" +
+            "         c.g = s;\n" +
+            "         c.b = 0.0;\n" +
+            "     } else if (c.g > c.b) {\n" +
+            "         /* g is max, b is mid, r is min */\n" +
+            "         c.b = mid(c.r, c.b, c.g, s);\n" +
+            "         c.g = s;\n" +
+            "         c.r = 0.0;\n" +
+            "     } else if (c.b > c.g) {\n" +
+            "         /* b is max, g is mid, r is min */\n" +
+            "         c.g = mid(c.r, c.g, c.b, s);\n" +
+            "         c.b = s;\n" +
+            "         c.r = 0.0;\n" +
+            "     } else {\n" +
+            "         c = vec3(0.0);\n" +
+            "     }\n" +
+            "     return c;\n" +
+            " }\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "   highp vec4 baseColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "   highp vec4 overlayColor = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+            "     \n" +
+            "     gl_FragColor = vec4(baseColor.rgb * (1.0 - overlayColor.a) + setlum(setsat(baseColor.rgb, sat(overlayColor.rgb)), lum(baseColor.rgb)) * overlayColor.a, baseColor.a);\n" +
+            " }";
+
+    public GPUImageSaturationBlendFilter() {
+        super(SATURATION_BLEND_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSaturationFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSaturationFilter.java
new file mode 100644
index 00000000..0725953d
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSaturationFilter.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+/**
+ * saturation: The degree of saturation or desaturation to apply to the image (0.0 - 2.0, with 1.0 as the default)
+ */
+public class GPUImageSaturationFilter extends GPUImageFilter {
+    public static final String SATURATION_FRAGMENT_SHADER = "" +
+            " varying highp vec2 textureCoordinate;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform lowp float saturation;\n" +
+            " \n" +
+            " // Values from \"Graphics Shaders: Theory and Practice\" by Bailey and Cunningham\n" +
+            " const mediump vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "    lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "    lowp float luminance = dot(textureColor.rgb, luminanceWeighting);\n" +
+            "    lowp vec3 greyScaleColor = vec3(luminance);\n" +
+            "    \n" +
+            "    gl_FragColor = vec4(mix(greyScaleColor, textureColor.rgb, saturation), textureColor.w);\n" +
+            "     \n" +
+            " }";
+
+    private int mSaturationLocation;
+    private float mSaturation;
+
+    public GPUImageSaturationFilter() {
+        this(1.0f);
+    }
+
+    public GPUImageSaturationFilter(final float saturation) {
+        super(NO_FILTER_VERTEX_SHADER, SATURATION_FRAGMENT_SHADER);
+        mSaturation = saturation;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mSaturationLocation = GLES20.glGetUniformLocation(getProgram(), "saturation");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setSaturation(mSaturation);
+    }
+
+    public void setSaturation(final float saturation) {
+        mSaturation = saturation;
+        setFloat(mSaturationLocation, mSaturation);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageScreenBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageScreenBlendFilter.java
new file mode 100644
index 00000000..2c63a699
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageScreenBlendFilter.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageScreenBlendFilter extends GPUImageTwoInputFilter {
+    public static final String SCREEN_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2;\n" +
+            "\n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     mediump vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "     mediump vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+            "     mediump vec4 whiteColor = vec4(1.0);\n" +
+            "     gl_FragColor = whiteColor - ((whiteColor - textureColor2) * (whiteColor - textureColor));\n" +
+            " }";
+
+    public GPUImageScreenBlendFilter() {
+        super(SCREEN_BLEND_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSketchFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSketchFilter.java
new file mode 100644
index 00000000..dd78e708
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSketchFilter.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Converts video to look like a sketch.
+ * This is just the Sobel edge detection filter with the colors inverted.
+ */
+public class GPUImageSketchFilter extends GPUImageFilterGroup {
+    public static final String SKETCH_FRAGMENT_SHADER = "" +
+            "precision mediump float;\n" +
+            "\n" +
+            "varying vec2 textureCoordinate;\n" +
+            "varying vec2 leftTextureCoordinate;\n" +
+            "varying vec2 rightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 topTextureCoordinate;\n" +
+            "varying vec2 topLeftTextureCoordinate;\n" +
+            "varying vec2 topRightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 bottomTextureCoordinate;\n" +
+            "varying vec2 bottomLeftTextureCoordinate;\n" +
+            "varying vec2 bottomRightTextureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n" +
+            "float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n" +
+            "float topLeftIntensity = texture2D(inputImageTexture, topLeftTextureCoordinate).r;\n" +
+            "float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n" +
+            "float leftIntensity = texture2D(inputImageTexture, leftTextureCoordinate).r;\n" +
+            "float rightIntensity = texture2D(inputImageTexture, rightTextureCoordinate).r;\n" +
+            "float bottomIntensity = texture2D(inputImageTexture, bottomTextureCoordinate).r;\n" +
+            "float topIntensity = texture2D(inputImageTexture, topTextureCoordinate).r;\n" +
+            "float h = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\n" +
+            "float v = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\n" +
+            "\n" +
+            "float mag = 1.0 - length(vec2(h, v));\n" +
+            "\n" +
+            "gl_FragColor = vec4(vec3(mag), 1.0);\n" +
+            "}\n";
+
+    public GPUImageSketchFilter() {
+        super();
+        addFilter(new GPUImageGrayscaleFilter());
+        addFilter(new GPUImage3x3TextureSamplingFilter(SKETCH_FRAGMENT_SHADER));
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSmoothToonFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSmoothToonFilter.java
new file mode 100644
index 00000000..655949f6
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSmoothToonFilter.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+/**
+ *  This uses a similar process as the GPUImageToonFilter, only it precedes the toon effect
+ *  with a Gaussian blur to smooth out noise.
+ */
+public class GPUImageSmoothToonFilter extends GPUImageFilterGroup {
+    GPUImageGaussianBlurFilter blurFilter;
+    GPUImageToonFilter toonFilter;
+
+    /**
+     * setup & teardown
+     */
+    public GPUImageSmoothToonFilter() {
+        // First pass: apply a variable Gaussian blur
+        blurFilter = new GPUImageGaussianBlurFilter();
+        addFilter(blurFilter);
+
+        // Second pass: run the Sobel edge detection on this blurred image, along with a posterization effect
+        toonFilter = new GPUImageToonFilter();
+        addFilter(toonFilter);
+
+        getFilters().add(blurFilter);
+
+        setBlurSize(0.5f);
+        setThreshold(0.2f);
+        setQuantizationLevels(10.0f);
+    }
+
+    /**
+     * Accessors
+     */
+    public void setTexelWidth(float value) {
+        toonFilter.setTexelWidth(value);
+    }
+
+    public void setTexelHeight(float value) {
+        toonFilter.setTexelHeight(value);
+    }
+
+    public void setBlurSize(float value) {
+        blurFilter.setBlurSize(value);
+    }
+
+    public void setThreshold(float value) {
+        toonFilter.setThreshold(value);
+    }
+
+    public void setQuantizationLevels(float value) {
+        toonFilter.setQuantizationLevels(value);
+    }
+
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelEdgeDetection.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelEdgeDetection.java
index 3381d11e..2a775d48 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelEdgeDetection.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSobelEdgeDetection.java
@@ -23,7 +23,6 @@
  * Applies sobel edge detection on the image.
  */
 public class GPUImageSobelEdgeDetection extends GPUImageFilterGroup {
-
     public static final String SOBEL_EDGE_DETECTION = "" +
             "precision mediump float;\n" + 
             "\n" + 
@@ -60,14 +59,9 @@
             "}";
 
     public GPUImageSobelEdgeDetection() {
-        super(createFilters());
-    }
-
-    private static List<GPUImageFilter> createFilters() {
-        List<GPUImageFilter> filters = new ArrayList<GPUImageFilter>(2);
-        filters.add(new GPUImageGrayscaleFilter());
-        filters.add(new GPUImage3x3TextureSamplingFilter(SOBEL_EDGE_DETECTION));
-        return filters;
+        super();
+        addFilter(new GPUImageGrayscaleFilter());
+        addFilter(new GPUImage3x3TextureSamplingFilter(SOBEL_EDGE_DETECTION));
     }
 
     public void setLineSize(final float size) {
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSoftLightBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSoftLightBlendFilter.java
new file mode 100644
index 00000000..0e1b742e
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSoftLightBlendFilter.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageSoftLightBlendFilter extends GPUImageTwoInputFilter {
+    public static final String SOFT_LIGHT_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2;\n" +
+            "\n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     mediump vec4 base = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "     mediump vec4 overlay = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+            "     \n" +
+            "     gl_FragColor = base * (overlay.a * (base / base.a) + (2.0 * overlay * (1.0 - (base / base.a)))) + overlay * (1.0 - base.a) + base * (1.0 - overlay.a);\n" +
+            " }";
+
+    public GPUImageSoftLightBlendFilter() {
+        super(SOFT_LIGHT_BLEND_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSourceOverBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSourceOverBlendFilter.java
new file mode 100644
index 00000000..ac883997
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSourceOverBlendFilter.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageSourceOverBlendFilter extends GPUImageTwoInputFilter {
+    public static final String SOURCE_OVER_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2;\n" +
+            " \n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "   lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "   lowp vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate);\n" +
+            "   \n" +
+            "   gl_FragColor = mix(textureColor, textureColor2, textureColor2.a);\n" +
+            " }";
+
+    public GPUImageSourceOverBlendFilter() {
+        super(SOURCE_OVER_BLEND_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSphereRefractionFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSphereRefractionFilter.java
new file mode 100644
index 00000000..6314cf19
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSphereRefractionFilter.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.graphics.PointF;
+import android.opengl.GLES20;
+
+public class GPUImageSphereRefractionFilter extends GPUImageFilter {
+    public static final String SPHERE_FRAGMENT_SHADER = "" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "uniform highp vec2 center;\n" +
+            "uniform highp float radius;\n" +
+            "uniform highp float aspectRatio;\n" +
+            "uniform highp float refractiveIndex;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "highp vec2 textureCoordinateToUse = vec2(textureCoordinate.x, (textureCoordinate.y * aspectRatio + 0.5 - 0.5 * aspectRatio));\n" +
+            "highp float distanceFromCenter = distance(center, textureCoordinateToUse);\n" +
+            "lowp float checkForPresenceWithinSphere = step(distanceFromCenter, radius);\n" +
+            "\n" +
+            "distanceFromCenter = distanceFromCenter / radius;\n" +
+            "\n" +
+            "highp float normalizedDepth = radius * sqrt(1.0 - distanceFromCenter * distanceFromCenter);\n" +
+            "highp vec3 sphereNormal = normalize(vec3(textureCoordinateToUse - center, normalizedDepth));\n" +
+            "\n" +
+            "highp vec3 refractedVector = refract(vec3(0.0, 0.0, -1.0), sphereNormal, refractiveIndex);\n" +
+            "\n" +
+            "gl_FragColor = texture2D(inputImageTexture, (refractedVector.xy + 1.0) * 0.5) * checkForPresenceWithinSphere;     \n" +
+            "}\n";
+
+    private PointF mCenter;
+    private int mCenterLocation;
+    private float mRadius;
+    private int mRadiusLocation;
+    private float mAspectRatio;
+    private int mAspectRatioLocation;
+    private float mRefractiveIndex;
+    private int mRefractiveIndexLocation;
+
+    public GPUImageSphereRefractionFilter() {
+        this(new PointF(0.5f, 0.5f), 0.25f, 0.71f);
+    }
+
+    public GPUImageSphereRefractionFilter(PointF center, float radius, float refractiveIndex) {
+        super(NO_FILTER_VERTEX_SHADER, SPHERE_FRAGMENT_SHADER);
+        mCenter = center;
+        mRadius = radius;
+        mRefractiveIndex = refractiveIndex;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mCenterLocation = GLES20.glGetUniformLocation(getProgram(), "center");
+        mRadiusLocation = GLES20.glGetUniformLocation(getProgram(), "radius");
+        mAspectRatioLocation = GLES20.glGetUniformLocation(getProgram(), "aspectRatio");
+        mRefractiveIndexLocation = GLES20.glGetUniformLocation(getProgram(), "refractiveIndex");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setRadius(mRadius);
+        setCenter(mCenter);
+        setRefractiveIndex(mRefractiveIndex);
+    }
+
+    @Override
+    public void onOutputSizeChanged(int width, int height) {
+        mAspectRatio = (float) height / width;
+        setAspectRatio(mAspectRatio);
+        super.onOutputSizeChanged(width, height);
+    }
+
+    private void setAspectRatio(float aspectRatio) {
+        mAspectRatio = aspectRatio;
+        setFloat(mAspectRatioLocation, aspectRatio);
+    }
+
+    /**
+     * The index of refraction for the sphere, with a default of 0.71
+     *
+     * @param refractiveIndex default 0.71
+     */
+    public void setRefractiveIndex(float refractiveIndex) {
+        mRefractiveIndex = refractiveIndex;
+        setFloat(mRefractiveIndexLocation, refractiveIndex);
+    }
+
+    /**
+     * The center about which to apply the distortion, with a default of (0.5, 0.5)
+     *
+     * @param center default (0.5, 0.5)
+     */
+    public void setCenter(PointF center) {
+        mCenter = center;
+        setPoint(mCenterLocation, center);
+    }
+
+    /**
+     * The radius of the distortion, ranging from 0.0 to 1.0, with a default of 0.25
+     *
+     * @param radius from 0.0 to 1.0, default 0.25
+     */
+    public void setRadius(float radius) {
+        mRadius = radius;
+        setFloat(mRadiusLocation, radius);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSubtractBlendFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSubtractBlendFilter.java
new file mode 100644
index 00000000..52b54ecc
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSubtractBlendFilter.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageSubtractBlendFilter extends GPUImageTwoInputFilter {
+    public static final String SUBTRACT_BLEND_FRAGMENT_SHADER = "varying highp vec2 textureCoordinate;\n" +
+            " varying highp vec2 textureCoordinate2;\n" +
+            "\n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D inputImageTexture2;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "   lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "   lowp vec4 textureColor2 = texture2D(inputImageTexture2, textureCoordinate2);\n" +
+            "\n" +
+            "   gl_FragColor = vec4(textureColor.rgb - textureColor2.rgb, textureColor.a);\n" +
+            " }";
+
+    public GPUImageSubtractBlendFilter() {
+        super(SUBTRACT_BLEND_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSwirlFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSwirlFilter.java
new file mode 100644
index 00000000..d4947b9a
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageSwirlFilter.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.graphics.PointF;
+import android.opengl.GLES20;
+
+/**
+ * Creates a swirl distortion on the image.
+ */
+public class GPUImageSwirlFilter extends GPUImageFilter {
+    public static final String SWIRL_FRAGMENT_SHADER = "" +
+            "varying highp vec2 textureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "uniform highp vec2 center;\n" +
+            "uniform highp float radius;\n" +
+            "uniform highp float angle;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "highp vec2 textureCoordinateToUse = textureCoordinate;\n" +
+            "highp float dist = distance(center, textureCoordinate);\n" +
+            "if (dist < radius)\n" +
+            "{\n" +
+            "textureCoordinateToUse -= center;\n" +
+            "highp float percent = (radius - dist) / radius;\n" +
+            "highp float theta = percent * percent * angle * 8.0;\n" +
+            "highp float s = sin(theta);\n" +
+            "highp float c = cos(theta);\n" +
+            "textureCoordinateToUse = vec2(dot(textureCoordinateToUse, vec2(c, -s)), dot(textureCoordinateToUse, vec2(s, c)));\n" +
+            "textureCoordinateToUse += center;\n" +
+            "}\n" +
+            "\n" +
+            "gl_FragColor = texture2D(inputImageTexture, textureCoordinateToUse );\n" +
+            "\n" +
+            "}\n";
+
+    private float mAngle;
+    private int mAngleLocation;
+    private float mRadius;
+    private int mRadiusLocation;
+    private PointF mCenter;
+    private int mCenterLocation;
+
+    public GPUImageSwirlFilter() {
+        this(0.5f, 1.0f, new PointF(0.5f, 0.5f));
+    }
+
+    public GPUImageSwirlFilter(float radius, float angle, PointF center) {
+        super(NO_FILTER_VERTEX_SHADER, SWIRL_FRAGMENT_SHADER);
+        mRadius = radius;
+        mAngle = angle;
+        mCenter = center;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mAngleLocation = GLES20.glGetUniformLocation(getProgram(), "angle");
+        mRadiusLocation = GLES20.glGetUniformLocation(getProgram(), "radius");
+        mCenterLocation = GLES20.glGetUniformLocation(getProgram(), "center");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setRadius(mRadius);
+        setAngle(mAngle);
+        setCenter(mCenter);
+    }
+
+    /**
+     * The radius of the distortion, ranging from 0.0 to 1.0, with a default of 0.5.
+     *
+     * @param radius from 0.0 to 1.0, default 0.5
+     */
+    public void setRadius(float radius) {
+        mRadius = radius;
+        setFloat(mRadiusLocation, radius);
+    }
+
+    /**
+     * The amount of distortion to apply, with a minimum of 0.0 and a default of 1.0.
+     *
+     * @param angle minimum 0.0, default 1.0
+     */
+    public void setAngle(float angle) {
+        mAngle = angle;
+        setFloat(mAngleLocation, angle);
+    }
+
+    /**
+     * The center about which to apply the distortion, with a default of (0.5, 0.5).
+     *
+     * @param center default (0.5, 0.5)
+     */
+    public void setCenter(PointF center) {
+        mCenter = center;
+        setPoint(mCenterLocation, center);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageToneCurveFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageToneCurveFilter.java
new file mode 100644
index 00000000..0f6e1d08
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageToneCurveFilter.java
@@ -0,0 +1,364 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.graphics.Point;
+import android.graphics.PointF;
+import android.opengl.GLES20;
+
+import java.io.*;
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Comparator;
+
+public class GPUImageToneCurveFilter extends GPUImageFilter {
+    public static final String TONE_CURVE_FRAGMENT_SHADER = "" +
+            " varying highp vec2 textureCoordinate;\n" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " uniform sampler2D toneCurveTexture;\n" +
+            "\n" +
+            " void main()\n" +
+            " {\n" +
+            "     lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "     lowp float redCurveValue = texture2D(toneCurveTexture, vec2(textureColor.r, 0.0)).r;\n" +
+            "     lowp float greenCurveValue = texture2D(toneCurveTexture, vec2(textureColor.g, 0.0)).g;\n" +
+            "     lowp float blueCurveValue = texture2D(toneCurveTexture, vec2(textureColor.b, 0.0)).b;\n" +
+            "\n" +
+            "     gl_FragColor = vec4(redCurveValue, greenCurveValue, blueCurveValue, textureColor.a);\n" +
+            " }";
+
+    private int[] mToneCurveTexture = new int[]{OpenGlUtils.NO_TEXTURE};
+    private int mToneCurveTextureUniformLocation;
+
+    private PointF[] mRgbCompositeControlPoints;
+    private PointF[] mRedControlPoints;
+    private PointF[] mGreenControlPoints;
+    private PointF[] mBlueControlPoints;
+
+    private ArrayList<Float> mRgbCompositeCurve;
+    private ArrayList<Float> mRedCurve;
+    private ArrayList<Float> mGreenCurve;
+    private ArrayList<Float> mBlueCurve;
+
+
+    public GPUImageToneCurveFilter() {
+        super(NO_FILTER_VERTEX_SHADER, TONE_CURVE_FRAGMENT_SHADER);
+
+        PointF[] defaultCurvePoints = new PointF[]{new PointF(0.0f, 0.0f), new PointF(0.5f, 0.5f), new PointF(1.0f, 1.0f)};
+        mRgbCompositeControlPoints = defaultCurvePoints;
+        mRedControlPoints = defaultCurvePoints;
+        mGreenControlPoints = defaultCurvePoints;
+        mBlueControlPoints = defaultCurvePoints;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mToneCurveTextureUniformLocation = GLES20.glGetUniformLocation(getProgram(), "toneCurveTexture");
+        GLES20.glActiveTexture(GLES20.GL_TEXTURE3);
+        GLES20.glGenTextures(1, mToneCurveTexture, 0);
+        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mToneCurveTexture[0]);
+        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR);
+        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR);
+        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);
+        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setRgbCompositeControlPoints(mRgbCompositeControlPoints);
+        setRedControlPoints(mRedControlPoints);
+        setGreenControlPoints(mGreenControlPoints);
+        setBlueControlPoints(mBlueControlPoints);
+    }
+
+    @Override
+    protected void onDrawArraysPre() {
+        if (mToneCurveTexture[0] != OpenGlUtils.NO_TEXTURE) {
+            GLES20.glActiveTexture(GLES20.GL_TEXTURE3);
+            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mToneCurveTexture[0]);
+            GLES20.glUniform1i(mToneCurveTextureUniformLocation, 3);
+        }
+    }
+
+    public void setFromCurveFileInputStream(InputStream input) {
+        try {
+            int version = readShort(input);
+            int totalCurves = readShort(input);
+
+            ArrayList<PointF[]> curves = new ArrayList<PointF[]>(totalCurves);
+            float pointRate = 1.0f / 255;
+
+            for (int i = 0; i < totalCurves; i++) {
+                // 2 bytes, Count of points in the curve (short integer from 2...19)
+                short pointCount = readShort(input);
+
+                PointF[] points = new PointF[pointCount];
+
+                // point count * 4
+                // Curve points. Each curve point is a pair of short integers where
+                // the first number is the output value (vertical coordinate on the
+                // Curves dialog graph) and the second is the input value. All coordinates have range 0 to 255.
+                for (int j = 0; j < pointCount; j++) {
+                    short y = readShort(input);
+                    short x = readShort(input);
+
+                    points[j] = new PointF(x * pointRate, y * pointRate);
+                }
+
+                curves.add(points);
+            }
+            input.close();
+
+            mRgbCompositeControlPoints = curves.get(0);
+            mRedControlPoints = curves.get(1);
+            mGreenControlPoints = curves.get(2);
+            mBlueControlPoints = curves.get(3);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private short readShort(InputStream input) throws IOException {
+        return (short) (input.read() << 8 | input.read());
+    }
+
+    public void setRgbCompositeControlPoints(PointF[] points) {
+        mRgbCompositeControlPoints = points;
+        mRgbCompositeCurve = createSplineCurve(mRgbCompositeControlPoints);
+        updateToneCurveTexture();
+    }
+
+    public void setRedControlPoints(PointF[] points) {
+        mRedControlPoints = points;
+        mRedCurve = createSplineCurve(mRedControlPoints);
+        updateToneCurveTexture();
+    }
+
+    public void setGreenControlPoints(PointF[] points) {
+        mGreenControlPoints = points;
+        mGreenCurve = createSplineCurve(mGreenControlPoints);
+        updateToneCurveTexture();
+    }
+
+    public void setBlueControlPoints(PointF[] points) {
+        mBlueControlPoints = points;
+        mBlueCurve = createSplineCurve(mBlueControlPoints);
+        updateToneCurveTexture();
+    }
+
+    private void updateToneCurveTexture() {
+        runOnDraw(new Runnable() {
+            @Override
+            public void run() {
+                GLES20.glActiveTexture(GLES20.GL_TEXTURE3);
+                GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mToneCurveTexture[0]);
+
+                if ((mRedCurve.size() >= 256) && (mGreenCurve.size() >= 256) && (mBlueCurve.size() >= 256) && (mRgbCompositeCurve.size() >= 256)) {
+                    byte[] toneCurveByteArray = new byte[256 * 4];
+                    for (int currentCurveIndex = 0; currentCurveIndex < 256; currentCurveIndex++) {
+                        // BGRA for upload to texture
+                        toneCurveByteArray[currentCurveIndex * 4 + 2] = (byte) ((int) Math.min(Math.max(currentCurveIndex + mBlueCurve.get(currentCurveIndex) + mRgbCompositeCurve.get(currentCurveIndex), 0), 255) & 0xff);
+                        toneCurveByteArray[currentCurveIndex * 4 + 1] = (byte) ((int) Math.min(Math.max(currentCurveIndex + mGreenCurve.get(currentCurveIndex) + mRgbCompositeCurve.get(currentCurveIndex), 0), 255) & 0xff);
+                        toneCurveByteArray[currentCurveIndex * 4] = (byte) ((int) Math.min(Math.max(currentCurveIndex + mRedCurve.get(currentCurveIndex) + mRgbCompositeCurve.get(currentCurveIndex), 0), 255) & 0xff);
+                        toneCurveByteArray[currentCurveIndex * 4 + 3] = (byte) (255 & 0xff);
+                    }
+
+                    GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, 256 /*width*/, 1 /*height*/, 0, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, ByteBuffer.wrap(toneCurveByteArray));
+                }
+//        Buffer pixels!
+//        GLES20.glTexImage2D(int target,
+//            int level,
+//            int internalformat,
+//            int width,
+//            int height,
+//            int border,
+//            int format,
+//            int type,
+//            java.nio.Buffer pixels);
+            }
+        });
+    }
+
+    private ArrayList<Float> createSplineCurve(PointF[] points) {
+        if (points == null || points.length <= 0) {
+            return null;
+        }
+
+        // Sort the array
+        PointF[] pointsSorted = points.clone();
+        Arrays.sort(pointsSorted, new Comparator<PointF>() {
+            @Override
+            public int compare(PointF point1, PointF point2) {
+                if (point1.x < point2.x) {
+                    return -1;
+                } else if (point1.x > point2.x) {
+                    return 1;
+                } else {
+                    return 0;
+                }
+            }
+        });
+
+        // Convert from (0, 1) to (0, 255).
+        Point[] convertedPoints = new Point[pointsSorted.length];
+        for (int i = 0; i < points.length; i++) {
+            PointF point = pointsSorted[i];
+            convertedPoints[i] = new Point((int) (point.x * 255), (int) (point.y * 255));
+        }
+
+        ArrayList<Point> splinePoints = createSplineCurve2(convertedPoints);
+
+        // If we have a first point like (0.3, 0) we'll be missing some points at the beginning
+        // that should be 0.
+        Point firstSplinePoint = splinePoints.get(0);
+        if (firstSplinePoint.x > 0) {
+            for (int i = firstSplinePoint.x; i >= 0; i--) {
+                splinePoints.add(0, new Point(i, 0));
+            }
+        }
+
+        // Insert points similarly at the end, if necessary.
+        Point lastSplinePoint = splinePoints.get(splinePoints.size() - 1);
+        if (lastSplinePoint.x < 255) {
+            for (int i = lastSplinePoint.x + 1; i <= 255; i++) {
+                splinePoints.add(new Point(i, 255));
+            }
+        }
+
+        // Prepare the spline points.
+        ArrayList<Float> preparedSplinePoints = new ArrayList<Float>(splinePoints.size());
+        for (Point newPoint : splinePoints) {
+            Point origPoint = new Point(newPoint.x, newPoint.x);
+
+            float distance = (float) Math.sqrt(Math.pow((origPoint.x - newPoint.x), 2.0) + Math.pow((origPoint.y - newPoint.y), 2.0));
+
+            if (origPoint.y > newPoint.y) {
+                distance = -distance;
+            }
+
+            preparedSplinePoints.add(distance);
+        }
+
+        return preparedSplinePoints;
+    }
+
+    private ArrayList<Point> createSplineCurve2(Point[] points) {
+        ArrayList<Double> sdA = createSecondDerivative(points);
+
+        // Is [points count] equal to [sdA count]?
+//    int n = [points count];
+        int n = sdA.size();
+        if (n < 1) {
+            return null;
+        }
+        double sd[] = new double[n];
+
+        // From NSMutableArray to sd[n];
+        for (int i = 0; i < n; i++) {
+            sd[i] = sdA.get(i);
+        }
+
+
+        ArrayList<Point> output = new ArrayList<Point>(n + 1);
+
+        for (int i = 0; i < n - 1; i++) {
+            Point cur = points[i];
+            Point next = points[i + 1];
+
+            for (int x = cur.x; x < next.x; x++) {
+                double t = (double) (x - cur.x) / (next.x - cur.x);
+
+                double a = 1 - t;
+                double b = t;
+                double h = next.x - cur.x;
+
+                double y = a * cur.y + b * next.y + (h * h / 6) * ((a * a * a - a) * sd[i] + (b * b * b - b) * sd[i + 1]);
+
+                if (y > 255.0) {
+                    y = 255.0;
+                } else if (y < 0.0) {
+                    y = 0.0;
+                }
+
+                output.add(new Point(x, (int) Math.round(y)));
+            }
+        }
+
+        // If the last point is (255, 255) it doesn't get added.
+        if (output.size() == 255) {
+            output.add(points[points.length - 1]);
+        }
+        return output;
+    }
+
+    private ArrayList<Double> createSecondDerivative(Point[] points) {
+        int n = points.length;
+        if (n <= 1) {
+            return null;
+        }
+
+        double matrix[][] = new double[n][3];
+        double result[] = new double[n];
+        matrix[0][1] = 1;
+        // What about matrix[0][1] and matrix[0][0]? Assuming 0 for now (Brad L.)
+        matrix[0][0] = 0;
+        matrix[0][2] = 0;
+
+        for (int i = 1; i < n - 1; i++) {
+            Point P1 = points[i - 1];
+            Point P2 = points[i];
+            Point P3 = points[i + 1];
+
+            matrix[i][0] = (double) (P2.x - P1.x) / 6;
+            matrix[i][1] = (double) (P3.x - P1.x) / 3;
+            matrix[i][2] = (double) (P3.x - P2.x) / 6;
+            result[i] = (double) (P3.y - P2.y) / (P3.x - P2.x) - (double) (P2.y - P1.y) / (P2.x - P1.x);
+        }
+
+        // What about result[0] and result[n-1]? Assuming 0 for now (Brad L.)
+        result[0] = 0;
+        result[n - 1] = 0;
+
+        matrix[n - 1][1] = 1;
+        // What about matrix[n-1][0] and matrix[n-1][2]? For now, assuming they are 0 (Brad L.)
+        matrix[n - 1][0] = 0;
+        matrix[n - 1][2] = 0;
+
+        // solving pass1 (up->down)
+        for (int i = 1; i < n; i++) {
+            double k = matrix[i][0] / matrix[i - 1][1];
+            matrix[i][1] -= k * matrix[i - 1][2];
+            matrix[i][0] = 0;
+            result[i] -= k * result[i - 1];
+        }
+        // solving pass2 (down->up)
+        for (int i = n - 2; i >= 0; i--) {
+            double k = matrix[i][2] / matrix[i + 1][1];
+            matrix[i][1] -= k * matrix[i + 1][0];
+            matrix[i][2] = 0;
+            result[i] -= k * result[i + 1];
+        }
+
+        ArrayList<Double> output = new ArrayList<Double>(n);
+        for (int i = 0; i < n; i++) output.add(result[i] / matrix[i][1]);
+
+        return output;
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageToonFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageToonFilter.java
new file mode 100644
index 00000000..5148d1d0
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageToonFilter.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+/**
+ * This uses Sobel edge detection to place a black border around objects,
+ * and then it quantizes the colors present in the image to give a cartoon-like quality to the image.
+ */
+public class GPUImageToonFilter extends GPUImage3x3TextureSamplingFilter {
+    public static final String TOON_FRAGMENT_SHADER = "" +
+            "precision highp float;\n" +
+            "\n" +
+            "varying vec2 textureCoordinate;\n" +
+            "varying vec2 leftTextureCoordinate;\n" +
+            "varying vec2 rightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 topTextureCoordinate;\n" +
+            "varying vec2 topLeftTextureCoordinate;\n" +
+            "varying vec2 topRightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 bottomTextureCoordinate;\n" +
+            "varying vec2 bottomLeftTextureCoordinate;\n" +
+            "varying vec2 bottomRightTextureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "uniform highp float intensity;\n" +
+            "uniform highp float threshold;\n" +
+            "uniform highp float quantizationLevels;\n" +
+            "\n" +
+            "const highp vec3 W = vec3(0.2125, 0.7154, 0.0721);\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "\n" +
+            "float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n" +
+            "float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n" +
+            "float topLeftIntensity = texture2D(inputImageTexture, topLeftTextureCoordinate).r;\n" +
+            "float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n" +
+            "float leftIntensity = texture2D(inputImageTexture, leftTextureCoordinate).r;\n" +
+            "float rightIntensity = texture2D(inputImageTexture, rightTextureCoordinate).r;\n" +
+            "float bottomIntensity = texture2D(inputImageTexture, bottomTextureCoordinate).r;\n" +
+            "float topIntensity = texture2D(inputImageTexture, topTextureCoordinate).r;\n" +
+            "float h = -topLeftIntensity - 2.0 * topIntensity - topRightIntensity + bottomLeftIntensity + 2.0 * bottomIntensity + bottomRightIntensity;\n" +
+            "float v = -bottomLeftIntensity - 2.0 * leftIntensity - topLeftIntensity + bottomRightIntensity + 2.0 * rightIntensity + topRightIntensity;\n" +
+            "\n" +
+            "float mag = length(vec2(h, v));\n" +
+            "\n" +
+            "vec3 posterizedImageColor = floor((textureColor.rgb * quantizationLevels) + 0.5) / quantizationLevels;\n" +
+            "\n" +
+            "float thresholdTest = 1.0 - step(threshold, mag);\n" +
+            "\n" +
+            "gl_FragColor = vec4(posterizedImageColor * thresholdTest, textureColor.a);\n" +
+            "}\n";
+
+    float mThreshold;
+    int mThresholdLocation;
+    float mQuantizationLevels;
+    int mQuantizationLevelsLocation;
+
+    public GPUImageToonFilter() {
+        this(0.2f, 10.0f);
+    }
+
+    public GPUImageToonFilter(float threshold, float quantizationLevels) {
+        super(TOON_FRAGMENT_SHADER);
+        mThreshold = threshold;
+        mQuantizationLevels = quantizationLevels;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mThresholdLocation = GLES20.glGetUniformLocation(getProgram(), "threshold");
+        mQuantizationLevelsLocation = GLES20.glGetUniformLocation(getProgram(), "quantizationLevels");
+    }
+
+    @Override
+    public void onInitialized() {
+        super.onInitialized();
+        setThreshold(mThreshold);
+        setQuantizationLevels(mQuantizationLevels);
+    }
+
+    /**
+     * The threshold at which to apply the edges, default of 0.2.
+     *
+     * @param threshold default 0.2
+     */
+    public void setThreshold(final float threshold) {
+        mThreshold = threshold;
+        setFloat(mThresholdLocation, threshold);
+    }
+
+    /**
+     * The levels of quantization for the posterization of colors within the scene, with a default of 10.0.
+     *
+     * @param quantizationLevels default 10.0
+     */
+    public void setQuantizationLevels(final float quantizationLevels) {
+        mQuantizationLevels = quantizationLevels;
+        setFloat(mQuantizationLevelsLocation, quantizationLevels);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoInputFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoInputFilter.java
new file mode 100644
index 00000000..afc3b864
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoInputFilter.java
@@ -0,0 +1,131 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.FloatBuffer;
+
+import jp.co.cyberagent.android.gpuimage.util.TextureRotationUtil;
+import android.graphics.Bitmap;
+import android.opengl.GLES20;
+
+public class GPUImageTwoInputFilter extends GPUImageFilter {
+    private static final String VERTEX_SHADER = "attribute vec4 position;\n" +
+            "attribute vec4 inputTextureCoordinate;\n" +
+            "attribute vec4 inputTextureCoordinate2;\n" +
+            " \n" +
+            "varying vec2 textureCoordinate;\n" +
+            "varying vec2 textureCoordinate2;\n" +
+            " \n" +
+            "void main()\n" +
+            "{\n" +
+            "    gl_Position = position;\n" +
+            "    textureCoordinate = inputTextureCoordinate.xy;\n" +
+            "    textureCoordinate2 = inputTextureCoordinate2.xy;\n" +
+            "}";
+
+    public int mFilterSecondTextureCoordinateAttribute;
+    public int mFilterInputTextureUniform2;
+    public int mFilterSourceTexture2 = OpenGlUtils.NO_TEXTURE;
+    private ByteBuffer mTexture2CoordinatesBuffer;
+    private Bitmap mBitmap;
+
+    public GPUImageTwoInputFilter(String fragmentShader) {
+        this(VERTEX_SHADER, fragmentShader);
+    }
+
+    public GPUImageTwoInputFilter(String vertexShader, String fragmentShader) {
+        super(vertexShader, fragmentShader);
+        setRotation(Rotation.NORMAL, false, false);
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+
+        mFilterSecondTextureCoordinateAttribute = GLES20.glGetAttribLocation(getProgram(), "inputTextureCoordinate2");
+        mFilterInputTextureUniform2 = GLES20.glGetUniformLocation(getProgram(), "inputImageTexture2"); // This does assume a name of "inputImageTexture2" for second input texture in the fragment shader
+        GLES20.glEnableVertexAttribArray(mFilterSecondTextureCoordinateAttribute);
+
+        if (mBitmap != null&&!mBitmap.isRecycled()) {
+            setBitmap(mBitmap);
+        }
+    }
+    
+    public void setBitmap(final Bitmap bitmap) {
+        if (bitmap != null && bitmap.isRecycled()) {
+            return;
+        }
+        mBitmap = bitmap;
+        if (mBitmap == null) {
+            return;
+        }
+        runOnDraw(new Runnable() {
+            public void run() {
+                if (mFilterSourceTexture2 == OpenGlUtils.NO_TEXTURE) {
+                    if (bitmap == null || bitmap.isRecycled()) {
+                        return;
+                    }
+                    GLES20.glActiveTexture(GLES20.GL_TEXTURE3);
+                    mFilterSourceTexture2 = OpenGlUtils.loadTexture(bitmap, OpenGlUtils.NO_TEXTURE, false);
+                }
+            }
+        });
+    }
+
+    public Bitmap getBitmap() {
+        return mBitmap;
+    }
+
+    public void recycleBitmap() {
+        if (mBitmap != null && !mBitmap.isRecycled()) {
+            mBitmap.recycle();
+            mBitmap = null;
+        }
+    }
+
+    public void onDestroy() {
+        super.onDestroy();
+        GLES20.glDeleteTextures(1, new int[]{
+                mFilterSourceTexture2
+        }, 0);
+        mFilterSourceTexture2 = OpenGlUtils.NO_TEXTURE;
+    }
+
+    @Override
+    protected void onDrawArraysPre() {
+        GLES20.glEnableVertexAttribArray(mFilterSecondTextureCoordinateAttribute);
+        GLES20.glActiveTexture(GLES20.GL_TEXTURE3);
+        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, mFilterSourceTexture2);
+        GLES20.glUniform1i(mFilterInputTextureUniform2, 3);
+
+        mTexture2CoordinatesBuffer.position(0);
+        GLES20.glVertexAttribPointer(mFilterSecondTextureCoordinateAttribute, 2, GLES20.GL_FLOAT, false, 0, mTexture2CoordinatesBuffer);
+    }
+
+    public void setRotation(final Rotation rotation, final boolean flipHorizontal, final boolean flipVertical) {
+        float[] buffer = TextureRotationUtil.getRotation(rotation, flipHorizontal, flipVertical);
+
+        ByteBuffer bBuffer = ByteBuffer.allocateDirect(32).order(ByteOrder.nativeOrder());
+        FloatBuffer fBuffer = bBuffer.asFloatBuffer();
+        fBuffer.put(buffer);
+        fBuffer.flip();
+
+        mTexture2CoordinatesBuffer = bBuffer;
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoPassFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoPassFilter.java
new file mode 100644
index 00000000..bf3fbf17
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoPassFilter.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageTwoPassFilter extends GPUImageFilterGroup {
+    public GPUImageTwoPassFilter(String firstVertexShader, String firstFragmentShader,
+                                 String secondVertexShader, String secondFragmentShader) {
+        super(null);
+        addFilter(new GPUImageFilter(firstVertexShader, firstFragmentShader));
+        addFilter(new GPUImageFilter(secondVertexShader, secondFragmentShader));
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoPassTextureSamplingFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoPassTextureSamplingFilter.java
new file mode 100644
index 00000000..19c0365b
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageTwoPassTextureSamplingFilter.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+public class GPUImageTwoPassTextureSamplingFilter extends GPUImageTwoPassFilter {
+    public GPUImageTwoPassTextureSamplingFilter(String firstVertexShader, String firstFragmentShader,
+                                                String secondVertexShader, String secondFragmentShader) {
+        super(firstVertexShader, firstFragmentShader,
+                secondVertexShader, secondFragmentShader);
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        initTexelOffsets();
+    }
+
+    protected void initTexelOffsets() {
+        float ratio = getHorizontalTexelOffsetRatio();
+        GPUImageFilter filter = mFilters.get(0);
+        int texelWidthOffsetLocation = GLES20.glGetUniformLocation(filter.getProgram(), "texelWidthOffset");
+        int texelHeightOffsetLocation = GLES20.glGetUniformLocation(filter.getProgram(), "texelHeightOffset");
+        filter.setFloat(texelWidthOffsetLocation, ratio / mOutputWidth);
+        filter.setFloat(texelHeightOffsetLocation, 0);
+
+        ratio = getVerticalTexelOffsetRatio();
+        filter = mFilters.get(1);
+        texelWidthOffsetLocation = GLES20.glGetUniformLocation(filter.getProgram(), "texelWidthOffset");
+        texelHeightOffsetLocation = GLES20.glGetUniformLocation(filter.getProgram(), "texelHeightOffset");
+        filter.setFloat(texelWidthOffsetLocation, 0);
+        filter.setFloat(texelHeightOffsetLocation, ratio / mOutputHeight);
+    }
+
+    @Override
+    public void onOutputSizeChanged(int width, int height) {
+        super.onOutputSizeChanged(width, height);
+        initTexelOffsets();
+    }
+
+    public float getVerticalTexelOffsetRatio() {
+        return 1f;
+    }
+
+    public float getHorizontalTexelOffsetRatio() {
+        return 1f;
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java
new file mode 100644
index 00000000..442f5593
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageView.java
@@ -0,0 +1,455 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.media.MediaScannerConnection;
+import android.net.Uri;
+import android.opengl.GLES20;
+import android.opengl.GLSurfaceView;
+import android.os.*;
+import android.util.AttributeSet;
+import android.view.Gravity;
+import android.view.ViewTreeObserver;
+import android.widget.FrameLayout;
+import android.widget.ProgressBar;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.nio.IntBuffer;
+import java.util.concurrent.Semaphore;
+
+public class GPUImageView extends FrameLayout {
+
+    private GLSurfaceView mGLSurfaceView;
+    private GPUImage mGPUImage;
+    private GPUImageFilter mFilter;
+    public Size mForceSize = null;
+    private float mRatio = 0.0f;
+
+    public GPUImageView(Context context) {
+        super(context);
+        init(context, null);
+    }
+
+    public GPUImageView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        init(context, attrs);
+    }
+
+    private void init(Context context, AttributeSet attrs) {
+        mGLSurfaceView = new GPUImageGLSurfaceView(context, attrs);
+        addView(mGLSurfaceView);
+        mGPUImage = new GPUImage(getContext());
+        mGPUImage.setGLSurfaceView(mGLSurfaceView);
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        if (mRatio != 0.0f) {
+            int width = MeasureSpec.getSize(widthMeasureSpec);
+            int height = MeasureSpec.getSize(heightMeasureSpec);
+
+            int newHeight;
+            int newWidth;
+            if (width / mRatio < height) {
+                newWidth = width;
+                newHeight = Math.round(width / mRatio);
+            } else {
+                newHeight = height;
+                newWidth = Math.round(height * mRatio);
+            }
+
+            int newWidthSpec = MeasureSpec.makeMeasureSpec(newWidth, MeasureSpec.EXACTLY);
+            int newHeightSpec = MeasureSpec.makeMeasureSpec(newHeight, MeasureSpec.EXACTLY);
+            super.onMeasure(newWidthSpec, newHeightSpec);
+        } else {
+            super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+        }
+    }
+
+    /**
+     * Retrieve the GPUImage instance used by this view.
+     *
+     * @return used GPUImage instance
+     */
+    public GPUImage getGPUImage() {
+        return mGPUImage;
+    }
+
+    // TODO Should be an xml attribute. But then GPUImage can not be distributed as .jar anymore.
+    public void setRatio(float ratio) {
+        mRatio = ratio;
+        mGLSurfaceView.requestLayout();
+        mGPUImage.deleteImage();
+    }
+
+    /**
+     * Set the scale type of GPUImage.
+     *
+     * @param scaleType the new ScaleType
+     */
+    public void setScaleType(GPUImage.ScaleType scaleType) {
+        mGPUImage.setScaleType(scaleType);
+    }
+
+    /**
+     * Sets the rotation of the displayed image.
+     *
+     * @param rotation new rotation
+     */
+    public void setRotation(Rotation rotation) {
+        mGPUImage.setRotation(rotation);
+        requestRender();
+    }
+
+    /**
+     * Set the filter to be applied on the image.
+     *
+     * @param filter Filter that should be applied on the image.
+     */
+    public void setFilter(GPUImageFilter filter) {
+        mFilter = filter;
+        mGPUImage.setFilter(filter);
+        requestRender();
+    }
+
+    /**
+     * Get the current applied filter.
+     *
+     * @return the current filter
+     */
+    public GPUImageFilter getFilter() {
+        return mFilter;
+    }
+
+    /**
+     * Sets the image on which the filter should be applied.
+     *
+     * @param bitmap the new image
+     */
+    public void setImage(final Bitmap bitmap) {
+        mGPUImage.setImage(bitmap);
+    }
+
+    /**
+     * Sets the image on which the filter should be applied from a Uri.
+     *
+     * @param uri the uri of the new image
+     */
+    public void setImage(final Uri uri) {
+        mGPUImage.setImage(uri);
+    }
+
+    /**
+     * Sets the image on which the filter should be applied from a File.
+     *
+     * @param file the file of the new image
+     */
+    public void setImage(final File file) {
+        mGPUImage.setImage(file);
+    }
+
+    public void requestRender() {
+        mGLSurfaceView.requestRender();
+    }
+
+    /**
+     * Save current image with applied filter to Pictures. It will be stored on
+     * the default Picture folder on the phone below the given folerName and
+     * fileName. <br />
+     * This method is async and will notify when the image was saved through the
+     * listener.
+     *
+     * @param folderName the folder name
+     * @param fileName the file name
+     * @param listener the listener
+     */
+    public void saveToPictures(final String folderName, final String fileName,
+                               final OnPictureSavedListener listener) {
+        new SaveTask(folderName, fileName, listener).execute();
+    }
+
+    /**
+     * Save current image with applied filter to Pictures. It will be stored on
+     * the default Picture folder on the phone below the given folerName and
+     * fileName. <br />
+     * This method is async and will notify when the image was saved through the
+     * listener.
+     *
+     * @param folderName the folder name
+     * @param fileName   the file name
+     * @param width      requested output width
+     * @param height     requested output height
+     * @param listener   the listener
+     */
+    public void saveToPictures(final String folderName, final String fileName,
+                               int width, int height,
+                               final OnPictureSavedListener listener) {
+        new SaveTask(folderName, fileName, width, height, listener).execute();
+    }
+
+    /**
+     * Retrieve current image with filter applied and given size as Bitmap.
+     *
+     * @param width  requested Bitmap width
+     * @param height requested Bitmap height
+     * @return Bitmap of picture with given size
+     * @throws InterruptedException
+     */
+    public Bitmap capture(final int width, final int height) throws InterruptedException {
+        // This method needs to run on a background thread because it will take a longer time
+        if (Looper.myLooper() == Looper.getMainLooper()) {
+            throw new IllegalStateException("Do not call this method from the UI thread!");
+        }
+
+        mForceSize = new Size(width, height);
+
+        final Semaphore waiter = new Semaphore(0);
+
+        // Layout with new size
+        getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
+            @Override
+            public void onGlobalLayout() {
+                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN) {
+                    getViewTreeObserver().removeGlobalOnLayoutListener(this);
+                } else {
+                    getViewTreeObserver().removeOnGlobalLayoutListener(this);
+                }
+                waiter.release();
+            }
+        });
+        post(new Runnable() {
+            @Override
+            public void run() {
+                // Show loading
+                addView(new LoadingView(getContext()));
+
+                mGLSurfaceView.requestLayout();
+            }
+        });
+        waiter.acquire();
+
+        // Run one render pass
+        mGPUImage.runOnGLThread(new Runnable() {
+            @Override
+            public void run() {
+                waiter.release();
+            }
+        });
+        requestRender();
+        waiter.acquire();
+        Bitmap bitmap = capture();
+
+
+        mForceSize = null;
+        post(new Runnable() {
+            @Override
+            public void run() {
+                mGLSurfaceView.requestLayout();
+            }
+        });
+        requestRender();
+
+        postDelayed(new Runnable() {
+            @Override
+            public void run() {
+                // Remove loading view
+                removeViewAt(1);
+            }
+        }, 300);
+
+        return bitmap;
+    }
+
+    /**
+     * Capture the current image with the size as it is displayed and retrieve it as Bitmap.
+     * @return current output as Bitmap
+     * @throws InterruptedException
+     */
+    public Bitmap capture() throws InterruptedException {
+        final Semaphore waiter = new Semaphore(0);
+
+        final int width = mGLSurfaceView.getMeasuredWidth();
+        final int height = mGLSurfaceView.getMeasuredHeight();
+
+        // Take picture on OpenGL thread
+        final IntBuffer pixelMirroredBuffer = IntBuffer.allocate(width * height);
+        mGPUImage.runOnGLThread(new Runnable() {
+            @Override
+            public void run() {
+                final IntBuffer pixelBuffer = IntBuffer.allocate(width * height);
+                GLES20.glReadPixels(0, 0, width, height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, pixelBuffer);
+
+                // Convert upside down mirror-reversed image to right-side up normal image.
+                for (int i = 0; i < height; i++) {
+                    for (int j = 0; j < width; j++) {
+                        pixelMirroredBuffer.put((height - i - 1) * width + j, pixelBuffer.get(i * width + j));
+                    }
+                }
+                waiter.release();
+            }
+        });
+        requestRender();
+        waiter.acquire();
+
+        Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
+        bitmap.copyPixelsFromBuffer(pixelMirroredBuffer);
+        return bitmap;
+    }
+
+    /**
+     * Pauses the GLSurfaceView.
+     */
+    public void onPause() {
+        mGLSurfaceView.onPause();
+    }
+
+    /**
+     * Resumes the GLSurfaceView.
+     */
+    public void onResume() {
+        mGLSurfaceView.onResume();
+    }
+
+    public static class Size {
+        int width;
+        int height;
+
+        public Size(int width, int height) {
+            this.width = width;
+            this.height = height;
+        }
+    }
+
+    private class GPUImageGLSurfaceView extends GLSurfaceView {
+        public GPUImageGLSurfaceView(Context context) {
+            super(context);
+        }
+
+        public GPUImageGLSurfaceView(Context context, AttributeSet attrs) {
+            super(context, attrs);
+        }
+
+        @Override
+        protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+            if (mForceSize != null) {
+                super.onMeasure(MeasureSpec.makeMeasureSpec(mForceSize.width, MeasureSpec.EXACTLY),
+                        MeasureSpec.makeMeasureSpec(mForceSize.height, MeasureSpec.EXACTLY));
+            } else {
+                super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+            }
+        }
+    }
+
+    private class LoadingView extends FrameLayout {
+        public LoadingView(Context context) {
+            super(context);
+            init();
+        }
+
+        public LoadingView(Context context, AttributeSet attrs) {
+            super(context, attrs);
+            init();
+        }
+
+        public LoadingView(Context context, AttributeSet attrs, int defStyle) {
+            super(context, attrs, defStyle);
+            init();
+        }
+
+        private void init() {
+            ProgressBar view = new ProgressBar(getContext());
+            view.setLayoutParams(
+                    new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT, Gravity.CENTER));
+            addView(view);
+            setBackgroundColor(Color.BLACK);
+        }
+    }
+
+    private class SaveTask extends AsyncTask<Void, Void, Void> {
+        private final String mFolderName;
+        private final String mFileName;
+        private final int mWidth;
+        private final int mHeight;
+        private final OnPictureSavedListener mListener;
+        private final Handler mHandler;
+
+        public SaveTask(final String folderName, final String fileName,
+                        final OnPictureSavedListener listener) {
+            this(folderName, fileName, 0, 0, listener);
+        }
+
+        public SaveTask(final String folderName, final String fileName, int width, int height,
+                        final OnPictureSavedListener listener) {
+            mFolderName = folderName;
+            mFileName = fileName;
+            mWidth = width;
+            mHeight = height;
+            mListener = listener;
+            mHandler = new Handler();
+        }
+
+        @Override
+        protected Void doInBackground(final Void... params) {
+            try {
+                Bitmap result = mWidth != 0 ? capture(mWidth, mHeight) : capture();
+                saveImage(mFolderName, mFileName, result);
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+            }
+            return null;
+        }
+
+        private void saveImage(final String folderName, final String fileName, final Bitmap image) {
+            File path = Environment
+                    .getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES);
+            File file = new File(path, folderName + "/" + fileName);
+            try {
+                file.getParentFile().mkdirs();
+                image.compress(Bitmap.CompressFormat.JPEG, 80, new FileOutputStream(file));
+                MediaScannerConnection.scanFile(getContext(),
+                        new String[]{
+                                file.toString()
+                        }, null,
+                        new MediaScannerConnection.OnScanCompletedListener() {
+                            @Override
+                            public void onScanCompleted(final String path, final Uri uri) {
+                                if (mListener != null) {
+                                    mHandler.post(new Runnable() {
+
+                                        @Override
+                                        public void run() {
+                                            mListener.onPictureSaved(uri);
+                                        }
+                                    });
+                                }
+                            }
+                        });
+            } catch (FileNotFoundException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    public interface OnPictureSavedListener {
+        void onPictureSaved(Uri uri);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageVignetteFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageVignetteFilter.java
new file mode 100644
index 00000000..439e8bd0
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageVignetteFilter.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.graphics.PointF;
+import android.opengl.GLES20;
+
+/**
+ * Performs a vignetting effect, fading out the image at the edges
+ * x:
+ * y: The directional intensity of the vignetting, with a default of x = 0.75, y = 0.5
+ */
+public class GPUImageVignetteFilter extends GPUImageFilter {
+    public static final String VIGNETTING_FRAGMENT_SHADER = "" +
+            " uniform sampler2D inputImageTexture;\n" +
+            " varying highp vec2 textureCoordinate;\n" +
+            " \n" +
+            " uniform lowp vec2 vignetteCenter;\n" +
+            " uniform lowp vec3 vignetteColor;\n" +
+            " uniform highp float vignetteStart;\n" +
+            " uniform highp float vignetteEnd;\n" +
+            " \n" +
+            " void main()\n" +
+            " {\n" +
+            "     /*\n" +
+            "     lowp vec3 rgb = texture2D(inputImageTexture, textureCoordinate).rgb;\n" +
+            "     lowp float d = distance(textureCoordinate, vec2(0.5,0.5));\n" +
+            "     rgb *= (1.0 - smoothstep(vignetteStart, vignetteEnd, d));\n" +
+            "     gl_FragColor = vec4(vec3(rgb),1.0);\n" +
+            "      */\n" +
+            "     \n" +
+            "     lowp vec3 rgb = texture2D(inputImageTexture, textureCoordinate).rgb;\n" +
+            "     lowp float d = distance(textureCoordinate, vec2(vignetteCenter.x, vignetteCenter.y));\n" +
+            "     lowp float percent = smoothstep(vignetteStart, vignetteEnd, d);\n" +
+            "     gl_FragColor = vec4(mix(rgb.x, vignetteColor.x, percent), mix(rgb.y, vignetteColor.y, percent), mix(rgb.z, vignetteColor.z, percent), 1.0);\n" +
+            " }";
+
+    private int mVignetteCenterLocation;
+    private PointF mVignetteCenter;
+    private int mVignetteColorLocation;
+    private float[] mVignetteColor;
+    private int mVignetteStartLocation;
+    private float mVignetteStart;
+    private int mVignetteEndLocation;
+    private float mVignetteEnd;
+    
+    public GPUImageVignetteFilter() {
+        this(new PointF(), new float[] {0.0f, 0.0f, 0.0f}, 0.3f, 0.75f);
+    }
+    
+    public GPUImageVignetteFilter(final PointF vignetteCenter, final float[] vignetteColor, final float vignetteStart, final float vignetteEnd) {
+        super(NO_FILTER_VERTEX_SHADER, VIGNETTING_FRAGMENT_SHADER);
+        mVignetteCenter = vignetteCenter;
+        mVignetteColor = vignetteColor;
+        mVignetteStart = vignetteStart;
+        mVignetteEnd = vignetteEnd;
+        
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mVignetteCenterLocation = GLES20.glGetUniformLocation(getProgram(), "vignetteCenter");
+        mVignetteColorLocation = GLES20.glGetUniformLocation(getProgram(), "vignetteColor");
+        mVignetteStartLocation = GLES20.glGetUniformLocation(getProgram(), "vignetteStart");
+        mVignetteEndLocation = GLES20.glGetUniformLocation(getProgram(), "vignetteEnd");
+        
+        setVignetteCenter(mVignetteCenter);
+        setVignetteColor(mVignetteColor);
+        setVignetteStart(mVignetteStart);
+        setVignetteEnd(mVignetteEnd);
+    }
+
+
+    public void setVignetteCenter(final PointF vignetteCenter) {
+        mVignetteCenter = vignetteCenter;
+        setPoint(mVignetteCenterLocation, mVignetteCenter);
+    }
+
+    public void setVignetteColor(final float[] vignetteColor) {
+        mVignetteColor = vignetteColor;
+        setFloatVec3(mVignetteColorLocation, mVignetteColor);
+    }
+    
+    public void setVignetteStart(final float vignetteStart) {
+        mVignetteStart = vignetteStart;
+        setFloat(mVignetteStartLocation, mVignetteStart);
+    }
+    
+    public void setVignetteEnd(final float vignetteEnd) {
+        mVignetteEnd = vignetteEnd;
+        setFloat(mVignetteEndLocation, mVignetteEnd);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageWeakPixelInclusionFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageWeakPixelInclusionFilter.java
new file mode 100644
index 00000000..3e1b8f01
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageWeakPixelInclusionFilter.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public class GPUImageWeakPixelInclusionFilter extends GPUImage3x3TextureSamplingFilter {
+    public static final String WEAKPIXEL_FRAGMENT_SHADER = "" +
+            "precision lowp float;\n" +
+            "\n" +
+            "varying vec2 textureCoordinate;\n" +
+            "varying vec2 leftTextureCoordinate;\n" +
+            "varying vec2 rightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 topTextureCoordinate;\n" +
+            "varying vec2 topLeftTextureCoordinate;\n" +
+            "varying vec2 topRightTextureCoordinate;\n" +
+            "\n" +
+            "varying vec2 bottomTextureCoordinate;\n" +
+            "varying vec2 bottomLeftTextureCoordinate;\n" +
+            "varying vec2 bottomRightTextureCoordinate;\n" +
+            "\n" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "float bottomLeftIntensity = texture2D(inputImageTexture, bottomLeftTextureCoordinate).r;\n" +
+            "float topRightIntensity = texture2D(inputImageTexture, topRightTextureCoordinate).r;\n" +
+            "float topLeftIntensity = texture2D(inputImageTexture, topLeftTextureCoordinate).r;\n" +
+            "float bottomRightIntensity = texture2D(inputImageTexture, bottomRightTextureCoordinate).r;\n" +
+            "float leftIntensity = texture2D(inputImageTexture, leftTextureCoordinate).r;\n" +
+            "float rightIntensity = texture2D(inputImageTexture, rightTextureCoordinate).r;\n" +
+            "float bottomIntensity = texture2D(inputImageTexture, bottomTextureCoordinate).r;\n" +
+            "float topIntensity = texture2D(inputImageTexture, topTextureCoordinate).r;\n" +
+            "float centerIntensity = texture2D(inputImageTexture, textureCoordinate).r;\n" +
+            "\n" +
+            "float pixelIntensitySum = bottomLeftIntensity + topRightIntensity + topLeftIntensity + bottomRightIntensity + leftIntensity + rightIntensity + bottomIntensity + topIntensity + centerIntensity;\n" +
+            "float sumTest = step(1.5, pixelIntensitySum);\n" +
+            "float pixelTest = step(0.01, centerIntensity);\n" +
+            "\n" +
+            "gl_FragColor = vec4(vec3(sumTest * pixelTest), 1.0);\n" +
+            "}\n";
+
+    public GPUImageWeakPixelInclusionFilter() {
+        super(WEAKPIXEL_FRAGMENT_SHADER);
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/GPUImageWhiteBalanceFilter.java b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageWhiteBalanceFilter.java
new file mode 100644
index 00000000..1816d829
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/GPUImageWhiteBalanceFilter.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+import android.opengl.GLES20;
+
+/**
+ * Adjusts the white balance of incoming image. <br />
+ * <br />
+ * temperature: 
+ * tint:
+ */
+public class GPUImageWhiteBalanceFilter extends GPUImageFilter {
+    public static final String WHITE_BALANCE_FRAGMENT_SHADER = "" +
+            "uniform sampler2D inputImageTexture;\n" +
+            "varying highp vec2 textureCoordinate;\n" +
+            " \n" +
+            "uniform lowp float temperature;\n" +
+            "uniform lowp float tint;\n" +
+            "\n" +
+            "const lowp vec3 warmFilter = vec3(0.93, 0.54, 0.0);\n" +
+            "\n" +
+            "const mediump mat3 RGBtoYIQ = mat3(0.299, 0.587, 0.114, 0.596, -0.274, -0.322, 0.212, -0.523, 0.311);\n" +
+            "const mediump mat3 YIQtoRGB = mat3(1.0, 0.956, 0.621, 1.0, -0.272, -0.647, 1.0, -1.105, 1.702);\n" +
+            "\n" +
+            "void main()\n" +
+            "{\n" +
+            "	lowp vec4 source = texture2D(inputImageTexture, textureCoordinate);\n" +
+            "	\n" +
+            "	mediump vec3 yiq = RGBtoYIQ * source.rgb; //adjusting tint\n" +
+            "	yiq.b = clamp(yiq.b + tint*0.5226*0.1, -0.5226, 0.5226);\n" +
+            "	lowp vec3 rgb = YIQtoRGB * yiq;\n" +
+            "\n" +
+            "	lowp vec3 processed = vec3(\n" +
+            "		(rgb.r < 0.5 ? (2.0 * rgb.r * warmFilter.r) : (1.0 - 2.0 * (1.0 - rgb.r) * (1.0 - warmFilter.r))), //adjusting temperature\n" +
+            "		(rgb.g < 0.5 ? (2.0 * rgb.g * warmFilter.g) : (1.0 - 2.0 * (1.0 - rgb.g) * (1.0 - warmFilter.g))), \n" +
+            "		(rgb.b < 0.5 ? (2.0 * rgb.b * warmFilter.b) : (1.0 - 2.0 * (1.0 - rgb.b) * (1.0 - warmFilter.b))));\n" +
+            "\n" +
+            "	gl_FragColor = vec4(mix(rgb, processed, temperature), source.a);\n" +
+            "}";
+
+    private int mTemperatureLocation;
+    private float mTemperature;
+    private int mTintLocation;
+    private float mTint;
+
+    public GPUImageWhiteBalanceFilter() {
+        this(5000.0f, 0.0f);
+    }
+    
+    public GPUImageWhiteBalanceFilter(final float temperature, final float tint) {
+        super(NO_FILTER_VERTEX_SHADER, WHITE_BALANCE_FRAGMENT_SHADER);
+        mTemperature = temperature;
+        mTint = tint;
+    }
+
+    @Override
+    public void onInit() {
+        super.onInit();
+        mTemperatureLocation = GLES20.glGetUniformLocation(getProgram(), "temperature");
+        mTintLocation = GLES20.glGetUniformLocation(getProgram(), "tint");
+
+        setTemperature(mTemperature);
+        setTint(mTint);
+    }
+
+
+    public void setTemperature(final float temperature) {
+        mTemperature = temperature;
+        setFloat(mTemperatureLocation, mTemperature < 5000 ? (float)(0.0004 * (mTemperature-5000.0)) : (float)(0.00006 * (mTemperature-5000.0)));
+    }
+    
+    public void setTint(final float tint) {
+        mTint = tint;
+        setFloat(mTintLocation, (float)(mTint/100.0));
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/OpenGlUtils.java b/library/src/jp/co/cyberagent/android/gpuimage/OpenGlUtils.java
index 5db15fbb..e8589704 100644
--- a/library/src/jp/co/cyberagent/android/gpuimage/OpenGlUtils.java
+++ b/library/src/jp/co/cyberagent/android/gpuimage/OpenGlUtils.java
@@ -45,6 +45,7 @@ public static int loadTexture(final Bitmap img, final int usedTexId, final boole
                     GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE);
             GLES20.glTexParameterf(GLES20.GL_TEXTURE_2D,
                     GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE);
+
             GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, img, 0);
         } else {
             GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, usedTexId);
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/Rotation.java b/library/src/jp/co/cyberagent/android/gpuimage/Rotation.java
new file mode 100644
index 00000000..bd2e840e
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/Rotation.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage;
+
+public enum Rotation {
+    NORMAL, ROTATION_90, ROTATION_180, ROTATION_270;
+
+    /**
+     * Retrieves the int representation of the Rotation.
+     *
+     * @return 0, 90, 180 or 270
+     */
+    public int asInt() {
+        switch (this) {
+            case NORMAL: return 0;
+            case ROTATION_90: return 90;
+            case ROTATION_180: return 180;
+            case ROTATION_270: return 270;
+            default: throw new IllegalStateException("Unknown Rotation!");
+        }
+    }
+
+    /**
+     * Create a Rotation from an integer. Needs to be either 0, 90, 180 or 270.
+     *
+     * @param rotation 0, 90, 180 or 270
+     * @return Rotation object
+     */
+    public static Rotation fromInt(int rotation) {
+        switch (rotation) {
+            case 0: return NORMAL;
+            case 90: return ROTATION_90;
+            case 180: return ROTATION_180;
+            case 270: return ROTATION_270;
+            case 360: return NORMAL;
+            default: throw new IllegalStateException(
+                    rotation + " is an unknown rotation. Needs to be either 0, 90, 180 or 270!");
+        }
+    }
+}
diff --git a/library/src/jp/co/cyberagent/android/gpuimage/util/TextureRotationUtil.java b/library/src/jp/co/cyberagent/android/gpuimage/util/TextureRotationUtil.java
new file mode 100644
index 00000000..c439d914
--- /dev/null
+++ b/library/src/jp/co/cyberagent/android/gpuimage/util/TextureRotationUtil.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2012 CyberAgent
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package jp.co.cyberagent.android.gpuimage.util;
+
+import jp.co.cyberagent.android.gpuimage.Rotation;
+
+public class TextureRotationUtil {
+
+    public static final float TEXTURE_NO_ROTATION[] = {
+            0.0f, 1.0f,
+            1.0f, 1.0f,
+            0.0f, 0.0f,
+            1.0f, 0.0f,
+    };
+
+    public static final float TEXTURE_ROTATED_90[] = {
+            1.0f, 1.0f,
+            1.0f, 0.0f,
+            0.0f, 1.0f,
+            0.0f, 0.0f,
+    };
+    public static final float TEXTURE_ROTATED_180[] = {
+            1.0f, 0.0f,
+            0.0f, 0.0f,
+            1.0f, 1.0f,
+            0.0f, 1.0f,
+    };
+    public static final float TEXTURE_ROTATED_270[] = {
+            0.0f, 0.0f,
+            0.0f, 1.0f,
+            1.0f, 0.0f,
+            1.0f, 1.0f,
+    };
+
+    private TextureRotationUtil() {
+    }
+
+    public static float[] getRotation(final Rotation rotation, final boolean flipHorizontal,
+                                                         final boolean flipVertical) {
+        float[] rotatedTex;
+        switch (rotation) {
+            case ROTATION_90:
+                rotatedTex = TEXTURE_ROTATED_90;
+                break;
+            case ROTATION_180:
+                rotatedTex = TEXTURE_ROTATED_180;
+                break;
+            case ROTATION_270:
+                rotatedTex = TEXTURE_ROTATED_270;
+                break;
+            case NORMAL:
+            default:
+                rotatedTex = TEXTURE_NO_ROTATION;
+                break;
+        }
+        if (flipHorizontal) {
+            rotatedTex = new float[]{
+                    flip(rotatedTex[0]), rotatedTex[1],
+                    flip(rotatedTex[2]), rotatedTex[3],
+                    flip(rotatedTex[4]), rotatedTex[5],
+                    flip(rotatedTex[6]), rotatedTex[7],
+            };
+        }
+        if (flipVertical) {
+            rotatedTex = new float[]{
+                    rotatedTex[0], flip(rotatedTex[1]),
+                    rotatedTex[2], flip(rotatedTex[3]),
+                    rotatedTex[4], flip(rotatedTex[5]),
+                    rotatedTex[6], flip(rotatedTex[7]),
+            };
+        }
+        return rotatedTex;
+    }
+
+
+    private static float flip(final float i) {
+        if (i == 0.0f) {
+            return 1.0f;
+        }
+        return 0.0f;
+    }
+}
diff --git a/pom.xml b/pom.xml
index cc397c65..476c80cd 100644
--- a/pom.xml
+++ b/pom.xml
@@ -10,11 +10,11 @@
 
   <groupId>jp.co.cyberagent.android.gpuimage</groupId>
   <artifactId>gpuimage-parent</artifactId>
-  <version>1.0.3</version>
+  <version>1.1.2-SNAPSHOT</version>
   <packaging>pom</packaging>
   <name>GPUImage for Android</name>
   <description>Image filters for Android with OpenGL (based on GPUImage for iOS)</description>
-  <url>https://github.com/cyberagent-jp/android-gpuimage/</url>
+  <url>https://github.com/cyberagent/android-gpuimage/</url>
 
   <modules>
     <module>library</module>
@@ -22,10 +22,10 @@
   </modules>
 
   <scm>
-    <url>git@github.com:cyberagent-jp/android-gpuimage.git</url>
-    <connection>scm:git:git@github.com:cyberagent-jp/android-gpuimage.git</connection>
-    <developerConnection>scm:git:git@github.com:cyberagent-jp/android-gpuimage.git</developerConnection>
-    <tag>v1.0.3</tag>
+    <url>git@github.com:CyberAgent/android-gpuimage.git</url>
+    <connection>scm:git:git@github.com:CyberAgent/android-gpuimage.git</connection>
+    <developerConnection>scm:git:git@github.com:CyberAgent/android-gpuimage.git</developerConnection>
+    <tag>HEAD</tag>
   </scm>
   <developers>
     <developer>
@@ -54,7 +54,7 @@
     <java.version>1.6</java.version>
     <android.version>4.1.1.4</android.version>
     <android.platform>16</android.platform>
-    <android-maven.version>3.2.0</android-maven.version>
+    <android-maven.version>3.6.0</android-maven.version>
   </properties>
 
   <build>
diff --git a/release.sh b/release.sh
index db1e2f22..a7e0d759 100755
--- a/release.sh
+++ b/release.sh
@@ -22,10 +22,15 @@ function updateManifest {
 updateManifest "sample/AndroidManifest.xml"
 updateManifest "library/AndroidManifest.xml"
 
+# update build.gradle
+perl -pi -e "s/version = \"(.*)\"/version = \"$VERSION\"/g" library/build.gradle
+
 echo ""
 echo "# Now run:"
 echo ""
 echo git commit -a -m \"Update version to v$VERSION\"
 echo mvn release:clean
 echo mvn release:prepare
-echo mvn release:perform
\ No newline at end of file
+echo mvn release:perform
+echo ""
+echo "./gradlew uploadArchives"
diff --git a/sample/AndroidManifest.xml b/sample/AndroidManifest.xml
index b09e04dc..dfd98f0e 100644
--- a/sample/AndroidManifest.xml
+++ b/sample/AndroidManifest.xml
@@ -10,6 +10,9 @@
     <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
     <uses-permission android:name="android.permission.CAMERA" />
 
+    <!-- For images from picasa -->
+    <uses-permission android:name="android.permission.INTERNET" />
+
     <application
         android:hardwareAccelerated="true"
         android:icon="@drawable/ic_launcher"
diff --git a/sample/build.gradle b/sample/build.gradle
new file mode 100644
index 00000000..b27d0f49
--- /dev/null
+++ b/sample/build.gradle
@@ -0,0 +1,45 @@
+apply plugin: 'android'
+
+dependencies {
+    compile project(':library')
+}
+
+android {
+    compileSdkVersion 17
+    buildToolsVersion "17.0.0"
+
+    defaultConfig {
+        minSdkVersion 8
+        targetSdkVersion 16
+    }
+
+    sourceSets {
+        main {
+            manifest.srcFile 'AndroidManifest.xml'
+            java.srcDirs = ['src']
+            resources.srcDirs = ['src']
+            aidl.srcDirs = ['src']
+            renderscript.srcDirs = ['src']
+            res.srcDirs = ['res']
+            assets.srcDirs = ['assets']
+        }
+
+        instrumentTest.setRoot('tests')
+    }
+}
+
+//////////////
+// NDK Support
+//////////////
+task copyNativeLibs(type: Copy) {
+    from(new File('libs')) { include '**/*.so' }
+    into new File(buildDir, 'native-libs')
+}
+
+tasks.withType(Compile) { compileTask -> compileTask.dependsOn copyNativeLibs }
+
+clean.dependsOn 'cleanCopyNativeLibs'
+
+tasks.withType(com.android.build.gradle.tasks.PackageApplication) { pkgTask ->
+    pkgTask.jniDir new File(buildDir, 'native-libs')
+}
\ No newline at end of file
diff --git a/sample/libs/armeabi/libgpuimage-library.so b/sample/libs/armeabi/libgpuimage-library.so
new file mode 100755
index 00000000..ed495b75
Binary files /dev/null and b/sample/libs/armeabi/libgpuimage-library.so differ
diff --git a/sample/libs/x86/libgpuimage-library.so b/sample/libs/x86/libgpuimage-library.so
new file mode 100755
index 00000000..7bdd9e55
Binary files /dev/null and b/sample/libs/x86/libgpuimage-library.so differ
diff --git a/sample/pom.xml b/sample/pom.xml
index f9b6974c..e3950f19 100644
--- a/sample/pom.xml
+++ b/sample/pom.xml
@@ -10,7 +10,7 @@
   <parent>
     <groupId>jp.co.cyberagent.android.gpuimage</groupId>
     <artifactId>gpuimage-parent</artifactId>
-    <version>1.0.3</version>
+    <version>1.1.2-SNAPSHOT</version>
   </parent>
 
   <dependencies>
diff --git a/sample/project.properties b/sample/project.properties
index 8cb211b5..24e0cbf3 100644
--- a/sample/project.properties
+++ b/sample/project.properties
@@ -12,5 +12,5 @@
 
 # Project target.
 target=android-16
-android.library.reference.1=../library
-proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
\ No newline at end of file
+proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+android.library.reference.1=../library
\ No newline at end of file
diff --git a/sample/res/drawable-nodpi/lookup_amatorka.png b/sample/res/drawable-nodpi/lookup_amatorka.png
new file mode 100644
index 00000000..4a2cc8ac
Binary files /dev/null and b/sample/res/drawable-nodpi/lookup_amatorka.png differ
diff --git a/sample/res/layout/activity_gallery.xml b/sample/res/layout/activity_gallery.xml
index 9667f125..c2575162 100644
--- a/sample/res/layout/activity_gallery.xml
+++ b/sample/res/layout/activity_gallery.xml
@@ -2,15 +2,16 @@
     android:layout_width="match_parent"
     android:layout_height="match_parent"
     android:background="#000000"
-    android:orientation="vertical" >
+    android:orientation="vertical">
 
     <FrameLayout
         android:layout_width="match_parent"
         android:layout_height="0dp"
-        android:layout_weight="1" >
+        android:layout_weight="1">
 
-        <android.opengl.GLSurfaceView
-            android:id="@+id/surfaceView"
+        <jp.co.cyberagent.android.gpuimage.GPUImageView
+            android:id="@+id/gpuimage"
+            android:layout_gravity="center"
             android:layout_width="wrap_content"
             android:layout_height="wrap_content" />
 
@@ -25,7 +26,7 @@
     <LinearLayout
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
-        android:layout_gravity="center_horizontal" >
+        android:layout_gravity="center_horizontal">
 
         <Button
             android:id="@+id/button_choose_filter"
diff --git a/sample/res/raw/tone_cuver_sample.acv b/sample/res/raw/tone_cuver_sample.acv
new file mode 100644
index 00000000..5b6c9555
Binary files /dev/null and b/sample/res/raw/tone_cuver_sample.acv differ
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
index ba0d4568..3e878c8a 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/GPUImageFilterTools.java
@@ -19,29 +19,21 @@
 import java.util.LinkedList;
 import java.util.List;
 
-import jp.co.cyberagent.android.gpuimage.GPUImage3x3ConvolutionFilter;
-import jp.co.cyberagent.android.gpuimage.GPUImage3x3TextureSamplingFilter;
-import jp.co.cyberagent.android.gpuimage.GPUImageBrightnessFilter;
-import jp.co.cyberagent.android.gpuimage.GPUImageContrastFilter;
-import jp.co.cyberagent.android.gpuimage.GPUImageDirectionalSobelEdgeDetectionFilter;
-import jp.co.cyberagent.android.gpuimage.GPUImageEmbossFilter;
-import jp.co.cyberagent.android.gpuimage.GPUImageFilter;
-import jp.co.cyberagent.android.gpuimage.GPUImageFilterGroup;
-import jp.co.cyberagent.android.gpuimage.GPUImageGammaFilter;
-import jp.co.cyberagent.android.gpuimage.GPUImageGrayscaleFilter;
-import jp.co.cyberagent.android.gpuimage.GPUImagePosterizeFilter;
-import jp.co.cyberagent.android.gpuimage.GPUImageSepiaFilter;
-import jp.co.cyberagent.android.gpuimage.GPUImageSharpenFilter;
-import jp.co.cyberagent.android.gpuimage.GPUImageSobelEdgeDetection;
+import jp.co.cyberagent.android.gpuimage.*;
 import android.app.AlertDialog;
 import android.content.Context;
 import android.content.DialogInterface;
+import android.graphics.BitmapFactory;
+import android.graphics.PointF;
 
-public class GPUImageFilterTools {
+public class GPUImageFilterTools {  
     public static void showDialog(final Context context,
             final OnGpuImageFilterChosenListener listener) {
         final FilterList filters = new FilterList();
         filters.addFilter("Contrast", FilterType.CONTRAST);
+        filters.addFilter("Invert", FilterType.INVERT);
+        filters.addFilter("Pixelation", FilterType.PIXELATION);
+        filters.addFilter("Hue", FilterType.HUE);
         filters.addFilter("Gamma", FilterType.GAMMA);
         filters.addFilter("Brightness", FilterType.BRIGHTNESS);
         filters.addFilter("Sepia", FilterType.SEPIA);
@@ -52,6 +44,63 @@ public static void showDialog(final Context context,
         filters.addFilter("Emboss", FilterType.EMBOSS);
         filters.addFilter("Posterize", FilterType.POSTERIZE);
         filters.addFilter("Grouped filters", FilterType.FILTER_GROUP);
+        filters.addFilter("Saturation", FilterType.SATURATION);
+        filters.addFilter("Exposure", FilterType.EXPOSURE);
+        filters.addFilter("Highlight Shadow", FilterType.HIGHLIGHT_SHADOW);
+        filters.addFilter("Monochrome", FilterType.MONOCHROME);
+        filters.addFilter("Opacity", FilterType.OPACITY);
+        filters.addFilter("RGB", FilterType.RGB);
+        filters.addFilter("White Balance", FilterType.WHITE_BALANCE);
+        filters.addFilter("Vignette", FilterType.VIGNETTE);
+        filters.addFilter("ToneCurve", FilterType.TONE_CURVE);
+
+        filters.addFilter("Blend (Difference)", FilterType.BLEND_DIFFERENCE);
+        filters.addFilter("Blend (Source Over)", FilterType.BLEND_SOURCE_OVER);
+        filters.addFilter("Blend (Color Burn)", FilterType.BLEND_COLOR_BURN);
+        filters.addFilter("Blend (Color Dodge)", FilterType.BLEND_COLOR_DODGE);
+        filters.addFilter("Blend (Darken)", FilterType.BLEND_DARKEN);
+        filters.addFilter("Blend (Dissolve)", FilterType.BLEND_DISSOLVE);
+        filters.addFilter("Blend (Exclusion)", FilterType.BLEND_EXCLUSION);
+        filters.addFilter("Blend (Hard Light)", FilterType.BLEND_HARD_LIGHT);
+        filters.addFilter("Blend (Lighten)", FilterType.BLEND_LIGHTEN);
+        filters.addFilter("Blend (Add)", FilterType.BLEND_ADD);
+        filters.addFilter("Blend (Divide)", FilterType.BLEND_DIVIDE);
+        filters.addFilter("Blend (Multiply)", FilterType.BLEND_MULTIPLY);
+        filters.addFilter("Blend (Overlay)", FilterType.BLEND_OVERLAY);
+        filters.addFilter("Blend (Screen)", FilterType.BLEND_SCREEN);
+        filters.addFilter("Blend (Alpha)", FilterType.BLEND_ALPHA);
+        filters.addFilter("Blend (Color)", FilterType.BLEND_COLOR);
+        filters.addFilter("Blend (Hue)", FilterType.BLEND_HUE);
+        filters.addFilter("Blend (Saturation)", FilterType.BLEND_SATURATION);
+        filters.addFilter("Blend (Luminosity)", FilterType.BLEND_LUMINOSITY);
+        filters.addFilter("Blend (Linear Burn)", FilterType.BLEND_LINEAR_BURN);
+        filters.addFilter("Blend (Soft Light)", FilterType.BLEND_SOFT_LIGHT);
+        filters.addFilter("Blend (Subtract)", FilterType.BLEND_SUBTRACT);
+        filters.addFilter("Blend (Chroma Key)", FilterType.BLEND_CHROMA_KEY);
+        filters.addFilter("Blend (Normal)", FilterType.BLEND_NORMAL);
+
+        filters.addFilter("Lookup (Amatorka)", FilterType.LOOKUP_AMATORKA);
+        filters.addFilter("Gaussian Blur", FilterType.GAUSSIAN_BLUR);
+        filters.addFilter("Crosshatch", FilterType.CROSSHATCH);
+
+        filters.addFilter("Box Blur", FilterType.BOX_BLUR);
+        filters.addFilter("CGA Color Space", FilterType.CGA_COLORSPACE);
+        filters.addFilter("Dilation", FilterType.DILATION);
+        filters.addFilter("Kuwahara", FilterType.KUWAHARA);
+        filters.addFilter("RGB Dilation", FilterType.RGB_DILATION);
+        filters.addFilter("Sketch", FilterType.SKETCH);
+        filters.addFilter("Toon", FilterType.TOON);
+        filters.addFilter("Smooth Toon", FilterType.SMOOTH_TOON);
+
+        filters.addFilter("Bulge Distortion", FilterType.BULGE_DISTORTION);
+        filters.addFilter("Glass Sphere", FilterType.GLASS_SPHERE);
+        filters.addFilter("Haze", FilterType.HAZE);
+        filters.addFilter("Laplacian", FilterType.LAPLACIAN);
+        filters.addFilter("Non Maximum Suppression", FilterType.NON_MAXIMUM_SUPPRESSION);
+        filters.addFilter("Sphere Refraction", FilterType.SPHERE_REFRACTION);
+        filters.addFilter("Swirl", FilterType.SWIRL);
+        filters.addFilter("Weak Pixel Inclusion", FilterType.WEAK_PIXEL_INCLUSION);
+        filters.addFilter("False Color", FilterType.FALSE_COLOR);
 
         AlertDialog.Builder builder = new AlertDialog.Builder(context);
         builder.setTitle("Choose a filter");
@@ -72,6 +121,12 @@ private static GPUImageFilter createFilterForType(final Context context, final F
                 return new GPUImageContrastFilter(2.0f);
             case GAMMA:
                 return new GPUImageGammaFilter(2.0f);
+            case INVERT:
+                return new GPUImageColorInvertFilter();
+            case PIXELATION:
+                return new GPUImagePixelationFilter();
+            case HUE:
+                return new GPUImageHueFilter(90.0f);
             case BRIGHTNESS:
                 return new GPUImageBrightnessFilter(1.5f);
             case GRAYSCALE:
@@ -102,18 +157,154 @@ private static GPUImageFilter createFilterForType(final Context context, final F
                 filters.add(new GPUImageDirectionalSobelEdgeDetectionFilter());
                 filters.add(new GPUImageGrayscaleFilter());
                 return new GPUImageFilterGroup(filters);
+            case SATURATION:
+                return new GPUImageSaturationFilter(1.0f);
+            case EXPOSURE:
+                return new GPUImageExposureFilter(0.0f);
+            case HIGHLIGHT_SHADOW:
+            	return new GPUImageHighlightShadowFilter(0.0f, 1.0f);
+            case MONOCHROME:
+            	return new GPUImageMonochromeFilter(1.0f, new float[]{0.6f, 0.45f, 0.3f, 1.0f});
+            case OPACITY:
+                return new GPUImageOpacityFilter(1.0f);  
+            case RGB:
+                return new GPUImageRGBFilter(1.0f, 1.0f, 1.0f);  
+            case WHITE_BALANCE:
+                return new GPUImageWhiteBalanceFilter(5000.0f, 0.0f);    
+            case VIGNETTE:
+                PointF centerPoint = new PointF();
+                centerPoint.x = 0.5f;
+                centerPoint.y = 0.5f;
+                return new GPUImageVignetteFilter(centerPoint, new float[] {0.0f, 0.0f, 0.0f}, 0.3f, 0.75f);
+            case TONE_CURVE:
+                GPUImageToneCurveFilter toneCurveFilter = new GPUImageToneCurveFilter();
+                toneCurveFilter.setFromCurveFileInputStream(
+                        context.getResources().openRawResource(R.raw.tone_cuver_sample));
+                return toneCurveFilter;
+            case BLEND_DIFFERENCE:
+                return createBlendFilter(context, GPUImageDifferenceBlendFilter.class);
+            case BLEND_SOURCE_OVER:
+                return createBlendFilter(context, GPUImageSourceOverBlendFilter.class);
+            case BLEND_COLOR_BURN:
+                return createBlendFilter(context, GPUImageColorBurnBlendFilter.class);
+            case BLEND_COLOR_DODGE:
+                return createBlendFilter(context, GPUImageColorDodgeBlendFilter.class);
+            case BLEND_DARKEN:
+                return createBlendFilter(context, GPUImageDarkenBlendFilter.class);
+            case BLEND_DISSOLVE:
+                return createBlendFilter(context, GPUImageDissolveBlendFilter.class);
+            case BLEND_EXCLUSION:
+                return createBlendFilter(context, GPUImageExclusionBlendFilter.class);
+
+
+            case BLEND_HARD_LIGHT:
+                return createBlendFilter(context, GPUImageHardLightBlendFilter.class);
+            case BLEND_LIGHTEN:
+                return createBlendFilter(context, GPUImageLightenBlendFilter.class);
+            case BLEND_ADD:
+                return createBlendFilter(context, GPUImageAddBlendFilter.class);
+            case BLEND_DIVIDE:
+                return createBlendFilter(context, GPUImageDivideBlendFilter.class);
+            case BLEND_MULTIPLY:
+                return createBlendFilter(context, GPUImageMultiplyBlendFilter.class);
+            case BLEND_OVERLAY:
+                return createBlendFilter(context, GPUImageOverlayBlendFilter.class);
+            case BLEND_SCREEN:
+                return createBlendFilter(context, GPUImageScreenBlendFilter.class);
+            case BLEND_ALPHA:
+                return createBlendFilter(context, GPUImageAlphaBlendFilter.class);
+            case BLEND_COLOR:
+                return createBlendFilter(context, GPUImageColorBlendFilter.class);
+            case BLEND_HUE:
+                return createBlendFilter(context, GPUImageHueBlendFilter.class);
+            case BLEND_SATURATION:
+                return createBlendFilter(context, GPUImageSaturationBlendFilter.class);
+            case BLEND_LUMINOSITY:
+                return createBlendFilter(context, GPUImageLuminosityBlendFilter.class);
+            case BLEND_LINEAR_BURN:
+                return createBlendFilter(context, GPUImageLinearBurnBlendFilter.class);
+            case BLEND_SOFT_LIGHT:
+                return createBlendFilter(context, GPUImageSoftLightBlendFilter.class);
+            case BLEND_SUBTRACT:
+                return createBlendFilter(context, GPUImageSubtractBlendFilter.class);
+            case BLEND_CHROMA_KEY:
+                return createBlendFilter(context, GPUImageChromaKeyBlendFilter.class);
+            case BLEND_NORMAL:
+                return createBlendFilter(context, GPUImageNormalBlendFilter.class);
+
+            case LOOKUP_AMATORKA:
+                GPUImageLookupFilter amatorka = new GPUImageLookupFilter();
+                amatorka.setBitmap(BitmapFactory.decodeResource(context.getResources(), R.drawable.lookup_amatorka));
+                return amatorka;
+            case GAUSSIAN_BLUR:
+                return new GPUImageGaussianBlurFilter();
+            case CROSSHATCH:
+                return new GPUImageCrosshatchFilter();
+
+            case BOX_BLUR:
+                return new GPUImageBoxBlurFilter();
+            case CGA_COLORSPACE:
+                return new GPUImageCGAColorspaceFilter();
+            case DILATION:
+                return new GPUImageDilationFilter();
+            case KUWAHARA:
+                return new GPUImageKuwaharaFilter();
+            case RGB_DILATION:
+                return new GPUImageRGBDilationFilter();
+            case SKETCH:
+                return new GPUImageSketchFilter();
+            case TOON:
+                return new GPUImageToonFilter();
+            case SMOOTH_TOON:
+                return new GPUImageSmoothToonFilter();
+
+            case BULGE_DISTORTION:
+                return new GPUImageBulgeDistortionFilter();
+            case GLASS_SPHERE:
+                return new GPUImageGlassSphereFilter();
+            case HAZE:
+                return new GPUImageHazeFilter();
+            case LAPLACIAN:
+                return new GPUImageLaplacianFilter();
+            case NON_MAXIMUM_SUPPRESSION:
+                return new GPUImageNonMaximumSuppressionFilter();
+            case SPHERE_REFRACTION:
+                return new GPUImageSphereRefractionFilter();
+            case SWIRL:
+                return new GPUImageSwirlFilter();
+            case WEAK_PIXEL_INCLUSION:
+                return new GPUImageWeakPixelInclusionFilter();
+            case FALSE_COLOR:
+                return new GPUImageFalseColorFilter();
+
             default:
                 throw new IllegalStateException("No filter of that type!");
         }
 
     }
 
+    private static GPUImageFilter createBlendFilter(Context context, Class<? extends GPUImageTwoInputFilter> filterClass) {
+        try {
+            GPUImageTwoInputFilter filter = filterClass.newInstance();
+            filter.setBitmap(BitmapFactory.decodeResource(context.getResources(), R.drawable.ic_launcher));
+            return filter;
+        } catch (Exception e) {
+            e.printStackTrace();
+            return null;
+        }
+    }
+
     public interface OnGpuImageFilterChosenListener {
         void onGpuImageFilterChosenListener(GPUImageFilter filter);
     }
 
     private enum FilterType {
-        CONTRAST, GRAYSCALE, SHARPEN, SEPIA, SOBEL_EDGE_DETECTION, THREE_X_THREE_CONVOLUTION, FILTER_GROUP, EMBOSS, POSTERIZE, GAMMA, BRIGHTNESS,
+        CONTRAST, GRAYSCALE, SHARPEN, SEPIA, SOBEL_EDGE_DETECTION, THREE_X_THREE_CONVOLUTION, FILTER_GROUP, EMBOSS, POSTERIZE, GAMMA, BRIGHTNESS, INVERT, HUE, PIXELATION,
+        SATURATION, EXPOSURE, HIGHLIGHT_SHADOW, MONOCHROME, OPACITY, RGB, WHITE_BALANCE, VIGNETTE, TONE_CURVE, BLEND_COLOR_BURN, BLEND_COLOR_DODGE, BLEND_DARKEN, BLEND_DIFFERENCE,
+        BLEND_DISSOLVE, BLEND_EXCLUSION, BLEND_SOURCE_OVER, BLEND_HARD_LIGHT, BLEND_LIGHTEN, BLEND_ADD, BLEND_DIVIDE, BLEND_MULTIPLY, BLEND_OVERLAY, BLEND_SCREEN, BLEND_ALPHA,
+        BLEND_COLOR, BLEND_HUE, BLEND_SATURATION, BLEND_LUMINOSITY, BLEND_LINEAR_BURN, BLEND_SOFT_LIGHT, BLEND_SUBTRACT, BLEND_CHROMA_KEY, BLEND_NORMAL, LOOKUP_AMATORKA,
+        GAUSSIAN_BLUR, CROSSHATCH, BOX_BLUR, CGA_COLORSPACE, DILATION, KUWAHARA, RGB_DILATION, SKETCH, TOON, SMOOTH_TOON, BULGE_DISTORTION, GLASS_SPHERE, HAZE, LAPLACIAN, NON_MAXIMUM_SUPPRESSION,
+        SPHERE_REFRACTION, SWIRL, WEAK_PIXEL_INCLUSION, FALSE_COLOR
     }
 
     private static class FilterList {
@@ -142,17 +333,57 @@ public FilterAdjuster(final GPUImageFilter filter) {
                 adjuster = new BrightnessAdjuster().filter(filter);
             } else if (filter instanceof GPUImageSobelEdgeDetection) {
                 adjuster = new SobelAdjuster().filter(filter);
-            } else if (filter instanceof GPUImage3x3TextureSamplingFilter) {
-                adjuster = new GPU3x3TextureAdjuster().filter(filter);
             } else if (filter instanceof GPUImageEmbossFilter) {
                 adjuster = new EmbossAdjuster().filter(filter);
+            } else if (filter instanceof GPUImage3x3TextureSamplingFilter) {
+                adjuster = new GPU3x3TextureAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageHueFilter) {
+                adjuster = new HueAdjuster().filter(filter);
             } else if (filter instanceof GPUImagePosterizeFilter) {
                 adjuster = new PosterizeAdjuster().filter(filter);
+            } else if (filter instanceof GPUImagePixelationFilter) {
+                adjuster = new PixelationAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageSaturationFilter) {
+                adjuster = new SaturationAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageExposureFilter) {
+                adjuster = new ExposureAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageHighlightShadowFilter) {
+                adjuster = new HighlightShadowAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageMonochromeFilter) {
+                adjuster = new MonochromeAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageOpacityFilter) {
+                adjuster = new OpacityAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageRGBFilter) {
+                adjuster = new RGBAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageWhiteBalanceFilter) {
+                adjuster = new WhiteBalanceAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageVignetteFilter) {
+                adjuster = new VignetteAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageDissolveBlendFilter) {
+                adjuster = new DissolveBlendAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageGaussianBlurFilter) {
+                adjuster = new GaussianBlurAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageCrosshatchFilter) {
+                adjuster = new CrosshatchBlurAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageBulgeDistortionFilter) {
+                adjuster = new BulgeDistortionAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageGlassSphereFilter) {
+                adjuster = new GlassSphereAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageHazeFilter) {
+                adjuster = new HazeAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageSphereRefractionFilter) {
+                adjuster = new SphereRefractionAdjuster().filter(filter);
+            } else if (filter instanceof GPUImageSwirlFilter) {
+                adjuster = new SwirlAdjuster().filter(filter);
             } else {
                 adjuster = null;
             }
         }
 
+        public boolean canAdjust() {
+            return adjuster != null;
+        }
+
         public void adjust(final int percentage) {
             if (adjuster != null) {
                 adjuster.adjust(percentage);
@@ -190,6 +421,20 @@ public void adjust(final int percentage) {
             }
         }
 
+        private class PixelationAdjuster extends Adjuster<GPUImagePixelationFilter> {
+          @Override
+          public void adjust(final int percentage) {
+              getFilter().setPixel(range(percentage, 1.0f, 100.0f));
+          }
+        }
+
+        private class HueAdjuster extends Adjuster<GPUImageHueFilter> {
+          @Override
+          public void adjust(final int percentage) {
+            getFilter().setHue(range(percentage, 0.0f, 360.0f));
+          }
+        }
+
         private class ContrastAdjuster extends Adjuster<GPUImageContrastFilter> {
             @Override
             public void adjust(final int percentage) {
@@ -246,5 +491,125 @@ public void adjust(final int percentage) {
                 getFilter().setLineSize(range(percentage, 0.0f, 5.0f));
             }
         }
+
+        private class SaturationAdjuster extends Adjuster<GPUImageSaturationFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setSaturation(range(percentage, 0.0f, 2.0f));
+            }
+        }
+        
+        private class ExposureAdjuster extends Adjuster<GPUImageExposureFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setExposure(range(percentage, -10.0f, 10.0f));
+            }
+        }   
+        
+        private class HighlightShadowAdjuster extends Adjuster<GPUImageHighlightShadowFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setShadows(range(percentage, 0.0f, 1.0f));
+                getFilter().setHighlights(range(percentage, 0.0f, 1.0f));
+            }
+        }
+        
+        private class MonochromeAdjuster extends Adjuster<GPUImageMonochromeFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setIntensity(range(percentage, 0.0f, 1.0f));
+                //getFilter().setColor(new float[]{0.6f, 0.45f, 0.3f, 1.0f});
+            }
+        }
+        
+        private class OpacityAdjuster extends Adjuster<GPUImageOpacityFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setOpacity(range(percentage, 0.0f, 1.0f));
+            }
+        }   
+        
+        private class RGBAdjuster extends Adjuster<GPUImageRGBFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setRed(range(percentage, 0.0f, 1.0f));
+                //getFilter().setGreen(range(percentage, 0.0f, 1.0f));
+                //getFilter().setBlue(range(percentage, 0.0f, 1.0f));
+            }
+        }   
+        
+        private class WhiteBalanceAdjuster extends Adjuster<GPUImageWhiteBalanceFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setTemperature(range(percentage, 2000.0f, 8000.0f));
+                //getFilter().setTint(range(percentage, -100.0f, 100.0f));
+            }
+        }
+
+        private class VignetteAdjuster extends Adjuster<GPUImageVignetteFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setVignetteStart(range(percentage, 0.0f, 1.0f));
+            }
+        }
+
+        private class DissolveBlendAdjuster extends Adjuster<GPUImageDissolveBlendFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setMix(range(percentage, 0.0f, 1.0f));
+            }
+        }
+
+        private class GaussianBlurAdjuster extends Adjuster<GPUImageGaussianBlurFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setBlurSize(range(percentage, 0.0f, 1.0f));
+            }
+        }
+
+        private class CrosshatchBlurAdjuster extends Adjuster<GPUImageCrosshatchFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setCrossHatchSpacing(range(percentage, 0.0f, 0.06f));
+                getFilter().setLineWidth(range(percentage, 0.0f, 0.006f));
+            }
+        }
+
+        private class BulgeDistortionAdjuster extends Adjuster<GPUImageBulgeDistortionFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setRadius(range(percentage, 0.0f, 1.0f));
+                getFilter().setScale(range(percentage, -1.0f, 1.0f));
+            }
+        }
+
+        private class GlassSphereAdjuster extends Adjuster<GPUImageGlassSphereFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setRadius(range(percentage, 0.0f, 1.0f));
+            }
+        }
+
+        private class HazeAdjuster extends Adjuster<GPUImageHazeFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setDistance(range(percentage, -0.3f, 0.3f));
+                getFilter().setSlope(range(percentage, -0.3f, 0.3f));
+            }
+        }
+
+        private class SphereRefractionAdjuster extends Adjuster<GPUImageSphereRefractionFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setRadius(range(percentage, 0.0f, 1.0f));
+            }
+        }
+
+        private class SwirlAdjuster extends Adjuster<GPUImageSwirlFilter> {
+            @Override
+            public void adjust(final int percentage) {
+                getFilter().setAngle(range(percentage, 0.0f, 2.0f));
+            }
+        }
     }
 }
diff --git a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityGallery.java b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityGallery.java
index 1416b6b2..ad734823 100644
--- a/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityGallery.java
+++ b/sample/src/jp/co/cyberagent/android/gpuimage/sample/activity/ActivityGallery.java
@@ -16,9 +16,9 @@
 
 package jp.co.cyberagent.android.gpuimage.sample.activity;
 
-import jp.co.cyberagent.android.gpuimage.GPUImage;
-import jp.co.cyberagent.android.gpuimage.GPUImage.OnPictureSavedListener;
 import jp.co.cyberagent.android.gpuimage.GPUImageFilter;
+import jp.co.cyberagent.android.gpuimage.GPUImageView;
+import jp.co.cyberagent.android.gpuimage.GPUImageView.OnPictureSavedListener;
 import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools;
 import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools.FilterAdjuster;
 import jp.co.cyberagent.android.gpuimage.sample.GPUImageFilterTools.OnGpuImageFilterChosenListener;
@@ -26,7 +26,6 @@
 import android.app.Activity;
 import android.content.Intent;
 import android.net.Uri;
-import android.opengl.GLSurfaceView;
 import android.os.Bundle;
 import android.view.View;
 import android.view.View.OnClickListener;
@@ -40,7 +39,7 @@
     private static final int REQUEST_PICK_IMAGE = 1;
     private GPUImageFilter mFilter;
     private FilterAdjuster mFilterAdjuster;
-    private GPUImage mGPUImage;
+    private GPUImageView mGPUImageView;
 
     @Override
     public void onCreate(final Bundle savedInstanceState) {
@@ -50,8 +49,7 @@ public void onCreate(final Bundle savedInstanceState) {
         findViewById(R.id.button_choose_filter).setOnClickListener(this);
         findViewById(R.id.button_save).setOnClickListener(this);
 
-        mGPUImage = new GPUImage(this);
-        mGPUImage.setGLSurfaceView((GLSurfaceView) findViewById(R.id.surfaceView));
+        mGPUImageView = (GPUImageView) findViewById(R.id.gpuimage);
 
         Intent photoPickerIntent = new Intent(Intent.ACTION_PICK);
         photoPickerIntent.setType("image/*");
@@ -84,7 +82,7 @@ public void onClick(final View v) {
                     @Override
                     public void onGpuImageFilterChosenListener(final GPUImageFilter filter) {
                         switchFilterTo(filter);
-                        mGPUImage.requestRender();
+                        mGPUImageView.requestRender();
                     }
 
                 });
@@ -106,15 +104,19 @@ public void onPictureSaved(final Uri uri) {
 
     private void saveImage() {
         String fileName = System.currentTimeMillis() + ".jpg";
-        mGPUImage.saveToPictures("GPUImage", fileName, this);
+        mGPUImageView.saveToPictures("GPUImage", fileName, this);
+//        mGPUImageView.saveToPictures("GPUImage", fileName, 1600, 1600, this);
     }
 
     private void switchFilterTo(final GPUImageFilter filter) {
         if (mFilter == null
                 || (filter != null && !mFilter.getClass().equals(filter.getClass()))) {
             mFilter = filter;
-            mGPUImage.setFilter(mFilter);
+            mGPUImageView.setFilter(mFilter);
             mFilterAdjuster = new FilterAdjuster(mFilter);
+
+            findViewById(R.id.seekBar).setVisibility(
+                    mFilterAdjuster.canAdjust() ? View.VISIBLE : View.GONE);
         }
     }
 
@@ -123,7 +125,7 @@ public void onProgressChanged(final SeekBar seekBar, final int progress, final b
         if (mFilterAdjuster != null) {
             mFilterAdjuster.adjust(progress);
         }
-        mGPUImage.requestRender();
+        mGPUImageView.requestRender();
     }
 
     @Override
@@ -135,6 +137,6 @@ public void onStopTrackingTouch(final SeekBar seekBar) {
     }
 
     private void handleImage(final Uri selectedImage) {
-        mGPUImage.setImage(selectedImage);
+        mGPUImageView.setImage(selectedImage);
     }
 }
diff --git a/settings.gradle b/settings.gradle
new file mode 100644
index 00000000..612d9e44
--- /dev/null
+++ b/settings.gradle
@@ -0,0 +1,2 @@
+include ':library'
+include ':sample'
diff --git a/utils/Shader2String.py b/utils/Shader2String.py
new file mode 100644
index 00000000..f3127006
--- /dev/null
+++ b/utils/Shader2String.py
@@ -0,0 +1,14 @@
+#!/usr/bin/python
+
+import sys
+
+f = sys.stdin
+if len(sys.argv) > 1:
+  f = open(sys.argv[1])
+
+lines = f.readlines()
+for line in lines[:-1]:
+  print '"' + line.rstrip() + '\\n\" +'
+print '"' + lines[-1].rstrip() + '\\n\"'
+
+f.close()
