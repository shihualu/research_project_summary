diff --git a/.travis.yml b/.travis.yml
index 49ca80a24..ca2710015 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -13,7 +13,9 @@ addons:
     packages:
       - oracle-java8-installer
       - libstdc++-4.9-dev # https://github.com/nodegit/nodegit/issues/853
-      - bazel=0.4.3
+      - bazel=0.4.5
+      - gcc-4.8
+      - g++-4.8
 
 jdk:
   - &jdk_for_publishing oraclejdk8
@@ -22,28 +24,22 @@ android:
   components:
     - tools
     - tools # Duplicated as per https://github.com/travis-ci/travis-ci/issues/6040#issuecomment-219367943
-    - build-tools-25.0.0
+    - build-tools-25.0.2
     - android-25
     - platform-tools
     - extra-android-m2repository
 
 before_install:
-  - echo "ANDROID_HOME = \"$ANDROID_HOME\"" > WORKSPACE.user.bzl
   - sudo rm -f /etc/mavenrc
   - wget http://www.us.apache.org/dist/maven/maven-3/3.1.1/binaries/apache-maven-3.1.1-bin.tar.gz
-  - tar -zxvf apache-maven-3.1.1-bin.tar.gz
-  - export MAVEN_OPTS="-Xmx512m -XX:MaxPermSize=192m"
-  - export M2_HOME=$PWD/apache-maven-3.1.1
-  - export PATH=$M2_HOME/bin:$PATH
-  - mvn --version
+  - tar -zxf apache-maven-3.1.1-bin.tar.gz
+  - export PATH="$PWD/apache-maven-3.1.1/bin:$PATH"
+  - mkdir travis_bin
+  - ln -s $(which gcc-4.8) travis_bin/gcc
+  - ln -s $(which g++-4.8) travis_bin/g++
+  - export PATH="${PWD}/travis_bin:${PATH}"
 
-install:
-  - bazel build //...
-  - mvn -B -P!standard-with-extra-repos -U install clean --fail-never --quiet -DskipTests=true -Dinvoker.skip=true
-
-script:
-  - bazel test --test_output errors //...
-  - mvn -B -P!standard-with-extra-repos -U verify --fail-at-end -Dsource.skip=true -Dmaven.javadoc.skip=true
+script: bazel test --test_output errors //...
 
 env:
   global:
@@ -60,7 +56,3 @@ branches:
   only:
     - master
     - /^release.*$/
-
-cache:
-  directories:
-    - $HOME/.m2
diff --git a/BUILD b/BUILD
index b77025b94..876e647c4 100644
--- a/BUILD
+++ b/BUILD
@@ -21,20 +21,95 @@ package_group(
 
 py_test(
     name = "maven_sha1_test",
-    srcs = ["tools/maven_sha1_test.py"],
-    data = [":WORKSPACE"],
+    srcs = ["maven_sha1_test.py"],
+    data = ["WORKSPACE"],
 )
 
 java_library(
     name = "dagger_with_compiler",
-    exported_plugins = ["//compiler:component-codegen"],
-    exports = ["//core"],
+    exported_plugins = ["//java/dagger/internal/codegen:component-codegen"],
+    exports = ["//java/dagger:core"],
 )
 
 java_library(
     name = "producers_with_compiler",
     exports = [
         ":dagger_with_compiler",
-        "//producers",
+        "//java/dagger/producers",
+    ],
+)
+
+android_library(
+    name = "android",
+    exported_plugins = ["//java/dagger/android/processor:plugin"],
+    exports = ["//java/dagger/android"],
+)
+
+android_library(
+    name = "android-support",
+    exports = [
+        ":android",
+        "//java/dagger/android/support",
+    ],
+)
+
+load("//tools:jarjar.bzl", "jarjar_library")
+
+jarjar_library(
+    name = "shaded_compiler",
+    rules_file = "shade_rules.txt",
+    deps = [
+        "//java/dagger/internal/codegen",
+        "@com_google_auto_auto_common//jar",
+    ],
+)
+
+jarjar_library(
+    name = "shaded_android_processor",
+    rules_file = "shade_rules.txt",
+    deps = [
+        "//java/dagger/android/processor",
+        "@com_google_auto_auto_common//jar",
+    ],
+)
+
+jarjar_library(
+    name = "shaded_grpc_server_processor",
+    rules_file = "shade_rules.txt",
+    deps = [
+        "//java/dagger/grpc/server/processor",
+        "@com_google_auto_auto_common//jar",
+    ],
+)
+
+load("//tools:javadoc.bzl", "javadoc_library")
+
+# coalesced javadocs used for the gh-pages site
+javadoc_library(
+    name = "user-docs",
+    srcs = [
+        "//java/dagger:javadoc-srcs",
+        "//java/dagger/android:android-srcs",
+        "//java/dagger/android/support:support-srcs",
+        "//java/dagger/grpc/server:javadoc-srcs",
+        "//java/dagger/grpc/server/processor:javadoc-srcs",
+        "//java/dagger/producers:producers-srcs",
+    ],
+    android_api_level = 25,
+    # TODO(ronshapiro): figure out how to specify the version number for release builds
+    doctitle = "Dagger Dependency Injection API",
+    exclude_packages = [
+        "dagger.internal",
+        "dagger.producers.internal",
+        "dagger.producers.monitoring.internal",
+    ],
+    root_packages = ["dagger"],
+    deps = [
+        "//java/dagger:core",
+        "//java/dagger/android",
+        "//java/dagger/android/support",
+        "//java/dagger/grpc/server",
+        "//java/dagger/grpc/server/processor",
+        "//java/dagger/producers",
     ],
 )
diff --git a/README.md b/README.md
index e918767a0..92b28ecdc 100644
--- a/README.md
+++ b/README.md
@@ -44,9 +44,39 @@ at compile time.
 ### Maven
 
 In a Maven project, include the `dagger` artifact in the dependencies section
-of your `pom.xml` and the `dagger-compiler` artifact as either an `optional` or
-`provided` dependency:
+of your `pom.xml` and the `dagger-compiler` artifact as an
+`annotationProcessorPaths` value of the `maven-compiler-plugin`:
 
+```xml
+<dependencies>
+  <dependency>
+    <groupId>com.google.dagger</groupId>
+    <artifactId>dagger</artifactId>
+    <version>2.x</version>
+  </dependency>
+</dependencies>
+<build>
+  <plugins>
+    <plugin>
+      <groupId>org.apache.maven.plugins</groupId>
+      <artifactId>maven-compiler-plugin</artifactId>
+      <version>3.6.1</version>
+      <configuration>
+        <annotationProcessorPaths>
+          <path>
+            <groupId>com.google.dagger</groupId>
+            <artifactId>dagger-compiler</artifactId>
+            <version>2.x</version>
+          </path>
+        </annotationProcessorPaths>
+      </configuration>
+    </plugin>
+  </plugins>
+</build>
+```
+
+If you are using a version of the `maven-compiler-plugin` lower than `3.5`, add
+the `dagger-compiler` artifact with the `provided` scope:
 ```xml
 <dependencies>
   <dependency>
@@ -58,7 +88,7 @@ of your `pom.xml` and the `dagger-compiler` artifact as either an `optional` or
     <groupId>com.google.dagger</groupId>
     <artifactId>dagger-compiler</artifactId>
     <version>2.x</version>
-    <optional>true</optional>
+    <scope>provided</scope>
   </dependency>
 </dependencies>
 ```
@@ -80,7 +110,7 @@ parallelizable execution graphs), then add this to your maven configuration:
 ```groovy
 // Add plugin https://plugins.gradle.org/plugin/net.ltgt.apt
 plugins {
-  id "net.ltgt.apt" version "0.5"
+  id "net.ltgt.apt" version "0.10"
 }
 
 // Add Dagger dependencies
@@ -99,6 +129,14 @@ dependencies {
 }
 ```
 
+If you're using classes in `dagger.android` you'll also want to include:
+
+```groovy
+compile 'com.google.dagger:dagger-android:2.x'
+compile 'com.google.dagger:dagger-android-support:2.x' // if you use the support libraries
+annotationProcessor 'com.google.dagger:dagger-android-processor:2.x'
+```
+
 If you're using a version of the Android gradle plugin below `2.2`, see
 https://bitbucket.org/hvisser/android-apt.
 
@@ -155,13 +193,12 @@ the GitHub project's master branch.
     See the License for the specific language governing permissions and
     limitations under the License.
 
-
-[20api]: http://google.github.io/dagger/api/2.0/
+[20api]: https://google.github.io/dagger/api/2.0/
 [community]: https://plus.google.com/communities/111933036769103367883
 [dagger-snap]: https://oss.sonatype.org/content/repositories/snapshots/com/google/dagger/
-[databinding]: https://developer.android.com/topic/libraries/data-binding/index.html
+[databinding]: https://developer.android.com/topic/libraries/data-binding/
 [gaktalk]: https://www.youtube.com/watch?v=oK_XtfXPkqw
-[latestapi]: http://google.github.io/dagger/api/latest/
+[latestapi]: https://google.github.io/dagger/api/latest/
 [mavenbadge-svg]: https://maven-badges.herokuapp.com/maven-central/com.google.dagger/dagger/badge.svg
 [mavenbadge]: https://maven-badges.herokuapp.com/maven-central/com.google.dagger/dagger
 [mavensearch]: http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.google.dagger%22
@@ -169,4 +206,4 @@ the GitHub project's master branch.
 [proposal]: https://github.com/square/dagger/issues/366
 [square]: http://github.com/square/dagger/
 [squarecommunity]: https://plus.google.com/communities/109244258569782858265
-[website]: http://google.github.io/dagger
+[website]: https://google.github.io/dagger
diff --git a/WORKSPACE b/WORKSPACE
index de425d11f..729e0290f 100644
--- a/WORKSPACE
+++ b/WORKSPACE
@@ -12,16 +12,10 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-# Every user should create a WORKSPACE.user.bzl file and declare the path to their $ANDROID_HOME
-# directory. If you don't want to compile //android, you can remove the android related targets in
-# the WORKSPACE
-load("/WORKSPACE.user", "ANDROID_HOME")
-
 android_sdk_repository(
     name = "androidsdk",
     api_level = 25,
     build_tools_version = "25.0.2",
-    path = ANDROID_HOME,
 )
 
 bind(
@@ -30,7 +24,7 @@ bind(
 )
 
 maven_jar(
-    name = "javax_annotations_jsr250_api",
+    name = "javax_annotation_jsr250_api",
     artifact = "javax.annotation:jsr250-api:1.0",
     sha1 = "5025422767732a1ab45d93abfea846513d742dcf",
 )
@@ -55,8 +49,8 @@ maven_jar(
 
 maven_jar(
     name = "com_google_guava_guava",
-    artifact = "com.google.guava:guava:21.0-rc1",
-    sha1 = "ea4681eb116c7335370adaad583010e0681cc53b",
+    artifact = "com.google.guava:guava:21.0",
+    sha1 = "3a3d111be1be1b745edfa7d91678a12d7ed38709",
 )
 
 maven_jar(
@@ -73,8 +67,8 @@ maven_jar(
 
 maven_jar(
     name = "com_google_googlejavaformat_google_java_format",
-    artifact = "com.google.googlejavaformat:google-java-format:1.2",
-    sha1 = "c897dff7c217667d797bc9bf9d54416e776e9917",
+    artifact = "com.google.googlejavaformat:google-java-format:1.3",
+    sha1 = "949e85e75b3160ce1446aa99d806d5b509631b02",
 )
 
 maven_jar(
@@ -133,8 +127,8 @@ maven_jar(
 
 maven_jar(
     name = "org_hamcrest_hamcrest_core",
-    artifact = "org.hamcrest:hamcrest-core:1.1",
-    sha1 = "860340562250678d1a344907ac75754e259cdb14",
+    artifact = "org.hamcrest:hamcrest-core:1.3",
+    sha1 = "42a25dc3219429f0e5d060061f71acb49bf010a0",
 )
 
 maven_jar(
@@ -149,8 +143,74 @@ maven_jar(
     sha1 = "9d591b5a66eda81f0b88cf1c748ab8853d99b18b",
 )
 
+maven_jar(
+    name = "com_google_truth_extensions_truth_java8_extension",
+    artifact = "com.google.truth.extensions:truth-java8-extension:0.30",
+    sha1 = "f3bb5e49001a9b575bcdef9aa8417b6d1ef35509",
+)
+
 maven_jar(
     name = "com_squareup_javapoet",
     artifact = "com.squareup:javapoet:1.7.0",
     sha1 = "4fdcf1fc27c1a8f55d1109df986c923152f07759",
 )
+
+maven_jar(
+    name = "io_grpc_grpc_core",
+    artifact = "io.grpc:grpc-core:1.2.0",
+    sha1 = "f12a213e2b59a0615df2cc9bed35dc15fd2fee37",
+)
+
+maven_jar(
+    name = "io_grpc_grpc_netty",
+    artifact = "io.grpc:grpc-netty:1.2.0",
+    sha1 = "e2682d2dc052898f87433e7a6d03d104ef98df74",
+)
+
+maven_jar(
+    name = "io_grpc_grpc_context",
+    artifact = "io.grpc:grpc-context:1.2.0",
+    sha1 = "1932db544cbb427bc18f902c7ebbb3f7e44991df",
+)
+
+maven_jar(
+    name = "io_grpc_grpc_protobuf",
+    artifact = "io.grpc:grpc-protobuf:1.2.0",
+    sha1 = "2676852d2dbd20155d9b1a940a456eae5b7445f0",
+)
+
+maven_jar(
+    name = "io_grpc_grpc_stub",
+    artifact = "io.grpc:grpc-stub:1.2.0",
+    sha1 = "964dda53b3085bfd17c7aaf51495f9efc8bda36c",
+)
+
+maven_jar(
+    name = "io_grpc_grpc_all",
+    artifact = "io.grpc:grpc-all:1.2.0",
+    sha1 = "f32006a1245dfa2d68bf92a1b4cc01831889c95b",
+)
+
+maven_jar(
+    name = "com_google_protobuf_protobuf_java",
+    artifact = "com.google.protobuf:protobuf-java:3.2.0",
+    sha1 = "62ccf171a106ff6791507f2d5364c275f9a3131d",
+)
+
+http_archive(
+    name = "com_google_protobuf",
+    sha256 = "ff771a662fb6bd4d3cc209bcccedef3e93980a49f71df1e987f6afa3bcdcba3a",
+    strip_prefix = "protobuf-b4b0e304be5a68de3d0ee1af9b286f958750f5e4",
+    urls = ["https://github.com/google/protobuf/archive/b4b0e304be5a68de3d0ee1af9b286f958750f5e4.zip"],
+)
+
+http_archive(
+    name = "com_google_protobuf_java",
+    sha256 = "ff771a662fb6bd4d3cc209bcccedef3e93980a49f71df1e987f6afa3bcdcba3a",
+    strip_prefix = "protobuf-b4b0e304be5a68de3d0ee1af9b286f958750f5e4",
+    urls = ["https://github.com/google/protobuf/archive/b4b0e304be5a68de3d0ee1af9b286f958750f5e4.zip"],
+)
+
+load("//tools:jarjar.bzl", "jarjar_deps")
+
+jarjar_deps()
diff --git a/android-compiler/pom.xml b/android-compiler/pom.xml
new file mode 100644
index 000000000..373af4923
--- /dev/null
+++ b/android-compiler/pom.xml
@@ -0,0 +1,141 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <parent>
+        <artifactId>dagger-parent</artifactId>
+        <groupId>com.google.dagger</groupId>
+        <version>3.0</version>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+
+    <artifactId>dagger-android-compiler</artifactId>
+
+    <dependencies>
+        <dependency>
+            <groupId>com.google.dagger</groupId>
+            <artifactId>dagger</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+        <dependency>
+            <groupId>com.google.auto.service</groupId>
+            <artifactId>auto-service</artifactId>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.google.auto.value</groupId>
+            <artifactId>auto-value</artifactId>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.google.googlejavaformat</groupId>
+            <artifactId>google-java-format</artifactId>
+        </dependency>
+        <dependency>
+            <groupId>com.squareup</groupId>
+            <artifactId>javapoet</artifactId>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <plugins>
+            <plugin>
+                <artifactId>maven-compiler-plugin</artifactId>
+                <configuration>
+                    <source>1.8</source>
+                    <target>1.8</target>
+                    <compilerArgument>-Xlint:all</compilerArgument>
+                    <showWarnings>true</showWarnings>
+                    <showDeprecation>true</showDeprecation>
+                </configuration>
+                <executions>
+
+                    <execution>
+                        <id>default-compile</id>
+                        <goals><goal>compile</goal></goals>
+                        <configuration>
+                            <annotationProcessors>
+                                <annotationProcessor>com.google.auto.value.processor.AutoValueProcessor</annotationProcessor>
+                                <annotationProcessor>com.google.auto.service.processor.AutoServiceProcessor</annotationProcessor>
+                            </annotationProcessors>
+                            <compilerArguments>
+                                <!-- enable the next line to have the output of the processor shown on console -->
+                                <Xlint/>
+                                <Averbose>true</Averbose>
+                            </compilerArguments>
+                            <!-- set the next to true to enable verbose output of the compiler plugin -->
+                            <verbose>true</verbose>
+                        </configuration>
+                    </execution>
+                    <!--<execution>
+                      <id>default-test-compile</id>
+                      <goals><goal>testCompile</goal></goals>
+                      <configuration>
+                        <annotationProcessors>
+                          <annotationProcessor>dagger.internal.codegen.ComponentProcessor</annotationProcessor>
+                        </annotationProcessors>
+                        <compilerArguments>
+                          <Xlint/>
+                          <Averbose>true</Averbose>
+                        </compilerArguments>
+                        <verbose>true</verbose>
+                      </configuration>
+                    </execution>-->
+                </executions>
+            </plugin>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-shade-plugin</artifactId>
+                <version>2.4.3</version>
+                <executions>
+                    <execution>
+                        <phase>package</phase>
+                        <goals>
+                            <goal>shade</goal>
+                        </goals>
+                        <configuration>
+                            <minimizeJar>true</minimizeJar>
+                            <artifactSet>
+                                <excludes>
+                                    <!-- guava which has a consistent API and whose public types we vend in producers -->
+                                    <exclude>com.google.guava</exclude>
+                                    <!-- annotation processors dagger uses to be built, not to operate -->
+                                    <exclude>com.google.auto.service</exclude>
+                                    <exclude>com.google.auto.value</exclude>
+                                    <!-- projects should depend on api projects directly -->
+                                    <exclude>com.google.dagger:dagger</exclude>
+                                    <exclude>com.google.dagger:dagger-producers</exclude>
+                                    <exclude>javax.inject</exclude>
+                                </excludes>
+                            </artifactSet>
+                            <relocations>
+                                <relocation>
+                                    <pattern>com.google.auto.common</pattern>
+                                    <shadedPattern>dagger.shaded.auto.common</shadedPattern>
+                                </relocation>
+                            </relocations>
+                            <filters>
+                                <filter>
+                                    <artifact>*:*</artifact>
+                                    <excludes>
+                                        <exclude>META-INF/*.SF</exclude>
+                                        <exclude>META-INF/*.DSA</exclude>
+                                        <exclude>META-INF/*.RSA</exclude>
+                                    </excludes>
+                                </filter>
+                                <!-- https://github.com/google/google-java-format/issues/114 -->
+                                <filter>
+                                    <artifact>com.google.errorprone:javac</artifact>
+                                    <includes>
+                                        <include>**</include>
+                                    </includes>
+                                </filter>
+                            </filters>
+                        </configuration>
+                    </execution>
+                </executions>
+            </plugin>
+        </plugins>
+    </build>
+
+</project>
\ No newline at end of file
diff --git a/android-compiler/src/main/java/dagger/android/AndroidInjector.java b/android-compiler/src/main/java/dagger/android/AndroidInjector.java
new file mode 100644
index 000000000..e5e85aa45
--- /dev/null
+++ b/android-compiler/src/main/java/dagger/android/AndroidInjector.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+import dagger.BindsInstance;
+import dagger.internal.Beta;
+
+@Beta
+public interface AndroidInjector<T> {
+
+  /** Injects the members of {@code instance}. */
+  void inject(T instance);
+
+  /**
+   * Creates {@link AndroidInjector}s for a concrete subtype of a core Android type.
+   *
+   * @param <T> the concrete type to be injected
+   */
+  interface Factory<T> {
+    /**
+     * Creates an {@link AndroidInjector} for {@code instance}. This should be the same instance
+     * that will be passed to {@link #inject(Object)}.
+     */
+    AndroidInjector<T> create(T instance);
+  }
+
+  /**
+   * An adapter that lets the common {@link dagger.Subcomponent.Builder} pattern implement {@link
+   * Factory}.
+   *
+   * @param <T> the concrete type to be injected
+   */
+  abstract class Builder<T> implements Factory<T> {
+    @Override
+    public final AndroidInjector<T> create(T instance) {
+      seedInstance(instance);
+      return build();
+    }
+
+    /**
+     * Provides {@code instance} to be used in the binding graph of the built {@link
+     * AndroidInjector}. By default, this is used as a {@link BindsInstance} method, but it may be
+     * overridden to provide any modules which need a reference to the activity.
+     *
+     * <p>This should be the same instance that will be passed to {@link #inject(Object)}.
+     */
+    @BindsInstance
+    public abstract void seedInstance(T instance);
+
+    /** Returns a newly-constructed {@link AndroidInjector}. */
+    public abstract AndroidInjector<T> build();
+  }
+}
diff --git a/android-compiler/src/main/java/dagger/android/ContributesAndroidInjector.java b/android-compiler/src/main/java/dagger/android/ContributesAndroidInjector.java
new file mode 100644
index 000000000..22f244c58
--- /dev/null
+++ b/android-compiler/src/main/java/dagger/android/ContributesAndroidInjector.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import java.lang.annotation.Target;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+/**
+ * Generates an {@link AndroidInjector} for the return type of this method. The injector is
+ * implemented with a {@link dagger.Subcomponent} and will be a child of the {@link dagger.Module}'s
+ * component.
+ *
+ * <p>This annotation must be applied to an abstract method in a {@link dagger.Module} that returns
+ * a concrete Android framework type (e.g. {@code FooActivity}, {@code BarFragment}, {@code
+ * MyService}, etc). The method should have no parameters.
+ *
+ * <p>For more information, see <a href="https://google.github.io/dagger/android">the docs</a>
+ */
+@Target(METHOD)
+public @interface ContributesAndroidInjector {
+  /** Modules to be installed in the generated {@link dagger.Subcomponent}. */
+  Class<?>[] modules() default {};
+}
diff --git a/android-compiler/src/main/java/dagger/android/processor/AndroidInjectorDescriptor.java b/android-compiler/src/main/java/dagger/android/processor/AndroidInjectorDescriptor.java
new file mode 100644
index 000000000..33553f316
--- /dev/null
+++ b/android-compiler/src/main/java/dagger/android/processor/AndroidInjectorDescriptor.java
@@ -0,0 +1,228 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static dagger.android.processor.AndroidMapKeys.annotationsAndFrameworkTypes;
+import static java.util.stream.Collectors.toList;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+
+import com.google.auto.common.AnnotationMirrors;
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.auto.value.AutoValue;
+import com.google.common.collect.ImmutableSet;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.TypeName;
+import dagger.Module;
+import dagger.android.ContributesAndroidInjector;
+import java.util.List;
+import java.util.Optional;
+import javax.annotation.processing.Messager;
+import javax.inject.Qualifier;
+import javax.inject.Scope;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleAnnotationValueVisitor8;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic.Kind;
+
+/**
+ * A descriptor of a generated {@link Module} and {@link dagger.Subcomponent} to be generated from a
+ * {@link ContributesAndroidInjector} method.
+ */
+@AutoValue
+abstract class AndroidInjectorDescriptor {
+  /** The type to be injected; the return type of the {@link ContributesAndroidInjector} method. */
+  abstract ClassName injectedType();
+
+  /**
+   * The base framework type of {@link #injectedType()}, e.g. {@code Activity}, {@code Fragment},
+   * etc.
+   */
+  abstract ClassName frameworkType();
+
+  /** Scopes to apply to the generated {@link dagger.Subcomponent}. */
+  abstract ImmutableSet<AnnotationSpec> scopes();
+
+  /** @see ContributesAndroidInjector#modules() */
+  abstract ImmutableSet<ClassName> modules();
+
+  /** The {@link Module} that contains the {@link ContributesAndroidInjector} method. */
+  abstract ClassName enclosingModule();
+
+  /** Simple name of the {@link ContributesAndroidInjector} method. */
+  abstract String methodName();
+
+  /**
+   * The {@link dagger.MapKey} annotation that groups {@link #frameworkType()}s, e.g.
+   * {@code @ActivityKey(MyActivity.class)}.
+   */
+  AnnotationSpec mapKeyAnnotation() {
+    String packageName =
+        frameworkType().packageName().contains(".support.")
+            ? "dagger.android.support"
+            : "dagger.android";
+    return AnnotationSpec.builder(ClassName.get(packageName, frameworkType().simpleName() + "Key"))
+        .addMember("value", "$T.class", injectedType())
+        .build();
+  }
+
+  @AutoValue.Builder
+  abstract static class Builder {
+    abstract Builder injectedType(ClassName injectedType);
+
+    abstract ImmutableSet.Builder<AnnotationSpec> scopesBuilder();
+
+    abstract ImmutableSet.Builder<ClassName> modulesBuilder();
+
+    abstract Builder frameworkType(ClassName frameworkType);
+
+    abstract Builder enclosingModule(ClassName enclosingModule);
+
+    abstract Builder methodName(String methodName);
+
+    abstract AndroidInjectorDescriptor build();
+  }
+
+  static final class Validator {
+    private final Types types;
+    private final Elements elements;
+    private final Messager messager;
+
+    Validator(Types types, Elements elements, Messager messager) {
+      this.types = types;
+      this.elements = elements;
+      this.messager = messager;
+    }
+
+    /**
+     * Validates a {@link ContributesAndroidInjector} method, returning an {@link
+     * AndroidInjectorDescriptor} if it is valid, or {@link Optional#empty()} otherwise.
+     */
+    Optional<AndroidInjectorDescriptor> createIfValid(ExecutableElement method) {
+      ErrorReporter reporter = new ErrorReporter(method, messager);
+
+      if (!method.getModifiers().contains(ABSTRACT)) {
+        reporter.reportError("@ContributesAndroidInjector methods must be abstract");
+      }
+
+      if (!method.getParameters().isEmpty()) {
+        reporter.reportError("@ContributesAndroidInjector methods cannot have parameters");
+      }
+
+      AndroidInjectorDescriptor.Builder builder = new AutoValue_AndroidInjectorDescriptor.Builder();
+      builder.methodName(method.getSimpleName().toString());
+      TypeElement enclosingElement = MoreElements.asType(method.getEnclosingElement());
+      if (!MoreElements.isAnnotationPresent(enclosingElement, Module.class)) {
+        reporter.reportError("@ContributesAndroidInjector methods must be in a @Module");
+      }
+      builder.enclosingModule(ClassName.get(enclosingElement));
+
+      TypeMirror injectedType = method.getReturnType();
+      Optional<TypeMirror> maybeFrameworkType =
+          annotationsAndFrameworkTypes(elements)
+              .values()
+              .stream()
+              .filter(frameworkType -> types.isAssignable(injectedType, frameworkType))
+              .findFirst();
+      if (maybeFrameworkType.isPresent()) {
+        builder.frameworkType((ClassName) TypeName.get(maybeFrameworkType.get()));
+        if (MoreTypes.asDeclared(injectedType).getTypeArguments().isEmpty()) {
+          builder.injectedType(ClassName.get(MoreTypes.asTypeElement(injectedType)));
+        } else {
+          reporter.reportError(
+              "@ContributesAndroidInjector methods cannot return parameterized types");
+        }
+      } else {
+        reporter.reportError(String.format("%s is not a framework type", injectedType));
+      }
+
+      AnnotationMirror annotation =
+          MoreElements.getAnnotationMirror(method, ContributesAndroidInjector.class).get();
+      for (TypeMirror module :
+          AnnotationMirrors.getAnnotationValue(annotation, "modules").accept(new AllTypesVisitor(), null)) {
+        if (MoreElements.isAnnotationPresent(MoreTypes.asElement(module), Module.class)) {
+          builder.modulesBuilder().add((ClassName) TypeName.get(module));
+        } else {
+          reporter.reportError(String.format("%s is not a @Module", module), annotation);
+        }
+      }
+
+      for (AnnotationMirror scope : AnnotationMirrors.getAnnotatedAnnotations(method, Scope.class)) {
+        builder.scopesBuilder().add(AnnotationSpec.get(scope));
+      }
+
+      for (AnnotationMirror qualifier : AnnotationMirrors.getAnnotatedAnnotations(method, Qualifier.class)) {
+        reporter.reportError(
+            "@ContributesAndroidInjector methods cannot have qualifiers", qualifier);
+      }
+
+      return reporter.hasError ? Optional.empty() : Optional.of(builder.build());
+    }
+
+    // TODO(ronshapiro): use ValidationReport once it is moved out of the compiler
+    private static class ErrorReporter {
+      private final Element subject;
+      private final Messager messager;
+      private boolean hasError;
+
+      ErrorReporter(Element subject, Messager messager) {
+        this.subject = subject;
+        this.messager = messager;
+      }
+
+      void reportError(String error) {
+        hasError = true;
+        messager.printMessage(Kind.ERROR, error, subject);
+      }
+
+      void reportError(String error, AnnotationMirror annotation) {
+        hasError = true;
+        messager.printMessage(Kind.ERROR, error, subject, annotation);
+      }
+    }
+  }
+
+  private static final class AllTypesVisitor
+      extends SimpleAnnotationValueVisitor8<ImmutableSet<TypeMirror>, Void> {
+    @Override
+    public ImmutableSet<TypeMirror> visitArray(List<? extends AnnotationValue> values, Void aVoid) {
+      return ImmutableSet.copyOf(
+          values.stream().flatMap(v -> v.accept(this, null).stream()).collect(toList()));
+    }
+
+    @Override
+    public ImmutableSet<TypeMirror> visitType(TypeMirror a, Void aVoid) {
+      return ImmutableSet.of(a);
+    }
+
+    @Override
+    protected ImmutableSet<TypeMirror> defaultAction(Object o, Void aVoid) {
+      throw new AssertionError(o);
+    }
+  }
+}
diff --git a/android-compiler/src/main/java/dagger/android/processor/AndroidMapKeyValidator.java b/android-compiler/src/main/java/dagger/android/processor/AndroidMapKeyValidator.java
new file mode 100644
index 000000000..f4dff3dcc
--- /dev/null
+++ b/android-compiler/src/main/java/dagger/android/processor/AndroidMapKeyValidator.java
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.android.processor.AndroidMapKeys.annotationsAndFrameworkTypes;
+
+import com.google.auto.common.AnnotationMirrors;
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.SetMultimap;
+import dagger.Binds;
+import dagger.android.AndroidInjector;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.annotation.processing.Messager;
+import javax.inject.Qualifier;
+import javax.inject.Scope;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic.Kind;
+
+/**
+ * Validates the correctness of {@link dagger.MapKey}s in {@code dagger.android} and {@code
+ * dagger.android.support} methods.
+ */
+final class AndroidMapKeyValidator implements ProcessingStep {
+  private final Elements elements;
+  private final Types types;
+  private final Messager messager;
+
+  AndroidMapKeyValidator(Elements elements, Types types, Messager messager) {
+    this.elements = elements;
+    this.types = types;
+    this.messager = messager;
+  }
+
+  @Override
+  public Set<? extends Class<? extends Annotation>> annotations() {
+    return annotationsAndFrameworkTypes(elements).keySet();
+  }
+
+  @Override
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    elementsByAnnotation.entries().forEach(
+        (entry) -> validateMethod(entry.getKey(), MoreElements.asExecutable(entry.getValue())));
+    return ImmutableSet.of();
+  }
+
+  private void validateMethod(Class<? extends Annotation> annotation, ExecutableElement method) {
+    if (!AnnotationMirrors.getAnnotatedAnnotations(method, Qualifier.class).isEmpty()) {
+      return;
+    }
+
+    TypeMirror returnType = method.getReturnType();
+    if (!types.isAssignable(types.erasure(returnType), factoryElement().asType())) {
+      // if returnType is not related to AndroidInjector.Factory, ignore the method
+      return;
+    }
+
+    TypeMirror frameworkType = annotationsAndFrameworkTypes(elements).get(annotation);
+
+    if (!AnnotationMirrors.getAnnotatedAnnotations(method, Scope.class).isEmpty()) {
+      SuppressWarnings suppressedWarnings = method.getAnnotation(SuppressWarnings.class);
+      if (suppressedWarnings == null
+          || !ImmutableSet.copyOf(suppressedWarnings.value())
+              .contains("dagger.android.ScopedInjectorFactory")) {
+        messager.printMessage(
+            Kind.ERROR,
+            String.format(
+                "%s bindings should not be scoped. Scoping this method may leak instances of %s. ",
+                AndroidInjector.Factory.class.getCanonicalName(), frameworkType),
+            method);
+      }
+    }
+
+    DeclaredType intendedReturnType = injectorFactoryOf(types.getWildcardType(frameworkType, null));
+    if (!MoreTypes.equivalence().equivalent(returnType, intendedReturnType)) {
+      messager.printMessage(
+          Kind.ERROR,
+          String.format(
+              "@%s methods should bind %s, not %s. See https://google.github.io/dagger/android",
+              annotation.getCanonicalName(), intendedReturnType, returnType),
+          method);
+    }
+
+    // @Binds methods should only have one parameter, but we can't guarantee the order of Processors
+    // in javac, so do a basic check for valid form
+    if (MoreElements.isAnnotationPresent(method, Binds.class) && method.getParameters().size() == 1) {
+      validateMapKeyMatchesBindsParameter(annotation, method);
+    }
+  }
+
+  /**
+   * A valid @Binds method could bind an {@link AndroidInjector.Factory} for one type, while giving
+   * it a map key of a different type. The return type and parameter type would pass typical @Binds
+   * validation, but the map lookup in {@link dagger.android.DispatchingAndroidInjector} would
+   * retrieve the wrong injector factory.
+   *
+   * <pre>{@code
+   * {@literal @Binds}
+   * {@literal @IntoMap}
+   * {@literal @ActivityKey(GreenActivity.class)}
+   * abstract AndroidInjector.Factory<? extends Activity> bindBlueActivity(
+   *     BlueActivityComponent.Builder builder);
+   * }</pre>
+   */
+  private void validateMapKeyMatchesBindsParameter(
+      Class<? extends Annotation> annotation, ExecutableElement method) {
+    TypeMirror parameterType = Iterables.getOnlyElement(method.getParameters()).asType();
+    AnnotationMirror annotationMirror = MoreElements.getAnnotationMirror(method, annotation).get();
+    TypeMirror mapKeyValue = (TypeMirror) AnnotationMirrors.getAnnotationValue(annotationMirror, "value").getValue();
+    if (!types.isAssignable(parameterType, injectorFactoryOf(mapKeyValue))) {
+      messager.printMessage(
+          Kind.ERROR,
+          String.format("%s does not implement AndroidInjector<%s>", parameterType, mapKeyValue),
+          method,
+          annotationMirror);
+    }
+  }
+
+  /** Returns a {@link DeclaredType} for {@code AndroidInjector.Factory<implementationType>}. */
+  private DeclaredType injectorFactoryOf(TypeMirror implementationType) {
+    return types.getDeclaredType(factoryElement(), implementationType);
+  }
+
+  private TypeElement factoryElement() {
+    return elements.getTypeElement(AndroidInjector.Factory.class.getCanonicalName());
+  }
+}
diff --git a/android-compiler/src/main/java/dagger/android/processor/AndroidMapKeys.java b/android-compiler/src/main/java/dagger/android/processor/AndroidMapKeys.java
new file mode 100644
index 000000000..4fbfaab4a
--- /dev/null
+++ b/android-compiler/src/main/java/dagger/android/processor/AndroidMapKeys.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static java.util.stream.Collectors.toMap;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+import static javax.lang.model.util.ElementFilter.typesIn;
+
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Iterables;
+import dagger.MapKey;
+import java.lang.annotation.Annotation;
+import java.util.List;
+import java.util.Objects;
+import java.util.stream.Stream;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.WildcardType;
+import javax.lang.model.util.Elements;
+
+final class AndroidMapKeys {
+
+  /**
+   * Returns the Android framework types available to the compiler, keyed by their associated {@code
+   * dagger.android} {@link MapKey}s. This will always contain the types that are defined by the
+   * framework, and only contain the support library types if they are on the classpath of the
+   * current compilation.
+   */
+  static ImmutableMap<Class<? extends Annotation>, TypeMirror> annotationsAndFrameworkTypes(
+      Elements elements) {
+    return ImmutableMap.copyOf(
+        Stream.of(
+                elements.getPackageElement("dagger.android"),
+                elements.getPackageElement("dagger.android.support"))
+            .filter(Objects::nonNull)
+            .flatMap(packageElement -> typesIn(packageElement.getEnclosedElements()).stream())
+            .filter(type -> MoreElements.isAnnotationPresent(type, MapKey.class))
+            .filter(mapKey -> mapKey.getAnnotation(MapKey.class).unwrapValue())
+            .flatMap(AndroidMapKeys::classForAnnotationElement)
+            .collect(toMap(key -> key, key -> mapKeyValue(key, elements))));
+  }
+
+  private static Stream<Class<? extends Annotation>> classForAnnotationElement(TypeElement type) {
+    try {
+      @SuppressWarnings("unchecked")
+      Class<? extends Annotation> clazz =
+          (Class<? extends Annotation>) Class.forName(type.getQualifiedName().toString());
+      return Stream.of(clazz);
+    } catch (ClassNotFoundException e) {
+      return Stream.of();
+    }
+  }
+
+  private static TypeMirror mapKeyValue(Class<? extends Annotation> annotation, Elements elements) {
+    List<ExecutableElement> mapKeyMethods =
+        methodsIn(elements.getTypeElement(annotation.getCanonicalName()).getEnclosedElements());
+    TypeMirror returnType = Iterables.getOnlyElement(mapKeyMethods).getReturnType();
+    // TODO(ronshapiro): replace with MoreTypes.asWildcard() when auto-common 0.9 is released
+    return ((WildcardType) Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments()))
+        .getExtendsBound();
+  }
+}
diff --git a/android-compiler/src/main/java/dagger/android/processor/AndroidProcessor.java b/android-compiler/src/main/java/dagger/android/processor/AndroidProcessor.java
new file mode 100644
index 000000000..7bb44474a
--- /dev/null
+++ b/android-compiler/src/main/java/dagger/android/processor/AndroidProcessor.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import com.google.auto.common.BasicAnnotationProcessor;
+import com.google.auto.service.AutoService;
+import com.google.common.collect.ImmutableList;
+import com.google.googlejavaformat.java.filer.FormattingFiler;
+import javax.annotation.processing.Filer;
+import javax.annotation.processing.Messager;
+import javax.annotation.processing.Processor;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+/**
+ * An {@linkplain javax.annotation.processing.Processor annotation processor} to verify usage of
+ * {@code dagger.android} code.
+ */
+@AutoService(Processor.class)
+public final class AndroidProcessor extends BasicAnnotationProcessor {
+  @Override
+  protected Iterable<? extends ProcessingStep> initSteps() {
+    Filer filer = new FormattingFiler(processingEnv.getFiler());
+    Messager messager = processingEnv.getMessager();
+    Elements elements = processingEnv.getElementUtils();
+    Types types = processingEnv.getTypeUtils();
+
+    return ImmutableList.of(
+        new AndroidMapKeyValidator(elements, types, messager),
+        new ContributesAndroidInjectorGenerator(
+            filer, new AndroidInjectorDescriptor.Validator(types, elements, messager)));
+  }
+
+  @Override
+  public SourceVersion getSupportedSourceVersion() {
+    return SourceVersion.latestSupported();
+  }
+}
diff --git a/android-compiler/src/main/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java b/android-compiler/src/main/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
new file mode 100644
index 000000000..80ac5afa6
--- /dev/null
+++ b/android-compiler/src/main/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
@@ -0,0 +1,176 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static com.squareup.javapoet.TypeSpec.interfaceBuilder;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.util.ElementFilter.methodsIn;
+
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.common.base.CaseFormat;
+import com.google.common.base.Joiner;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import com.squareup.javapoet.JavaFile;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.WildcardTypeName;
+import dagger.Binds;
+import dagger.Module;
+import dagger.Subcomponent;
+import dagger.Subcomponent.Builder;
+import dagger.android.AndroidInjector;
+import dagger.android.ContributesAndroidInjector;
+import dagger.multibindings.IntoMap;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.annotation.processing.Filer;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.Modifier;
+import javax.lang.model.util.ElementFilter;
+
+/** Generates the implementation specified in {@link ContributesAndroidInjector}. */
+final class ContributesAndroidInjectorGenerator implements ProcessingStep {
+
+  private final Filer filer;
+  private final AndroidInjectorDescriptor.Validator validator;
+
+  ContributesAndroidInjectorGenerator(Filer filer, AndroidInjectorDescriptor.Validator validator) {
+    this.filer = filer;
+    this.validator = validator;
+  }
+
+  @Override
+  public Set<? extends Class<? extends Annotation>> annotations() {
+    return ImmutableSet.of(ContributesAndroidInjector.class);
+  }
+
+  @Override
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    for (ExecutableElement method : ElementFilter.methodsIn(elementsByAnnotation.values())) {
+      validator.createIfValid(method).ifPresent(this::generate);
+    }
+    return ImmutableSet.of();
+  }
+
+  private void generate(AndroidInjectorDescriptor descriptor) {
+    ClassName moduleName =
+        descriptor
+            .enclosingModule()
+            .topLevelClassName()
+            .peerClass(
+                Joiner.on('_').join(descriptor.enclosingModule().simpleNames())
+                    + "_"
+                    + CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_CAMEL, descriptor.methodName()));
+
+    String baseName = descriptor.injectedType().simpleName();
+    ClassName subcomponentName = moduleName.nestedClass(baseName + "Subcomponent");
+    ClassName subcomponentBuilderName = subcomponentName.nestedClass("Builder");
+
+    TypeSpec module =
+        TypeSpec.classBuilder(moduleName)
+            .addModifiers(PUBLIC, ABSTRACT)
+            .addAnnotation(
+                AnnotationSpec.builder(Module.class)
+                    .addMember("subcomponents", "$T.class", subcomponentName)
+                    .build())
+            .addMethod(bindAndroidInjectorFactory(descriptor, subcomponentBuilderName))
+            .addType(subcomponent(descriptor, subcomponentName, subcomponentBuilderName))
+            .addMethod(MethodSpec.constructorBuilder().addModifiers(PRIVATE).build())
+            .build();
+    try {
+      JavaFile.builder(moduleName.packageName(), module)
+          .skipJavaLangImports(true)
+          .build()
+          .writeTo(filer);
+    } catch (IOException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+  private MethodSpec bindAndroidInjectorFactory(
+      AndroidInjectorDescriptor descriptor, ClassName subcomponentBuilderName) {
+    return MethodSpec.methodBuilder("bindAndroidInjectorFactory")
+        .addAnnotation(Binds.class)
+        .addAnnotation(IntoMap.class)
+        .addAnnotation(descriptor.mapKeyAnnotation())
+        .addModifiers(ABSTRACT)
+        .returns(
+            parameterizedTypeName(
+                AndroidInjector.Factory.class,
+                WildcardTypeName.subtypeOf(descriptor.frameworkType())))
+        .addParameter(subcomponentBuilderName, "builder")
+        .build();
+  }
+
+  private TypeSpec subcomponent(
+      AndroidInjectorDescriptor descriptor,
+      ClassName subcomponentName,
+      ClassName subcomponentBuilderName) {
+    AnnotationSpec.Builder subcomponentAnnotation = AnnotationSpec.builder(Subcomponent.class);
+    for (ClassName module : descriptor.modules()) {
+      subcomponentAnnotation.addMember("modules", CodeBlock.of("$T.class", module));
+    }
+
+    return TypeSpec.interfaceBuilder(subcomponentName)
+        .addModifiers(PUBLIC)
+        .addAnnotation(subcomponentAnnotation.build())
+        .addAnnotations(descriptor.scopes())
+        .addSuperinterface(parameterizedTypeName(AndroidInjector.class, descriptor.injectedType()))
+        .addType(subcomponentBuilder(descriptor, subcomponentName, subcomponentBuilderName))
+        .build();
+  }
+
+  private MethodSpec overrideBuildMethod(ClassName subcomponentName) {
+    return MethodSpec.methodBuilder("build")
+            .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
+            .addAnnotation(Override.class)
+            .returns(subcomponentName)
+            .build();
+  }
+
+  private TypeSpec subcomponentBuilder(
+          AndroidInjectorDescriptor descriptor, ClassName subcomponentName, ClassName subcomponentBuilderName) {
+    return TypeSpec.classBuilder(subcomponentBuilderName)
+        .addAnnotation(Builder.class)
+        .addModifiers(PUBLIC, ABSTRACT, STATIC)
+        .addMethod(overrideBuildMethod(subcomponentName))
+        .superclass(parameterizedTypeName(AndroidInjector.Builder.class, descriptor.injectedType()))
+        .build();
+  }
+
+  private static ParameterizedTypeName parameterizedTypeName(
+      Class<?> clazz, TypeName... typeArguments) {
+    return ParameterizedTypeName.get(ClassName.get(clazz), typeArguments);
+  }
+}
diff --git a/android-support/pom.xml b/android-support/pom.xml
new file mode 100644
index 000000000..d6d6badf8
--- /dev/null
+++ b/android-support/pom.xml
@@ -0,0 +1,66 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <parent>
+        <artifactId>dagger-parent</artifactId>
+        <groupId>com.google.dagger</groupId>
+        <version>3.0</version>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+
+    <artifactId>dagger-android-support</artifactId>
+
+    <name>Dagger for Android Support</name>
+
+    <packaging>aar</packaging>
+
+    <repositories>
+        <repository>
+            <id>android-support</id>
+            <url>file://${env.ANDROID_HOME}/extras/android/m2repository</url>
+        </repository>
+    </repositories>
+
+    <properties>
+        <java.version>1.6</java.version>
+    </properties>
+
+    <dependencies>
+        <dependency>
+            <groupId>com.android.support</groupId>
+            <artifactId>appcompat-v7</artifactId>
+            <version>24.1.1</version>
+            <type>aar</type>
+        </dependency>
+        <dependency>
+            <groupId>com.google.android</groupId>
+            <artifactId>android</artifactId>
+            <version>4.2.2_r3</version>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>com.google.dagger</groupId>
+            <artifactId>dagger-android</artifactId>
+            <version>3.0</version>
+            <type>aar</type>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>com.simpligility.maven.plugins</groupId>
+                <artifactId>android-maven-plugin</artifactId>
+                <extensions>true</extensions>
+                <configuration>
+                    <sdk>
+                        <platform>${android.latest.version}</platform>
+                        <path>${env.ANDROID_HOME}</path>
+                    </sdk>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+</project>
\ No newline at end of file
diff --git a/android-support/src/main/AndroidManifest.xml b/android-support/src/main/AndroidManifest.xml
new file mode 100644
index 000000000..d080e115c
--- /dev/null
+++ b/android-support/src/main/AndroidManifest.xml
@@ -0,0 +1,19 @@
+<!--
+  ~ Copyright (C) 2017 The Dagger Authors.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~ http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+  package="dagger.android.support">
+  <uses-sdk android:minSdkVersion="14" />
+</manifest>
diff --git a/android-support/src/main/java/dagger/android/support/AndroidSupportInjection.java b/android-support/src/main/java/dagger/android/support/AndroidSupportInjection.java
new file mode 100644
index 000000000..4603bd566
--- /dev/null
+++ b/android-support/src/main/java/dagger/android/support/AndroidSupportInjection.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+import android.app.Activity;
+import android.support.v4.app.Fragment;
+import android.util.Log;
+import dagger.android.AndroidInjector;
+import dagger.internal.Beta;
+import dagger.internal.Preconditions;
+
+/** Injects core Android types from support libraries. */
+@Beta
+public final class AndroidSupportInjection {
+  private static final String TAG = "dagger.android.support";
+
+  /**
+   * Injects {@code fragment} if an associated {@link dagger.android.AndroidInjector} implementation
+   * can be found, otherwise throws an {@link IllegalArgumentException}.
+   *
+   * <p>Uses the following algorithm to find the appropriate {@code AndroidInjector<Fragment>} to
+   * use to inject {@code fragment}:
+   *
+   * <ol>
+   *   <li>Walks the parent-fragment hierarchy to find the a fragment that implements {@link
+   *       HasSupportFragmentInjector}, and if none do
+   *   <li>Uses the {@code fragment}'s {@link Fragment#getActivity() activity} if it implements
+   *       {@link HasSupportFragmentInjector}, and if not
+   *   <li>Uses the {@link android.app.Application} if it implements {@link
+   *       HasSupportFragmentInjector}.
+   * </ol>
+   *
+   * If none of them implement {@link HasSupportFragmentInjector}, a {@link
+   * IllegalArgumentException} is thrown.
+   *
+   * @throws IllegalArgumentException if no parent fragment, activity, or application implements
+   *     {@link HasSupportFragmentInjector}.
+   */
+  public static void inject(Fragment fragment) {
+    Preconditions.checkNotNull(fragment, "fragment");
+    HasSupportFragmentInjector hasSupportFragmentInjector = findHasFragmentInjector(fragment);
+    Log.d(
+        TAG,
+        String.format(
+            "An injector for %s was found in %s",
+            fragment.getClass().getCanonicalName(),
+            hasSupportFragmentInjector.getClass().getCanonicalName()));
+
+    AndroidInjector<Fragment> fragmentInjector =
+        hasSupportFragmentInjector.supportFragmentInjector();
+    Preconditions.checkNotNull(
+        fragmentInjector,
+        "%s.supportFragmentInjector() returned null",
+        hasSupportFragmentInjector.getClass().getCanonicalName());
+
+    fragmentInjector.inject(fragment);
+  }
+
+  private static HasSupportFragmentInjector findHasFragmentInjector(Fragment fragment) {
+    Fragment parentFragment = fragment;
+    while ((parentFragment = parentFragment.getParentFragment()) != null) {
+      if (parentFragment instanceof HasSupportFragmentInjector) {
+        return (HasSupportFragmentInjector) parentFragment;
+      }
+    }
+    Activity activity = fragment.getActivity();
+    if (activity instanceof HasSupportFragmentInjector) {
+      return (HasSupportFragmentInjector) activity;
+    }
+    if (activity.getApplication() instanceof HasSupportFragmentInjector) {
+      return (HasSupportFragmentInjector) activity.getApplication();
+    }
+    throw new IllegalArgumentException(
+        String.format("No injector was found for %s", fragment.getClass().getCanonicalName()));
+  }
+
+  private AndroidSupportInjection() {}
+}
diff --git a/android-support/src/main/java/dagger/android/support/AndroidSupportInjectionModule.java b/android-support/src/main/java/dagger/android/support/AndroidSupportInjectionModule.java
new file mode 100644
index 000000000..6349afb67
--- /dev/null
+++ b/android-support/src/main/java/dagger/android/support/AndroidSupportInjectionModule.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import android.support.v4.app.Fragment;
+import dagger.Module;
+import dagger.android.AndroidInjectionModule;
+import dagger.android.AndroidInjector;
+import dagger.internal.Beta;
+import dagger.multibindings.Multibinds;
+import java.util.Map;
+
+/**
+ * Configures bindings to ensure the usability of {@code dagger.android} and {@code
+ * dagger.android.support} framework classes. This module should be installed in the root-most
+ * component which will use these types.
+ */
+@Beta
+@Module(includes = AndroidInjectionModule.class)
+public abstract class AndroidSupportInjectionModule {
+  @Multibinds
+  abstract Map<Class<? extends Fragment>, AndroidInjector.Factory<? extends Fragment>>
+      supportFragmentInjectorFactories();
+
+  private AndroidSupportInjectionModule() {}
+}
diff --git a/android-support/src/main/java/dagger/android/support/DaggerAppCompatActivity.java b/android-support/src/main/java/dagger/android/support/DaggerAppCompatActivity.java
new file mode 100644
index 000000000..adfe4db85
--- /dev/null
+++ b/android-support/src/main/java/dagger/android/support/DaggerAppCompatActivity.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import android.os.Bundle;
+import android.support.v4.app.Fragment;
+import android.support.v7.app.AppCompatActivity;
+import dagger.android.AndroidInjection;
+import dagger.android.AndroidInjector;
+import dagger.android.DispatchingAndroidInjector;
+import dagger.android.HasFragmentInjector;
+import dagger.internal.Beta;
+import javax.inject.Inject;
+
+/**
+ * An {@link AppCompatActivity} that injects its members in {@link #onCreate(Bundle)} and can be
+ * used to inject {@code Fragment}s attached to it.
+ */
+@Beta
+public abstract class DaggerAppCompatActivity extends AppCompatActivity
+    implements HasFragmentInjector, HasSupportFragmentInjector {
+
+  @Inject DispatchingAndroidInjector<Fragment> supportFragmentInjector;
+  @Inject DispatchingAndroidInjector<android.app.Fragment> frameworkFragmentInjector;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    AndroidInjection.inject(this);
+    super.onCreate(savedInstanceState);
+  }
+
+  @Override
+  public AndroidInjector<Fragment> supportFragmentInjector() {
+    return supportFragmentInjector;
+  }
+
+  @Override
+  public AndroidInjector<android.app.Fragment> fragmentInjector() {
+    return frameworkFragmentInjector;
+  }
+}
diff --git a/android-support/src/main/java/dagger/android/support/DaggerApplication.java b/android-support/src/main/java/dagger/android/support/DaggerApplication.java
new file mode 100644
index 000000000..294d2aad4
--- /dev/null
+++ b/android-support/src/main/java/dagger/android/support/DaggerApplication.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import android.support.v4.app.Fragment;
+import dagger.android.AndroidInjector;
+import dagger.android.DispatchingAndroidInjector;
+import javax.inject.Inject;
+
+/**
+ * An {@link android.app.Application} that injects its members and can be used to inject {@link
+ * android.app.Activity}s, {@linkplain android.app.Fragment framework fragments}, {@linkplain
+ * Fragment support fragments}, {@link android.app.Service}s, {@link
+ * android.content.BroadcastReceiver}s, and {@link android.content.ContentProvider}s attached to it.
+ */
+public abstract class DaggerApplication extends dagger.android.DaggerApplication
+    implements HasSupportFragmentInjector {
+
+  @Inject DispatchingAndroidInjector<Fragment> supportFragmentInjector;
+
+  @Override
+  protected abstract AndroidInjector<? extends DaggerApplication> applicationInjector();
+
+  @Override
+  public DispatchingAndroidInjector<Fragment> supportFragmentInjector() {
+    return supportFragmentInjector;
+  }
+}
diff --git a/android-support/src/main/java/dagger/android/support/DaggerFragment.java b/android-support/src/main/java/dagger/android/support/DaggerFragment.java
new file mode 100644
index 000000000..c7335a88b
--- /dev/null
+++ b/android-support/src/main/java/dagger/android/support/DaggerFragment.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import android.content.Context;
+import android.support.v4.app.Fragment;
+import dagger.android.AndroidInjector;
+import dagger.android.DispatchingAndroidInjector;
+import dagger.internal.Beta;
+import javax.inject.Inject;
+
+/**
+ * A {@link Fragment} that injects its members in {@link #onAttach(Context)} and can be used to
+ * inject child {@link Fragment}s attached to it. Note that when this fragment gets reattached, its
+ * members will be injected again.
+ */
+@Beta
+public abstract class DaggerFragment extends Fragment implements HasSupportFragmentInjector {
+
+  @Inject DispatchingAndroidInjector<Fragment> childFragmentInjector;
+
+  @Override
+  public void onAttach(Context context) {
+    AndroidSupportInjection.inject(this);
+    super.onAttach(context);
+  }
+
+  @Override
+  public AndroidInjector<Fragment> supportFragmentInjector() {
+    return childFragmentInjector;
+  }
+}
diff --git a/android-support/src/main/java/dagger/android/support/FragmentKey.java b/android-support/src/main/java/dagger/android/support/FragmentKey.java
new file mode 100644
index 000000000..a5ecda4d7
--- /dev/null
+++ b/android-support/src/main/java/dagger/android/support/FragmentKey.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import android.support.v4.app.Fragment;
+import dagger.MapKey;
+import dagger.internal.Beta;
+import java.lang.annotation.Target;
+
+/** {@link MapKey} annotation to key bindings by a type of a {@link Fragment}. */
+@Beta
+@MapKey
+@Target(METHOD)
+public @interface FragmentKey {
+  Class<? extends Fragment> value();
+}
diff --git a/android-support/src/main/java/dagger/android/support/HasSupportFragmentInjector.java b/android-support/src/main/java/dagger/android/support/HasSupportFragmentInjector.java
new file mode 100644
index 000000000..e80609ec5
--- /dev/null
+++ b/android-support/src/main/java/dagger/android/support/HasSupportFragmentInjector.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import android.support.v4.app.Fragment;
+import dagger.android.AndroidInjector;
+import dagger.internal.Beta;
+
+/** Provides an {@link AndroidInjector} of {@link Fragment}s. */
+@Beta
+public interface HasSupportFragmentInjector {
+
+  /** Returns an {@link AndroidInjector} of {@link Fragment}s. */
+  AndroidInjector<Fragment> supportFragmentInjector();
+}
diff --git a/android/BUILD b/android/BUILD
deleted file mode 100644
index 6c0714ec9..000000000
--- a/android/BUILD
+++ /dev/null
@@ -1,25 +0,0 @@
-# Copyright (C) 2017 The Dagger Authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-# Description:
-#   Public Dagger API for Android
-
-package(default_visibility = ["//:src"])
-
-android_library(
-    name = "android",
-    exports = [
-        "//android/src/main/java/dagger/android",
-    ],
-)
diff --git a/android/pom.xml b/android/pom.xml
index 5d6dc0655..6fe096965 100644
--- a/android/pom.xml
+++ b/android/pom.xml
@@ -28,10 +28,6 @@
 
   <packaging>aar</packaging>
 
-  <properties>
-    <java.version>1.6</java.version>
-  </properties>
-
   <repositories>
     <repository>
       <id>android-support</id>
@@ -39,22 +35,16 @@
     </repository>
   </repositories>
 
+  <properties>
+    <java.version>1.6</java.version>
+  </properties>
+
   <dependencies>
     <dependency>
       <groupId>com.google.dagger</groupId>
       <artifactId>dagger</artifactId>
       <version>${project.version}</version>
     </dependency>
-    <dependency>
-      <groupId>com.google.android</groupId>
-      <artifactId>android</artifactId>
-      <scope>provided</scope>
-    </dependency>
-    <dependency>
-      <groupId>com.android.support</groupId>
-      <artifactId>support-v4</artifactId>
-      <type>aar</type>
-    </dependency>
     <dependency>
       <groupId>com.android.support</groupId>
       <artifactId>support-annotations</artifactId>
@@ -62,8 +52,18 @@
       <dependency>
           <groupId>com.google.android</groupId>
           <artifactId>android</artifactId>
-          <version>4.1.1.4</version>
+          <version>4.2.2_r3</version>
+          <scope>provided</scope>
       </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+      <optional>true</optional>
+    </dependency>
+    <dependency>
+      <groupId>com.google.errorprone</groupId>
+      <artifactId>error_prone_annotations</artifactId>
+    </dependency>
   </dependencies>
 
   <build>
diff --git a/android/src/it/functional-tests/src/main/java/test/android/BUILD b/android/src/it/functional-tests/src/main/java/test/android/BUILD
deleted file mode 100644
index 9675854e3..000000000
--- a/android/src/it/functional-tests/src/main/java/test/android/BUILD
+++ /dev/null
@@ -1,39 +0,0 @@
-# Copyright (C) 2017 The Dagger Authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-# Description:
-#   Functional test code for Dagger-Android
-
-package(default_visibility = ["//:src"])
-
-load(
-    "//:build_defs.bzl",
-    "DOCLINT_HTML_AND_SYNTAX",
-    "PRE_JAVA_8_INFERENCE_OPTS",
-    "JAVA_6_SOURCE_LEVEL",
-)
-
-# Sample code to be tested in functional tests.
-android_library(
-    name = "android",
-    testonly = 1,
-    srcs = glob(["*.java"]),
-    javacopts = PRE_JAVA_8_INFERENCE_OPTS + JAVA_6_SOURCE_LEVEL + DOCLINT_HTML_AND_SYNTAX,
-    # NOTE: This should not depend on Guava or jsr305 to ensure that Dagger can be
-    # used without a Guava and jsr305 deps.
-    deps = [
-        "//:dagger_with_compiler",
-        "//android",
-    ],
-)
diff --git a/android/src/it/functional-tests/src/main/java/test/android/InScope.java b/android/src/it/functional-tests/src/main/java/test/android/InScope.java
deleted file mode 100644
index 6054add97..000000000
--- a/android/src/it/functional-tests/src/main/java/test/android/InScope.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.android;
-
-import java.lang.annotation.Annotation;
-import javax.inject.Qualifier;
-
-@Qualifier
-@interface InScope {
-  Class<? extends Annotation> value();
-}
diff --git a/android/src/it/functional-tests/src/main/java/test/android/ReleaseWhenModerate.java b/android/src/it/functional-tests/src/main/java/test/android/ReleaseWhenModerate.java
deleted file mode 100644
index b5b100251..000000000
--- a/android/src/it/functional-tests/src/main/java/test/android/ReleaseWhenModerate.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.android;
-
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE;
-import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.ElementType.TYPE;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import dagger.android.ReleaseReferencesAt;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Retention;
-import java.lang.annotation.Target;
-import javax.inject.Scope;
-
-@Documented
-@Retention(RUNTIME)
-@Target({TYPE, METHOD})
-@ReleaseReferencesAt(TRIM_MEMORY_MODERATE)
-@Scope
-@interface ReleaseWhenModerate {}
diff --git a/android/src/it/functional-tests/src/main/java/test/android/ReleaseWhenUiHidden.java b/android/src/it/functional-tests/src/main/java/test/android/ReleaseWhenUiHidden.java
deleted file mode 100644
index b3dfd17aa..000000000
--- a/android/src/it/functional-tests/src/main/java/test/android/ReleaseWhenUiHidden.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.android;
-
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
-import static java.lang.annotation.ElementType.METHOD;
-import static java.lang.annotation.ElementType.TYPE;
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import dagger.android.ReleaseReferencesAt;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Retention;
-import java.lang.annotation.Target;
-import javax.inject.Scope;
-
-@Documented
-@Retention(RUNTIME)
-@Target({TYPE, METHOD})
-@ReleaseReferencesAt(TRIM_MEMORY_UI_HIDDEN)
-@Scope
-@interface ReleaseWhenUiHidden {}
diff --git a/android/src/it/functional-tests/src/main/java/test/android/TestComponent.java b/android/src/it/functional-tests/src/main/java/test/android/TestComponent.java
deleted file mode 100644
index c46420d07..000000000
--- a/android/src/it/functional-tests/src/main/java/test/android/TestComponent.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.android;
-
-import dagger.Component;
-import dagger.android.AndroidMemorySensitiveReferenceManager;
-import javax.inject.Singleton;
-
-@Singleton
-@ReleaseWhenUiHidden
-@ReleaseWhenModerate
-@Component(modules = TestModule.class)
-interface TestComponent {
-  AndroidMemorySensitiveReferenceManager manager();
-
-  @InScope(ReleaseWhenUiHidden.class)
-  Object releasedWhenUiHidden();
-
-  @InScope(ReleaseWhenModerate.class)
-  Object releasedWhenModerate();
-}
diff --git a/android/src/it/functional-tests/src/main/java/test/android/TestModule.java b/android/src/it/functional-tests/src/main/java/test/android/TestModule.java
deleted file mode 100644
index 7d7c59e6c..000000000
--- a/android/src/it/functional-tests/src/main/java/test/android/TestModule.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.android;
-
-import dagger.Module;
-import dagger.Provides;
-
-@Module
-class TestModule {
-  int releasedWhenUiHiddenCalls;
-  int releasedWhenModerateCalls;
-
-  @Provides
-  @ReleaseWhenUiHidden
-  @InScope(ReleaseWhenUiHidden.class)
-  Object releasedWhenUiHidden() {
-    ++releasedWhenUiHiddenCalls;
-    return new Object();
-  }
-
-  @Provides
-  @ReleaseWhenModerate
-  @InScope(ReleaseWhenModerate.class)
-  Object releasedWhenModerate() {
-    ++releasedWhenModerateCalls;
-    return new Object();
-  }
-}
diff --git a/android/src/it/functional-tests/src/test/java/test/android/AndroidMemorySensitiveReferenceManagerTest.java b/android/src/it/functional-tests/src/test/java/test/android/AndroidMemorySensitiveReferenceManagerTest.java
deleted file mode 100644
index 348376243..000000000
--- a/android/src/it/functional-tests/src/test/java/test/android/AndroidMemorySensitiveReferenceManagerTest.java
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.android;
-
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
-import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
-import static com.google.common.truth.Truth.assertThat;
-import static test.android.AndroidMemorySensitiveReferenceManagerTest.AllWeakReferencesCleared.allWeakReferencesCleared;
-
-import com.google.common.collect.ImmutableList;
-import com.google.common.testing.GcFinalization;
-import com.google.common.testing.GcFinalization.FinalizationPredicate;
-import org.robolectric.RobolectricTestRunner;
-import java.lang.ref.WeakReference;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-/** Functional tests of {@link dagger.android.AndroidMemorySensitiveReferenceManager}. */
-@RunWith(RobolectricTestRunner.class)
-public final class AndroidMemorySensitiveReferenceManagerTest {
-
-  private TestModule testModule;
-  private TestComponent component;
-
-  @Before
-  public void setUp() {
-    testModule = new TestModule();
-    component = DaggerTestComponent.builder().testModule(testModule).build();
-  }
-
-  @Test
-  public void scoped() {
-    assertThat(component.releasedWhenUiHidden()).isSameAs(component.releasedWhenUiHidden());
-    assertThat(component.releasedWhenModerate()).isSameAs(component.releasedWhenModerate());
-    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(1);
-    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
-  }
-
-  @Test
-  public void onTrimMemory_aboveThresholds() {
-    component.releasedWhenUiHidden();
-    component.releasedWhenModerate();
-
-    component.manager().onTrimMemory(TRIM_MEMORY_COMPLETE);
-    GcFinalization.awaitDone(
-        allWeakReferencesCleared(
-            component.releasedWhenUiHidden(), component.releasedWhenModerate()));
-
-    assertThat(component.releasedWhenUiHidden()).isSameAs(component.releasedWhenUiHidden());
-    assertThat(component.releasedWhenModerate()).isSameAs(component.releasedWhenModerate());
-    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(2);
-    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(2);
-  }
-
-  @Test
-  public void onTrimMemory_atOneThresholdBelowAnother() {
-    component.releasedWhenUiHidden();
-    component.releasedWhenModerate();
-
-    component.manager().onTrimMemory(TRIM_MEMORY_UI_HIDDEN);
-    GcFinalization.awaitDone(allWeakReferencesCleared(component.releasedWhenUiHidden()));
-
-    assertThat(component.releasedWhenUiHidden()).isSameAs(component.releasedWhenUiHidden());
-    assertThat(component.releasedWhenModerate()).isSameAs(component.releasedWhenModerate());
-    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(2);
-    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
-  }
-
-  @Test
-  public void onTrimMemory_belowThresholds() {
-    component.releasedWhenUiHidden();
-    component.releasedWhenModerate();
-    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(1);
-    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
-
-    component.manager().onTrimMemory(TRIM_MEMORY_RUNNING_MODERATE);
-    GcFinalization.awaitDone(allWeakReferencesCleared(new Object()));
-
-    assertThat(component.releasedWhenUiHidden()).isSameAs(component.releasedWhenUiHidden());
-    assertThat(component.releasedWhenModerate()).isSameAs(component.releasedWhenModerate());
-    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(1);
-    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
-  }
-
-  @Test
-  public void onTrimMemory_restore() {
-    component.releasedWhenUiHidden();
-    component.releasedWhenModerate();
-    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(1);
-    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
-
-    component.manager().onTrimMemory(TRIM_MEMORY_UI_HIDDEN);
-    component.manager().onTrimMemory(TRIM_MEMORY_RUNNING_MODERATE);
-    GcFinalization.awaitDone(allWeakReferencesCleared(new Object()));
-
-    assertThat(component.releasedWhenUiHidden()).isSameAs(component.releasedWhenUiHidden());
-    assertThat(component.releasedWhenModerate()).isSameAs(component.releasedWhenModerate());
-    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(1);
-    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
-  }
-
-  static final class AllWeakReferencesCleared implements FinalizationPredicate {
-
-    private final ImmutableList<WeakReference<Object>> references;
-
-    AllWeakReferencesCleared(ImmutableList<WeakReference<Object>> references) {
-      this.references = references;
-    }
-
-    @Override
-    public boolean isDone() {
-      for (WeakReference<Object> reference : references) {
-        if (reference.get() != null) {
-          return false;
-        }
-      }
-      return true;
-    }
-
-    static AllWeakReferencesCleared allWeakReferencesCleared(Object... objects) {
-      ImmutableList.Builder<WeakReference<Object>> referencesBuilder = ImmutableList.builder();
-      for (Object object : objects) {
-        referencesBuilder.add(new WeakReference<>(object));
-      }
-      return new AllWeakReferencesCleared(referencesBuilder.build());
-    }
-  }
-}
diff --git a/android/src/it/functional-tests/src/test/java/test/android/BUILD b/android/src/it/functional-tests/src/test/java/test/android/BUILD
deleted file mode 100644
index 13beefb8d..000000000
--- a/android/src/it/functional-tests/src/test/java/test/android/BUILD
+++ /dev/null
@@ -1,40 +0,0 @@
-# Copyright (C) 2017 The Dagger Authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-# Description:
-#   Functional test code for Dagger-Android
-
-package(default_visibility = ["//:src"])
-
-load(
-    "//:build_defs.bzl",
-    "DOCLINT_HTML_AND_SYNTAX",
-    "PRE_JAVA_8_INFERENCE_OPTS",
-)
-load("//:test_defs.bzl", "GenRobolectricTests")
-
-GenRobolectricTests(
-    name = "android_tests",
-    srcs = glob(["*.java"]),
-    javacopts = PRE_JAVA_8_INFERENCE_OPTS + DOCLINT_HTML_AND_SYNTAX,
-    deps = [
-        "//android/src/it/functional-tests/src/main/java/test/android",
-        "//third_party:guava",
-        "//third_party:guava_testlib",
-        "//third_party:junit",
-        "//third_party:truth",
-    ],
-)
-
-test_suite(name = "AllTests")
diff --git a/android/src/main/AndroidManifest.xml b/android/src/main/AndroidManifest.xml
index 8acac7a8f..f071b6018 100644
--- a/android/src/main/AndroidManifest.xml
+++ b/android/src/main/AndroidManifest.xml
@@ -15,5 +15,5 @@
 -->
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
     package="dagger.android">
-  <uses-sdk android:minSdkVersion="15" android:targetSdkVersion="24" />
+  <uses-sdk android:minSdkVersion="14" />
 </manifest>
diff --git a/android/src/main/java/dagger/android/ActivityKey.java b/android/src/main/java/dagger/android/ActivityKey.java
new file mode 100644
index 000000000..2fe7aeeee
--- /dev/null
+++ b/android/src/main/java/dagger/android/ActivityKey.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import android.app.Activity;
+import dagger.MapKey;
+import dagger.internal.Beta;
+import java.lang.annotation.Target;
+
+/** {@link MapKey} annotation to key bindings by a type of an {@link Activity}. */
+@Beta
+@MapKey
+@Target(METHOD)
+public @interface ActivityKey {
+  Class<? extends Activity> value();
+}
diff --git a/android/src/main/java/dagger/android/AndroidInjection.java b/android/src/main/java/dagger/android/AndroidInjection.java
new file mode 100644
index 000000000..a3d92d858
--- /dev/null
+++ b/android/src/main/java/dagger/android/AndroidInjection.java
@@ -0,0 +1,207 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+import android.app.Activity;
+import android.app.Application;
+import android.app.Fragment;
+import android.app.Service;
+import android.content.BroadcastReceiver;
+import android.content.ContentProvider;
+import android.content.Context;
+import android.util.Log;
+import dagger.internal.Beta;
+
+/** Injects core Android types. */
+@Beta
+public final class AndroidInjection {
+  private static final String TAG = "dagger.android";
+
+  /**
+   * Injects {@code activity} if an associated {@link AndroidInjector} implementation can be found,
+   * otherwise throws an {@link IllegalArgumentException}.
+   *
+   * @throws RuntimeException if the {@link Application} doesn't implement {@link
+   *     HasActivityInjector}.
+   */
+  public static void inject(Activity activity) {
+    checkNotNull(activity, "activity");
+    Application application = activity.getApplication();
+    if (!(application instanceof HasActivityInjector)) {
+      throw new RuntimeException(
+          String.format(
+              "%s does not implement %s",
+              application.getClass().getCanonicalName(),
+              HasActivityInjector.class.getCanonicalName()));
+    }
+
+    AndroidInjector<Activity> activityInjector =
+        ((HasActivityInjector) application).activityInjector();
+    checkNotNull(
+        activityInjector,
+        "%s.activityInjector() returned null",
+        application.getClass().getCanonicalName());
+
+    activityInjector.inject(activity);
+  }
+
+  /**
+   * Injects {@code fragment} if an associated {@link AndroidInjector} implementation can be found,
+   * otherwise throws an {@link IllegalArgumentException}.
+   *
+   * <p>Uses the following algorithm to find the appropriate {@code AndroidInjector<Fragment>} to
+   * use to inject {@code fragment}:
+   *
+   * <ol>
+   *   <li>Walks the parent-fragment hierarchy to find the a fragment that implements {@link
+   *       HasFragmentInjector}, and if none do
+   *   <li>Uses the {@code fragment}'s {@link Fragment#getActivity() activity} if it implements
+   *       {@link HasFragmentInjector}, and if not
+   *   <li>Uses the {@link android.app.Application} if it implements {@link HasFragmentInjector}.
+   * </ol>
+   *
+   * If none of them implement {@link HasFragmentInjector}, a {@link IllegalArgumentException} is
+   * thrown.
+   *
+   * @throws IllegalArgumentException if no parent fragment, activity, or application implements
+   *     {@link HasFragmentInjector}.
+   */
+  public static void inject(Fragment fragment) {
+    checkNotNull(fragment, "fragment");
+    HasFragmentInjector hasFragmentInjector = findHasFragmentInjector(fragment);
+    Log.d(
+        TAG,
+        String.format(
+            "An injector for %s was found in %s",
+            fragment.getClass().getCanonicalName(),
+            hasFragmentInjector.getClass().getCanonicalName()));
+
+    AndroidInjector<Fragment> fragmentInjector = hasFragmentInjector.fragmentInjector();
+    checkNotNull(
+        fragmentInjector,
+        "%s.fragmentInjector() returned null",
+        hasFragmentInjector.getClass().getCanonicalName());
+
+    fragmentInjector.inject(fragment);
+  }
+
+  private static HasFragmentInjector findHasFragmentInjector(Fragment fragment) {
+    Fragment parentFragment = fragment;
+    while ((parentFragment = parentFragment.getParentFragment()) != null) {
+      if (parentFragment instanceof HasFragmentInjector) {
+        return (HasFragmentInjector) parentFragment;
+      }
+    }
+    Activity activity = fragment.getActivity();
+    if (activity instanceof HasFragmentInjector) {
+      return (HasFragmentInjector) activity;
+    }
+    if (activity.getApplication() instanceof HasFragmentInjector) {
+      return (HasFragmentInjector) activity.getApplication();
+    }
+    throw new IllegalArgumentException(
+        String.format("No injector was found for %s", fragment.getClass().getCanonicalName()));
+  }
+
+  /**
+   * Injects {@code service} if an associated {@link AndroidInjector} implementation can be found,
+   * otherwise throws an {@link IllegalArgumentException}.
+   *
+   * @throws RuntimeException if the {@link Application} doesn't implement {@link
+   *     HasServiceInjector}.
+   */
+  public static void inject(Service service) {
+    checkNotNull(service, "service");
+    Application application = service.getApplication();
+    if (!(application instanceof HasServiceInjector)) {
+      throw new RuntimeException(
+          String.format(
+              "%s does not implement %s",
+              application.getClass().getCanonicalName(),
+              HasServiceInjector.class.getCanonicalName()));
+    }
+
+    AndroidInjector<Service> serviceInjector = ((HasServiceInjector) application).serviceInjector();
+    checkNotNull(
+        serviceInjector,
+        "%s.serviceInjector() returned null",
+        application.getClass().getCanonicalName());
+
+    serviceInjector.inject(service);
+  }
+
+  /**
+   * Injects {@code broadcastReceiver} if an associated {@link AndroidInjector} implementation can
+   * be found, otherwise throws an {@link IllegalArgumentException}.
+   *
+   * @throws RuntimeException if the {@link Application} from {@link
+   *     Context#getApplicationContext()} doesn't implement {@link HasBroadcastReceiverInjector}.
+   */
+  public static void inject(BroadcastReceiver broadcastReceiver, Context context) {
+    checkNotNull(broadcastReceiver, "broadcastReceiver");
+    checkNotNull(context, "context");
+    Application application = (Application) context.getApplicationContext();
+    if (!(application instanceof HasBroadcastReceiverInjector)) {
+      throw new RuntimeException(
+          String.format(
+              "%s does not implement %s",
+              application.getClass().getCanonicalName(),
+              HasBroadcastReceiverInjector.class.getCanonicalName()));
+    }
+
+    AndroidInjector<BroadcastReceiver> broadcastReceiverInjector =
+        ((HasBroadcastReceiverInjector) application).broadcastReceiverInjector();
+    checkNotNull(
+        broadcastReceiverInjector,
+        "%s.broadcastReceiverInjector() returned null",
+        application.getClass().getCanonicalName());
+
+    broadcastReceiverInjector.inject(broadcastReceiver);
+  }
+
+  /**
+   * Injects {@code contentProvider} if an associated {@link AndroidInjector} implementation can be
+   * found, otherwise throws an {@link IllegalArgumentException}.
+   *
+   * @throws RuntimeException if the {@link Application} doesn't implement {@link
+   *     HasContentProviderInjector}.
+   */
+  public static void inject(ContentProvider contentProvider) {
+    checkNotNull(contentProvider, "contentProvider");
+    Application application = (Application) contentProvider.getContext().getApplicationContext();
+    if (!(application instanceof HasContentProviderInjector)) {
+      throw new RuntimeException(
+          String.format(
+              "%s does not implement %s",
+              application.getClass().getCanonicalName(),
+              HasContentProviderInjector.class.getCanonicalName()));
+    }
+
+    AndroidInjector<ContentProvider> contentProviderInjector =
+        ((HasContentProviderInjector) application).contentProviderInjector();
+    checkNotNull(
+        contentProviderInjector,
+        "%s.contentProviderInjector() returned null",
+        application.getClass().getCanonicalName());
+
+    contentProviderInjector.inject(contentProvider);
+  }
+
+  private AndroidInjection() {}
+}
diff --git a/android/src/main/java/dagger/android/AndroidInjectionModule.java b/android/src/main/java/dagger/android/AndroidInjectionModule.java
new file mode 100644
index 000000000..224e07f71
--- /dev/null
+++ b/android/src/main/java/dagger/android/AndroidInjectionModule.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Activity;
+import android.app.Fragment;
+import android.app.Service;
+import android.content.BroadcastReceiver;
+import android.content.ContentProvider;
+import dagger.Module;
+import dagger.internal.Beta;
+import dagger.multibindings.Multibinds;
+import java.util.Map;
+
+/**
+ * Contains bindings to ensure the usability of {@code dagger.android} framework classes. This
+ * module should be installed in the component that is used to inject the {@link
+ * android.app.Application} class.
+ */
+@Beta
+@Module
+public abstract class AndroidInjectionModule {
+  @Multibinds
+  abstract Map<Class<? extends Activity>, AndroidInjector.Factory<? extends Activity>>
+      activityInjectorFactories();
+
+  @Multibinds
+  abstract Map<Class<? extends Fragment>, AndroidInjector.Factory<? extends Fragment>>
+      fragmentInjectorFactories();
+
+  @Multibinds
+  abstract Map<Class<? extends Service>, AndroidInjector.Factory<? extends Service>>
+      serviceInjectorFactories();
+
+  @Multibinds
+  abstract Map<
+          Class<? extends BroadcastReceiver>, AndroidInjector.Factory<? extends BroadcastReceiver>>
+      broadcastReceiverInjectorFactories();
+
+  @Multibinds
+  abstract Map<
+          Class<? extends ContentProvider>, AndroidInjector.Factory<? extends ContentProvider>>
+      contentProviderInjectorFactories();
+
+  private AndroidInjectionModule() {}
+}
diff --git a/android/src/main/java/dagger/android/AndroidInjector.java b/android/src/main/java/dagger/android/AndroidInjector.java
new file mode 100644
index 000000000..df778e2d5
--- /dev/null
+++ b/android/src/main/java/dagger/android/AndroidInjector.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import com.google.errorprone.annotations.DoNotMock;
+import dagger.BindsInstance;
+import dagger.internal.Beta;
+
+/**
+ * Performs members-injection for a concrete subtype of a <a
+ * href="https://developer.android.com/guide/components/">core Android type</a> (e.g., {@link
+ * android.app.Activity} or {@link android.app.Fragment}).
+ *
+ * <p>Commonly implemented by {@link dagger.Subcomponent}-annotated types whose {@link
+ * dagger.Subcomponent.Builder} extends {@link Builder}.
+ *
+ * @param <T> a concrete subtype of a core Android type
+ * @see AndroidInjection
+ * @see DispatchingAndroidInjector
+ */
+@Beta
+@DoNotMock(
+    "Faked versions of AndroidInjector are much clearer than a mock. See https://google.github.io/dagger/testing")
+public interface AndroidInjector<T> {
+
+  /** Injects the members of {@code instance}. */
+  void inject(T instance);
+
+  /**
+   * Creates {@link AndroidInjector}s for a concrete subtype of a core Android type.
+   *
+   * @param <T> the concrete type to be injected
+   */
+  @DoNotMock
+  interface Factory<T> {
+    /**
+     * Creates an {@link AndroidInjector} for {@code instance}. This should be the same instance
+     * that will be passed to {@link #inject(Object)}.
+     */
+    AndroidInjector<T> create(T instance);
+  }
+
+  /**
+   * An adapter that lets the common {@link dagger.Subcomponent.Builder} pattern implement {@link
+   * Factory}.
+   *
+   * @param <T> the concrete type to be injected
+   */
+  @DoNotMock
+  abstract class Builder<T> implements AndroidInjector.Factory<T> {
+    @Override
+    public final AndroidInjector<T> create(T instance) {
+      seedInstance(instance);
+      return build();
+    }
+
+    /**
+     * Provides {@code instance} to be used in the binding graph of the built {@link
+     * AndroidInjector}. By default, this is used as a {@link BindsInstance} method, but it may be
+     * overridden to provide any modules which need a reference to the activity.
+     *
+     * <p>This should be the same instance that will be passed to {@link #inject(Object)}.
+     */
+    @BindsInstance
+    public abstract void seedInstance(T instance);
+
+    /** Returns a newly-constructed {@link AndroidInjector}. */
+    public abstract AndroidInjector<T> build();
+  }
+}
diff --git a/android/src/main/java/dagger/android/BUILD b/android/src/main/java/dagger/android/BUILD
deleted file mode 100644
index 70060f8d4..000000000
--- a/android/src/main/java/dagger/android/BUILD
+++ /dev/null
@@ -1,37 +0,0 @@
-# Copyright (C) 2017 The Dagger Authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-# Description:
-#   Public Dagger API for Android
-
-package(default_visibility = ["//:src"])
-
-load(
-    "//:build_defs.bzl",
-    "DOCLINT_HTML_AND_SYNTAX",
-    "DOCLINT_REFERENCES",
-    "JAVA_6_SOURCE_LEVEL",
-    "PRE_JAVA_8_INFERENCE_OPTS",
-)
-
-android_library(
-    name = "android",
-    srcs = glob(["*.java"]),
-    javacopts = PRE_JAVA_8_INFERENCE_OPTS + JAVA_6_SOURCE_LEVEL + DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
-    deps = [
-        "//:dagger_with_compiler",
-        "//third_party:auto_value",
-        "@androidsdk//com.android.support:support-annotations-24.2.0",
-    ],
-)
diff --git a/android/src/main/java/dagger/android/BroadcastReceiverKey.java b/android/src/main/java/dagger/android/BroadcastReceiverKey.java
new file mode 100644
index 000000000..942577ac1
--- /dev/null
+++ b/android/src/main/java/dagger/android/BroadcastReceiverKey.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import android.content.BroadcastReceiver;
+import dagger.MapKey;
+import dagger.internal.Beta;
+import java.lang.annotation.Target;
+
+/** {@link MapKey} annotation to key bindings by a type of a {@link BroadcastReceiver}. */
+@Beta
+@MapKey
+@Target(METHOD)
+public @interface BroadcastReceiverKey {
+  Class<? extends BroadcastReceiver> value();
+}
diff --git a/android/src/main/java/dagger/android/ContentProviderKey.java b/android/src/main/java/dagger/android/ContentProviderKey.java
new file mode 100644
index 000000000..891821c89
--- /dev/null
+++ b/android/src/main/java/dagger/android/ContentProviderKey.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import android.content.ContentProvider;
+import dagger.MapKey;
+import dagger.internal.Beta;
+import java.lang.annotation.Target;
+
+/** {@link MapKey} annotation to key bindings by a type of a {@link ContentProvider}. */
+@Beta
+@MapKey
+@Target(METHOD)
+public @interface ContentProviderKey {
+  Class<? extends ContentProvider> value();
+}
diff --git a/android/src/main/java/dagger/android/ContributesAndroidInjector.java b/android/src/main/java/dagger/android/ContributesAndroidInjector.java
new file mode 100644
index 000000000..b8c63b268
--- /dev/null
+++ b/android/src/main/java/dagger/android/ContributesAndroidInjector.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import java.lang.annotation.Target;
+
+/**
+ * Generates an {@link AndroidInjector} for the return type of this method. The injector is
+ * implemented with a {@link dagger.Subcomponent} and will be a child of the {@link dagger.Module}'s
+ * component.
+ *
+ * <p>This annotation must be applied to an abstract method in a {@link dagger.Module} that returns
+ * a concrete Android framework type (e.g. {@code FooActivity}, {@code BarFragment}, {@code
+ * MyService}, etc). The method should have no parameters.
+ *
+ * <p>For more information, see <a href="https://google.github.io/dagger/android">the docs</a>
+ */
+@Target(METHOD)
+public @interface ContributesAndroidInjector {
+  /** Modules to be installed in the generated {@link dagger.Subcomponent}. */
+  Class<?>[] modules() default {};
+}
diff --git a/android/src/main/java/dagger/android/DaggerActivity.java b/android/src/main/java/dagger/android/DaggerActivity.java
new file mode 100644
index 000000000..ff18ed174
--- /dev/null
+++ b/android/src/main/java/dagger/android/DaggerActivity.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Activity;
+import android.app.Fragment;
+import android.os.Bundle;
+import dagger.internal.Beta;
+import javax.inject.Inject;
+
+/**
+ * An {@link Activity} that injects its members in {@link #onCreate(Bundle)} and can be used to
+ * inject {@link Fragment}s attached to it.
+ */
+@Beta
+public abstract class DaggerActivity extends Activity implements HasFragmentInjector {
+
+  @Inject DispatchingAndroidInjector<Fragment> fragmentInjector;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    AndroidInjection.inject(this);
+    super.onCreate(savedInstanceState);
+  }
+
+  @Override
+  public AndroidInjector<Fragment> fragmentInjector() {
+    return fragmentInjector;
+  }
+}
diff --git a/android/src/main/java/dagger/android/DaggerApplication.java b/android/src/main/java/dagger/android/DaggerApplication.java
new file mode 100644
index 000000000..4ea81b468
--- /dev/null
+++ b/android/src/main/java/dagger/android/DaggerApplication.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Activity;
+import android.app.Application;
+import android.app.Fragment;
+import android.app.Service;
+import android.content.BroadcastReceiver;
+import android.content.ContentProvider;
+import com.google.errorprone.annotations.ForOverride;
+import dagger.internal.Beta;
+import javax.inject.Inject;
+
+/**
+ * An {@link Application} that injects its members and can be used to inject {@link Activity}s,
+ * {@link Fragment}s, {@link Service}s, {@link BroadcastReceiver}s and {@link ContentProvider}s
+ * attached to it. Injection is performed in {@link #onCreate()} or the first call to {@link
+ * AndroidInjection#inject(ContentProvider)}, whichever happens first.
+ */
+@Beta
+public abstract class DaggerApplication extends Application
+    implements HasActivityInjector,
+        HasFragmentInjector,
+        HasServiceInjector,
+        HasBroadcastReceiverInjector,
+        HasContentProviderInjector {
+
+  @Inject DispatchingAndroidInjector<Activity> activityInjector;
+  @Inject DispatchingAndroidInjector<BroadcastReceiver> broadcastReceiverInjector;
+  @Inject DispatchingAndroidInjector<Fragment> fragmentInjector;
+  @Inject DispatchingAndroidInjector<Service> serviceInjector;
+  @Inject DispatchingAndroidInjector<ContentProvider> contentProviderInjector;
+  private volatile boolean needToInject = true;
+
+  @Override
+  public void onCreate() {
+    super.onCreate();
+    injectIfNecessary();
+  }
+
+  /**
+   * Implementations should return an {@link AndroidInjector} for the concrete {@link
+   * DaggerApplication}. Typically, that injector is a {@link dagger.Component}.
+   */
+  @ForOverride
+  protected abstract AndroidInjector<? extends DaggerApplication> applicationInjector();
+
+  /**
+   * Lazily injects the {@link DaggerApplication}'s members. Injection cannot be performed in {@link
+   * Application#onCreate()} since {@link android.content.ContentProvider}s' {@link
+   * android.content.ContentProvider#onCreate() onCreate()} method will be called first and might
+   * need injected members on the application. Injection is not performed in the the constructor, as
+   * that may result in members-injection methods being called before the constructor has completed,
+   * allowing for a partially-constructed instance to escape.
+   */
+  private void injectIfNecessary() {
+    if (needToInject) {
+      synchronized (this) {
+        if (needToInject) {
+          @SuppressWarnings("unchecked")
+          AndroidInjector<DaggerApplication> applicationInjector =
+              (AndroidInjector<DaggerApplication>) applicationInjector();
+          applicationInjector.inject(this);
+          if (needToInject) {
+            throw new IllegalStateException(
+                "The AndroidInjector returned from applicationInjector() did not inject the "
+                    + "DaggerApplication");
+          }
+        }
+      }
+    }
+  }
+
+  @Inject
+  void setInjected() {
+    needToInject = false;
+  }
+
+  @Override
+  public DispatchingAndroidInjector<Activity> activityInjector() {
+    return activityInjector;
+  }
+
+  @Override
+  public DispatchingAndroidInjector<Fragment> fragmentInjector() {
+    return fragmentInjector;
+  }
+
+  @Override
+  public DispatchingAndroidInjector<BroadcastReceiver> broadcastReceiverInjector() {
+    return broadcastReceiverInjector;
+  }
+
+  @Override
+  public DispatchingAndroidInjector<Service> serviceInjector() {
+    return serviceInjector;
+  }
+
+  // injectIfNecessary is called here but not on the other *Injector() methods because it is the
+  // only one that should be called (in AndroidInjection.inject(ContentProvider)) before
+  // Application.onCreate()
+  @Override
+  public AndroidInjector<ContentProvider> contentProviderInjector() {
+    injectIfNecessary();
+    return contentProviderInjector;
+  }
+}
diff --git a/android/src/main/java/dagger/android/DaggerBroadcastReceiver.java b/android/src/main/java/dagger/android/DaggerBroadcastReceiver.java
new file mode 100644
index 000000000..430604a46
--- /dev/null
+++ b/android/src/main/java/dagger/android/DaggerBroadcastReceiver.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.support.annotation.CallSuper;
+import dagger.internal.Beta;
+
+/**
+ * A {@link BroadcastReceiver} that injects its members in the first call to {@link
+ * #onReceive(Context, Intent)}.
+ *
+ * <p>This class should only be used for {@link BroadcastReceiver}s that are declared in an {@code
+ * AndroidManifest.xml}. If, instead, the {@link BroadcastReceiver} is created in code, prefer
+ * constructor injection.
+ *
+ * <p>Note: this class is <em>not thread safe</em> and should not be used with multiple {@link
+ * android.os.Handler}s in calls to {@link Context#registerReceiver(BroadcastReceiver,
+ * android.content.IntentFilter, String, android.os.Handler)}. Injection is performed on each
+ * invocation to {@link #onReceive(Context, Intent)} which could result in inconsistent views of
+ * injected dependencies across threads.
+ *
+ * <p>Subclasses should override {@link #onReceive(Context, Intent)} and call {@code
+ * super.onReceive(context, intent)} immediately to ensure injection is performed immediately.
+ */
+@Beta
+public abstract class DaggerBroadcastReceiver extends BroadcastReceiver {
+  @CallSuper
+  @Override
+  public void onReceive(Context context, Intent intent) {
+    AndroidInjection.inject(this, context);
+  }
+}
diff --git a/android/src/main/java/dagger/android/DaggerContentProvider.java b/android/src/main/java/dagger/android/DaggerContentProvider.java
new file mode 100644
index 000000000..4aad4859a
--- /dev/null
+++ b/android/src/main/java/dagger/android/DaggerContentProvider.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.content.ContentProvider;
+import android.support.annotation.CallSuper;
+import dagger.internal.Beta;
+
+/** A {@link ContentProvider} that injects its members in {@link #onCreate()}. */
+@Beta
+public abstract class DaggerContentProvider extends ContentProvider {
+  @CallSuper
+  @Override
+  public boolean onCreate() {
+    AndroidInjection.inject(this);
+    return true;
+  }
+}
diff --git a/android/src/main/java/dagger/android/DaggerFragment.java b/android/src/main/java/dagger/android/DaggerFragment.java
new file mode 100644
index 000000000..564119031
--- /dev/null
+++ b/android/src/main/java/dagger/android/DaggerFragment.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Fragment;
+import android.content.Context;
+import dagger.internal.Beta;
+import javax.inject.Inject;
+
+/**
+ * A {@link Fragment} that injects its members in {@link #onAttach(Context)} and can be used to
+ * inject child {@link Fragment}s attached to it. Note that when this fragment gets reattached, its
+ * members will be injected again.
+ */
+@Beta
+public abstract class DaggerFragment extends Fragment implements HasFragmentInjector {
+
+  @Inject DispatchingAndroidInjector<Fragment> childFragmentInjector;
+
+  /*@Override
+  public void onAttach(Context context) {
+    AndroidInjection.inject(this);
+    super.onAttach(context);
+  }*/
+
+  @Override
+  public AndroidInjector<Fragment> fragmentInjector() {
+    return childFragmentInjector;
+  }
+}
diff --git a/android/src/main/java/dagger/android/DaggerIntentService.java b/android/src/main/java/dagger/android/DaggerIntentService.java
new file mode 100644
index 000000000..7d9dabb12
--- /dev/null
+++ b/android/src/main/java/dagger/android/DaggerIntentService.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.IntentService;
+import dagger.internal.Beta;
+
+/** An {@link IntentService} that injects its members in {@link #onCreate()}. */
+@Beta
+public abstract class DaggerIntentService extends IntentService {
+  public DaggerIntentService(String name) {
+    super(name);
+  }
+
+  @Override
+  public void onCreate() {
+    AndroidInjection.inject(this);
+    super.onCreate();
+  }
+}
diff --git a/android/src/main/java/dagger/android/DaggerService.java b/android/src/main/java/dagger/android/DaggerService.java
new file mode 100644
index 000000000..cfc6d6b57
--- /dev/null
+++ b/android/src/main/java/dagger/android/DaggerService.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Service;
+import dagger.internal.Beta;
+
+/** A {@link Service} that injects its members in {@link #onCreate()}. */
+@Beta
+public abstract class DaggerService extends Service {
+  @Override
+  public void onCreate() {
+    AndroidInjection.inject(this);
+    super.onCreate();
+  }
+}
diff --git a/android/src/main/java/dagger/android/DispatchingAndroidInjector.java b/android/src/main/java/dagger/android/DispatchingAndroidInjector.java
new file mode 100644
index 000000000..8af9631bb
--- /dev/null
+++ b/android/src/main/java/dagger/android/DispatchingAndroidInjector.java
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static dagger.internal.Preconditions.checkNotNull;
+
+import android.app.Activity;
+import android.app.Fragment;
+import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import dagger.internal.Beta;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+/**
+ * Performs members-injection on instances of core Android types that are constructed by the Android framework and not by Dagger. This class relies on
+ * an injected mapping from each concrete class to an {@link AndroidInjector.Factory} for an {@link
+ * AndroidInjector} of that class. Each concrete class must have its own entry in the map, even if
+ * it extends another class which is already present in the map. Calls {@link Object#getClass()} on
+ * the instance in order to find the appropriate {@link AndroidInjector.Factory}.
+ *
+ * @param <T> the core Android type to be injected
+ */
+@Beta
+public final class DispatchingAndroidInjector<T> implements AndroidInjector<T> {
+  private static final String NO_SUPERTYPES_BOUND_FORMAT =
+      "No injector factory bound for Class<%s>";
+  private static final String SUPERTYPES_BOUND_FORMAT =
+      "No injector factory bound for Class<%1$s>. Injector factories were bound for supertypes "
+          + "of %1$s: %2$s. Did you mean to bind an injector factory for the subtype?";
+
+  private final Map<Class<? extends T>, Provider<AndroidInjector.Factory<? extends T>>>
+      injectorFactories;
+
+  @Inject
+  DispatchingAndroidInjector(
+      Map<Class<? extends T>, Provider<AndroidInjector.Factory<? extends T>>> injectorFactories) {
+    this.injectorFactories = injectorFactories;
+  }
+
+  /**
+   * Attempts to perform members-injection on {@code instance}, returning {@code true} if
+   * successful, {@code false} otherwise.
+   *
+   * @throws InvalidInjectorBindingException if the injector factory bound for a class does not
+   *     inject instances of that class
+   */
+  @CanIgnoreReturnValue
+  public boolean maybeInject(T instance) {
+    Provider<AndroidInjector.Factory<? extends T>> factoryProvider =
+        injectorFactories.get(instance.getClass());
+    if (factoryProvider == null) {
+      return false;
+    }
+
+    @SuppressWarnings("unchecked")
+    AndroidInjector.Factory<T> factory = (AndroidInjector.Factory<T>) factoryProvider.get();
+    try {
+      AndroidInjector<T> injector =
+          checkNotNull(
+              factory.create(instance),
+              "%s.create(I) should not return null.",
+              factory.getClass().getCanonicalName());
+
+      injector.inject(instance);
+      return true;
+    } catch (ClassCastException e) {
+      throw new InvalidInjectorBindingException(
+          String.format(
+              "%s does not implement AndroidInjector.Factory<%s>",
+              factory.getClass().getCanonicalName(), instance.getClass().getCanonicalName()),
+          e);
+    }
+  }
+
+  /**
+   * Performs members-injection on {@code instance}.
+   *
+   * @throws InvalidInjectorBindingException if the injector factory bound for a class does not
+   *     inject instances of that class
+   * @throws IllegalArgumentException if no {@link AndroidInjector.Factory} is bound for {@code
+   *     instance}
+   */
+  @Override
+  public void inject(T instance) {
+    boolean wasInjected = maybeInject(instance);
+    if (!wasInjected) {
+      throw new IllegalArgumentException(errorMessageSuggestions(instance));
+    }
+  }
+
+  /**
+   * Exception thrown if an incorrect binding is made for a {@link AndroidInjector.Factory}. If you
+   * see this exception, make sure the value in your {@code @ActivityKey(YourActivity.class)} or
+   * {@code @FragmentKey(YourFragment.class)} matches the type argument of the injector factory.
+   */
+  @Beta
+  public static final class InvalidInjectorBindingException extends RuntimeException {
+    InvalidInjectorBindingException(String message, ClassCastException cause) {
+      super(message, cause);
+    }
+  }
+
+  /** Returns an error message with the class names that are supertypes of {@code instance}. */
+  private String errorMessageSuggestions(T instance) {
+    List<String> suggestions = new ArrayList<String>();
+    for (Class<? extends T> activityClass : injectorFactories.keySet()) {
+      if (activityClass.isInstance(instance)) {
+        suggestions.add(activityClass.getCanonicalName());
+      }
+    }
+    Collections.sort(suggestions);
+
+    return String.format(
+        suggestions.isEmpty() ? NO_SUPERTYPES_BOUND_FORMAT : SUPERTYPES_BOUND_FORMAT,
+        instance.getClass().getCanonicalName(),
+        suggestions);
+  }
+}
diff --git a/android/src/main/java/dagger/android/FragmentKey.java b/android/src/main/java/dagger/android/FragmentKey.java
new file mode 100644
index 000000000..5f27e3f01
--- /dev/null
+++ b/android/src/main/java/dagger/android/FragmentKey.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import android.app.Fragment;
+import dagger.MapKey;
+import dagger.internal.Beta;
+import java.lang.annotation.Target;
+
+/** {@link MapKey} annotation to key bindings by a type of a {@link Fragment}. */
+@Beta
+@MapKey
+@Target(METHOD)
+public @interface FragmentKey {
+  Class<? extends Fragment> value();
+}
diff --git a/android/src/main/java/dagger/android/HasActivityInjector.java b/android/src/main/java/dagger/android/HasActivityInjector.java
new file mode 100644
index 000000000..136bbad68
--- /dev/null
+++ b/android/src/main/java/dagger/android/HasActivityInjector.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Activity;
+import dagger.internal.Beta;
+
+/** Provides an {@link AndroidInjector} of {@link Activity}s. */
+@Beta
+public interface HasActivityInjector {
+
+  /** Returns an {@link AndroidInjector} of {@link Activity}s. */
+  AndroidInjector<Activity> activityInjector();
+}
diff --git a/android/src/main/java/dagger/android/HasBroadcastReceiverInjector.java b/android/src/main/java/dagger/android/HasBroadcastReceiverInjector.java
new file mode 100644
index 000000000..b2aa99211
--- /dev/null
+++ b/android/src/main/java/dagger/android/HasBroadcastReceiverInjector.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.content.BroadcastReceiver;
+import dagger.internal.Beta;
+
+/** Provides an {@link AndroidInjector} of {@link BroadcastReceiver}s. */
+@Beta
+public interface HasBroadcastReceiverInjector {
+
+  /** Returns an {@link AndroidInjector} of {@link BroadcastReceiver}s. */
+  AndroidInjector<BroadcastReceiver> broadcastReceiverInjector();
+}
diff --git a/android/src/main/java/dagger/android/HasContentProviderInjector.java b/android/src/main/java/dagger/android/HasContentProviderInjector.java
new file mode 100644
index 000000000..997ddb88c
--- /dev/null
+++ b/android/src/main/java/dagger/android/HasContentProviderInjector.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.content.ContentProvider;
+import dagger.internal.Beta;
+
+/** Provides an {@link AndroidInjector} of {@link ContentProvider}s. */
+@Beta
+public interface HasContentProviderInjector {
+
+  /** Returns an {@link AndroidInjector} of {@link ContentProvider}s. */
+  AndroidInjector<ContentProvider> contentProviderInjector();
+}
diff --git a/android/src/main/java/dagger/android/HasFragmentInjector.java b/android/src/main/java/dagger/android/HasFragmentInjector.java
new file mode 100644
index 000000000..564f32d5d
--- /dev/null
+++ b/android/src/main/java/dagger/android/HasFragmentInjector.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Fragment;
+import dagger.internal.Beta;
+
+/** Provides an {@link AndroidInjector} of {@link Fragment}s. */
+@Beta
+public interface HasFragmentInjector {
+
+  /** Returns an {@link AndroidInjector} of {@link Fragment}s. */
+  AndroidInjector<Fragment> fragmentInjector();
+}
diff --git a/android/src/main/java/dagger/android/HasServiceInjector.java b/android/src/main/java/dagger/android/HasServiceInjector.java
new file mode 100644
index 000000000..d1c6a6c2a
--- /dev/null
+++ b/android/src/main/java/dagger/android/HasServiceInjector.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import android.app.Service;
+import dagger.internal.Beta;
+
+/** Provides an {@link AndroidInjector} of {@link Service}s. */
+@Beta
+public interface HasServiceInjector {
+
+  /** Returns an {@link AndroidInjector} of {@link Service}s. */
+  AndroidInjector<Service> serviceInjector();
+}
diff --git a/android/src/main/java/dagger/android/ServiceKey.java b/android/src/main/java/dagger/android/ServiceKey.java
new file mode 100644
index 000000000..1461a98e5
--- /dev/null
+++ b/android/src/main/java/dagger/android/ServiceKey.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import android.app.Service;
+import dagger.MapKey;
+import dagger.internal.Beta;
+import java.lang.annotation.Target;
+
+/** {@link MapKey} annotation to key bindings by a type of a {@link Service}. */
+@Beta
+@MapKey
+@Target(METHOD)
+public @interface ServiceKey {
+  Class<? extends Service> value();
+}
diff --git a/android/src/main/java/dagger/android/package-info.java b/android/src/main/java/dagger/android/package-info.java
new file mode 100644
index 000000000..085c5ee87
--- /dev/null
+++ b/android/src/main/java/dagger/android/package-info.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+@CheckReturnValue
+package dagger.android;
+
+/**
+ * APIs to assist with using Dagger on Android devices. It includes common code to perform injection
+ * as well as Android-specific extensions to {@link dagger.releasablereferences}.
+ */
+import javax.annotation.CheckReturnValue;
diff --git a/build_defs.bzl b/build_defs.bzl
index 9b0447c0c..c3d869889 100644
--- a/build_defs.bzl
+++ b/build_defs.bzl
@@ -18,12 +18,4 @@ DOCLINT_HTML_AND_SYNTAX = ["-Xdoclint:html,syntax"]
 
 DOCLINT_REFERENCES = ["-Xdoclint:reference"]
 
-JAVA_6_SOURCE_LEVEL = ["-source 1.6"]
-
-JAVA_7_SOURCE_LEVEL = ["-source 1.7"]
-
-PRE_JAVA_8_INFERENCE_OPTS = [
-    "-XDusePolyAttribution=false",
-    "-XDuseStrictMethodClashCheck=false",
-    "-XDuseGraphInference=false",
-]
+SOURCE_7_TARGET_7 = ["-source 1.7 -target 1.7"]
diff --git a/compiler/BUILD b/compiler/BUILD
deleted file mode 100644
index 08c111641..000000000
--- a/compiler/BUILD
+++ /dev/null
@@ -1,94 +0,0 @@
-# Copyright (C) 2017 The Dagger Authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-# Description:
-#   A JSR-330 compliant dependency injection system for android and java
-
-package(default_visibility = ["//:src"])
-
-load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX", "DOCLINT_REFERENCES")
-
-COMPILER_SRCS = glob(
-    ["src/main/java/**/*.java"],
-)
-
-COMPILER_PLUGINS = [
-    # TODO(cgruber): Enable Beta checker.
-]
-
-COMPILER_SHARED_DEPS = [
-    "//third_party:auto_service",
-    "//third_party:auto_value",
-    "//third_party:auto_common",
-    "//third_party:error_prone_annotations",
-    "//third_party:google_java_format",
-    "//third_party:javapoet",
-    "@local_jdk//:lib/tools.jar",
-    "//third_party:jsr305_annotations",
-    "//third_party:jsr330_inject",
-    "//core",
-    "//producers",
-]
-
-java_library(
-    name = "compiler",
-    srcs = COMPILER_SRCS,
-    javacopts = DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
-    plugins = COMPILER_PLUGINS,
-    deps = COMPILER_SHARED_DEPS + [
-        "//third_party:guava",
-    ],
-)
-
-java_plugin(
-    name = "component-codegen",
-    generates_api = 1,
-    processor_class = "dagger.internal.codegen.ComponentProcessor",
-    deps = [":compiler"],
-)
-
-load("//:test_defs.bzl", "GenJavaTests")
-
-GenJavaTests(
-    name = "compiler_tests",
-    srcs = glob(["src/test/java/**/*.java"]),
-    javacopts = DOCLINT_HTML_AND_SYNTAX,
-    plugins = [":component-codegen"],
-    deps = [
-        ":compiler",
-        "//core",
-        "//producers",
-        "//third_party:auto_common",
-        "//third_party:auto_value",
-        "//third_party:compile_testing",
-        "//third_party:guava",
-        "//third_party:javapoet",
-        "//third_party:jsr330_inject",
-        "//third_party:junit",
-        "//third_party:mockito",
-        "//third_party:truth",
-    ],
-)
-
-test_suite(name = "AllTests")
-
-test_suite(
-    name = "UnitAndFunctionalTests",
-    tests = [
-        ":AllTests",
-        "//compiler/src/it/functional-tests:AllTests",
-        "//compiler/src/it/producers-functional-tests:AllTests",
-        "//compiler/src/it/tck:AllTests",
-    ],
-)
diff --git a/compiler/src/it/functional-tests/BUILD b/compiler/src/it/functional-tests/BUILD
deleted file mode 100644
index 1e705697e..000000000
--- a/compiler/src/it/functional-tests/BUILD
+++ /dev/null
@@ -1,66 +0,0 @@
-# Copyright (C) 2017 The Dagger Authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-# Description:
-#   Functional tests for Dagger
-
-package(default_visibility = ["//:src"])
-
-load(
-    "//:build_defs.bzl",
-    "DOCLINT_HTML_AND_SYNTAX",
-    "DOCLINT_REFERENCES",
-    "PRE_JAVA_8_INFERENCE_OPTS",
-)
-
-# Sample code to be tested in functional tests.
-java_library(
-    name = "code_under_test",
-    testonly = 1,
-    srcs = glob(
-        ["src/main/java/**/*.java"],
-    ),
-    javacopts = PRE_JAVA_8_INFERENCE_OPTS + DOCLINT_HTML_AND_SYNTAX,
-    # NOTE: This should not depend on Guava or jsr305 to ensure that Dagger can be
-    # used without a Guava and jsr305 deps.
-    deps = [
-        "//:dagger_with_compiler",
-        "//third_party:auto_factory",
-        "//third_party:auto_value",
-        "//third_party:jsr330_inject",
-        "//third_party:junit",
-    ],
-)
-
-load("//:test_defs.bzl", "GenJavaTests")
-
-GenJavaTests(
-    name = "test_lib",
-    srcs = glob(
-        ["src/test/java/**/*.java"],
-    ),
-    javacopts = PRE_JAVA_8_INFERENCE_OPTS + DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
-    deps = [
-        ":code_under_test",
-        "//:dagger_with_compiler",
-        "//third_party:auto_value",
-        "//third_party:guava",
-        "//third_party:guava_testlib",
-        "//third_party:jsr330_inject",
-        "//third_party:junit",
-        "//third_party:truth",
-    ],
-)
-
-test_suite(name = "AllTests")
diff --git a/compiler/src/it/functional-tests/src/main/java/test/A.java b/compiler/src/it/functional-tests/src/main/java/test/A.java
deleted file mode 100644
index b6c27338b..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/A.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import javax.inject.Inject;
-
-class A {
-  @Inject A() {}
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/AbstractMembersInjectingBaseClass.java b/compiler/src/it/functional-tests/src/main/java/test/AbstractMembersInjectingBaseClass.java
deleted file mode 100644
index 7e9676888..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/AbstractMembersInjectingBaseClass.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import javax.inject.Inject;
-
-abstract class AbstractMembersInjectingBaseClass {
-  @Inject Thing thing;
-}
-
diff --git a/compiler/src/it/functional-tests/src/main/java/test/AbstractMiddleClassWithoutMembers.java b/compiler/src/it/functional-tests/src/main/java/test/AbstractMiddleClassWithoutMembers.java
deleted file mode 100644
index 41bcddbdc..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/AbstractMiddleClassWithoutMembers.java
+++ /dev/null
@@ -1,21 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-abstract class AbstractMiddleClassWithoutMembers extends AbstractMembersInjectingBaseClass {
-}
-
diff --git a/compiler/src/it/functional-tests/src/main/java/test/B.java b/compiler/src/it/functional-tests/src/main/java/test/B.java
deleted file mode 100644
index 844f9d7cb..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/B.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import javax.inject.Inject;
-
-class B {
-  @Inject B() {}
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BasicAbstractClassComponent.java b/compiler/src/it/functional-tests/src/main/java/test/BasicAbstractClassComponent.java
deleted file mode 100644
index 473c085c4..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/BasicAbstractClassComponent.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
-* Copyright (C) 2015 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package test;
-
-import dagger.Component;
-
-/**
- * This component tests behavior equivalent to {@link BasicComponent}, but as an abstract class
- * rather than an interface.
- */
-@Component(modules = {PrimitivesModule.class, NullableModule.class})
-abstract class BasicAbstractClassComponent implements BasicComponent {
-  void throwAParty() {
-    throw new RuntimeException("Paaarrrrrtaaaaaaaay!");
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java b/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
deleted file mode 100644
index 6f068c51e..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/BasicComponent.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
-* Copyright (C) 2014 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package test;
-
-import dagger.Component;
-import dagger.Lazy;
-import dagger.MembersInjector;
-import javax.inject.Provider;
-import test.NullableModule.Nullable;
-
-@Component(modules = {PrimitivesModule.class, NullableModule.class})
-interface BasicComponent extends Injector<Thing> {
-  byte getByte();
-  char getChar();
-  short getShort();
-  int getInt();
-  long getLong();
-  boolean getBoolean();
-  float getFloat();
-  double getDouble();
-
-  Byte getBoxedByte();
-  Character getBoxedChar();
-  Short getBoxedShort();
-  Integer getBoxedInt();
-  Long getBoxedLong();
-  Boolean getBoxedBoolean();
-  Float getBoxedFloat();
-  Double getBoxedDouble();
-
-  Provider<Byte> getByteProvider();
-  Provider<Character> getCharProvider();
-  Provider<Short> getShortProvider();
-  Provider<Integer> getIntProvider();
-  Provider<Long> getLongProvider();
-  Provider<Boolean> getBooleanProvider();
-  Provider<Float> getFloatProvider();
-  Provider<Double> getDoubleProvider();
-
-  byte[] getByteArray();
-  char[] getCharArray();
-  short[] getShortArray();
-  int[] getIntArray();
-  long[] getLongArray();
-  boolean[] getBooleanArray();
-  float[] getFloatArray();
-  double[] getDoubleArray();
-
-  Provider<byte[]> getByteArrayProvider();
-  Provider<char[]> getCharArrayProvider();
-  Provider<short[]> getShortArrayProvider();
-  Provider<int[]> getIntArrayProvider();
-  Provider<long[]> getLongArrayProvider();
-  Provider<boolean[]> getBooleanArrayProvider();
-  Provider<float[]> getFloatArrayProvider();
-  Provider<double[]> getDoubleArrayProvider();
-
-  Object noOpMembersInjection(Object obviouslyDoesNotHaveMembersToInject);
-
-  Thing thing();
-  InjectedThing injectedThing();
-  Provider<InjectedThing> injectedThingProvider();
-  Lazy<InjectedThing> lazyInjectedThing();
-  Provider<Lazy<InjectedThing>> lazyInjectedThingProvider();
-  MembersInjector<InjectedThing> injectedThingMembersInjector();
-  
-  @Nullable Object nullObject();
-  Provider<Object> nullObjectProvider();
-  Lazy<Object> lazyNullObject();
-
-  TypeWithInheritedMembersInjection typeWithInheritedMembersInjection();
-  MembersInjector<TypeWithInheritedMembersInjection>
-      typeWithInheritedMembersInjectionMembersInjector();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BooleanKey.java b/compiler/src/it/functional-tests/src/main/java/test/BooleanKey.java
deleted file mode 100644
index 78fab2e45..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/BooleanKey.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
-* Copyright (C) 2015 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package test;
-
-import dagger.MapKey;
-
-@MapKey(unwrapValue = true)
-@interface BooleanKey {
-  boolean value();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericComponent.java
deleted file mode 100644
index 605bf0ae5..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericComponent.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import dagger.Component;
-import java.util.ArrayList;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Set;
-
-@Component(modules = BoundedGenericModule.class)
-interface BoundedGenericComponent {
-  BoundedGenerics<Integer, ArrayList<String>, LinkedList<CharSequence>, Integer, List<Integer>>
-      bounds1();
-  BoundedGenerics<Double, LinkedList<String>, LinkedList<Comparable<String>>, Double, Set<Double>>
-      bounds2();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericModule.java b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericModule.java
deleted file mode 100644
index f24f46166..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/BoundedGenericModule.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import dagger.Module;
-import dagger.Provides;
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Set;
-
-@Module
-class BoundedGenericModule {
-
-  @Provides
-  Integer provideInteger() {
-    return 1;
-  }
-
-  @Provides
-  Double provideDouble() {
-    return 2d;
-  }
-
-  @Provides
-  ArrayList<String> provideArrayListString() {
-    ArrayList<String> list = new ArrayList<>();
-    list.add("arrayListOfString");
-    return list;
-  }
-
-  @Provides
-  LinkedList<String> provideLinkedListString() {
-    LinkedList<String> list = new LinkedList<>();
-    list.add("linkedListOfString");
-    return list;
-  }
-
-  @Provides
-  LinkedList<CharSequence> provideLinkedListCharSeq() {
-    LinkedList<CharSequence> list = new LinkedList<>();
-    list.add("linkedListOfCharSeq");
-    return list;
-  }
-
-  @Provides
-  @SuppressWarnings("unchecked")
-  LinkedList<Comparable<String>> provideArrayListOfComparableString() {
-    LinkedList<Comparable<String>> list = new LinkedList<>();
-    list.add("arrayListOfComparableOfString");
-    return list;
-  }
-
-  @Provides
-  List<Integer> provideListOfInteger() {
-    LinkedList<Integer> list = new LinkedList<>();
-    list.add(3);
-    return list;
-  }
-
-  @Provides
-  Set<Double> provideSetOfDouble() {
-    Set<Double> set = new HashSet<>();
-    set.add(4d);
-    return set;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/BoundedGenerics.java b/compiler/src/it/functional-tests/src/main/java/test/BoundedGenerics.java
deleted file mode 100644
index d433728aa..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/BoundedGenerics.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import java.util.List;
-import javax.inject.Inject;
-
-class BoundedGenerics<A extends Number & Comparable<? super A>, 
-      B extends List<? extends CharSequence>,
-      C extends List<? super String>,
-      D extends A,
-      E extends Iterable<D>> {
-  
-  final A a;
-  final B b;
-  final C c;
-  final D d;
-  final E e;
-  
-  @Inject BoundedGenerics(A a, B b, C c, D d, E e) {
-    this.a = a;
-    this.b = b;
-    this.c = c;
-    this.d = d;
-    this.e = e;
-  }
-
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ByteKey.java b/compiler/src/it/functional-tests/src/main/java/test/ByteKey.java
deleted file mode 100644
index e04ee33dd..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/ByteKey.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
-* Copyright (C) 2015 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package test;
-
-import dagger.MapKey;
-
-@MapKey(unwrapValue = true)
-@interface ByteKey {
-  byte value();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/CharKey.java b/compiler/src/it/functional-tests/src/main/java/test/CharKey.java
deleted file mode 100644
index 276ee6153..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/CharKey.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
-* Copyright (C) 2015 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package test;
-
-import dagger.MapKey;
-
-@MapKey(unwrapValue = true)
-@interface CharKey {
-  char value();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ChildDoubleModule.java b/compiler/src/it/functional-tests/src/main/java/test/ChildDoubleModule.java
deleted file mode 100644
index 09a1e6b72..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/ChildDoubleModule.java
+++ /dev/null
@@ -1,21 +0,0 @@
-package test;
-
-import dagger.Module;
-import dagger.Provides;
-import java.util.ArrayList;
-import java.util.List;
-
-@Module
-class ChildDoubleModule extends ParentModule<Double, String, List<Double>> {
-
-  @Provides Double provideDouble() {
-    return 3d;
-  }
-
-  @Provides List<Double> provideListOfDouble() {
-    List<Double> list = new ArrayList<>();
-    list.add(4d);
-    return list;
-  }
-
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ChildIntegerModule.java b/compiler/src/it/functional-tests/src/main/java/test/ChildIntegerModule.java
deleted file mode 100644
index ac9c61207..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/ChildIntegerModule.java
+++ /dev/null
@@ -1,21 +0,0 @@
-package test;
-
-import dagger.Module;
-import dagger.Provides;
-import java.util.ArrayList;
-import java.util.List;
-
-@Module
-class ChildIntegerModule extends ParentModule<Integer, String, List<Integer>> {
-
-  @Provides Integer provideInteger() {
-    return 1;
-  }
-
-  @Provides List<Integer> provideListOfInteger() {
-    List<Integer> list = new ArrayList<>();
-    list.add(2);
-    return list;
-  }
-
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComplexGenerics.java b/compiler/src/it/functional-tests/src/main/java/test/ComplexGenerics.java
deleted file mode 100644
index 272b29bec..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/ComplexGenerics.java
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import dagger.Lazy;
-import javax.inject.Inject;
-import javax.inject.Provider;
-
-class ComplexGenerics {
-  
-  final Generic2<Generic<A>> g2ga;
-  final Lazy<Generic2<Generic<A>>> g2gaLazy;
-  final Provider<Generic2<Generic<A>>> g2gaProvider;
-  final Generic2<Generic<B>> g2gb;
-  final Lazy<Generic2<Generic<B>>> g2gbLazy;
-  final Provider<Generic2<Generic<B>>> g2gbProvider;
-  final Generic2<A> g2a;
-  final Generic<Generic2<A>> gg2a;
-  final Generic<Generic2<B>> gg2b;
-  
-  @Inject ComplexGenerics(
-      Generic2<Generic<A>> g2ga,
-      Lazy<Generic2<Generic<A>>> g2gaLazy,
-      Provider<Generic2<Generic<A>>> g2gaProvider,
-      Generic2<Generic<B>> g2gb,
-      Lazy<Generic2<Generic<B>>> g2gbLazy,
-      Provider<Generic2<Generic<B>>> g2gbProvider,
-      Generic2<A> g2a,
-      Generic<Generic2<A>> gg2a,
-      Generic<Generic2<B>> gg2b) {
-    this.g2ga = g2ga;
-    this.g2gaLazy = g2gaLazy;
-    this.g2gaProvider = g2gaProvider;
-    this.g2gb = g2gb;
-    this.g2gbLazy = g2gbLazy;
-    this.g2gbProvider = g2gbProvider;
-    this.g2a = g2a;
-    this.gg2a = gg2a;
-    this.gg2b = gg2b;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComponentDependsOnGeneratedCode.java b/compiler/src/it/functional-tests/src/main/java/test/ComponentDependsOnGeneratedCode.java
deleted file mode 100644
index cdc693d0b..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/ComponentDependsOnGeneratedCode.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
-* Copyright (C) 2015 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package test;
-
-import dagger.Component;
-
-/**
- * A component that indirectly depends on code generated by another processor, in this case
- * {@link com.google.auto.factory.AutoFactory}. Neither this type nor its immediately referenced
- * types are generated, but {@link NeedsFactory} depends on the generated
- * {@link NeedsFactory_SomethingFactory}.
- *
- */
-@Component
-interface ComponentDependsOnGeneratedCode {
-  NeedsFactory needsFactory();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCode.java b/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCode.java
deleted file mode 100644
index 28fcf5fc8..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCode.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import dagger.Component;
-
-/**
- * A component whose supertype depends on code generated by another processor, in this case
- * {@link com.google.auto.factory.AutoFactory}.
- *
- */
-@Component
-interface ComponentSupertypeDependsOnGeneratedCode
-    extends ComponentSupertypeDependsOnGeneratedCodeInterface {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCodeInterface.java b/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCodeInterface.java
deleted file mode 100644
index 325c44970..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/ComponentSupertypeDependsOnGeneratedCodeInterface.java
+++ /dev/null
@@ -1,21 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-interface ComponentSupertypeDependsOnGeneratedCodeInterface {
-  NeedsFactory_SomethingFactory somethingFactory();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComponentWithReusableBindings.java b/compiler/src/it/functional-tests/src/main/java/test/ComponentWithReusableBindings.java
deleted file mode 100644
index ad1e4c881..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/ComponentWithReusableBindings.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import dagger.Component;
-import dagger.Module;
-import dagger.Provides;
-import dagger.Reusable;
-import dagger.Subcomponent;
-import javax.inject.Qualifier;
-
-@Component(modules = ComponentWithReusableBindings.ReusableBindingsModule.class)
-interface ComponentWithReusableBindings {
-
-  @Qualifier
-  @interface InParent {}
-
-  @Qualifier
-  @interface InChildren {}
-
-  @InParent
-  Object reusableInParent();
-
-  ChildOne childOne();
-
-  ChildTwo childTwo();
-
-  @Subcomponent
-  interface ChildOne {
-    @InParent
-    Object reusableInParent();
-
-    @InChildren
-    Object reusableInChild();
-  }
-
-  @Subcomponent
-  interface ChildTwo {
-    @InParent
-    Object reusableInParent();
-
-    @InChildren
-    Object reusableInChild();
-  }
-
-  @Module
-  static class ReusableBindingsModule {
-    @Provides
-    @Reusable
-    @InParent
-    static Object inParent() {
-      return new Object();
-    }
-
-    @Provides
-    @Reusable
-    @InChildren
-    static Object inChildren() {
-      return new Object();
-    }
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ComponentsWithNestedModules.java b/compiler/src/it/functional-tests/src/main/java/test/ComponentsWithNestedModules.java
deleted file mode 100644
index 48faad190..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/ComponentsWithNestedModules.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import dagger.Component;
-import dagger.Module;
-
-// https://github.com/google/dagger/issues/279
-public class ComponentsWithNestedModules {
-  @Component(modules = RegularComponent.SharedModule.class)
-  public interface RegularComponent {
-    @Module class SharedModule {}
-  }
-
-  @Component(modules = ExtendsRegularComponent.SharedModule.class)
-  public interface ExtendsRegularComponent extends RegularComponent {
-    @Module(includes = RegularComponent.SharedModule.class)
-    class SharedModule {}
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/Generic.java b/compiler/src/it/functional-tests/src/main/java/test/Generic.java
deleted file mode 100644
index 72e8f1c5d..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/Generic.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import javax.inject.Inject;
-
-public class Generic<T> {
-  final T t;
-
-  @Inject public Generic(T t) {
-    this.t = t;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/Generic2.java b/compiler/src/it/functional-tests/src/main/java/test/Generic2.java
deleted file mode 100644
index 0d353bf6b..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/Generic2.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import javax.inject.Inject;
-
-public class Generic2<T> {
-  final T t;
-
-  @Inject Generic2(T t) {
-    this.t = t;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericChild.java b/compiler/src/it/functional-tests/src/main/java/test/GenericChild.java
deleted file mode 100644
index 3c42bc885..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/GenericChild.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import javax.inject.Inject;
-
-class GenericChild<T> extends GenericParent<T, B> {
-  
-  A registeredA;
-  T registeredT;
-  
-  @Inject GenericChild() {}
-  
-  @Inject A a;
-  @Inject T t;
-  
-  @Inject void registerA(A a) { this.registeredA = a; }
-  @Inject void registerT(T t) { this.registeredT = t; }
-
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java
deleted file mode 100644
index 6ce8d89ac..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/GenericComponent.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import dagger.Component;
-import test.sub.Exposed;
-import test.sub.PublicSubclass;
-
-@Component(modules = {ChildDoubleModule.class, ChildIntegerModule.class})
-interface GenericComponent {
-  ReferencesGeneric referencesGeneric();
-  GenericDoubleReferences<A> doubleGenericA();
-  GenericDoubleReferences<B> doubleGenericB();
-  ComplexGenerics complexGenerics();
-  GenericNoDeps<A> noDepsA();
-  GenericNoDeps<B> noDepsB();
-
-  void injectA(GenericChild<A> childA);
-  void injectB(GenericChild<B> childB);
-
-  Exposed exposed();
-  PublicSubclass publicSubclass();
-  
-  Iterable<Integer> iterableInt();
-  Iterable<Double> iterableDouble();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericDoubleReferences.java b/compiler/src/it/functional-tests/src/main/java/test/GenericDoubleReferences.java
deleted file mode 100644
index d70f9e25c..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/GenericDoubleReferences.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import javax.inject.Inject;
-
-class GenericDoubleReferences<T> {
-  final T t;
-  final T t2;
-  final Thing a;
-  final Thing a2;
-
-  @Inject GenericDoubleReferences(T t, Thing a, T t2, Thing a2) {
-    this.t = t;
-    this.a = a;
-    this.t2 = t2;
-    this.a2 = a2;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericNoDeps.java b/compiler/src/it/functional-tests/src/main/java/test/GenericNoDeps.java
deleted file mode 100644
index b569ecb3e..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/GenericNoDeps.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import javax.inject.Inject;
-
-class GenericNoDeps<T> {
-  
-  @Inject GenericNoDeps() {}
-
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java b/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java
deleted file mode 100644
index 1f7a322f3..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/GenericParent.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import javax.inject.Inject;
-import javax.inject.Provider;
-
-class GenericParent<X, Y> {
-  
-  Provider<X> registeredX;
-  Y registeredY;
-  B registeredB;
-  
-  @Inject GenericParent() {}
-  
-  @Inject Provider<X> x;
-  @Inject Y y;
-  @Inject B b;
-  
-  @Inject
-  void registerX(Provider<X> x) {
-    this.registeredX = x;
-  }
-  @Inject void registerY(Y y) { this.registeredY = y; }
-  @Inject void registerB(B b) { this.registeredB = b; }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/InjectedThing.java b/compiler/src/it/functional-tests/src/main/java/test/InjectedThing.java
deleted file mode 100644
index a262e87ae..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/InjectedThing.java
+++ /dev/null
@@ -1,231 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import dagger.Lazy;
-import dagger.MembersInjector;
-import javax.inject.Inject;
-import javax.inject.Provider;
-
-@SuppressWarnings("unused")
-final class InjectedThing {
-  @Inject byte primitiveByte;
-  @Inject char primitiveChar;
-  @Inject short primitiveShort;
-  @Inject int primitiveInt;
-  @Inject long primitiveLong;
-  @Inject boolean primitiveBoolean;
-  @Inject float primitiveFloat;
-  @Inject double primitiveDouble;
-
-  @Inject Provider<Byte> byteProvider;
-  @Inject Provider<Character> charProvider;
-  @Inject Provider<Short> shortProvider;
-  @Inject Provider<Integer> intProvider;
-  @Inject Provider<Long> longProvider;
-  @Inject Provider<Boolean> booleanProvider;
-  @Inject Provider<Float> floatProvider;
-  @Inject Provider<Double> doubleProvider;
-
-  @Inject Lazy<Byte> lazyByte;
-  @Inject Lazy<Character> lazyChar;
-  @Inject Lazy<Short> lazyShort;
-  @Inject Lazy<Integer> lazyInt;
-  @Inject Lazy<Long> lazyLong;
-  @Inject Lazy<Boolean> lazyBoolean;
-  @Inject Lazy<Float> lazyFloat;
-  @Inject Lazy<Double> lazyDouble;
-
-  @Inject Byte boxedBype;
-  @Inject Character boxedChar;
-  @Inject Short boxedShort;
-  @Inject Integer boxedInt;
-  @Inject Long boxedLong;
-  @Inject Boolean boxedBoolean;
-  @Inject Float boxedFloat;
-  @Inject Double boxedDouble;
-
-  @Inject byte[] byteArray;
-  @Inject char[] charArray;
-  @Inject short[] shortArray;
-  @Inject int[] intArray;
-  @Inject long[] longArray;
-  @Inject boolean[] booleanArray;
-  @Inject float[] floatArray;
-  @Inject double[] doubleArray;
-
-  @Inject Provider<byte[]> byteArrayProvider;
-  @Inject Provider<char[]> charArrayProvider;
-  @Inject Provider<short[]> shortArrayProvider;
-  @Inject Provider<int[]> intArrayProvider;
-  @Inject Provider<long[]> longArrayProvider;
-  @Inject Provider<boolean[]> booleanArrayProvider;
-  @Inject Provider<float[]> floatArrayProvider;
-  @Inject Provider<double[]> doubleArrayProvider;
-
-  @Inject Lazy<byte[]> lazyByteArray;
-  @Inject Lazy<char[]> lazyCharArray;
-  @Inject Lazy<short[]> lazyShortArray;
-  @Inject Lazy<int[]> lazyIntArray;
-  @Inject Lazy<long[]> lazyLongArray;
-  @Inject Lazy<boolean[]> lazyBooleanArray;
-  @Inject Lazy<float[]> lazy;
-  @Inject Lazy<double[]> lazyDoubleArray;
-
-  @Inject Thing thing;
-  @Inject Provider<Thing> thingProvider;
-  @Inject Lazy<Thing> lazyThing;
-  @Inject Provider<Lazy<Thing>> lazyThingProvider;
-  @Inject MembersInjector<Thing> thingMembersInjector;
-
-  @Inject InjectedThing(
-      byte primitiveByte,
-      char primitiveChar,
-      short primitiveShort,
-      int primitiveInt,
-      long primitiveLong,
-      boolean primitiveBoolean,
-      float primitiveFloat,
-      double primitiveDouble,
-
-      Provider<Byte> byteProvider,
-      Provider<Character> charProvider,
-      Provider<Short> shortProvider,
-      Provider<Integer> intProvider,
-      Provider<Long> longProvider,
-      Provider<Boolean> booleanProvider,
-      Provider<Float> floatProvider,
-      Provider<Double> doubleProvider,
-
-      Lazy<Byte> lazyByte,
-      Lazy<Character> lazyChar,
-      Lazy<Short> lazyShort,
-      Lazy<Integer> lazyInt,
-      Lazy<Long> lazyLong,
-      Lazy<Boolean> lazyBoolean,
-      Lazy<Float> lazyFloat,
-      Lazy<Double> lazyDouble,
-
-      Byte boxedBype,
-      Character boxedChar,
-      Short boxedShort,
-      Integer boxedInt,
-      Long boxedLong,
-      Boolean boxedBoolean,
-      Float boxedFloat,
-      Double boxedDouble,
-
-      byte[] byteArray,
-      char[] charArray,
-      short[] shortArray,
-      int[] intArray,
-      long[] longArray,
-      boolean[] booleanArray,
-      float[] floatArray,
-      double[] doubleArray,
-
-      Provider<byte[]> byteArrayProvider,
-      Provider<char[]> charArrayProvider,
-      Provider<short[]> shortArrayProvider,
-      Provider<int[]> intArrayProvider,
-      Provider<long[]> longArrayProvider,
-      Provider<boolean[]> booleanArrayProvider,
-      Provider<float[]> floatArrayProvider,
-      Provider<double[]> doubleArrayProvider,
-
-      Lazy<byte[]> lazyByteArray,
-      Lazy<char[]> lazyCharArray,
-      Lazy<short[]> lazyShortArray,
-      Lazy<int[]> lazyIntArray,
-      Lazy<long[]> lazyLongArray,
-      Lazy<boolean[]> lazyBooleanArray,
-      Lazy<float[]> lazy,
-      Lazy<double[]> lazyDoubleArray,
-
-      Thing thing,
-      Provider<Thing> thingProvider,
-      Lazy<Thing> lazyThing,
-      MembersInjector<Thing> thingMembersInjector) {}
-
-  @Inject void primitiveByte(byte primitiveByte) {}
-  @Inject void primitiveChar(char primitiveChar) {}
-  @Inject void primitiveShort(short primitiveShort) {}
-  @Inject void primitiveInt(int primitiveInt) {}
-  @Inject void primitiveLong(long primitiveLong) {}
-  @Inject void primitiveBoolean(boolean primitiveBoolean) {}
-  @Inject void primitiveFloat(float primitiveFloat) {}
-  @Inject void primitiveDouble(double primitiveDouble) {}
-
-  @Inject void byteProvider(Provider<Byte> byteProvider) {}
-  @Inject void charProvider(Provider<Character> charProvider) {}
-  @Inject void shortProvider(Provider<Short> shortProvider) {}
-  @Inject void intProvider(Provider<Integer> intProvider) {}
-  @Inject void longProvider(Provider<Long> longProvider) {}
-  @Inject void booleanProvider(Provider<Boolean> booleanProvider) {}
-  @Inject void floatProvider(Provider<Float> floatProvider) {}
-  @Inject void doubleProvider(Provider<Double> doubleProvider) {}
-
-  @Inject void lazyByte(Lazy<Byte> lazyByte) {}
-  @Inject void lazyChar(Lazy<Character> lazyChar) {}
-  @Inject void lazyShort(Lazy<Short> lazyShort) {}
-  @Inject void lazyInt(Lazy<Integer> lazyInt) {}
-  @Inject void lazyLong(Lazy<Long> lazyLong) {}
-  @Inject void lazyBoolean(Lazy<Boolean> lazyBoolean) {}
-  @Inject void lazyFloat(Lazy<Float> lazyFloat) {}
-  @Inject void lazyDouble(Lazy<Double> lazyDouble) {}
-
-  @Inject void boxedBype(Byte boxedBype) {}
-  @Inject void boxedChar(Character boxedChar) {}
-  @Inject void boxedShort(Short boxedShort) {}
-  @Inject void boxedInt(Integer boxedInt) {}
-  @Inject void boxedLong(Long boxedLong) {}
-  @Inject void boxedBoolean(Boolean boxedBoolean) {}
-  @Inject void boxedFloat(Float boxedFloat) {}
-  @Inject void boxedDouble(Double boxedDouble) {}
-
-  @Inject void byteArray(byte[] byteArray) {}
-  @Inject void charArray(char[] charArray) {}
-  @Inject void shortArray(short[] shortArray) {}
-  @Inject void intArray(int[] intArray) {}
-  @Inject void longArray(long[] longArray) {}
-  @Inject void booleanArray(boolean[] booleanArray) {}
-  @Inject void floatArray(float[] floatArray) {}
-  @Inject void doubleArray(double[] doubleArray) {}
-
-  @Inject void byteArrayProvider(Provider<byte[]> byteArrayProvider) {}
-  @Inject void charArrayProvider(Provider<char[]> charArrayProvider) {}
-  @Inject void shortArrayProvider(Provider<short[]> shortArrayProvider) {}
-  @Inject void intArrayProvider(Provider<int[]> intArrayProvider) {}
-  @Inject void longArrayProvider(Provider<long[]> longArrayProvider) {}
-  @Inject void booleanArrayProvider(Provider<boolean[]> booleanArrayProvider) {}
-  @Inject void floatArrayProvider(Provider<float[]> floatArrayProvider) {}
-  @Inject void doubleArrayProvider(Provider<double[]> doubleArrayProvider) {}
-
-  @Inject void lazyByteArray(Lazy<byte[]> lazyByteArray) {}
-  @Inject void lazyCharArray(Lazy<char[]> lazyCharArray) {}
-  @Inject void lazyShortArray(Lazy<short[]> lazyShortArray) {}
-  @Inject void lazyIntArray(Lazy<int[]> lazyIntArray) {}
-  @Inject void lazyLongArray(Lazy<long[]> lazyLongArray) {}
-  @Inject void lazyBooleanArray(Lazy<boolean[]> lazyBooleanArray) {}
-  @Inject void lazy(Lazy<float[]> lazy) {}
-  @Inject void lazyDoubleArray(Lazy<double[]> lazyDoubleArray) {}
-
-  @Inject void thing(Thing thing) {}
-  @Inject void thingProvider(Provider<Thing> thingProvider) {}
-  @Inject void lazyThing(Lazy<Thing> lazyThing) {}
-  @Inject void thingMembersInjector(MembersInjector<Thing> thingMembersInjector) {}
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/Injector.java b/compiler/src/it/functional-tests/src/main/java/test/Injector.java
deleted file mode 100644
index e890640a2..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/Injector.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (C) 2014 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import dagger.Lazy;
-import dagger.MembersInjector;
-import javax.inject.Provider;
-
-/**
- * A simple interface that exercises all forms of injection for a given type.
- */
-interface Injector<T> {
-  T instance();
-  Provider<T> provider();
-  Lazy<T> lazy();
-  MembersInjector<T> membersInjector();
-  void injectMembers(T t);
-  T injectMembersAndReturn(T t);
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ModuleIncludesCollectedFromModuleSuperclasses.java b/compiler/src/it/functional-tests/src/main/java/test/ModuleIncludesCollectedFromModuleSuperclasses.java
deleted file mode 100644
index 0b330a1f9..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/ModuleIncludesCollectedFromModuleSuperclasses.java
+++ /dev/null
@@ -1,65 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import dagger.Component;
-import dagger.Module;
-import dagger.Provides;
-
-/**
- * This tests that @Module.includes are traversed for supertypes of a module.
- */
-final class ModuleIncludesCollectedFromModuleSuperclasses {
-  @Component(modules = TopLevelModule.class)
-  interface C {
-    Foo<String> foo();
-    int includedInTopLevelModule();
-    String includedFromModuleInheritance();
-  }
-
-  @Module(includes = IncludedTopLevel.class)
-  static class TopLevelModule extends FooModule<String> {}
-
-  static class Foo<T> {}
-
-  @Module(includes = IncludedFromModuleInheritance.class)
-  abstract static class FooModule<T> extends FooCreator {
-    @Provides Foo<T> fooOfT() {
-      return createFoo();
-    }
-  }
-
-  static class FooCreator {
-    <T> Foo<T> createFoo() {
-      return new Foo<T>();
-    }
-  }
-
-  @Module
-  static class IncludedTopLevel {
-    @Provides int i() {
-      return 123;
-    }
-  }
-
-  @Module
-  static class IncludedFromModuleInheritance {
-    @Provides String inheritedProvision() {
-      return "inherited";
-    }
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ModuleWithConflictingNames.java b/compiler/src/it/functional-tests/src/main/java/test/ModuleWithConflictingNames.java
deleted file mode 100644
index 2ec4f387d..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/ModuleWithConflictingNames.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import dagger.Module;
-import dagger.Provides;
-import javax.inject.Inject;
-import javax.inject.Provider;
-
-/**
- * Module with bindings that might result in generated factories with conflicting field and
- * parameter names.
- */
-@Module
-final class ModuleWithConflictingNames {
-  @Provides
-  static Object object(int foo, Provider<String> fooProvider) {
-    return foo + fooProvider.get();
-  }
-
-  /**
-   * A class that might result in a generated factory with conflicting field and parameter names.
-   */
-  static class InjectedClassWithConflictingNames {
-    final int foo;
-    final Provider<String> fooProvider;
-
-    @Inject
-    InjectedClassWithConflictingNames(int foo, Provider<String> fooProvider) {
-      this.foo = foo;
-      this.fooProvider = fooProvider;
-    }
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
deleted file mode 100644
index cd9aba794..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponent.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
-* Copyright (C) 2015 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package test;
-
-import dagger.Component;
-import dagger.multibindings.StringKey;
-import java.util.Collection;
-import java.util.Map;
-import java.util.Set;
-import javax.inject.Named;
-import javax.inject.Provider;
-import test.sub.ContributionsModule;
-
-@Component(
-  modules = {MultibindingModule.class, MultibindsModule.class, ContributionsModule.class},
-  dependencies = MultibindingDependency.class
-)
-interface MultibindingComponent {
-  Map<String, String> map();
-  Map<String, String[]> mapOfArrays();
-  Map<String, Provider<String>> mapOfProviders();
-  Set<String> mapKeys();
-  Collection<String> mapValues();
-  Set<Integer> set();
-  Map<NestedAnnotationContainer.NestedWrappedKey, String> nestedKeyMap();
-  Map<Class<? extends Number>, String> numberClassKeyMap();
-  Map<Class<?>, String> classKeyMap();
-  Map<Long, String> longKeyMap();
-  Map<Integer, String> integerKeyMap();
-  Map<Short, String> shortKeyMap();
-  Map<Byte, String> byteKeyMap();
-  Map<Boolean, String> booleanKeyMap();
-  Map<Character, String> characterKeyMap();
-  Map<StringKey, String> unwrappedAnnotationKeyMap();
-  Map<WrappedAnnotationKey, String> wrappedAnnotationKeyMap();
-  @Named("complexQualifier") Set<String> complexQualifierStringSet();
-  Set<Object> emptySet();
-
-  @Named("complexQualifier")
-  Set<Object> emptyQualifiedSet();
-
-  Map<String, Object> emptyMap();
-
-  @Named("complexQualifier")
-  Map<String, Object> emptyQualifiedMap();
-
-  Set<CharSequence> maybeEmptySet();
-
-  @Named("complexQualifier")
-  Set<CharSequence> maybeEmptyQualifiedSet();
-
-  Map<String, CharSequence> maybeEmptyMap();
-
-  @Named("complexQualifier")
-  Map<String, CharSequence> maybeEmptyQualifiedMap();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponentWithMultibindingsInterface.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponentWithMultibindingsInterface.java
deleted file mode 100644
index c711bb257..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingComponentWithMultibindingsInterface.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import dagger.Component;
-import dagger.Multibindings;
-import test.sub.ContributionsModule;
-
-/**
- * A component used to test multibindings that use {@link Multibindings @Multibindings}-annotated
- * nested interfaces to declare multibindings.
- */
-@Component(
-  modules = {
-    MultibindingModule.class,
-    MultibindingsInterfaceModule.class,
-    ContributionsModule.class
-  },
-  dependencies = MultibindingDependency.class
-)
-interface MultibindingComponentWithMultibindingsInterface extends MultibindingComponent {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingDependency.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingDependency.java
deleted file mode 100644
index d4dca4f32..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingDependency.java
+++ /dev/null
@@ -1,21 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-interface MultibindingDependency {
-  double doubleDependency();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
deleted file mode 100644
index 8bb18db55..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingModule.java
+++ /dev/null
@@ -1,242 +0,0 @@
-/*
-* Copyright (C) 2015 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package test;
-
-import dagger.Module;
-import dagger.Provides;
-import dagger.multibindings.ClassKey;
-import dagger.multibindings.ElementsIntoSet;
-import dagger.multibindings.IntKey;
-import dagger.multibindings.IntoMap;
-import dagger.multibindings.IntoSet;
-import dagger.multibindings.LongKey;
-import dagger.multibindings.StringKey;
-import java.math.BigDecimal;
-import java.math.BigInteger;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
-import javax.inject.Named;
-import javax.inject.Provider;
-
-@Module
-class MultibindingModule {
-  @Provides
-  @IntoMap
-  @StringKey("foo")
-  static String provideFooKey(@SuppressWarnings("unused") double doubleDependency) {
-    return "foo value";
-  }
-
-  @Provides
-  @IntoMap
-  @StringKey("bar")
-  static String provideBarKey() {
-    return "bar value";
-  }
-
-  @Provides
-  @IntoMap
-  @StringKey("foo")
-  static String[] provideFooArrayValue(@SuppressWarnings("unused") double doubleDependency) {
-    return new String[] {"foo1", "foo2"};
-  }
-
-  @Provides
-  @IntoMap
-  @StringKey("bar")
-  static String[] provideBarArrayValue() {
-    return new String[] {"bar1", "bar2"};
-  }
-
-  @Provides
-  @IntoSet
-  static int provideFiveToSet() {
-    return 5;
-  }
-
-  @Provides
-  @IntoSet
-  static int provideSixToSet() {
-    return 6;
-  }
-
-  @Provides
-  @ElementsIntoSet
-  static Set<Integer> provideElementsIntoSet() {
-    Set<Integer> set = new HashSet<>();
-    set.add(-101);
-    set.add(-102);
-    return set;
-  }
-
-  @Provides
-  static Set<String> provideMapKeys(Map<String, Provider<String>> map) {
-    return map.keySet();
-  }
-
-  @Provides
-  static Collection<String> provideMapValues(Map<String, String> map) {
-    return map.values();
-  }
-
-  @Provides
-  @IntoMap
-  @NestedAnnotationContainer.NestedWrappedKey(Integer.class)
-  static String valueForInteger() {
-    return "integer";
-  }
-
-  @Provides
-  @IntoMap
-  @NestedAnnotationContainer.NestedWrappedKey(Long.class)
-  static String valueForLong() {
-    return "long";
-  }
-
-  @Provides
-  @IntoMap
-  @ClassKey(Integer.class)
-  static String valueForClassInteger() {
-    return "integer";
-  }
-
-  @Provides
-  @IntoMap
-  @ClassKey(Long.class)
-  static String valueForClassLong() {
-    return "long";
-  }
-
-  @Provides
-  @IntoMap
-  @NumberClassKey(BigDecimal.class)
-  static String valueForNumberClassBigDecimal() {
-    return "bigdecimal";
-  }
-
-  @Provides
-  @IntoMap
-  @NumberClassKey(BigInteger.class)
-  static String valueForNumberClassBigInteger() {
-    return "biginteger";
-  }
-
-  @Provides
-  @IntoMap
-  @LongKey(100)
-  static String valueFor100Long() {
-    return "100 long";
-  }
-
-  @Provides
-  @IntoMap
-  @IntKey(100)
-  static String valueFor100Int() {
-    return "100 int";
-  }
-
-  @Provides
-  @IntoMap
-  @ShortKey(100)
-  static String valueFor100Short() {
-    return "100 short";
-  }
-
-  @Provides
-  @IntoMap
-  @ByteKey(100)
-  static String valueFor100Byte() {
-    return "100 byte";
-  }
-
-  @Provides
-  @IntoMap
-  @BooleanKey(true)
-  static String valueForTrue() {
-    return "true";
-  }
-
-  @Provides
-  @IntoMap
-  @CharKey('a')
-  static String valueForA() {
-    return "a char";
-  }
-
-  @Provides
-  @IntoMap
-  @CharKey('\n')
-  static String valueForNewline() {
-    return "newline char";
-  }
-
-  @Provides
-  @IntoMap
-  @UnwrappedAnnotationKey(@StringKey("foo\n"))
-  static String valueForUnwrappedAnnotationKeyFoo() {
-    return "foo annotation";
-  }
-
-  @Provides
-  @IntoMap
-  @WrappedAnnotationKey(
-    value = @StringKey("foo"),
-    integers = {1, 2, 3},
-    annotations = {},
-    classes = {Long.class, Integer.class}
-  )
-  static String valueForWrappedAnnotationKeyFoo() {
-    return "wrapped foo annotation";
-  }
-
-  @Provides
-  @IntoSet
-  @Named("complexQualifier")
-  static String valueForComplexQualifierSet() {
-    return "foo";
-  }
-
-  @Provides
-  @IntoSet
-  static CharSequence setContribution() {
-    return "foo";
-  }
-
-  @Provides
-  @IntoSet
-  @Named("complexQualifier")
-  static CharSequence qualifiedSetContribution() {
-    return "qualified foo";
-  }
-
-  @Provides
-  @IntoMap
-  @StringKey("key")
-  static CharSequence mapContribution() {
-    return "foo value";
-  }
-
-  @Provides
-  @IntoMap
-  @Named("complexQualifier")
-  @StringKey("key")
-  static CharSequence qualifiedMapContribution() {
-    return "qualified foo value";
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindingsInterfaceModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindingsInterfaceModule.java
deleted file mode 100644
index cc58830a9..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindingsInterfaceModule.java
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import dagger.Module;
-import dagger.Multibindings;
-import java.util.Map;
-import java.util.Set;
-import javax.inject.Named;
-
-/**
- * A module that uses a {@link Multibindings @Multibindings}-annotated nested interface to declare
- * multibindings.
- */
-@Module
-final class MultibindingsInterfaceModule {
-
-  interface EmptiesSupertype {
-    Set<Object> emptySet();
-
-    Map<String, Object> emptyMap();
-
-    Set<CharSequence> set();
-
-    Map<String, CharSequence> map();
-  }
-
-  @Multibindings
-  interface Empties extends EmptiesSupertype {
-    @Named("complexQualifier")
-    Set<Object> emptyQualifiedSet();
-
-    @Named("complexQualifier")
-    Map<String, Object> emptyQualifiedMap();
-
-    @Named("complexQualifier")
-    Set<CharSequence> qualifiedSet();
-
-    @Named("complexQualifier")
-    Map<String, CharSequence> qualifiedMap();
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/MultibindsModule.java b/compiler/src/it/functional-tests/src/main/java/test/MultibindsModule.java
deleted file mode 100644
index 7e213e61b..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/MultibindsModule.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import dagger.Module;
-import dagger.multibindings.Multibinds;
-import java.util.Map;
-import java.util.Set;
-import javax.inject.Named;
-
-/**
- * A module that uses {@link Multibinds @Multibinds}-annotated abstract methods to declare
- * multibindings.
- */
-@Module
-abstract class MultibindsModule {
-
-  @Multibinds
-  abstract Set<Object> emptySet();
-
-  @Multibinds
-  abstract Map<String, Object> emptyMap();
-
-  @Multibinds
-  abstract Set<CharSequence> set();
-
-  @Multibinds
-  abstract Map<String, CharSequence> map();
-
-  @Multibinds
-  @Named("complexQualifier")
-  abstract Set<Object> emptyQualifiedSet();
-
-  @Multibinds
-  @Named("complexQualifier")
-  abstract Map<String, Object> emptyQualifiedMap();
-
-  @Multibinds
-  @Named("complexQualifier")
-  abstract Set<CharSequence> qualifiedSet();
-
-  @Multibinds
-  @Named("complexQualifier")
-  abstract Map<String, CharSequence> qualifiedMap();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/NeedsFactory.java b/compiler/src/it/functional-tests/src/main/java/test/NeedsFactory.java
deleted file mode 100644
index a60345f31..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/NeedsFactory.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
-* Copyright (C) 2015 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package test;
-
-import com.google.auto.factory.AutoFactory;
-import javax.inject.Inject;
-
-class NeedsFactory {
-  @Inject
-  NeedsFactory(@SuppressWarnings("unused") NeedsFactory_SomethingFactory somethingFactory) {}
-
-  @AutoFactory
-  static class Something {}
-}
-
diff --git a/compiler/src/it/functional-tests/src/main/java/test/NestedAnnotationContainer.java b/compiler/src/it/functional-tests/src/main/java/test/NestedAnnotationContainer.java
deleted file mode 100644
index e5d3b6499..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/NestedAnnotationContainer.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
-* Copyright (C) 2015 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package test;
-
-import dagger.MapKey;
-
-public final class NestedAnnotationContainer {
-
-  @MapKey(unwrapValue = false)
-  @interface NestedWrappedKey {
-    Class<?> value();
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/NonComponentDependencyComponent.java b/compiler/src/it/functional-tests/src/main/java/test/NonComponentDependencyComponent.java
deleted file mode 100644
index f9f68ced5..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/NonComponentDependencyComponent.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
-* Copyright (C) 2015 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package test;
-
-import dagger.Component;
-import javax.inject.Inject;
-import test.sub.OtherThing;
-
-@Component(dependencies = {NonComponentDependencyComponent.ThingComponent.class})
-interface NonComponentDependencyComponent {
-  ThingTwo thingTwo();
-
-  static class ThingTwo {
-    @SuppressWarnings("unused")
-    @Inject
-    ThingTwo(
-        Thing thing,
-        NonComponentDependencyComponent nonComponentDependencyComponent,
-        NonComponentDependencyComponent.ThingComponent thingComponent) {}
-  }
-
-  // A non-component interface which this interface depends upon.
-  interface ThingComponent {
-    Thing thing();
-  }
-
-  // The implementation for that interface.
-  static class ThingComponentImpl implements ThingComponent {
-    @Override
-    public Thing thing() {
-      return new Thing(new OtherThing(1));
-    }
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/NullableModule.java b/compiler/src/it/functional-tests/src/main/java/test/NullableModule.java
deleted file mode 100644
index f1545e47c..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/NullableModule.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import dagger.Module;
-import dagger.Provides;
-
-@Module
-final class NullableModule {
-  /**
-   * A {@code Nullable} that isn't {@link javax.annotation.Nullable}, to ensure that Dagger can be
-   * built without depending on JSR-305.
-   */
-  @interface Nullable {}
-
-  @Provides
-  @Nullable
-  static Object nullObject() {
-    return null;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/NumberClassKey.java b/compiler/src/it/functional-tests/src/main/java/test/NumberClassKey.java
deleted file mode 100644
index 3980260ed..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/NumberClassKey.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
-* Copyright (C) 2015 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package test;
-
-import dagger.MapKey;
-
-@MapKey(unwrapValue = true)
-@interface NumberClassKey {
-  Class<? extends Number> value();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/OuterClassBar.java b/compiler/src/it/functional-tests/src/main/java/test/OuterClassBar.java
deleted file mode 100644
index 80106e7af..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/OuterClassBar.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import dagger.Component;
-
-final class OuterClassBar {
-  @Component(modules = PrimitivesModule.class)
-  interface NestedComponent {
-    InjectedThing injectedThing();
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/OuterClassFoo.java b/compiler/src/it/functional-tests/src/main/java/test/OuterClassFoo.java
deleted file mode 100644
index 73c68c2aa..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/OuterClassFoo.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import dagger.Component;
-
-final class OuterClassFoo {
-  @Component(modules = PrimitivesModule.class)
-  interface NestedComponent {
-    Thing thing();
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java b/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java
deleted file mode 100644
index 4d0f56266..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/ParentModule.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package test;
-
-import dagger.Module;
-import dagger.Provides;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Set;
-
-@Module
-abstract class ParentModule<A extends Number & Comparable<A>, B, C extends Iterable<A>> {
-  @Provides Iterable<A> provideIterableOfAWithC(A a, C c) {
-    List<A> list = new ArrayList<>();
-    list.add(a);
-    for (A elt : c) {
-      list.add(elt);
-    }
-    return list;
-  }
-
-  @Provides static char provideNonGenericBindingInParameterizedModule() {
-    return 'c';
-  }
-
-  @Provides
-  static List<Set<String>> provideStaticGenericTypeWithNoTypeParametersInParameterizedModule() {
-    return new ArrayList<>();
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/PrimitivesModule.java b/compiler/src/it/functional-tests/src/main/java/test/PrimitivesModule.java
deleted file mode 100644
index acbf271df..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/PrimitivesModule.java
+++ /dev/null
@@ -1,93 +0,0 @@
-package test;
-
-import dagger.Module;
-import dagger.Provides;
-
-@Module
-final class PrimitivesModule {
-  static final byte BOUND_BYTE = -41;
-  static final char BOUND_CHAR = 'g';
-  static final short BOUND_SHORT = 21840;
-  static final int BOUND_INT = 1894833693;
-  static final long BOUND_LONG = -4369839828653523584L;
-  static final boolean BOUND_BOOLEAN = true;
-  static final float BOUND_FLOAT = (float) 0.9964542;
-  static final double BOUND_DOUBLE = 0.12681322049667765;
-
-  /*
-   * While we can't ensure that these constants stay constant, this is a test so we're just going to
-   * keep our fingers crossed that we're not going to be jerks.
-   */
-  static final byte[] BOUND_BYTE_ARRAY =  {1, 2, 3};
-  static final char[] BOUND_CHAR_ARRAY = {'g', 'a', 'k'};
-  static final short[] BOUND_SHORT_ARRAY = {2, 4};
-  static final int[] BOUND_INT_ARRAY = {3, 1, 2};
-  static final long[] BOUND_LONG_ARRAY = {1, 1, 2, 3, 5};
-  static final boolean[] BOUND_BOOLEAN_ARRAY = {false, true, false, false};
-  static final float[] BOUND_FLOAT_ARRAY = {(float) 0.1, (float) 0.01, (float) 0.001};
-  static final double[] BOUND_DOUBLE_ARRAY = {0.2, 0.02, 0.002};
-
-  @Provides static byte provideByte() {
-    return BOUND_BYTE;
-  }
-
-  @Provides static char provideChar() {
-    return BOUND_CHAR;
-  }
-
-  @Provides static short provideShort() {
-    return BOUND_SHORT;
-  }
-
-  @Provides static int provideInt() {
-    return BOUND_INT;
-  }
-
-  @Provides static long provideLong() {
-    return BOUND_LONG;
-  }
-
-  @Provides static boolean provideBoolean() {
-    return BOUND_BOOLEAN;
-  }
-
-  @Provides static float provideFloat() {
-    return BOUND_FLOAT;
-  }
-
-  @Provides static double boundDouble() {
-    return BOUND_DOUBLE;
-  }
-
-  @Provides static byte[] provideByteArray() {
-    return BOUND_BYTE_ARRAY;
-  }
-
-  @Provides static char[] provideCharArray() {
-    return BOUND_CHAR_ARRAY;
-  }
-
-  @Provides static short[] provideShortArray() {
-    return BOUND_SHORT_ARRAY;
-  }
-
-  @Provides static int[] provideIntArray() {
-    return BOUND_INT_ARRAY;
-  }
-
-  @Provides static long[] provideLongArray() {
-    return BOUND_LONG_ARRAY;
-  }
-
-  @Provides static boolean[] provideBooleanArray() {
-    return BOUND_BOOLEAN_ARRAY;
-  }
-
-  @Provides static float[] provideFloatArray() {
-    return BOUND_FLOAT_ARRAY;
-  }
-
-  @Provides static double[] boundDoubleArray() {
-    return BOUND_DOUBLE_ARRAY;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ReferencesGeneric.java b/compiler/src/it/functional-tests/src/main/java/test/ReferencesGeneric.java
deleted file mode 100644
index 453bdfb7e..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/ReferencesGeneric.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import javax.inject.Inject;
-
-class ReferencesGeneric {
-  final Generic<A> genericA;
-  
-  @Inject ReferencesGeneric(Generic<A> genericA) {
-    this.genericA = genericA;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ReleasableReferencesComponents.java b/compiler/src/it/functional-tests/src/main/java/test/ReleasableReferencesComponents.java
deleted file mode 100644
index 84b1bb1e4..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/ReleasableReferencesComponents.java
+++ /dev/null
@@ -1,227 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-import static test.ReleasableReferencesComponents.Thing.thing;
-
-import dagger.Component;
-import dagger.Module;
-import dagger.Provides;
-import dagger.Subcomponent;
-import dagger.multibindings.ClassKey;
-import dagger.multibindings.IntoMap;
-import dagger.releasablereferences.CanReleaseReferences;
-import dagger.releasablereferences.ForReleasableReferences;
-import dagger.releasablereferences.ReleasableReferenceManager;
-import dagger.releasablereferences.TypedReleasableReferenceManager;
-import java.lang.annotation.Retention;
-import java.util.Map;
-import java.util.Set;
-import javax.inject.Scope;
-
-final class ReleasableReferencesComponents {
-
-  interface ThingComponent {
-    /**
-     * A map whose keys are the scope annotations for each value. For unscoped values, the key is
-     * the module that contains the unscoped binding. So for {@link Parent}, the unscoped {@link
-     * Thing}'s key is {@link ParentModule ParentModule.class}; for {@link Child}, it is {@link
-     * ChildModule ChildModule.class}.
-     */
-    Map<Class<?>, Thing> things();
-  }
-
-  @ParentRegularScope
-  @ParentReleasableScope1
-  @ParentReleasableScope2
-  @Component(modules = ParentModule.class)
-  interface Parent extends ThingComponent {
-
-    Set<ReleasableReferenceManager> managers();
-
-    Set<TypedReleasableReferenceManager<Metadata1>> typedReleasableReferenceManagers1();
-
-    Set<TypedReleasableReferenceManager<Metadata2>> typedReleasableReferenceManagers2();
-
-    @ForReleasableReferences(ParentReleasableScope1.class)
-    ReleasableReferenceManager parentReleasableScope1Manager();
-
-    @ForReleasableReferences(ParentReleasableScope2.class)
-    ReleasableReferenceManager parentReleasableScope2Manager();
-
-    @ForReleasableReferences(ParentReleasableScope2.class)
-    TypedReleasableReferenceManager<Metadata1> parentReleasableScope2TypedReferenceManager();
-
-    @ForReleasableReferences(ChildReleasableScope1.class)
-    ReleasableReferenceManager childReleasableScope1Manager();
-
-    @ForReleasableReferences(ChildReleasableScope2.class)
-    ReleasableReferenceManager childReleasableScope2Manager();
-
-    @ForReleasableReferences(ChildReleasableScope2.class)
-    TypedReleasableReferenceManager<Metadata1> childReleasableScope2TypedReferenceManager1();
-
-    @ForReleasableReferences(ChildReleasableScope2.class)
-    TypedReleasableReferenceManager<Metadata2> childReleasableScope2TypedReferenceManager2();
-
-    Child child();
-  }
-
-  // TODO(ronshapiro): investigate the maven-compiler-plugin bug that is blocking javac from
-  // recognizing @AutoValue when it is imported instead of fully-qualified
-  // http://bugs.java.com/view_bug.do?bug_id=7101822
-  @com.google.auto.value.AutoValue
-  abstract static class Thing {
-    abstract int count();
-
-    static Thing thing(int count) {
-      return new AutoValue_ReleasableReferencesComponents_Thing(count);
-    }
-  }
-
-  @ChildRegularScope
-  @ChildReleasableScope1
-  @ChildReleasableScope2
-  @ChildReleasableScope3
-  @Subcomponent(modules = ChildModule.class)
-  interface Child extends ThingComponent {}
-
-  @CanReleaseReferences
-  @interface Metadata1 {
-    String value();
-  }
-
-  @CanReleaseReferences
-  @interface Metadata2 {
-    String value();
-  }
-
-  @Retention(RUNTIME)
-  @Scope
-  @interface ParentRegularScope {}
-
-  @Retention(RUNTIME)
-  @Scope
-  @interface ChildRegularScope {}
-
-  @Retention(RUNTIME)
-  @CanReleaseReferences
-  @Scope
-  @interface ParentReleasableScope1 {}
-
-  @Retention(RUNTIME)
-  @Metadata1("ParentReleasableScope2")
-  @Scope
-  @interface ParentReleasableScope2 {}
-
-  @Retention(RUNTIME)
-  @Metadata2("ChildReleasableScope1")
-  @Scope
-  @interface ChildReleasableScope1 {}
-
-  @Retention(RUNTIME)
-  @Metadata1("ChildReleasableScope2.1")
-  @Metadata2("ChildReleasableScope2.2")
-  @Scope
-  @interface ChildReleasableScope2 {}
-
-  @Retention(RUNTIME)
-  @Metadata1("ChildReleasableScope3.1")
-  @Metadata2("ChildReleasableScope3.2")
-  @CanReleaseReferences
-  @Scope
-  @interface ChildReleasableScope3 {}
-
-  @Module
-  static final class ParentModule {
-    private int unscopedCount;
-    private int regularScopeCount;
-    private int releasableScope1Count;
-    private int releasableScope2Count;
-
-    @Provides
-    @IntoMap
-    @ClassKey(ParentModule.class)
-    Thing parentUnscopedThing() {
-      return thing(++unscopedCount);
-    }
-
-    @Provides
-    @IntoMap
-    @ClassKey(ParentRegularScope.class)
-    @ParentRegularScope
-    Thing regularScopedThing() {
-      return thing(++regularScopeCount);
-    }
-
-    @Provides
-    @IntoMap
-    @ClassKey(ParentReleasableScope1.class)
-    @ParentReleasableScope1
-    Thing releasableScope1Thing() {
-      return thing(++releasableScope1Count);
-    }
-
-    @Provides
-    @IntoMap
-    @ClassKey(ParentReleasableScope2.class)
-    @ParentReleasableScope2
-    Thing releasableScope2Thing() {
-      return thing(++releasableScope2Count);
-    }
-  }
-
-  @Module
-  static final class ChildModule {
-    private int unscopedCount;
-    private int regularScopeCount;
-    private int releasableScope1Count;
-    private int releasableScope2Count;
-
-    @Provides
-    @IntoMap
-    @ClassKey(ChildModule.class)
-    Thing childUnscopedThing() {
-      return thing(++unscopedCount);
-    }
-
-    @Provides
-    @IntoMap
-    @ClassKey(ChildRegularScope.class)
-    @ChildRegularScope
-    Thing regularScopedThing() {
-      return thing(++regularScopeCount);
-    }
-
-    @Provides
-    @IntoMap
-    @ClassKey(ChildReleasableScope1.class)
-    @ChildReleasableScope1
-    Thing releasableScope1Thing() {
-      return thing(++releasableScope1Count);
-    }
-
-    @Provides
-    @IntoMap
-    @ClassKey(ChildReleasableScope2.class)
-    @ChildReleasableScope2
-    Thing releasableScope2Thing() {
-      return thing(++releasableScope2Count);
-    }
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ScopedGeneric.java b/compiler/src/it/functional-tests/src/main/java/test/ScopedGeneric.java
deleted file mode 100644
index 37d68e01e..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/ScopedGeneric.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package test;
-
-import javax.inject.Inject;
-import javax.inject.Singleton;
-
-@Singleton
-class ScopedGeneric<T> { 
-  final T t;  
-  @Inject ScopedGeneric(T t) {
-    this.t = t;
-  }  
-}
\ No newline at end of file
diff --git a/compiler/src/it/functional-tests/src/main/java/test/ShortKey.java b/compiler/src/it/functional-tests/src/main/java/test/ShortKey.java
deleted file mode 100644
index 9cb8f3e86..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/ShortKey.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
-* Copyright (C) 2015 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package test;
-
-import dagger.MapKey;
-
-@MapKey(unwrapValue = true)
-@interface ShortKey {
-  short value();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/SingletonGenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/SingletonGenericComponent.java
deleted file mode 100644
index 44a2cb553..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/SingletonGenericComponent.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package test;
-
-import dagger.Component;
-import javax.inject.Singleton;
-
-@Singleton
-@Component
-interface SingletonGenericComponent {
-  
-  ScopedGeneric<A> scopedGenericA();
-  ScopedGeneric<B> scopedGenericB();
-
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/SomeQualifier.java b/compiler/src/it/functional-tests/src/main/java/test/SomeQualifier.java
deleted file mode 100644
index 9ead648b3..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/SomeQualifier.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import java.lang.annotation.Documented;
-import java.lang.annotation.Retention;
-import javax.inject.Qualifier;
-
-@Documented
-@Retention(RUNTIME)
-@Qualifier
-public @interface SomeQualifier {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/Thing.java b/compiler/src/it/functional-tests/src/main/java/test/Thing.java
deleted file mode 100644
index 2099eba6c..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/Thing.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
-* Copyright (C) 2014 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package test;
-
-import javax.inject.Inject;
-import test.sub.OtherThing;
-
-final class Thing {
-  @Inject Thing(@SuppressWarnings("unused") OtherThing unused) {}
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/TypeWithInheritedMembersInjection.java b/compiler/src/it/functional-tests/src/main/java/test/TypeWithInheritedMembersInjection.java
deleted file mode 100644
index 8bb6fcac4..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/TypeWithInheritedMembersInjection.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import javax.inject.Inject;
-
-final class TypeWithInheritedMembersInjection extends AbstractMiddleClassWithoutMembers {
-  @Inject TypeWithInheritedMembersInjection() {}
-}
-
diff --git a/compiler/src/it/functional-tests/src/main/java/test/UnwrappedAnnotationKey.java b/compiler/src/it/functional-tests/src/main/java/test/UnwrappedAnnotationKey.java
deleted file mode 100644
index 96d2cb289..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/UnwrappedAnnotationKey.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
-* Copyright (C) 2015 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package test;
-
-import dagger.MapKey;
-import dagger.multibindings.StringKey;
-
-@MapKey(unwrapValue = true)
-@interface UnwrappedAnnotationKey {
-  StringKey value();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/WrappedAnnotationKey.java b/compiler/src/it/functional-tests/src/main/java/test/WrappedAnnotationKey.java
deleted file mode 100644
index 50306d032..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/WrappedAnnotationKey.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
-* Copyright (C) 2015 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package test;
-
-import dagger.MapKey;
-import dagger.multibindings.ClassKey;
-import dagger.multibindings.StringKey;
-
-@MapKey(unwrapValue = false)
-@interface WrappedAnnotationKey {
-  StringKey value();
-  int[] integers();
-  ClassKey[] annotations();
-  Class<? extends Number>[] classes();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/binds/Foo.java b/compiler/src/it/functional-tests/src/main/java/test/binds/Foo.java
deleted file mode 100644
index 6835ebbba..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/binds/Foo.java
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.binds;
-
-/**
- * This is the type that will be bound.  We throw in generics just to complicate the test.
- */
-interface Foo<T> {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/binds/FooOfObjects.java b/compiler/src/it/functional-tests/src/main/java/test/binds/FooOfObjects.java
deleted file mode 100644
index bd3950c7b..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/binds/FooOfObjects.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.binds;
-
-import javax.inject.Inject;
-
-final class FooOfObjects implements Foo<Object> {
-  @Inject FooOfObjects() {}
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/binds/FooOfStrings.java b/compiler/src/it/functional-tests/src/main/java/test/binds/FooOfStrings.java
deleted file mode 100644
index 0243e3a18..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/binds/FooOfStrings.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.binds;
-
-import javax.inject.Inject;
-
-final class FooOfStrings implements Foo<String> {
-  @Inject
-  FooOfStrings() {}
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/binds/InterfaceModule.java b/compiler/src/it/functional-tests/src/main/java/test/binds/InterfaceModule.java
deleted file mode 100644
index 732c040c5..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/binds/InterfaceModule.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.binds;
-
-import dagger.Binds;
-import dagger.Module;
-
-@Module
-interface InterfaceModule {
-  @Binds Foo<Object> bindFooOfObjects(FooOfObjects impl);
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/binds/SimpleBindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/binds/SimpleBindingModule.java
deleted file mode 100644
index 34c460763..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/binds/SimpleBindingModule.java
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.binds;
-
-import dagger.Binds;
-import dagger.Module;
-import dagger.Provides;
-import dagger.Reusable;
-import dagger.multibindings.ElementsIntoSet;
-import dagger.multibindings.IntKey;
-import dagger.multibindings.IntoMap;
-import dagger.multibindings.IntoSet;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Set;
-import java.util.TreeSet;
-import javax.inject.Named;
-import javax.inject.Singleton;
-import test.SomeQualifier;
-
-@Module(includes = InterfaceModule.class)
-abstract class SimpleBindingModule {
-  @Binds
-  abstract Object bindObject(FooOfStrings impl);
-
-  @Binds
-  @Reusable
-  @SomeQualifier
-  abstract Object bindReusableObject(FooOfStrings impl);
-
-  @Binds
-  abstract Foo<String> bindFooOfStrings(FooOfStrings impl);
-
-  @Binds
-  abstract Foo<? extends Number> bindFooOfNumbers(Foo<Integer> fooOfIntegers);
-
-  @Binds
-  @Singleton
-  @SomeQualifier
-  abstract Foo<String> bindQualifiedFooOfStrings(FooOfStrings impl);
-
-  @Provides
-  static Foo<Integer> provideFooOfIntegers() {
-    return new Foo<Integer>() {};
-  }
-
-  @Provides
-  static Foo<Double> provideFooOfDoubles() {
-    return new Foo<Double>() {};
-  }
-
-  @Binds
-  @IntoSet
-  abstract Foo<? extends Number> bindFooOfIntegersIntoSet(Foo<Integer> fooOfIntegers);
-
-  @Binds
-  @IntoSet
-  abstract Foo<? extends Number> bindFooExtendsNumberIntoSet(Foo<Double> fooOfDoubles);
-
-  @Binds
-  @ElementsIntoSet
-  abstract Set<Object> bindSetOfFooNumbersToObjects(Set<Foo<? extends Number>> setOfFooNumbers);
-
-  @Binds
-  @IntoSet
-  abstract Object bindFooOfStringsIntoSetOfObjects(FooOfStrings impl);
-
-  @Provides
-  static HashSet<String> provideStringHashSet() {
-    return new HashSet<>(Arrays.asList("hash-string1", "hash-string2"));
-  }
-
-  @Provides
-  static TreeSet<CharSequence> provideCharSequenceTreeSet() {
-    return new TreeSet<CharSequence>(Arrays.asList("tree-charSequence1", "tree-charSequence2"));
-  }
-
-  @Provides
-  static Collection<CharSequence> provideCharSequenceCollection() {
-    return Arrays.<CharSequence>asList("list-charSequence");
-  }
-
-  @Binds
-  @ElementsIntoSet
-  abstract Set<CharSequence> bindHashSetOfStrings(HashSet<String> set);
-
-  @Binds
-  @ElementsIntoSet
-  abstract Set<CharSequence> bindTreeSetOfCharSequences(TreeSet<CharSequence> set);
-
-  @Binds
-  @ElementsIntoSet
-  abstract Set<CharSequence> bindCollectionOfCharSequences(Collection<CharSequence> collection);
-
-  @Binds
-  @IntoMap
-  @IntKey(123)
-  abstract Object bind123ForMap(@Named("For-123") String string);
-
-  @Binds
-  @IntoMap
-  @IntKey(456)
-  abstract Object bind456ForMap(@Named("For-456") String string);
-
-  @Provides
-  @IntoMap
-  @IntKey(789)
-  static Object provide789ForMap() {
-    return "789-string";
-  }
-
-  @Binds
-  @IntoMap
-  @IntKey(123)
-  @SomeQualifier
-  abstract Object bindFooOfStringsIntoQualifiedMap(FooOfStrings fooOfStrings);
-  
-  @Provides
-  @Named("For-123")
-  static String provide123String() {
-    return "123-string";
-  }
-
-  @Provides
-  @Named("For-456")
-  static String provide456String() {
-    return "456-string";
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/binds/TestComponent.java b/compiler/src/it/functional-tests/src/main/java/test/binds/TestComponent.java
deleted file mode 100644
index bada4b164..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/binds/TestComponent.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.binds;
-
-import dagger.Component;
-import java.util.Map;
-import java.util.Set;
-import javax.inject.Provider;
-import javax.inject.Singleton;
-import test.SomeQualifier;
-
-@Singleton
-@Component(modules = SimpleBindingModule.class)
-public interface TestComponent {
-  Object object();
-
-  @SomeQualifier
-  Object reusableObject();
-
-  Foo<String> fooOfStrings();
-
-  Foo<Object> fooOfObjects();
-
-  @SomeQualifier
-  Foo<String> qualifiedFooOfStrings();
-
-  Foo<Integer> fooOfIntegers();
-
-  Set<Foo<? extends Number>> foosOfNumbers();
-
-  Set<Object> objects();
-
-  Set<CharSequence> charSequences();
-
-  Map<Integer, Object> integerObjectMap();
-
-  Map<Integer, Provider<Object>> integerProviderOfObjectMap();
-
-  @SomeQualifier Map<Integer, Object> qualifiedIntegerObjectMap();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/ByteModule.java b/compiler/src/it/functional-tests/src/main/java/test/builder/ByteModule.java
deleted file mode 100644
index feafdd0d6..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/ByteModule.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.builder;
-
-import dagger.Module;
-import dagger.Provides;
-
-@Module
-class ByteModule {
-  final byte b;
-
-  ByteModule(byte b) {
-    this.b = b;
-  }
-  
-  @Provides byte b() { return b; }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/DepComponent.java b/compiler/src/it/functional-tests/src/main/java/test/builder/DepComponent.java
deleted file mode 100644
index 1d18341f4..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/DepComponent.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.builder;
-
-import dagger.Component;
-
-@Component
-interface DepComponent {
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/DoubleModule.java b/compiler/src/it/functional-tests/src/main/java/test/builder/DoubleModule.java
deleted file mode 100644
index 8cf226bef..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/DoubleModule.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.builder;
-
-import dagger.Module;
-import dagger.Provides;
-
-@Module
-class DoubleModule {
-  @Provides
-  double d() {
-    return 4.2d;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/FloatModule.java b/compiler/src/it/functional-tests/src/main/java/test/builder/FloatModule.java
deleted file mode 100644
index 0d3af1d31..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/FloatModule.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.builder;
-
-import dagger.Module;
-import dagger.Provides;
-
-@Module
-class FloatModule {  
-  @Provides
-  float f() {
-    return 5.5f;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/GenericParent.java b/compiler/src/it/functional-tests/src/main/java/test/builder/GenericParent.java
deleted file mode 100644
index beffe27a6..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/GenericParent.java
+++ /dev/null
@@ -1,21 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.builder;
-
-interface GenericParent<B> {  
-  B subcomponentBuilder();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/Grandchild.java b/compiler/src/it/functional-tests/src/main/java/test/builder/Grandchild.java
deleted file mode 100644
index 759b470df..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/Grandchild.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.builder;
-
-import dagger.Subcomponent;
-
-@Subcomponent(modules = IntModuleIncludingDoubleAndFloat.class)
-interface Grandchild {
-  int i();
-  String s();
-
-  @Subcomponent.Builder
-  interface Builder {
-    Grandchild build();
-    Builder set(IntModuleIncludingDoubleAndFloat intModule);
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/IntModuleIncludingDoubleAndFloat.java b/compiler/src/it/functional-tests/src/main/java/test/builder/IntModuleIncludingDoubleAndFloat.java
deleted file mode 100644
index 69c12259d..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/IntModuleIncludingDoubleAndFloat.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.builder;
-
-import dagger.Module;
-import dagger.Provides;
-
-@Module(includes = { DoubleModule.class, FloatModule.class })
-class IntModuleIncludingDoubleAndFloat {
-  final int integer;
-
-  IntModuleIncludingDoubleAndFloat(int integer) {
-    this.integer = integer;
-  }
-  
-  @Provides
-  int integer() {
-    return integer;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/LongModule.java b/compiler/src/it/functional-tests/src/main/java/test/builder/LongModule.java
deleted file mode 100644
index cb848a707..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/LongModule.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.builder;
-
-import dagger.Module;
-import dagger.Provides;
-
-@Module
-class LongModule {  
-  @Provides
-  long l() {
-    return 6L;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java b/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java
deleted file mode 100644
index b606b7986..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleChild.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.builder;
-
-import dagger.Subcomponent;
-
-@MiddleScope
-@Subcomponent(modules = StringModule.class)
-interface MiddleChild {
-  String s();
-  
-  Grandchild.Builder grandchildBuilder();
-  
-  RequiresSubcomponentBuilder<Grandchild.Builder> requiresGrandchildBuilder();
-  
-  @Subcomponent.Builder
-  interface Builder {
-    MiddleChild build();
-    Builder set(StringModule stringModule);
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleScope.java b/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleScope.java
deleted file mode 100644
index 8f0c8bb67..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/MiddleScope.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.builder;
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import java.lang.annotation.Retention;
-import javax.inject.Scope;
-
-@Scope
-@Retention(RUNTIME)
-@interface MiddleScope {
-
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/OtherMiddleChild.java b/compiler/src/it/functional-tests/src/main/java/test/builder/OtherMiddleChild.java
deleted file mode 100644
index a5871c6e8..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/OtherMiddleChild.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.builder;
-
-import dagger.Subcomponent;
-
-@MiddleScope
-@Subcomponent(modules = {StringModule.class, LongModule.class})
-interface OtherMiddleChild {
-  long l();
-  String s();
-  
-  Grandchild.Builder grandchildBuilder();
-  
-  @Subcomponent.Builder
-  interface Builder {
-    OtherMiddleChild build();
-    Builder set(StringModule stringModule);
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java
deleted file mode 100644
index a9b8fc723..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/ParentComponent.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.builder;
-
-import dagger.Component;
-import javax.inject.Singleton;
-
-@Singleton
-@Component
-interface ParentComponent {  
-  TestChildComponentWithBuilderAbstractClass.Builder childAbstractClassBuilder();
-  TestChildComponentWithBuilderInterface.Builder childInterfaceBuilder();
-  
-  MiddleChild.Builder middleBuilder();
-  OtherMiddleChild.Builder otherBuilder();
-  
-  RequiresSubcomponentBuilder<MiddleChild.Builder> requiresMiddleChildBuilder();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/ParentOfGenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/builder/ParentOfGenericComponent.java
deleted file mode 100644
index ad0c49193..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/ParentOfGenericComponent.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.builder;
-
-import dagger.Component;
-import javax.inject.Singleton;
-
-@Component(modules = StringModule.class)
-@Singleton
-interface ParentOfGenericComponent extends GenericParent<Grandchild.Builder> {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/RequiresSubcomponentBuilder.java b/compiler/src/it/functional-tests/src/main/java/test/builder/RequiresSubcomponentBuilder.java
deleted file mode 100644
index 23bbaa904..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/RequiresSubcomponentBuilder.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.builder;
-
-import javax.inject.Inject;
-import javax.inject.Provider;
-
-class RequiresSubcomponentBuilder<B> {
-  private final Provider<B> subcomponentBuilderProvider;
-  private final B subcomponentBuilder;
-
-  @Inject
-  RequiresSubcomponentBuilder(Provider<B> subcomponentBuilderProvider, B subcomponentBuilder) {
-    this.subcomponentBuilderProvider = subcomponentBuilderProvider;
-    this.subcomponentBuilder = subcomponentBuilder;
-  }
-
-  Provider<B> subcomponentBuilderProvider() {
-    return subcomponentBuilderProvider;
-  }
-  
-  B subcomponentBuilder() {
-    return subcomponentBuilder;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/StringModule.java b/compiler/src/it/functional-tests/src/main/java/test/builder/StringModule.java
deleted file mode 100644
index c1fb723fb..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/StringModule.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.builder;
-
-import dagger.Module;
-import dagger.Provides;
-
-@Module
-class StringModule {
-  final String string;
-
-  StringModule(String string) {
-    this.string = string;
-  }
-  
-  @Provides
-  String string() {
-    return string;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderAbstractClass.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderAbstractClass.java
deleted file mode 100644
index 21d1ddd59..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderAbstractClass.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.builder;
-
-import dagger.Subcomponent;
-
-@Subcomponent(modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class,
-    LongModule.class, ByteModule.class})
-interface TestChildComponentWithBuilderAbstractClass {
-  String s();
-  int i();
-  long l();
-  float f();
-  double d();
-  byte b();
- 
-  abstract class SharedBuilder<B, C, M1, M2> {
-    abstract C build(); // Test resolving return type of build()
-    abstract B setM1(M1 m1); // Test resolving return type & param of setter
-    abstract SharedBuilder<B, C, M1, M2> setM2(M2 m2); // Test being overridden
-    abstract void setM3(DoubleModule doubleModule);  // Test being overridden
-    abstract SharedBuilder<B, C, M1, M2> set(FloatModule floatModule); // Test returning supertype.
-  }
-  
-  @Subcomponent.Builder
-  abstract class Builder extends SharedBuilder<Builder, TestChildComponentWithBuilderAbstractClass,
-      StringModule, IntModuleIncludingDoubleAndFloat> {
-    @Override abstract Builder setM2(IntModuleIncludingDoubleAndFloat m2); // Test covariance
-    @Override abstract void setM3(DoubleModule doubleModule); // Test simple overrides allowed    
-    abstract void set(ByteModule byteModule);
-    
-    // Note we're missing LongModule -- it's implicit
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderInterface.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderInterface.java
deleted file mode 100644
index 59e39e543..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/TestChildComponentWithBuilderInterface.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.builder;
-
-import dagger.Subcomponent;
-
-@Subcomponent(modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class,
-    LongModule.class, ByteModule.class})
-interface TestChildComponentWithBuilderInterface {
-  String s();
-  int i();
-  long l();
-  float f();
-  double d();
-  byte b();
-  
-  interface SharedBuilder<B, C, M1, M2> {
-    C build(); // Test resolving return type of build()
-    B setM1(M1 m1); // Test resolving return type & param of setter
-    SharedBuilder<B, C, M1, M2> setM2(M2 m2); // Test being overridden
-    void setM3(DoubleModule doubleModule);  // Test being overridden
-    SharedBuilder<B, C, M1, M2> set(FloatModule floatModule); // Test return type is supertype.
-  }
-  
-  @Subcomponent.Builder
-  interface Builder extends SharedBuilder<Builder, TestChildComponentWithBuilderInterface,
-      StringModule, IntModuleIncludingDoubleAndFloat> {
-    @Override Builder setM2(IntModuleIncludingDoubleAndFloat m2); // Test covariant overrides
-    @Override void setM3(DoubleModule doubleModule); // Test simple overrides allowed    
-    void set(ByteModule byteModule);
-    
-    // Note we're missing LongModule -- it's implicit
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderAbstractClass.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderAbstractClass.java
deleted file mode 100644
index da966cc6d..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderAbstractClass.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.builder;
-
-import dagger.Component;
-
-@Component(
-    modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class, LongModule.class},
-    dependencies = DepComponent.class)
-abstract class TestComponentWithBuilderAbstractClass {
-  
-  static Builder builder() {
-    return DaggerTestComponentWithBuilderAbstractClass.builder();
-  }
-  
-  abstract String s();
-  abstract int i();
-  abstract long l();
-  abstract float f();
-  abstract double d();
-  
-
-  static abstract class SharedBuilder {
-    // Make sure we use the overriding signature.
-    abstract Object build();
-    
-    Object stringModule(@SuppressWarnings("unused") StringModule stringModule) {
-      return null;
-    } 
-
-    SharedBuilder ignoredLongModule(@SuppressWarnings("unused") LongModule longModule) {
-      return null;
-    }
-    
-  }
-  
-  @Component.Builder
-  static abstract class Builder extends SharedBuilder {
-    @Override abstract TestComponentWithBuilderAbstractClass build(); // Narrowing return type
-    @Override abstract Builder stringModule(StringModule stringModule); // Make abstract & narrow
-    abstract Builder intModule(IntModuleIncludingDoubleAndFloat intModule);
-    abstract void doubleModule(DoubleModule doubleModule); // Module w/o args
-    abstract void depComponent(DepComponent depComponent);
-
-    Builder ignoredIntModule(
-        @SuppressWarnings("unused") IntModuleIncludingDoubleAndFloat intModule) {
-      return null;
-    }    
-    
-    // Note we're missing LongModule & FloatModule -- they/re implicit
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderInterface.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderInterface.java
deleted file mode 100644
index 6cd556199..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithBuilderInterface.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.builder;
-
-import dagger.Component;
-
-@Component(
-    modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class, LongModule.class},
-    dependencies = DepComponent.class)
-interface TestComponentWithBuilderInterface {
-  String s();
-  int i();
-  long l();
-  float f();
-  double d();
-  
-  interface SharedBuilder {
-    // Make sure we use the overriding signature.
-    Object build();
-    Object stringModule(StringModule m1); 
-  }
-  
-  @Component.Builder
-  interface Builder extends SharedBuilder {
-    @Override TestComponentWithBuilderInterface build(); // Narrowing return type
-    @Override Builder stringModule(StringModule stringModule); // Narrowing return type
-    Builder intModule(IntModuleIncludingDoubleAndFloat intModule);
-    void doubleModule(DoubleModule doubleModule); // Module w/o args
-    void depComponent(DepComponent depComponent);
-    
-    // Note we're missing LongModule & FloatModule -- they/re implicit
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderAbstractClass.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderAbstractClass.java
deleted file mode 100644
index d7603e9c8..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderAbstractClass.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.builder;
-
-import dagger.Component;
-
-@Component(
-    modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class, LongModule.class},
-    dependencies = DepComponent.class)
-interface TestComponentWithGenericBuilderAbstractClass {
-  String s();
-  int i();
-  long l();
-  float f();
-  double d();
-  
-  static abstract class SharedBuilder<B, C, M1, M2> {
-    abstract C build(); // Test resolving return type of build()
-    abstract B setM1(M1 m1); // Test resolving return type & param of setter
-    abstract SharedBuilder<B, C, M1, M2> setM2(M2 m2); // Test being overridden
-    abstract void doubleModule(DoubleModule doubleModule);  // Test being overridden
-    abstract SharedBuilder<B, C, M1, M2> depComponent(FloatModule floatModule); // Test return type
-  }
-  
-  @Component.Builder
-  static abstract class Builder extends SharedBuilder<Builder,
-      TestComponentWithGenericBuilderAbstractClass, StringModule,
-      IntModuleIncludingDoubleAndFloat> {
-    @Override abstract Builder setM2(IntModuleIncludingDoubleAndFloat m2); // Test covariant overrides
-    @Override abstract void doubleModule(DoubleModule module3); // Test simple overrides allowed    
-    abstract void depComponent(DepComponent depComponent);
-    
-    // Note we're missing LongModule & FloatModule -- they're implicit
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderInterface.java b/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderInterface.java
deleted file mode 100644
index 5e8ca2400..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/builder/TestComponentWithGenericBuilderInterface.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.builder;
-
-import dagger.Component;
-
-@Component(
-    modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class, LongModule.class},
-    dependencies = DepComponent.class)
-interface TestComponentWithGenericBuilderInterface {
-  String s();
-  int i();
-  long l();
-  float f();
-  double d();
-  
-  interface SharedBuilder<B, C, M1, M2> {
-    C build(); // Test resolving return type of build()
-    B setM1(M1 m1); // Test resolving return type & param of setter
-    SharedBuilder<B, C, M1, M2> setM2(M2 m2); // Test being overridden
-    void doubleModule(DoubleModule doubleModule);  // Test being overridden
-    SharedBuilder<B, C, M1, M2> set(FloatModule floatModule); // Test return type is supertype.
-  }
-  
-  @Component.Builder
-  interface Builder extends SharedBuilder<Builder, TestComponentWithGenericBuilderInterface,
-      StringModule, IntModuleIncludingDoubleAndFloat> {
-    @Override Builder setM2(IntModuleIncludingDoubleAndFloat m2); // Test covariant overrides allowed
-    @Override void doubleModule(DoubleModule module3); // Test simple overrides allowed    
-    void depComponent(DepComponent depComponent);
-    
-    // Note we're missing M5 -- that's implicit.
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builderbinds/BuilderSupertype.java b/compiler/src/it/functional-tests/src/main/java/test/builderbinds/BuilderSupertype.java
deleted file mode 100644
index c965bc224..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/builderbinds/BuilderSupertype.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2017 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.builderbinds;
-
-import dagger.BindsInstance;
-import javax.inject.Named;
-
-interface BuilderSupertype {
-  @BindsInstance
-  void boundInSubtype(@Named("subtype") int subtype);
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builderbinds/Nullable.java b/compiler/src/it/functional-tests/src/main/java/test/builderbinds/Nullable.java
deleted file mode 100644
index 971eb0620..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/builderbinds/Nullable.java
+++ /dev/null
@@ -1,19 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.builderbinds;
-
-@interface Nullable {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/builderbinds/TestComponent.java b/compiler/src/it/functional-tests/src/main/java/test/builderbinds/TestComponent.java
deleted file mode 100644
index 75d470b9a..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/builderbinds/TestComponent.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.builderbinds;
-
-import dagger.BindsInstance;
-import dagger.Component;
-import java.util.List;
-import javax.inject.Named;
-
-@Component
-interface TestComponent {
-  int count();
-
-  long l();
-
-  @Named("input")
-  String input();
-
-  @Nullable
-  @Named("nullable input")
-  String nullableInput();
-
-  List<String> listOfString();
-
-  @Named("subtype")
-  int boundInSubtype();
-
-  @Component.Builder
-  interface Builder extends BuilderSupertype {
-    @BindsInstance
-    Builder count(int count);
-
-    @BindsInstance
-    Builder l(long l);
-
-    @BindsInstance
-    Builder input(@Named("input") String input);
-
-    @BindsInstance
-    Builder nullableInput(@Nullable @Named("nullable input") String nullableInput);
-
-    @BindsInstance
-    Builder listOfString(List<String> listOfString);
-
-    TestComponent build();
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java b/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
deleted file mode 100644
index b78c4e76a..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/cycle/Cycles.java
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.cycle;
-
-import dagger.Binds;
-import dagger.Component;
-import dagger.Lazy;
-import dagger.Module;
-import dagger.Provides;
-import dagger.Subcomponent;
-import dagger.multibindings.IntoMap;
-import dagger.multibindings.StringKey;
-import java.util.Map;
-import javax.inject.Inject;
-import javax.inject.Provider;
-
-/**
- * Cycle classes used for testing cyclic dependencies.
- *
- * <pre>
- * {@literal A  (E  D  B  C  Provider<A>, Lazy<A>), (B  C  Provider<A>, Lazy<A>)}
- * {@literal S  Provider<S>, Lazy<S>}
- * </pre>
- *
- * @author Tony Bentancur
- * @since 2.0
- */
-final class Cycles {
-  private Cycles() {}
-
-  static class A {
-    public final B b;
-    public final E e;
-
-    @Inject
-    A(E e, B b) {
-      this.e = e;
-      this.b = b;
-    }
-  }
-
-  static class B {
-    public final C c;
-
-    @Inject
-    B(C c) {
-      this.c = c;
-    }
-  }
-
-  static class C {
-    public final Provider<A> aProvider;
-    @Inject public Lazy<A> aLazy;
-    @Inject public Provider<Lazy<A>> aLazyProvider;
-
-    @Inject
-    C(Provider<A> aProvider) {
-      this.aProvider = aProvider;
-    }
-  }
-
-  static class D {
-    public final B b;
-
-    @Inject
-    D(B b) {
-      this.b = b;
-    }
-  }
-
-  static class E {
-    public final D d;
-
-    @Inject
-    E(D d) {
-      this.d = d;
-    }
-  }
-
-  static class S {
-    public final Provider<S> sProvider;
-    @Inject public Lazy<S> sLazy;
-
-    @Inject
-    S(Provider<S> sProvider) {
-      this.sProvider = sProvider;
-    }
-  }
-
-  static class X {
-    public final Y y;
-
-    @Inject
-    X(Y y) {
-      this.y = y;
-    }
-  }
-
-  static class Y {
-    public final Map<String, Provider<X>> mapOfProvidersOfX;
-    public final Map<String, Provider<Y>> mapOfProvidersOfY;
-
-    @Inject
-    Y(Map<String, Provider<X>> mapOfProvidersOfX, Map<String, Provider<Y>> mapOfProvidersOfY) {
-      this.mapOfProvidersOfX = mapOfProvidersOfX;
-      this.mapOfProvidersOfY = mapOfProvidersOfY;
-    }
-  }
-
-  @Module
-  abstract static class CycleMapModule {
-    @Binds
-    @IntoMap
-    @StringKey("X")
-    abstract X x(X x);
-
-    @Binds
-    @IntoMap
-    @StringKey("Y")
-    abstract Y y(Y y);
-  }
-
-  @SuppressWarnings("dependency-cycle")
-  @Component(modules = CycleMapModule.class)
-  interface CycleMapComponent {
-    Y y();
-  }
-
-  @SuppressWarnings("dependency-cycle")
-  @Component(modules = CycleModule.class)
-  interface CycleComponent {
-    A a();
-
-    C c();
-
-    ChildCycleComponent child();
-  }
-
-  @Module
-  static class CycleModule {
-    @Provides
-    static Object provideObjectWithCycle(@SuppressWarnings("unused") Provider<Object> object) {
-      return "object";
-    }
-  }
-
-  @SuppressWarnings("dependency-cycle")
-  @Component
-  interface SelfCycleComponent {
-    S s();
-  }
-
-  @Subcomponent
-  interface ChildCycleComponent {
-    @SuppressWarnings("dependency-cycle")
-    A a();
-
-    @SuppressWarnings("dependency-cycle")
-    Object object();
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/cycle/LongCycle.java b/compiler/src/it/functional-tests/src/main/java/test/cycle/LongCycle.java
deleted file mode 100644
index ed1518b35..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/cycle/LongCycle.java
+++ /dev/null
@@ -1,140 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.cycle;
-
-import dagger.Component;
-import javax.inject.Inject;
-import javax.inject.Provider;
-
-/**
- * Component with a long enough cycle such that the initialization of a provider happens in a
- * separate {@code initialize} method from the one where it is used as a delegated factory.
- *
- */
-// Each nested class's constructor has an intentionally unused parameter.
-@SuppressWarnings("unused")
-final class LongCycle {
-  static class Class1 { @Inject Class1(Class2 class2) {} }
-  static class Class2 { @Inject Class2(Class3 class3) {} }
-  static class Class3 { @Inject Class3(Class4 class4) {} }
-  static class Class4 { @Inject Class4(Class5 class5) {} }
-  static class Class5 { @Inject Class5(Class6 class6) {} }
-  static class Class6 { @Inject Class6(Class7 class7) {} }
-  static class Class7 { @Inject Class7(Class8 class8) {} }
-  static class Class8 { @Inject Class8(Class9 class9) {} }
-  static class Class9 { @Inject Class9(Class10 class10) {} }
-  static class Class10 { @Inject Class10(Class11 class11) {} }
-  static class Class11 { @Inject Class11(Class12 class12) {} }
-  static class Class12 { @Inject Class12(Class13 class13) {} }
-  static class Class13 { @Inject Class13(Class14 class14) {} }
-  static class Class14 { @Inject Class14(Class15 class15) {} }
-  static class Class15 { @Inject Class15(Class16 class16) {} }
-  static class Class16 { @Inject Class16(Class17 class17) {} }
-  static class Class17 { @Inject Class17(Class18 class18) {} }
-  static class Class18 { @Inject Class18(Class19 class19) {} }
-  static class Class19 { @Inject Class19(Class20 class20) {} }
-  static class Class20 { @Inject Class20(Class21 class21) {} }
-  static class Class21 { @Inject Class21(Class22 class22) {} }
-  static class Class22 { @Inject Class22(Class23 class23) {} }
-  static class Class23 { @Inject Class23(Class24 class24) {} }
-  static class Class24 { @Inject Class24(Class25 class25) {} }
-  static class Class25 { @Inject Class25(Class26 class26) {} }
-  static class Class26 { @Inject Class26(Class27 class27) {} }
-  static class Class27 { @Inject Class27(Class28 class28) {} }
-  static class Class28 { @Inject Class28(Class29 class29) {} }
-  static class Class29 { @Inject Class29(Class30 class30) {} }
-  static class Class30 { @Inject Class30(Class31 class31) {} }
-  static class Class31 { @Inject Class31(Class32 class32) {} }
-  static class Class32 { @Inject Class32(Class33 class33) {} }
-  static class Class33 { @Inject Class33(Class34 class34) {} }
-  static class Class34 { @Inject Class34(Class35 class35) {} }
-  static class Class35 { @Inject Class35(Class36 class36) {} }
-  static class Class36 { @Inject Class36(Class37 class37) {} }
-  static class Class37 { @Inject Class37(Class38 class38) {} }
-  static class Class38 { @Inject Class38(Class39 class39) {} }
-  static class Class39 { @Inject Class39(Class40 class40) {} }
-  static class Class40 { @Inject Class40(Class41 class41) {} }
-  static class Class41 { @Inject Class41(Class42 class42) {} }
-  static class Class42 { @Inject Class42(Class43 class43) {} }
-  static class Class43 { @Inject Class43(Class44 class44) {} }
-  static class Class44 { @Inject Class44(Class45 class45) {} }
-  static class Class45 { @Inject Class45(Class46 class46) {} }
-  static class Class46 { @Inject Class46(Class47 class47) {} }
-  static class Class47 { @Inject Class47(Class48 class48) {} }
-  static class Class48 { @Inject Class48(Class49 class49) {} }
-  static class Class49 { @Inject Class49(Class50 class50) {} }
-  static class Class50 { @Inject Class50(Class51 class51) {} }
-  static class Class51 { @Inject Class51(Class52 class52) {} }
-  static class Class52 { @Inject Class52(Class53 class53) {} }
-  static class Class53 { @Inject Class53(Class54 class54) {} }
-  static class Class54 { @Inject Class54(Class55 class55) {} }
-  static class Class55 { @Inject Class55(Class56 class56) {} }
-  static class Class56 { @Inject Class56(Class57 class57) {} }
-  static class Class57 { @Inject Class57(Class58 class58) {} }
-  static class Class58 { @Inject Class58(Class59 class59) {} }
-  static class Class59 { @Inject Class59(Class60 class60) {} }
-  static class Class60 { @Inject Class60(Class61 class61) {} }
-  static class Class61 { @Inject Class61(Class62 class62) {} }
-  static class Class62 { @Inject Class62(Class63 class63) {} }
-  static class Class63 { @Inject Class63(Class64 class64) {} }
-  static class Class64 { @Inject Class64(Class65 class65) {} }
-  static class Class65 { @Inject Class65(Class66 class66) {} }
-  static class Class66 { @Inject Class66(Class67 class67) {} }
-  static class Class67 { @Inject Class67(Class68 class68) {} }
-  static class Class68 { @Inject Class68(Class69 class69) {} }
-  static class Class69 { @Inject Class69(Class70 class70) {} }
-  static class Class70 { @Inject Class70(Class71 class71) {} }
-  static class Class71 { @Inject Class71(Class72 class72) {} }
-  static class Class72 { @Inject Class72(Class73 class73) {} }
-  static class Class73 { @Inject Class73(Class74 class74) {} }
-  static class Class74 { @Inject Class74(Class75 class75) {} }
-  static class Class75 { @Inject Class75(Class76 class76) {} }
-  static class Class76 { @Inject Class76(Class77 class77) {} }
-  static class Class77 { @Inject Class77(Class78 class78) {} }
-  static class Class78 { @Inject Class78(Class79 class79) {} }
-  static class Class79 { @Inject Class79(Class80 class80) {} }
-  static class Class80 { @Inject Class80(Class81 class81) {} }
-  static class Class81 { @Inject Class81(Class82 class82) {} }
-  static class Class82 { @Inject Class82(Class83 class83) {} }
-  static class Class83 { @Inject Class83(Class84 class84) {} }
-  static class Class84 { @Inject Class84(Class85 class85) {} }
-  static class Class85 { @Inject Class85(Class86 class86) {} }
-  static class Class86 { @Inject Class86(Class87 class87) {} }
-  static class Class87 { @Inject Class87(Class88 class88) {} }
-  static class Class88 { @Inject Class88(Class89 class89) {} }
-  static class Class89 { @Inject Class89(Class90 class90) {} }
-  static class Class90 { @Inject Class90(Class91 class91) {} }
-  static class Class91 { @Inject Class91(Class92 class92) {} }
-  static class Class92 { @Inject Class92(Class93 class93) {} }
-  static class Class93 { @Inject Class93(Class94 class94) {} }
-  static class Class94 { @Inject Class94(Class95 class95) {} }
-  static class Class95 { @Inject Class95(Class96 class96) {} }
-  static class Class96 { @Inject Class96(Class97 class97) {} }
-  static class Class97 { @Inject Class97(Class98 class98) {} }
-  static class Class98 { @Inject Class98(Class99 class99) {} }
-  static class Class99 { @Inject Class99(Class100 class100) {} }
-  static class Class100 { @Inject Class100(Class101 class101) {} }
-  static class Class101 { @Inject Class101(Provider<Class1> class1Provider) {} }
-
-  @SuppressWarnings("dependency-cycle")
-  @Component
-  interface LongCycleComponent {
-    Class1 class1();
-  }
-
-  private LongCycle() {}
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfArrayOfParentOfStringArray.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfArrayOfParentOfStringArray.java
deleted file mode 100644
index de07ef9f8..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfArrayOfParentOfStringArray.java
+++ /dev/null
@@ -1,21 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.membersinject;
-
-class ChildOfArrayOfParentOfStringArray extends
-    MembersInjectGenericParent<MembersInjectGenericParent<String[]>[]> {
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfPrimitiveIntArray.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfPrimitiveIntArray.java
deleted file mode 100644
index 9ba1ca349..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfPrimitiveIntArray.java
+++ /dev/null
@@ -1,21 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.membersinject;
-
-class ChildOfPrimitiveIntArray extends MembersInjectGenericParent<int[]> {
-
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfStringArray.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfStringArray.java
deleted file mode 100644
index e11dad1cd..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/membersinject/ChildOfStringArray.java
+++ /dev/null
@@ -1,21 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.membersinject;
-
-class ChildOfStringArray extends MembersInjectGenericParent<String[]> {
-
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectComponent.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectComponent.java
deleted file mode 100644
index 9fe099f33..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectComponent.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.membersinject;
-
-import dagger.Component;
-
-@Component(modules = {MembersInjectModule.class})
-interface MembersInjectComponent {
-  
-  void inject(ChildOfStringArray subfoo);
-  void inject(ChildOfArrayOfParentOfStringArray subfoo);
-  void inject(ChildOfPrimitiveIntArray subfoo);
-  void inject(RawFrameworkTypes rawFrameworkTypes);
-
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectGenericParent.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectGenericParent.java
deleted file mode 100644
index 674da5052..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectGenericParent.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.membersinject;
-
-import javax.inject.Inject;
-
-class MembersInjectGenericParent<T> {
-  
-  @Inject T t; 
-
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectModule.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectModule.java
deleted file mode 100644
index fc31c772e..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/membersinject/MembersInjectModule.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.membersinject;
-
-import dagger.Module;
-import dagger.Provides;
-
-@Module
-class MembersInjectModule {
-  
-  @Provides String[] provideStringArray() { return new String[10]; }
-  
-  @Provides int[] provideIntArray() { return new int[10]; }
-  
-  @SuppressWarnings("unchecked")
-  @Provides MembersInjectGenericParent<String[]>[] provideFooArrayOfStringArray() { return new MembersInjectGenericParent[10]; }
-
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/NonRequestedChild.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/NonRequestedChild.java
deleted file mode 100644
index 448c37df1..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/membersinject/NonRequestedChild.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.membersinject;
-
-import javax.inject.Inject;
-
-/**
- * A class that should not be requested by any component, to ensure that we still generate a members
- * injector for it.
- */
-class NonRequestedChild extends MembersInjectGenericParent<String> {
-  @Inject
-  NonRequestedChild() {}
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/membersinject/RawFrameworkTypes.java b/compiler/src/it/functional-tests/src/main/java/test/membersinject/RawFrameworkTypes.java
deleted file mode 100644
index 88a473177..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/membersinject/RawFrameworkTypes.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.membersinject;
-
-import dagger.Lazy;
-import dagger.MembersInjector;
-import javax.inject.Provider;
-
-// https://github.com/google/dagger/issues/419
-@SuppressWarnings({"rawtypes", "unused"})
-class RawFrameworkTypes {
-  void nonInjectMethodWithARawProvider(Provider rawProvider) {}
-  void nonInjectMethodWithARawLazy(Lazy rawLazy) {}
-  void nonInjectMethodWithARawMembersInjector(MembersInjector rawMembersInjector) {}
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/FooComponent.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/FooComponent.java
deleted file mode 100644
index afbc3f05f..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/FooComponent.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.multipackage;
-
-import dagger.Component;
-import java.util.Set;
-import test.multipackage.a.AModule;
-import test.multipackage.a.UsesInaccessible;
-import test.multipackage.a.UsesInaccessibleInGenericsOnly;
-import test.multipackage.sub.FooChildComponent;
-
-/**
- * A component that tests the interaction between subcomponents, multiple packages, and
- * multibindings. Specifically, we want:
- * <ul>
- * <li>A set binding with some contributions in the parent component, and some in the subcomponent.
- * <li>The contributions come from different packages, but not the package of either component.
- * <li>The set binding is requested in the subcomponent through a binding from a separate package.
- * <li>No binding in the subcomponent, that's in the subcomponent's package, directly uses any
- *     binding from the component's package.
- * </ul>
- */
-// NOTE(beder): Be careful about changing any bindings in either this component or the subcomponent.
-// Even adding a binding might stop this test from testing what it's supposed to test.
-@Component(modules = {AModule.class})
-interface FooComponent {
-  Set<String> setOfString();
-
-  FooChildComponent fooChildComponent();
-
-  UsesInaccessible usesInaccessible();
-
-  UsesInaccessibleInGenericsOnly accessibleConstructorUsesInaccessibleInGenericsOnly();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/MembersInjectionVisibilityComponent.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/MembersInjectionVisibilityComponent.java
deleted file mode 100644
index 608255b9d..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/MembersInjectionVisibilityComponent.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.multipackage;
-
-import dagger.Component;
-import test.multipackage.a.AGrandchild;
-import test.multipackage.a.AModule;
-import test.multipackage.a.AParent;
-import test.multipackage.b.BChild;
-
-/**
- * A component that tests members injection across packages and subclasses.
- */
-@Component(modules = {AModule.class})
-public interface MembersInjectionVisibilityComponent {
-  void inject(AParent aParent);
-
-  void inject(BChild aChild);
-
-  void inject(AGrandchild aGrandchild);
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/MultibindsComponent.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/MultibindsComponent.java
deleted file mode 100644
index b4ef7475b..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/MultibindsComponent.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.multipackage;
-
-import dagger.Component;
-import test.multipackage.a.AMultibindsModule;
-import test.multipackage.a.UsesInaccessible;
-
-/**
- * A component that tests the interaction between multiple packages and {@code @Multibinding}s.
- * Specifically, we want:
- *
- * <ul>
- * <li>A {@code @Multibinding} for an empty set of a type not accessible from this package.
- * <li>A {@code @Multibinding} for an empty map of a type not accessible from this package.
- * <li>A public type that injects the empty set and map of inaccessible objects.
- * </ul>
- */
-@Component(modules = {AMultibindsModule.class})
-interface MultibindsComponent {
-  UsesInaccessible usesInaccessible();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AGrandchild.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AGrandchild.java
deleted file mode 100644
index 0aa46faed..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AGrandchild.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.multipackage.a;
-
-import javax.inject.Inject;
-import test.multipackage.b.BChild;
-
-public class AGrandchild extends BChild {
-
-  @Inject APackagePrivateObject aGrandchildField;
-
-  private APackagePrivateObject aGrandchildMethod;
-
-  @Inject
-  void aGrandchildMethod(APackagePrivateObject aGrandchildMethod) {
-    this.aGrandchildMethod = aGrandchildMethod;
-  }
-
-  @Override
-  @Inject
-  protected void aParentMethod(APublicObject aParentMethod) {
-    super.aParentMethod(aParentMethod);
-  }
-
-  @SuppressWarnings("OverridesJavaxInjectableMethod")
-  @Override
-  protected void aChildMethod(APublicObject aChildMethod) {
-    super.aChildMethod(aChildMethod);
-  }
-
-  public APackagePrivateObject aGrandchildField() {
-    return aGrandchildField;
-  }
-
-  public APackagePrivateObject aGrandchildMethod() {
-    return aGrandchildMethod;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java
deleted file mode 100644
index 7095d98df..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AModule.java
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.multipackage.a;
-
-import dagger.Binds;
-import dagger.Module;
-import dagger.Provides;
-import dagger.multibindings.ElementsIntoSet;
-import dagger.multibindings.IntoMap;
-import dagger.multibindings.IntoSet;
-import dagger.multibindings.StringKey;
-import java.util.HashSet;
-import java.util.Set;
-
-@Module
-public abstract class AModule {
-  @Provides
-  @IntoSet
-  static String provideString() {
-    return "a";
-  }
-
-  @Binds
-  @IntoSet
-  abstract Inaccessible provideInaccessible(Inaccessible inaccessible);
-
-  @Provides
-  @ElementsIntoSet
-  static Set<Inaccessible> provideSetOfInaccessibles() {
-    return new HashSet<>();
-  }
-
-  @Binds
-  @IntoMap
-  @StringKey("inaccessible")
-  abstract Inaccessible provideInaccessibleToMap(Inaccessible inaccessible);
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AMultibindsModule.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AMultibindsModule.java
deleted file mode 100644
index 2ddd0d8e3..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AMultibindsModule.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.multipackage.a;
-
-import dagger.Module;
-import dagger.multibindings.Multibinds;
-import java.util.Map;
-import java.util.Set;
-
-/** A module that {@code @Multibinds} a set and a map of {@link Inaccessible}. */
-@Module
-public abstract class AMultibindsModule {
-  @Multibinds
-  abstract Set<Inaccessible> inaccessibleSet();
-
-  @Multibinds
-  abstract Map<String, Inaccessible> inaccessibleMap();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APackagePrivateObject.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APackagePrivateObject.java
deleted file mode 100644
index 3e67bb088..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APackagePrivateObject.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.multipackage.a;
-
-import javax.inject.Inject;
-
-class APackagePrivateObject {
-
-  @Inject
-  APackagePrivateObject() {}
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AParent.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AParent.java
deleted file mode 100644
index 647ebdeda..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/AParent.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.multipackage.a;
-
-import javax.inject.Inject;
-
-public class AParent {
-
-  @Inject APackagePrivateObject aParentField;
-
-  private APublicObject aParentMethod;
-
-  @Inject
-  protected void aParentMethod(APublicObject aParentMethod) {
-    this.aParentMethod = aParentMethod;
-  }
-
-  public APackagePrivateObject aParentField() {
-    return aParentField;
-  }
-
-  public APublicObject aParentMethod() {
-    return aParentMethod;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APublicObject.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APublicObject.java
deleted file mode 100644
index 5262ec40e..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/APublicObject.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.multipackage.a;
-
-import javax.inject.Inject;
-
-public class APublicObject {
-
-  @Inject
-  APublicObject() {}
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/Inaccessible.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/Inaccessible.java
deleted file mode 100644
index e20d74f0e..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/Inaccessible.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.multipackage.a;
-
-import javax.inject.Inject;
-
-final class Inaccessible {
-  @Inject Inaccessible() {}
-}
\ No newline at end of file
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessible.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessible.java
deleted file mode 100644
index 3ee3a5e06..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessible.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.multipackage.a;
-
-import java.util.Map;
-import java.util.Set;
-import javax.inject.Inject;
-
-@SuppressWarnings("unused")
-public class UsesInaccessible {
-  @Inject
-  public UsesInaccessible(
-      Inaccessible inaccessible,
-      Set<Inaccessible> inaccessibleSet,
-      Map<String, Inaccessible> inaccessibleMap) {}
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessibleInGenericsOnly.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessibleInGenericsOnly.java
deleted file mode 100644
index f212a0c66..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/a/UsesInaccessibleInGenericsOnly.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.multipackage.a;
-
-import java.util.Map;
-import java.util.Set;
-import javax.inject.Inject;
-
-@SuppressWarnings("unused")
-public class UsesInaccessibleInGenericsOnly {
-  @Inject
-  public UsesInaccessibleInGenericsOnly(
-      Set<Inaccessible> inaccessibleSet, Map<String, Inaccessible> inaccessibleMap) {}
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BChild.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BChild.java
deleted file mode 100644
index 6a62006b9..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BChild.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.multipackage.b;
-
-import javax.inject.Inject;
-import test.multipackage.a.AParent;
-import test.multipackage.a.APublicObject;
-
-public class BChild extends AParent {
-
-  @Inject BPackagePrivateObject aChildField;
-
-  private APublicObject aChildMethod;
-
-  @Inject
-  protected void aChildMethod(APublicObject aChildMethod) {
-    this.aChildMethod = aChildMethod;
-  }
-
-  @SuppressWarnings("OverridesJavaxInjectableMethod")
-  @Override
-  protected void aParentMethod(APublicObject aParentMethod) {
-    super.aParentMethod(aParentMethod);
-  }
-
-  public BPackagePrivateObject aChildField() {
-    return aChildField;
-  }
-
-  public APublicObject aChildMethod() {
-    return aChildMethod;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BModule.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BModule.java
deleted file mode 100644
index e9c5482fa..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BModule.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.multipackage.b;
-
-import dagger.Module;
-import dagger.Provides;
-import dagger.multibindings.IntoSet;
-
-@Module
-public final class BModule {
-  @Provides
-  @IntoSet
-  static String provideString() {
-    return "b";
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BPackagePrivateObject.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BPackagePrivateObject.java
deleted file mode 100644
index bce3e4c71..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/b/BPackagePrivateObject.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.multipackage.b;
-
-import javax.inject.Inject;
-
-class BPackagePrivateObject {
-
-  @Inject
-  BPackagePrivateObject() {}
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/c/CModule.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/c/CModule.java
deleted file mode 100644
index b137cee2f..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/c/CModule.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.multipackage.c;
-
-import dagger.Module;
-import dagger.Provides;
-import dagger.multibindings.IntoSet;
-
-@Module
-public final class CModule {
-  @Provides
-  @IntoSet
-  static String provideString() {
-    return "c";
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/d/DModule.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/d/DModule.java
deleted file mode 100644
index b638c84b2..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/d/DModule.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.multipackage.d;
-
-import dagger.Module;
-import dagger.Provides;
-import dagger.multibindings.IntoSet;
-
-@Module
-public final class DModule {
-  @Provides
-  @IntoSet
-  static String provideString() {
-    return "d";
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/foo/Foo.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/foo/Foo.java
deleted file mode 100644
index f028f39b3..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/foo/Foo.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.multipackage.foo;
-
-import java.util.Set;
-import javax.inject.Inject;
-
-public final class Foo<T> {
-  public final Set<String> strings;
-
-  @Inject Foo(Set<String> strings) {
-    this.strings = strings;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/grandsub/FooGrandchildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/grandsub/FooGrandchildComponent.java
deleted file mode 100644
index 36c9b180f..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/grandsub/FooGrandchildComponent.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.multipackage.grandsub;
-
-import dagger.Subcomponent;
-import test.multipackage.d.DModule;
-import test.multipackage.foo.Foo;
-
-@Subcomponent(modules = DModule.class)
-public interface FooGrandchildComponent {
-  Foo<FooGrandchildComponent> foo();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/multipackage/sub/FooChildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/multipackage/sub/FooChildComponent.java
deleted file mode 100644
index 56cf422bc..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/multipackage/sub/FooChildComponent.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.multipackage.sub;
-
-import dagger.Subcomponent;
-import test.multipackage.b.BModule;
-import test.multipackage.c.CModule;
-import test.multipackage.foo.Foo;
-import test.multipackage.grandsub.FooGrandchildComponent;
-
-@Subcomponent(modules = {BModule.class, CModule.class})
-public interface FooChildComponent {
-  Foo<FooChildComponent> foo();
-
-  FooGrandchildComponent fooGrandchildComponent();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponent.java b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponent.java
deleted file mode 100644
index 464b5a2a0..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponent.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
-* Copyright (C) 2015 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package test.nullables;
-
-import dagger.Component;
-import javax.inject.Provider;
-
-@Component(modules = NullModule.class)
-interface NullComponent {
-  NullFoo nullFoo();
-  @Nullable String string();
-  Provider<String> stringProvider();
-  Number number();
-  Provider<Number> numberProvider();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponentWithDependency.java b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponentWithDependency.java
deleted file mode 100644
index b250af6f9..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullComponentWithDependency.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
-* Copyright (C) 2015 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package test.nullables;
-
-import dagger.Component;
-import javax.inject.Provider;
-
-@Component(dependencies = NullComponent.class)
-interface NullComponentWithDependency {
-  @Nullable String string();
-  Provider<String> stringProvider();
-  Number number();
-  Provider<Number> numberProvider();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullFoo.java b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullFoo.java
deleted file mode 100644
index 13f60fe78..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullFoo.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
-* Copyright (C) 2015 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package test.nullables;
-
-import javax.inject.Inject;
-import javax.inject.Provider;
-
-class NullFoo {
-  final String string;
-  final Provider<String> stringProvider;
-  final Number number;
-  final Provider<Number> numberProvider;
-
-  @Inject
-  NullFoo(@Nullable String string,
-      Provider<String> stringProvider,
-      Number number,
-      Provider<Number> numberProvider) {
-    this.string = string;
-    this.stringProvider = stringProvider;
-    this.number = number;
-    this.numberProvider = numberProvider;
-  }
-
-  String methodInjectedString;
-  Provider<String> methodInjectedStringProvider;
-  Number methodInjectedNumber;
-  Provider<Number> methodInjectedNumberProvider;
-  @Inject void inject(@Nullable String string,
-      Provider<String> stringProvider,
-      Number number,
-      Provider<Number> numberProvider) {
-    this.methodInjectedString = string;
-    this.methodInjectedStringProvider = stringProvider;
-    this.methodInjectedNumber = number;
-    this.methodInjectedNumberProvider = numberProvider;
-  }
-
-  @Nullable @Inject String fieldInjectedString;
-  @Inject Provider<String> fieldInjectedStringProvider;
-  @Inject Number fieldInjectedNumber;
-  @Inject Provider<Number> fieldInjectedNumberProvider;
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullModule.java b/compiler/src/it/functional-tests/src/main/java/test/nullables/NullModule.java
deleted file mode 100644
index dc827adfe..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/nullables/NullModule.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
-* Copyright (C) 2015 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package test.nullables;
-
-import dagger.Module;
-import dagger.Provides;
-
-@Module
-class NullModule {
-  Number numberValue = null;
-
-  @Nullable
-  @Provides
-  String provideNullableString() {
-    return null;
-  }
-
-  @Provides
-  Number provideNumber() {
-    return numberValue;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/nullables/Nullable.java b/compiler/src/it/functional-tests/src/main/java/test/nullables/Nullable.java
deleted file mode 100644
index 86776406a..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/nullables/Nullable.java
+++ /dev/null
@@ -1,3 +0,0 @@
-package test.nullables;
-
-@interface Nullable {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/BlueModule.java b/compiler/src/it/functional-tests/src/main/java/test/scope/BlueModule.java
deleted file mode 100644
index ff4703152..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/scope/BlueModule.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.scope;
-
-import dagger.Module;
-import dagger.Provides;
-import dagger.multibindings.IntoSet;
-
-@Module
-final class BlueModule {
-  @Provides
-  @IntoSet
-  @BlueScope
-  static Object blue() {
-    return new Object();
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/BlueScope.java b/compiler/src/it/functional-tests/src/main/java/test/scope/BlueScope.java
deleted file mode 100644
index 969a51ebd..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/scope/BlueScope.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.scope;
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import java.lang.annotation.Documented;
-import java.lang.annotation.Retention;
-import javax.inject.Scope;
-
-@Documented
-@Retention(RUNTIME)
-@Scope
-@interface BlueScope {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/GreenModule.java b/compiler/src/it/functional-tests/src/main/java/test/scope/GreenModule.java
deleted file mode 100644
index a8d96057d..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/scope/GreenModule.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.scope;
-
-import dagger.Module;
-import dagger.Provides;
-import dagger.multibindings.IntoSet;
-
-@Module
-final class GreenModule  {
-  @Provides
-  @IntoSet
-  @GreenScope
-  static Object green() {
-    return new Object();
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/GreenScope.java b/compiler/src/it/functional-tests/src/main/java/test/scope/GreenScope.java
deleted file mode 100644
index 485b06bc3..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/scope/GreenScope.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.scope;
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import java.lang.annotation.Documented;
-import java.lang.annotation.Retention;
-import javax.inject.Scope;
-
-@Documented
-@Retention(RUNTIME)
-@Scope
-@interface GreenScope {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/ScopedComponent.java b/compiler/src/it/functional-tests/src/main/java/test/scope/ScopedComponent.java
deleted file mode 100644
index 8ea281108..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/scope/ScopedComponent.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.scope;
-
-import dagger.Component;
-import java.util.Set;
-
-@BlueScope
-@GreenScope
-@Component(modules = {BlueModule.class, GreenModule.class, TurquoiseModule.class})
-interface ScopedComponent {
-  Set<Object> set();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/scope/TurquoiseModule.java b/compiler/src/it/functional-tests/src/main/java/test/scope/TurquoiseModule.java
deleted file mode 100644
index ef6fb5455..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/scope/TurquoiseModule.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.scope;
-
-import dagger.Module;
-import dagger.Provides;
-import dagger.multibindings.IntoSet;
-
-@Module
-final class TurquoiseModule {
-  @Provides
-  @IntoSet
-  @BlueScope
-  static Object blue() {
-    return new Object();
-  }
-
-  @Provides
-  @IntoSet
-  @GreenScope
-  static Object green() {
-    return new Object();
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/AllStaticModule.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/AllStaticModule.java
deleted file mode 100644
index 89b3f0eb3..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/AllStaticModule.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.staticprovides;
-
-import static java.util.Collections.emptySet;
-
-import dagger.Module;
-import dagger.Provides;
-import dagger.multibindings.ElementsIntoSet;
-import dagger.multibindings.IntoSet;
-import java.util.Set;
-
-@Module
-final class AllStaticModule {
-  @Provides
-  @IntoSet
-  static String contributeString() {
-    return AllStaticModule.class + ".contributeString";
-  }
-
-  @Provides
-  @ElementsIntoSet
-  static Set<Integer> contibuteEmptyIntegerSet() {
-    return emptySet();
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/SomeStaticModule.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/SomeStaticModule.java
deleted file mode 100644
index 56d10f9a6..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/SomeStaticModule.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.staticprovides;
-
-import dagger.Module;
-import dagger.Provides;
-import dagger.multibindings.IntoSet;
-
-@Module
-final class SomeStaticModule {
-  @Provides
-  @IntoSet
-  static String contributeStringFromAStaticMethod() {
-    return SomeStaticModule.class + ".contributeStringFromAStaticMethod";
-  }
-
-  @Provides
-  @IntoSet
-  static String contributeStringFromAnInstanceMethod() {
-    return SomeStaticModule.class + ".contributeStringFromAnInstanceMethod";
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java
deleted file mode 100644
index 1a3e67799..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponent.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.staticprovides;
-
-import dagger.Component;
-import java.util.Set;
-
-/**
- * A simple component that demonstrates both static and non-static provides methods.
- */
-@Component(modules = {AllStaticModule.class, SomeStaticModule.class})
-interface StaticTestComponent {
-  Set<String> getMultiboundStrings();
-  Set<Integer> getMultiboundIntegers();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponentWithBuilder.java b/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponentWithBuilder.java
deleted file mode 100644
index 8ae132d39..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/staticprovides/StaticTestComponentWithBuilder.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.staticprovides;
-
-import dagger.Component;
-
-/**
- * A simple component that demonstrates both static and non-static provides methods with a builder.
- */
-@Component(modules = {AllStaticModule.class, SomeStaticModule.class})
-interface StaticTestComponentWithBuilder extends StaticTestComponent {
-  @Component.Builder
-  interface Builder {
-    Builder allStaticModule(AllStaticModule allStaticModule);
-    Builder someStaticModule(SomeStaticModule someStaticModule);
-    StaticTestComponentWithBuilder build();
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/ContributionsModule.java b/compiler/src/it/functional-tests/src/main/java/test/sub/ContributionsModule.java
deleted file mode 100644
index a72ab14aa..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/sub/ContributionsModule.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.sub;
-
-import dagger.Module;
-import dagger.Provides;
-import dagger.multibindings.ElementsIntoSet;
-import dagger.multibindings.IntoSet;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.LinkedHashSet;
-import java.util.Set;
-
-@Module
-public final class ContributionsModule {
-  @Provides
-  @IntoSet
-  static int contributeAnInt(@SuppressWarnings("unused") double doubleDependency) {
-    return 1742;
-  }
-
-  @Provides
-  @IntoSet
-  static int contributeAnotherInt() {
-    return 832;
-  }
-
-  @Provides
-  @ElementsIntoSet
-  static Set<Integer> contributeSomeInts() {
-    return Collections.unmodifiableSet(new LinkedHashSet<Integer>(Arrays.asList(-1, -90, -17)));
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/Exposed.java b/compiler/src/it/functional-tests/src/main/java/test/sub/Exposed.java
deleted file mode 100644
index 9195b33f9..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/sub/Exposed.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package test.sub;
-
-import javax.inject.Inject;
-import test.Generic;
-import test.Generic2;
-
-public class Exposed {
-  
-  @Inject public Generic2<PackagePrivate> gpp2;
-  @Inject public Generic2<PackagePrivateContainer.PublicEnclosed> gppc2;
-
-  public Generic<PackagePrivate> gpp;
-  public Generic<PackagePrivateContainer.PublicEnclosed> gppc;
-  
-  @Inject Exposed(Generic<PackagePrivate> gpp, Generic<PackagePrivateContainer.PublicEnclosed> gppc) {
-    this.gpp = gpp;
-    this.gppc = gppc;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/OtherThing.java b/compiler/src/it/functional-tests/src/main/java/test/sub/OtherThing.java
deleted file mode 100644
index 9597f570c..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/sub/OtherThing.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.sub;
-
-import javax.inject.Inject;
-
-public final class OtherThing {
-  @Inject
-  public OtherThing(@SuppressWarnings("unused") int i) {}
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/PackagePrivate.java b/compiler/src/it/functional-tests/src/main/java/test/sub/PackagePrivate.java
deleted file mode 100644
index 9af646a50..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/sub/PackagePrivate.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package test.sub;
-
-import javax.inject.Inject;
-
-class PackagePrivate {  
-  @Inject PackagePrivate() {}
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/PackagePrivateContainer.java b/compiler/src/it/functional-tests/src/main/java/test/sub/PackagePrivateContainer.java
deleted file mode 100644
index 765b01504..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/sub/PackagePrivateContainer.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package test.sub;
-
-import javax.inject.Inject;
-
-class PackagePrivateContainer {  
-  public static class PublicEnclosed {
-    @Inject PublicEnclosed() {}
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/PublicSubclass.java b/compiler/src/it/functional-tests/src/main/java/test/sub/PublicSubclass.java
deleted file mode 100644
index 586d55d93..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/sub/PublicSubclass.java
+++ /dev/null
@@ -1,10 +0,0 @@
-package test.sub;
-
-import javax.inject.Inject;
-import test.Generic;
-
-public class PublicSubclass extends Generic<PackagePrivate> {
-  @Inject public PublicSubclass(PackagePrivate pp) {
-    super(pp);
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/sub/PublicSubclass2.java b/compiler/src/it/functional-tests/src/main/java/test/sub/PublicSubclass2.java
deleted file mode 100644
index c356fa8f0..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/sub/PublicSubclass2.java
+++ /dev/null
@@ -1,10 +0,0 @@
-package test.sub;
-
-import javax.inject.Inject;
-import test.Generic;
-
-public class PublicSubclass2 extends Generic<PackagePrivateContainer.PublicEnclosed> {
-  @Inject public PublicSubclass2(PackagePrivateContainer.PublicEnclosed pp) {
-    super(pp);
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/AnInterface.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/AnInterface.java
deleted file mode 100644
index 325bbb421..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/AnInterface.java
+++ /dev/null
@@ -1,20 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-interface AnInterface {
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/BoundAsSingleton.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/BoundAsSingleton.java
deleted file mode 100644
index b11cadf7d..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/BoundAsSingleton.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import java.lang.annotation.Documented;
-import java.lang.annotation.Retention;
-import javax.inject.Qualifier;
-
-@Documented
-@Retention(RUNTIME)
-@Qualifier
-@interface BoundAsSingleton {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildAbstractClassComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildAbstractClassComponent.java
deleted file mode 100644
index b7abe9408..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildAbstractClassComponent.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import dagger.Subcomponent;
-
-@Subcomponent(modules = {ChildModule.class, StaticChildModule.class})
-abstract class ChildAbstractClassComponent implements ChildComponent {
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
deleted file mode 100644
index 3353cf091..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponent.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import dagger.Subcomponent;
-import java.util.Set;
-import javax.inject.Provider;
-
-@Subcomponent(modules = {ChildModule.class, StaticChildModule.class})
-interface ChildComponent {
-  Provider<UnscopedType> getUnscopedTypeProvider();
-
-  RequiresSingletons requiresSingleton();
-
-  Set<Object> objectSet();
-
-  GrandchildComponent newGrandchildComponent();
-  
-  Object object();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponentRequiringModules.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponentRequiringModules.java
deleted file mode 100644
index 78a5c4a73..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponentRequiringModules.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import dagger.Subcomponent;
-
-@Subcomponent(modules = {
-    ChildModule.class,
-    ChildModuleWithParameters.class,
-    ChildModuleWithState.class})
-interface ChildComponentRequiringModules {
-  int getInt();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModule.java
deleted file mode 100644
index a86093a36..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModule.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import dagger.Module;
-import dagger.Provides;
-import dagger.multibindings.IntoSet;
-
-@Module
-final class ChildModule {
-  @Provides
-  @IntoSet
-  static Object provideUnscopedObject() {
-    return new Object() {
-      @Override public String toString() {
-        return "unscoped in child";
-      }
-    };
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithParameters.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithParameters.java
deleted file mode 100644
index fd6b7fddd..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithParameters.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import dagger.Module;
-
-/**
- * This is a module that can't be constructed with a default constructor.
- */
-@Module
-final class ChildModuleWithParameters {
-  public ChildModuleWithParameters(@SuppressWarnings("unused") Object whatever) {}
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithState.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithState.java
deleted file mode 100644
index 1952a27a1..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildModuleWithState.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import dagger.Module;
-import dagger.Provides;
-
-/**
- * This is a module that can be constructed with a default constructor, but has state, so callers
- * might want to pass a reference anyway.
- */
-@Module
-final class ChildModuleWithState {
-  private int i = 0;
-
-  @Provides int provideInt() {
-    return i++;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GenericParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GenericParentComponent.java
deleted file mode 100644
index 5b8414cea..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GenericParentComponent.java
+++ /dev/null
@@ -1,21 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-interface GenericParentComponent<B> {  
-  B subcomponent();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java
deleted file mode 100644
index 0fc79f979..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildComponent.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import dagger.Subcomponent;
-import java.util.Set;
-import javax.inject.Provider;
-
-@Subcomponent(modules = GrandchildModule.class)
-interface GrandchildComponent {
-  Provider<UnscopedType> getUnscopedTypeProvider();
-
-  RequiresSingletons requiresSingleton();
-
-  Set<Object> objectSet();
-
-  NeedsAnInterface needsAnInterface();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java
deleted file mode 100644
index a261117a5..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/GrandchildModule.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import dagger.Binds;
-import dagger.Module;
-import dagger.Provides;
-import dagger.multibindings.IntoSet;
-
-@Module
-abstract class GrandchildModule {
-  @Provides
-  @IntoSet
-  static Object provideUnscopedObject() {
-    return new Object() {
-      @Override public String toString() {
-        return "unscoped in grandchild";
-      }
-    };
-  }
-
-  @Binds
-  abstract AnInterface provideAnInterface(ImplementsAnInterface implementsAnInterface);
-
-  @Provides
-  static NeedsAnInterface provideNeedsAnInterface(AnInterface anInterface) {
-    return new NeedsAnInterface(anInterface);
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ImplementsAnInterface.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ImplementsAnInterface.java
deleted file mode 100644
index 8be798f42..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ImplementsAnInterface.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import javax.inject.Inject;
-
-class ImplementsAnInterface implements AnInterface {
-  @Inject ImplementsAnInterface() {}
-}
-
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
deleted file mode 100644
index fa53807cb..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/MultibindingSubcomponents.java
+++ /dev/null
@@ -1,254 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import dagger.Binds;
-import dagger.Component;
-import dagger.Module;
-import dagger.Provides;
-import dagger.Subcomponent;
-import dagger.multibindings.IntoMap;
-import dagger.multibindings.IntoSet;
-import dagger.multibindings.StringKey;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Set;
-import javax.inject.Inject;
-
-final class MultibindingSubcomponents {
-
-  /** Multibindings for this type are bound only in the parent component. */
-  enum BoundInParent {
-    INSTANCE;
-  }
-
-  /** Multibindings for this type are bound only in the child component. */
-  enum BoundInChild {
-    INSTANCE;
-  }
-
-  /** Multibindings for this type are bound in the parent component and the child component. */
-  enum BoundInParentAndChild {
-    IN_PARENT,
-    IN_CHILD;
-  }
-
-  static final class RequiresMultibindings<T> {
-    private final Set<T> set;
-    private final Map<String, T> map;
-
-    @Inject
-    RequiresMultibindings(Set<T> set, Map<String, T> map) {
-      this.set = set;
-      this.map = map;
-    }
-
-    Set<T> set() {
-      return set;
-    }
-
-    Map<String, T> map() {
-      return map;
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-      return obj instanceof RequiresMultibindings<?>
-          && set.equals(((RequiresMultibindings<?>) obj).set)
-          && map.equals(((RequiresMultibindings<?>) obj).map);
-    }
-
-    @Override
-    public int hashCode() {
-      return Objects.hash(set, map);
-    }
-
-    @Override
-    public String toString() {
-      return String.format(
-          "%s{set=%s, map=%s}", RequiresMultibindings.class.getSimpleName(), set, map);
-    }
-  }
-
-  @Module
-  abstract static class ParentMultibindingModule {
-
-    @Provides
-    @IntoSet
-    static BoundInParent onlyInParentElement() {
-      return BoundInParent.INSTANCE;
-    }
-
-    @Provides
-    @IntoMap
-    @StringKey("parent key")
-    static BoundInParent onlyInParentEntry() {
-      return BoundInParent.INSTANCE;
-    }
-
-    @Provides
-    @IntoSet
-    static BoundInParentAndChild inParentAndChildElement() {
-      return BoundInParentAndChild.IN_PARENT;
-    }
-
-    @Provides
-    @IntoMap
-    @StringKey("parent key")
-    static BoundInParentAndChild inParentAndChildEntry() {
-      return BoundInParentAndChild.IN_PARENT;
-    }
-
-    /* This is not static because otherwise we have no tests that cover the case where a
-     * subcomponent uses a module instance installed onto a parent component. */
-    @Binds
-    @IntoSet
-    abstract RequiresMultibindings<BoundInParentAndChild>
-        requiresMultibindingsInParentAndChildElement(
-            RequiresMultibindings<BoundInParentAndChild> requiresMultibindingsInParentAndChild);
-  }
-
-  @Module
-  static final class ChildMultibindingModule {
-
-    @Provides
-    @IntoSet
-    static BoundInParentAndChild inParentAndChildElement() {
-      return BoundInParentAndChild.IN_CHILD;
-    }
-
-    @Provides
-    @IntoMap
-    @StringKey("child key")
-    static BoundInParentAndChild inParentAndChildEntry() {
-      return BoundInParentAndChild.IN_CHILD;
-    }
-
-    @Provides
-    @IntoSet
-    static BoundInChild onlyInChildElement() {
-      return BoundInChild.INSTANCE;
-    }
-
-    @Provides
-    @IntoMap
-    @StringKey("child key")
-    static BoundInChild onlyInChildEntry() {
-      return BoundInChild.INSTANCE;
-    }
-  }
-
-  @Module
-  abstract static class ChildMultibindingModuleWithOnlyBindsMultibindings {
-    @Provides
-    static BoundInParentAndChild provideBoundInParentAndChildForBinds() {
-      return BoundInParentAndChild.IN_CHILD;
-    }
-
-    @Binds
-    @IntoSet
-    abstract BoundInParentAndChild bindsLocalContribution(BoundInParentAndChild instance);
-
-    @Binds
-    @IntoMap
-    @StringKey("child key")
-    abstract BoundInParentAndChild inParentAndChildEntry(BoundInParentAndChild instance);
-
-    @Provides
-    static BoundInChild provideBoundInChildForBinds() {
-      return BoundInChild.INSTANCE;
-    }
-
-    @Binds
-    @IntoSet
-    abstract BoundInChild inChild(BoundInChild instance);
-
-    @Binds
-    @IntoMap
-    @StringKey("child key")
-    abstract BoundInChild inChildEntry(BoundInChild instance);
-  }
-
-  interface ProvidesBoundInParent {
-    RequiresMultibindings<BoundInParent> requiresMultibindingsBoundInParent();
-  }
-
-  interface ProvidesBoundInChild {
-    RequiresMultibindings<BoundInChild> requiresMultibindingsBoundInChild();
-  }
-
-  interface ProvidesBoundInParentAndChild {
-    RequiresMultibindings<BoundInParentAndChild> requiresMultibindingsBoundInParentAndChild();
-  }
-
-  interface ProvidesSetOfRequiresMultibindings {
-    Set<RequiresMultibindings<BoundInParentAndChild>> setOfRequiresMultibindingsInParentAndChild();
-  }
-
-  interface ParentWithProvision
-      extends ProvidesBoundInParent, ProvidesBoundInParentAndChild,
-          ProvidesSetOfRequiresMultibindings {}
-
-  interface HasChildWithProvision {
-    ChildWithProvision childWithProvision();
-  }
-
-  interface HasChildWithoutProvision {
-    ChildWithoutProvision childWithoutProvision();
-  }
-
-  @Component(modules = ParentMultibindingModule.class)
-  interface ParentWithoutProvisionHasChildWithoutProvision extends HasChildWithoutProvision {}
-
-  @Component(modules = ParentMultibindingModule.class)
-  interface ParentWithoutProvisionHasChildWithProvision extends HasChildWithProvision {}
-
-  @Component(modules = ParentMultibindingModule.class)
-  interface ParentWithProvisionHasChildWithoutProvision
-      extends ParentWithProvision, HasChildWithoutProvision {}
-
-  @Component(modules = ParentMultibindingModule.class)
-  interface ParentWithProvisionHasChildWithProvision
-      extends ParentWithProvision, HasChildWithProvision {}
-
-  @Subcomponent(modules = ChildMultibindingModule.class)
-  interface ChildWithoutProvision {
-    Grandchild grandchild();
-  }
-
-  @Subcomponent(modules = ChildMultibindingModule.class)
-  interface ChildWithProvision
-      extends ProvidesBoundInParent, ProvidesBoundInParentAndChild, ProvidesBoundInChild,
-          ProvidesSetOfRequiresMultibindings {
-
-    Grandchild grandchild();
-  }
-
-  @Subcomponent
-  interface Grandchild
-      extends ProvidesBoundInParent, ProvidesBoundInParentAndChild, ProvidesBoundInChild,
-          ProvidesSetOfRequiresMultibindings {}
-
-  @Component(modules = ParentMultibindingModule.class)
-  interface ParentWithProvisionHasChildWithBinds extends ParentWithProvision {
-    ChildWithBinds childWithBinds();
-  }
-
-  @Subcomponent(modules = ChildMultibindingModuleWithOnlyBindsMultibindings.class)
-  interface ChildWithBinds extends ChildWithProvision {}
-
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/NeedsAnInterface.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/NeedsAnInterface.java
deleted file mode 100644
index e1d983180..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/NeedsAnInterface.java
+++ /dev/null
@@ -1,21 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-class NeedsAnInterface {
-  NeedsAnInterface(@SuppressWarnings("unused") AnInterface anInterface) {}
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
deleted file mode 100644
index 38f298adf..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponent.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import dagger.Component;
-import javax.inject.Singleton;
-import test.SomeQualifier;
-
-@Component(modules = {ParentModule.class, UnresolvableChildComponentModule.class})
-@Singleton
-interface ParentComponent extends ParentGetters {
-  ChildComponent newChildComponent();
-
-  ChildAbstractClassComponent newChildAbstractClassComponent();
-
-  ChildComponentRequiringModules newChildComponentRequiringModules(
-      ChildModuleWithParameters cmwp,
-      ChildModuleWithState childModuleWithState);
-
-  /**
-   * Requests a qualified version of this subcomponent builder, which does not install it as a
-   * subcomponent, but instead, uses the explicit binding of this qualified builder.
-   */
-  @SomeQualifier UnresolvableChildComponent.Builder unresolvableChildComponentBuilder();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentGetters.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentGetters.java
deleted file mode 100644
index 6614ddfe5..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentGetters.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import java.util.Set;
-import javax.inject.Provider;
-
-interface ParentGetters {
-  Provider<UnscopedType> getUnscopedTypeProvider();
-
-  Set<Object> objectSet();
-
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java
deleted file mode 100644
index dce3eadfa..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentModule.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import dagger.Binds;
-import dagger.Module;
-import dagger.Provides;
-import dagger.multibindings.IntoSet;
-import javax.inject.Singleton;
-
-@Module
-abstract class ParentModule {
-  @Provides
-  @IntoSet
-  static Object provideUnscopedObject() {
-    return new Object() {
-      @Override public String toString() {
-        return "unscoped in parent";
-      }
-    };
-  }
-
-  @Provides
-  @IntoSet
-  @Singleton
-  static Object provideSingletonObject() {
-    return new Object() {
-      @Override public String toString() {
-        return "singleton";
-      }
-    };
-  }
-
-  @Binds
-  @Singleton
-  @BoundAsSingleton
-  abstract UnscopedType provideUnscopedTypeBoundAsSingleton(UnscopedType unscopedType);
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentOfGenericComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentOfGenericComponent.java
deleted file mode 100644
index edd3095cb..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentOfGenericComponent.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import dagger.Component;
-import javax.inject.Singleton;
-
-@Component(modules = ParentModule.class)
-@Singleton
-interface ParentOfGenericComponent extends GenericParentComponent<ChildComponent>, ParentGetters {
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSingletons.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSingletons.java
deleted file mode 100644
index 2e9cadb57..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSingletons.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import javax.inject.Inject;
-
-final class RequiresSingletons {
-  private final SingletonType singletonType;
-  private final UnscopedType unscopedTypeBoundAsSingleton;
-
-  @Inject RequiresSingletons(SingletonType singletonType,
-      @BoundAsSingleton UnscopedType unscopedTypeBoundAsSingleton) {
-    this.singletonType = singletonType;
-    this.unscopedTypeBoundAsSingleton = unscopedTypeBoundAsSingleton;
-  }
-
-  SingletonType singletonType() {
-    return singletonType;
-  }
-
-  UnscopedType unscopedTypeBoundAsSingleton() {
-    return unscopedTypeBoundAsSingleton;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SingletonType.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SingletonType.java
deleted file mode 100644
index 68a063600..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SingletonType.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import javax.inject.Inject;
-import javax.inject.Singleton;
-
-@Singleton
-final class SingletonType {
-  @Inject SingletonType() {}
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/StaticChildModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/StaticChildModule.java
deleted file mode 100644
index 4896dd67a..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/StaticChildModule.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import dagger.Module;
-import dagger.Provides;
-
-@Module
-final class StaticChildModule {
-  private StaticChildModule() {}
-  
-  @Provides static Object provideStaticObject() {
-    return "static";
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SubcomponentFromModuleAndFactoryMethod.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SubcomponentFromModuleAndFactoryMethod.java
deleted file mode 100644
index 8a04944ab..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/SubcomponentFromModuleAndFactoryMethod.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import dagger.Component;
-import dagger.Module;
-import dagger.Subcomponent;
-
-/**
- * Tests for {@link Subcomponent}s which are defined with {@link Module#subcomponents()} and are
- * also requested as component factory methods.
- */
-public class SubcomponentFromModuleAndFactoryMethod {
-  @Subcomponent
-  interface Sub {
-    @Subcomponent.Builder
-    interface Builder {
-      Sub sub();
-    }
-  }
-
-  @Module(subcomponents = Sub.class)
-  class ModuleWithSubcomponent {}
-
-  @Component(modules = ModuleWithSubcomponent.class)
-  interface ExposesBuilder {
-    Sub.Builder subcomponentBuilder();
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/Unbound.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/Unbound.java
deleted file mode 100644
index e4c2338d5..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/Unbound.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import java.lang.annotation.Documented;
-import java.lang.annotation.Retention;
-import javax.inject.Qualifier;
-
-/**
- * A qualifier representing an unbound type, to verify that the compiler does not attempt to
- * generate code depending on it.
- */
-@Documented
-@Retention(RUNTIME)
-@Qualifier
-@interface Unbound {}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponent.java
deleted file mode 100644
index a7d470212..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponent.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import dagger.Subcomponent;
-
-/**
- * A subcomponent that's not resolvable in any parent component, for testing that qualified methods
- * on components that return subcomponents do not trigger actual subcomponents.
- */
-@Subcomponent
-interface UnresolvableChildComponent {
-  /**
-   * Requests a type that is never bound in any component that this subcomponent might be installed
-   * in. If this subcomponent is ever attempted to be installed in a component, then it will produce
-   * a compiler error.
-   */
-  @Unbound
-  String unboundString();
-
-  @Subcomponent.Builder
-  interface Builder {
-    UnresolvableChildComponent build();
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponentModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponentModule.java
deleted file mode 100644
index 34aa73e95..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnresolvableChildComponentModule.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import dagger.Module;
-import dagger.Provides;
-import test.SomeQualifier;
-
-@Module
-final class UnresolvableChildComponentModule {
-  /**
-   * Provides a qualified version of the {@link UnresolvableChildComponent}'s builder. If the
-   * subcomponent were actually installed in a component, this would be a duplicate binding; but
-   * since that doesn't happen, this binding is OK.
-   */
-  @Provides
-  @SomeQualifier
-  static UnresolvableChildComponent.Builder unresolvableChildComponentBuilder() {
-    return new UnresolvableChildComponent.Builder() {
-      @Override
-      public UnresolvableChildComponent build() {
-        return new UnresolvableChildComponent() {
-          @Override
-          public String unboundString() {
-            return "unbound";
-          }
-        };
-      }
-    };
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnscopedType.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnscopedType.java
deleted file mode 100644
index 620df47b5..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UnscopedType.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import javax.inject.Inject;
-
-final class UnscopedType {
-  @Inject UnscopedType(@SuppressWarnings("unused") SingletonType singletonType) {}
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UsesModuleSubcomponents.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UsesModuleSubcomponents.java
deleted file mode 100644
index 9c7ba3111..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/UsesModuleSubcomponents.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import dagger.Component;
-import dagger.Module;
-import dagger.Provides;
-import dagger.Subcomponent;
-import dagger.multibindings.IntoSet;
-import java.util.Set;
-import javax.inject.Inject;
-
-/** Supporting types for {@link ModuleWithSubcomponentsTest}. */
-@Component(modules = UsesModuleSubcomponents.ModuleWithSubcomponents.class)
-public interface UsesModuleSubcomponents {
-  UsesChild usesChild();
-
-  Set<String> strings();
-
-  @Module(subcomponents = Child.class, includes = AlsoIncludesSubcomponents.class)
-  class ModuleWithSubcomponents {
-    @Provides
-    @IntoSet
-    static String provideStringInParent() {
-      return "from parent";
-    }
-  }
-
-  @Module(subcomponents = Child.class)
-  class AlsoIncludesSubcomponents {}
-
-  @Subcomponent(modules = ChildModule.class)
-  interface Child {
-    Set<String> strings();
-
-    @Subcomponent.Builder
-    interface Builder {
-      Child build();
-    }
-  }
-
-  @Module
-  class ChildModule {
-    @Provides
-    @IntoSet
-    static String provideStringInChild() {
-      return "from child";
-    }
-  }
-
-  class UsesChild {
-    Set<String> strings;
-
-    @Inject
-    UsesChild(Child.Builder childBuilder) {
-      this.strings = childBuilder.build().strings();
-    }
-  }
-
-  @Module(includes = ModuleWithSubcomponents.class)
-  class OnlyIncludesModuleWithSubcomponents {}
-
-  @Component(modules = OnlyIncludesModuleWithSubcomponents.class)
-  interface ParentIncludesSubcomponentTransitively extends UsesModuleSubcomponents {}
-
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/ChildComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/ChildComponent.java
deleted file mode 100644
index 5f7c0258a..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/ChildComponent.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent.hiding;
-
-import dagger.Subcomponent;
-
-@Subcomponent(modules = test.subcomponent.hiding.b.CommonModuleName.class)
-interface ChildComponent {
-  //ensure that t.s.h.a.CommonName gets bound in this component
-  test.subcomponent.hiding.a.CommonName aCommonName();
-  //ensure that t.s.h.b.CommonName gets bound in this component
-  test.subcomponent.hiding.b.CommonName bCommonName();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/ParentComponent.java
deleted file mode 100644
index ffbea8fe4..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/ParentComponent.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent.hiding;
-
-import dagger.Component;
-import javax.inject.Singleton;
-
-@Component(modules = test.subcomponent.hiding.a.CommonModuleName.class)
-@Singleton
-interface ParentComponent {
-  // ensure that t.s.h.a.CommonName gets bound in this component
-  test.subcomponent.hiding.a.CommonName aCommonName();
-
-  ChildComponent newChildComponent();
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/a/CommonModuleName.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/a/CommonModuleName.java
deleted file mode 100644
index 8fbbd6f15..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/a/CommonModuleName.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent.hiding.a;
-
-import dagger.Module;
-import dagger.Provides;
-
-@Module
-public class CommonModuleName {
-  @Provides String provideString() {
-    return "a";
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/a/CommonName.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/a/CommonName.java
deleted file mode 100644
index 864799f30..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/a/CommonName.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent.hiding.a;
-
-import javax.inject.Inject;
-
-public final class CommonName {
-  private final String s;
-
-  @Inject CommonName(String s) {
-    this.s = s;
-  }
-
-  @Override
-  public String toString() {
-    return s;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/b/CommonModuleName.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/b/CommonModuleName.java
deleted file mode 100644
index 10f5a1f32..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/b/CommonModuleName.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent.hiding.b;
-
-import dagger.Module;
-import dagger.Provides;
-
-@Module
-public class CommonModuleName {
-  @Provides int provideString() {
-    return 1;
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/b/CommonName.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/b/CommonName.java
deleted file mode 100644
index 21c1a115c..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/hiding/b/CommonName.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent.hiding.b;
-
-import javax.inject.Inject;
-
-public final class CommonName {
-  private final int i;
-
-  @Inject CommonName(int i) {
-    this.i = i;
-  }
-
-  @Override
-  public String toString() {
-    return Integer.toString(i);
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/pruning/ParentDoesntUseSubcomponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/pruning/ParentDoesntUseSubcomponent.java
deleted file mode 100644
index 3126f13f3..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/pruning/ParentDoesntUseSubcomponent.java
+++ /dev/null
@@ -1,95 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent.pruning;
-
-import dagger.Component;
-import dagger.Module;
-import dagger.Provides;
-import dagger.Subcomponent;
-import dagger.multibindings.IntoSet;
-import java.util.Set;
-import javax.inject.Qualifier;
-
-/**
- * Supporting types for {@link SubcomponentOnlyRequestedBySiblingTest}. {@link ChildA} is a direct
- * child of the top level component, but is only requested within its sibling, not directly from its
- * parent.
- */
-@Component(modules = ParentDoesntUseSubcomponent.ParentModule.class)
-interface ParentDoesntUseSubcomponent {
-
-  ChildB.Builder childBBuilder();
-
-  @Subcomponent(modules = ChildAModule.class)
-  interface ChildA {
-    @Subcomponent.Builder
-    interface Builder {
-      ChildA build();
-    }
-
-    Set<Class<?>> componentHierarchy();
-  }
-
-  @Subcomponent(modules = ChildBModule.class)
-  interface ChildB {
-    @Subcomponent.Builder
-    interface Builder {
-      ChildB build();
-    }
-
-    Set<Class<?>> componentHierarchy();
-
-    @FromChildA
-    Set<Class<?>> componentHierarchyFromChildA();
-  }
-
-  @Module(subcomponents = {ChildA.class, ChildB.class})
-  class ParentModule {
-    @Provides
-    @IntoSet
-    static Class<?> provideComponentType() {
-      return ParentDoesntUseSubcomponent.class;
-    }
-  }
-
-  @Module
-  class ChildAModule {
-    @Provides
-    @IntoSet
-    static Class<?> provideComponentType() {
-      return ChildA.class;
-    }
-  }
-
-  @Module
-  class ChildBModule {
-    @Provides
-    @IntoSet
-    static Class<?> provideComponentType() {
-      return ChildB.class;
-    }
-
-    @Provides
-    @FromChildA
-    Set<Class<?>> fromChildA(ChildA.Builder childABuilder) {
-      return childABuilder.build().componentHierarchy();
-    }
-  }
-
-  @Qualifier
-  @interface FromChildA {}
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OnlyUsedInChild.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OnlyUsedInChild.java
deleted file mode 100644
index 2dd8d20d3..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OnlyUsedInChild.java
+++ /dev/null
@@ -1,5 +0,0 @@
-package test.subcomponent.repeat;
-
-abstract class OnlyUsedInChild {
-
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OnlyUsedInParent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OnlyUsedInParent.java
deleted file mode 100644
index cc22b1e05..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OnlyUsedInParent.java
+++ /dev/null
@@ -1,5 +0,0 @@
-package test.subcomponent.repeat;
-
-abstract class OnlyUsedInParent {
-
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OtherSubcomponentWithRepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OtherSubcomponentWithRepeatedModule.java
deleted file mode 100644
index 31844a5ed..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/OtherSubcomponentWithRepeatedModule.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent.repeat;
-
-import dagger.Subcomponent;
-
-@Subcomponent(modules = RepeatedModule.class)
-interface OtherSubcomponentWithRepeatedModule extends SubcomponentWithRepeatedModule {
-
-  @Subcomponent.Builder
-  interface Builder {
-    Builder repeatedModule(RepeatedModule repeatedModule);
-
-    OtherSubcomponentWithRepeatedModule build();
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java
deleted file mode 100644
index 6ecfd17cc..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/ParentComponent.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent.repeat;
-
-import dagger.Component;
-import java.util.Set;
-
-@Component(modules = RepeatedModule.class)
-interface ParentComponent {
-  Object state();
-
-  String getString();
-  Set<String> getMultiboundStrings();
-  OnlyUsedInParent getOnlyUsedInParent();
-
-  SubcomponentWithRepeatedModule.Builder newChildComponentBuilder();
-
-  SubcomponentWithoutRepeatedModule newChildComponentWithoutRepeatedModule();
-
-  @Component.Builder
-  interface Builder {
-    Builder repeatedModule(RepeatedModule repeatedModule);
-
-    ParentComponent build();
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
deleted file mode 100644
index f4635e55e..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/RepeatedModule.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent.repeat;
-
-import dagger.Module;
-import dagger.Provides;
-import dagger.multibindings.IntoSet;
-
-@Module
-final class RepeatedModule {
-  private final Object state = new Object();
-
-  @Provides
-  Object state() {
-    return state;
-  }
-
-  @Provides
-  static String provideString() {
-    return "a string";
-  }
-
-  @Provides
-  @IntoSet
-  static String contributeString() {
-    return "a string in a set";
-  }
-
-  @Provides
-  static OnlyUsedInParent provideOnlyUsedInParent() {
-    return new OnlyUsedInParent() {};
-  }
-
-  @Provides
-  static OnlyUsedInChild provideOnlyUsedInChild() {
-    return new OnlyUsedInChild() {};
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java
deleted file mode 100644
index 4a3dd061e..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithRepeatedModule.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent.repeat;
-
-import dagger.Subcomponent;
-import java.util.Set;
-
-@Subcomponent(modules = RepeatedModule.class)
-interface SubcomponentWithRepeatedModule {
-  Object state();
-
-  String getString();
-
-  Set<String> getMultiboundStrings();
-
-  OnlyUsedInChild getOnlyUsedInChild();
-
-  @Subcomponent.Builder
-  interface Builder {
-    Builder repeatedModule(RepeatedModule repeatedModule);
-
-    SubcomponentWithRepeatedModule build();
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java
deleted file mode 100644
index e7829a025..000000000
--- a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java
+++ /dev/null
@@ -1,24 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent.repeat;
-
-import dagger.Subcomponent;
-
-@Subcomponent
-interface SubcomponentWithoutRepeatedModule {
-  OtherSubcomponentWithRepeatedModule.Builder newGrandchildBuilder();
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java b/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
deleted file mode 100644
index 5b298e620..000000000
--- a/compiler/src/it/functional-tests/src/test/java/test/BasicTest.java
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
-* Copyright (C) 2014 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package test;
-
-import static com.google.common.truth.Truth.assertThat;
-import static test.PrimitivesModule.BOUND_BOOLEAN;
-import static test.PrimitivesModule.BOUND_BOOLEAN_ARRAY;
-import static test.PrimitivesModule.BOUND_BYTE;
-import static test.PrimitivesModule.BOUND_BYTE_ARRAY;
-import static test.PrimitivesModule.BOUND_CHAR;
-import static test.PrimitivesModule.BOUND_CHAR_ARRAY;
-import static test.PrimitivesModule.BOUND_DOUBLE;
-import static test.PrimitivesModule.BOUND_DOUBLE_ARRAY;
-import static test.PrimitivesModule.BOUND_FLOAT;
-import static test.PrimitivesModule.BOUND_FLOAT_ARRAY;
-import static test.PrimitivesModule.BOUND_INT;
-import static test.PrimitivesModule.BOUND_INT_ARRAY;
-import static test.PrimitivesModule.BOUND_LONG;
-import static test.PrimitivesModule.BOUND_LONG_ARRAY;
-import static test.PrimitivesModule.BOUND_SHORT;
-import static test.PrimitivesModule.BOUND_SHORT_ARRAY;
-
-import dagger.Lazy;
-import javax.inject.Provider;
-import org.junit.experimental.theories.DataPoint;
-import org.junit.experimental.theories.Theories;
-import org.junit.experimental.theories.Theory;
-import org.junit.runner.RunWith;
-
-@RunWith(Theories.class)
-public class BasicTest {
-  @DataPoint
-  public static final BasicComponent basicComponent = DaggerBasicComponent.create();
-  @DataPoint
-  public static final BasicComponent abstractClassBasicComponent =
-      DaggerBasicAbstractClassComponent.create();
-
-  @Theory public void primitives(BasicComponent basicComponent) {
-    assertThat(basicComponent.getByte()).isEqualTo(BOUND_BYTE);
-    assertThat(basicComponent.getChar()).isEqualTo(BOUND_CHAR);
-    assertThat(basicComponent.getShort()).isEqualTo(BOUND_SHORT);
-    assertThat(basicComponent.getInt()).isEqualTo(BOUND_INT);
-    assertThat(basicComponent.getLong()).isEqualTo(BOUND_LONG);
-    assertThat(basicComponent.getBoolean()).isEqualTo(BOUND_BOOLEAN);
-    assertThat(basicComponent.getFloat()).isWithin(0).of(BOUND_FLOAT);
-    assertThat(basicComponent.getDouble()).isWithin(0).of(BOUND_DOUBLE);
-  }
-
-  @Theory public void boxedPrimitives(BasicComponent basicComponent) {
-    assertThat(basicComponent.getBoxedByte()).isEqualTo(new Byte(BOUND_BYTE));
-    assertThat(basicComponent.getBoxedChar()).isEqualTo(new Character(BOUND_CHAR));
-    assertThat(basicComponent.getBoxedShort()).isEqualTo(new Short(BOUND_SHORT));
-    assertThat(basicComponent.getBoxedInt()).isEqualTo(new Integer(BOUND_INT));
-    assertThat(basicComponent.getBoxedLong()).isEqualTo(new Long(BOUND_LONG));
-    assertThat(basicComponent.getBoxedBoolean()).isEqualTo(new Boolean(BOUND_BOOLEAN));
-    assertThat(basicComponent.getBoxedFloat()).isWithin(0).of(BOUND_FLOAT);
-    assertThat(basicComponent.getBoxedDouble()).isWithin(0).of(BOUND_DOUBLE);
-  }
-
-  @Theory public void boxedPrimitiveProviders(BasicComponent basicComponent) {
-    assertThat(basicComponent.getByteProvider().get()).isEqualTo(new Byte(BOUND_BYTE));
-    assertThat(basicComponent.getCharProvider().get()).isEqualTo(new Character(BOUND_CHAR));
-    assertThat(basicComponent.getShortProvider().get()).isEqualTo(new Short(BOUND_SHORT));
-    assertThat(basicComponent.getIntProvider().get()).isEqualTo(new Integer(BOUND_INT));
-    assertThat(basicComponent.getLongProvider().get()).isEqualTo(new Long(BOUND_LONG));
-    assertThat(basicComponent.getBooleanProvider().get()).isEqualTo(new Boolean(BOUND_BOOLEAN));
-    assertThat(basicComponent.getFloatProvider().get()).isWithin(0).of(BOUND_FLOAT);
-    assertThat(basicComponent.getDoubleProvider().get()).isWithin(0).of(BOUND_DOUBLE);
-  }
-
-  @Theory public void primitiveArrays(BasicComponent basicComponent) {
-    assertThat(basicComponent.getByteArray()).isSameAs(BOUND_BYTE_ARRAY);
-    assertThat(basicComponent.getCharArray()).isSameAs(BOUND_CHAR_ARRAY);
-    assertThat(basicComponent.getShortArray()).isSameAs(BOUND_SHORT_ARRAY);
-    assertThat(basicComponent.getIntArray()).isSameAs(BOUND_INT_ARRAY);
-    assertThat(basicComponent.getLongArray()).isSameAs(BOUND_LONG_ARRAY);
-    assertThat(basicComponent.getBooleanArray()).isSameAs(BOUND_BOOLEAN_ARRAY);
-    assertThat(basicComponent.getFloatArray()).isSameAs(BOUND_FLOAT_ARRAY);
-    assertThat(basicComponent.getDoubleArray()).isSameAs(BOUND_DOUBLE_ARRAY);
-  }
-
-  @Theory public void primitiveArrayProviders(BasicComponent basicComponent) {
-    assertThat(basicComponent.getByteArrayProvider().get()).isSameAs(BOUND_BYTE_ARRAY);
-    assertThat(basicComponent.getCharArrayProvider().get()).isSameAs(BOUND_CHAR_ARRAY);
-    assertThat(basicComponent.getShortArrayProvider().get()).isSameAs(BOUND_SHORT_ARRAY);
-    assertThat(basicComponent.getIntArrayProvider().get()).isSameAs(BOUND_INT_ARRAY);
-    assertThat(basicComponent.getLongArrayProvider().get()).isSameAs(BOUND_LONG_ARRAY);
-    assertThat(basicComponent.getBooleanArrayProvider().get()).isSameAs(BOUND_BOOLEAN_ARRAY);
-    assertThat(basicComponent.getFloatArrayProvider().get()).isSameAs(BOUND_FLOAT_ARRAY);
-    assertThat(basicComponent.getDoubleArrayProvider().get()).isSameAs(BOUND_DOUBLE_ARRAY);
-  }
-
-  @Theory public void noOpMembersInjection(BasicComponent basicComponent) {
-    Object object = new Object();
-    assertThat(basicComponent.noOpMembersInjection(object)).isSameAs(object);
-  }
-
-  @Theory public void basicObject_noDeps(BasicComponent basicComponent) {
-    assertThat(basicComponent.thing()).isNotNull();
-  }
-
-  @Theory public void inheritedMembersInjection(BasicComponent basicComponent) {
-    assertThat(basicComponent.typeWithInheritedMembersInjection().thing).isNotNull();
-  }
-  
-  @Theory
-  public void nullableInjection(BasicComponent basicComponent) {
-    assertThat(basicComponent.nullObject()).isNull();
-    assertThat(basicComponent.nullObjectProvider().get()).isNull();
-    assertThat(basicComponent.lazyNullObject().get()).isNull();
-  }
-  
-  @Theory
-  public void providerOfLazy(BasicComponent basicComponent) {
-    Provider<Lazy<InjectedThing>> lazyInjectedThingProvider =
-        basicComponent.lazyInjectedThingProvider();
-    Lazy<InjectedThing> lazyInjectedThing1 = lazyInjectedThingProvider.get();
-    Lazy<InjectedThing> lazyInjectedThing2 = lazyInjectedThingProvider.get();
-    assertThat(lazyInjectedThing2).isNotSameAs(lazyInjectedThing1);
-    assertThat(lazyInjectedThing1.get()).isSameAs(lazyInjectedThing1.get());
-    assertThat(lazyInjectedThing2.get()).isSameAs(lazyInjectedThing2.get());
-    assertThat(lazyInjectedThing2.get()).isNotSameAs(lazyInjectedThing1.get());
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/DependsOnGeneratedCodeTest.java b/compiler/src/it/functional-tests/src/test/java/test/DependsOnGeneratedCodeTest.java
deleted file mode 100644
index 418f9f9fb..000000000
--- a/compiler/src/it/functional-tests/src/test/java/test/DependsOnGeneratedCodeTest.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
-* Copyright (C) 2015 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package test;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-/**
- * @see <a href="http://b/19435358">Bug 19435358</a>
- */
-@RunWith(JUnit4.class)
-public class DependsOnGeneratedCodeTest {
-  @Test public void testComponentDependsOnGeneratedCode() {
-    assertThat(DaggerComponentDependsOnGeneratedCode.create().needsFactory()).isNotNull();
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java b/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java
deleted file mode 100644
index 0bb10b20b..000000000
--- a/compiler/src/it/functional-tests/src/test/java/test/GenericTest.java
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.assertEquals;
-
-import java.util.ArrayList;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Set;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import test.sub.Exposed;
-import test.sub.PublicSubclass;
-
-@RunWith(JUnit4.class)
-public class GenericTest {
-
-  @Test public void testGenericComponentCreate() {
-    GenericComponent component = DaggerGenericComponent.create();
-    assertThat(component).isNotNull();
-  }
-  
-  @Test public void testGenericSimpleReferences() {
-    GenericComponent component = DaggerGenericComponent.create();
-    assertThat(component.referencesGeneric().genericA.t).isNotNull();    
-  }
-  
-  @Test public void testGenericDoubleReferences() {
-    GenericComponent component = DaggerGenericComponent.create();
-    GenericDoubleReferences<A> doubleA = component.doubleGenericA();
-    assertThat(doubleA.a).isNotNull();
-    assertThat(doubleA.a2).isNotNull();
-    assertThat(doubleA.t).isNotNull();
-    assertThat(doubleA.t2).isNotNull();
-
-    GenericDoubleReferences<B> doubleB = component.doubleGenericB();
-    assertThat(doubleB.a).isNotNull();
-    assertThat(doubleB.a2).isNotNull();
-    assertThat(doubleB.t).isNotNull();
-    assertThat(doubleB.t2).isNotNull();
-  }
-  
-  @Test public void complexGenerics() {
-    GenericComponent component = DaggerGenericComponent.create();
-    // validate these can be called w/o exceptions.
-    component.complexGenerics();
-  }
-  
-  @Test public void noDepsGenerics() {
-    GenericComponent component = DaggerGenericComponent.create();
-    // validate these can be called w/o exceptions.
-    component.noDepsA();
-    component.noDepsB();
-  }
-  
-  @Test public void boundedGenerics() {
-    BoundedGenericModule expected = new BoundedGenericModule();
-    BoundedGenericComponent component = DaggerBoundedGenericComponent.create();
-    BoundedGenerics<Integer, ArrayList<String>, LinkedList<CharSequence>, Integer, List<Integer>>
-        b1 = component.bounds1();
-    assertEquals(expected.provideInteger(), b1.a);
-    assertEquals(expected.provideArrayListString(), b1.b);
-    assertEquals(expected.provideLinkedListCharSeq(), b1.c);
-    assertEquals(expected.provideInteger(), b1.d);
-    assertEquals(expected.provideListOfInteger(), b1.e);
-
-    BoundedGenerics<Double, LinkedList<String>, LinkedList<Comparable<String>>, Double, Set<Double>>
-        b2 = component.bounds2();
-    assertEquals(expected.provideDouble(), b2.a);
-    assertEquals(expected.provideLinkedListString(), b2.b);
-    assertEquals(expected.provideArrayListOfComparableString(), b2.c);
-    assertEquals(expected.provideDouble(), b2.d);
-    assertEquals(expected.provideSetOfDouble(), b2.e);
-  }
-  
-  @Test public void membersInjections() {
-    GenericComponent component = DaggerGenericComponent.create();
-    GenericChild<A> childA = new GenericChild<A>();
-    component.injectA(childA);
-    assertThat(childA.a).isNotNull();
-    assertThat(childA.b).isNotNull();
-    assertThat(childA.registeredA).isNotNull();
-    assertThat(childA.registeredB).isNotNull();
-    assertThat(childA.registeredT).isNotNull();
-    assertThat(childA.registeredX).isNotNull();
-    assertThat(childA.registeredY).isNotNull();
-    
-    GenericChild<B> childB = new GenericChild<B>();
-    component.injectB(childB);
-    assertThat(childB.a).isNotNull();
-    assertThat(childB.b).isNotNull();
-    assertThat(childB.registeredA).isNotNull();
-    assertThat(childB.registeredB).isNotNull();
-    assertThat(childB.registeredT).isNotNull();
-    assertThat(childB.registeredX).isNotNull();
-    assertThat(childB.registeredY).isNotNull();
-  }
-  
-  @Test public void packagePrivateTypeParameterDependencies() {
-    GenericComponent component = DaggerGenericComponent.create();
-    Exposed exposed = component.exposed();
-    assertThat(exposed.gpp.t).isNotNull();
-    assertThat(exposed.gpp2).isNotNull();
-  }
-  
-  @SuppressWarnings("rawtypes")
-  @Test public void publicSubclassWithPackagePrivateTypeParameterOfSuperclass() {
-    GenericComponent component = DaggerGenericComponent.create();
-    PublicSubclass publicSubclass = component.publicSubclass();
-    assertThat(((Generic)publicSubclass).t).isNotNull();
-  }
-  
-  @Test public void singletonScopesAppliesToEachResolvedType() {
-    SingletonGenericComponent component = DaggerSingletonGenericComponent.create();
-    ScopedGeneric<A> a = component.scopedGenericA();
-    assertThat(a).isSameAs(component.scopedGenericA());
-    assertThat(a.t).isNotNull();
-    
-    ScopedGeneric<B> b = component.scopedGenericB();
-    assertThat(b).isSameAs(component.scopedGenericB());
-    assertThat(b.t).isNotNull();
-    
-    assertThat(a).isNotSameAs(b);
-  }
-  
-  @Test public void genericModules() {
-    GenericComponent component = DaggerGenericComponent.create();
-    assertThat(component.iterableInt()).containsExactly(1, 2).inOrder();
-    assertThat(component.iterableDouble()).containsExactly(3d, 4d).inOrder();
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java b/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
deleted file mode 100644
index 89b75cb13..000000000
--- a/compiler/src/it/functional-tests/src/test/java/test/MultibindingTest.java
+++ /dev/null
@@ -1,229 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
- * in compliance with the License. You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
- */
-
-package test;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import com.google.auto.value.AutoAnnotation;
-import com.google.common.collect.ImmutableList;
-import dagger.multibindings.ClassKey;
-import dagger.multibindings.StringKey;
-import java.math.BigDecimal;
-import java.math.BigInteger;
-import java.util.Map;
-import javax.inject.Provider;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
-
-@RunWith(Parameterized.class)
-public class MultibindingTest {
-
-  private static final MultibindingDependency MULTIBINDING_DEPENDENCY =
-      new MultibindingDependency() {
-        @Override
-        public double doubleDependency() {
-          return 0.0;
-        }
-      };
-
-  @Parameters(name = "{0}")
-  public static Iterable<Object[]> parameters() {
-    return ImmutableList.copyOf(
-        new Object[][] {
-          {
-            DaggerMultibindingComponent.builder()
-                .multibindingDependency(MULTIBINDING_DEPENDENCY)
-                .build()
-          },
-          {
-            DaggerMultibindingComponentWithMultibindingsInterface.builder()
-                .multibindingDependency(MULTIBINDING_DEPENDENCY)
-                .build()
-          }
-        });
-  }
-
-  private final MultibindingComponent multibindingComponent;
-
-  public MultibindingTest(MultibindingComponent multibindingComponent) {
-    this.multibindingComponent = multibindingComponent;
-  }
-
-  @Test public void map() {
-    Map<String, String> map = multibindingComponent.map();
-    assertThat(map).hasSize(2);
-    assertThat(map).containsEntry("foo", "foo value");
-    assertThat(map).containsEntry("bar", "bar value");
-  }
-
-  @Test public void mapOfArrays() {
-    Map<String, String[]> map = multibindingComponent.mapOfArrays();
-    assertThat(map).hasSize(2);
-    assertThat(map).containsKey("foo");
-    assertThat(map.get("foo")).asList().containsExactly("foo1", "foo2").inOrder();
-    assertThat(map).containsKey("bar");
-    assertThat(map.get("bar")).asList().containsExactly("bar1", "bar2").inOrder();
-  }
-
-  @Test public void mapOfProviders() {
-    Map<String, Provider<String>> mapOfProviders = multibindingComponent.mapOfProviders();
-    assertThat(mapOfProviders).hasSize(2);
-    assertThat(mapOfProviders.get("foo").get()).isEqualTo("foo value");
-    assertThat(mapOfProviders.get("bar").get()).isEqualTo("bar value");
-  }
-
-  @Test public void mapKeysAndValues() {
-    assertThat(multibindingComponent.mapKeys())
-        .containsExactly("foo", "bar");
-    assertThat(multibindingComponent.mapValues())
-        .containsExactly("foo value", "bar value");
-  }
-
-  @Test public void nestedKeyMap() {
-    assertThat(multibindingComponent.nestedKeyMap())
-        .containsExactly(
-            nestedWrappedKey(Integer.class), "integer", nestedWrappedKey(Long.class), "long");
-  }
-
-  @Test
-  public void unwrappedAnnotationKeyMap() {
-    assertThat(multibindingComponent.unwrappedAnnotationKeyMap())
-        .containsExactly(testStringKey("foo\n"), "foo annotation");
-  }
-
-  @Test
-  public void wrappedAnnotationKeyMap() {
-    @SuppressWarnings("unchecked")
-    Class<? extends Number>[] classes = new Class[] {Long.class, Integer.class};
-    assertThat(multibindingComponent.wrappedAnnotationKeyMap())
-        .containsExactly(
-            testWrappedAnnotationKey(
-                testStringKey("foo"), new int[] {1, 2, 3}, new ClassKey[] {}, classes),
-            "wrapped foo annotation");
-  }
-
-  @Test
-  public void booleanKeyMap() {
-    assertThat(multibindingComponent.booleanKeyMap()).containsExactly(true, "true");
-  }
-
-  @Test
-  public void byteKeyMap() {
-    assertThat(multibindingComponent.byteKeyMap()).containsExactly((byte) 100, "100 byte");
-  }
-
-  @Test
-  public void charKeyMap() {
-    assertThat(multibindingComponent.characterKeyMap())
-        .containsExactly('a', "a char", '\n', "newline char");
-  }
-
-  @Test
-  public void classKeyMap() {
-    assertThat(multibindingComponent.classKeyMap())
-        .containsExactly(Integer.class, "integer", Long.class, "long");
-  }
-
-  @Test
-  public void numberClassKeyMap() {
-    assertThat(multibindingComponent.numberClassKeyMap())
-        .containsExactly(BigDecimal.class, "bigdecimal", BigInteger.class, "biginteger");
-  }
-
-  @Test
-  public void intKeyMap() {
-    assertThat(multibindingComponent.integerKeyMap()).containsExactly(100, "100 int");
-  }
-
-  @Test
-  public void longKeyMap() {
-    assertThat(multibindingComponent.longKeyMap()).containsExactly((long) 100, "100 long");
-  }
-
-  @Test
-  public void shortKeyMap() {
-    assertThat(multibindingComponent.shortKeyMap()).containsExactly((short) 100, "100 short");
-  }
-
-  @Test public void setBindings() {
-    assertThat(multibindingComponent.set())
-        .containsExactly(-90, -17, -1, 5, 6, 832, 1742, -101, -102);
-  }
-
-  @Test
-  public void complexQualifierSet() {
-    assertThat(multibindingComponent.complexQualifierStringSet()).containsExactly("foo");
-  }
-
-  @Test
-  public void emptySet() {
-    assertThat(multibindingComponent.emptySet()).isEmpty();
-  }
-
-  @Test
-  public void emptyQualifiedSet() {
-    assertThat(multibindingComponent.emptyQualifiedSet()).isEmpty();
-  }
-
-  @Test
-  public void emptyMap() {
-    assertThat(multibindingComponent.emptyMap()).isEmpty();
-  }
-
-  @Test
-  public void emptyQualifiedMap() {
-    assertThat(multibindingComponent.emptyQualifiedMap()).isEmpty();
-  }
-
-  @Test
-  public void maybeEmptySet() {
-    assertThat(multibindingComponent.maybeEmptySet()).containsExactly("foo");
-  }
-
-  @Test
-  public void maybeEmptyQualifiedSet() {
-    assertThat(multibindingComponent.maybeEmptyQualifiedSet()).containsExactly("qualified foo");
-  }
-
-  @Test
-  public void maybeEmptyMap() {
-    assertThat(multibindingComponent.maybeEmptyMap()).containsEntry("key", "foo value");
-  }
-
-  @Test
-  public void maybeEmptyQualifiedMap() {
-    assertThat(multibindingComponent.maybeEmptyQualifiedMap())
-        .containsEntry("key", "qualified foo value");
-  }
-
-  @AutoAnnotation
-  static StringKey testStringKey(String value) {
-    return new AutoAnnotation_MultibindingTest_testStringKey(value);
-  }
-
-  @AutoAnnotation
-  static NestedAnnotationContainer.NestedWrappedKey nestedWrappedKey(Class<?> value) {
-    return new AutoAnnotation_MultibindingTest_nestedWrappedKey(value);
-  }
-
-  @AutoAnnotation
-  static WrappedAnnotationKey testWrappedAnnotationKey(
-      StringKey value, int[] integers, ClassKey[] annotations, Class<? extends Number>[] classes) {
-    return new AutoAnnotation_MultibindingTest_testWrappedAnnotationKey(
-        value, integers, annotations, classes);
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/NestedTest.java b/compiler/src/it/functional-tests/src/test/java/test/NestedTest.java
deleted file mode 100644
index 09d2cbedf..000000000
--- a/compiler/src/it/functional-tests/src/test/java/test/NestedTest.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class NestedTest {
-  @Test public void nestedFoo() {
-    OuterClassFoo.NestedComponent nestedFoo = DaggerOuterClassFoo_NestedComponent.create();
-    assertThat(nestedFoo.thing()).isNotNull();
-  }
-
-  @Test public void nestedBar() {
-    OuterClassBar.NestedComponent nestedBar = DaggerOuterClassBar_NestedComponent.create();
-    assertThat(nestedBar.injectedThing()).isNotNull();
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/NonComponentDependencyTest.java b/compiler/src/it/functional-tests/src/test/java/test/NonComponentDependencyTest.java
deleted file mode 100644
index 6ed6691a2..000000000
--- a/compiler/src/it/functional-tests/src/test/java/test/NonComponentDependencyTest.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
-* Copyright (C) 2015 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package test;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class NonComponentDependencyTest {
-  @Test public void testThing() {
-    NonComponentDependencyComponent component =
-        DaggerNonComponentDependencyComponent.builder()
-            .thingComponent(new NonComponentDependencyComponent.ThingComponentImpl())
-            .build();
-    assertThat(component).isNotNull();
-    assertThat(component.thingTwo()).isNotNull();
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/ReleasableReferencesComponentsTest.java b/compiler/src/it/functional-tests/src/test/java/test/ReleasableReferencesComponentsTest.java
deleted file mode 100644
index 5d46da763..000000000
--- a/compiler/src/it/functional-tests/src/test/java/test/ReleasableReferencesComponentsTest.java
+++ /dev/null
@@ -1,381 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import static com.google.common.truth.Truth.assertThat;
-import static test.ReleasableReferencesComponents.Thing.thing;
-
-import com.google.auto.value.AutoAnnotation;
-import com.google.common.base.Function;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ListMultimap;
-import com.google.common.collect.Maps;
-import com.google.common.collect.Multimaps;
-import com.google.common.testing.GcFinalization;
-import com.google.common.testing.GcFinalization.FinalizationPredicate;
-import dagger.releasablereferences.ReleasableReferenceManager;
-import dagger.releasablereferences.TypedReleasableReferenceManager;
-import java.lang.annotation.Annotation;
-import java.lang.ref.WeakReference;
-import java.util.Map;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import test.ReleasableReferencesComponents.Child;
-import test.ReleasableReferencesComponents.ChildModule;
-import test.ReleasableReferencesComponents.ChildRegularScope;
-import test.ReleasableReferencesComponents.ChildReleasableScope1;
-import test.ReleasableReferencesComponents.ChildReleasableScope2;
-import test.ReleasableReferencesComponents.ChildReleasableScope3;
-import test.ReleasableReferencesComponents.Metadata1;
-import test.ReleasableReferencesComponents.Parent;
-import test.ReleasableReferencesComponents.ParentModule;
-import test.ReleasableReferencesComponents.ParentRegularScope;
-import test.ReleasableReferencesComponents.ParentReleasableScope1;
-import test.ReleasableReferencesComponents.ParentReleasableScope2;
-import test.ReleasableReferencesComponents.Thing;
-import test.ReleasableReferencesComponents.ThingComponent;
-
-@RunWith(JUnit4.class)
-public final class ReleasableReferencesComponentsTest {
-
-  private Parent component;
-  private ParentAsserts parentAsserts;
-  private ChildAsserts childAsserts;
-
-  @Before
-  public void setUp() {
-    component = DaggerReleasableReferencesComponents_Parent.create();
-    parentAsserts = new ParentAsserts(component);
-    childAsserts = parentAsserts.newChildAsserts();
-  }
-
-  @Test
-  public void releasableReferenceManagers() {
-    ImmutableMap<Class<? extends Annotation>, ReleasableReferenceManager> managers =
-        Maps.uniqueIndex(
-            component.managers(),
-            new Function<ReleasableReferenceManager, Class<? extends Annotation>>() {
-              @Override
-              public Class<? extends Annotation> apply(
-                  ReleasableReferenceManager releasableReferenceManager) {
-                return releasableReferenceManager.scope();
-              }
-            });
-    assertThat(managers)
-        .containsEntry(ParentReleasableScope1.class, component.parentReleasableScope1Manager());
-    assertThat(managers)
-        .containsEntry(ParentReleasableScope2.class, component.parentReleasableScope2Manager());
-    assertThat(managers)
-        .containsEntry(ChildReleasableScope1.class, component.childReleasableScope1Manager());
-    assertThat(managers)
-        .containsEntry(ChildReleasableScope2.class, component.childReleasableScope2Manager());
-    // Should contain a manager for ChildReleasableScope3 even though
-    // @ForReleasableReferences(Scope5.class) isn't needed.
-    assertThat(managers).containsKey(ChildReleasableScope3.class);
-  }
-
-  @Test
-  public void setOfTypedReleasableReferenceManagers() {
-    ListMultimap<Class<? extends Annotation>, Metadata1> managers =
-        Multimaps.transformValues(
-            Multimaps.index(
-                component.typedReleasableReferenceManagers1(),
-                new Function<TypedReleasableReferenceManager<?>, Class<? extends Annotation>>() {
-                  @Override
-                  public Class<? extends Annotation> apply(
-                      TypedReleasableReferenceManager<?> releasableReferenceManager) {
-                    return releasableReferenceManager.scope();
-                  }
-                }),
-            new Function<TypedReleasableReferenceManager<Metadata1>, Metadata1>() {
-              @Override
-              public Metadata1 apply(TypedReleasableReferenceManager<Metadata1> manager) {
-                return manager.metadata();
-              }
-            });
-    assertThat(managers)
-        .containsEntry(ParentReleasableScope2.class, metadata1("ParentReleasableScope2"));
-    assertThat(managers)
-        .containsEntry(ChildReleasableScope2.class, metadata1("ChildReleasableScope2.1"));
-    assertThat(managers)
-        .containsEntry(ChildReleasableScope3.class, metadata1("ChildReleasableScope3.1"));
-  }
-
-  @AutoAnnotation
-  static Metadata1 metadata1(String value) {
-    return new AutoAnnotation_ReleasableReferencesComponentsTest_metadata1(value);
-  }
-
-  @Test
-  public void basicScopingWorks() {
-    assertBindingCallCounts();
-    // assert again to make sure that the scoped bindings aren't called again
-    assertBindingCallCounts();
-  }
-
-  @Test
-  public void releaseThenGc() {
-    assertBindingCallCounts();
-    component.parentReleasableScope1Manager().releaseStrongReferences(); // release scope 1
-    assertBindingCallCounts(); // no change to scoped bindings
-    gcAndWaitUntilWeakReferencesCleared(
-        ParentModule.class, ChildModule.class, ParentReleasableScope1.class); // GC
-    parentAsserts.expectedCallsForParentReleasableScope1Thing++; // expect scope 1 bindings again
-    assertBindingCallCounts();
-  }
-
-  @Test
-  public void releaseThenRestoreThenGcThenRelease() {
-    assertBindingCallCounts();
-    component.parentReleasableScope2Manager().releaseStrongReferences(); // release scope 2
-    assertBindingCallCounts(); // no change to scoped bindings
-    component.parentReleasableScope2Manager().restoreStrongReferences(); // restore scope 2
-    assertBindingCallCounts(); // no change to scoped bindings
-    gcAndWaitUntilWeakReferencesCleared(ParentModule.class, ChildModule.class); // GC
-    assertBindingCallCounts(); // no change to scoped bindings
-
-    // Releasing again and GCing again means the binding is executed again.
-    component.parentReleasableScope2Manager().releaseStrongReferences(); // release scope 2
-    assertBindingCallCounts(); // no change to scoped bindings
-    gcAndWaitUntilWeakReferencesCleared(
-        ParentModule.class, ChildModule.class, ParentReleasableScope2.class); // GC
-    parentAsserts.expectedCallsForParentReleasableScope2Thing++; // expect scope 2 bindings again
-    assertBindingCallCounts();
-  }
-
-  @Test
-  public void subcomponentReleaseThenGc() {
-    assertBindingCallCounts();
-    component.childReleasableScope1Manager().releaseStrongReferences(); // release scope 3
-    assertBindingCallCounts(); // no change to scoped bindings
-    gcAndWaitUntilWeakReferencesCleared(
-        ParentModule.class, ChildModule.class, ChildReleasableScope1.class); // GC
-    childAsserts.expectedCallsForChildReleasableScope1Thing++; // expect scope 3 bindings again
-    assertBindingCallCounts();
-  }
-
-  @Test
-  public void subcomponentReleaseThenRestoreThenGcThenRelease() {
-    assertBindingCallCounts();
-    component.childReleasableScope2Manager().releaseStrongReferences(); // release scope 4
-    assertBindingCallCounts(); // no change to scoped bindings
-    component.childReleasableScope2Manager().restoreStrongReferences(); // restore scope 4
-    gcAndWaitUntilWeakReferencesCleared(ParentModule.class, ChildModule.class); // GC
-    assertBindingCallCounts(); // no change to scoped bindings
-    component.childReleasableScope2Manager().releaseStrongReferences(); // release scope 4
-    gcAndWaitUntilWeakReferencesCleared(
-        ParentModule.class, ChildModule.class, ChildReleasableScope2.class); // GC
-    childAsserts.expectedCallsForChildReleasableScope2Thing++; // expect scope 4 bindings again
-    assertBindingCallCounts();
-  }
-
-  @Test
-  public void twoInstancesOfSameSubcomponent() {
-    // Two instances of the same subcomponent.
-    ChildAsserts child2Asserts = parentAsserts.newChildAsserts();
-    childAsserts.assertBindingCallCounts();
-    child2Asserts.assertBindingCallCounts();
-
-    component.childReleasableScope1Manager().releaseStrongReferences(); // release scope 3
-    childAsserts.assertBindingCallCounts(); // no change to scoped bindings in child 1
-    child2Asserts.assertBindingCallCounts(); // no change to scoped bindings in child 2
-    gcAndWaitUntilWeakReferencesCleared(
-        ParentModule.class, ChildModule.class, ChildReleasableScope1.class); // GC
-    childAsserts.expectedCallsForChildReleasableScope1Thing++; // expect scope 3 bindings again
-    childAsserts.assertBindingCallCounts(); // when calling child.things()
-    child2Asserts.expectedCallsForChildReleasableScope1Thing++; // expect scope 3 bindings yet again
-    child2Asserts.assertBindingCallCounts(); // when calling child2.things()
-  }
-
-  private void assertBindingCallCounts() {
-    parentAsserts.assertBindingCallCounts();
-    childAsserts.assertBindingCallCounts();
-  }
-
-  /**
-   * Tries to run garbage collection, and waits for the {@link WeakReference}s to the {@link Thing}s
-   * in the maps last returned by {@link Parent#things()} and {@link Child#things()} for {@code
-   * keys} to be cleared.
-   */
-  void gcAndWaitUntilWeakReferencesCleared(final Class<?>... keys) {
-    GcFinalization.awaitDone(
-        new FinalizationPredicate() {
-          @Override
-          public boolean isDone() {
-            for (Class<?> key : keys) {
-              if (parentAsserts.weakThingReferenceUncollected(key)
-                  || childAsserts.weakThingReferenceUncollected(key)) {
-                return false;
-              }
-            }
-            return true;
-          }
-        });
-  }
-
-  /**
-   * Asserts that the map of {@link Thing}s in a {@link ThingComponent} matches expected values. Can
-   * also tell when certain values in the map have been finalized.
-   */
-  private abstract static class ThingAsserts {
-
-    private final ThingComponent component;
-    private ImmutableMap<Class<?>, WeakReference<Thing>> weakThings = ImmutableMap.of();
-
-    protected ThingAsserts(ThingComponent component) {
-      this.component = component;
-    }
-
-    /**
-     * Asserts that {@code component.things()} returns an expected map. Each time this is called,
-     * the current values in the map are wrapped in {@link WeakReference}s so we can {@linkplain
-     * #weakThingReferenceUncollected(Object) check whether they've been cleared} later.
-     */
-    final void assertBindingCallCounts() {
-      Map<Class<?>, Thing> things = component.things();
-      assertThat(things).containsExactlyEntriesIn(expectedThingMap());
-      weakThings =
-          ImmutableMap.copyOf(
-              Maps.transformValues(
-                  things,
-                  new Function<Thing, WeakReference<Thing>>() {
-                    @Override
-                    public WeakReference<Thing> apply(Thing thing) {
-                      return new WeakReference<>(thing);
-                    }
-                  }));
-    }
-
-    /** Returns the expected map. */
-    protected abstract ImmutableMap<Class<?>, Thing> expectedThingMap();
-
-    /**
-     * Returns {@code true} if the {@link WeakReference} to the {@link Thing} in the map returned by
-     * the last call to {@link #assertBindingCallCounts()} for the given key has not been cleared.
-     */
-    boolean weakThingReferenceUncollected(Object key) {
-      WeakReference<Thing> weakThing = weakThings.get(key);
-      return weakThing != null && weakThing.get() != null;
-    }
-  }
-
-  /** Asserts for the {@link Thing}s returned by {@link Parent#things()}. */
-  private static final class ParentAsserts extends ThingAsserts {
-    final Parent parent;
-
-    /**
-     * The number of times we expect the {@code @Provides @IntoMap @ClassKey(ParentModule.class)
-     * Thing} provider to have been called.
-     */
-    int expectedCallsForParentUnscopedThing;
-
-    /**
-     * The number of times we expect the
-     * {@code @Provides @IntoMap @ClassKey(ParentRegularScope.class) Thing} provider to have been
-     * called.
-     */
-    int expectedCallsForParentRegularScopeThing = 1;
-
-    /**
-     * The number of times we expect the
-     * {@code @Provides @IntoMap @ClassKey(ParentReleasableScope1.class) Thing} provider to have
-     * been called.
-     */
-    int expectedCallsForParentReleasableScope1Thing = 1;
-
-    /**
-     * The number of times we expect the
-     * {@code @Provides @IntoMap @ClassKey(ParentReleasableScope2.class) Thing} provider to have
-     * been called.
-     */
-    int expectedCallsForParentReleasableScope2Thing = 1;
-
-    ParentAsserts(Parent parent) {
-      super(parent);
-      this.parent = parent;
-    }
-
-    /**
-     * Returns an object that can make assertions for the {@link Thing}s returned by {@link
-     * Child#things()}.
-     */
-    ChildAsserts newChildAsserts() {
-      return new ChildAsserts(this, parent.child());
-    }
-
-    @Override
-    protected ImmutableMap<Class<?>, Thing> expectedThingMap() {
-      ++expectedCallsForParentUnscopedThing; // unscoped Thing @Provides method is always called
-      return ImmutableMap.of(
-          ParentModule.class, thing(expectedCallsForParentUnscopedThing),
-          ParentRegularScope.class, thing(expectedCallsForParentRegularScopeThing),
-          ParentReleasableScope1.class, thing(expectedCallsForParentReleasableScope1Thing),
-          ParentReleasableScope2.class, thing(expectedCallsForParentReleasableScope2Thing));
-    }
-  }
-
-  /** Asserts for the {@link Thing}s returned by {@link Child#things()}. */
-  private static final class ChildAsserts extends ThingAsserts {
-    final ParentAsserts parentAsserts;
-
-    /**
-     * The number of times we expect the {@code @Provides @IntoMap @ClassKey(ChildModule.class)
-     * Thing} provider to have been called.
-     */
-    int expectedCallsForChildUnscopedThing;
-
-    /**
-     * The number of times we expect the
-     * {@code @Provides @IntoMap @ClassKey(ChildRegularScope.class) Thing} provider to have been
-     * called.
-     */
-    int expectedCallsForChildRegularScopeThing = 1;
-
-    /**
-     * The number of times we expect the
-     * {@code @Provides @IntoMap @ClassKey(ChildReleasableScope1.class) Thing} provider to have been
-     * called.
-     */
-    int expectedCallsForChildReleasableScope1Thing = 1;
-
-    /**
-     * The number of times we expect the
-     * {@code @Provides @IntoMap @ClassKey(ChildReleasableScope2.class) Thing} provider to have been
-     * called.
-     */
-    int expectedCallsForChildReleasableScope2Thing = 1;
-
-    ChildAsserts(ParentAsserts parentAsserts, Child child) {
-      super(child);
-      this.parentAsserts = parentAsserts;
-    }
-
-    @Override
-    protected ImmutableMap<Class<?>, Thing> expectedThingMap() {
-      ++expectedCallsForChildUnscopedThing; // unscoped Thing @Provides method is always called
-      return new ImmutableMap.Builder<Class<?>, Thing>()
-          .putAll(parentAsserts.expectedThingMap())
-          .put(ChildModule.class, thing(expectedCallsForChildUnscopedThing))
-          .put(ChildRegularScope.class, thing(expectedCallsForChildRegularScopeThing))
-          .put(ChildReleasableScope1.class, thing(expectedCallsForChildReleasableScope1Thing))
-          .put(ChildReleasableScope2.class, thing(expectedCallsForChildReleasableScope2Thing))
-          .build();
-    }
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/ReusableTest.java b/compiler/src/it/functional-tests/src/test/java/test/ReusableTest.java
deleted file mode 100644
index 27aa425b6..000000000
--- a/compiler/src/it/functional-tests/src/test/java/test/ReusableTest.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import test.ComponentWithReusableBindings.ChildOne;
-import test.ComponentWithReusableBindings.ChildTwo;
-
-@RunWith(JUnit4.class)
-public class ReusableTest {
-  @Test
-  public void testReusable() {
-    ComponentWithReusableBindings parent = DaggerComponentWithReusableBindings.create();
-    ChildOne childOne = parent.childOne();
-    ChildTwo childTwo = parent.childTwo();
-
-    Object reusableInParent = parent.reusableInParent();
-    assertThat(parent.reusableInParent()).isSameAs(reusableInParent);
-    assertThat(childOne.reusableInParent()).isSameAs(reusableInParent);
-    assertThat(childTwo.reusableInParent()).isSameAs(reusableInParent);
-
-    Object reusableFromChildOne = childOne.reusableInChild();
-    assertThat(childOne.reusableInChild()).isSameAs(reusableFromChildOne);
-
-    Object reusableFromChildTwo = childTwo.reusableInChild();
-    assertThat(childTwo.reusableInChild()).isSameAs(reusableFromChildTwo);
-
-    assertThat(reusableFromChildTwo).isNotSameAs(reusableFromChildOne);
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/binds/BindsCollectionsWithoutMultibindingsTest.java b/compiler/src/it/functional-tests/src/test/java/test/binds/BindsCollectionsWithoutMultibindingsTest.java
deleted file mode 100644
index c9f5e93f6..000000000
--- a/compiler/src/it/functional-tests/src/test/java/test/binds/BindsCollectionsWithoutMultibindingsTest.java
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.binds;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import com.google.common.collect.ImmutableMap;
-import dagger.Binds;
-import dagger.Component;
-import dagger.Module;
-import dagger.Provides;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class BindsCollectionsWithoutMultibindingsTest {
-  @Module
-  abstract static class M {
-    @Provides
-    static HashSet<String> provideHashSet() {
-      HashSet<String> set = new HashSet<>();
-      set.add("binds");
-      set.add("set");
-      return set;
-    }
-
-    @Binds
-    abstract Set<String> bindStringSet(HashSet<String> set);
-
-    @Provides
-    static HashMap<String, String> provideHashMap() {
-      HashMap<String, String> map = new HashMap<>();
-      map.put("binds", "map");
-      map.put("without", "multibindings");
-      return map;
-    }
-
-    @Binds
-    abstract Map<String, String> bindStringMap(HashMap<String, String> map);
-  }
-
-  @Component(modules = M.class)
-  interface C {
-    Set<String> set();
-
-    Map<String, String> map();
-  }
-
-  @Test
-  public void works() {
-    C component = DaggerBindsCollectionsWithoutMultibindingsTest_C.create();
-
-    assertThat(component.set()).containsExactly("binds", "set");
-    assertThat(component.map())
-        .containsExactlyEntriesIn(
-            ImmutableMap.of(
-                "binds", "map",
-                "without", "multibindings"));
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/binds/BindsTest.java b/compiler/src/it/functional-tests/src/test/java/test/binds/BindsTest.java
deleted file mode 100644
index 2341e1ade..000000000
--- a/compiler/src/it/functional-tests/src/test/java/test/binds/BindsTest.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.binds;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import com.google.common.collect.ImmutableMap;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class BindsTest {
-
-  private TestComponent component;
-
-  @Before
-  public void setUp() {
-    component = DaggerTestComponent.create();
-  }
-
-  @Test
-  public void bindDelegates() {
-    assertThat(component.object()).isInstanceOf(FooOfStrings.class);
-    assertThat(component.fooOfStrings()).isInstanceOf(FooOfStrings.class);
-    assertThat(component.fooOfObjects()).isInstanceOf(FooOfObjects.class);
-    assertThat(component.fooOfIntegers()).isNotNull();
-  }
-
-  @Test
-  public void bindWithScope() {
-    assertThat(component.qualifiedFooOfStrings())
-        .isSameAs(component.qualifiedFooOfStrings());
-  }
-
-  @Test
-  public void multibindings() {
-    assertThat(component.foosOfNumbers()).hasSize(2);
-    assertThat(component.objects()).hasSize(3);
-    assertThat(component.charSequences()).hasSize(5);
-
-    assertThat(component.integerObjectMap())
-        .containsExactlyEntriesIn(
-            ImmutableMap.of(123, "123-string", 456, "456-string", 789, "789-string"));
-    assertThat(component.integerProviderOfObjectMap()).hasSize(3);
-    assertThat(component.integerProviderOfObjectMap().get(123).get()).isEqualTo("123-string");
-    assertThat(component.integerProviderOfObjectMap().get(456).get()).isEqualTo("456-string");
-    assertThat(component.integerProviderOfObjectMap().get(789).get()).isEqualTo("789-string");
-
-    assertThat(component.qualifiedIntegerObjectMap()).hasSize(1);
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java b/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java
deleted file mode 100644
index 02ce6e43f..000000000
--- a/compiler/src/it/functional-tests/src/test/java/test/builder/BuilderTest.java
+++ /dev/null
@@ -1,267 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.builder;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class BuilderTest {
-
-  @Test public void interfaceBuilder() {
-    TestComponentWithBuilderInterface.Builder builder =
-        DaggerTestComponentWithBuilderInterface.builder();
-
-    // Make sure things fail if we don't set our required modules.
-    try {
-      builder.build();
-      fail();
-    } catch(IllegalStateException expected) {}
-    
-    builder.intModule(new IntModuleIncludingDoubleAndFloat(1))
-        .stringModule(new StringModule("sam"))
-        .depComponent(new DepComponent() {});
-    builder.doubleModule(new DoubleModule());
-    // Don't set other modules -- make sure it works.
-    
-    TestComponentWithBuilderInterface component = builder.build();
-    assertThat(component.s()).isEqualTo("sam");
-    assertThat(component.i()).isEqualTo(1);
-    assertThat(component.d()).isWithin(0).of(4.2d);
-    assertThat(component.f()).isWithin(0).of(5.5f);
-    assertThat(component.l()).isEqualTo(6L);
-  }
-
-  @Test public void abstractClassBuilder() {
-    TestComponentWithBuilderAbstractClass.Builder builder =
-        TestComponentWithBuilderAbstractClass.builder();
-
-    // Make sure things fail if we don't set our required modules.
-    try {
-      builder.build();
-      fail();
-    } catch(IllegalStateException expected) {}
-    
-    builder.intModule(new IntModuleIncludingDoubleAndFloat(1))
-        .stringModule(new StringModule("sam"))
-        .depComponent(new DepComponent() {});
-    builder.doubleModule(new DoubleModule());
-    // Don't set other modules -- make sure it works.
-    
-    TestComponentWithBuilderAbstractClass component = builder.build();
-    assertThat(component.s()).isEqualTo("sam");
-    assertThat(component.i()).isEqualTo(1);
-    assertThat(component.d()).isWithin(0).of(4.2d);
-    assertThat(component.f()).isWithin(0).of(5.5f);
-    assertThat(component.l()).isEqualTo(6L);
-  }
-
-  @Test public void interfaceGenericBuilder() {
-    TestComponentWithGenericBuilderInterface.Builder builder =
-        DaggerTestComponentWithGenericBuilderInterface.builder();
-
-    // Make sure things fail if we don't set our required modules.
-    try {
-      builder.build();
-      fail();
-    } catch(IllegalStateException expected) {}
-    
-    builder.setM2(new IntModuleIncludingDoubleAndFloat(1))
-        .setM1(new StringModule("sam"))
-        .depComponent(new DepComponent() {});
-    builder.doubleModule(new DoubleModule());
-    // Don't set other modules -- make sure it works.
-    
-    TestComponentWithGenericBuilderInterface component = builder.build();
-    assertThat(component.s()).isEqualTo("sam");
-    assertThat(component.i()).isEqualTo(1);
-    assertThat(component.d()).isWithin(0).of(4.2d);
-    assertThat(component.f()).isWithin(0).of(5.5f);
-    assertThat(component.l()).isEqualTo(6L);
-  }
-
-  @Test public void abstractClassGenericBuilder() {
-    TestComponentWithGenericBuilderAbstractClass.Builder builder =
-        DaggerTestComponentWithGenericBuilderAbstractClass.builder();
-
-    // Make sure things fail if we don't set our required modules.
-    try {
-      builder.build();
-      fail();
-    } catch(IllegalStateException expected) {}
-    
-    builder.setM2(new IntModuleIncludingDoubleAndFloat(1))
-        .setM1(new StringModule("sam"))
-        .depComponent(new DepComponent() {});
-    builder.doubleModule(new DoubleModule());
-    // Don't set other modules -- make sure it works.
-    
-    TestComponentWithGenericBuilderAbstractClass component = builder.build();
-    assertThat(component.s()).isEqualTo("sam");
-    assertThat(component.i()).isEqualTo(1);
-    assertThat(component.d()).isWithin(0).of(4.2d);
-    assertThat(component.f()).isWithin(0).of(5.5f);
-    assertThat(component.l()).isEqualTo(6L);
-  }
-  
-  @Test public void subcomponents_interface() {
-    ParentComponent parent = DaggerParentComponent.create();    
-    TestChildComponentWithBuilderInterface.Builder builder1 = parent.childInterfaceBuilder();
-    try {
-      builder1.build();
-      fail();
-    } catch(IllegalStateException expected) {}
-    
-    builder1.setM2(new IntModuleIncludingDoubleAndFloat(1))
-        .setM1(new StringModule("sam"))
-        .set(new ByteModule((byte)7));
-    builder1.set(new FloatModule());
-    TestChildComponentWithBuilderInterface child1 = builder1.build();
-    assertThat(child1.s()).isEqualTo("sam");
-    assertThat(child1.i()).isEqualTo(1);
-    assertThat(child1.d()).isWithin(0).of(4.2d);
-    assertThat(child1.f()).isWithin(0).of(5.5f);
-    assertThat(child1.l()).isEqualTo(6L);
-    assertThat(child1.b()).isEqualTo((byte)7);
-  }
-  
-  @Test public void subcomponents_abstractclass() {
-    ParentComponent parent = DaggerParentComponent.create();
-    TestChildComponentWithBuilderAbstractClass.Builder builder2 =
-        parent.childAbstractClassBuilder();
-    try {
-      builder2.build();
-      fail();
-    } catch(IllegalStateException expected) {}
-    
-    builder2.setM2(new IntModuleIncludingDoubleAndFloat(10))
-        .setM1(new StringModule("tara"))
-        .set(new ByteModule((byte)70));
-    builder2.set(new FloatModule());
-    TestChildComponentWithBuilderAbstractClass child2 = builder2.build();
-    assertThat(child2.s()).isEqualTo("tara");
-    assertThat(child2.i()).isEqualTo(10);
-    assertThat(child2.d()).isWithin(0).of(4.2d);
-    assertThat(child2.f()).isWithin(0).of(5.5f);
-    assertThat(child2.l()).isEqualTo(6L);
-    assertThat(child2.b()).isEqualTo((byte)70);
-  }
-    
-  @Test
-  public void grandchildren() {
-    ParentComponent parent = DaggerParentComponent.create();
-    MiddleChild middle1 = parent.middleBuilder().set(new StringModule("sam")).build();
-    Grandchild grandchild1 =
-        middle1.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(21)).build();
-    Grandchild grandchild2 =
-        middle1.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(22)).build();
-    
-    assertThat(middle1.s()).isEqualTo("sam");
-    assertThat(grandchild1.i()).isEqualTo(21);
-    assertThat(grandchild1.s()).isEqualTo("sam");
-    assertThat(grandchild2.i()).isEqualTo(22);
-    assertThat(grandchild2.s()).isEqualTo("sam");
-
-    // Make sure grandchildren from newer children have no relation to the older ones.
-    MiddleChild middle2 = parent.middleBuilder().set(new StringModule("tara")).build();
-    Grandchild grandchild3 =
-        middle2.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(23)).build();
-    Grandchild grandchild4 =
-        middle2.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(24)).build();
-    
-    assertThat(middle2.s()).isEqualTo("tara");
-    assertThat(grandchild3.i()).isEqualTo(23);
-    assertThat(grandchild3.s()).isEqualTo("tara");
-    assertThat(grandchild4.i()).isEqualTo(24);
-    assertThat(grandchild4.s()).isEqualTo("tara");
-  }
-  
-  @Test
-  public void diamondGrandchildren() {
-    ParentComponent parent = DaggerParentComponent.create();
-    MiddleChild middle = parent.middleBuilder().set(new StringModule("sam")).build();
-    OtherMiddleChild other = parent.otherBuilder().set(new StringModule("tara")).build();
-    
-    Grandchild middlegrand =
-        middle.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(21)).build();
-    Grandchild othergrand =
-        other.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(22)).build();
-    
-    assertThat(middle.s()).isEqualTo("sam");
-    assertThat(other.s()).isEqualTo("tara");
-    assertThat(middlegrand.s()).isEqualTo("sam");
-    assertThat(othergrand.s()).isEqualTo("tara");
-    assertThat(middlegrand.i()).isEqualTo(21);
-    assertThat(othergrand.i()).isEqualTo(22);
-  }
-  
-  @Test
-  public void genericSubcomponentMethod() {
-    ParentOfGenericComponent parent =
-        DaggerParentOfGenericComponent.builder().stringModule(new StringModule("sam")).build();
-    Grandchild.Builder builder = parent.subcomponentBuilder();
-    Grandchild child = builder.set(new IntModuleIncludingDoubleAndFloat(21)).build();
-    assertThat(child.s()).isEqualTo("sam");
-    assertThat(child.i()).isEqualTo(21);
-  }
-  
-  @Test
-  public void requireSubcomponentBuilderProviders() {
-    ParentComponent parent = DaggerParentComponent.create();
-    MiddleChild middle =
-        parent
-            .requiresMiddleChildBuilder()
-            .subcomponentBuilderProvider()
-            .get()
-            .set(new StringModule("sam"))
-            .build();
-    Grandchild grandchild =
-        middle
-            .requiresGrandchildBuilder()
-            .subcomponentBuilderProvider()
-            .get()
-            .set(new IntModuleIncludingDoubleAndFloat(12))
-            .build();
-    assertThat(middle.s()).isEqualTo("sam");
-    assertThat(grandchild.i()).isEqualTo(12);
-    assertThat(grandchild.s()).isEqualTo("sam");
-  }
-  
-  @Test
-  public void requireSubcomponentBuilders() {
-    ParentComponent parent = DaggerParentComponent.create();
-    MiddleChild middle =
-        parent
-            .requiresMiddleChildBuilder()
-            .subcomponentBuilder()
-            .set(new StringModule("sam"))
-            .build();
-    Grandchild grandchild =
-        middle
-            .requiresGrandchildBuilder()
-            .subcomponentBuilder()
-            .set(new IntModuleIncludingDoubleAndFloat(12))
-            .build();
-    assertThat(middle.s()).isEqualTo("sam");
-    assertThat(grandchild.i()).isEqualTo(12);
-    assertThat(grandchild.s()).isEqualTo("sam");
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/builderbinds/BuilderBindsTest.java b/compiler/src/it/functional-tests/src/test/java/test/builderbinds/BuilderBindsTest.java
deleted file mode 100644
index 01c73842e..000000000
--- a/compiler/src/it/functional-tests/src/test/java/test/builderbinds/BuilderBindsTest.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.builderbinds;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-
-import java.util.Arrays;
-import java.util.Collections;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import test.builderbinds.TestComponent.Builder;
-
-@RunWith(JUnit4.class)
-public final class BuilderBindsTest {
-
-  @Test
-  public void builderBinds() {
-    TestComponent.Builder builder =
-        DaggerTestComponent.builder()
-            .count(5)
-            .l(10L)
-            .input("foo")
-            .nullableInput("bar")
-            .listOfString(Arrays.asList("x", "y", "z"));
-    builder.boundInSubtype(20);
-    TestComponent component = builder.build();
-    assertThat(component.count()).isEqualTo(5);
-    assertThat(component.input()).isEqualTo("foo");
-    assertThat(component.nullableInput()).isEqualTo("bar");
-    assertThat(component.listOfString()).containsExactly("x", "y", "z").inOrder();
-  }
-
-  @Test
-  public void builderBindsNullableWithNull() {
-    Builder builder =
-        DaggerTestComponent.builder()
-            .count(5)
-            .l(10L)
-            .input("foo")
-            .nullableInput(null)
-            .listOfString(Collections.<String>emptyList());
-    builder.boundInSubtype(20);
-    TestComponent component = builder.build();
-
-    assertThat(component.count()).isEqualTo(5);
-    assertThat(component.input()).isEqualTo("foo");
-    assertThat(component.nullableInput()).isNull();
-    assertThat(component.listOfString()).isEmpty();
-  }
-
-  @Test
-  public void builderBindsNonNullableWithNull() {
-    try {
-      DaggerTestComponent.builder().count(5).l(10L).input(null);
-      fail("expected NullPointerException");
-    } catch (NullPointerException expected) {
-    }
-  }
-
-  @Test
-  public void builderBindsPrimitiveNotSet() {
-    try {
-      TestComponent.Builder builder =
-          DaggerTestComponent.builder()
-              .l(10L)
-              .input("foo")
-              .nullableInput("bar")
-              .listOfString(Collections.<String>emptyList());
-      builder.boundInSubtype(20);
-      builder.build();
-      fail("expected IllegalStateException");
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test
-  public void builderBindsNonNullableNotSet() {
-    try {
-      TestComponent.Builder builder =
-          DaggerTestComponent.builder()
-              .count(5)
-              .l(10L)
-              .nullableInput("foo")
-              .listOfString(Collections.<String>emptyList());
-      builder.boundInSubtype(20);
-      builder.build();
-      fail("expected IllegalStateException");
-    } catch (IllegalStateException expected) {
-    }
-  }
-
-  @Test
-  public void builderBindsNullableNotSet() {
-    Builder builder =
-        DaggerTestComponent.builder()
-            .count(5)
-            .l(10L)
-            .input("foo")
-            .listOfString(Collections.<String>emptyList());
-    builder.boundInSubtype(20);
-    TestComponent component = builder.build();
-    assertThat(component.count()).isEqualTo(5);
-    assertThat(component.input()).isEqualTo("foo");
-    assertThat(component.nullableInput()).isNull();
-    assertThat(component.listOfString()).isEmpty();
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/cycle/CycleTest.java b/compiler/src/it/functional-tests/src/test/java/test/cycle/CycleTest.java
deleted file mode 100644
index 1a62597dd..000000000
--- a/compiler/src/it/functional-tests/src/test/java/test/cycle/CycleTest.java
+++ /dev/null
@@ -1,92 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.cycle;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import test.cycle.Cycles.A;
-import test.cycle.Cycles.C;
-import test.cycle.Cycles.ChildCycleComponent;
-import test.cycle.Cycles.CycleComponent;
-import test.cycle.Cycles.CycleMapComponent;
-import test.cycle.Cycles.S;
-import test.cycle.Cycles.SelfCycleComponent;
-
-@RunWith(JUnit4.class)
-public class CycleTest {
-  @Test
-  public void providerIndirectionSelfCycle() {
-    SelfCycleComponent selfCycleComponent = DaggerCycles_SelfCycleComponent.create();
-    S s = selfCycleComponent.s();
-    assertThat(s.sProvider.get()).isNotNull();
-  }
-
-  @Test
-  public void providerIndirectionCycle() {
-    CycleComponent cycleComponent = DaggerCycles_CycleComponent.create();
-    A a = cycleComponent.a();
-    C c = cycleComponent.c();
-    assertThat(c.aProvider.get()).isNotNull();
-    assertThat(a.b.c.aProvider.get()).isNotNull();
-    assertThat(a.e.d.b.c.aProvider.get()).isNotNull();
-  }
-
-  @Test
-  public void lazyIndirectionSelfCycle() {
-    SelfCycleComponent selfCycleComponent = DaggerCycles_SelfCycleComponent.create();
-    S s = selfCycleComponent.s();
-    assertThat(s.sLazy.get()).isNotNull();
-  }
-
-  @Test
-  public void lazyIndirectionCycle() {
-    CycleComponent cycleComponent = DaggerCycles_CycleComponent.create();
-    A a = cycleComponent.a();
-    C c = cycleComponent.c();
-    assertThat(c.aLazy.get()).isNotNull();
-    assertThat(a.b.c.aLazy.get()).isNotNull();
-    assertThat(a.e.d.b.c.aLazy.get()).isNotNull();
-  }
-  
-  @Test
-  public void subcomponentIndirectionCycle() {
-    ChildCycleComponent childCycleComponent = DaggerCycles_CycleComponent.create().child();
-    A a = childCycleComponent.a();
-    assertThat(a.b.c.aProvider.get()).isNotNull();
-    assertThat(a.e.d.b.c.aProvider.get()).isNotNull();
-  }
-  
-  @Test
-  public void providerMapIndirectionCycle() {
-    CycleMapComponent cycleMapComponent = DaggerCycles_CycleMapComponent.create();
-    assertThat(cycleMapComponent.y()).isNotNull();
-    assertThat(cycleMapComponent.y().mapOfProvidersOfX).containsKey("X");
-    assertThat(cycleMapComponent.y().mapOfProvidersOfX.get("X")).isNotNull();
-    assertThat(cycleMapComponent.y().mapOfProvidersOfX.get("X").get()).isNotNull();
-    assertThat(cycleMapComponent.y().mapOfProvidersOfX.get("X").get().y).isNotNull();
-    assertThat(cycleMapComponent.y().mapOfProvidersOfX).hasSize(1);
-    assertThat(cycleMapComponent.y().mapOfProvidersOfY).containsKey("Y");
-    assertThat(cycleMapComponent.y().mapOfProvidersOfY.get("Y")).isNotNull();
-    assertThat(cycleMapComponent.y().mapOfProvidersOfY.get("Y").get()).isNotNull();
-    assertThat(cycleMapComponent.y().mapOfProvidersOfY.get("Y").get().mapOfProvidersOfX).hasSize(1);
-    assertThat(cycleMapComponent.y().mapOfProvidersOfY.get("Y").get().mapOfProvidersOfY).hasSize(1);
-    assertThat(cycleMapComponent.y().mapOfProvidersOfY).hasSize(1);
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/cycle/LongCycleTest.java b/compiler/src/it/functional-tests/src/test/java/test/cycle/LongCycleTest.java
deleted file mode 100644
index ce6293f93..000000000
--- a/compiler/src/it/functional-tests/src/test/java/test/cycle/LongCycleTest.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.cycle;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import test.cycle.LongCycle.LongCycleComponent;
-
-@RunWith(JUnit4.class)
-public class LongCycleTest {
-  
-  /**
-   * Tests a cycle long enough that the real factory is created in a separate initialize method from
-   * the delegate factory.
-   */
-  @Test
-  public void longCycle() {
-    LongCycleComponent longCycleComponent = DaggerLongCycle_LongCycleComponent.create();
-    assertThat(longCycleComponent.class1()).isNotNull();
-  }
-
-  /**
-   * Fails if {@link LongCycleComponent} doesn't have a long enough cycle to make sure the real
-   * factory is created in a separate method from the delegate factory.
-   */
-  @Test
-  public void longCycleHasMoreThanOneInitializeMethod() throws NoSuchMethodException {
-    DaggerLongCycle_LongCycleComponent.class
-        .getDeclaredMethod("initialize2", DaggerLongCycle_LongCycleComponent.Builder.class);
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java b/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java
deleted file mode 100644
index 82c67e381..000000000
--- a/compiler/src/it/functional-tests/src/test/java/test/membersinject/MembersInjectTest.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *  http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.membersinject;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import dagger.MembersInjector;
-import javax.inject.Provider;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import test.multipackage.DaggerMembersInjectionVisibilityComponent;
-import test.multipackage.MembersInjectionVisibilityComponent;
-import test.multipackage.a.AGrandchild;
-import test.multipackage.a.AParent;
-import test.multipackage.b.BChild;
-
-@RunWith(JUnit4.class)
-public class MembersInjectTest {
-  @Test public void testMembersInject_arrays() {
-    MembersInjectComponent component = DaggerMembersInjectComponent.builder().build();
-
-    ChildOfStringArray childOfStringArray = new ChildOfStringArray();
-    component.inject(childOfStringArray);
-  }
-
-  @Test public void testMembersInject_nestedArrays() {
-    MembersInjectComponent component = DaggerMembersInjectComponent.builder().build();
-
-    ChildOfArrayOfParentOfStringArray childOfArrayOfParentOfStringArray =
-        new ChildOfArrayOfParentOfStringArray();
-    component.inject(childOfArrayOfParentOfStringArray);
-  }
-
-  @Test public void testMembersInject_primitives() {
-    MembersInjectComponent component = DaggerMembersInjectComponent.builder().build();
-
-    ChildOfPrimitiveIntArray childOfPrimitiveIntArray = new ChildOfPrimitiveIntArray();
-    component.inject(childOfPrimitiveIntArray);
-  }
-
-  @Test
-  public void testMembersInject_overrides() {
-    MembersInjectionVisibilityComponent component =
-        DaggerMembersInjectionVisibilityComponent.create();
-    AParent aParent = new AParent();
-    component.inject(aParent);
-    assertThat(aParent.aParentField()).isNotNull();
-    assertThat(aParent.aParentMethod()).isNotNull();
-
-    BChild aChild = new BChild();
-    component.inject(aChild);
-    assertThat(aChild.aParentField()).isNotNull();
-    assertThat(aChild.aParentMethod()).isNull();
-    assertThat(aChild.aChildField()).isNotNull();
-    assertThat(aChild.aChildMethod()).isNotNull();
-
-    AGrandchild aGrandchild = new AGrandchild();
-    component.inject(aGrandchild);
-    assertThat(aGrandchild.aParentField()).isNotNull();
-    assertThat(aGrandchild.aParentMethod()).isNotNull();
-    assertThat(aGrandchild.aChildField()).isNotNull();
-    assertThat(aGrandchild.aChildMethod()).isNull();
-    assertThat(aGrandchild.aGrandchildField()).isNotNull();
-    assertThat(aGrandchild.aGrandchildMethod()).isNotNull();
-  }
-
-  @Test
-  public void testNonRequestedMembersInjector() {
-    NonRequestedChild child = new NonRequestedChild();
-    Provider<String> provider =
-        new Provider<String>() {
-          @Override
-          public String get() {
-            return "field!";
-          }
-        };
-    MembersInjector<NonRequestedChild> injector = new NonRequestedChild_MembersInjector(provider);
-    injector.injectMembers(child);
-    assertThat(child.t).isEqualTo("field!");
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/nullables/NullabilityTest.java b/compiler/src/it/functional-tests/src/test/java/test/nullables/NullabilityTest.java
deleted file mode 100644
index 0bc859d09..000000000
--- a/compiler/src/it/functional-tests/src/test/java/test/nullables/NullabilityTest.java
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
-* Copyright (C) 2015 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package test.nullables;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-
-import javax.inject.Provider;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class NullabilityTest {
-  @Test public void testNullability_provides() {
-    NullModule module = new NullModule();
-    NullComponent component = DaggerNullComponent.builder().nullModule(module).build();
-
-    // Can't construct NullFoo because it depends on Number, and Number was null.
-    try {
-      component.nullFoo();
-      fail();
-    } catch (NullPointerException npe) {
-      assertThat(npe).hasMessage("Cannot return null from a non-@Nullable @Provides method");
-    }
-
-    // set number to non-null so we can create
-    module.numberValue = 1;
-    NullFoo nullFoo = component.nullFoo();
-
-    // Then set it back to null so we can test its providers.
-    module.numberValue = null;
-    validate(true, nullFoo.string, nullFoo.stringProvider, nullFoo.numberProvider);
-    validate(true, nullFoo.methodInjectedString, nullFoo.methodInjectedStringProvider,
-        nullFoo.methodInjectedNumberProvider);
-    validate(true, nullFoo.fieldInjectedString, nullFoo.fieldInjectedStringProvider,
-        nullFoo.fieldInjectedNumberProvider);
-  }
-  
-  @Test public void testNullability_components() {
-    NullComponent nullComponent = new NullComponent() {      
-      @Override public Provider<String> stringProvider() {
-        return new Provider<String>() {
-          @Override public String get() {
-            return null;
-          }
-        };
-      }
-      
-      @Override public String string() {
-        return null;
-      }
-      
-      @Override public Provider<Number> numberProvider() {
-        return new Provider<Number>() {
-          @Override public Number get() {
-            return null;
-          }
-        };
-      }
-      
-      @Override public Number number() {
-        return null;
-      }
-      
-      @Override public NullFoo nullFoo() {
-        return null;
-      }
-    };
-    NullComponentWithDependency component =
-        DaggerNullComponentWithDependency.builder().nullComponent(nullComponent).build();
-    validate(false, component.string(), component.stringProvider(), component.numberProvider());
-    
-    // Also validate that the component's number() method fails
-    try {
-      component.number();
-      fail();
-    } catch (NullPointerException npe) {
-      assertThat(npe).hasMessage("Cannot return null from a non-@Nullable component method");
-    }
-  }
-
-  private void validate(boolean fromProvides,
-      String string,
-      Provider<String> stringProvider,
-      Provider<Number> numberProvider) {
-    assertThat(string).isNull();
-    assertThat(numberProvider).isNotNull();
-    try {
-      numberProvider.get();
-      fail();
-    } catch(NullPointerException npe) {
-      assertThat(npe).hasMessage("Cannot return null from a non-@Nullable "
-          + (fromProvides ? "@Provides" : "component") + " method");
-    }
-    assertThat(stringProvider.get()).isNull();
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/scope/ScopeTest.java b/compiler/src/it/functional-tests/src/test/java/test/scope/ScopeTest.java
deleted file mode 100644
index 7a3b1d94c..000000000
--- a/compiler/src/it/functional-tests/src/test/java/test/scope/ScopeTest.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.scope;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public final class ScopeTest {
-
-  @Test
-  public void testScope() {
-    ScopedComponent component = DaggerScopedComponent.create();
-    assertThat(component.set()).hasSize(4);
-    assertThat(component.set()).isEqualTo(component.set());
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java b/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java
deleted file mode 100644
index 76f3ba485..000000000
--- a/compiler/src/it/functional-tests/src/test/java/test/staticprovides/StaticProvidesTest.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.staticprovides;
-
-import static com.google.common.truth.Truth.assertThat;
-import static com.google.common.truth.Truth.assertWithMessage;
-
-import com.google.common.collect.ImmutableSet;
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.util.Arrays;
-import java.util.Collection;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameter;
-import org.junit.runners.Parameterized.Parameters;
-
-@RunWith(Parameterized.class)
-public class StaticProvidesTest {
-  @Parameters
-  public static Collection<Object[]> components() {
-    return Arrays.asList(new Object[][] {
-        {DaggerStaticTestComponent.create()},
-        {DaggerStaticTestComponentWithBuilder.builder().build()},
-        {DaggerStaticTestComponentWithBuilder.builder()
-          .allStaticModule(new AllStaticModule())
-          .someStaticModule(new SomeStaticModule())
-          .build()}});
-  }
-
-  @Parameter
-  public StaticTestComponent component;
-
-  @Test public void setMultibinding() {
-    assertThat(component.getMultiboundStrings()).isEqualTo(ImmutableSet.of(
-        AllStaticModule.class + ".contributeString",
-        SomeStaticModule.class + ".contributeStringFromAStaticMethod",
-        SomeStaticModule.class + ".contributeStringFromAnInstanceMethod"));
-  }
-
-  @Test public void allStaticProvidesModules_noFieldInComponentBuilder() {
-    for (Field field : DaggerStaticTestComponent.Builder.class.getDeclaredFields()) {
-      assertWithMessage(field.getName())
-          .that(field.getType()).isNotEqualTo(AllStaticModule.class);
-    }
-  }
-
-  @Test public void allStaticProvidesModules_deprecatedMethodInComponentBuilder() {
-    for (Method method : DaggerStaticTestComponent.Builder.class.getDeclaredMethods()) {
-      if (Arrays.asList(method.getParameterTypes()).contains(AllStaticModule.class)) {
-        assertWithMessage(method.getName())
-            .that(method.isAnnotationPresent(Deprecated.class))
-            .isTrue();
-      }
-    }
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/ModuleWithSubcomponentsTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/ModuleWithSubcomponentsTest.java
deleted file mode 100644
index 34dbf8825..000000000
--- a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/ModuleWithSubcomponentsTest.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import dagger.Module;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import test.subcomponent.UsesModuleSubcomponents.ParentIncludesSubcomponentTransitively;
-
-/** Tests for {@link Module#subcomponents()}. */
-@RunWith(JUnit4.class)
-public class ModuleWithSubcomponentsTest {
-
-  @Test
-  public void subcomponentFromModules() {
-    UsesModuleSubcomponents parent = DaggerUsesModuleSubcomponents.create();
-    assertThat(parent.strings()).containsExactly("from parent");
-    assertThat(parent.usesChild().strings).containsExactly("from parent", "from child");
-  }
-
-  @Test
-  public void subcomponentFromModules_transitively() {
-    ParentIncludesSubcomponentTransitively parent =
-        DaggerUsesModuleSubcomponents_ParentIncludesSubcomponentTransitively.create();
-    assertThat(parent.strings()).containsExactly("from parent");
-    assertThat(parent.usesChild().strings).containsExactly("from parent", "from child");
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java
deleted file mode 100644
index 3e0e52702..000000000
--- a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java
+++ /dev/null
@@ -1,282 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import test.subcomponent.MultibindingSubcomponents.BoundInChild;
-import test.subcomponent.MultibindingSubcomponents.BoundInParent;
-import test.subcomponent.MultibindingSubcomponents.BoundInParentAndChild;
-import test.subcomponent.MultibindingSubcomponents.ParentWithProvisionHasChildWithProvision;
-import test.subcomponent.MultibindingSubcomponents.ParentWithProvisionHasChildWithoutProvision;
-import test.subcomponent.MultibindingSubcomponents.ParentWithoutProvisionHasChildWithProvision;
-import test.subcomponent.MultibindingSubcomponents.ParentWithoutProvisionHasChildWithoutProvision;
-import test.subcomponent.MultibindingSubcomponents.RequiresMultibindings;
-
-@RunWith(JUnit4.class)
-public class SubcomponentMultibindingsTest {
-
-  private static final RequiresMultibindings<BoundInParent> BOUND_IN_PARENT =
-      new RequiresMultibindings<>(
-          ImmutableSet.of(BoundInParent.INSTANCE),
-          ImmutableMap.of("parent key", BoundInParent.INSTANCE));
-
-  private static final RequiresMultibindings<BoundInChild> BOUND_IN_CHILD =
-      new RequiresMultibindings<>(
-          ImmutableSet.of(BoundInChild.INSTANCE),
-          ImmutableMap.of("child key", BoundInChild.INSTANCE));
-
-  private static final RequiresMultibindings<BoundInParentAndChild> BOUND_IN_PARENT_AND_CHILD =
-      new RequiresMultibindings<>(
-          ImmutableSet.of(BoundInParentAndChild.IN_PARENT, BoundInParentAndChild.IN_CHILD),
-          ImmutableMap.of(
-              "parent key", BoundInParentAndChild.IN_PARENT,
-              "child key", BoundInParentAndChild.IN_CHILD));
-
-  private static final RequiresMultibindings<BoundInParentAndChild>
-      BOUND_IN_PARENT_AND_CHILD_PROVIDED_BY_PARENT =
-          new RequiresMultibindings<>(
-              ImmutableSet.of(BoundInParentAndChild.IN_PARENT),
-              ImmutableMap.of("parent key", BoundInParentAndChild.IN_PARENT));
-
-  private ParentWithoutProvisionHasChildWithoutProvision
-      parentWithoutProvisionHasChildWithoutProvision;
-  private ParentWithoutProvisionHasChildWithProvision parentWithoutProvisionHasChildWithProvision;
-  private ParentWithProvisionHasChildWithoutProvision parentWithProvisionHasChildWithoutProvision;
-  private ParentWithProvisionHasChildWithProvision parentWithProvisionHasChildWithProvision;
-
-  @Before
-  public void setUp() {
-    parentWithoutProvisionHasChildWithoutProvision =
-        DaggerMultibindingSubcomponents_ParentWithoutProvisionHasChildWithoutProvision.create();
-    parentWithoutProvisionHasChildWithProvision =
-        DaggerMultibindingSubcomponents_ParentWithoutProvisionHasChildWithProvision.create();
-    parentWithProvisionHasChildWithoutProvision =
-        DaggerMultibindingSubcomponents_ParentWithProvisionHasChildWithoutProvision.create();
-    parentWithProvisionHasChildWithProvision =
-        DaggerMultibindingSubcomponents_ParentWithProvisionHasChildWithProvision.create();
-  }
-
-  @Test
-  public void testParentWithoutProvisionHasChildWithoutProvision() {
-    // Child
-    assertThat(
-            parentWithoutProvisionHasChildWithoutProvision
-                .childWithoutProvision()
-                .grandchild()
-                .requiresMultibindingsBoundInParent())
-        .isEqualTo(BOUND_IN_PARENT);
-
-    // Grandchild
-    assertThat(
-            parentWithoutProvisionHasChildWithoutProvision
-                .childWithoutProvision()
-                .grandchild()
-                .requiresMultibindingsBoundInParentAndChild())
-        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
-    assertThat(
-            parentWithoutProvisionHasChildWithoutProvision
-                .childWithoutProvision()
-                .grandchild()
-                .requiresMultibindingsBoundInChild())
-        .isEqualTo(BOUND_IN_CHILD);
-
-    /*
-     * Even though the multibinding for Set<RequiresMultiboundObjects> does not itself have a
-     * contribution from the child, it must be pushed down to (not duplicated in) the child because
-     * its contribution depends on multibindings that have one contribution from the parent and one
-     * from the child.
-     *
-     */
-    assertThat(
-            parentWithoutProvisionHasChildWithoutProvision
-                .childWithoutProvision()
-                .grandchild()
-                .setOfRequiresMultibindingsInParentAndChild())
-        .containsExactly(BOUND_IN_PARENT_AND_CHILD);
-  }
-
-  @Test
-  public void testParentWithoutProvisionHasChildWithProvision() {
-    // Child
-    assertThat(
-            parentWithoutProvisionHasChildWithProvision
-                .childWithProvision()
-                .grandchild()
-                .requiresMultibindingsBoundInParent())
-        .isEqualTo(BOUND_IN_PARENT);
-
-    // Grandchild
-    assertThat(
-            parentWithoutProvisionHasChildWithProvision
-                .childWithProvision()
-                .grandchild()
-                .requiresMultibindingsBoundInParentAndChild())
-        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
-    assertThat(
-            parentWithoutProvisionHasChildWithProvision
-                .childWithProvision()
-                .grandchild()
-                .requiresMultibindingsBoundInChild())
-        .isEqualTo(BOUND_IN_CHILD);
-
-    /*
-     * Even though the multibinding for Set<RequiresMultiboundObjects> does not itself have a
-     * contribution from the child, it must be pushed down to (not duplicated in) the child because
-     * its contribution depends on multibindings that have one contribution from the parent and one
-     * from the child.
-     *
-     */
-    assertThat(
-            parentWithoutProvisionHasChildWithProvision
-                .childWithProvision()
-                .grandchild()
-                .setOfRequiresMultibindingsInParentAndChild())
-        .containsExactly(BOUND_IN_PARENT_AND_CHILD);
-  }
-
-  @Test
-  public void testParentWithProvisionHasChildWithoutProvision() {
-    // Parent
-    assertThat(parentWithProvisionHasChildWithoutProvision.requiresMultibindingsBoundInParent())
-        .isEqualTo(BOUND_IN_PARENT);
-
-    assertThat(
-            parentWithProvisionHasChildWithoutProvision
-                .requiresMultibindingsBoundInParentAndChild())
-        .isEqualTo(BOUND_IN_PARENT_AND_CHILD_PROVIDED_BY_PARENT);
-
-    // Grandchild
-    assertThat(
-            parentWithProvisionHasChildWithoutProvision
-                .childWithoutProvision()
-                .grandchild()
-                .requiresMultibindingsBoundInParent())
-        .isEqualTo(BOUND_IN_PARENT);
-    assertThat(
-            parentWithProvisionHasChildWithoutProvision
-                .childWithoutProvision()
-                .grandchild()
-                .requiresMultibindingsBoundInChild())
-        .isEqualTo(BOUND_IN_CHILD);
-
-    assertThat(
-            parentWithProvisionHasChildWithoutProvision
-                .childWithoutProvision()
-                .grandchild()
-                .requiresMultibindingsBoundInParentAndChild())
-        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
-
-    /*
-     * Even though the multibinding for Set<RequiresMultiboundObjects> does not itself have a
-     * contribution from the child, it must be pushed down to (not duplicated in) the child because
-     * its contribution depends on multibindings that have one contribution from the parent and one
-     * from the child.
-     *
-     */
-    assertThat(
-            parentWithProvisionHasChildWithoutProvision
-                .childWithoutProvision()
-                .grandchild()
-                .setOfRequiresMultibindingsInParentAndChild())
-        .containsExactly(BOUND_IN_PARENT_AND_CHILD);
-  }
-
-  @Test
-  public void testParentWithProvisionHasChildWithProvision() {
-    // Parent
-    assertThat(parentWithProvisionHasChildWithProvision.requiresMultibindingsBoundInParent())
-        .isEqualTo(BOUND_IN_PARENT);
-
-    // Child
-    assertThat(
-            parentWithProvisionHasChildWithProvision
-                .childWithProvision()
-                .requiresMultibindingsBoundInParent())
-        .isEqualTo(BOUND_IN_PARENT);
-    assertThat(
-            parentWithProvisionHasChildWithProvision
-                .childWithProvision()
-                .requiresMultibindingsBoundInChild())
-        .isEqualTo(BOUND_IN_CHILD);
-    assertThat(
-            parentWithProvisionHasChildWithProvision
-                .childWithProvision()
-                .requiresMultibindingsBoundInParentAndChild())
-        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
-
-    // https://github.com/google/dagger/issues/401
-    assertThat(
-        DaggerMultibindingSubcomponents_ParentWithProvisionHasChildWithBinds.create()
-            .childWithBinds()
-            .requiresMultibindingsBoundInParentAndChild())
-        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
-
-    /*
-     * Even though the multibinding for Set<RequiresMultiboundObjects> does not itself have a
-     * contribution from the child, it must be pushed down to (not duplicated in) the child because
-     * its contribution depends on multibindings that have one contribution from the parent and one
-     * from the child.
-     *
-     */
-    assertThat(
-            parentWithProvisionHasChildWithProvision
-                .childWithProvision()
-                .setOfRequiresMultibindingsInParentAndChild())
-        .containsExactly(BOUND_IN_PARENT_AND_CHILD);
-
-    // Grandchild
-    assertThat(
-            parentWithProvisionHasChildWithProvision
-                .childWithProvision()
-                .grandchild()
-                .requiresMultibindingsBoundInParent())
-        .isEqualTo(BOUND_IN_PARENT);
-    assertThat(
-            parentWithProvisionHasChildWithProvision
-                .childWithProvision()
-                .grandchild()
-                .requiresMultibindingsBoundInChild())
-        .isEqualTo(BOUND_IN_CHILD);
-    assertThat(
-            parentWithProvisionHasChildWithProvision
-                .childWithProvision()
-                .grandchild()
-                .requiresMultibindingsBoundInParentAndChild())
-        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
-
-    /*
-     * Even though the multibinding for Set<RequiresMultiboundObjects> does not itself have a
-     * contribution from the child, it must be pushed down to (not duplicated in) the child because
-     * its contribution depends on multibindings that have one contribution from the parent and one
-     * from the child.
-     *
-     */
-    assertThat(
-            parentWithProvisionHasChildWithProvision
-                .childWithProvision()
-                .grandchild()
-                .setOfRequiresMultibindingsInParentAndChild())
-        .containsExactly(BOUND_IN_PARENT_AND_CHILD);
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java
deleted file mode 100644
index 9c7b2118c..000000000
--- a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentTest.java
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent;
-
-import static com.google.common.collect.Sets.intersection;
-import static com.google.common.truth.Truth.assertThat;
-
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Set;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
-
-@RunWith(Parameterized.class)
-public class SubcomponentTest {
-  private static final ParentComponent parentComponent = DaggerParentComponent.create();
-  private static final ParentOfGenericComponent parentOfGenericComponent =
-      DaggerParentOfGenericComponent.create();
-  
-  @Parameters
-  public static Collection<Object[]> parameters() {
-    return Arrays.asList(new Object[][] {
-        { parentComponent, parentComponent.newChildComponent() },
-        { parentComponent, parentComponent.newChildAbstractClassComponent() },
-        { parentOfGenericComponent, parentOfGenericComponent.subcomponent() }});
-  }        
-  
-  private final ParentGetters parentGetters;
-  private final ChildComponent childComponent;
-  
-  public SubcomponentTest(ParentGetters parentGetters, ChildComponent childComponent) {
-    this.parentGetters = parentGetters;
-    this.childComponent = childComponent;
-  }
-  
-
-  @Test
-  public void scopePropagatesUpward_class() {
-    assertThat(childComponent.requiresSingleton().singletonType())
-        .isSameAs(childComponent.requiresSingleton().singletonType());
-    assertThat(childComponent.requiresSingleton().singletonType())
-        .isSameAs(childComponent.newGrandchildComponent().requiresSingleton().singletonType());
-  }
-
-  @Test
-  public void scopePropagatesUpward_provides() {
-    assertThat(childComponent
-        .requiresSingleton().unscopedTypeBoundAsSingleton())
-            .isSameAs(childComponent
-                .requiresSingleton().unscopedTypeBoundAsSingleton());
-    assertThat(childComponent
-        .requiresSingleton().unscopedTypeBoundAsSingleton())
-            .isSameAs(childComponent.newGrandchildComponent()
-                .requiresSingleton().unscopedTypeBoundAsSingleton());
-  }
-
-  @Test
-  public void multibindingContributions() {
-    Set<Object> parentObjectSet = parentGetters.objectSet();
-    assertThat(parentObjectSet).hasSize(2);
-    Set<Object> childObjectSet = childComponent.objectSet();
-    assertThat(childObjectSet).hasSize(3);
-    Set<Object> grandchildObjectSet =
-        childComponent.newGrandchildComponent().objectSet();
-    assertThat(grandchildObjectSet).hasSize(4);
-    assertThat(intersection(parentObjectSet, childObjectSet)).hasSize(1);
-    assertThat(intersection(parentObjectSet, grandchildObjectSet)).hasSize(1);
-    assertThat(intersection(childObjectSet, grandchildObjectSet)).hasSize(1);
-  }
-
-  @Test
-  public void unscopedProviders() {
-    assertThat(parentGetters.getUnscopedTypeProvider())
-        .isSameAs(childComponent.getUnscopedTypeProvider());
-    assertThat(parentGetters.getUnscopedTypeProvider())
-        .isSameAs(childComponent
-            .newGrandchildComponent()
-            .getUnscopedTypeProvider());
-  }
-
-  @Test
-  public void passedModules() {
-    ChildModuleWithState childModuleWithState = new ChildModuleWithState();
-    ChildComponentRequiringModules childComponent1 =
-        parentComponent.newChildComponentRequiringModules(
-            new ChildModuleWithParameters(new Object()),
-            childModuleWithState);
-    ChildComponentRequiringModules childComponent2 =
-        parentComponent.newChildComponentRequiringModules(
-            new ChildModuleWithParameters(new Object()),
-            childModuleWithState);
-    assertThat(childComponent1.getInt()).isEqualTo(0);
-    assertThat(childComponent2.getInt()).isEqualTo(1);
-  }
-
-  @Test
-  public void dependenceisInASubcomponent() {
-    assertThat(childComponent.newGrandchildComponent().needsAnInterface()).isNotNull();
-  }
-
-  @Test
-  public void qualifiedSubcomponentIsBound() {
-    assertThat(parentComponent.unresolvableChildComponentBuilder().build().unboundString())
-        .isEqualTo("unbound");
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/hiding/SubcomponentHidingTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/hiding/SubcomponentHidingTest.java
deleted file mode 100644
index 8b141fac0..000000000
--- a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/hiding/SubcomponentHidingTest.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent.hiding;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class SubcomponentHidingTest {
-  @Test public void moduleNameHiding() {
-    ParentComponent parent = DaggerParentComponent.create();
-    assertThat(parent.aCommonName().toString()).isEqualTo("a");
-    assertThat(parent.newChildComponent().aCommonName().toString()).isEqualTo("a");
-    assertThat(parent.newChildComponent().bCommonName().toString()).isEqualTo("1");
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/pruning/SubcomponentOnlyRequestedBySiblingTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/pruning/SubcomponentOnlyRequestedBySiblingTest.java
deleted file mode 100644
index fb856a73d..000000000
--- a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/pruning/SubcomponentOnlyRequestedBySiblingTest.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent.pruning;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import dagger.Module;
-import dagger.Subcomponent;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import test.subcomponent.pruning.ParentDoesntUseSubcomponent.ChildA;
-import test.subcomponent.pruning.ParentDoesntUseSubcomponent.ChildB;
-
-/**
- * Tests for {@link Subcomponent}s which are included with {@link Module#subcomponents()} but not
- * used directly within the component which adds them.
- *
- * <p>This tests to make sure that while resolving one subcomponent (A), another subcomponent (B)
- * can be requested if they have a shared ancestor component. If that shared ancestor did not
- * resolve B directly via any of its entry points, B will still be generated since it is requested
- * by a descendant.
- */
-@RunWith(JUnit4.class)
-public class SubcomponentOnlyRequestedBySiblingTest {
-  @Test
-  public void subcomponentAddedInParent_onlyUsedInSibling() {
-    ParentDoesntUseSubcomponent parent = DaggerParentDoesntUseSubcomponent.create();
-    ChildB childB = parent.childBBuilder().build();
-    assertThat(childB.componentHierarchy())
-        .containsExactly(ParentDoesntUseSubcomponent.class, ChildB.class);
-    assertThat(childB.componentHierarchyFromChildA())
-        .containsExactly(ParentDoesntUseSubcomponent.class, ChildA.class);
-  }
-}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/repeat/RepeatedModuleTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/repeat/RepeatedModuleTest.java
deleted file mode 100644
index e4b21c1ba..000000000
--- a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/repeat/RepeatedModuleTest.java
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.subcomponent.repeat;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public final class RepeatedModuleTest {
-  private ParentComponent parentComponent;
-
-  @Before
-  public void initializeParentComponent() {
-    this.parentComponent = DaggerParentComponent.builder().build();
-  }
-
-  @Test
-  public void repeatedModuleHasSameStateInSubcomponent() {
-    SubcomponentWithRepeatedModule childComponent =
-        parentComponent.newChildComponentBuilder().build();
-    assertThat(parentComponent.state()).isSameAs(childComponent.state());
-  }
-
-  @Test
-  public void repeatedModuleHasSameStateInGrandchildSubcomponent() {
-    SubcomponentWithoutRepeatedModule childComponent =
-        parentComponent.newChildComponentWithoutRepeatedModule();
-    SubcomponentWithRepeatedModule grandchildComponent =
-        childComponent.newGrandchildBuilder().build();
-    assertThat(parentComponent.state()).isSameAs(grandchildComponent.state());
-  }
-
-  @Test
-  public void repeatedModuleBuilderThrowsInSubcomponent() {
-    SubcomponentWithRepeatedModule.Builder childComponentBuilder =
-        parentComponent.newChildComponentBuilder();
-    try {
-      childComponentBuilder.repeatedModule(new RepeatedModule());
-      fail();
-    } catch (UnsupportedOperationException expected) {
-      assertThat(expected)
-          .hasMessage(
-              "test.subcomponent.repeat.RepeatedModule cannot be set "
-                  + "because it is inherited from the enclosing component");
-    }
-  }
-
-  @Test
-  public void repeatedModuleBuilderThrowsInGrandchildSubcomponent() {
-    SubcomponentWithoutRepeatedModule childComponent =
-        parentComponent.newChildComponentWithoutRepeatedModule();
-    OtherSubcomponentWithRepeatedModule.Builder grandchildComponentBuilder =
-        childComponent.newGrandchildBuilder();
-    try {
-      grandchildComponentBuilder.repeatedModule(new RepeatedModule());
-      fail();
-    } catch (UnsupportedOperationException expected) {
-      assertThat(expected)
-          .hasMessage(
-              "test.subcomponent.repeat.RepeatedModule cannot be set "
-                  + "because it is inherited from the enclosing component");
-    }
-  }
-}
diff --git a/compiler/src/it/guava-functional-tests/BUILD b/compiler/src/it/guava-functional-tests/BUILD
deleted file mode 100644
index a94af72b1..000000000
--- a/compiler/src/it/guava-functional-tests/BUILD
+++ /dev/null
@@ -1,53 +0,0 @@
-# Copyright (C) 2017 The Dagger Authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-# Description:
-#   Functional tests for Dagger that depend on Guava
-
-package(default_visibility = ["//:src"])
-
-load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX", "PRE_JAVA_8_INFERENCE_OPTS")
-
-java_library(
-    name = "code_under_test",
-    testonly = 1,
-    srcs = glob(["src/main/java/**/*.java"]),
-    javacopts = PRE_JAVA_8_INFERENCE_OPTS + DOCLINT_HTML_AND_SYNTAX,
-    deps = [
-        "//:dagger_with_compiler",
-        "//third_party:auto_value",
-        "//third_party:guava",
-        "//third_party:jsr330_inject",
-        "//third_party:junit",
-    ],
-)
-
-load("//:test_defs.bzl", "GenJavaTests")
-
-GenJavaTests(
-    name = "guava_functional_tests",
-    srcs = glob(["src/test/java/**/*.java"]),
-    javacopts = PRE_JAVA_8_INFERENCE_OPTS + DOCLINT_HTML_AND_SYNTAX,
-    deps = [
-        ":code_under_test",
-        "//:dagger_with_compiler",
-        "//third_party:auto_value",
-        "//third_party:guava",
-        "//third_party:jsr330_inject",
-        "//third_party:junit",
-        "//third_party:truth",
-    ],
-)
-
-test_suite(name = "AllTests")
diff --git a/compiler/src/it/guava-functional-tests/src/main/java/test/optional/OptionalBindingComponents.java b/compiler/src/it/guava-functional-tests/src/main/java/test/optional/OptionalBindingComponents.java
deleted file mode 100644
index 33d6918b9..000000000
--- a/compiler/src/it/guava-functional-tests/src/main/java/test/optional/OptionalBindingComponents.java
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.optional;
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import com.google.auto.value.AutoValue;
-import com.google.common.base.Optional;
-import dagger.BindsOptionalOf;
-import dagger.Component;
-import dagger.Lazy;
-import dagger.Module;
-import dagger.Provides;
-import dagger.Subcomponent;
-import java.lang.annotation.Retention;
-import javax.inject.Inject;
-import javax.inject.Provider;
-import javax.inject.Qualifier;
-
-/** Classes to support testing {@code BindsOptionalOf} functionality. */
-public final class OptionalBindingComponents {
-
-  /** A qualifier. */
-  @Qualifier
-  @Retention(RUNTIME)
-  public @interface SomeQualifier {}
-
-  /** A value object that contains various optionally-bound objects. */
-  @AutoValue
-  public abstract static class Values {
-    abstract Optional<Value> optionalInstance();
-
-    abstract Optional<Provider<Value>> optionalProvider();
-
-    abstract Optional<Lazy<Value>> optionalLazy();
-
-    abstract Optional<Provider<Lazy<Value>>> optionalLazyProvider();
-  }
-
-  // Default access so that it's inaccessible to OptionalBindingComponentsWithInaccessibleTypes.
-  enum Value {
-    VALUE,
-    QUALIFIED_VALUE
-  }
-
-  static final class InjectedThing {
-    @Inject
-    InjectedThing() {}
-  }
-
-  /** Binds optionals and {@link Values}. */
-  @Module
-  public abstract static class OptionalBindingModule {
-    @BindsOptionalOf
-    abstract Value value();
-
-    @BindsOptionalOf
-    @SomeQualifier abstract Value qualifiedValue();
-
-    // Valid because it's qualified.
-    @BindsOptionalOf
-    @SomeQualifier abstract InjectedThing qualifiedInjectedThing();
-
-    @Provides
-    static Values values(
-        Optional<Value> optionalInstance,
-        Optional<Provider<Value>> optionalProvider,
-        Optional<Lazy<Value>> optionalLazy,
-        Optional<Provider<Lazy<Value>>> optionalLazyProvider) {
-      return new AutoValue_OptionalBindingComponents_Values(
-          optionalInstance, optionalProvider, optionalLazy, optionalLazyProvider);
-    }
-
-    @Provides
-    @SomeQualifier
-    static Values qualifiedValues(
-        @SomeQualifier Optional<Value> optionalInstance,
-        @SomeQualifier Optional<Provider<Value>> optionalProvider,
-        @SomeQualifier Optional<Lazy<Value>> optionalLazy,
-        @SomeQualifier Optional<Provider<Lazy<Value>>> optionalLazyProvider) {
-      return new AutoValue_OptionalBindingComponents_Values(
-          optionalInstance, optionalProvider, optionalLazy, optionalLazyProvider);
-    }
-  }
-
-  /** Binds {@link Value}. */
-  @Module
-  public abstract static class ConcreteBindingModule {
-    /** @param cycle to demonstrate that optional {@link Provider} injection can break cycles */
-    @Provides
-    static Value value(Optional<Provider<Value>> cycle) {
-      return Value.VALUE;
-    }
-
-    @Provides
-    @SomeQualifier static Value qualifiedValue() {
-      return Value.QUALIFIED_VALUE;
-    }
-  }
-
-  /** Interface for components used to test optional bindings. */
-  public interface OptionalBindingComponent {
-    Values values();
-
-    @SomeQualifier
-    Values qualifiedValues();
-  }
-
-  @Component(modules = OptionalBindingModule.class)
-  interface AbsentOptionalBindingComponent extends OptionalBindingComponent {
-    PresentOptionalBindingSubcomponent presentChild();
-  }
-
-  @Component(modules = {OptionalBindingModule.class, ConcreteBindingModule.class})
-  interface PresentOptionalBindingComponent extends OptionalBindingComponent {}
-
-  @Subcomponent(modules = ConcreteBindingModule.class)
-  interface PresentOptionalBindingSubcomponent extends OptionalBindingComponent {}
-}
diff --git a/compiler/src/it/guava-functional-tests/src/main/java/test/optional/a/OptionalBindingComponentsWithInaccessibleTypes.java b/compiler/src/it/guava-functional-tests/src/main/java/test/optional/a/OptionalBindingComponentsWithInaccessibleTypes.java
deleted file mode 100644
index c3beaef79..000000000
--- a/compiler/src/it/guava-functional-tests/src/main/java/test/optional/a/OptionalBindingComponentsWithInaccessibleTypes.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.optional.a;
-
-import dagger.Component;
-import test.optional.OptionalBindingComponents.ConcreteBindingModule;
-import test.optional.OptionalBindingComponents.OptionalBindingComponent;
-import test.optional.OptionalBindingComponents.OptionalBindingModule;
-
-final class OptionalBindingComponentsWithInaccessibleTypes {
-
-  @Component(modules = OptionalBindingModule.class)
-  interface AbsentOptionalBindingComponent extends OptionalBindingComponent {}
-
-  @Component(modules = {OptionalBindingModule.class, ConcreteBindingModule.class})
-  interface PresentOptionalBindingComponent extends OptionalBindingComponent {}
-}
diff --git a/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsAbsentTest.java b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsAbsentTest.java
deleted file mode 100644
index 491cf85e7..000000000
--- a/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsAbsentTest.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.optional;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import test.optional.OptionalBindingComponents.AbsentOptionalBindingComponent;
-
-/** Tests for absent optional bindings. */
-@RunWith(JUnit4.class)
-public final class OptionalBindingComponentsAbsentTest {
-  private AbsentOptionalBindingComponent absent;
-
-  @Before
-  public void setUp() {
-    absent = DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create();
-  }
-
-  @Test
-  public void optional() {
-    assertThat(absent.values().optionalInstance()).isAbsent();
-  }
-
-  @Test
-  public void optionalProvider() {
-    assertThat(absent.values().optionalProvider()).isAbsent();
-  }
-
-  @Test
-  public void optionalLazy() {
-    assertThat(absent.values().optionalLazy()).isAbsent();
-  }
-
-  @Test
-  public void optionalLazyProvider() {
-    assertThat(absent.values().optionalLazyProvider()).isAbsent();
-  }
-
-  @Test
-  public void qualifiedOptional() {
-    assertThat(absent.qualifiedValues().optionalInstance()).isAbsent();
-  }
-
-  @Test
-  public void qualifiedOptionalProvider() {
-    assertThat(absent.qualifiedValues().optionalProvider()).isAbsent();
-  }
-
-  @Test
-  public void qualifiedOptionalLazy() {
-    assertThat(absent.qualifiedValues().optionalLazy()).isAbsent();
-  }
-
-  @Test
-  public void qualifiedOptionalLazyProvider() {
-    assertThat(absent.qualifiedValues().optionalLazyProvider()).isAbsent();
-  }
-}
diff --git a/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsPresentTest.java b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsPresentTest.java
deleted file mode 100644
index 448329092..000000000
--- a/compiler/src/it/guava-functional-tests/src/test/java/test/optional/OptionalBindingComponentsPresentTest.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.optional;
-
-import static com.google.common.truth.Truth.assertThat;
-import static test.optional.OptionalBindingComponents.Value.QUALIFIED_VALUE;
-import static test.optional.OptionalBindingComponents.Value.VALUE;
-
-import com.google.common.collect.ImmutableList;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
-import test.optional.OptionalBindingComponents.OptionalBindingComponent;
-
-/** Tests for present optional bindings. */
-@RunWith(Parameterized.class)
-public final class OptionalBindingComponentsPresentTest {
-
-  @Parameters(name = "{0}")
-  public static Iterable<Object[]> parameters() {
-    return ImmutableList.copyOf(
-        new Object[][] {
-          {DaggerOptionalBindingComponents_PresentOptionalBindingComponent.create()},
-          {DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create().presentChild()},
-        });
-  }
-
-  private final OptionalBindingComponent component;
-
-  public OptionalBindingComponentsPresentTest(OptionalBindingComponent component) {
-    this.component = component;
-  }
-
-  @Test
-  public void optionalProvider() {
-    assertThat(component.values().optionalProvider().get().get()).isEqualTo(VALUE);
-  }
-
-  @Test
-  public void optionalLazy() {
-    assertThat(component.values().optionalLazy().get().get()).isEqualTo(VALUE);
-  }
-
-  @Test
-  public void optionalLazyProvider() {
-    assertThat(component.values().optionalLazyProvider().get().get().get()).isEqualTo(VALUE);
-  }
-
-  @Test
-  public void qualifiedOptional() {
-    assertThat(component.qualifiedValues().optionalInstance()).hasValue(QUALIFIED_VALUE);
-  }
-
-  @Test
-  public void qualifiedOptionalProvider() {
-    assertThat(component.qualifiedValues().optionalProvider().get().get())
-        .isEqualTo(QUALIFIED_VALUE);
-  }
-
-  @Test
-  public void qualifiedOptionalLazy() {
-    assertThat(component.qualifiedValues().optionalLazy().get().get()).isEqualTo(QUALIFIED_VALUE);
-  }
-
-  @Test
-  public void qualifiedOptionalLazyProvider() {
-    assertThat(component.qualifiedValues().optionalLazyProvider().get().get().get())
-        .isEqualTo(QUALIFIED_VALUE);
-  }
-}
diff --git a/compiler/src/it/guava-functional-tests/src/test/java/test/optional/a/OptionalBindingComponentsWithInaccessibleTypesTest.java b/compiler/src/it/guava-functional-tests/src/test/java/test/optional/a/OptionalBindingComponentsWithInaccessibleTypesTest.java
deleted file mode 100644
index ed655022f..000000000
--- a/compiler/src/it/guava-functional-tests/src/test/java/test/optional/a/OptionalBindingComponentsWithInaccessibleTypesTest.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.optional.a;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-/** Tests for optional bindings that include types inaccessible to the component. */
-@RunWith(JUnit4.class)
-public class OptionalBindingComponentsWithInaccessibleTypesTest {
-  @Test
-  public void components() {
-    DaggerOptionalBindingComponentsWithInaccessibleTypes_AbsentOptionalBindingComponent.create();
-    DaggerOptionalBindingComponentsWithInaccessibleTypes_PresentOptionalBindingComponent.create();
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/BUILD b/compiler/src/it/producers-functional-tests/BUILD
deleted file mode 100644
index 79e137ce1..000000000
--- a/compiler/src/it/producers-functional-tests/BUILD
+++ /dev/null
@@ -1,58 +0,0 @@
-# Copyright (C) 2017 The Dagger Authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-# Description:
-#   Functional tests for Dagger Producers
-
-package(default_visibility = ["//:src"])
-
-load(
-    "//:build_defs.bzl",
-    "DOCLINT_HTML_AND_SYNTAX",
-    "DOCLINT_REFERENCES",
-    "JAVA_7_SOURCE_LEVEL",
-    "PRE_JAVA_8_INFERENCE_OPTS",
-)
-
-# Sample code to be tested in functional tests.
-java_library(
-    name = "code_under_test",
-    srcs = glob(["src/main/java/**/*.java"]),
-    javacopts = PRE_JAVA_8_INFERENCE_OPTS + JAVA_7_SOURCE_LEVEL + DOCLINT_HTML_AND_SYNTAX,
-    deps = [
-        "//:producers_with_compiler",
-        "//third_party:auto_value",
-        "//third_party:guava",
-        "//third_party:jsr330_inject",
-    ],
-)
-
-load("//:test_defs.bzl", "GenJavaTests")
-
-GenJavaTests(
-    name = "producers-functional-tests",
-    srcs = glob(["src/test/java/**/*.java"]),
-    javacopts = PRE_JAVA_8_INFERENCE_OPTS + JAVA_7_SOURCE_LEVEL + DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
-    deps = [
-        ":code_under_test",
-        "//:producers_with_compiler",
-        "//third_party:guava",
-        "//third_party:jsr330_inject",
-        "//third_party:junit",
-        "//third_party:mockito",
-        "//third_party:truth",
-    ],
-)
-
-test_suite(name = "AllTests")
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedComponent.java
deleted file mode 100644
index 81306c002..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedComponent.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest;
-
-import dagger.Component;
-
-@Component(modules = DependedModule.class)
-interface DependedComponent {
-  String getGreeting();
-}
-
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedModule.java
deleted file mode 100644
index 47b722d34..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedModule.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest;
-
-import dagger.Module;
-import dagger.Provides;
-
-@Module
-final class DependedModule {
-  @Provides
-  String provideGreeting() {
-    return "Hello world!";
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProducerModule.java
deleted file mode 100644
index b352c6bd3..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProducerModule.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest;
-
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-
-@ProducerModule
-final class DependedProducerModule {
-
-  @Produces
-  int produceNumberOfGreetings() {
-    return 2;
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProductionComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProductionComponent.java
deleted file mode 100644
index 8fd6761c9..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependedProductionComponent.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest;
-
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.producers.ProductionComponent;
-
-@ProductionComponent(modules = {ExecutorModule.class, DependedProducerModule.class})
-interface DependedProductionComponent {
-  ListenableFuture<Integer> numGreetings();
-}
-
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentComponent.java
deleted file mode 100644
index 0c8508eee..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentComponent.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest;
-
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.producers.ProductionComponent;
-import java.util.List;
-
-@ProductionComponent(
-  modules = {ExecutorModule.class, DependentProducerModule.class},
-  dependencies = {DependedComponent.class, DependedProductionComponent.class}
-)
-interface DependentComponent {
-  ListenableFuture<List<String>> greetings();
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentProducerModule.java
deleted file mode 100644
index 8467ee144..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/DependentProducerModule.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest;
-
-import com.google.common.base.Ascii;
-import com.google.common.collect.ImmutableList;
-import com.google.common.util.concurrent.Futures;
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-import java.util.List;
-
-@ProducerModule
-final class DependentProducerModule {
-  @Produces
-  ListenableFuture<List<String>> greetings(Integer numGreetings, String greeting) {
-    List<String> greetings = ImmutableList.of(
-        String.valueOf(numGreetings), greeting, Ascii.toUpperCase(greeting));
-    return Futures.immediateFuture(greetings);
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ExecutorModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ExecutorModule.java
deleted file mode 100644
index 92492471f..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ExecutorModule.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest;
-
-import com.google.common.util.concurrent.MoreExecutors;
-import dagger.Module;
-import dagger.Provides;
-import dagger.producers.Production;
-import java.util.concurrent.Executor;
-
-/**
- * A module that provides an optionally user-defined executor for a production component, defaulting
- * to the direct executor.
- */
-@Module
-public final class ExecutorModule {
-  private final Executor executor;
-
-  public ExecutorModule() {
-    this(MoreExecutors.directExecutor());
-  }
-
-  public ExecutorModule(Executor executor) {
-    this.executor = executor;
-  }
-
-  @Provides
-  @Production
-  Executor executor() {
-    return executor;
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ProvidesInProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ProvidesInProducerModule.java
deleted file mode 100644
index 70617127d..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ProvidesInProducerModule.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest;
-
-import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.MoreExecutors;
-import dagger.Provides;
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-import dagger.producers.Production;
-import dagger.producers.ProductionComponent;
-import java.util.concurrent.Executor;
-
-final class ProvidesInProducerModule {
-  @ProducerModule
-  static class OnlyModule {
-    @Provides
-    @Production
-    static Executor provideExecutor() {
-      return MoreExecutors.directExecutor();
-    }
-
-    @Produces
-    static String produceString() {
-      return "produced";
-    }
-  }
-
-  @ProductionComponent(modules = OnlyModule.class)
-  interface C {
-    ListenableFuture<String> string();
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/Request.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/Request.java
deleted file mode 100644
index 6a6cbba20..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/Request.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest;
-
-import javax.inject.Inject;
-
-final class Request {
-  private final String name;
-
-  @Inject
-  Request() {
-    this.name = "Request";
-  }
-
-  String name() {
-    return this.name;
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/Response.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/Response.java
deleted file mode 100644
index 2e87cc440..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/Response.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest;
-
-final class Response {
-  private final String data;
-
-  Response(String data) {
-    this.data = data;
-  }
-
-  String data() {
-    return this.data;
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseModule.java
deleted file mode 100644
index 3252ce36d..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseModule.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest;
-
-import dagger.Module;
-import dagger.Provides;
-
-@Module
-final class ResponseModule {
-  @Provides
-  static int requestNumber() {
-    return 5;
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseProducerModule.java
deleted file mode 100644
index 0b75e881c..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/ResponseProducerModule.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest;
-
-import com.google.common.util.concurrent.Futures;
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.Lazy;
-import dagger.producers.Produced;
-import dagger.producers.Producer;
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-import javax.inject.Provider;
-import javax.inject.Qualifier;
-
-@ProducerModule(includes = ResponseModule.class)
-final class ResponseProducerModule {
-  @Qualifier
-  @interface RequestsProducerAndProduced {}
-
-  @Produces
-  static ListenableFuture<String> greeting() {
-    return Futures.immediateFuture("Hello");
-  }
-
-  @Produces
-  @RequestsProducerAndProduced
-  static ListenableFuture<String> intermediateGreeting(
-      // TODO(beder): Allow Producer and Provider of the same type (which would force the binding
-      // to be a provision binding), and add validation for that.
-      @SuppressWarnings("unused") String greeting,
-      Producer<String> greetingProducer,
-      @SuppressWarnings("unused") Produced<String> greetingProduced,
-      @SuppressWarnings("unused") Provider<Integer> requestNumberProvider,
-      @SuppressWarnings("unused") Lazy<Integer> requestNumberLazy) {
-    return greetingProducer.get();
-  }
-
-  @Produces
-  static Response response(
-      @RequestsProducerAndProduced String greeting, Request request, int requestNumber) {
-    return new Response(String.format("%s, %s #%d!", greeting, request.name(), requestNumber));
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleComponent.java
deleted file mode 100644
index 0ac75a476..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleComponent.java
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest;
-
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.producers.ProductionComponent;
-
-@ProductionComponent(modules = {ExecutorModule.class, ResponseProducerModule.class})
-interface SimpleComponent {
-  ListenableFuture<Response> response();
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
deleted file mode 100644
index a06c059a9..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/SimpleProducerModule.java
+++ /dev/null
@@ -1,281 +0,0 @@
-/*
-* Copyright (C) 2015 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package producerstest;
-
-import com.google.common.collect.ImmutableSet;
-import com.google.common.util.concurrent.Futures;
-import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.SettableFuture;
-import dagger.Lazy;
-import dagger.multibindings.ElementsIntoSet;
-import dagger.multibindings.IntoSet;
-import dagger.producers.Produced;
-import dagger.producers.Producer;
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-import java.io.IOException;
-import java.util.Set;
-import javax.inject.Provider;
-import javax.inject.Qualifier;
-
-/**
- * A module that contains various signatures of produces methods. This is not used in any
- * components.
- */
-@ProducerModule
-final class SimpleProducerModule {
-  @Qualifier @interface Qual {
-    int value();
-  }
-
-  // Unique bindings.
-
-  @Produces
-  @Qual(-2)
-  static ListenableFuture<String> throwingProducer() {
-    throw new RuntimeException("monkey");
-  }
-
-  @Produces
-  @Qual(-1)
-  static ListenableFuture<String> settableFutureStr(SettableFuture<String> future) {
-    return future;
-  }
-
-  @Produces
-  @Qual(0)
-  static String str() {
-    return "str";
-  }
-
-  @Produces
-  @Qual(1)
-  static ListenableFuture<String> futureStr() {
-    return Futures.immediateFuture("future str");
-  }
-
-  @Produces
-  @Qual(2)
-  static String strWithArg(@SuppressWarnings("unused") int i) {
-    return "str with arg";
-  }
-
-  @Produces
-  @Qual(3)
-  static ListenableFuture<String> futureStrWithArg(@SuppressWarnings("unused") int i) {
-    return Futures.immediateFuture("future str with arg");
-  }
-
-  @Produces
-  @Qual(4)
-  @SuppressWarnings("unused") // unthrown exception for test
-  static String strThrowingException() throws IOException {
-    return "str throwing exception";
-  }
-
-  @Produces
-  @Qual(5)
-  @SuppressWarnings("unused") // unthrown exception for test
-  static ListenableFuture<String> futureStrThrowingException() throws IOException {
-    return Futures.immediateFuture("future str throwing exception");
-  }
-
-  @Produces
-  @Qual(6)
-  @SuppressWarnings("unused") // unthrown exception for test, unused parameter for test
-  static String strWithArgThrowingException(int i) throws IOException {
-    return "str with arg throwing exception";
-  }
-
-  @Produces
-  @Qual(7)
-  @SuppressWarnings("unused") // unthrown exception for test, unused parameter for test
-  static ListenableFuture<String> futureStrWithArgThrowingException(int i) throws IOException {
-    return Futures.immediateFuture("future str with arg throwing exception");
-  }
-
-  @Produces
-  @Qual(8)
-  static String strWithArgs(
-      @SuppressWarnings("unused") int i,
-      @SuppressWarnings("unused") Produced<Double> b,
-      @SuppressWarnings("unused") Producer<Object> c,
-      @SuppressWarnings("unused") Provider<Boolean> d) {
-    return "str with args";
-  }
-
-  @Produces
-  @Qual(9)
-  @SuppressWarnings("unused") // unthrown exception for test, unused parameters for test
-  static String strWithArgsThrowingException(
-      int i, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) throws IOException {
-    return "str with args throwing exception";
-  }
-
-  @Produces
-  @Qual(10)
-  static ListenableFuture<String> futureStrWithArgs(
-      @SuppressWarnings("unused") int i,
-      @SuppressWarnings("unused") Produced<Double> b,
-      @SuppressWarnings("unused") Producer<Object> c,
-      @SuppressWarnings("unused") Provider<Boolean> d) {
-    return Futures.immediateFuture("future str with args");
-  }
-
-  @Produces
-  @Qual(11)
-  @SuppressWarnings("unused") // unthrown exception for test, unused parameter for test
-  static ListenableFuture<String> futureStrWithArgsThrowingException(
-      int i, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) throws IOException {
-    return Futures.immediateFuture("str with args throwing exception");
-  }
-
-  @Produces
-  @Qual(12)
-  static String strWithFrameworkTypeArgs(
-      @SuppressWarnings("unused") @Qual(1) int i,
-      @SuppressWarnings("unused") @Qual(1) Provider<Integer> iProvider,
-      @SuppressWarnings("unused") @Qual(1) Lazy<Integer> iLazy,
-      @SuppressWarnings("unused") @Qual(2) int j,
-      @SuppressWarnings("unused") @Qual(2) Produced<Integer> jProduced,
-      @SuppressWarnings("unused") @Qual(2) Producer<Integer> jProducer,
-      @SuppressWarnings("unused") @Qual(3) Produced<Integer> kProduced,
-      @SuppressWarnings("unused") @Qual(3) Producer<Integer> kProducer) {
-    return "str with framework type args";
-  }
-
-  // Set bindings.
-
-  @Produces
-  @IntoSet
-  static String setOfStrElement() {
-    return "set of str element";
-  }
-
-  @Produces
-  @IntoSet
-  @SuppressWarnings("unused") // unthrown exception for test
-  static String setOfStrElementThrowingException() throws IOException {
-    return "set of str element throwing exception";
-  }
-
-  @Produces
-  @IntoSet
-  static ListenableFuture<String> setOfStrFutureElement() {
-    return Futures.immediateFuture("set of str element");
-  }
-
-  @Produces
-  @IntoSet
-  @SuppressWarnings("unused") // unthrown exception for test
-  static ListenableFuture<String> setOfStrFutureElementThrowingException() throws IOException {
-    return Futures.immediateFuture("set of str element throwing exception");
-  }
-
-  @Produces
-  @IntoSet
-  static String setOfStrElementWithArg(@SuppressWarnings("unused") int i) {
-    return "set of str element with arg";
-  }
-
-  @Produces
-  @IntoSet
-  @SuppressWarnings("unused") // unthrown exception for test, unused parameter for test
-  static String setOfStrElementWithArgThrowingException(int i) throws IOException {
-    return "set of str element with arg throwing exception";
-  }
-
-  @Produces
-  @IntoSet
-  static ListenableFuture<String> setOfStrFutureElementWithArg(@SuppressWarnings("unused") int i) {
-    return Futures.immediateFuture("set of str element with arg");
-  }
-
-  @Produces
-  @IntoSet
-  @SuppressWarnings("unused") // unthrown exception for test, unused parameter for test
-  static ListenableFuture<String> setOfStrFutureElementWithArgThrowingException(int i)
-      throws IOException {
-    return Futures.immediateFuture("set of str element with arg throwing exception");
-  }
-
-  @Produces
-  @ElementsIntoSet
-  static Set<String> setOfStrValues() {
-    return ImmutableSet.of("set of str 1", "set of str 2");
-  }
-
-  @Produces
-  @ElementsIntoSet
-  @SuppressWarnings("unused") // unthrown exception for test
-  static Set<String> setOfStrValuesThrowingException() throws IOException {
-    return ImmutableSet.of("set of str 1", "set of str 2 throwing exception");
-  }
-
-  @Produces
-  @ElementsIntoSet
-  static ListenableFuture<Set<String>> setOfStrFutureValues() {
-    return Futures.<Set<String>>immediateFuture(ImmutableSet.of("set of str 1", "set of str 2"));
-  }
-
-  @Produces
-  @ElementsIntoSet
-  @SuppressWarnings("unused") // unthrown exception for test
-  static ListenableFuture<Set<String>> setOfStrFutureValuesThrowingException() throws IOException {
-    return Futures.<Set<String>>immediateFuture(
-        ImmutableSet.of("set of str 1", "set of str 2 throwing exception"));
-  }
-
-  @Produces
-  @ElementsIntoSet
-  static Set<String> setOfStrValuesWithArg(@SuppressWarnings("unused") int i) {
-    return ImmutableSet.of("set of str with arg 1", "set of str with arg 2");
-  }
-
-  @Produces
-  @ElementsIntoSet
-  @SuppressWarnings("unused") // unthrown exception for test, unused parameter for test
-  static Set<String> setOfStrValuesWithArgThrowingException(int i) throws IOException {
-    return ImmutableSet.of("set of str with arg 1", "set of str with arg 2 throwing exception");
-  }
-
-  @Produces
-  @ElementsIntoSet
-  static ListenableFuture<Set<String>> setOfStrFutureValuesWithArg(
-      @SuppressWarnings("unused") int i) {
-    return Futures.<Set<String>>immediateFuture(
-        ImmutableSet.of("set of str with arg 1", "set of str with arg 2"));
-  }
-
-  @Produces
-  @ElementsIntoSet
-  @SuppressWarnings("unused") // unthrown exception for test, unused parameter for test
-  static ListenableFuture<Set<String>> setOfStrFutureValuesWithArgThrowingException(int i)
-      throws IOException {
-    return Futures.<Set<String>>immediateFuture(
-        ImmutableSet.of("set of str with arg 1", "set of str with arg 2 throwing exception"));
-  }
-
-  /**
-   * A binding method that might result in a generated factory with conflicting field and parameter
-   * names.
-   */
-  @Produces
-  static Object object(int foo, Provider<String> fooProvider) {
-    return foo + fooProvider.get();
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/ComponentDependency.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/ComponentDependency.java
deleted file mode 100644
index 0844b0cbf..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/ComponentDependency.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.badexecutor;
-
-import com.google.common.util.concurrent.ListenableFuture;
-
-interface ComponentDependency {
-  ListenableFuture<Double> doubleDep();
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleComponent.java
deleted file mode 100644
index e13c47024..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleComponent.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.badexecutor;
-
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.producers.ProductionComponent;
-import producerstest.ExecutorModule;
-
-/**
- * A component that contains entry points that exercise different execution paths, for verifying the
- * behavior when the executor throws a {@link java.util.concurrent.RejectedExecutionException}.
- */
-@ProductionComponent(
-  dependencies = ComponentDependency.class,
-  modules = {ExecutorModule.class, SimpleProducerModule.class}
-)
-interface SimpleComponent {
-  /** An entry point exposing a producer method with no args. */
-  ListenableFuture<String> noArgStr();
-
-  /** An entry point exposing a producer method that depends on another producer method. */
-  ListenableFuture<Integer> singleArgInt();
-
-  /** An entry point exposing a producer method that depends on a component dependency method. */
-  ListenableFuture<Boolean> singleArgBool();
-
-  /** An entry point exposing a component dependency method. */
-  ListenableFuture<Double> doubleDep();
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleProducerModule.java
deleted file mode 100644
index 24a5ae52b..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/badexecutor/SimpleProducerModule.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.badexecutor;
-
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-
-@ProducerModule
-final class SimpleProducerModule {
-  @Produces
-  static String noArgStr() {
-    return "no arg string";
-  }
-
-  @Produces
-  static int singleArgInt(String arg) {
-    return arg.length();
-  }
-
-  @Produces
-  static boolean singleArgBool(double arg) {
-    return arg > 0.0;
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/Foo.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/Foo.java
deleted file mode 100644
index 343e90ecb..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/Foo.java
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.binds;
-
-/**
- * This is the type that will be bound.  We throw in generics just to complicate the test.
- */
-interface Foo<T> {}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/FooOfStrings.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/FooOfStrings.java
deleted file mode 100644
index 1c0377b23..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/FooOfStrings.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.binds;
-
-/**
- * This is not marked with {@link javax.inject.Inject @Inject} in order to test that {@link
- * dagger.Binds @Binds} properly translate to {@link dagger.internal.codegen.ProductionBinding}s
- * when the right-hand-side of the method is also a production binding. We force this by adding a
- * {@link dagger.producers.Produces @Produces} method to add it to the graph instead of relying on
- * the {@link dagger.internal.codegen.ProvisionBinding} that would be created by default with an
- * {@code @Inject} constructor.
- */
-final class FooOfStrings implements Foo<String> {}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/SimpleBindingModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/SimpleBindingModule.java
deleted file mode 100644
index 84b09689a..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/SimpleBindingModule.java
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.binds;
-
-import com.google.common.util.concurrent.MoreExecutors;
-import dagger.Binds;
-import dagger.Module;
-import dagger.Provides;
-import dagger.multibindings.ElementsIntoSet;
-import dagger.multibindings.IntKey;
-import dagger.multibindings.IntoMap;
-import dagger.multibindings.IntoSet;
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-import dagger.producers.Production;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Set;
-import java.util.TreeSet;
-import java.util.concurrent.Executor;
-import javax.inject.Named;
-import javax.inject.Qualifier;
-import javax.inject.Singleton;
-
-@ProducerModule(includes = {
-    SimpleBindingModule.ExecutorModule.class,
-    SimpleBindingModule.ProvisionModuleForMap.class
-})
-abstract class SimpleBindingModule {
-  @Binds
-  abstract Object bindObject(FooOfStrings impl);
-
-  @Binds
-  abstract Foo<String> bindFooOfStrings(FooOfStrings impl);
-
-  @Binds
-  abstract Foo<? extends Number> bindFooOfNumbers(Foo<Integer> fooOfIntegers);
-
-  @Binds
-  @Singleton
-  @SomeQualifier
-  abstract Foo<String> bindQualifiedFooOfStrings(FooOfStrings impl);
-
-  @Produces
-  static FooOfStrings produceFooOfStrings() {
-    return new FooOfStrings();
-  }
-
-  @Produces
-  static Foo<Integer> produceFooOfIntegers() {
-    return new Foo<Integer>() {};
-  }
-
-  @Produces
-  static Foo<Double> produceFooOfDoubles() {
-    return new Foo<Double>() {};
-  }
-
-  @Binds
-  @IntoSet
-  abstract Foo<? extends Number> bindFooOfIntegersIntoSet(Foo<Integer> fooOfIntegers);
-
-  @Binds
-  @IntoSet
-  abstract Foo<? extends Number> bindFooExtendsNumberIntoSet(Foo<Double> fooOfDoubles);
-
-  @Binds
-  @ElementsIntoSet
-  abstract Set<Object> bindSetOfFooNumbersToObjects(Set<Foo<? extends Number>> setOfFooNumbers);
-
-  @Binds
-  @IntoSet
-  abstract Object bindFooOfStringsIntoSetOfObjects(FooOfStrings impl);
-
-  @Produces
-  static HashSet<String> produceStringHashSet() {
-    return new HashSet<>(Arrays.asList("hash-string1", "hash-string2"));
-  }
-
-  @Produces
-  static TreeSet<CharSequence> produceCharSequenceTreeSet() {
-    return new TreeSet<CharSequence>(Arrays.asList("tree-charSequence1", "tree-charSequence2"));
-  }
-
-  @Produces
-  static Collection<CharSequence> produceCharSequenceCollection() {
-    return Arrays.<CharSequence>asList("list-charSequence");
-  }
-
-  @Binds
-  @ElementsIntoSet
-  abstract Set<CharSequence> bindHashSetOfStrings(HashSet<String> set);
-
-  @Binds
-  @ElementsIntoSet
-  abstract Set<CharSequence> bindTreeSetOfCharSequences(TreeSet<CharSequence> set);
-
-  @Binds
-  @ElementsIntoSet
-  abstract Set<CharSequence> bindCollectionOfCharSequences(Collection<CharSequence> collection);
-
-  @Qualifier
-  @Retention(RetentionPolicy.RUNTIME)
-  @interface SomeQualifier {}
-
-  @Module
-  static final class ExecutorModule {
-    @Provides @Production
-    static Executor provideExecutor() {
-      return MoreExecutors.directExecutor();
-    }
-  }
-
-  @Binds
-  @IntoMap
-  @IntKey(123)
-  abstract Object bind123ForMap(@Named("For-123") String string);
-
-  @Binds
-  @IntoMap
-  @IntKey(456)
-  abstract Object bind456ForMap(@Named("For-456") String string);
-
-  @Produces
-  @IntoMap
-  @IntKey(789)
-  static Object produce789ForMap() {
-    return "789-string";
-  }
-
-  @Module
-  abstract static class ProvisionModuleForMap {
-    @Provides @Named("Provision string") static String provideProvisionString() {
-      return "provision-string";
-    }
-
-    @Binds
-    @IntoMap
-    @IntKey(-1)
-    abstract Object bindNegative1ForMap(@Named("Provision string") String string);
-  }
-
-  @Binds
-  @IntoMap
-  @IntKey(123)
-  @SomeQualifier
-  abstract Object bindFooOfStringsIntoQualifiedMap(FooOfStrings fooOfStrings);
-
-  @Produces
-  @Named("For-123")
-  static String produce123String() {
-    return "123-string";
-  }
-
-  @Produces
-  @Named("For-456")
-  static String produce456String() {
-    return "456-string";
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/SimpleBindsProductionComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/SimpleBindsProductionComponent.java
deleted file mode 100644
index db72ca8b5..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/binds/SimpleBindsProductionComponent.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.binds;
-
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.producers.Produced;
-import dagger.producers.Producer;
-import dagger.producers.ProductionComponent;
-import java.util.Map;
-import java.util.Set;
-import javax.inject.Singleton;
-import producerstest.binds.SimpleBindingModule.SomeQualifier;
-
-@Singleton
-@ProductionComponent(modules = SimpleBindingModule.class)
-public interface SimpleBindsProductionComponent {
-  ListenableFuture<Object> object();
-
-  ListenableFuture<Foo<String>> fooOfStrings();
-
-  @SomeQualifier
-  ListenableFuture<Foo<String>> qualifiedFooOfStrings();
-
-  ListenableFuture<Foo<Integer>> fooOfIntegers();
-
-  ListenableFuture<Set<Foo<? extends Number>>> foosOfNumbers();
-
-  ListenableFuture<Set<Object>> objects();
-
-  ListenableFuture<Set<CharSequence>> charSequences();
-
-  ListenableFuture<Map<Integer, Object>> integerObjectMap();
-
-  ListenableFuture<Map<Integer, Producer<Object>>> integerProducerOfObjectMap();
-
-  ListenableFuture<Map<Integer, Produced<Object>>> integerProducedOfObjectMap();
-
-  @SomeQualifier ListenableFuture<Map<Integer, Object>> qualifiedIntegerObjectMap();
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/DepComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/DepComponent.java
deleted file mode 100644
index 1c72cdb66..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/DepComponent.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.builder;
-
-import com.google.common.util.concurrent.ListenableFuture;
-
-interface DepComponent {
-  ListenableFuture<Double> d();
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/IntModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/IntModule.java
deleted file mode 100644
index be7fb16ff..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/IntModule.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.builder;
-
-import dagger.Module;
-import dagger.Provides;
-
-@Module
-final class IntModule {
-  @Provides
-  static int i() {
-    return 42;
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/StringModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/StringModule.java
deleted file mode 100644
index 30e6eb9a1..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/StringModule.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.builder;
-
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-
-@ProducerModule
-final class StringModule {
-  @Produces
-  static String str(int i) {
-    return "arg: " + i;
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/TestComponentWithBuilder.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/TestComponentWithBuilder.java
deleted file mode 100644
index 2705a6573..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/builder/TestComponentWithBuilder.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.builder;
-
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.producers.ProductionComponent;
-import producerstest.ExecutorModule;
-
-@ProductionComponent(
-  modules = {ExecutorModule.class, StringModule.class, IntModule.class},
-  dependencies = DepComponent.class
-)
-interface TestComponentWithBuilder {
-  ListenableFuture<String> s();
-  ListenableFuture<Double> d();
-
-  @ProductionComponent.Builder
-  interface Builder {
-    Builder depComponent(DepComponent depComponent);
-    Builder strModule(StringModule strModule);
-    TestComponentWithBuilder build();
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoredComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoredComponent.java
deleted file mode 100644
index 27df6fb52..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoredComponent.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.monitoring;
-
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.producers.ProductionComponent;
-import producerstest.ExecutorModule;
-
-@ProductionComponent(
-  modules = {ExecutorModule.class, MonitoringModule.class, StubModule.class, ServingModule.class}
-)
-interface MonitoredComponent {
-  ListenableFuture<String> output();
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoringModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoringModule.java
deleted file mode 100644
index 489b89a88..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/MonitoringModule.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.monitoring;
-
-import dagger.Module;
-import dagger.Provides;
-import dagger.multibindings.IntoSet;
-import dagger.producers.monitoring.ProductionComponentMonitor;
-
-@Module
-final class MonitoringModule {
-  private final ProductionComponentMonitor.Factory monitorFactory;
-
-  MonitoringModule(ProductionComponentMonitor.Factory monitorFactory) {
-    this.monitorFactory = monitorFactory;
-  }
-
-  @Provides
-  @IntoSet
-  ProductionComponentMonitor.Factory monitorFactory() {
-    return monitorFactory;
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ServingModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ServingModule.java
deleted file mode 100644
index caaefa60b..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ServingModule.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.monitoring;
-
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-import javax.inject.Qualifier;
-import producerstest.monitoring.StubModule.ForServer1;
-import producerstest.monitoring.StubModule.ForServer2;
-
-@ProducerModule
-final class ServingModule {
-  @Qualifier
-  @interface RequestData {}
-
-  @Qualifier
-  @interface IntermediateData {}
-
-  @Produces
-  @RequestData
-  static String requestData() {
-    return "Hello, World!";
-  }
-
-  @Produces
-  @IntermediateData
-  static ListenableFuture<String> callServer1(
-      @RequestData String data, @ForServer1 StringStub stub) {
-    return stub.run(data);
-  }
-
-  @Produces
-  static ListenableFuture<String> callServer2(
-      @IntermediateData String data, @ForServer2 StringStub stub) {
-    return stub.run(data);
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StringStub.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StringStub.java
deleted file mode 100644
index 9503a74f4..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StringStub.java
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.monitoring;
-
-import com.google.common.util.concurrent.ListenableFuture;
-
-interface StringStub {
-  ListenableFuture<String> run(String input);
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StubModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StubModule.java
deleted file mode 100644
index 0bc3bd681..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/StubModule.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.monitoring;
-
-import dagger.Module;
-import dagger.Provides;
-import javax.inject.Qualifier;
-
-@Module
-final class StubModule {
-  @Qualifier
-  @interface ForServer1 {}
-
-  @Qualifier
-  @interface ForServer2 {}
-
-  private final StringStub server1;
-  private final StringStub server2;
-
-  StubModule(StringStub server1, StringStub server2) {
-    this.server1 = server1;
-    this.server2 = server2;
-  }
-
-  @Provides
-  @ForServer1
-  StringStub server1() {
-    return server1;
-  }
-
-  @Provides
-  @ForServer2
-  StringStub server2() {
-    return server2;
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadAccumulator.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadAccumulator.java
deleted file mode 100644
index 2eb4abda7..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadAccumulator.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.monitoring;
-
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-import javax.inject.Inject;
-import javax.inject.Singleton;
-
-@Singleton
-final class ThreadAccumulator {
-  private final Map<String, Long> threadIds = new ConcurrentHashMap<>();
-
-  @Inject
-  ThreadAccumulator() {}
-
-  void markThread(String name) {
-    threadIds.put(name, Thread.currentThread().getId());
-  }
-
-  long threadId(String name) {
-    return threadIds.get(name);
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadModule.java
deleted file mode 100644
index 829d6c4a8..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadModule.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.monitoring;
-
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.producers.Producer;
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-import producerstest.monitoring.ThreadQualifiers.Deferred;
-import producerstest.monitoring.ThreadQualifiers.EntryPoint;
-import producerstest.monitoring.ThreadQualifiers.Required;
-
-@ProducerModule
-final class ThreadModule {
-  @Produces
-  @Deferred
-  Object deferred(ThreadAccumulator acc) {
-    acc.markThread("deferred");
-    return new Object();
-  }
-
-  @Produces
-  @Required
-  ListenableFuture<Object> required(@Deferred Producer<Object> o, ThreadAccumulator acc) {
-    acc.markThread("required");
-    return o.get();
-  }
-
-  @Produces
-  @EntryPoint
-  ThreadAccumulator entryPoint(@Required Object o, ThreadAccumulator acc) {
-    acc.markThread("entryPoint");
-    return acc;
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadMonitoredComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadMonitoredComponent.java
deleted file mode 100644
index bc565feaa..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadMonitoredComponent.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.monitoring;
-
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.producers.ProductionComponent;
-import javax.inject.Singleton;
-import producerstest.ExecutorModule;
-import producerstest.monitoring.ThreadQualifiers.EntryPoint;
-
-@Singleton
-@ProductionComponent(modules = {ExecutorModule.class, MonitoringModule.class, ThreadModule.class})
-interface ThreadMonitoredComponent {
-  @EntryPoint
-  ListenableFuture<ThreadAccumulator> threadAccumulator();
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadQualifiers.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadQualifiers.java
deleted file mode 100644
index bfd415094..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/monitoring/ThreadQualifiers.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.monitoring;
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import java.lang.annotation.Documented;
-import java.lang.annotation.Retention;
-import javax.inject.Qualifier;
-
-final class ThreadQualifiers {
-  private ThreadQualifiers() {}
-
-  @Qualifier
-  @Retention(RUNTIME)
-  @Documented
-  @interface EntryPoint {}
-
-  @Qualifier
-  @Retention(RUNTIME)
-  @Documented
-  @interface Required {}
-
-  @Qualifier
-  @Retention(RUNTIME)
-  @Documented
-  @interface Deferred {}
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
deleted file mode 100644
index e858bed68..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.multibindings;
-
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.producers.Produced;
-import dagger.producers.Producer;
-import dagger.producers.ProductionComponent;
-import java.util.Map;
-import java.util.Set;
-import producerstest.ExecutorModule;
-import producerstest.multibindings.Qualifiers.EmptyButDeclaredInModule;
-import producerstest.multibindings.Qualifiers.EmptyButDeclaredInModuleAndProducerModule;
-import producerstest.multibindings.Qualifiers.ObjCount;
-import producerstest.multibindings.Qualifiers.OnlyProvisionMultibindings;
-import producerstest.multibindings.Qualifiers.PossiblyThrowingMap;
-import producerstest.multibindings.Qualifiers.PossiblyThrowingSet;
-
-@ProductionComponent(
-  modules = {ExecutorModule.class, MultibindingProducerModule.class, MultibindingModule.class}
-)
-interface MultibindingComponent {
-  ListenableFuture<Set<String>> strs();
-  ListenableFuture<Integer> strCount();
-
-  ListenableFuture<Set<Produced<String>>> successfulSet();
-
-  @PossiblyThrowingSet
-  ListenableFuture<Set<Produced<String>>> possiblyThrowingSet();
-
-  ListenableFuture<Map<Integer, String>> map();
-
-  ListenableFuture<Map<Integer, Producer<String>>> mapOfProducer();
-
-  ListenableFuture<Map<Integer, Produced<String>>> mapOfProduced();
-
-  @PossiblyThrowingMap
-  ListenableFuture<Map<Integer, String>> possiblyThrowingMap();
-
-  @PossiblyThrowingMap
-  ListenableFuture<Map<Integer, Producer<String>>> possiblyThrowingMapOfProducer();
-
-  @PossiblyThrowingMap
-  ListenableFuture<Map<Integer, Produced<String>>> possiblyThrowingMapOfProduced();
-
-  ListenableFuture<Set<Object>> objs();
-
-  ListenableFuture<Set<Produced<Object>>> producedObjs();
-
-  ListenableFuture<Map<Object, Object>> objMap();
-
-  ListenableFuture<Map<Object, Produced<Object>>> objMapOfProduced();
-
-  ListenableFuture<Map<Object, Producer<Object>>> objMapOfProducer();
-
-  @ObjCount
-  ListenableFuture<Integer> objCount();
-
-  @EmptyButDeclaredInModuleAndProducerModule
-  ListenableFuture<Map<String, Object>> emptyButDeclaredInModuleAndProducerModule();
-
-  @EmptyButDeclaredInModule
-  ListenableFuture<Map<String, Object>> emptyButDeclaredInModule();
-
-  @OnlyProvisionMultibindings
-  ListenableFuture<Map<String, Object>> onlyProvisionMultibindings();
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingModule.java
deleted file mode 100644
index 969cb9fad..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingModule.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.multibindings;
-
-import com.google.common.collect.ImmutableSet;
-import dagger.Module;
-import dagger.Provides;
-import dagger.multibindings.ElementsIntoSet;
-import dagger.multibindings.IntKey;
-import dagger.multibindings.IntoMap;
-import dagger.multibindings.IntoSet;
-import dagger.multibindings.Multibinds;
-import dagger.multibindings.StringKey;
-import java.util.Map;
-import java.util.Set;
-import producerstest.multibindings.Qualifiers.EmptyButDeclaredInModule;
-import producerstest.multibindings.Qualifiers.EmptyButDeclaredInModuleAndProducerModule;
-import producerstest.multibindings.Qualifiers.OnlyProvisionMultibindings;
-
-@Module
-abstract class MultibindingModule {
-  @Provides
-  @IntoSet
-  static String providedStr() {
-    return "providedStr";
-  }
-
-  @Provides
-  @ElementsIntoSet
-  static Set<String> providedStrs() {
-    return ImmutableSet.of("providedStr1", "providedStr2");
-  }
-
-  @Provides
-  @IntoMap
-  @IntKey(3)
-  static String providedValueFor3() {
-    return "provided three";
-  }
-  
-  @Multibinds
-  @EmptyButDeclaredInModuleAndProducerModule
-  abstract Map<String, Object> emptyButDeclaredInModuleAndProducerModule();
-
-  @Multibinds
-  @EmptyButDeclaredInModule
-  abstract Map<String, Object> emptyButDeclaredInModule();
-
-  @Provides
-  @IntoMap
-  @StringKey("a")
-  @OnlyProvisionMultibindings
-  static Object onlyProvisionMultibindings() {
-    return "only multibinding";
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
deleted file mode 100644
index ee23fa206..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingProducerModule.java
+++ /dev/null
@@ -1,140 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.multibindings;
-
-import com.google.common.collect.ImmutableSet;
-import com.google.common.util.concurrent.Futures;
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.multibindings.ElementsIntoSet;
-import dagger.multibindings.IntKey;
-import dagger.multibindings.IntoMap;
-import dagger.multibindings.IntoSet;
-import dagger.multibindings.Multibinds;
-import dagger.producers.Produced;
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-import java.util.Map;
-import java.util.Set;
-import producerstest.multibindings.Qualifiers.EmptyButDeclaredInModuleAndProducerModule;
-import producerstest.multibindings.Qualifiers.ObjCount;
-import producerstest.multibindings.Qualifiers.PossiblyThrowingMap;
-import producerstest.multibindings.Qualifiers.PossiblyThrowingSet;
-
-@ProducerModule
-abstract class MultibindingProducerModule {
-  @Produces
-  @IntoSet
-  static ListenableFuture<String> futureStr() {
-    return Futures.immediateFuture("foo");
-  }
-
-  @Produces
-  @IntoSet
-  static String str() {
-    return "bar";
-  }
-
-  @Produces
-  @ElementsIntoSet
-  static ListenableFuture<Set<String>> futureStrs() {
-    return Futures.<Set<String>>immediateFuture(ImmutableSet.of("foo1", "foo2"));
-  }
-
-  @Produces
-  @ElementsIntoSet
-  static Set<ListenableFuture<String>> strFutures() {
-    return ImmutableSet.of(Futures.immediateFuture("baz1"), Futures.immediateFuture("baz2"));
-  }
-
-  @Produces
-  @ElementsIntoSet
-  static Set<String> strs() {
-    return ImmutableSet.of("bar1", "bar2");
-  }
-
-  @Produces
-  static int strCount(Set<String> strs) {
-    return strs.size();
-  }
-
-  @Produces
-  @IntoSet
-  @PossiblyThrowingSet
-  static String successfulStringForSet() {
-    return "singleton";
-  }
-
-  @Produces
-  @ElementsIntoSet
-  @PossiblyThrowingSet
-  static Set<String> successfulStringsForSet() {
-    return ImmutableSet.of("double", "ton");
-  }
-
-  @Produces
-  @IntoSet
-  @PossiblyThrowingSet
-  static String throwingStringForSet() {
-    throw new RuntimeException("monkey");
-  }
-
-  @Produces
-  @IntoMap
-  @IntKey(42)
-  static ListenableFuture<String> futureFor42() {
-    return Futures.immediateFuture("forty two");
-  }
-
-  @Produces
-  @IntoMap
-  @IntKey(15)
-  static String valueFor15() {
-    return "fifteen";
-  }
-
-  @Produces
-  @IntoMap
-  @PossiblyThrowingMap
-  @IntKey(42)
-  static ListenableFuture<String> successfulFutureFor42() {
-    return Futures.immediateFuture("forty two");
-  }
-
-  @Produces
-  @IntoMap
-  @PossiblyThrowingMap
-  @IntKey(15)
-  static String throwingValueFor15() {
-    throw new RuntimeException("monkey");
-  }
-
-  @Multibinds
-  abstract Set<Object> objs();
-
-  @Multibinds
-  abstract Map<Object, Object> objMap();
-
-  @Produces
-  @ObjCount
-  static int objCount(Set<Produced<Object>> objs, Map<Object, Produced<Object>> objMap) {
-    return objs.size() + objMap.size();
-  }
-  
-  @Multibinds
-  @EmptyButDeclaredInModuleAndProducerModule
-  abstract Map<String, Object> emptyButDeclaredInModuleAndProducerModule();
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java
deleted file mode 100644
index 3a2f359e9..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/Qualifiers.java
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.multibindings;
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import java.lang.annotation.Documented;
-import java.lang.annotation.Retention;
-import javax.inject.Qualifier;
-
-final class Qualifiers {
-  @Documented
-  @Retention(RUNTIME)
-  @Qualifier
-  @interface PossiblyThrowingSet {}
-
-  @Documented
-  @Retention(RUNTIME)
-  @Qualifier
-  @interface PossiblyThrowingMap {}
-
-  @Documented
-  @Retention(RUNTIME)
-  @Qualifier
-  @interface ObjCount {}
-
-  @Documented
-  @Retention(RUNTIME)
-  @Qualifier
-  @interface EmptyButDeclaredInModule {}
-
-  @Documented
-  @Retention(RUNTIME)
-  @Qualifier
-  @interface EmptyButDeclaredInModuleAndProducerModule {}
-
-  @Documented
-  @Retention(RUNTIME)
-  @Qualifier
-  @interface OnlyProvisionMultibindings {}
-
-  private Qualifiers() {}
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/optional/OptionalBindingComponents.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/optional/OptionalBindingComponents.java
deleted file mode 100644
index 743b033e1..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/optional/OptionalBindingComponents.java
+++ /dev/null
@@ -1,175 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.optional;
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import com.google.auto.value.AutoValue;
-import com.google.common.base.Optional;
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.BindsOptionalOf;
-import dagger.Module;
-import dagger.Provides;
-import dagger.producers.Produced;
-import dagger.producers.Producer;
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-import dagger.producers.Production;
-import dagger.producers.ProductionComponent;
-import dagger.producers.ProductionSubcomponent;
-import java.lang.annotation.Retention;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
-import javax.inject.Provider;
-import javax.inject.Qualifier;
-
-/** Classes to support testing {@code BindsOptionalOf} functionality. */
-final class OptionalBindingComponents {
-
-  /** A qualifier. */
-  @Qualifier
-  @Retention(RUNTIME)
-  @interface SomeQualifier {}
-
-  /** A value object that contains various optionally-bound objects. */
-  @AutoValue
-  abstract static class Values {
-    abstract Optional<Value> optionalInstance();
-
-    abstract Optional<Producer<Value>> optionalProducer();
-
-    abstract Optional<Produced<Value>> optionalProduced();
-  }
-
-  enum Value {
-    VALUE,
-    QUALIFIED_VALUE
-  }
-
-  @Module
-  static final class ExecutorModule {
-    @Provides
-    @Production
-    static Executor executor() {
-      return Executors.newSingleThreadExecutor();
-    }
-  }
-
-  /** Binds optionals and {@link Values}. */
-  @ProducerModule
-  abstract static class OptionalBindingModule {
-    @BindsOptionalOf
-    abstract Value value();
-
-    @BindsOptionalOf
-    @SomeQualifier
-    abstract Value qualifiedValue();
-
-    @Produces
-    static Values values(
-        Optional<Value> optionalInstance,
-        Optional<Producer<Value>> optionalProducer,
-        Optional<Produced<Value>> optionalProduced) {
-      return new AutoValue_OptionalBindingComponents_Values(
-          optionalInstance, optionalProducer, optionalProduced);
-    }
-
-    @Produces
-    @SomeQualifier
-    static Values qualifiedValues(
-        Optional<Value> optionalInstance,
-        Optional<Producer<Value>> optionalProducer,
-        Optional<Produced<Value>> optionalProduced) {
-      return new AutoValue_OptionalBindingComponents_Values(
-          optionalInstance, optionalProducer, optionalProduced);
-    }
-  }
-
-  /** Binds {@link Value} using {@link Producer}s. */
-  @ProducerModule
-  abstract static class ConcreteBindingProducerModule {
-    @Produces
-    static Value value() {
-      return Value.VALUE;
-    }
-
-    @Produces
-    @SomeQualifier
-    static Value qualifiedValue() {
-      return Value.QUALIFIED_VALUE;
-    }
-  }
-
-  /** Binds {@link Value} using {@link Provider}s. */
-  @Module
-  abstract static class ConcreteBindingModule {
-    @Provides
-    static Value value() {
-      return Value.VALUE;
-    }
-
-    @Provides
-    @SomeQualifier
-    static Value qualifiedValue() {
-      return Value.QUALIFIED_VALUE;
-    }
-  }
-
-  interface OptionalBindingComponent {
-    ListenableFuture<Values> values();
-
-    ListenableFuture<Optional<Value>> optionalInstance();
-
-    ListenableFuture<Optional<Producer<Value>>> optionalProducer();
-
-    ListenableFuture<Optional<Produced<Value>>> optionalProduced();
-
-    @SomeQualifier
-    ListenableFuture<Values> qualifiedValues();
-
-    @SomeQualifier
-    ListenableFuture<Optional<Value>> qualifiedOptionalInstance();
-
-    @SomeQualifier
-    ListenableFuture<Optional<Producer<Value>>> qualifiedOptionalProducer();
-
-    @SomeQualifier
-    ListenableFuture<Optional<Produced<Value>>> qualifiedOptionalProduced();
-  }
-
-  @ProductionComponent(modules = {ExecutorModule.class, OptionalBindingModule.class})
-  interface AbsentOptionalBindingComponent extends OptionalBindingComponent {
-    PresentOptionalBindingSubcomponent presentChild();
-  }
-
-  @ProductionComponent(
-    modules = {
-      ExecutorModule.class,
-      OptionalBindingModule.class,
-      ConcreteBindingProducerModule.class
-    }
-  )
-  interface PresentOptionalBindingComponent extends OptionalBindingComponent {}
-
-  @ProductionSubcomponent(modules = ConcreteBindingProducerModule.class)
-  interface PresentOptionalBindingSubcomponent extends OptionalBindingComponent {}
-
-  @ProductionComponent(
-    modules = {ExecutorModule.class, OptionalBindingModule.class, ConcreteBindingModule.class}
-  )
-  interface PresentOptionalProvisionBindingComponent extends OptionalBindingComponent {}
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/provisions/Provisions.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/provisions/Provisions.java
deleted file mode 100644
index 779c7277e..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/provisions/Provisions.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.provisions;
-
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.producers.Producer;
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-import dagger.producers.ProductionComponent;
-import javax.inject.Inject;
-import javax.inject.Qualifier;
-import producerstest.ExecutorModule;
-
-/** Tests for requesting provisions from producers. */
-final class Provisions {
-  static final class InjectedClass {
-    @Inject InjectedClass() {}
-  }
-
-  static final class WrappedProducer<T> {
-    final Producer<T> producer;
-
-    WrappedProducer(Producer<T> producer) {
-      this.producer = producer;
-    }
-  }
-
-  static final class Output {
-    final Producer<InjectedClass> injectedClass1;
-    final Producer<InjectedClass> injectedClass2;
-
-    Output(Producer<InjectedClass> injectedClass1, Producer<InjectedClass> injectedClass2) {
-      this.injectedClass1 = injectedClass1;
-      this.injectedClass2 = injectedClass2;
-    }
-  }
-
-  @Qualifier @interface First {}
-  @Qualifier @interface Second {}
-
-  @ProducerModule
-  static final class TestModule {
-    @Produces @First static WrappedProducer<InjectedClass> firstProducer(
-        Producer<InjectedClass> injectedClass) {
-      return new WrappedProducer<InjectedClass>(injectedClass);
-    }
-
-    @Produces @Second static WrappedProducer<InjectedClass> secondProducer(
-        Producer<InjectedClass> injectedClass) {
-      return new WrappedProducer<InjectedClass>(injectedClass);
-    }
-
-    @Produces static Output output(
-        @First WrappedProducer<InjectedClass> producer1,
-        @Second WrappedProducer<InjectedClass> producer2) {
-      return new Output(producer1.producer, producer2.producer);
-    }
-  }
-
-  @ProductionComponent(modules = {ExecutorModule.class, TestModule.class})
-  interface TestComponent {
-    ListenableFuture<Output> output();
-  }
-
-  private Provisions() {}
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/ScopedModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/ScopedModule.java
deleted file mode 100644
index 5027a7b57..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/ScopedModule.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.scope;
-
-import dagger.Module;
-import dagger.Provides;
-import dagger.producers.ProductionScope;
-
-@Module
-final class ScopedModule {
-  @Provides
-  @ProductionScope
-  static Object newScopedObject() {
-    return new Object();
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/ScopedObject.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/ScopedObject.java
deleted file mode 100644
index cdb72d8d8..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/ScopedObject.java
+++ /dev/null
@@ -1,26 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.scope;
-
-import dagger.producers.ProductionScope;
-import javax.inject.Inject;
-
-@ProductionScope
-final class ScopedObject {
-  @Inject
-  ScopedObject() {}
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetComponent.java
deleted file mode 100644
index a4bde48e8..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetComponent.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.scope;
-
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.producers.ProductionComponent;
-import java.util.Set;
-import producerstest.ExecutorModule;
-
-@ProductionComponent(modules = {ExecutorModule.class, ScopedModule.class, SetProducerModule.class})
-interface SetComponent {
-  ScopedObject scopedObject();
-
-  ListenableFuture<Set<Object>> set();
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetProducerModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetProducerModule.java
deleted file mode 100644
index 23a441815..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/scope/SetProducerModule.java
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.scope;
-
-import dagger.multibindings.IntoSet;
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-
-/**
- * A module that provides two entries into a set; but since the inputs are scoped, the set should
- * only have one value.
- */
-@ProducerModule
-final class SetProducerModule {
-  @Produces
-  @IntoSet
-  static Object setValue1(Object value) {
-    return value;
-  }
-
-  @Produces
-  @IntoSet
-  static Object setValue2(Object value) {
-    return value;
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/ModuleSubcomponentsInterop.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/ModuleSubcomponentsInterop.java
deleted file mode 100644
index 7c0c02f73..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/ModuleSubcomponentsInterop.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.subcomponent;
-
-import dagger.Component;
-import dagger.Module;
-import dagger.Subcomponent;
-import dagger.producers.ProducerModule;
-import dagger.producers.ProductionComponent;
-import dagger.producers.ProductionSubcomponent;
-
-final class ModuleSubcomponentsInterop {
-  @Component(modules = ProvisionTestModule.class)
-  interface ProvisionParent {
-    ProductionChild.Builder productionChild();
-  }
-
-  @Module(subcomponents = ProductionChild.class)
-  static class ProvisionTestModule {}
-
-  @ProductionSubcomponent
-  interface ProductionChild {
-    @ProductionSubcomponent.Builder
-    interface Builder {
-      ProductionChild build();
-    }
-  }
-
-  @ProductionComponent(modules = ProductionTestModule.class)
-  interface ProductionParent {
-    ProvisionChild.Builder provisionBuilder();
-  }
-
-  @ProducerModule(subcomponents = ProvisionChild.class)
-  static class ProductionTestModule {}
-
-  @Subcomponent
-  interface ProvisionChild {
-    @Subcomponent.Builder
-    interface Builder {
-      ProvisionChild build();
-    }
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/MultiPackageSubcomponents.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/MultiPackageSubcomponents.java
deleted file mode 100644
index afef85d1a..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/MultiPackageSubcomponents.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.subcomponent;
-
-import dagger.Component;
-import dagger.Module;
-import dagger.Provides;
-import producerstest.subcomponent.sub.ChildComponent;
-
-final class MultiPackageSubcomponents {
-  @Component(modules = IntModule.class)
-  interface ParentComponent {
-    ChildComponent.Builder childComponentBuilder();
-  }
-
-  @Module
-  static final class IntModule {
-    @Provides
-    static int i() {
-      return 42;
-    }
-  }
-
-  private MultiPackageSubcomponents() {}
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/ProductionSubcomponentFromModuleAndFactoryMethod.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/ProductionSubcomponentFromModuleAndFactoryMethod.java
deleted file mode 100644
index c9c067aba..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/ProductionSubcomponentFromModuleAndFactoryMethod.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.subcomponent;
-
-import dagger.Module;
-import dagger.Subcomponent;
-import dagger.producers.ProducerModule;
-import dagger.producers.ProductionComponent;
-import dagger.producers.ProductionSubcomponent;
-import producerstest.ExecutorModule;
-
-/**
- * Tests for {@link Subcomponent}s which are defined with {@link Module#subcomponents()} and are
- * also requested as component factory methods.
- */
-public class ProductionSubcomponentFromModuleAndFactoryMethod {
-  @ProductionSubcomponent
-  interface Sub {
-    @ProductionSubcomponent.Builder
-    interface Builder {
-      Sub sub();
-    }
-  }
-
-  @ProducerModule(subcomponents = Sub.class)
-  static class ModuleWithSubcomponent {}
-
-  @ProductionComponent(modules = {ModuleWithSubcomponent.class, ExecutorModule.class})
-  interface ExposesBuilder {
-    Sub.Builder subcomponentBuilder();
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/SubcomponentsWithBoundExecutor.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/SubcomponentsWithBoundExecutor.java
deleted file mode 100644
index bbd418a58..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/SubcomponentsWithBoundExecutor.java
+++ /dev/null
@@ -1,176 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.subcomponent;
-
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.Component;
-import dagger.Module;
-import dagger.Provides;
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-import dagger.producers.Production;
-import dagger.producers.ProductionComponent;
-import dagger.producers.ProductionSubcomponent;
-import java.util.concurrent.Executor;
-import java.util.concurrent.atomic.AtomicInteger;
-import javax.inject.Inject;
-import javax.inject.Provider;
-import javax.inject.Qualifier;
-
-final class SubcomponentsWithBoundExecutor {
-  @Qualifier
-  @interface FromParent {}
-
-  @Qualifier
-  @interface FromChild {}
-
-  @Qualifier
-  @interface FromGrandchild {}
-
-  static final class CountingExecutor implements Executor {
-    private final AtomicInteger executionCount;
-
-    CountingExecutor(AtomicInteger executionCount) {
-      this.executionCount = executionCount;
-    }
-
-    @Override
-    public void execute(Runnable runnable) {
-      executionCount.incrementAndGet();
-      runnable.run();
-    }
-  }
-
-  @Module
-  static final class ExecutorModule {
-    private final AtomicInteger constructionCount;
-    private final AtomicInteger executionCount;
-
-    ExecutorModule(AtomicInteger constructionCount, AtomicInteger executionCount) {
-      this.constructionCount = constructionCount;
-      this.executionCount = executionCount;
-    }
-
-    @Provides
-    @Production
-    Executor executor() {
-      constructionCount.incrementAndGet();
-      return new CountingExecutor(executionCount);
-    }
-  }
-
-  @Module
-  static final class ParentModule {
-    @Provides
-    @FromParent
-    static String fromParent() {
-      return "parent";
-    }
-  }
-
-  @Component(modules = {ParentModule.class, ExecutorModule.class})
-  interface ParentComponent {
-    InjectsChildBuilder injectsChildBuilder();
-
-    ChildComponent.Builder newChildComponentBuilder();
-  }
-
-  @ProducerModule
-  static final class ParentProducerModule {
-    @Produces
-    @FromParent
-    static String fromParent() {
-      return "parentproduction";
-    }
-  }
-
-  @ProductionComponent(modules = {ParentProducerModule.class, ExecutorModule.class})
-  interface ParentProductionComponent {
-    ChildComponent.Builder newChildComponentBuilder();
-
-    @ProductionComponent.Builder
-    interface Builder {
-      Builder executorModule(ExecutorModule executorModule);
-
-      ParentProductionComponent build();
-    }
-  }
-
-  @ProducerModule
-  static final class ChildProducerModule {
-    @Produces
-    @FromChild
-    static String fromChild(@FromParent String fromParent) {
-      return "child:" + fromParent;
-    }
-  }
-
-  @ProductionSubcomponent(modules = ChildProducerModule.class)
-  interface ChildComponent {
-    @FromChild
-    ListenableFuture<String> fromChild();
-
-    GrandchildComponent.Builder newGrandchildComponentBuilder();
-    GrandchildComponentWithoutBuilder newGrandchildComponent();
-
-    @ProductionSubcomponent.Builder
-    interface Builder {
-      ChildComponent build();
-    }
-  }
-
-  static final class InjectsChildBuilder {
-    private final Provider<ChildComponent.Builder> childBuilder;
-
-    @Inject
-    InjectsChildBuilder(Provider<ChildComponent.Builder> childBuilder) {
-      this.childBuilder = childBuilder;
-    }
-
-    ChildComponent.Builder childBuilder() {
-      return childBuilder.get();
-    }
-  }
-
-  @ProducerModule
-  static final class GrandchildProducerModule {
-    @Produces
-    @FromGrandchild
-    static String fromGranchild(@FromChild String fromChild) {
-      return "grandchild:" + fromChild;
-    }
-  }
-
-  @ProductionSubcomponent(modules = GrandchildProducerModule.class)
-  interface GrandchildComponent {
-    @FromGrandchild
-    ListenableFuture<String> fromGrandchild();
-
-    @ProductionSubcomponent.Builder
-    interface Builder {
-      GrandchildComponent build();
-    }
-  }
-
-  @ProductionSubcomponent(modules = GrandchildProducerModule.class)
-  interface GrandchildComponentWithoutBuilder {
-    @FromGrandchild
-    ListenableFuture<String> fromGrandchild();
-  }
-
-  private SubcomponentsWithBoundExecutor() {}
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/UsesProducerModuleSubcomponents.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/UsesProducerModuleSubcomponents.java
deleted file mode 100644
index 07502ffeb..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/UsesProducerModuleSubcomponents.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.subcomponent;
-
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.multibindings.IntoSet;
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-import dagger.producers.ProductionComponent;
-import dagger.producers.ProductionSubcomponent;
-import java.util.Set;
-import javax.inject.Qualifier;
-import producerstest.ExecutorModule;
-
-/** Supporting types for {@link ProducerModuleWithSubcomponentsTest}. */
-@ProductionComponent(
-  modules = UsesProducerModuleSubcomponents.ProducerModuleWithSubcomponents.class
-)
-public interface UsesProducerModuleSubcomponents {
-
-  ListenableFuture<Set<String>> strings();
-
-  @FromChild
-  ListenableFuture<Set<String>> stringsFromChild();
-
-  @ProducerModule(
-    subcomponents = Child.class,
-    includes = {AlsoIncludesSubcomponents.class, ExecutorModule.class}
-  )
-  class ProducerModuleWithSubcomponents {
-    @Produces
-    @IntoSet
-    static String produceStringInParent() {
-      return "from parent";
-    }
-
-    @Produces
-    @FromChild
-    static Set<String> stringsFromChild(Child.Builder childBuilder) throws Exception {
-      return childBuilder.build().strings().get();
-    }
-  }
-
-  @ProducerModule(subcomponents = Child.class)
-  class AlsoIncludesSubcomponents {}
-
-  @ProductionSubcomponent(modules = ChildModule.class)
-  interface Child {
-    ListenableFuture<Set<String>> strings();
-
-    @ProductionSubcomponent.Builder
-    interface Builder {
-      Child build();
-    }
-  }
-
-  @ProducerModule
-  class ChildModule {
-    @Produces
-    @IntoSet
-    static String produceStringInChild() {
-      return "from child";
-    }
-  }
-
-  @Qualifier
-  @interface FromChild {}
-
-  @ProducerModule(includes = ProducerModuleWithSubcomponents.class)
-  class OnlyIncludesProducerModuleWithSubcomponents {}
-
-  @ProductionComponent(modules = OnlyIncludesProducerModuleWithSubcomponents.class)
-  interface ParentIncludesProductionSubcomponentTransitively
-      extends UsesProducerModuleSubcomponents {}
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/pruning/ParentDoesntUseProductionSubcomponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/pruning/ParentDoesntUseProductionSubcomponent.java
deleted file mode 100644
index d16b1d063..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/pruning/ParentDoesntUseProductionSubcomponent.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.subcomponent.pruning;
-
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.multibindings.IntoSet;
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-import dagger.producers.ProductionComponent;
-import dagger.producers.ProductionSubcomponent;
-import java.util.Set;
-import javax.inject.Qualifier;
-
-/**
- * Supporting types for {@link ProductionSubcomponentOnlyRequestedBySiblingTest}. {@link ChildA} is
- * a direct child of the top level component, but is only requested within its sibling, not directly
- * from its parent.
- */
-@ProductionComponent(
-  modules = {
-    ParentDoesntUseProductionSubcomponent.ParentModule.class,
-    producerstest.ExecutorModule.class
-  }
-)
-interface ParentDoesntUseProductionSubcomponent {
-
-  ChildB.Builder childBBuilder();
-
-  @ProductionSubcomponent(modules = ChildAModule.class)
-  interface ChildA {
-    @ProductionSubcomponent.Builder
-    interface Builder {
-      ChildA build();
-    }
-
-    ListenableFuture<Set<Class<?>>> componentHierarchy();
-  }
-
-  @ProductionSubcomponent(modules = ChildBModule.class)
-  interface ChildB {
-    @ProductionSubcomponent.Builder
-    interface Builder {
-      ChildB build();
-    }
-
-    ListenableFuture<Set<Class<?>>> componentHierarchy();
-
-    @FromChildA
-    ListenableFuture<Set<Class<?>>> componentHierarchyFromChildA();
-  }
-
-  @ProducerModule(subcomponents = {ChildA.class, ChildB.class})
-  class ParentModule {
-    @Produces
-    @IntoSet
-    static Class<?> produceComponentType() {
-      return ParentDoesntUseProductionSubcomponent.class;
-    }
-  }
-
-  @ProducerModule
-  class ChildAModule {
-    @Produces
-    @IntoSet
-    static Class<?> produceComponentType() {
-      return ChildA.class;
-    }
-  }
-
-  @ProducerModule
-  class ChildBModule {
-    @Produces
-    @IntoSet
-    static Class<?> produceComponentType() {
-      return ChildB.class;
-    }
-
-    @Produces
-    @FromChildA
-    Set<Class<?>> fromChildA(ChildA.Builder childABuilder) throws Exception {
-      return childABuilder.build().componentHierarchy().get();
-    }
-  }
-
-  @Qualifier
-  @interface FromChildA {}
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildComponent.java
deleted file mode 100644
index c49e1c08a..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildComponent.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.subcomponent.sub;
-
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.producers.ProductionSubcomponent;
-import producerstest.ExecutorModule;
-
-@ProductionSubcomponent(modules = {ExecutorModule.class, ChildModule.class})
-public interface ChildComponent {
-  ListenableFuture<String> str();
-
-  @ProductionSubcomponent.Builder
-  interface Builder {
-    ChildComponent build();
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildModule.java
deleted file mode 100644
index c8d730f75..000000000
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/subcomponent/sub/ChildModule.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.subcomponent.sub;
-
-import dagger.producers.ProducerModule;
-import dagger.producers.Produces;
-
-@ProducerModule
-final class ChildModule {
-  @Produces
-  static String str(int n) {
-    return "Hello, World " + n;
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/DependentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/DependentTest.java
deleted file mode 100644
index 7298a4258..000000000
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/DependentTest.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
-* Copyright (C) 2015 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package producerstest;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import com.google.common.util.concurrent.Futures;
-import com.google.common.util.concurrent.ListenableFuture;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class DependentTest {
-  @Test public void dependentComponent() throws Exception {
-    DependentComponent dependentComponent =
-        DaggerDependentComponent.builder()
-            .dependedProductionComponent(DaggerDependedProductionComponent.create())
-            .dependedComponent(DaggerDependedComponent.create())
-            .build();
-    assertThat(dependentComponent).isNotNull();
-    assertThat(dependentComponent.greetings().get()).containsExactly(
-        "2", "Hello world!", "HELLO WORLD!");
-  }
-
-  @Test public void reuseBuilderWithDependentComponent() throws Exception {
-    DaggerDependentComponent.Builder dependentComponentBuilder = DaggerDependentComponent.builder();
-
-    DependentComponent componentUsingComponents =
-        dependentComponentBuilder
-            .dependedProductionComponent(DaggerDependedProductionComponent.create())
-            .dependedComponent(DaggerDependedComponent.create())
-            .build();
-
-    DependentComponent componentUsingJavaImpls = dependentComponentBuilder
-        .dependedProductionComponent(new DependedProductionComponent() {
-          @Override public ListenableFuture<Integer> numGreetings() {
-            return Futures.immediateFuture(3);
-          }
-        })
-        .dependedComponent(new DependedComponent() {
-          @Override public String getGreeting() {
-            return "Goodbye world!";
-          }
-        })
-        .build();
-
-    assertThat(componentUsingJavaImpls.greetings().get()).containsExactly(
-        "3", "Goodbye world!", "GOODBYE WORLD!");
-    assertThat(componentUsingComponents.greetings().get()).containsExactly(
-        "2", "Hello world!", "HELLO WORLD!");
-
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java
deleted file mode 100644
index 6da997702..000000000
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/ProducerFactoryTest.java
+++ /dev/null
@@ -1,197 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-import static org.mockito.Matchers.any;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.when;
-
-import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.MoreExecutors;
-import com.google.common.util.concurrent.SettableFuture;
-import dagger.producers.Producer;
-import dagger.producers.monitoring.ProducerMonitor;
-import dagger.producers.monitoring.ProducerToken;
-import dagger.producers.monitoring.ProductionComponentMonitor;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Executor;
-import javax.inject.Provider;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.InOrder;
-import org.mockito.Mock;
-import org.mockito.Mockito;
-import org.mockito.MockitoAnnotations;
-
-@RunWith(JUnit4.class)
-public class ProducerFactoryTest {
-  @Mock private ProductionComponentMonitor componentMonitor;
-  private ProducerMonitor monitor;
-  private Provider<Executor> executorProvider;
-  private Provider<ProductionComponentMonitor> componentMonitorProvider;
-
-  @Before
-  public void setUpMocks() {
-    MockitoAnnotations.initMocks(this);
-    monitor = Mockito.mock(ProducerMonitor.class, Mockito.CALLS_REAL_METHODS);
-    when(componentMonitor.producerMonitorFor(any(ProducerToken.class))).thenReturn(monitor);
-    // TODO(beder): Use Providers.of when available.
-    executorProvider =
-        new Provider<Executor>() {
-          @Override
-          public Executor get() {
-            return MoreExecutors.directExecutor();
-          }
-        };
-    componentMonitorProvider =
-        new Provider<ProductionComponentMonitor>() {
-          @Override
-          public ProductionComponentMonitor get() {
-            return componentMonitor;
-          }
-        };
-  }
-
-  @Test
-  public void noArgMethod() throws Exception {
-    ProducerToken token = ProducerToken.create(SimpleProducerModule_StrFactory.class);
-    Producer<String> producer =
-        new SimpleProducerModule_StrFactory(executorProvider, componentMonitorProvider);
-    assertThat(producer.get().get()).isEqualTo("str");
-    InOrder order = inOrder(componentMonitor, monitor);
-    order.verify(componentMonitor).producerMonitorFor(token);
-    order.verify(monitor).methodStarting();
-    order.verify(monitor).methodFinished();
-    order.verify(monitor).succeeded("str");
-    order.verifyNoMoreInteractions();
-  }
-
-  @Test
-  public void singleArgMethod() throws Exception {
-    SettableFuture<Integer> intFuture = SettableFuture.create();
-    Producer<Integer> intProducer = producerOfFuture(intFuture);
-    Producer<String> producer =
-        new SimpleProducerModule_StrWithArgFactory(
-            executorProvider, componentMonitorProvider, intProducer);
-    assertThat(producer.get().isDone()).isFalse();
-    intFuture.set(42);
-    assertThat(producer.get().get()).isEqualTo("str with arg");
-  }
-
-  @Test
-  public void successMonitor() throws Exception {
-    ProducerToken token = ProducerToken.create(SimpleProducerModule_SettableFutureStrFactory.class);
-
-    SettableFuture<String> strFuture = SettableFuture.create();
-    SettableFuture<SettableFuture<String>> strFutureFuture = SettableFuture.create();
-    Producer<SettableFuture<String>> strFutureProducer = producerOfFuture(strFutureFuture);
-    Producer<String> producer =
-        new SimpleProducerModule_SettableFutureStrFactory(
-            executorProvider, componentMonitorProvider, strFutureProducer);
-    assertThat(producer.get().isDone()).isFalse();
-
-    InOrder order = inOrder(componentMonitor, monitor);
-    order.verify(componentMonitor).producerMonitorFor(token);
-
-    strFutureFuture.set(strFuture);
-    order.verify(monitor).methodStarting();
-    order.verify(monitor).methodFinished();
-    assertThat(producer.get().isDone()).isFalse();
-
-    strFuture.set("monkey");
-    assertThat(producer.get().get()).isEqualTo("monkey");
-    order.verify(monitor).succeeded("monkey");
-
-    order.verifyNoMoreInteractions();
-  }
-
-  @Test
-  public void failureMonitor() throws Exception {
-    ProducerToken token = ProducerToken.create(SimpleProducerModule_SettableFutureStrFactory.class);
-
-    SettableFuture<String> strFuture = SettableFuture.create();
-    SettableFuture<SettableFuture<String>> strFutureFuture = SettableFuture.create();
-    Producer<SettableFuture<String>> strFutureProducer = producerOfFuture(strFutureFuture);
-    Producer<String> producer =
-        new SimpleProducerModule_SettableFutureStrFactory(
-            executorProvider, componentMonitorProvider, strFutureProducer);
-    assertThat(producer.get().isDone()).isFalse();
-
-    InOrder order = inOrder(componentMonitor, monitor);
-    order.verify(componentMonitor).producerMonitorFor(token);
-
-    strFutureFuture.set(strFuture);
-    order.verify(monitor).methodStarting();
-    order.verify(monitor).methodFinished();
-    assertThat(producer.get().isDone()).isFalse();
-
-    Throwable t = new RuntimeException("monkey");
-    strFuture.setException(t);
-    try {
-      producer.get().get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(e.getCause()).isSameAs(t);
-      order.verify(monitor).failed(t);
-    }
-
-    order.verifyNoMoreInteractions();
-  }
-
-  @Test
-  public void failureMonitorDueToThrowingProducer() throws Exception {
-    ProducerToken token = ProducerToken.create(SimpleProducerModule_ThrowingProducerFactory.class);
-
-    Producer<String> producer =
-        new SimpleProducerModule_ThrowingProducerFactory(
-            executorProvider, componentMonitorProvider);
-    assertThat(producer.get().isDone()).isTrue();
-
-    InOrder order = inOrder(componentMonitor, monitor);
-    order.verify(componentMonitor).producerMonitorFor(token);
-
-    order.verify(monitor).methodStarting();
-    order.verify(monitor).methodFinished();
-
-    try {
-      producer.get().get();
-      fail();
-    } catch (ExecutionException e) {
-      order.verify(monitor).failed(e.getCause());
-    }
-
-    order.verifyNoMoreInteractions();
-  }
-
-  @Test(expected = NullPointerException.class)
-  public void nullComponentMonitorProvider() throws Exception {
-    new SimpleProducerModule_StrFactory(executorProvider, null);
-  }
-
-  private static <T> Producer<T> producerOfFuture(final ListenableFuture<T> future) {
-    return new Producer<T>() {
-      @Override
-      public ListenableFuture<T> get() {
-        return future;
-      }
-    };
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/SimpleTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/SimpleTest.java
deleted file mode 100644
index 5c52e0382..000000000
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/SimpleTest.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
-* Copyright (C) 2015 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-package producerstest;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class SimpleTest {
-  @Test public void testSimpleComponent() throws Exception {
-    SimpleComponent simpleComponent = DaggerSimpleComponent.create();
-    assertThat(simpleComponent).isNotNull();
-    assertThat(simpleComponent.response().get().data()).isEqualTo("Hello, Request #5!");
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/badexecutor/BadExecutorTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/badexecutor/BadExecutorTest.java
deleted file mode 100644
index 39ff83e12..000000000
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/badexecutor/BadExecutorTest.java
+++ /dev/null
@@ -1,75 +0,0 @@
-package producerstest.badexecutor;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-
-import com.google.common.util.concurrent.Futures;
-import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.ListeningExecutorService;
-import com.google.common.util.concurrent.MoreExecutors;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.RejectedExecutionException;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import producerstest.ExecutorModule;
-
-/** This test verifies behavior when the executor throws {@link RejectedExecutionException}. */
-@RunWith(JUnit4.class)
-public final class BadExecutorTest {
-  private SimpleComponent component;
-
-  @Before
-  public void setUpComponent() {
-    ComponentDependency dependency =
-        new ComponentDependency() {
-          @Override
-          public ListenableFuture<Double> doubleDep() {
-            return Futures.immediateFuture(42.0);
-          }
-        };
-    ListeningExecutorService executorService = MoreExecutors.newDirectExecutorService();
-    component =
-        DaggerSimpleComponent.builder()
-            .executorModule(new ExecutorModule(executorService))
-            .componentDependency(dependency)
-            .build();
-    executorService.shutdown();
-  }
-
-  @Test
-  public void rejectNoArgMethod() throws Exception {
-    try {
-      component.noArgStr().get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(e.getCause()).isInstanceOf(RejectedExecutionException.class);
-    }
-  }
-
-  @Test
-  public void rejectSingleArgMethod() throws Exception {
-    try {
-      component.singleArgInt().get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(e.getCause()).isInstanceOf(RejectedExecutionException.class);
-    }
-  }
-
-  @Test
-  public void rejectSingleArgFromComponentDepMethod() throws Exception {
-    try {
-      component.singleArgBool().get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(e.getCause()).isInstanceOf(RejectedExecutionException.class);
-    }
-  }
-
-  @Test
-  public void doNotRejectComponentDepMethod() throws Exception {
-    assertThat(component.doubleDep().get()).isWithin(0).of(42.0);
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/binds/BindsProducersTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/binds/BindsProducersTest.java
deleted file mode 100644
index 42ebe6889..000000000
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/binds/BindsProducersTest.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.binds;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import com.google.common.collect.ImmutableMap;
-import dagger.producers.Produced;
-import dagger.producers.Producer;
-import java.util.Map;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class BindsProducersTest {
-
-  private SimpleBindsProductionComponent component;
-
-  @Before
-  public void setUp() {
-    component = DaggerSimpleBindsProductionComponent.create();
-  }
-
-  @Test
-  public void bindDelegates() throws Exception {
-    assertThat(component.object().get()).isInstanceOf(FooOfStrings.class);
-    assertThat(component.fooOfStrings().get()).isInstanceOf(FooOfStrings.class);
-    assertThat(component.fooOfIntegers().get()).isNotNull();
-  }
-
-  @Test
-  public void bindWithScope() throws Exception {
-    assertThat(component.qualifiedFooOfStrings().get())
-        .isSameAs(component.qualifiedFooOfStrings().get());
-  }
-
-  @Test
-  public void multibindings() throws Exception {
-    assertThat(component.foosOfNumbers().get()).hasSize(2);
-    assertThat(component.objects().get()).hasSize(3);
-    assertThat(component.charSequences().get()).hasSize(5);
-
-    assertThat(component.integerObjectMap().get())
-        .containsExactlyEntriesIn(
-            ImmutableMap.of(
-                123, "123-string", 456, "456-string", 789, "789-string", -1, "provision-string"));
-
-    Map<Integer, Producer<Object>> integerProducerOfObjectMap =
-        component.integerProducerOfObjectMap().get();
-    assertThat(integerProducerOfObjectMap).hasSize(4);
-    assertThat(integerProducerOfObjectMap.get(123).get().get()).isEqualTo("123-string");
-    assertThat(integerProducerOfObjectMap.get(456).get().get()).isEqualTo("456-string");
-    assertThat(integerProducerOfObjectMap.get(789).get().get()).isEqualTo("789-string");
-    assertThat(integerProducerOfObjectMap.get(-1).get().get()).isEqualTo("provision-string");
-
-    assertThat(component.integerProducedOfObjectMap().get())
-        .containsExactlyEntriesIn(
-            ImmutableMap.of(
-                123, Produced.successful("123-string"),
-                456, Produced.successful("456-string"),
-                789, Produced.successful("789-string"),
-                -1, Produced.successful("provision-string")));
-
-    assertThat(component.qualifiedIntegerObjectMap().get()).hasSize(1);
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java
deleted file mode 100644
index ece750fc7..000000000
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/builder/ProductionComponentBuilderTest.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.builder;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import com.google.common.util.concurrent.Futures;
-import com.google.common.util.concurrent.ListenableFuture;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-/** Tests for {@link dagger.producers.ProductionComponent.Builder}. */
-@RunWith(JUnit4.class)
-public final class ProductionComponentBuilderTest {
-
-  @Test
-  public void successfulBuild() throws Exception {
-    TestComponentWithBuilder component =
-        DaggerTestComponentWithBuilder.builder()
-            .depComponent(depComponent(15.3))
-            .strModule(new StringModule())
-            .build();
-    assertThat(component.s().get()).isEqualTo("arg: 42");
-    assertThat(component.d().get()).isWithin(0).of(15.3);
-  }
-
-  @Test
-  public void successfulBuild_withMissingZeroArgModule() throws Exception {
-    TestComponentWithBuilder component =
-        DaggerTestComponentWithBuilder.builder()
-            .depComponent(depComponent(15.3))
-            .build();
-    assertThat(component.s().get()).isEqualTo("arg: 42");
-    assertThat(component.d().get()).isWithin(0).of(15.3);
-  }
-
-  @Test(expected = IllegalStateException.class)
-  public void missingDepComponent() {
-    DaggerTestComponentWithBuilder.builder()
-        .strModule(new StringModule())
-        .build();
-  }
-
-  private static DepComponent depComponent(final double value) {
-    return new DepComponent() {
-      @Override
-      public ListenableFuture<Double> d() {
-        return Futures.immediateFuture(value);
-      }
-    };
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java
deleted file mode 100644
index 921464a47..000000000
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/monitoring/MonitoringTest.java
+++ /dev/null
@@ -1,254 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.monitoring;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-import static org.mockito.Mockito.any;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.when;
-
-import com.google.common.base.Throwables;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.SettableFuture;
-import dagger.producers.monitoring.ProducerMonitor;
-import dagger.producers.monitoring.ProducerToken;
-import dagger.producers.monitoring.ProductionComponentMonitor;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Executors;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.InOrder;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-import producerstest.ExecutorModule;
-
-/** Tests for production components using monitoring. */
-@RunWith(JUnit4.class)
-public final class MonitoringTest {
-  @Mock private ProductionComponentMonitor.Factory componentMonitorFactory;
-  @Mock private StringStub server1;
-  @Mock private StringStub server2;
-  private SettableFuture<String> server1Future;
-  private SettableFuture<String> server2Future;
-  private FakeProductionComponentMonitor componentMonitor;
-
-  @Before
-  public void setUp() {
-    MockitoAnnotations.initMocks(this);
-    componentMonitor = new FakeProductionComponentMonitor();
-    when(componentMonitorFactory.create(any())).thenReturn(componentMonitor);
-    server1Future = SettableFuture.create();
-    server2Future = SettableFuture.create();
-    when(server1.run(any(String.class))).thenReturn(server1Future);
-    when(server2.run(any(String.class))).thenReturn(server2Future);
-  }
-
-  @Test
-  public void basicMonitoring() throws Exception {
-    MonitoredComponent component =
-        DaggerMonitoredComponent.builder()
-            .monitoringModule(new MonitoringModule(componentMonitorFactory))
-            .stubModule(new StubModule(server1, server2))
-            .build();
-    ListenableFuture<String> output = component.output();
-    assertThat(componentMonitor.monitors).hasSize(3);
-    ImmutableList<Map.Entry<ProducerToken, ProducerMonitor>> entries =
-        ImmutableList.copyOf(componentMonitor.monitors.entrySet());
-    assertThat(entries.get(0).getKey().toString()).contains("CallServer2");
-    assertThat(entries.get(1).getKey().toString()).contains("CallServer1");
-    assertThat(entries.get(2).getKey().toString()).contains("RequestData");
-
-    ProducerMonitor callServer2Monitor = entries.get(0).getValue();
-    ProducerMonitor callServer1Monitor = entries.get(1).getValue();
-    ProducerMonitor requestDataMonitor = entries.get(2).getValue();
-
-    InOrder inOrder = inOrder(requestDataMonitor, callServer1Monitor, callServer2Monitor);
-    inOrder.verify(callServer2Monitor).requested();
-    inOrder.verify(callServer1Monitor).requested();
-    inOrder.verify(requestDataMonitor).requested();
-    inOrder.verify(requestDataMonitor).ready();
-    inOrder.verify(requestDataMonitor).methodStarting();
-    inOrder.verify(requestDataMonitor).methodFinished();
-    inOrder.verify(requestDataMonitor).succeeded("Hello, World!");
-    inOrder.verify(callServer1Monitor).ready();
-    inOrder.verify(callServer1Monitor).methodStarting();
-    inOrder.verify(callServer1Monitor).methodFinished();
-    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
-
-    server1Future.set("server 1 response");
-    inOrder.verify(callServer1Monitor).succeeded("server 1 response");
-    inOrder.verify(callServer2Monitor).ready();
-    inOrder.verify(callServer2Monitor).methodStarting();
-    inOrder.verify(callServer2Monitor).methodFinished();
-    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
-
-    server2Future.set("server 2 response");
-    inOrder.verify(callServer2Monitor).succeeded("server 2 response");
-    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
-    assertThat(output.get()).isEqualTo("server 2 response");
-  }
-
-  @Test
-  public void basicMonitoringWithFailure() throws Exception {
-    MonitoredComponent component =
-        DaggerMonitoredComponent.builder()
-            .monitoringModule(new MonitoringModule(componentMonitorFactory))
-            .stubModule(new StubModule(server1, server2))
-            .build();
-    ListenableFuture<String> output = component.output();
-    assertThat(componentMonitor.monitors).hasSize(3);
-    ImmutableList<Map.Entry<ProducerToken, ProducerMonitor>> entries =
-        ImmutableList.copyOf(componentMonitor.monitors.entrySet());
-    assertThat(entries.get(0).getKey().toString()).contains("CallServer2");
-    assertThat(entries.get(1).getKey().toString()).contains("CallServer1");
-    assertThat(entries.get(2).getKey().toString()).contains("RequestData");
-
-    ProducerMonitor callServer2Monitor = entries.get(0).getValue();
-    ProducerMonitor callServer1Monitor = entries.get(1).getValue();
-    ProducerMonitor requestDataMonitor = entries.get(2).getValue();
-
-    InOrder inOrder = inOrder(requestDataMonitor, callServer1Monitor, callServer2Monitor);
-    inOrder.verify(callServer2Monitor).requested();
-    inOrder.verify(callServer1Monitor).requested();
-    inOrder.verify(requestDataMonitor).requested();
-    inOrder.verify(requestDataMonitor).ready();
-    inOrder.verify(requestDataMonitor).methodStarting();
-    inOrder.verify(requestDataMonitor).methodFinished();
-    inOrder.verify(requestDataMonitor).succeeded("Hello, World!");
-    inOrder.verify(callServer1Monitor).ready();
-    inOrder.verify(callServer1Monitor).methodStarting();
-    inOrder.verify(callServer1Monitor).methodFinished();
-    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
-
-    RuntimeException cause = new RuntimeException("monkey");
-    server1Future.setException(cause);
-    inOrder.verify(callServer1Monitor).failed(cause);
-    inOrder.verify(callServer2Monitor).ready();
-    inOrder.verify(callServer2Monitor).failed(any(Throwable.class));
-    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
-    try {
-      output.get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(Throwables.getRootCause(e)).isSameAs(cause);
-    }
-  }
-
-  private static final class FakeProductionComponentMonitor extends ProductionComponentMonitor {
-    final Map<ProducerToken, ProducerMonitor> monitors = new LinkedHashMap<>();
-
-    @Override
-    public ProducerMonitor producerMonitorFor(ProducerToken token) {
-      ProducerMonitor monitor = mock(ProducerMonitor.class);
-      monitors.put(token, monitor);
-      return monitor;
-    }
-  }
-
-  @Test
-  public void monitoringWithThreads() throws Exception {
-    ThreadRecordingProductionComponentMonitor componentMonitor =
-        new ThreadRecordingProductionComponentMonitor();
-    when(componentMonitorFactory.create(any())).thenReturn(componentMonitor);
-
-    ThreadMonitoredComponent component =
-        DaggerThreadMonitoredComponent.builder()
-            .monitoringModule(new MonitoringModule(componentMonitorFactory))
-            .executorModule(new ExecutorModule(Executors.newFixedThreadPool(10)))
-            .build();
-    ThreadAccumulator threadAccumulator = component.threadAccumulator().get();
-
-    assertThat(componentMonitor.monitors).hasSize(3);
-    ImmutableList<Map.Entry<ProducerToken, ThreadRecordingProducerMonitor>> entries =
-        ImmutableList.copyOf(componentMonitor.monitors.entrySet());
-
-    assertThat(entries.get(0).getKey().toString()).contains("EntryPoint");
-    ThreadRecordingProducerMonitor entryPointMonitor = entries.get(0).getValue();
-    assertThat(entries.get(1).getKey().toString()).contains("Required");
-    ThreadRecordingProducerMonitor requiredMonitor = entries.get(1).getValue();
-    assertThat(entries.get(2).getKey().toString()).contains("Deferred");
-    ThreadRecordingProducerMonitor deferredMonitor = entries.get(2).getValue();
-
-    // The entry point producer was requested from the main thread, then ran in its own thread.
-    assertThat(entryPointMonitor.requestedThreadId).isEqualTo(Thread.currentThread().getId());
-    assertThat(entryPointMonitor.startingThreadId)
-        .isEqualTo(threadAccumulator.threadId("entryPoint"));
-    assertThat(entryPointMonitor.finishedThreadId)
-        .isEqualTo(threadAccumulator.threadId("entryPoint"));
-
-    // The deferred producer was requested by the required producer, then ran in its own thread.
-    assertThat(deferredMonitor.requestedThreadId).isEqualTo(threadAccumulator.threadId("required"));
-    assertThat(deferredMonitor.startingThreadId).isEqualTo(threadAccumulator.threadId("deferred"));
-    assertThat(deferredMonitor.finishedThreadId).isEqualTo(threadAccumulator.threadId("deferred"));
-
-    // The required producer was requested by the entry point producer, then ran in its own thread.
-    assertThat(requiredMonitor.requestedThreadId).isEqualTo(entryPointMonitor.requestedThreadId);
-    assertThat(requiredMonitor.startingThreadId).isEqualTo(threadAccumulator.threadId("required"));
-    assertThat(requiredMonitor.finishedThreadId).isEqualTo(threadAccumulator.threadId("required"));
-
-    // Each producer ran in a distinct thread.
-    ImmutableSet<Long> threadIds =
-        ImmutableSet.of(
-            Thread.currentThread().getId(),
-            threadAccumulator.threadId("required"),
-            threadAccumulator.threadId("deferred"),
-            threadAccumulator.threadId("entryPoint"));
-    assertThat(threadIds).hasSize(4);
-  }
-
-  private static final class ThreadRecordingProductionComponentMonitor
-      extends ProductionComponentMonitor {
-    final Map<ProducerToken, ThreadRecordingProducerMonitor> monitors = new LinkedHashMap<>();
-
-    @Override
-    public ProducerMonitor producerMonitorFor(ProducerToken token) {
-      ThreadRecordingProducerMonitor monitor = new ThreadRecordingProducerMonitor();
-      monitors.put(token, monitor);
-      return monitor;
-    }
-  }
-
-  private static final class ThreadRecordingProducerMonitor extends ProducerMonitor {
-    private long requestedThreadId;
-    private long startingThreadId;
-    private long finishedThreadId;
-
-    @Override
-    public void requested() {
-      requestedThreadId = Thread.currentThread().getId();
-    }
-
-    @Override
-    public void methodStarting() {
-      startingThreadId = Thread.currentThread().getId();
-    }
-
-    @Override
-    public void methodFinished() {
-      finishedThreadId = Thread.currentThread().getId();
-    }
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
deleted file mode 100644
index 79f58fdce..000000000
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
+++ /dev/null
@@ -1,189 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.multibindings;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.junit.Assert.fail;
-
-import com.google.common.collect.Iterables;
-import com.google.common.util.concurrent.ListenableFuture;
-import dagger.producers.Produced;
-import dagger.producers.Producer;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.ExecutionException;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class MultibindingTest {
-  @Test
-  public void setBinding() throws Exception {
-    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
-    assertThat(multibindingComponent.strs().get())
-        .containsExactly(
-            "foo",
-            "foo1",
-            "foo2",
-            "baz1",
-            "baz2",
-            "bar",
-            "bar1",
-            "bar2",
-            "providedStr",
-            "providedStr1",
-            "providedStr2");
-    assertThat(multibindingComponent.strCount().get()).isEqualTo(11);
-  }
-
-  @Test
-  public void setBindingOfProduced() throws Exception {
-    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
-    assertThat(multibindingComponent.successfulSet().get())
-        .containsExactly(
-            Produced.successful("foo"),
-            Produced.successful("foo1"),
-            Produced.successful("foo2"),
-            Produced.successful("baz1"),
-            Produced.successful("baz2"),
-            Produced.successful("bar"),
-            Produced.successful("bar1"),
-            Produced.successful("bar2"),
-            Produced.successful("providedStr"),
-            Produced.successful("providedStr1"),
-            Produced.successful("providedStr2"));
-  }
-
-  @Test
-  public void setBindingOfProducedWithFailures() throws Exception {
-    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
-    Set<Produced<String>> possiblyThrowingSet = multibindingComponent.possiblyThrowingSet().get();
-    Set<String> successes = new HashSet<>();
-    Set<ExecutionException> failures = new HashSet<>();
-    for (Produced<String> str : possiblyThrowingSet) {
-      try {
-        successes.add(str.get());
-      } catch (ExecutionException e) {
-        failures.add(e);
-      }
-    }
-    assertThat(successes).containsExactly("singleton", "double", "ton");
-    assertThat(failures).hasSize(1);
-    assertThat(Iterables.getOnlyElement(failures).getCause()).hasMessage("monkey");
-  }
-
-  @Test
-  public void mapBinding() throws Exception {
-    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
-    Map<Integer, String> map = multibindingComponent.map().get();
-    assertThat(map).hasSize(3);
-    assertThat(map).containsEntry(15, "fifteen");
-    assertThat(map).containsEntry(42, "forty two");
-    assertThat(map).containsEntry(3, "provided three");
-  }
-
-  @Test
-  public void mapOfProducerBinding() throws Exception {
-    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
-    Map<Integer, Producer<String>> map = multibindingComponent.mapOfProducer().get();
-    assertThat(map).hasSize(3);
-    assertThat(map).containsKey(15);
-    assertThat(map.get(15).get().get()).isEqualTo("fifteen");
-    assertThat(map).containsKey(42);
-    assertThat(map.get(42).get().get()).isEqualTo("forty two");
-    assertThat(map).containsKey(3);
-    assertThat(map.get(3).get().get()).isEqualTo("provided three");
-  }
-
-  @Test
-  public void mapOfProducedBinding() throws Exception {
-    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
-    Map<Integer, Produced<String>> map = multibindingComponent.mapOfProduced().get();
-    assertThat(map).hasSize(3);
-    assertThat(map).containsKey(15);
-    assertThat(map.get(15).get()).isEqualTo("fifteen");
-    assertThat(map).containsKey(42);
-    assertThat(map.get(42).get()).isEqualTo("forty two");
-    assertThat(map).containsKey(3);
-    assertThat(map.get(3).get()).isEqualTo("provided three");
-  }
-
-  @Test
-  public void mapBindingWithFailures() throws Exception {
-    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
-    try {
-      multibindingComponent.possiblyThrowingMap().get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(e.getCause()).hasMessage("monkey");
-    }
-  }
-
-  @Test
-  public void mapOfProducerBindingWithFailures() throws Exception {
-    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
-    Map<Integer, Producer<String>> map =
-        multibindingComponent.possiblyThrowingMapOfProducer().get();
-    assertThat(map).hasSize(2);
-    assertThat(map).containsKey(42);
-    assertThat(map.get(42).get().get()).isEqualTo("forty two");
-    assertThat(map).containsKey(15);
-    ListenableFuture<String> future = map.get(15).get();
-    try {
-      future.get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(e.getCause()).hasMessage("monkey");
-    }
-  }
-
-  @Test
-  public void mapOfProducedBindingWithFailures() throws Exception {
-    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
-    Map<Integer, Produced<String>> map =
-        multibindingComponent.possiblyThrowingMapOfProduced().get();
-    assertThat(map).hasSize(2);
-    assertThat(map).containsKey(42);
-    assertThat(map.get(42).get()).isEqualTo("forty two");
-    assertThat(map).containsKey(15);
-    Produced<String> produced = map.get(15);
-    try {
-      produced.get();
-      fail();
-    } catch (ExecutionException e) {
-      assertThat(e.getCause()).hasMessage("monkey");
-    }
-  }
-
-  @Test
-  public void emptySet() throws Exception {
-    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
-    assertThat(multibindingComponent.objs().get()).isEmpty();
-    assertThat(multibindingComponent.producedObjs().get()).isEmpty();
-    assertThat(multibindingComponent.objCount().get()).isEqualTo(0);
-  }
-
-  @Test
-  public void emptyMap() throws Exception {
-    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
-    assertThat(multibindingComponent.objMap().get()).isEmpty();
-    assertThat(multibindingComponent.objMapOfProduced().get()).isEmpty();
-    assertThat(multibindingComponent.objMapOfProducer().get()).isEmpty();
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/optional/OptionalBindingComponentsAbsentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/optional/OptionalBindingComponentsAbsentTest.java
deleted file mode 100644
index c2d5ce530..000000000
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/optional/OptionalBindingComponentsAbsentTest.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.optional;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import producerstest.optional.OptionalBindingComponents.AbsentOptionalBindingComponent;
-
-/** Tests for absent optional bindings. */
-@RunWith(JUnit4.class)
-public final class OptionalBindingComponentsAbsentTest {
-  private AbsentOptionalBindingComponent absent;
-
-  @Before
-  public void setUp() {
-    absent = DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create();
-  }
-
-  @Test
-  public void optional() throws Exception {
-    assertThat(absent.optionalInstance().get()).isAbsent();
-  }
-
-  @Test
-  public void optionalProducer() throws Exception {
-    assertThat(absent.optionalProducer().get()).isAbsent();
-  }
-
-  @Test
-  public void optionalProduced() throws Exception {
-    assertThat(absent.optionalProduced().get()).isAbsent();
-  }
-
-  @Test
-  public void qualifiedOptional() throws Exception {
-    assertThat(absent.qualifiedOptionalInstance().get()).isAbsent();
-  }
-
-  @Test
-  public void qualifiedOptionalProducer() throws Exception {
-    assertThat(absent.qualifiedOptionalProducer().get()).isAbsent();
-  }
-
-  @Test
-  public void qualifiedOptionalProduced() throws Exception {
-    assertThat(absent.qualifiedOptionalProduced().get()).isAbsent();
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/optional/OptionalBindingComponentsPresentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/optional/OptionalBindingComponentsPresentTest.java
deleted file mode 100644
index 8788e5236..000000000
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/optional/OptionalBindingComponentsPresentTest.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.optional;
-
-import static com.google.common.truth.Truth.assertThat;
-import static producerstest.optional.OptionalBindingComponents.Value.QUALIFIED_VALUE;
-import static producerstest.optional.OptionalBindingComponents.Value.VALUE;
-
-import com.google.common.collect.ImmutableList;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-import org.junit.runners.Parameterized.Parameters;
-import producerstest.optional.OptionalBindingComponents.OptionalBindingComponent;
-
-/** Tests for present optional bindings. */
-@RunWith(Parameterized.class)
-public final class OptionalBindingComponentsPresentTest {
-
-  @Parameters(name = "{0}")
-  public static Iterable<Object[]> parameters() {
-    return ImmutableList.copyOf(
-        new Object[][] {
-          {DaggerOptionalBindingComponents_PresentOptionalBindingComponent.create()},
-          {DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create().presentChild()},
-          {DaggerOptionalBindingComponents_PresentOptionalProvisionBindingComponent.create()}
-        });
-  }
-  
-  private final OptionalBindingComponent component;
-
-  public OptionalBindingComponentsPresentTest(OptionalBindingComponent component) {
-    this.component = component;
-  }
-
-  @Test
-  public void optional() throws Exception {
-    assertThat(component.optionalInstance().get()).hasValue(VALUE);
-  }
-
-  @Test
-  public void optionalProducer() throws Exception {
-    assertThat(component.optionalProducer().get().get().get().get()).isEqualTo(VALUE);
-  }
-
-  @Test
-  public void optionalProduced() throws Exception {
-    assertThat(component.optionalProduced().get().get().get()).isEqualTo(VALUE);
-  }
-
-  @Test
-  public void qualifiedOptional() throws Exception {
-    assertThat(component.qualifiedOptionalInstance().get()).hasValue(QUALIFIED_VALUE);
-  }
-
-  @Test
-  public void qualifiedOptionalProducer() throws Exception {
-    assertThat(component.qualifiedOptionalProducer().get().get().get().get())
-        .isEqualTo(QUALIFIED_VALUE);
-  }
-
-  @Test
-  public void qualifiedOptionalProduced() throws Exception {
-    assertThat(component.qualifiedOptionalProduced().get().get().get()).isEqualTo(QUALIFIED_VALUE);
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/provisions/ProvisionsTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/provisions/ProvisionsTest.java
deleted file mode 100644
index 53543f962..000000000
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/provisions/ProvisionsTest.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.provisions;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import producerstest.provisions.DaggerProvisions_TestComponent;
-import producerstest.provisions.Provisions.Output;
-import producerstest.provisions.Provisions.TestComponent;
-
-@RunWith(JUnit4.class)
-public final class ProvisionsTest {
-
-  @Test
-  public void provisionsOnlyAreHeldInOneProducer() throws Exception {
-    TestComponent component = DaggerProvisions_TestComponent.create();
-    Output output = component.output().get();
-    assertThat(output.injectedClass1).isSameAs(output.injectedClass2);
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/scope/ScopeTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/scope/ScopeTest.java
deleted file mode 100644
index 1cffdd306..000000000
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/scope/ScopeTest.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.scope;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public final class ScopeTest {
-
-  @Test
-  public void scope() throws Exception {
-    SetComponent component = DaggerSetComponent.create();
-    assertThat(component.set().get()).hasSize(1);
-    assertThat(component.scopedObject()).isSameAs(component.scopedObject());
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/MultiPackageSubcomponentTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/MultiPackageSubcomponentTest.java
deleted file mode 100644
index aca8ea165..000000000
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/MultiPackageSubcomponentTest.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.subcomponent;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import producerstest.subcomponent.MultiPackageSubcomponents.ParentComponent;
-import producerstest.subcomponent.sub.ChildComponent;
-
-@RunWith(JUnit4.class)
-public final class MultiPackageSubcomponentTest {
-
-  @Test
-  public void childComponent() throws Exception {
-    ParentComponent parent = DaggerMultiPackageSubcomponents_ParentComponent.create();
-    ChildComponent child = parent.childComponentBuilder().build();
-    assertThat(child.str().get()).isEqualTo("Hello, World 42");
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/ProducerModuleWithSubcomponentsTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/ProducerModuleWithSubcomponentsTest.java
deleted file mode 100644
index 24d43e5b6..000000000
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/ProducerModuleWithSubcomponentsTest.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.subcomponent;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import dagger.producers.ProducerModule;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import producerstest.subcomponent.UsesProducerModuleSubcomponents.ParentIncludesProductionSubcomponentTransitively;
-
-/** Tests for {@link ProducerModule#subcomponents()}. */
-@RunWith(JUnit4.class)
-public class ProducerModuleWithSubcomponentsTest {
-
-  @Test
-  public void subcomponentFromModules() throws Exception {
-    UsesProducerModuleSubcomponents parent = DaggerUsesProducerModuleSubcomponents.create();
-    assertThat(parent.strings().get()).containsExactly("from parent");
-    assertThat(parent.stringsFromChild().get()).containsExactly("from parent", "from child");
-  }
-
-  @Test
-  public void subcomponentFromModules_transitively() throws Exception {
-    ParentIncludesProductionSubcomponentTransitively parent =
-        DaggerUsesProducerModuleSubcomponents_ParentIncludesProductionSubcomponentTransitively
-            .create();
-    assertThat(parent.strings().get()).containsExactly("from parent");
-    assertThat(parent.stringsFromChild().get()).containsExactly("from parent", "from child");
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentWithBoundExecutorTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentWithBoundExecutorTest.java
deleted file mode 100644
index 14ae444c8..000000000
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/SubcomponentWithBoundExecutorTest.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.subcomponent;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import java.util.concurrent.atomic.AtomicInteger;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import producerstest.subcomponent.SubcomponentsWithBoundExecutor.ChildComponent;
-import producerstest.subcomponent.SubcomponentsWithBoundExecutor.ExecutorModule;
-import producerstest.subcomponent.SubcomponentsWithBoundExecutor.GrandchildComponent;
-import producerstest.subcomponent.SubcomponentsWithBoundExecutor.GrandchildComponentWithoutBuilder;
-import producerstest.subcomponent.SubcomponentsWithBoundExecutor.ParentComponent;
-import producerstest.subcomponent.SubcomponentsWithBoundExecutor.ParentProductionComponent;
-
-@RunWith(JUnit4.class)
-public final class SubcomponentWithBoundExecutorTest {
-  private ParentComponent parentComponent;
-  private ParentProductionComponent parentProductionComponent;
-  private final AtomicInteger executorConstructionCount = new AtomicInteger();
-  private final AtomicInteger executionCount = new AtomicInteger();
-
-  @Before
-  public void setUp() {
-    parentComponent =
-        DaggerSubcomponentsWithBoundExecutor_ParentComponent.builder()
-            .executorModule(new ExecutorModule(executorConstructionCount, executionCount))
-            .build();
-    parentProductionComponent =
-        DaggerSubcomponentsWithBoundExecutor_ParentProductionComponent.builder()
-            .executorModule(new ExecutorModule(executorConstructionCount, executionCount))
-            .build();
-  }
-
-  @Test
-  public void topLevelComponent_child() throws Exception {
-    ChildComponent child = parentComponent.newChildComponentBuilder().build();
-    assertThat(child.fromChild().get()).isEqualTo("child:parent");
-    assertThat(executorConstructionCount.get()).isEqualTo(1);
-    assertThat(executionCount.get()).isEqualTo(1);
-  }
-
-  @Test
-  public void topLevelComponent_injectsChildBuilder() throws Exception {
-    ChildComponent child = parentComponent.injectsChildBuilder().childBuilder().build();
-    assertThat(child.fromChild().get()).isEqualTo("child:parent");
-    assertThat(executorConstructionCount.get()).isEqualTo(1);
-    assertThat(executionCount.get()).isEqualTo(1);
-  }
-
-  @Test
-  public void topLevelComponent_grandchild() throws Exception {
-    ChildComponent child = parentComponent.newChildComponentBuilder().build();
-    GrandchildComponent grandchild = child.newGrandchildComponentBuilder().build();
-    assertThat(grandchild.fromGrandchild().get()).isEqualTo("grandchild:child:parent");
-    assertThat(executorConstructionCount.get()).isEqualTo(1);
-    assertThat(executionCount.get()).isEqualTo(2);
-  }
-
-  @Test
-  public void topLevelComponent_grandchildWithoutBuilder() throws Exception {
-    ChildComponent child = parentComponent.newChildComponentBuilder().build();
-    GrandchildComponentWithoutBuilder grandchild = child.newGrandchildComponent();
-    assertThat(grandchild.fromGrandchild().get()).isEqualTo("grandchild:child:parent");
-    assertThat(executorConstructionCount.get()).isEqualTo(1);
-    assertThat(executionCount.get()).isEqualTo(2);
-  }
-
-  @Test
-  public void topLevelProductionComponent_child() throws Exception {
-    ChildComponent child = parentProductionComponent.newChildComponentBuilder().build();
-    assertThat(child.fromChild().get()).isEqualTo("child:parentproduction");
-    assertThat(executorConstructionCount.get()).isEqualTo(1);
-    assertThat(executionCount.get()).isEqualTo(2);
-  }
-
-  @Test
-  public void topLevelProductionComponent_grandchild() throws Exception {
-    ChildComponent child = parentProductionComponent.newChildComponentBuilder().build();
-    GrandchildComponent grandchild = child.newGrandchildComponentBuilder().build();
-    assertThat(grandchild.fromGrandchild().get()).isEqualTo("grandchild:child:parentproduction");
-    assertThat(executorConstructionCount.get()).isEqualTo(1);
-    assertThat(executionCount.get()).isEqualTo(3);
-  }
-
-  @Test
-  public void topLevelProductionComponent_grandchildWithoutBuilder() throws Exception {
-    ChildComponent child = parentProductionComponent.newChildComponentBuilder().build();
-    GrandchildComponentWithoutBuilder grandchild = child.newGrandchildComponent();
-    assertThat(grandchild.fromGrandchild().get()).isEqualTo("grandchild:child:parentproduction");
-    assertThat(executorConstructionCount.get()).isEqualTo(1);
-    assertThat(executionCount.get()).isEqualTo(3);
-  }
-}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/pruning/ProductionSubcomponentOnlyRequestedBySiblingTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/pruning/ProductionSubcomponentOnlyRequestedBySiblingTest.java
deleted file mode 100644
index c579fb171..000000000
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/subcomponent/pruning/ProductionSubcomponentOnlyRequestedBySiblingTest.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package producerstest.subcomponent.pruning;
-
-import static com.google.common.truth.Truth.assertThat;
-
-import dagger.producers.ProducerModule;
-import dagger.producers.ProductionSubcomponent;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import producerstest.subcomponent.pruning.ParentDoesntUseProductionSubcomponent.ChildA;
-import producerstest.subcomponent.pruning.ParentDoesntUseProductionSubcomponent.ChildB;
-
-/**
- * Tests for {@link ProductionSubcomponent}s which are included with {@link
- * ProducerModule#subcomponents()} but not used directly within the component which adds them.
- *
- * <p>This tests to make sure that while resolving one subcomponent (A), another subcomponent (B)
- * can be requested if they have a shared ancestor component. If that shared ancestor did not
- * resolve B directly via any of its entry points, B will still be generated since it is requested
- * by a descendant.
- */
-@RunWith(JUnit4.class)
-public class ProductionSubcomponentOnlyRequestedBySiblingTest {
-  @Test
-  public void subcomponentAddedInParent_onlyUsedInSibling() throws Exception {
-    ParentDoesntUseProductionSubcomponent parent =
-        DaggerParentDoesntUseProductionSubcomponent.create();
-    ChildB childB = parent.childBBuilder().build();
-    assertThat(childB.componentHierarchy().get())
-        .containsExactly(ParentDoesntUseProductionSubcomponent.class, ChildB.class);
-    assertThat(childB.componentHierarchyFromChildA().get())
-        .containsExactly(ParentDoesntUseProductionSubcomponent.class, ChildA.class);
-  }
-}
diff --git a/compiler/src/it/tck/BUILD b/compiler/src/it/tck/BUILD
deleted file mode 100644
index c0979488c..000000000
--- a/compiler/src/it/tck/BUILD
+++ /dev/null
@@ -1,60 +0,0 @@
-# Copyright (C) 2017 The Dagger Authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-# Description:
-#  TCK tests for Dagger
-
-package(default_visibility = ["//:src"])
-
-load(
-    "//:build_defs.bzl",
-    "DOCLINT_HTML_AND_SYNTAX",
-    "DOCLINT_REFERENCES",
-    "PRE_JAVA_8_INFERENCE_OPTS",
-)
-
-# Sample code to be tested in functional tests.
-java_library(
-    name = "code_under_test",
-    testonly = 1,
-    srcs = glob(["src/main/java/**/*.java"]),
-    javacopts = PRE_JAVA_8_INFERENCE_OPTS + DOCLINT_HTML_AND_SYNTAX + [
-        "-Adagger.privateMemberValidation=warning",
-        "-Adagger.staticMemberValidation=warning",
-        "-Adagger.ignorePrivateAndStaticInjectionForComponent=enabled",
-    ],
-    deps = [
-        "//:dagger_with_compiler",
-        "//third_party:jsr330_inject",
-        "//third_party:jsr330_inject_tck",
-        "//third_party:junit",
-    ],
-)
-
-load("//:test_defs.bzl", "GenJavaTests")
-
-GenJavaTests(
-    name = "tck_tests",
-    srcs = glob(["src/test/java/**/*.java"]),
-    javacopts = PRE_JAVA_8_INFERENCE_OPTS + DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
-    deps = [
-        ":code_under_test",
-        "//:dagger_with_compiler",
-        "//third_party:jsr330_inject",
-        "//third_party:jsr330_inject_tck",
-        "//third_party:junit",
-    ],
-)
-
-test_suite(name = "AllTests")
diff --git a/compiler/src/it/tck/src/main/java/test/tck/CarModule.java b/compiler/src/it/tck/src/main/java/test/tck/CarModule.java
deleted file mode 100644
index 6ef5d3811..000000000
--- a/compiler/src/it/tck/src/main/java/test/tck/CarModule.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.tck;
-
-import dagger.Binds;
-import dagger.Module;
-import org.atinject.tck.auto.Car;
-import org.atinject.tck.auto.Convertible;
-
-@Module
-abstract class CarModule {
-  @Binds
-  abstract Car provideConvertible(Convertible convertible);
-}
diff --git a/compiler/src/it/tck/src/main/java/test/tck/CarShop.java b/compiler/src/it/tck/src/main/java/test/tck/CarShop.java
deleted file mode 100644
index 73f326d67..000000000
--- a/compiler/src/it/tck/src/main/java/test/tck/CarShop.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.tck;
-
-import dagger.Component;
-import javax.inject.Singleton;
-import org.atinject.tck.auto.Car;
-
-@Singleton
-@Component(
-  modules = {
-    CarModule.class,
-    TireModule.class,
-    SeatModule.class,
-    EngineModule.class,
-    FuelTankModule.class
-  }
-)
-public interface CarShop {
-  @SuppressWarnings("dependency-cycle")
-  Car make();
-}
diff --git a/compiler/src/it/tck/src/main/java/test/tck/EngineModule.java b/compiler/src/it/tck/src/main/java/test/tck/EngineModule.java
deleted file mode 100644
index dd27dcb40..000000000
--- a/compiler/src/it/tck/src/main/java/test/tck/EngineModule.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.tck;
-
-import dagger.MembersInjector;
-import dagger.Module;
-import dagger.Provides;
-import org.atinject.tck.auto.Engine;
-import org.atinject.tck.auto.V8Engine;
-
-@Module
-public class EngineModule {
-  @Provides
-  static Engine provideEngine(MembersInjector<V8Engine> injector) {
-    // This is provided because V8Engine has no @Inject constructor and Dagger requires an @Inject
-    // constructor, however this is a TCK supplied class that we prefer to leave unmodified.
-    V8Engine engine = new V8Engine();
-    injector.injectMembers(engine);
-    return engine;
-  }
-}
diff --git a/compiler/src/it/tck/src/main/java/test/tck/FuelTankModule.java b/compiler/src/it/tck/src/main/java/test/tck/FuelTankModule.java
deleted file mode 100644
index 77f6a4172..000000000
--- a/compiler/src/it/tck/src/main/java/test/tck/FuelTankModule.java
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.tck;
-
-import dagger.Module;
-import dagger.Provides;
-import org.atinject.tck.auto.FuelTank;
-
-@Module
-class FuelTankModule {
-  @Provides
-  static FuelTank provideFuelTank() {
-    return new FuelTank();
-  }
-}
diff --git a/compiler/src/it/tck/src/main/java/test/tck/SeatModule.java b/compiler/src/it/tck/src/main/java/test/tck/SeatModule.java
deleted file mode 100644
index e5a90c08e..000000000
--- a/compiler/src/it/tck/src/main/java/test/tck/SeatModule.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.tck;
-
-import dagger.Binds;
-import dagger.Module;
-import org.atinject.tck.auto.Drivers;
-import org.atinject.tck.auto.DriversSeat;
-import org.atinject.tck.auto.Seat;
-
-@Module
-abstract class SeatModule {
-  @Binds
-  @Drivers
-  abstract Seat provideSeat(DriversSeat seat);
-}
diff --git a/compiler/src/it/tck/src/main/java/test/tck/TireModule.java b/compiler/src/it/tck/src/main/java/test/tck/TireModule.java
deleted file mode 100644
index 8b668eda2..000000000
--- a/compiler/src/it/tck/src/main/java/test/tck/TireModule.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.tck;
-
-import dagger.Binds;
-import dagger.Module;
-import javax.inject.Named;
-import org.atinject.tck.auto.Tire;
-import org.atinject.tck.auto.accessories.SpareTire;
-
-@Module
-abstract class TireModule {
-  @Binds
-  @Named("spare")
-  abstract Tire provideTire(SpareTire sparetire);
-}
diff --git a/compiler/src/it/tck/src/test/java/test/tck/TckTest.java b/compiler/src/it/tck/src/test/java/test/tck/TckTest.java
deleted file mode 100644
index e6d6301a0..000000000
--- a/compiler/src/it/tck/src/test/java/test/tck/TckTest.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package test.tck;
-
-import junit.framework.Test;
-import org.atinject.tck.Tck;
-import org.atinject.tck.auto.Car;
-import org.atinject.tck.auto.Convertible;
-
-/** 
- * Test suite to execute the JSR-330 TCK in JUnit.
- */
-public class TckTest {
-  public static Test suite() {
-    CarShop carShopComponent = DaggerCarShop.create();
-    Car car = carShopComponent.make();
-    Convertible.localConvertible.set((Convertible) car);
-    return Tck.testsFor(car, false, false);
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 3d0a11f7f..ff548f4d0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -34,6 +34,7 @@
 import static dagger.internal.codegen.BindingKey.contribution;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.SINGLETON_INSTANCE;
+import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;
 import static dagger.internal.codegen.MapKeys.getMapKeyExpression;
 import static dagger.internal.codegen.MemberSelect.emptyFrameworkMapFactory;
@@ -47,10 +48,8 @@
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;
-import static dagger.internal.codegen.SourceFiles.simpleVariableName;
 import static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;
 import static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;
-import static dagger.internal.codegen.TypeNames.FACTORY;
 import static dagger.internal.codegen.TypeNames.INSTANCE_FACTORY;
 import static dagger.internal.codegen.TypeNames.LISTENABLE_FUTURE;
 import static dagger.internal.codegen.TypeNames.MAP_FACTORY;
@@ -73,6 +72,7 @@
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.VOID;
 
@@ -155,6 +155,7 @@
   private final Map<BindingKey, MemberSelect> memberSelects = new HashMap<>();
   private final Map<BindingKey, MemberSelect> producerFromProviderMemberSelects = new HashMap<>();
   private final RequestFulfillmentRegistry requestFulfillmentRegistry;
+  protected TypeMirror application;
   protected final MethodSpec.Builder constructor = constructorBuilder().addModifiers(PRIVATE);
   protected Optional<ClassName> builderName = Optional.empty();
   private Map<Key, String> delegateFieldNames = new HashMap<>();
@@ -191,7 +192,8 @@
       ClassName name,
       BindingGraph graph,
       ImmutableMap<ComponentDescriptor, String> subcomponentNames,
-      OptionalFactories optionalFactories) {
+      OptionalFactories optionalFactories,
+      TypeMirror application) {
     this.types = types;
     this.elements = elements;
     this.keyFactory = keyFactory;
@@ -203,6 +205,7 @@
     this.optionalFactories = optionalFactories;
     this.requestFulfillmentRegistry =
         new RequestFulfillmentRegistry(graph.resolvedBindings(), this);
+    this.application = application;
   }
 
   protected AbstractComponentWriter(
@@ -215,7 +218,9 @@ protected AbstractComponentWriter(
         name,
         graph,
         parent.subcomponentNames,
-        parent.optionalFactories);
+        parent.optionalFactories,
+        parent.application
+    );
   }
 
   protected final ClassName componentDefinitionTypeName() {
@@ -271,7 +276,7 @@ private CodeBlock getComponentContributionExpression(ComponentRequirement compon
     return FieldSpec.builder(type, componentFieldNames.getUniqueName(name));
   }
 
-  private CodeBlock getMemberSelectExpression(BindingKey key) {
+  protected CodeBlock getMemberSelectExpression(BindingKey key) {
     return getMemberSelect(key).getExpressionFor(name);
   }
 
@@ -312,6 +317,7 @@ protected CodeBlock getReferenceReleasingProviderManagerExpression(Scope scope)
     addFactoryMethods();
     addReferenceReleasingProviderManagerFields();
     addFrameworkFields();
+    postAddBuildMethod();
     initializeFrameworkTypes();
     implementInterfaceMethods();
     addSubcomponents();
@@ -503,6 +509,8 @@ private void addBuilderMethods(
     }
   }
 
+  public void postAddBuildMethod() {}
+
   private void addBuilderMethodReturnStatementForSpec(
       ExecutableElement specMethod, MethodSpec.Builder builderMethod) {
     if (!specMethod.getReturnType().getKind().equals(VOID)) {
@@ -922,8 +930,6 @@ private void addSubcomponents() {
   private void initializeFrameworkTypes() {
     ImmutableList.Builder<CodeBlock> codeBlocks = ImmutableList.builder();
 
-    //codeBlocks.add(initDelegateFields());
-
     for (BindingKey bindingKey : graph.resolvedBindings().keySet()) {
       initializeFrameworkType(bindingKey).ifPresent(codeBlocks::add);
     }
@@ -1012,10 +1018,7 @@ private void initializeFrameworkTypes() {
                 ImmutableList.of(
                     initializeDeferredDependencies(binding),
                     initializeMember(
-                        bindingKey,
-                        binding.scope().isPresent()
-                            ? decorateForScope(delegatingCodeBlock, binding.scope().get())
-                            : delegatingCodeBlock))));
+                        bindingKey, decorateForScope(delegatingCodeBlock, binding.scope())))));
       case SINGLETON_INSTANCE:
         if (!binding.scope().isPresent()) {
           return Optional.empty();
@@ -1151,15 +1154,16 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
         {
           TypeElement dependencyType = dependencyTypeForBinding(binding);
           String dependencyVariable = simpleVariableName(dependencyType);
+          String componentMethod = binding.bindingElement().get().getSimpleName().toString();
           CodeBlock callFactoryMethod =
-              CodeBlock.of(
-                  "$L.$L()", dependencyVariable, binding.bindingElement().get().getSimpleName());
+              CodeBlock.of("$L.$L()", dependencyVariable, componentMethod);
           // TODO(sameb): This throws a very vague NPE right now.  The stack trace doesn't
           // help to figure out what the method or return type is.  If we include a string
           // of the return type or method name in the error message, that can defeat obfuscation.
           // We can easily include the raw type (no generics) + annotation type (no values),
           // using .class & String.format -- but that wouldn't be the whole story.
           // What should we do?
+/*<<<<<<< HEAD:compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
 
           CodeBlock.Builder getMethodBodyBuilder = CodeBlock.builder();
           getMethodBodyBuilder.add(getCodeBlock(binding, callFactoryMethod));
@@ -1173,17 +1177,61 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
                       "    $7L",
                       "  }",
                       "}"),
-              /* 1 */ FACTORY,
-              /* 2 */ bindingKeyTypeName,
-              /* 3 */ getComponentContributionExpression(
+                      FACTORY,
+                      bindingKeyTypeName,
+                      getComponentContributionExpression(
                   ComponentRequirement.forDependency(dependencyType.asType())),
-              /* 4 */ nullableAnnotation(binding.nullableType()),
-              /* 5 */ TypeName.get(dependencyType.asType()),
-              /* 6 */ dependencyVariable,
-              /* 7 */ getMethodBodyBuilder.build());
+                      nullableAnnotation(binding.nullableType()),
+                      TypeName.get(dependencyType.asType()),
+                      dependencyVariable,
+                      getMethodBodyBuilder.build());
+=======*/
+          CodeBlock getMethodBody =
+              binding.nullableType().isPresent()
+                      || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)
+                  ? CodeBlock.of("return $L;", callFactoryMethod)
+                  : CodeBlock.of(
+                      "return $T.checkNotNull($L, $S);",
+                      Preconditions.class,
+                      callFactoryMethod,
+                      CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+          ClassName dependencyClassName = ClassName.get(dependencyType);
+          String factoryName =
+              dependencyClassName.toString().replace('.', '_') + "_" + componentMethod;
+          MethodSpec.Builder getMethod =
+              methodBuilder("get")
+                  .addAnnotation(Override.class)
+                  .addModifiers(PUBLIC)
+                  .returns(bindingKeyTypeName)
+                  .addCode(getMethodBody);
+          if (binding.nullableType().isPresent()) {
+            getMethod.addAnnotation(
+                ClassName.get(MoreTypes.asTypeElement(binding.nullableType().get())));
+          }
+          component.addType(
+              TypeSpec.classBuilder(factoryName)
+                  .addSuperinterface(providerOf(bindingKeyTypeName))
+                  .addModifiers(PRIVATE, STATIC)
+                  .addField(dependencyClassName, dependencyVariable, PRIVATE, FINAL)
+                  .addMethod(
+                      constructorBuilder()
+                          .addParameter(dependencyClassName, dependencyVariable)
+                          .addStatement("this.$1L = $1L", dependencyVariable)
+                          .build())
+                  .addMethod(getMethod.build())
+                  .build());
+          return CodeBlock.of(
+              "new $L($L)",
+              factoryName,
+              getComponentContributionExpression(
+                  ComponentRequirement.forDependency(dependencyType.asType())));
+//>>>>>>> upstream/master:java/dagger/internal/codegen/AbstractComponentWriter.java
         }
 
       case SUBCOMPONENT_BUILDER:
+
+        final CodeBlock expression = getMemberSelectExpression(BindingKey.contribution(Key.builder(application).build()));
+
         String subcomponentName =
             subcomponentNames.get(
                 graph.componentDescriptor()
@@ -1192,16 +1240,21 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
         return CodeBlock.of(
             Joiner.on('\n')
                 .join(
-                    "new $1T<$2T>() {",
+                    "new $1L<$2T>() {",
                     "  @Override public $2T get() {",
-                    "    return new $3LBuilder();",
+                    "    return $4L.get().$5L(new $3LBuilder());",
                     "  }",
                     "}"),
-            /* 1 */ FACTORY,
+            // TODO(ronshapiro): Until we remove Factory, fully qualify the import so it doesn't
+            // conflict with dagger.android.ActivityInjector.Factory
+            /* 1 */ "dagger.internal.Factory",
             /* 2 */ bindingKeyTypeName,
-            /* 3 */ subcomponentName);
+            /* 3 */ subcomponentName,
+            /* 4 */ expression,
+            /* 5 */ Util.lowerCaseFirstLetter(subcomponentName));
 
       case BUILDER_BINDING:
+
         final CodeBlock parameter = getComponentContributionExpression(ComponentRequirement.forBinding(binding));
         CodeBlock parameterDecision;
         if (delegateFieldName != null && bindingSupportsTestDelegate(binding)) {
@@ -1236,9 +1289,16 @@ private CodeBlock initializeFactoryForContributionBinding(ContributionBinding bi
                   "$T.create($L)",
                   generatedClassNameForBinding(binding),
                   makeParametersCodeBlock(arguments));
-          return binding.scope().isPresent()
-              ? decorateForScope(factoryCreate, binding.scope().get())
-              : factoryCreate;
+
+          // If scoping a parameterized factory for an @Inject class, Java 7 cannot always infer the
+          // type properly, so cast to a raw framework type before scoping.
+          if (binding.bindingKind().equals(INJECTION)
+              && binding.unresolved().isPresent()
+              && binding.scope().isPresent()) {
+            factoryCreate =
+                CodeBlock.of("($T) $L", binding.bindingType().frameworkClass(), factoryCreate);
+          }
+          return decorateForScope(factoryCreate, binding.scope());
         }
 
       case COMPONENT_PRODUCTION:
@@ -1323,7 +1383,11 @@ private TypeElement dependencyTypeForBinding(ContributionBinding binding) {
     return graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement().get());
   }
 
-  private CodeBlock decorateForScope(CodeBlock factoryCreate, Scope scope) {
+  private CodeBlock decorateForScope(CodeBlock factoryCreate, Optional<Scope> maybeScope) {
+    if (!maybeScope.isPresent()) {
+      return factoryCreate;
+    }
+    Scope scope = maybeScope.get();
     if (requiresReleasableReferences(scope)) {
       return CodeBlock.of(
           "$T.create($L, $L)",
@@ -1338,12 +1402,6 @@ private CodeBlock decorateForScope(CodeBlock factoryCreate, Scope scope) {
     }
   }
 
-  private CodeBlock nullableAnnotation(Optional<DeclaredType> nullableType) {
-    return nullableType.isPresent()
-        ? CodeBlock.of("@$T ", TypeName.get(nullableType.get()))
-        : CodeBlock.of("");
-  }
-
   private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding binding) {
     return binding.injectionSites().isEmpty()
         ? CodeBlock.of("$T.noOp()", MEMBERS_INJECTORS)
diff --git a/compiler/src/main/java/dagger/internal/codegen/ApplicationGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ApplicationGenerator.java
index de999e8d2..1f4444ec0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ApplicationGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ApplicationGenerator.java
@@ -45,14 +45,14 @@ ClassName nameGeneratedType(DI input) {
     Optional<TypeSpec.Builder> write(ClassName generatedTypeName, DI di) {
         final TypeSpec.Builder builder = TypeSpec.classBuilder(generatedTypeName);
         TypeName superclass = ClassName.get(di.getBaseAppClass());
-        builder.addModifiers(Modifier.PUBLIC).superclass(superclass);
+        builder.addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT).superclass(superclass);
         builder.addSuperinterface(TYPENAME_INJECTOR_SPEC);
         final Set<TypeElement> components = di.getComponents();
 
         builder.addField(TYPENAME_INJECTOR, FIELDNAME_INJECTOR, Modifier.PRIVATE);
 
         for (TypeElement component : components) {
-            final List<SpecComponentInfo> infos = ComponentInfo.forSpec(component, componentDescriptorFactory, bindingGraphFactory);
+            final List<SpecComponentInfo> infos = ComponentInfo.forSpec(component, componentDescriptorFactory, bindingGraphFactory, di.getAppClass().asType());
             final List<MethodSpec.Builder> methodBuilders = infos.stream()
                     .flatMap(info -> info.getMethods().stream())
                     .collect(Collectors.toList());
diff --git a/compiler/src/main/java/dagger/internal/codegen/BasicProcessor.java b/compiler/src/main/java/dagger/internal/codegen/BasicProcessor.java
index c33ac127f..00ce55fe6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BasicProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BasicProcessor.java
@@ -65,7 +65,7 @@
  * access the {@link ProcessingEnvironment} using {@link #processingEnv}.
  *
  * Any logic that needs to happen once per round can be specified by overriding
- * {@link #postRound(RoundEnvironment, boolean)}.
+ * {@link #postRound(RoundEnvironment)}.
  *
  * <h3>Ill-formed elements are deferred</h3>
  * Any annotated element whose nearest enclosing type is not well-formed is deferred, and not passed
@@ -75,7 +75,6 @@
  * <p>A non-package element is considered well-formed if its type, type parameters, parameters,
  * default values, supertypes, annotations, and enclosed elements are. Package elements are treated
  * similarly, except that their enclosed elements are not validated. See
- * {@link SuperficialValidation#validateElement(Element)} for details.
  *
  * <p>The primary disadvantage to this validation is that any element that forms a circular
  * dependency with a type generated by another {@code BasicAnnotationProcessor} will never compile
@@ -85,7 +84,7 @@
  * <h3>Each {@code ProcessingStep} can defer elements</h3>
  *
  * <p>Each {@code ProcessingStep} can defer elements by including them in the set returned by
- * {@link ProcessingStep#process(SetMultimap)}; elements deferred by a step will be passed back to
+ * elements deferred by a step will be passed back to
  * that step in a later round of processing.
  *
  * <p>This feature is useful when one processor may depend on code generated by another,
@@ -121,7 +120,7 @@ public final synchronized void init(ProcessingEnvironment processingEnv) {
     }
 
     /**
-     * Creates {@linkplain BasicAnnotationProcessor#ProcessingStep processing steps} for this processor.
+     * Creates {@linkplain ProcessingStep processing steps} for this processor.
      * {@link #processingEnv} is guaranteed to be set when this method is invoked.
      */
     protected abstract Iterable<? extends ProcessingStep> initSteps();
@@ -129,7 +128,7 @@ public final synchronized void init(ProcessingEnvironment processingEnv) {
     /**
      * An optional hook for logic to be executed at the end of each round.
      *
-     * @deprecated use {@link #postRound(RoundEnvironment, boolean)} instead
+     * @deprecated use {@link #postRound(RoundEnvironment)} instead
      */
     @Deprecated
     protected void postProcess() {}
@@ -152,7 +151,7 @@ protected void postRound(RoundEnvironment roundEnv) {
 
     /**
      * Returns the set of supported annotation types as a  collected from registered
-     * {@linkplain BasicAnnotationProcessor#ProcessingStep processing steps}.
+     * {@linkplain ProcessingStep}.
      */
     @Override
     public final ImmutableSet<String> getSupportedAnnotationTypes() {
@@ -329,7 +328,7 @@ private void process(ImmutableSetMultimap<Class<? extends Annotation>, Element>
                 elementsDeferredBySteps.removeAll(step);
             } else {
                 Set<? extends Element> rejectedElements = step.process(stepElements, rejectedAnyElements);
-                if (rejectedElements.isEmpty() && !rejectedAnyElements) {
+                if (!rejectedElements.isEmpty() && !rejectedAnyElements) {
                     rejectedAnyElements = true;
                 }
                 elementsDeferredBySteps.replaceValues(
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index 5e1d385ac..bb1e073ec 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -16,13 +16,14 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.Suppliers.memoize;
 import static com.google.common.collect.Iterables.getOnlyElement;
-import static java.util.stream.Collectors.toList;
+import static dagger.internal.codegen.Util.toImmutableList;
 import static javax.lang.model.element.Modifier.PUBLIC;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.value.AutoValue;
-import com.google.auto.value.extension.memoized.Memoized;
+import com.google.common.base.Supplier;
 import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -91,6 +92,14 @@
         : Sets.union(implicitDependencies, explicitDependencies());
   }
 
+  private final Supplier<ImmutableList<FrameworkDependency>> frameworkDependencies =
+      memoize(
+          () ->
+              dependencyAssociations()
+                  .stream()
+                  .map(DependencyAssociation::frameworkDependency)
+                  .collect(toImmutableList()));
+
   /**
    * The framework dependencies of {@code binding}. There will be one element for each different
    * binding key in the <em>{@linkplain Binding#unresolved() unresolved}</em> version of {@code
@@ -125,13 +134,8 @@
   /* TODO(dpb): The stable-order postcondition is actually hard to verify in code for two equal
    * instances of Binding, because it really depends on the order of the binding's dependencies,
    * and two equal instances of Binding may have the same dependencies in a different order. */
-  @Memoized
   ImmutableList<FrameworkDependency> frameworkDependencies() {
-    return ImmutableList.copyOf(
-        dependencyAssociations()
-            .stream()
-            .map(DependencyAssociation::frameworkDependency)
-            .collect(toList()));
+    return frameworkDependencies.get();
   }
 
   /**
@@ -151,6 +155,25 @@ static DependencyAssociation create(
     }
   }
 
+  private final Supplier<ImmutableList<DependencyAssociation>> dependencyAssociations =
+      memoize(
+          () -> {
+            BindingTypeMapper bindingTypeMapper = BindingTypeMapper.forBindingType(bindingType());
+            ImmutableList.Builder<DependencyAssociation> list = ImmutableList.builder();
+            for (Collection<DependencyRequest> requests : groupByUnresolvedKey()) {
+              list.add(
+                  DependencyAssociation.create(
+                      FrameworkDependency.create(
+                          getOnlyElement(
+                              FluentIterable.from(requests)
+                                  .transform(DependencyRequest::bindingKey)
+                                  .toSet()),
+                          bindingTypeMapper.getBindingType(requests)),
+                      requests));
+            }
+            return list.build();
+          });
+
   /**
    * Returns the same {@link FrameworkDependency} instances from {@link #frameworkDependencies}, but
    * with the set of {@link DependencyRequest} instances with which each is associated.
@@ -160,38 +183,32 @@ static DependencyAssociation create(
    * multiple times if the {@linkplain Binding#unresolved() unresolved} binding requires it. If that
    * distinction is not important, the entries can be merged into a single mapping.
    */
-  @Memoized
   ImmutableList<DependencyAssociation> dependencyAssociations() {
-    BindingTypeMapper bindingTypeMapper = BindingTypeMapper.forBindingType(bindingType());
-    ImmutableList.Builder<DependencyAssociation> frameworkDependencies = ImmutableList.builder();
-    for (Collection<DependencyRequest> requests : groupByUnresolvedKey()) {
-      frameworkDependencies.add(
-          DependencyAssociation.create(
-              FrameworkDependency.create(
-                  getOnlyElement(
-                      FluentIterable.from(requests)
-                          .transform(DependencyRequest::bindingKey)
-                          .toSet()),
-                  bindingTypeMapper.getBindingType(requests)),
-              requests));
-    }
-    return frameworkDependencies.build();
+    return dependencyAssociations.get();
   }
 
+  private final Supplier<ImmutableMap<DependencyRequest, FrameworkDependency>>
+      frameworkDependenciesMap =
+          memoize(
+              () -> {
+                ImmutableMap.Builder<DependencyRequest, FrameworkDependency> frameworkDependencies =
+                    ImmutableMap.builder();
+                for (DependencyAssociation dependencyAssociation : dependencyAssociations()) {
+                  for (DependencyRequest dependencyRequest :
+                      dependencyAssociation.dependencyRequests()) {
+                    frameworkDependencies.put(
+                        dependencyRequest, dependencyAssociation.frameworkDependency());
+                  }
+                }
+                return frameworkDependencies.build();
+              });
+
   /**
    * Returns the mapping from each {@linkplain #dependencies dependency} to its associated {@link
    * FrameworkDependency}.
    */
-  @Memoized
   ImmutableMap<DependencyRequest, FrameworkDependency> dependenciesToFrameworkDependenciesMap() {
-    ImmutableMap.Builder<DependencyRequest, FrameworkDependency> frameworkDependencyMap =
-        ImmutableMap.builder();
-    for (DependencyAssociation dependencyAssociation : dependencyAssociations()) {
-      for (DependencyRequest dependencyRequest : dependencyAssociation.dependencyRequests()) {
-        frameworkDependencyMap.put(dependencyRequest, dependencyAssociation.frameworkDependency());
-      }
-    }
-    return frameworkDependencyMap.build();
+    return frameworkDependenciesMap.get();
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index f39142f2f..5f1e84fcb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -40,16 +40,7 @@
 import com.google.common.base.VerifyException;
 import com.google.common.cache.Cache;
 import com.google.common.cache.CacheBuilder;
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.ImmutableSetMultimap;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
-import com.google.common.collect.TreeTraverser;
+import com.google.common.collect.*;
 import dagger.Reusable;
 import dagger.Subcomponent;
 import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
@@ -68,6 +59,7 @@
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 
@@ -227,6 +219,7 @@ TypeElement componentType() {
     private final Key.Factory keyFactory;
     private final ProvisionBinding.Factory provisionBindingFactory;
     private final ProductionBinding.Factory productionBindingFactory;
+    private TypeMirror application;
 
     Factory(
         Elements elements,
@@ -241,19 +234,19 @@ TypeElement componentType() {
       this.productionBindingFactory = productionBindingFactory;
     }
 
-    BindingGraph create(ComponentDescriptor componentDescriptor) {
+    BindingGraph create(ComponentDescriptor componentDescriptor, TypeMirror application) {
+      this.application = application;
       return create(Optional.empty(), componentDescriptor);
     }
 
-    private BindingGraph create(
-        Optional<Resolver> parentResolver, ComponentDescriptor componentDescriptor) {
+    private BindingGraph create(Optional<Resolver> parentResolver, ComponentDescriptor componentDescriptor) {
+
       ImmutableSet.Builder<ContributionBinding> explicitBindingsBuilder = ImmutableSet.builder();
       ImmutableSet.Builder<DelegateDeclaration> delegatesBuilder = ImmutableSet.builder();
       ImmutableSet.Builder<OptionalBindingDeclaration> optionalsBuilder = ImmutableSet.builder();
 
       // binding for the component itself
-      explicitBindingsBuilder.add(
-          provisionBindingFactory.forComponent(componentDescriptor.componentDefinitionType()));
+      explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDescriptor.componentDefinitionType()));
 
       // Collect Component dependencies.
       for (TypeElement componentDependency : componentDescriptor.dependencies()) {
@@ -277,7 +270,8 @@ private BindingGraph create(
         for (BuilderRequirementMethod method :
             componentDescriptor.builderSpec().get().requirementMethods()) {
           if (method.requirement().kind().equals(ComponentRequirement.Kind.BINDING)) {
-            explicitBindingsBuilder.add(provisionBindingFactory.forBuilderBinding(method));
+            final ProvisionBinding builderBinding = provisionBindingFactory.forBuilderBinding(method);
+            explicitBindingsBuilder.add(builderBinding);
           }
         }
       }
@@ -291,7 +285,7 @@ private BindingGraph create(
           explicitBindingsBuilder.add(
               provisionBindingFactory.forSubcomponentBuilderMethod(
                   componentMethod.methodElement(),
-                  componentDescriptor.componentDefinitionType()));
+                  componentDescriptor.componentDefinitionType(), application));
         }
       }
 
@@ -346,6 +340,8 @@ private BindingGraph create(
               indexByKey(subcomponentDeclarations.build()),
               indexByKey(delegatesBuilder.build()),
               indexByKey(optionalsBuilder.build()));
+
+
       for (ComponentMethodDescriptor componentMethod : componentDescriptor.componentMethods()) {
         Optional<DependencyRequest> componentMethodRequest = componentMethod.dependencyRequest();
         if (componentMethodRequest.isPresent()) {
@@ -453,9 +449,10 @@ private BindingGraph create(
        * <p>For {@link BindingKey.Kind#MEMBERS_INJECTION} requests, returns the {@link
        * MembersInjectionBinding} for the type.
        */
-      ResolvedBindings lookUpBindings(BindingKey bindingKey) {
+      ResolvedBindings lookUpBindings(BindingKey bindingKey, TypeMirror application) {
         Key requestKey = bindingKey.key();
         switch (bindingKey.kind()) {
+
           case CONTRIBUTION:
             Set<ContributionBinding> contributionBindings = new LinkedHashSet<>();
             ImmutableSet.Builder<ContributionBinding> multibindingContributionsBuilder =
@@ -489,14 +486,14 @@ ResolvedBindings lookUpBindings(BindingKey bindingKey) {
             maybeContributionBindings.add(
                 syntheticMultibinding(requestKey, multibindingContributions, multibindingDeclarations)
             );
-            syntheticSubcomponentBuilderBinding(subcomponentDeclarations)
+            syntheticSubcomponentBuilderBinding(subcomponentDeclarations, application)
                 .ifPresent(
                     binding -> {
                       contributionBindings.add(binding);
                       addSubcomponentToOwningResolver(binding);
                     });
             maybeContributionBindings.add(
-                syntheticOptionalBinding(requestKey, optionalBindingDeclarations));
+                syntheticOptionalBinding(requestKey, optionalBindingDeclarations, application));
 
             /* If there are no bindings, add the implicit @Inject-constructed binding if there is
              * one. */
@@ -514,6 +511,12 @@ ResolvedBindings lookUpBindings(BindingKey bindingKey) {
                 .map(Optional::get)
                 .forEach(contributionBindings::add);
 
+            if (bindingKey.key().type().toString().equals(application.toString())) {
+              explicitBindingsSet.stream()
+                      .filter(contributionBinding -> contributionBinding.key().type().toString().equals(application.toString()))
+                      .findFirst().ifPresent(contributionBindings::add);
+            }
+
             return ResolvedBindings.forContributionBindings(
                 bindingKey,
                 componentDescriptor,
@@ -662,11 +665,11 @@ private boolean multibindingsRequireProduction(
       }
 
       private Optional<ProvisionBinding> syntheticSubcomponentBuilderBinding(
-          ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations) {
+              ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations, TypeMirror application) {
         return subcomponentDeclarations.isEmpty()
             ? Optional.empty()
             : Optional.of(
-                provisionBindingFactory.syntheticSubcomponentBuilder(subcomponentDeclarations));
+                provisionBindingFactory.syntheticSubcomponentBuilder(subcomponentDeclarations, application));
       }
 
       /**
@@ -680,12 +683,12 @@ private boolean multibindingsRequireProduction(
        * binding. Otherwise returns a provision binding.
        */
       private Optional<ContributionBinding> syntheticOptionalBinding(
-          Key key, ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations) {
+          Key key, ImmutableSet<OptionalBindingDeclaration> optionalBindingDeclarations, TypeMirror application) {
         if (optionalBindingDeclarations.isEmpty()) {
           return Optional.empty();
         }
         ResolvedBindings underlyingKeyBindings =
-            lookUpBindings(contribution(keyFactory.unwrapOptional(key).get()));
+            lookUpBindings(contribution(keyFactory.unwrapOptional(key).get()), application);
         if (underlyingKeyBindings.isEmpty()) {
           return Optional.of(provisionBindingFactory.syntheticAbsentBinding(key));
         } else if (underlyingKeyBindings.bindingTypes().contains(BindingType.PRODUCTION)) {
@@ -720,7 +723,7 @@ private ContributionBinding createDelegateBinding(DelegateDeclaration delegateDe
         ResolvedBindings resolvedDelegate;
         try {
           cycleStack.push(delegateBindingKey);
-          resolvedDelegate = lookUpBindings(delegateBindingKey);
+          resolvedDelegate = lookUpBindings(delegateBindingKey, application);
         } finally {
           cycleStack.pop();
         }
@@ -955,6 +958,7 @@ private boolean isResolvedInParent(BindingKey bindingKey, ContributionBinding bi
       }
 
       void resolve(BindingKey bindingKey) {
+
         // If we find a cycle, stop resolving. The original request will add it with all of the
         // other resolved deps.
         if (cycleStack.contains(bindingKey)) {
@@ -993,7 +997,7 @@ void resolve(BindingKey bindingKey) {
 
         cycleStack.push(bindingKey);
         try {
-          ResolvedBindings bindings = lookUpBindings(bindingKey);
+          ResolvedBindings bindings = lookUpBindings(bindingKey, application);
           for (Binding binding : bindings.ownedBindings()) {
             for (DependencyRequest dependency : binding.dependencies()) {
               resolve(dependency.bindingKey());
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
index 26c5d8755..d68d86975 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraphValidator.java
@@ -91,6 +91,7 @@
 import dagger.MapKey;
 import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
 import dagger.internal.codegen.ComponentDescriptor.BuilderSpec;
+import dagger.internal.codegen.ComponentRequirement.NullPolicy;
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.releasablereferences.CanReleaseReferences;
 import dagger.releasablereferences.ForReleasableReferences;
@@ -354,7 +355,8 @@ private void validateBuilders(BindingGraph graph) {
       Set<ComponentRequirement> availableDependencies = graph.availableDependencies();
       Set<ComponentRequirement> requiredDependencies =
           Sets.filter(
-              availableDependencies, input -> !componentCanMakeNewInstances(input.typeElement()));
+              availableDependencies,
+              input -> input.nullPolicy(elements, types).equals(NullPolicy.THROW));
       final BuilderSpec spec = componentDesc.builderSpec().get();
       ImmutableSet<BuilderRequirementMethod> declaredSetters =
           spec.requirementMethods()
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
index 084224540..0b5f96b09 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
@@ -162,8 +162,7 @@ protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder)
    * Adds an error if the method is not declared in a class or interface annotated with one of the
    * {@link #enclosingElementAnnotations}.
    */
-  // TODO(b/28861722): Make private once @Multibindings is deleted.
-  protected void checkEnclosingElement(ValidationReport.Builder<ExecutableElement> builder) {
+  private void checkEnclosingElement(ValidationReport.Builder<ExecutableElement> builder) {
     if (!isAnyAnnotationPresent(
         builder.getSubject().getEnclosingElement(), enclosingElementAnnotations)) {
       builder.addError(
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
index 3108e8a25..780963820 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
@@ -73,7 +73,7 @@ private void checkParameters(ValidationReport.Builder<ExecutableElement> builder
     List<? extends VariableElement> parameters = method.getParameters();
     if (parameters.size() == 1) {
       VariableElement parameter = getOnlyElement(parameters);
-      TypeMirror leftHandSide = method.getReturnType();
+      TypeMirror leftHandSide = boxIfNecessary(method.getReturnType());
       TypeMirror rightHandSide = parameter.asType();
       ContributionType contributionType = ContributionType.fromBindingMethod(method);
       switch (contributionType) {
@@ -152,4 +152,11 @@ private TypeElement mapElement() {
   private TypeMirror unboundedWildcard() {
     return types.getWildcardType(null, null);
   }
+
+  private TypeMirror boxIfNecessary(TypeMirror maybePrimitive) {
+    if (maybePrimitive.getKind().isPrimitive()) {
+      return types.boxedClass(MoreTypes.asPrimitiveType(maybePrimitive)).asType();
+    }
+    return maybePrimitive;
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
index edad7b733..72df34e5c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BuilderValidator.java
@@ -23,9 +23,15 @@
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.util.ElementFilter.methodsIn;
 
+import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableSet;
+import dagger.internal.codegen.ErrorMessages.ComponentBuilderMessages;
+import dagger.internal.codegen.ValidationReport.Builder;
 import java.lang.annotation.Annotation;
+import java.util.Arrays;
 import java.util.List;
 import java.util.Set;
 import javax.lang.model.element.Element;
@@ -45,6 +51,7 @@
  * @author sameb@google.com (Sam Berlin)
  */
 class BuilderValidator {
+
   private final Elements elements;
   private final Types types;
 
@@ -102,20 +109,34 @@
     }
 
     ExecutableElement buildMethod = null;
-    for (ExecutableElement method : getUnimplementedMethods(elements, types, subject)) {
+    for (ExecutableElement method : getUnimplementedMethods(subject, types, elements)) {
       ExecutableType resolvedMethodType =
           MoreTypes.asExecutable(types.asMemberOf(MoreTypes.asDeclared(subject.asType()), method));
       TypeMirror returnType = resolvedMethodType.getReturnType();
       if (method.getParameters().size() == 0) {
         // If this is potentially a build() method, validate it returns the correct type.
-        if (types.isSameType(returnType, componentElement.asType())) {
+        if (types.isSubtype(componentElement.asType(), returnType)) {
+          validateBuildMethodReturnType(
+              builder,
+              // since types.isSubtype() passed, componentElement cannot be a PackageElement
+              MoreElements.asType(componentElement),
+              msgs,
+              method,
+              returnType);
           if (buildMethod != null) {
             // If we found more than one build-like method, fail.
-            error(builder, method, msgs.twoBuildMethods(), msgs.inheritedTwoBuildMethods(),
+            error(
+                builder,
+                method,
+                msgs.twoBuildMethods(),
+                msgs.inheritedTwoBuildMethods(),
                 buildMethod);
           }
         } else {
-          error(builder, method, msgs.buildMustReturnComponentType(),
+          error(
+              builder,
+              method,
+              msgs.buildMustReturnComponentType(),
               msgs.inheritedBuildMustReturnComponentType());
         }
         // We set the buildMethod regardless of the return type to reduce error spam.
@@ -151,6 +172,25 @@
     return builder.build();
   }
 
+  private void validateBuildMethodReturnType(
+      ValidationReport.Builder<TypeElement> builder,
+      TypeElement componentElement,
+      ComponentBuilderMessages msgs,
+      ExecutableElement method,
+      TypeMirror returnType) {
+    if (types.isSameType(componentElement.asType(), returnType)) {
+      return;
+    }
+    ImmutableSet<ExecutableElement> methodsOnlyInComponent =
+        methodsOnlyInComponent(componentElement);
+    if (!methodsOnlyInComponent.isEmpty()) {
+      builder.addWarning(
+          msgs.buildMethodReturnsSupertypeWithMissingMethods(
+              componentElement, builder.getSubject(), returnType, method, methodsOnlyInComponent),
+          method);
+    }
+  }
+
   /**
    * Generates one of two error messages. If the method is enclosed in the subject, we target the
    * error to the method itself. Otherwise we target the error to the subject and list the method as
@@ -169,7 +209,7 @@
    * This check is a little more strict than necessary -- ideally we'd check if method's enclosing
    * class was included in this compile run.  But that's hard, and this is close enough.
    */
-  private void error(
+  private static void error(
       ValidationReport.Builder<TypeElement> builder,
       ExecutableElement method,
       String enclosedError,
@@ -178,10 +218,37 @@ private void error(
     if (method.getEnclosingElement().equals(builder.getSubject())) {
       builder.addError(String.format(enclosedError, extraArgs), method);
     } else {
-      Object[] newArgs = new Object[extraArgs.length + 1];
-      newArgs[0] = method;
-      System.arraycopy(extraArgs, 0, newArgs, 1, extraArgs.length);
-      builder.addError(String.format(inheritedError, newArgs));
+      builder.addError(String.format(inheritedError, append(extraArgs, method)));
     }
   }
+
+  /** @see #error(Builder, ExecutableElement, String, String, Object...) */
+  private static void warning(
+      ValidationReport.Builder<TypeElement> builder,
+      ExecutableElement method,
+      String enclosedWarning,
+      String inheritedWarning,
+      Object... extraArgs) {
+    if (method.getEnclosingElement().equals(builder.getSubject())) {
+      builder.addWarning(String.format(enclosedWarning, extraArgs), method);
+    } else {
+      builder.addWarning(String.format(inheritedWarning, append(extraArgs, method)), method);
+    }
+  }
+
+  private static Object[] append(Object[] initial, Object additional) {
+    Object[] newArray = Arrays.copyOf(initial, initial.length + 1);
+    newArray[initial.length] = additional;
+    return newArray;
+  }
+
+  /**
+   * Returns all methods defind in {@code componentType} which are not inherited from a supertype.
+   */
+  private ImmutableSet<ExecutableElement> methodsOnlyInComponent(TypeElement componentType) {
+    // TODO(ronshapiro): Ideally this shouldn't return methods which are redeclared from a
+    // supertype, but do not change the return type. We don't have a good/simple way of checking
+    // that, and it doesn't seem likely, so the warning won't be too bad.
+    return ImmutableSet.copyOf(methodsIn(componentType.getEnclosedElements()));
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
index 7156cc4cd..c8f06405c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
+++ b/compiler/src/main/java/dagger/internal/codegen/CodeBlocks.java
@@ -16,9 +16,12 @@
 
 package dagger.internal.codegen;
 
+import static dagger.internal.codegen.TypeNames.rawTypeName;
 import static java.util.stream.StreamSupport.stream;
 
+import com.google.auto.common.MoreElements;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.CodeBlock.Builder;
 import com.squareup.javapoet.TypeName;
@@ -53,16 +56,8 @@
    * use as type parameters or javadoc method arguments.
    */
   static Collector<TypeName, ?, CodeBlock> toTypeNamesCodeBlock() {
-    return typeNamesIntoCodeBlock(CodeBlock.builder());
-  }
-
-  /**
-   * Adds {@link TypeName} instances to the given {@link CodeBlock.Builder} in a comma-separated
-   * list for use as type parameters or javadoc method arguments.
-   */
-  static Collector<TypeName, ?, CodeBlock> typeNamesIntoCodeBlock(CodeBlock.Builder builder) {
     return Collector.of(
-        () -> new CodeBlockJoiner(", ", builder),
+        () -> new CodeBlockJoiner(", ", CodeBlock.builder()),
         CodeBlockJoiner::addTypeName,
         CodeBlockJoiner::merge,
         CodeBlockJoiner::join);
@@ -141,7 +136,11 @@ static CodeBlock stringLiteral(String toWrap) {
   /** Returns a javadoc {@literal @link} tag that poins to the given {@link ExecutableElement}. */
   static CodeBlock javadocLinkTo(ExecutableElement executableElement) {
     CodeBlock.Builder builder =
-        CodeBlock.builder().add("{@link $T#", executableElement.getEnclosingElement());
+        CodeBlock.builder()
+            .add(
+                "{@link $T#",
+                rawTypeName(
+                    ClassName.get(MoreElements.asType(executableElement.getEnclosingElement()))));
     switch (executableElement.getKind()) {
       case METHOD:
         builder.add("$L", executableElement.getSimpleName());
@@ -157,13 +156,14 @@ static CodeBlock javadocLinkTo(ExecutableElement executableElement) {
         throw new AssertionError(executableElement.toString());
     }
     builder.add("(");
-    executableElement
-        .getParameters()
-        .stream()
-        .map(VariableElement::asType)
-        .map(TypeName::get)
-        .map(TypeNames::rawTypeName)
-        .collect(typeNamesIntoCodeBlock(builder));
+    builder.add(
+        executableElement
+            .getParameters()
+            .stream()
+            .map(VariableElement::asType)
+            .map(TypeName::get)
+            .map(TypeNames::rawTypeName)
+            .collect(toTypeNamesCodeBlock()));
     return builder.add(")}").build();
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
index d2e226726..d279d9003 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -25,6 +25,7 @@
 import static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;
 import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponent;
 import static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentBuilder;
+import static dagger.internal.codegen.DaggerElements.checkTypePresent;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
 import static dagger.internal.codegen.DaggerElements.getUnimplementedMethods;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
@@ -532,7 +533,7 @@ private ComponentDescriptor create(
         }
       }
       ImmutableSet<ExecutableElement> unimplementedMethods =
-          getUnimplementedMethods(elements, types, componentDefinitionType);
+          getUnimplementedMethods(componentDefinitionType, types, elements);
 
       ImmutableSet.Builder<ComponentMethodDescriptor> componentMethodsBuilder =
           ImmutableSet.builder();
@@ -678,7 +679,7 @@ private ComponentMethodDescriptor getDescriptorForComponentMethod(
         return Optional.empty();
       }
       TypeElement element = MoreTypes.asTypeElement(builderType.get());
-      ImmutableSet<ExecutableElement> methods = getUnimplementedMethods(elements, types, element);
+      ImmutableSet<ExecutableElement> methods = getUnimplementedMethods(element, types, elements);
       ImmutableSet.Builder<BuilderRequirementMethod> requirementMethods = ImmutableSet.builder();
       ExecutableElement buildMethod = null;
       for (ExecutableElement method : methods) {
@@ -729,11 +730,7 @@ private ComponentRequirement requirementForBuilderMethod(
     private ModuleDescriptor descriptorForMonitoringModule(TypeElement componentDefinitionType) {
       ClassName monitoringModuleName =
           SourceFiles.generatedMonitoringModuleName(componentDefinitionType);
-      String generatedMonitorModuleName = monitoringModuleName.toString();
-      TypeElement monitoringModule = elements.getTypeElement(generatedMonitorModuleName);
-      if (monitoringModule == null) {
-        throw new TypeNotPresentException(generatedMonitorModuleName, null);
-      }
+      TypeElement monitoringModule = checkTypePresent(monitoringModuleName.toString(), elements);
       return moduleDescriptorFactory.create(monitoringModule);
     }
 
@@ -749,12 +746,8 @@ private ModuleDescriptor descriptorForProductionExecutorModule(
         TypeElement componentDefinitionType) {
       ClassName productionExecutorModuleName =
           SourceFiles.generatedProductionExecutorModuleName(componentDefinitionType);
-      String generatedProductionExecutorModuleName = productionExecutorModuleName.toString();
       TypeElement productionExecutorModule =
-          elements.getTypeElement(generatedProductionExecutorModuleName);
-      if (productionExecutorModule == null) {
-        throw new TypeNotPresentException(generatedProductionExecutorModuleName, null);
-      }
+          checkTypePresent(productionExecutorModuleName.toString(), elements);
       return moduleDescriptorFactory.create(productionExecutorModule);
     }
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
index b04d2c401..2964a6115 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentGenerator.java
@@ -23,6 +23,7 @@
 import java.util.Optional;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
@@ -37,18 +38,40 @@
   private final Elements elements;
   private final Key.Factory keyFactory;
   private final CompilerOptions compilerOptions;
+  private TypeMirror applicationClassName;
 
-  ComponentGenerator(
+  private ComponentGenerator(
           Filer filer,
           Elements elements,
           Types types,
           Key.Factory keyFactory,
-          CompilerOptions compilerOptions) {
+          CompilerOptions compilerOptions,
+          TypeMirror applicationClassName) {
     super(filer, elements);
     this.types = types;
     this.elements = elements;
     this.keyFactory = keyFactory;
     this.compilerOptions = compilerOptions;
+    this.applicationClassName = applicationClassName;
+  }
+
+  public static class Factory {
+    private final Filer filer;
+    private final Elements elements;
+    private final Types types;
+    private final Key.Factory keyFactory;
+    private final CompilerOptions compilerOptions;
+
+    public Factory(Filer filer, Elements elements, Types types, Key.Factory keyFactory, CompilerOptions compilerOptions) {
+      this.filer = filer;
+      this.elements = elements;
+      this.types = types;
+      this.keyFactory = keyFactory;
+      this.compilerOptions = compilerOptions;
+    }
+    public ComponentGenerator createComponentGenerator(TypeMirror applicationClassName) {
+      return new ComponentGenerator(filer, elements, types, keyFactory, compilerOptions, applicationClassName);
+    }
   }
 
   @Override
@@ -65,7 +88,7 @@ ClassName nameGeneratedType(BindingGraph input) {
   @Override
   Optional<TypeSpec.Builder> write(ClassName componentName, BindingGraph input) {
     return Optional.of(
-        new ComponentWriter(types, elements, keyFactory, compilerOptions, componentName, input)
+        new ComponentWriter(types, elements, keyFactory, compilerOptions, componentName, input, applicationClassName)
             .write());
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentInfo.java b/compiler/src/main/java/dagger/internal/codegen/ComponentInfo.java
index d786b58b7..d388c82a3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentInfo.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentInfo.java
@@ -10,15 +10,13 @@
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.stream.Collectors;
 
 import static dagger.internal.codegen.AbstractComponentWriter.simpleVariableName;
 
-/**
- * Created by Andy on 12.05.2017.
- */
 public abstract class ComponentInfo {
 
     protected final TypeElement component;
@@ -26,22 +24,31 @@
     protected final BindingGraph bindingGraph;
     protected List<ComponentInfo> infos = new ArrayList<>();
 
-    public static List<SpecComponentInfo> forSpec(TypeElement component, ComponentDescriptor.Factory componentDescriptorFactory, BindingGraph.Factory bindingGraphFactory) {
-        return createSpecComponentInfo(component, componentDescriptorFactory, bindingGraphFactory)
+    public static List<SpecComponentInfo> forSpec(TypeElement component,
+                                                  ComponentDescriptor.Factory componentDescriptorFactory,
+                                                  BindingGraph.Factory bindingGraphFactory,
+                                                  TypeMirror application) {
+        return createSpecComponentInfo(component, componentDescriptorFactory, bindingGraphFactory, application)
                 .stream()
                 .distinct()
                 .collect(Collectors.toList());
     }
 
-    public static List<GeneratorComponentInfo> forGenerator(TypeElement component, ComponentDescriptor.Factory componentDescriptorFactory, BindingGraph.Factory bindingGraphFactory) {
-        return createGeneratorComponentInfo(component, componentDescriptorFactory, bindingGraphFactory)
+    public static List<GeneratorComponentInfo> forGenerator(TypeElement component,
+                                                            ComponentDescriptor.Factory componentDescriptorFactory,
+                                                            BindingGraph.Factory bindingGraphFactory,
+                                                            TypeMirror application) {
+        return createGeneratorComponentInfo(component, componentDescriptorFactory, bindingGraphFactory, application)
                 .stream()
                 .distinct()
                 .collect(Collectors.toList());
     }
 
-    public static List<TriggerComponentInfo> forTrigger(TypeElement component, ComponentDescriptor.Factory componentDescriptorFactory, BindingGraph.Factory bindingGraphFactory) {
-        return createTriggerComponentInfo(component, componentDescriptorFactory, bindingGraphFactory)
+    public static List<TriggerComponentInfo> forTrigger(TypeElement component,
+                                                        ComponentDescriptor.Factory componentDescriptorFactory,
+                                                        BindingGraph.Factory bindingGraphFactory,
+                                                        TypeMirror application) {
+        return createTriggerComponentInfo(component, componentDescriptorFactory, bindingGraphFactory, application)
                 .stream()
                 .distinct()
                 .collect(Collectors.toList());
@@ -49,10 +56,11 @@
 
     private static List<TriggerComponentInfo> createTriggerComponentInfo(TypeElement component,
                                                             ComponentDescriptor.Factory componentDescriptorFactory,
-                                                            BindingGraph.Factory bindingGraphFactory) {
+                                                            BindingGraph.Factory bindingGraphFactory,
+                                                            TypeMirror application) {
         List<TriggerComponentInfo> infos = new ArrayList<>();
         final ComponentDescriptor descriptor = componentDescriptorFactory.forComponent(component);
-        final BindingGraph bindingGraph = bindingGraphFactory.create(descriptor);
+        final BindingGraph bindingGraph = bindingGraphFactory.create(descriptor, application);
         final TriggerComponentInfo componentInfo = new TriggerComponentInfo(component, descriptor, bindingGraph);
         infos.add(componentInfo);
         for (BindingGraph subGraph : bindingGraph.subgraphs()) {
@@ -76,10 +84,11 @@
 
     private static List<SpecComponentInfo> createSpecComponentInfo(TypeElement component,
                                                          ComponentDescriptor.Factory componentDescriptorFactory,
-                                                         BindingGraph.Factory bindingGraphFactory) {
+                                                         BindingGraph.Factory bindingGraphFactory,
+                                                         TypeMirror application) {
         List<SpecComponentInfo> infos = new ArrayList<>();
         final ComponentDescriptor descriptor = componentDescriptorFactory.forComponent(component);
-        final BindingGraph bindingGraph = bindingGraphFactory.create(descriptor);
+        final BindingGraph bindingGraph = bindingGraphFactory.create(descriptor, application);
         infos.add(new SpecComponentInfo(component, descriptor, bindingGraph));
         for (BindingGraph graph : bindingGraph.subgraphs()) {
             infos.addAll(createSpecSubcomponentInfo(graph.componentDescriptor(), graph));
@@ -98,11 +107,12 @@
     }
 
     private static List<GeneratorComponentInfo> createGeneratorComponentInfo(TypeElement component,
-                                                     ComponentDescriptor.Factory componentDescriptorFactory,
-                                                     BindingGraph.Factory bindingGraphFactory) {
+                                                                             ComponentDescriptor.Factory componentDescriptorFactory,
+                                                                             BindingGraph.Factory bindingGraphFactory,
+                                                                             TypeMirror application) {
         List<GeneratorComponentInfo> infos = new ArrayList<>();
         final ComponentDescriptor descriptor = componentDescriptorFactory.forComponent(component);
-        final BindingGraph bindingGraph = bindingGraphFactory.create(descriptor);
+        final BindingGraph bindingGraph = bindingGraphFactory.create(descriptor, application);
         infos.add(new GeneratorComponentInfo(component, descriptor, bindingGraph));
         for (BindingGraph subGraph : bindingGraph.subgraphs()) {
             infos.addAll(createGeneratorSubcomponentInfo(subGraph.componentDescriptor(), subGraph));
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
index 3fb51ebc6..7c018f411 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -24,6 +24,7 @@
 import com.google.common.collect.Maps;
 import com.google.common.collect.Multimaps;
 import com.google.common.collect.SetMultimap;
+import com.squareup.javapoet.ClassName;
 import dagger.Component;
 import dagger.Config;
 import dagger.Subcomponent;
@@ -32,12 +33,12 @@
 import dagger.producers.ProductionComponent;
 import dagger.producers.ProductionSubcomponent;
 import java.lang.annotation.Annotation;
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
+import java.util.*;
 import javax.annotation.processing.Messager;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.MirroredTypeException;
+import javax.lang.model.type.TypeMirror;
 
 /**
  * A {@link ProcessingStep} that is responsible for dealing with a component or production component
@@ -55,12 +56,14 @@
   private final BindingGraphValidator bindingGraphValidator;
   private final ComponentDescriptor.Factory componentDescriptorFactory;
   private final BindingGraph.Factory bindingGraphFactory;
-  private final ComponentGenerator componentGenerator;
+  private final ComponentGenerator.Factory componentGeneratorFactory;
 
   public static Set<TypeElement> allComponents = new HashSet<>();
   public static TypeElement appClass;
 
   public static boolean generatedAllComponents = true;
+  private final AppConfig.Factory appConfigFactory;
+  private static AppConfig appConfig;
 
   ComponentProcessingStep(
       ComponentDescriptor.Kind componentKind,
@@ -72,7 +75,8 @@
       BindingGraphValidator bindingGraphValidator,
       Factory componentDescriptorFactory,
       BindingGraph.Factory bindingGraphFactory,
-      ComponentGenerator componentGenerator) {
+      ComponentGenerator.Factory componentGeneratorFactory,
+      AppConfig.Factory appConfigFactory) {
     this.componentKind = componentKind;
     this.messager = messager;
     this.componentValidator = componentValidator;
@@ -82,7 +86,8 @@
     this.bindingGraphValidator = bindingGraphValidator;
     this.componentDescriptorFactory = componentDescriptorFactory;
     this.bindingGraphFactory = bindingGraphFactory;
-    this.componentGenerator = componentGenerator;
+    this.componentGeneratorFactory = componentGeneratorFactory;
+    this.appConfigFactory = appConfigFactory;
   }
 
   @Override
@@ -106,7 +111,12 @@
     if (appClass == null) {
       final Set<Element> elements = elementsByAnnotation.get(Config.class);
       if (!elements.isEmpty()) {
-        appClass = MoreElements.asType(elements.iterator().next());
+        final Iterator<Element> it = elements.iterator();
+        if (it.hasNext()) {
+          final Element e = it.next();
+          appConfig = appConfigFactory.create(e.getAnnotation(Config.class));
+          appClass = MoreElements.asType(e);
+        }
       }
     }
 
@@ -151,7 +161,7 @@
               componentHierarchyValidator.validate(componentDescriptor);
           hierarchyReport.printMessagesTo(messager);
           if (hierarchyReport.isClean()) {
-            BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+            BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor, appConfig.getAppClass().asType());
             ValidationReport<TypeElement> graphReport =
                 bindingGraphValidator.validate(bindingGraph);
             graphReport.printMessagesTo(messager);
@@ -176,7 +186,9 @@
   }
 
   private void generateComponent(BindingGraph bindingGraph) {
-    componentGenerator.generate(bindingGraph, messager);
+    final AppConfig appConfig = appConfigFactory.create(appClass.getAnnotation(Config.class));
+    final TypeMirror appClass = appConfig.getAppClass().asType();
+    componentGeneratorFactory.createComponentGenerator(appClass).generate(bindingGraph, messager);
   }
 
   private ImmutableSet<Element> getElementsFromAnnotations(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
index e3ac7b8b0..5aa1277a0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentProcessor.java
@@ -19,7 +19,6 @@
 import static dagger.internal.codegen.ModuleProcessingStep.moduleProcessingStep;
 import static dagger.internal.codegen.ModuleProcessingStep.producerModuleProcessingStep;
 
-import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.service.AutoService;
 import com.google.common.collect.ImmutableList;
 import com.google.googlejavaformat.java.filer.FormattingFiler;
@@ -89,47 +88,35 @@ public SourceVersion getSupportedSourceVersion() {
     BindsMethodValidator bindsMethodValidator = new BindsMethodValidator(elements, types);
     MultibindsMethodValidator multibindsMethodValidator =
             new MultibindsMethodValidator(elements, types);
-    MultibindingsMethodValidator multibindingsMethodValidator =
-            new MultibindingsMethodValidator(elements, types);
     BindsOptionalOfMethodValidator bindsOptionalOfMethodValidator =
             new BindsOptionalOfMethodValidator(elements, types);
     AnyBindingMethodValidator anyBindingMethodValidator =
-            new AnyBindingMethodValidator(
-                    providesMethodValidator,
-                    producesMethodValidator,
-                    bindsMethodValidator,
-                    multibindsMethodValidator,
-                    bindsOptionalOfMethodValidator);
-    MultibindingsValidator multibindingsValidator =
-            new MultibindingsValidator(
-                    elements,
-                    types,
-                    keyFactory,
-                    keyFormatter,
-                    methodSignatureFormatter,
-                    multibindingsMethodValidator);
+        new AnyBindingMethodValidator(
+            providesMethodValidator,
+            producesMethodValidator,
+            bindsMethodValidator,
+            multibindsMethodValidator,
+            bindsOptionalOfMethodValidator);
     ModuleValidator moduleValidator =
-            new ModuleValidator(
-                    types,
-                    elements,
-                    anyBindingMethodValidator,
-                    multibindingsValidator,
-                    methodSignatureFormatter);
+        new ModuleValidator(
+            types,
+            elements,
+            anyBindingMethodValidator,
+            methodSignatureFormatter);
     BuilderValidator builderValidator = new BuilderValidator(elements, types);
     ComponentValidator subcomponentValidator =
             ComponentValidator.createForSubcomponent(
                     elements, types, moduleValidator, builderValidator);
     ComponentValidator componentValidator =
-            ComponentValidator.createForComponent(
-                    elements, types, moduleValidator, subcomponentValidator, builderValidator);
-    MapKeyValidator mapKeyValidator = new MapKeyValidator();
+        ComponentValidator.createForComponent(
+            elements, types, moduleValidator, subcomponentValidator, builderValidator);
+    MapKeyValidator mapKeyValidator = new MapKeyValidator(elements);
 
     StubGenerator stubGenerator = new StubGenerator(filer, elements, types);
     FactoryGenerator factoryGenerator = new FactoryGenerator(filer, elements, compilerOptions, injectValidatorWhenGeneratingCode);
     multipleGenerator = new MultipleSourceFileGenerator<>(filer, elements, Arrays.asList(stubGenerator, factoryGenerator));
     membersInjectorGenerator = new MembersInjectorGenerator(filer, elements, injectValidatorWhenGeneratingCode);
-    ComponentGenerator componentGenerator =
-            new ComponentGenerator(filer, elements, types, keyFactory, compilerOptions);
+    ComponentGenerator.Factory componentGeneratorFactory = new ComponentGenerator.Factory(filer, elements, types, keyFactory, compilerOptions);
     ProducerFactoryGenerator producerFactoryGenerator =
             new ProducerFactoryGenerator(filer, elements, compilerOptions);
     MonitoringModuleGenerator monitoringModuleGenerator =
@@ -208,69 +195,66 @@ public SourceVersion getSupportedSourceVersion() {
                     keyFactory);
 
     return ImmutableList.of(
-            new AppConfigProcessingStep(messager, elements, types, new AppConfig.Validator(elements, types)),
-            new MapKeyProcessingStep(
-                    messager, types, mapKeyValidator, annotationCreatorGenerator, unwrappedMapKeyGenerator),
-            new ForReleasableReferencesValidator(messager),
-            new CanReleaseReferencesProcessingStep(
-                    messager, canReleaseReferencesValidator, annotationCreatorGenerator),
-            new InjectProcessingStep(injectBindingRegistry),
-            new MonitoringModuleProcessingStep(messager, monitoringModuleGenerator),
-            new ProductionExecutorModuleProcessingStep(messager, productionExecutorModuleGenerator),
-            new MultibindingAnnotationsProcessingStep(messager),
-            new BindsInstanceProcessingStep(messager),
-            moduleProcessingStep(
-                    messager,
-                    moduleValidator,
-                    provisionBindingFactory,
-                    this.multipleGenerator),
-            new ComponentProcessingStep(
-                    ComponentDescriptor.Kind.COMPONENT,
-                    messager,
-                    componentValidator,
-                    subcomponentValidator,
-                    builderValidator,
-                    componentHierarchyValidator,
-                    bindingGraphValidator,
-                    componentDescriptorFactory,
-                    bindingGraphFactory,
-                    componentGenerator),
-            producerModuleProcessingStep(
-                    messager,
-                    moduleValidator,
-                    provisionBindingFactory,
-                    multipleGenerator,
-                    productionBindingFactory,
-                    producerFactoryGenerator),
-            new ComponentProcessingStep(
-                    ComponentDescriptor.Kind.PRODUCTION_COMPONENT,
-                    messager,
-                    componentValidator,
-                    subcomponentValidator,
-                    builderValidator,
-                    componentHierarchyValidator,
-                    bindingGraphValidator,
-                    componentDescriptorFactory,
-                    bindingGraphFactory,
-                    componentGenerator),
-            new MultibindingsProcessingStep(messager, multibindingsValidator),
-            new BindingMethodProcessingStep(messager, anyBindingMethodValidator),
-            new InjectorProcessingStep(
-                    types,
-                    messager,
-                    new AppConfig.Factory(elements),
-                    new InjectorGenerator(filer, elements, componentDescriptorFactory,
-                            bindingGraphFactory, new TestClassGenerator.Factory(filer, elements),
-                            testRegistry, new Decorator.Factory(filer, elements, bindingGraphFactory, testRegistry)),
-                    ComponentDescriptor.Kind.COMPONENT,
-                    bindingGraphFactory,
-                    componentDescriptorFactory,
-                    new DependencySpecGenerator(filer, elements, componentDescriptorFactory, bindingGraphFactory),
-                    new DependencyInjectorGenerator(filer, elements, bindingGraphFactory, componentDescriptorFactory),
-                    provisionBindingFactory,
-                    new ApplicationGenerator(filer, types, elements, bindingGraphFactory, componentDescriptorFactory),
-                    stubGenerator
-            )
+        new MapKeyProcessingStep(
+            messager, types, mapKeyValidator, annotationCreatorGenerator, unwrappedMapKeyGenerator),
+        new ForReleasableReferencesValidator(messager),
+        new CanReleaseReferencesProcessingStep(
+            messager, canReleaseReferencesValidator, annotationCreatorGenerator),
+        new InjectProcessingStep(injectBindingRegistry),
+        new MonitoringModuleProcessingStep(messager, monitoringModuleGenerator),
+        new ProductionExecutorModuleProcessingStep(messager, productionExecutorModuleGenerator),
+        new MultibindingAnnotationsProcessingStep(messager),
+        new BindsInstanceProcessingStep(messager),
+        moduleProcessingStep(messager, moduleValidator, provisionBindingFactory, multipleGenerator),
+        new ComponentProcessingStep(
+            ComponentDescriptor.Kind.COMPONENT,
+            messager,
+            componentValidator,
+            subcomponentValidator,
+            builderValidator,
+            componentHierarchyValidator,
+            bindingGraphValidator,
+            componentDescriptorFactory,
+            bindingGraphFactory,
+            componentGeneratorFactory,
+            new AppConfig.Factory(elements)
+        ),
+        producerModuleProcessingStep(
+            messager,
+            moduleValidator,
+            provisionBindingFactory,
+            multipleGenerator,
+            productionBindingFactory,
+            producerFactoryGenerator),
+        new ComponentProcessingStep(
+            ComponentDescriptor.Kind.PRODUCTION_COMPONENT,
+            messager,
+            componentValidator,
+            subcomponentValidator,
+            builderValidator,
+            componentHierarchyValidator,
+            bindingGraphValidator,
+            componentDescriptorFactory,
+            bindingGraphFactory,
+            componentGeneratorFactory,
+            new AppConfig.Factory(elements)),
+        new BindingMethodProcessingStep(messager, anyBindingMethodValidator),
+        new InjectorProcessingStep(
+                types,
+                messager,
+                new AppConfig.Factory(elements),
+                new InjectorGenerator(filer, elements, componentDescriptorFactory,
+                        bindingGraphFactory, new TestClassGenerator.Factory(filer, elements),
+                        testRegistry, new Decorator.Factory(filer, elements, bindingGraphFactory, testRegistry)),
+                ComponentDescriptor.Kind.COMPONENT,
+                bindingGraphFactory,
+                componentDescriptorFactory,
+                new DependencySpecGenerator(filer, elements, componentDescriptorFactory, bindingGraphFactory),
+                new DependencyInjectorGenerator(filer, elements, bindingGraphFactory, componentDescriptorFactory),
+                provisionBindingFactory,
+                new ApplicationGenerator(filer, types, elements, bindingGraphFactory, componentDescriptorFactory),
+                stubGenerator
+        )
     );
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java b/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java
index cee962d32..c0216c23c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentRequirement.java
@@ -16,18 +16,27 @@
 
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Preconditions.checkNotNull;
+import static dagger.internal.codegen.DaggerElements.isAnyAnnotationPresent;
 import static dagger.internal.codegen.SourceFiles.simpleVariableName;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
-import static dagger.internal.codegen.Util.requiresAPassedInstance;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.STATIC;
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
 import com.google.common.base.Equivalence;
+import com.google.common.collect.ImmutableSet;
+import dagger.Binds;
+import dagger.BindsOptionalOf;
 import dagger.Module;
-
+import dagger.Provides;
+import dagger.multibindings.Multibinds;
+import dagger.producers.Produces;
 import java.util.Optional;
+import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
@@ -90,20 +99,52 @@ NullPolicy nullPolicy(Elements elements, Types types) {
       return overrideNullPolicy().get();
     }
     switch (kind()) {
-      case DEPENDENCY:
-        return NullPolicy.THROW;
       case MODULE:
         return componentCanMakeNewInstances(typeElement())
             ? NullPolicy.NEW
-            : requiresAPassedInstance(elements, types, typeElement())
-                ? NullPolicy.THROW
-                : NullPolicy.ALLOW;
+            : requiresAPassedInstance(elements, types) ? NullPolicy.THROW : NullPolicy.ALLOW;
+      case DEPENDENCY:
       case BINDING:
         return NullPolicy.THROW;
     }
     throw new AssertionError();
   }
 
+  /**
+   * Returns true if the passed {@link ComponentRequirement} requires a passed instance in order
+   * to be used within a component.
+   */
+  boolean requiresAPassedInstance(Elements elements, Types types) {
+    if (kind().equals(ComponentRequirement.Kind.BINDING)) {
+      // A user has explicitly defined in their component builder they will provide an instance.
+      return true;
+    }
+
+    ImmutableSet<ExecutableElement> methods =
+        getLocalAndInheritedMethods(typeElement(), types, elements);
+    boolean foundInstanceMethod = false;
+    for (ExecutableElement method : methods) {
+      if (method.getModifiers().contains(ABSTRACT)
+          && !isAnyAnnotationPresent(
+              method, Binds.class, Multibinds.class, BindsOptionalOf.class)) {
+        // TODO(ronshapiro): it would be cool to have internal meta-annotations that could describe
+        // these, like @AbstractBindingMethod
+        /* We found an abstract method that isn't a binding method. That automatically means that
+         * a user will have to provide an instance because we don't know which subclass to use. */
+        return true;
+      } else if (!method.getModifiers().contains(STATIC)
+          && isAnyAnnotationPresent(method, Provides.class, Produces.class)) {
+        foundInstanceMethod = true;
+      }
+    }
+
+    if (foundInstanceMethod) {
+      return !componentCanMakeNewInstances(typeElement());
+    }
+
+    return false;
+  }
+
   /** The key for this requirement, if one is available. */
   abstract Optional<Key> key();
 
@@ -113,7 +154,7 @@ NullPolicy nullPolicy(Elements elements, Types types) {
   abstract boolean autoCreate();
 
   static ComponentRequirement forDependency(TypeMirror type) {
-    return new AutoValue_ComponentRequirement(
+    return new dagger.internal.codegen.AutoValue_ComponentRequirement(
         Kind.DEPENDENCY,
         MoreTypes.equivalence().wrap(checkNotNull(type)),
         Optional.empty(),
@@ -124,7 +165,7 @@ static ComponentRequirement forDependency(TypeMirror type) {
 
   static ComponentRequirement forModule(TypeMirror type) {
     final Module annotation = MoreTypes.asTypeElement(type).getAnnotation(Module.class);
-    return new AutoValue_ComponentRequirement(
+    return new dagger.internal.codegen.AutoValue_ComponentRequirement(
         Kind.MODULE,
         MoreTypes.equivalence().wrap(checkNotNull(type)),
         Optional.empty(),
@@ -135,7 +176,7 @@ static ComponentRequirement forModule(TypeMirror type) {
   }
 
   static ComponentRequirement forBinding(Key key, boolean nullable, String variableName) {
-    return new AutoValue_ComponentRequirement(
+    return new dagger.internal.codegen.AutoValue_ComponentRequirement(
         Kind.BINDING,
         key.wrappedType(),
         nullable ? Optional.of(NullPolicy.ALLOW) : Optional.empty(),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
index d0e949abc..cae48a5d7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ComponentWriter.java
@@ -19,26 +19,32 @@
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.TypeSpecs.addSupertype;
-import static dagger.internal.codegen.Util.requiresAPassedInstance;
+import static java.lang.Character.isUpperCase;
+import static java.lang.String.format;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 
+import com.google.common.base.CharMatcher;
 import com.google.common.base.Joiner;
 import com.google.common.base.Splitter;
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Multimaps;
 import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeSpec;
 import java.util.Collection;
+import java.util.Iterator;
 import java.util.LinkedHashMap;
-import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 import javax.lang.model.element.Name;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
@@ -53,7 +59,8 @@
           Key.Factory keyFactory,
           CompilerOptions compilerOptions,
           ClassName name,
-          BindingGraph graph) {
+          BindingGraph graph,
+          TypeMirror applicationClassName) {
     super(
         types,
         elements,
@@ -62,7 +69,8 @@
         name,
         graph,
         new UniqueSubcomponentNamesGenerator(graph).generate(),
-        new OptionalFactories());
+        new OptionalFactories(),
+        applicationClassName);
   }
 
   /**
@@ -77,7 +85,7 @@
     private final BindingGraph graph;
     private final ImmutableListMultimap<String, ComponentDescriptor>
         componentDescriptorsBySimpleName;
-    private final ImmutableListMultimap<ComponentDescriptor, String> componentQualifiedNamePieces;
+    private final ImmutableMap<ComponentDescriptor, Namer> componentNamers;
 
     public UniqueSubcomponentNamesGenerator(BindingGraph graph) {
       this.graph = graph;
@@ -86,7 +94,7 @@ public UniqueSubcomponentNamesGenerator(BindingGraph graph) {
               graph.componentDescriptors(),
               componentDescriptor ->
                   componentDescriptor.componentDefinitionType().getSimpleName().toString());
-      componentQualifiedNamePieces = qualifiedNames(graph.componentDescriptors());
+      componentNamers = qualifiedNames(graph.componentDescriptors());
     }
 
     public ImmutableBiMap<ComponentDescriptor, String> generate() {
@@ -103,36 +111,77 @@ public UniqueSubcomponentNamesGenerator(BindingGraph graph) {
     private ImmutableBiMap<ComponentDescriptor, String> disambiguateConflictingSimpleNames(
         Collection<ComponentDescriptor> components) {
       Map<String, ComponentDescriptor> generatedSimpleNames = new LinkedHashMap<>();
-      // The ending condition is when there is a unique simple name generated for every element
-      // in components. The sizes should be equivalent (with one generated name per component).
-      for (int levels = 0; generatedSimpleNames.size() != components.size(); levels++) {
+
+      // Let's see if we can get away with using simpleName() everywhere.
+      for (ComponentDescriptor component : components) {
+        Namer namer = componentNamers.get(component);
+        if (generatedSimpleNames.containsKey(namer.simpleName())) {
+          break;
+        }
+        generatedSimpleNames.put(namer.simpleName(), component);
+      }
+
+      if (generatedSimpleNames.size() != components.size()) {
+        // Simple approach didn't work out, let's use more complicated names.
+        // We keep them small to fix https://github.com/google/dagger/issues/421.
         generatedSimpleNames.clear();
+        UniqueNameSet nameSet = new UniqueNameSet();
         for (ComponentDescriptor component : components) {
-          List<String> pieces = componentQualifiedNamePieces.get(component);
-          String simpleName =
-              QUALIFIED_NAME_JOINER.join(
-                  pieces.subList(Math.max(0, pieces.size() - levels - 1), pieces.size()));
-          ComponentDescriptor conflict = generatedSimpleNames.put(simpleName, component);
-          if (conflict != null) {
-            // if the map previously contained an entry for the same simple name, stop early since
-            // 2+ subcomponent descriptors will have the same simple name
-            break;
-          }
+          Namer namer = componentNamers.get(component);
+          String simpleName = namer.simpleName();
+          String basePrefix = namer.uniquingPrefix();
+          generatedSimpleNames.put(format("%s_%s", nameSet.getUniqueName(basePrefix), simpleName),
+              component);
         }
       }
       return ImmutableBiMap.copyOf(generatedSimpleNames).inverse();
     }
 
-    private static ImmutableListMultimap<ComponentDescriptor, String> qualifiedNames(
+    private static ImmutableMap<ComponentDescriptor, Namer> qualifiedNames(
         Iterable<ComponentDescriptor> componentDescriptors) {
-      ImmutableListMultimap.Builder<ComponentDescriptor, String> builder =
-          ImmutableListMultimap.builder();
+      ImmutableMap.Builder<ComponentDescriptor, Namer> builder = ImmutableMap.builder();
       for (ComponentDescriptor component : componentDescriptors) {
-        Name qualifiedName = component.componentDefinitionType().getQualifiedName();
-        builder.putAll(component, QUALIFIED_NAME_SPLITTER.split(qualifiedName));
+        builder.put(component, new Namer(component.componentDefinitionType()));
       }
       return builder.build();
     }
+
+    private static final class Namer {
+      final TypeElement typeElement;
+
+      Namer(TypeElement typeElement) {
+        this.typeElement = typeElement;
+      }
+
+      String simpleName() {
+        return typeElement.getSimpleName().toString();
+      }
+
+      /** Returns a prefix that could make {@link #simpleName()} more unique. */
+      String uniquingPrefix() {
+        String containerName = typeElement.getEnclosingElement().getSimpleName().toString();
+
+        // If parent element looks like a class, use its initials as a prefix.
+        if (!containerName.isEmpty() && isUpperCase(containerName.charAt(0))) {
+          return CharMatcher.javaLowerCase().removeFrom(containerName);
+        }
+
+        // Not in a normally named class. Prefix with the initials of the elements leading here.
+        Name qualifiedName = typeElement.getQualifiedName();
+        Iterator<String> pieces = QUALIFIED_NAME_SPLITTER.split(qualifiedName).iterator();
+        StringBuilder b = new StringBuilder();
+
+        while (pieces.hasNext()) {
+          String next = pieces.next();
+          if (pieces.hasNext()) {
+            b.append(next.charAt(0));
+          }
+        }
+
+        // Note that a top level class in the root package will be prefixed "$_".
+        return b.length() > 0 ? b.toString() : "$";
+      }
+    }
   }
 
   @Override
@@ -149,21 +198,26 @@ protected ClassName builderName() {
   @Override
   protected TypeSpec.Builder createBuilder(String builderSimpleName) {
     TypeSpec.Builder builder = classBuilder(builderSimpleName).addModifiers(STATIC);
+    return builder;
+  }
 
+  public void postAddBuildMethod() {
     // Only top-level components have the factory builder() method.
     // Mirror the user's builder API type if they had one.
     MethodSpec builderFactoryMethod =
-        methodBuilder("builder")
-            .addModifiers(PUBLIC, STATIC)
-            .returns(
-                graph.componentDescriptor().builderSpec().isPresent()
-                    ? ClassName.get(
-                        graph.componentDescriptor().builderSpec().get().builderDefinitionType())
-                    : builderName.get())
-            .addStatement("return new $T()", builderName.get())
-            .build();
+            methodBuilder("builder")
+                    .addModifiers(PUBLIC, STATIC)
+                    .addParameter(ClassName.get(application), "application")
+                    .returns(
+                            graph.componentDescriptor().builderSpec().isPresent()
+                                    ? ClassName.get(
+                                    graph.componentDescriptor().builderSpec().get().builderDefinitionType())
+                                    : builderName.get())
+                    .addStatement("return application.$L(new $T())",
+                            Util.lowerCaseFirstLetter(graph.componentType().getSimpleName().toString()),
+                            builderName.get())
+                    .build();
     component.addMethod(builderFactoryMethod);
-    return builder;
   }
 
   @Override
@@ -182,7 +236,7 @@ protected void addFactoryMethods() {
           methodBuilder("create")
               .returns(componentDefinitionTypeName())
               .addModifiers(PUBLIC, STATIC)
-              .addStatement("return builder().$L()", buildMethodName)
+              .addStatement("return new Builder().$L()", buildMethodName)
               .build());
     }*/
   }
@@ -191,6 +245,6 @@ protected void addFactoryMethods() {
   private boolean canInstantiateAllRequirements() {
     return !Iterables.any(
         graph.componentRequirements(),
-        dependency -> requiresAPassedInstance(elements, types, dependency.typeElement()));
+        dependency -> dependency.requiresAPassedInstance(elements, types));
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index afd226f2d..36745f9e0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -230,7 +230,7 @@ FactoryCreationStrategy factoryCreationStrategy() {
 
   /**
    * The {@link TypeMirror type} for the {@code Factory<T>} or {@code Producer<T>} which is created
-   * for this binding. Uses the binding's key, V in the came of {@code Map<K, FrameworkClass<V>>>},
+   * for this binding. Uses the binding's key, V in the case of {@code Map<K, FrameworkClass<V>>>},
    * and E {@code Set<E>} for {@link dagger.multibindings.IntoSet @IntoSet} methods.
    */
   final TypeMirror contributedType() {
diff --git a/compiler/src/main/java/dagger/internal/codegen/DaggerElements.java b/compiler/src/main/java/dagger/internal/codegen/DaggerElements.java
index f88dcdecc..fe19903b9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DaggerElements.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DaggerElements.java
@@ -49,7 +49,7 @@
 final class DaggerElements {
 
   static ImmutableSet<ExecutableElement> getUnimplementedMethods(
-      Elements elements, Types types, TypeElement type) {
+      TypeElement type, Types types, Elements elements) {
     return FluentIterable.from(getLocalAndInheritedMethods(type, types, elements))
         .filter(hasModifiers(ABSTRACT))
         .toSet();
@@ -169,4 +169,16 @@ static boolean isAnnotationPresent(Element element, TypeMirror annotationType) {
     }
     return ImmutableSet.copyOf(suppressedWarnings.value());
   }
+
+  /**
+   * Invokes {@link Elements#getTypeElement(CharSequence)}, throwing {@link TypeNotPresentException}
+   * if it is not accessible in the current compilation.
+   */
+  static TypeElement checkTypePresent(String typeName, Elements elements) {
+    TypeElement type = elements.getTypeElement(typeName);
+    if (type == null) {
+      throw new TypeNotPresentException(typeName, null);
+    }
+    return type;
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Decorator.java b/compiler/src/main/java/dagger/internal/codegen/Decorator.java
index edfc16645..2ebbbc925 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Decorator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Decorator.java
@@ -9,6 +9,7 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
 import java.io.IOException;
 import java.util.ArrayList;
@@ -18,13 +19,15 @@
 public class Decorator  extends SourceFileGenerator<BindingGraph>{
 
     private BindingGraph.Factory factory;
-    private ClassName appClass;
+    private TypeMirror appClass;
+    private ClassName testAppClassName;
     private TestRegistry testRegistry;
 
-    private Decorator(Filer filer, Elements elements, BindingGraph.Factory factory, ClassName appClass, TestRegistry testRegistry) {
+    private Decorator(Filer filer, Elements elements, BindingGraph.Factory factory, TypeMirror appClass, ClassName testAppClassName, TestRegistry testRegistry) {
         super(filer, elements);
         this.factory = factory;
         this.appClass = appClass;
+        this.testAppClassName = testAppClassName;
         this.testRegistry = testRegistry;
     }
 
@@ -48,9 +51,11 @@ private ClassName getClassName(BindingGraph input) {
         final TypeSpec.Builder builder = TypeSpec.classBuilder(generatedTypeName)
                 .addModifiers(Modifier.PUBLIC);
 
-        final String daggerBuilderClassName = TriggerComponentInfo.resolveBuilderName(factory, input.componentDescriptor());
+        ComponentDescriptor topDescriptor = getTopDescriptor(input.componentDescriptor());
+        final BindingGraph parentGraph = factory.create(topDescriptor, appClass);
+        final String daggerBuilderClassName = TriggerComponentInfo.resolveBuilderName(input, parentGraph);
 
-        builder.addField(appClass, "app", Modifier.PRIVATE);
+        builder.addField(testAppClassName, "app", Modifier.PRIVATE);
         TypeName builderClassName = ClassName.get(input.componentDescriptor().builderSpec().get().builderDefinitionType());
         final ImmutableSet<ContributionBinding> delegateRequirements = input.delegateRequirements();
 
@@ -73,7 +78,7 @@ private ClassName getClassName(BindingGraph input) {
         }
         interfaceBuilder.addMethod(MethodSpec.methodBuilder("and")
                 .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
-                .returns(appClass)
+                .returns(testAppClassName)
                 .build());
         return interfaceBuilder;
     }
@@ -83,7 +88,7 @@ private void addDecoratorType(TypeSpec.Builder builder, String className, TypeNa
         builder.addModifiers(Modifier.PUBLIC);
         builder.addMethod(MethodSpec.constructorBuilder()
                 .addModifiers(Modifier.PUBLIC)
-                .addParameter(appClass, "app")
+                .addParameter(testAppClassName, "app")
                 .addStatement("this.app = app")
                 .build());
 
@@ -91,7 +96,7 @@ private void addDecoratorType(TypeSpec.Builder builder, String className, TypeNa
         final ClassName name = ClassName.bestGuess(className);
         statements.add(CodeBlock.of("$T impl = ($T) builder;", name, name));
 
-        TypeName interfaceName = this.getAccessorTypeName(appClass, componentName);
+        TypeName interfaceName = this.getAccessorTypeName(ClassName.bestGuess(testAppClassName.toString()), componentName);
         builder.addSuperinterface(interfaceName);
 
         for (ContributionBinding contributionBinding : delegateRequirements) {
@@ -106,7 +111,7 @@ private void addDecoratorType(TypeSpec.Builder builder, String className, TypeNa
         builder.addMethod(MethodSpec.methodBuilder("and")
                 .addModifiers(Modifier.PUBLIC)
                 .addStatement("return app")
-                .returns(appClass)
+                .returns(testAppClassName)
                 .build());
 
         builder.addMethod(MethodSpec.methodBuilder("decorate")
@@ -135,6 +140,13 @@ public ClassName getAccessorTypeName(ClassName app, String componentName) {
         return app.nestedClass(componentName + "Accessor");
     }
 
+    private static ComponentDescriptor getTopDescriptor(ComponentDescriptor descriptor) {
+        while(descriptor.getParentDescriptor() != null) {
+            descriptor = descriptor.getParentDescriptor();
+        }
+        return descriptor;
+    }
+
     public static class Factory {
 
         private final Filer filer;
@@ -149,8 +161,8 @@ public ClassName getAccessorTypeName(ClassName app, String componentName) {
             this.testRegistry = testRegistry;
         }
 
-        public Decorator create(ClassName appClass) {
-            return new Decorator(filer, elements, bindingGraphFactory, appClass, testRegistry);
+        public Decorator create(ClassName testAppClassName, TypeMirror appClass) {
+            return new Decorator(filer, elements, bindingGraphFactory, appClass, testAppClassName, testRegistry);
         }
 
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/DependencyInjectorGenerator.java
index 3590bb2f5..5882733a9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyInjectorGenerator.java
@@ -46,8 +46,8 @@ ClassName nameGeneratedType(DI input) {
                 .addStatement(String.format("this.%s = %s", APP_FIELDNAME, APP_FIELDNAME))
                 .build());
         builder.addField(appType, APP_FIELDNAME, Modifier.PRIVATE);
-        for (TypeElement typeElement : input.getComponents()) {
-            final List<GeneratorComponentInfo> infos = ComponentInfo.forGenerator(typeElement, componentDescriptorFactory, bindingGraphFactory);
+        /*for (TypeElement typeElement : input.getComponents()) {
+            final List<GeneratorComponentInfo> infos = ComponentInfo.forGenerator(typeElement, componentDescriptorFactory, bindingGraphFactory, input.getAppClass().asType());
             infos.forEach(info -> info.process(builder));
         }
 
@@ -63,7 +63,7 @@ ClassName nameGeneratedType(DI input) {
                 .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                 .addParameter(ClassName.bestGuess("android.app.Application"), "app")
                 .returns(Util.TYPENAME_INJECTOR)
-                .build());
+                .build());*/
 
         return Optional.of(builder);
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index fe8e27a72..aaec20556 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -37,7 +37,9 @@
 import com.google.common.collect.Iterables;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.google.googlejavaformat.Op;
 import com.squareup.javapoet.TypeName;
+import dagger.BindsInstance;
 import dagger.Lazy;
 import dagger.MembersInjector;
 import dagger.Provides;
@@ -267,7 +269,7 @@ protected KindAndType defaultAction(TypeMirror otherType, Void p) {
 
     abstract Builder key(Key key);
 
-    abstract Builder requestElement(Element element);
+    abstract Builder requestElement(Optional<Element> element);
 
     abstract Builder isNullable(boolean isNullable);
 
@@ -370,6 +372,16 @@ private Kind multibindingContributionRequestKind(ContributionBinding multibindin
       return requests.build();
     }
 
+    DependencyRequest plantDependency(TypeMirror typeMirror) {
+      return DependencyRequest.builder()
+              .kind(Kind.INSTANCE)
+              .key(Key.builder(typeMirror).build())
+              .requestElement(Optional.empty())
+              .isNullable(false)
+              .overriddenVariableName(Optional.of(Util.toParameterName(Util.extractClassName(typeMirror))))
+              .build();
+    }
+
     DependencyRequest forRequiredVariable(VariableElement variableElement) {
       return forRequiredVariable(variableElement, Optional.empty());
     }
@@ -378,7 +390,7 @@ DependencyRequest forRequiredVariable(VariableElement variableElement, Optional<
       checkNotNull(variableElement);
       TypeMirror type = variableElement.asType();
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
-      return newDependencyRequest(variableElement, type, qualifier, name);
+      return newDependencyRequest(Optional.of(variableElement), type, qualifier, name);
     }
 
     DependencyRequest forRequiredResolvedVariable(
@@ -386,7 +398,7 @@ DependencyRequest forRequiredResolvedVariable(
       checkNotNull(variableElement);
       checkNotNull(resolvedType);
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(variableElement);
-      return newDependencyRequest(variableElement, resolvedType, qualifier, Optional.empty());
+      return newDependencyRequest(Optional.of(variableElement), resolvedType, qualifier, Optional.empty());
     }
 
     DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod,
@@ -399,7 +411,7 @@ DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod,
           provisionMethod);
       Optional<AnnotationMirror> qualifier = InjectionAnnotations.getQualifier(provisionMethod);
       return newDependencyRequest(
-          provisionMethod, provisionMethodType.getReturnType(), qualifier, Optional.empty());
+          Optional.of(provisionMethod), provisionMethodType.getReturnType(), qualifier, Optional.empty());
     }
 
     DependencyRequest forComponentProductionMethod(ExecutableElement productionMethod,
@@ -417,10 +429,10 @@ DependencyRequest forComponentProductionMethod(ExecutableElement productionMetho
             .kind(Kind.FUTURE)
             .key(keyFactory.forQualifiedType(
                 qualifier, Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments())))
-            .requestElement(productionMethod)
+            .requestElement(Optional.of(productionMethod))
             .build();
       } else {
-        return newDependencyRequest(productionMethod, type, qualifier, Optional.empty());
+        return newDependencyRequest(Optional.of(productionMethod), type, qualifier, Optional.empty());
       }
     }
 
@@ -439,7 +451,7 @@ DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersIn
       return DependencyRequest.builder()
           .kind(Kind.MEMBERS_INJECTOR)
           .key(keyFactory.forMembersInjectedType(membersInjectedType))
-          .requestElement(membersInjectionMethod)
+          .requestElement(Optional.of(membersInjectionMethod))
           .build();
     }
 
@@ -447,7 +459,7 @@ DependencyRequest forMembersInjectedType(DeclaredType type) {
       return DependencyRequest.builder()
           .kind(Kind.MEMBERS_INJECTOR)
           .key(keyFactory.forMembersInjectedType(type))
-          .requestElement(type.asElement())
+          .requestElement(Optional.of(type.asElement()))
           .build();
     }
 
@@ -456,7 +468,7 @@ DependencyRequest forProductionImplementationExecutor() {
       return DependencyRequest.builder()
           .kind(Kind.PROVIDER)
           .key(key)
-          .requestElement(MoreTypes.asElement(key.type()))
+          .requestElement(Optional.of(MoreTypes.asElement(key.type())))
           .build();
     }
 
@@ -465,7 +477,7 @@ DependencyRequest forProductionComponentMonitor() {
       return DependencyRequest.builder()
           .kind(Kind.PROVIDER)
           .key(key)
-          .requestElement(MoreTypes.asElement(key.type()))
+          .requestElement(Optional.of(MoreTypes.asElement(key.type())))
           .overriddenVariableName(Optional.of("monitor"))
           .build();
     }
@@ -488,7 +500,7 @@ DependencyRequest forSyntheticPresentOptionalBinding(Key requestKey, Kind kind)
     }
 
     private DependencyRequest newDependencyRequest(
-        Element requestElement,
+        Optional<Element> requestElement,
         TypeMirror type,
         Optional<AnnotationMirror> qualifier,
         Optional<String> name) {
@@ -500,7 +512,7 @@ private DependencyRequest newDependencyRequest(
           .kind(kindAndType.kind())
           .key(keyFactory.forQualifiedType(qualifier, kindAndType.type()))
           .requestElement(requestElement)
-          .isNullable(allowsNull(kindAndType.kind(), getNullableType(requestElement)))
+          .isNullable(allowsNull(kindAndType.kind(), requestElement.isPresent() ? getNullableType(requestElement.get()) : Optional.empty()))
           .overriddenVariableName(name)
           .build();
     }
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencySpecGenerator.java b/compiler/src/main/java/dagger/internal/codegen/DependencySpecGenerator.java
index 855f79b41..f63c9d1c6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencySpecGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencySpecGenerator.java
@@ -12,7 +12,7 @@
 import static dagger.internal.codegen.Util.TYPENAME_INJECTOR;
 import static dagger.internal.codegen.Util.TYPENAME_INJECTOR_SPEC;
 
-public class DependencySpecGenerator extends SourceFileGenerator<Set<TypeElement>> {
+public class DependencySpecGenerator extends SourceFileGenerator<DI> {
 
     private ComponentDescriptor.Factory componentDescriptorFactory;
     private BindingGraph.Factory bindingGraphFactory;
@@ -24,23 +24,24 @@
     }
 
     @Override
-    ClassName nameGeneratedType(Set<TypeElement> input) {
+    ClassName nameGeneratedType(DI input) {
         return TYPENAME_INJECTOR_SPEC;
     }
 
     @Override
-    Optional<? extends Element> getElementForErrorReporting(Set<TypeElement> input) {
+    Optional<? extends Element> getElementForErrorReporting(DI input) {
         return Optional.empty();
     }
 
     @Override
-    Optional<TypeSpec.Builder> write(ClassName generatedTypeName, Set<TypeElement> input) {
+    Optional<TypeSpec.Builder> write(ClassName generatedTypeName, DI input) {
 
         final TypeSpec.Builder builder = TypeSpec.interfaceBuilder(generatedTypeName)
                 .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT);
 
-        input.stream()
-                .flatMap(typeElement -> ComponentInfo.forSpec(typeElement, componentDescriptorFactory, bindingGraphFactory).stream())
+        input.getComponents().stream()
+                .flatMap(typeElement -> ComponentInfo.forSpec(typeElement, componentDescriptorFactory, bindingGraphFactory, input.getAppClass().asType())
+                .stream())
                 .collect(Collectors.toList())
                 .forEach(info -> info.process(builder));
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 10d60dd71..e09e68d38 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -23,12 +23,13 @@
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
-import dagger.Multibindings;
+import com.google.common.base.Joiner;
 import dagger.multibindings.Multibinds;
 import dagger.releasablereferences.CanReleaseReferences;
 import dagger.releasablereferences.ForReleasableReferences;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
+import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import javax.lang.model.element.AnnotationMirror;
@@ -418,16 +419,20 @@ static String tooManyBindingMethodAnnotations(
   static class ComponentBuilderMessages {
     static final ComponentBuilderMessages INSTANCE = new ComponentBuilderMessages();
 
-    protected String process(String s) { return s; }
+    protected String process(String s) {
+      return s;
+    }
 
-    /** Errors for component builders. */
+    /**
+     * Errors for component builders.
+     */
     final String moreThanOne() {
       return process("@Component has more than one @Component.Builder: %s");
     }
 
     final String cxtorOnlyOneAndNoArgs() {
       return process("@Component.Builder classes must have exactly one constructor,"
-          + " and it must not have any parameters");
+              + " and it must not have any parameters");
     }
 
     final String generics() {
@@ -456,43 +461,42 @@ final String mustBeAbstract() {
 
     final String missingBuildMethod() {
       return process("@Component.Builder types must have exactly one no-args method that "
-          + " returns the @Component type");
+              + " returns the @Component type");
     }
 
     final String manyMethodsForType() {
       return process("@Component.Builder types must not have more than one setter method per type,"
-          + " but %s is set by %s");
+              + " but %s is set by %s");
     }
 
     final String extraSetters() {
       return process(
-          "@Component.Builder has setters for modules or components that aren't required: %s");
+              "@Component.Builder has setters for modules or components that aren't required: %s");
     }
 
     final String missingSetters() {
       return process(
-          "@Component.Builder is missing setters for required modules or components: %s");
+              "@Component.Builder is missing setters for required modules or components: %s");
     }
 
     final String twoBuildMethods() {
       return process("@Component.Builder types must have exactly one zero-arg method, and that"
-          + " method must return the @Component type. Already found: %s");
+              + " method must return the @Component type. Already found: %s");
     }
 
     final String inheritedTwoBuildMethods() {
       return process("@Component.Builder types must have exactly one zero-arg method, and that"
-          + " method must return the @Component type. Found %s and %s");
+              + " method must return the @Component type. Found %s and %s");
     }
 
     final String buildMustReturnComponentType() {
       return process(
-          "@Component.Builder methods that have no arguments must return the @Component type");
+              "@Component.Builder methods that have no arguments must return the @Component type or a "
+                      + "supertype of the @Component");
     }
 
     final String inheritedBuildMustReturnComponentType() {
-      return process(
-          "@Component.Builder methods that have no arguments must return the @Component type"
-          + " Inherited method: %s");
+      return process(buildMustReturnComponentType() + ". Inherited method: %s");
     }
 
     final String methodsMustTakeOneArg() {
@@ -501,17 +505,17 @@ final String methodsMustTakeOneArg() {
 
     final String inheritedMethodsMustTakeOneArg() {
       return process(
-          "@Component.Builder methods must not have more than one argument. Inherited method: %s");
+              "@Component.Builder methods must not have more than one argument. Inherited method: %s");
     }
 
     final String methodsMustReturnVoidOrBuilder() {
       return process("@Component.Builder setter methods must return void, the builder,"
-          + " or a supertype of the builder");
+              + " or a supertype of the builder");
     }
 
     final String inheritedMethodsMustReturnVoidOrBuilder() {
       return process("@Component.Builder setter methods must return void, the builder,"
-          + "or a supertype of the builder. Inherited method: %s");
+              + "or a supertype of the builder. Inherited method: %s");
     }
 
     final String methodsMayNotHaveTypeParameters() {
@@ -520,12 +524,29 @@ final String methodsMayNotHaveTypeParameters() {
 
     final String inheritedMethodsMayNotHaveTypeParameters() {
       return process(
-          "@Component.Builder methods must not have type parameters. Inherited method: %s");
+              "@Component.Builder methods must not have type parameters. Inherited method: %s");
     }
 
     public String noBuilderPresent() {
       return process("Each Component and Subcomponent needs a @Component.Builder or @Subcomponent.Builder declaration. Declaration is missing for: %s");
     }
+
+    final String buildMethodReturnsSupertypeWithMissingMethods(
+            TypeElement component,
+            TypeElement componentBuilder,
+            TypeMirror returnType,
+            ExecutableElement buildMethod,
+            Set<ExecutableElement> additionalMethods) {
+      return String.format(
+              "%1$s.%2$s() returns %3$s, but %4$s declares additional component method(s): %5$s. In "
+                      + "order to provide type-safe access to these methods, override %2$s() to return "
+                      + "%4$s",
+              componentBuilder.getQualifiedName(),
+              buildMethod.getSimpleName(),
+              returnType,
+              component.getQualifiedName(),
+              Joiner.on(", ").join(additionalMethods));
+    }
   }
 
   static final class SubcomponentBuilderMessages extends ComponentBuilderMessages {
@@ -569,28 +590,7 @@ protected String process(String s) {
     }
   }
 
-  /** Error messages related to {@link Multibindings @Multibindings}. */
-  static final class MultibindingsMessages {
-    static final String MUST_BE_INTERFACE = "@Multibindings can be applied only to interfaces";
-
-    static final String MUST_NOT_HAVE_TYPE_PARAMETERS =
-        "@Multibindings types must not have type parameters";
-
-    static final String MUST_BE_IN_MODULE =
-        "@Multibindings types must be nested within a @Module or @ProducerModule";
-
-    static String tooManyMethodsForKey(String formattedKey) {
-      return String.format(
-          "Too many @Multibindings methods for %s", stripCommonTypePrefixes(formattedKey));
-    }
-
-    private MultibindingsMessages() {}
-  }
-
-  /**
-   * Error messages related to {@link Multibinds @Multibinds} methods and methods in
-   * {@link Multibindings} interfaces.
-   */
+  /** Error messages related to {@link Multibinds @Multibinds} methods. */
   static final class MultibindsMessages {
     static final String METHOD_MUST_RETURN_MAP_OR_SET =
         "@%s methods must return Map<K, V> or Set<T>";
diff --git a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
index 1e4cff071..0ac166e87 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FactoryGenerator.java
@@ -27,6 +27,7 @@
 import static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;
 import static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;
 import static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;
+import static dagger.internal.codegen.GwtCompatibility.gwtIncompatibleAnnotation;
 import static dagger.internal.codegen.Proxies.createProxy;
 import static dagger.internal.codegen.Proxies.shouldGenerateProxy;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
@@ -327,6 +328,8 @@ ClassName nameGeneratedType(ProvisionBinding binding) {
 
     proxyMethodFor(binding).ifPresent(factoryBuilder::addMethod);
 
+    gwtIncompatibleAnnotation(binding).ifPresent(factoryBuilder::addAnnotation);
+
     return Optional.of(factoryBuilder);
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/GeneratorComponentInfo.java b/compiler/src/main/java/dagger/internal/codegen/GeneratorComponentInfo.java
index 639b58515..0f22a3644 100644
--- a/compiler/src/main/java/dagger/internal/codegen/GeneratorComponentInfo.java
+++ b/compiler/src/main/java/dagger/internal/codegen/GeneratorComponentInfo.java
@@ -80,6 +80,9 @@ protected String getId() {
                 final TypeElement typeElement = requirement.typeElement();
                 final boolean hasNotOnlyNoArgConstructor = hasNotOnlyNoArgConstructor(typeElement, requirement.autoCreate());
                 final String methodName = requirementMethod.method().getSimpleName().toString();
+                if (requirement.kind() == ComponentRequirement.Kind.BINDING && requirementMethod.method().getReturnType().toString().equals(void.class.getName())) {
+                    continue;
+                }
                 if ((requirement.kind() == ComponentRequirement.Kind.MODULE &&
                         hasNotOnlyNoArgConstructor) || requirement.kind() != ComponentRequirement.Kind.MODULE) {
                     moduleConstructorStatements.add(CodeBlock.of(".$L($L)",
diff --git a/compiler/src/main/java/dagger/internal/codegen/GwtCompatibility.java b/compiler/src/main/java/dagger/internal/codegen/GwtCompatibility.java
new file mode 100644
index 000000000..34d8f6d69
--- /dev/null
+++ b/compiler/src/main/java/dagger/internal/codegen/GwtCompatibility.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkArgument;
+
+import com.squareup.javapoet.AnnotationSpec;
+import java.util.Optional;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.Name;
+
+final class GwtCompatibility {
+
+  /**
+   * Returns a {@code @GwtIncompatible} annotation that is applied to {@code binding}'s {@link
+   * Binding#bindingElement()} or any enclosing type.
+   */
+  static Optional<AnnotationSpec> gwtIncompatibleAnnotation(Binding binding) {
+    checkArgument(binding.bindingElement().isPresent());
+    Element element = binding.bindingElement().get();
+    while (element != null) {
+      Optional<AnnotationSpec> gwtIncompatible =
+          element
+              .getAnnotationMirrors()
+              .stream()
+              .filter(annotation -> isGwtIncompatible(annotation))
+              .map(AnnotationSpec::get)
+              .findFirst();
+      if (gwtIncompatible.isPresent()) {
+        return gwtIncompatible;
+      }
+      element = element.getEnclosingElement();
+    }
+    return Optional.empty();
+  }
+
+  private static boolean isGwtIncompatible(AnnotationMirror annotation) {
+    Name simpleName = annotation.getAnnotationType().asElement().getSimpleName();
+    return simpleName.contentEquals("GwtIncompatible");
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
index 3f504d23f..c86ec8c76 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorGenerator.java
@@ -52,7 +52,7 @@ ClassName nameGeneratedType(DI input) {
         createDecoratorClasses(builder, components, appClass);
         for (TypeElement component : components) {
             final List<TriggerComponentInfo> infos =
-                    ComponentInfo.forTrigger(component, componentDescriptorFactory, bindingGraphFactory);
+                    ComponentInfo.forTrigger(component, componentDescriptorFactory, bindingGraphFactory, input.getAppClass().asType());
             infos.forEach(info -> info.process(builder));
         }
 
@@ -62,11 +62,11 @@ ClassName nameGeneratedType(DI input) {
     private void createDecoratorClasses(TypeSpec.Builder builder, Set<TypeElement> components, TypeElement appClass) {
         final ClassName appClassName = ClassName.get(appClass);
         ClassName testAppClassName = appClassName.topLevelClassName().peerClass("Test" + appClassName.simpleName());
-        final Decorator decorator = decoratorFactory.create(testAppClassName);
+        final Decorator decorator = decoratorFactory.create(testAppClassName, appClass.asType());
 
         components.stream()
                 .map(componentDescriptorFactory::forComponent)
-                .map(bindingGraphFactory::create)
+                .map(descriptor -> bindingGraphFactory.create(descriptor, appClass.asType()))
                 .flatMap(this::flatMapAllSubgraphs)
                 .filter(bindingGraph -> bindingGraph.componentDescriptor() != null && !bindingGraph.delegateRequirements().isEmpty())
                 .filter(distinctByKey(graph -> simpleVariableName(graph.componentDescriptor().componentDefinitionType())))
diff --git a/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
index 94a76d397..73b7f3055 100644
--- a/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/InjectorProcessingStep.java
@@ -70,16 +70,19 @@ public InjectorProcessingStep(Types types, Messager messager,
     @Override
     public Set<Element> process(SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation, boolean anyElementsRejected) {
 
-        if(anyElementsRejected) {
-            return ImmutableSet.of();
-        }
-
         final Iterator<Element> it = elementsByAnnotation.get(Config.class).iterator();
         if (!it.hasNext()) {
-            return ImmutableSet.of();
+            return ImmutableSet.copyOf(elementsByAnnotation.values());
+        }
+
+        final Element config = it.next();
+        final Config configAnnotation = config.getAnnotation(Config.class);
+
+        if(anyElementsRejected) {
+            return ImmutableSet.copyOf(elementsByAnnotation.values());
         }
 
-        final Config configAnnotation = it.next().getAnnotation(Config.class);
+        final AppConfig appConfig = appConfigFactory.create(configAnnotation);
 
         Set<Element> rejectedElements = new LinkedHashSet<>();
 
@@ -90,14 +93,14 @@ public InjectorProcessingStep(Types types, Messager messager,
         for (Element element : elementsByAnnotation.get(component.annotationType())) {
             TypeElement componentTypeElement = (TypeElement) element;
             ComponentDescriptor componentDescriptor = componentDescriptorFactory.forComponent(componentTypeElement);
-            BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+            BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor, appConfig.getAppClass().asType());
             InjectorType injectorType = new InjectorType(componentTypeElement, bindingGraph, componentDescriptor);
             injectorTypeList.add(injectorType);
         }
         if (rejectedElements.isEmpty()) {
             for (TypeElement component : components) {
                 final ComponentDescriptor componentDescriptor = componentDescriptorFactory.forComponent(component);
-                final BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+                final BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor, appConfig.getAppClass().asType());
                 final ImmutableSet<ComponentDescriptor> componentDescriptors = bindingGraph.componentDescriptors();
                 componentDescriptors
                         .stream()
@@ -106,13 +109,14 @@ public InjectorProcessingStep(Types types, Messager messager,
                         .map(ComponentDescriptor.BuilderSpec::requirementMethods)
                         .flatMap(Collection::stream)
                         .filter(method -> method.requirement().kind() == ComponentRequirement.Kind.BINDING)
-                        .forEach(method -> stubGenerator.generate(provisionBindingFactory.forBuilderBinding(method), messager));
+                        .forEach(method -> {
+                            stubGenerator.generate(provisionBindingFactory.forBuilderBinding(method), messager);
+                        });
 
             }
-            final AppConfig appConfig = appConfigFactory.create(configAnnotation);
             final DI di = new DI(appConfig, components, injectorTypeList);
             this.applicationGenerator.generate(di, messager);
-            this.dependencySpecGenerator.generate(components, messager);
+            this.dependencySpecGenerator.generate(di, messager);
             this.dependencyInjectorGenerator.generate(di, messager);
             this.injectorGenerator.generate(di, messager);
         } else {
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index 4ff20e8b3..21983a788 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -45,7 +45,6 @@
 import dagger.Binds;
 import dagger.BindsOptionalOf;
 import dagger.MapKey;
-import dagger.Multibindings;
 import dagger.multibindings.*;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
@@ -128,7 +127,7 @@
   public abstract int hashCode();
 
   static Builder builder(TypeMirror type) {
-    return new AutoValue_Key.Builder().type(type);
+    return new dagger.internal.codegen.AutoValue_Key.Builder().type(type);
   }
 
   @AutoValue.Builder
@@ -406,7 +405,7 @@ Key withoutMultibindingContributionIdentifier() {
   }
 
   boolean isValidMembersInjectionKey() {
-    return !qualifier().isPresent() && !type().getKind().equals(TypeKind.WILDCARD);
+    return !qualifier().isPresent() && type().getKind().equals(TypeKind.DECLARED);
   }
 
   /**
@@ -604,8 +603,7 @@ private Key forBindingMethod(
     }
 
     /**
-     * Returns the key for a {@link Multibinds @Multibinds} method or a method in a
-     * {@link Multibindings @Multibindings} interface.
+     * Returns the key for a {@link Multibinds @Multibinds} method.
      *
      * <p>The key's type is either {@code Set<T>} or {@code Map<K, F<V>>}, where {@code F} is either
      * {@link Provider} or {@link Producer}, depending on {@code bindingType}.
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java b/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
index 5d565dd14..ca4bed2b2 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapKeyValidator.java
@@ -27,6 +27,7 @@
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeKind;
+import javax.lang.model.util.Elements;
 
 /**
  * A validator for {@link MapKey} annotations.
@@ -36,6 +37,12 @@
  */
 // TODO(dpb,gak): Should unwrapped MapKeys be required to have their single member be named "value"?
 final class MapKeyValidator {
+  private final Elements elements;
+
+  MapKeyValidator(Elements elements) {
+    this.elements = elements;
+  }
+
   ValidationReport<Element> validate(Element element) {
     ValidationReport.Builder<Element> builder = ValidationReport.about(element);
     List<ExecutableElement> members = methodsIn(((TypeElement) element).getEnclosedElements());
@@ -47,7 +54,15 @@
       } else if (members.get(0).getReturnType().getKind() == TypeKind.ARRAY) {
         builder.addError(UNWRAPPED_MAP_KEY_WITH_ARRAY_MEMBER, element);
       }
+    } else if (autoAnnotationIsMissing()) {
+      builder.addError(
+          "@AutoAnnotation is a necessary dependency if @MapKey(unwrapValue = false). Add a "
+              + "dependency on com.google.auto.value:auto-value:<current version>");
     }
     return builder.build();
   }
+
+  private boolean autoAnnotationIsMissing() {
+    return elements.getTypeElement("com.google.auto.value.AutoAnnotation") == null;
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
index 3cf636764..eeca10431 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectorGenerator.java
@@ -29,6 +29,7 @@
 import static dagger.internal.codegen.AnnotationSpecs.suppressWarnings;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
+import static dagger.internal.codegen.GwtCompatibility.gwtIncompatibleAnnotation;
 import static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
@@ -219,6 +220,8 @@ ClassName nameGeneratedType(MembersInjectionBinding binding) {
     injectorTypeBuilder.addMethod(injectMembersBuilder.build());
     injectMethodsForSubclasses.forEach(injectorTypeBuilder::addMethod);
 
+    gwtIncompatibleAnnotation(binding).ifPresent(injectorTypeBuilder::addAnnotation);
+
     return Optional.of(injectorTypeBuilder);
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java b/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java
index c510e091c..0c1fae7f6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MethodSignature.java
@@ -1,3 +1,19 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index ec665409f..52211589f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -16,16 +16,21 @@
 
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreElements.getPackage;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 import static com.google.common.base.Preconditions.checkArgument;
 import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
+import static dagger.internal.codegen.DaggerElements.checkTypePresent;
 import static dagger.internal.codegen.DaggerElements.getAnnotationMirror;
+import static dagger.internal.codegen.DaggerElements.isAnnotationPresent;
+import static dagger.internal.codegen.SourceFiles.classFileName;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.NONE;
 import static javax.lang.model.util.ElementFilter.methodsIn;
-import static javax.lang.model.util.ElementFilter.typesIn;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
@@ -33,10 +38,10 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Sets;
 import com.google.errorprone.annotations.CanIgnoreReturnValue;
+import com.squareup.javapoet.ClassName;
 import dagger.Binds;
 import dagger.BindsOptionalOf;
 import dagger.Module;
-import dagger.Multibindings;
 import dagger.Provides;
 import dagger.multibindings.Multibinds;
 import dagger.producers.ProducerModule;
@@ -81,8 +86,8 @@
     private final Class<? extends Annotation> methodAnnotation;
 
     /**
-     * Returns the kind of an annotated element if it is annotated with one of the
-     * {@linkplain #moduleAnnotation() annotation types}.
+     * Returns the kind of an annotated element if it is annotated with one of the {@linkplain
+     * #moduleAnnotation() annotation types}.
      *
      * @throws IllegalArgumentException if the element is annotated with more than one of the
      *     annotation types
@@ -184,13 +189,6 @@ ModuleDescriptor create(TypeElement moduleElement) {
         }
       }
 
-      for (TypeElement memberType : typesIn(elements.getAllMembers(moduleElement))) {
-        if (isAnnotationPresent(memberType, Multibindings.class)) {
-          multibindingDeclarations.addAll(
-              multibindingDeclarationFactory.forMultibindingsInterface(memberType));
-        }
-      }
-
       return new AutoValue_ModuleDescriptor(
           moduleElement,
           ImmutableSet.copyOf(collectIncludedModules(new LinkedHashSet<>(), moduleElement)),
@@ -219,8 +217,35 @@ ModuleDescriptor create(TypeElement moduleElement) {
             .map(MoreTypes::asTypeElement)
             .map(this::create)
             .forEach(includedModules::add);
+
+        collectImplicitlyIncludedModules(includedModules, moduleElement);
       }
       return includedModules;
     }
+
+    // @ContributesAndroidInjector generates a module that is implicitly included in the enclosing
+    // module
+    private void collectImplicitlyIncludedModules(
+        Set<ModuleDescriptor> includedModules, TypeElement moduleElement) {
+      TypeElement contributesAndroidInjector =
+          elements.getTypeElement("dagger.android.ContributesAndroidInjector");
+      if (contributesAndroidInjector == null) {
+        return;
+      }
+      for (ExecutableElement method : methodsIn(moduleElement.getEnclosedElements())) {
+        if (isAnnotationPresent(method, contributesAndroidInjector.asType())) {
+          includedModules.add(
+              create(checkTypePresent(implicitlyIncludedModuleName(method), elements)));
+        }
+      }
+    }
+
+    private String implicitlyIncludedModuleName(ExecutableElement method) {
+      return getPackage(method).getQualifiedName()
+          + "."
+          + classFileName(ClassName.get(MoreElements.asType(method.getEnclosingElement())))
+          + "_"
+          + LOWER_CAMEL.to(UPPER_CAMEL, method.getSimpleName().toString());
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
index fd0a59a09..fdf7d1c15 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleValidator.java
@@ -43,7 +43,6 @@
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.util.ElementFilter.methodsIn;
-import static javax.lang.model.util.ElementFilter.typesIn;
 
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
@@ -56,7 +55,6 @@
 import com.google.common.collect.Sets;
 import dagger.Binds;
 import dagger.Module;
-import dagger.Multibindings;
 import dagger.Subcomponent;
 import dagger.multibindings.Multibinds;
 import dagger.producers.ProducerModule;
@@ -99,7 +97,6 @@
   private final Types types;
   private final Elements elements;
   private final AnyBindingMethodValidator anyBindingMethodValidator;
-  private final MultibindingsValidator multibindingsValidator;
   private final MethodSignatureFormatter methodSignatureFormatter;
   private final Map<TypeElement, ValidationReport<TypeElement>> cache = new HashMap<>();
   private final Set<TypeElement> knownModules = new HashSet<>();
@@ -108,12 +105,10 @@
       Types types,
       Elements elements,
       AnyBindingMethodValidator anyBindingMethodValidator,
-      MultibindingsValidator multibindingsValidator,
       MethodSignatureFormatter methodSignatureFormatter) {
     this.types = types;
     this.elements = elements;
     this.anyBindingMethodValidator = anyBindingMethodValidator;
-    this.multibindingsValidator = multibindingsValidator;
     this.methodSignatureFormatter = methodSignatureFormatter;
   }
 
@@ -175,20 +170,10 @@ void addKnownModules(Collection<TypeElement> modules) {
     validateModifiers(module, builder);
     validateReferencedModules(module, moduleKind, builder);
     validateReferencedSubcomponents(module, moduleKind, builder);
-    validateNestedMultibindingsTypes(module, builder);
 
     return builder.build();
   }
 
-  private void validateNestedMultibindingsTypes(
-      TypeElement module, ValidationReport.Builder<TypeElement> builder) {
-    for (TypeElement nestedType : typesIn(elements.getAllMembers(module))) {
-      if (isAnnotationPresent(nestedType, Multibindings.class)) {
-        builder.addSubreport(multibindingsValidator.validate(nestedType));
-      }
-    }
-  }
-
   private void validateReferencedSubcomponents(
       final TypeElement subject,
       ModuleDescriptor.Kind moduleKind,
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
index 5be39a059..10c5a1e6f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingDeclaration.java
@@ -16,16 +16,12 @@
 
 package dagger.internal.codegen;
 
-import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.base.Preconditions.checkArgument;
-import static javax.lang.model.element.ElementKind.INTERFACE;
 
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
-import com.google.common.collect.ImmutableSet;
 import dagger.Module;
-import dagger.Multibindings;
 import dagger.internal.codegen.BindingType.HasBindingType;
 import dagger.internal.codegen.ContributionType.HasContributionType;
 import dagger.multibindings.Multibinds;
@@ -38,7 +34,6 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
-import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Elements;
@@ -47,7 +42,7 @@
 /**
  * A declaration that a multibinding with a certain key is available to be injected in a component
  * even if the component has no multibindings for that key. Identified by a map- or set-returning
- * method in a {@link Multibindings @Multibindings}-annotated interface nested within a module.
+ * method annotated with {@link Multibinds @Multibinds}.
  */
 @AutoValue
 abstract class MultibindingDeclaration extends BindingDeclaration
@@ -69,8 +64,8 @@
   public abstract ContributionType contributionType();
 
   /**
-   * {@link BindingType#PROVISION} if the {@link Multibindings @Multibindings}-annotated interface
-   * is nested in a {@link Module @Module}, or {@link BindingType#PROVISION} if it is nested in a
+   * {@link BindingType#PROVISION} if {@link Multibinds @Multibinds}-annotated method
+   * is enclosed in a {@link Module @Module}, or {@link BindingType#PROVISION} if it is nested in a
    * {@link ProducerModule @ProducerModule}.
    */
   @Override
@@ -92,28 +87,6 @@
       this.objectElement = elements.getTypeElement(Object.class.getCanonicalName());
     }
 
-    /**
-     * Creates multibinding declarations for each method in a
-     * {@link Multibindings @Multibindings}-annotated interface.
-     */
-    ImmutableSet<MultibindingDeclaration> forMultibindingsInterface(TypeElement interfaceElement) {
-      checkArgument(interfaceElement.getKind().equals(INTERFACE));
-      checkArgument(isAnnotationPresent(interfaceElement, Multibindings.class));
-      BindingType bindingType = bindingType(interfaceElement.getEnclosingElement());
-      DeclaredType interfaceType = MoreTypes.asDeclared(interfaceElement.asType());
-
-      ImmutableSet.Builder<MultibindingDeclaration> declarations = ImmutableSet.builder();
-      for (ExecutableElement method :
-          getLocalAndInheritedMethods(interfaceElement, types, elements)) {
-        if (!method.getEnclosingElement().equals(objectElement)) {
-          ExecutableType methodType =
-              MoreTypes.asExecutable(types.asMemberOf(interfaceType, method));
-          declarations.add(forDeclaredMethod(bindingType, method, methodType, interfaceElement));
-        }
-      }
-      return declarations.build();
-    }
-
     /** A multibinding declaration for a {@link Multibinds @Multibinds} method. */
     MultibindingDeclaration forMultibindsMethod(
         ExecutableElement moduleMethod, TypeElement moduleElement) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java
deleted file mode 100644
index fed327ff1..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import com.google.common.collect.ImmutableSet;
-import dagger.Multibindings;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-
-/** A validator for methods in {@link Multibindings @Multibindings} interfaces. */
-final class MultibindingsMethodValidator extends MultibindsMethodValidator {
-
-  MultibindingsMethodValidator(Elements elements, Types types) {
-    super(elements, types, Multibindings.class, ImmutableSet.of(Multibindings.class));
-  }
-
-  @Override
-  protected void checkEnclosingElement(ValidationReport.Builder<ExecutableElement> builder) {
-    // no-op, since @Multibindings interfaces can inherit methods from unannotated supertypes.
-  }
-}
-
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsProcessingStep.java
deleted file mode 100644
index 6cf8c1bcd..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingsProcessingStep.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static javax.lang.model.util.ElementFilter.typesIn;
-
-import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.SetMultimap;
-import dagger.Multibindings;
-import java.lang.annotation.Annotation;
-import java.util.Set;
-import javax.annotation.processing.Messager;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
-
-/**
- * Valdiates types annotated with {@link Multibindings @Multibindings} that haven't already been
- * validated while processing their enclosing modules.
- */
-class MultibindingsProcessingStep implements BasicProcessor.ProcessingStep {
-  private final Messager messager;
-  private final MultibindingsValidator multibindingsValidator;
-
-  MultibindingsProcessingStep(Messager messager, MultibindingsValidator multibindingsValidator) {
-    this.messager = messager;
-    this.multibindingsValidator = multibindingsValidator;
-  }
-
-  @Override
-  public Set<? extends Class<? extends Annotation>> annotations() {
-    return ImmutableSet.of(Multibindings.class);
-  }
-
-  @Override
-  public Set<Element> process(
-      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation, boolean anyElementsRejected) {
-    for (TypeElement element : typesIn(elementsByAnnotation.values())) {
-      if (!multibindingsValidator.wasAlreadyValidated(element)) {
-        multibindingsValidator.validate(element).printMessagesTo(messager);
-      }
-    }
-    return ImmutableSet.of();
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
deleted file mode 100644
index 4785b64cb..000000000
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingsValidator.java
+++ /dev/null
@@ -1,148 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;
-import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static com.google.auto.common.MoreTypes.asExecutable;
-import static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;
-import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.MUST_BE_INTERFACE;
-import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.MUST_BE_IN_MODULE;
-import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.MUST_NOT_HAVE_TYPE_PARAMETERS;
-import static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.tooManyMethodsForKey;
-import static javax.lang.model.element.ElementKind.INTERFACE;
-
-import com.google.common.collect.ImmutableListMultimap;
-import dagger.Module;
-import dagger.Multibindings;
-import dagger.producers.ProducerModule;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Optional;
-import javax.lang.model.element.ExecutableElement;
-import javax.lang.model.element.TypeElement;
-import javax.lang.model.util.Elements;
-import javax.lang.model.util.Types;
-
-/**
- * A {@linkplain ValidationReport validator} for {@link Multibindings @Multibindings}-annotated
- * types.
- */
-final class MultibindingsValidator {
-  private final Elements elements;
-  private final Types types;
-  private final Key.Factory keyFactory;
-  private final KeyFormatter keyFormatter;
-  private final MethodSignatureFormatter methodSignatureFormatter;
-  private final TypeElement objectElement;
-  private final MultibindingsMethodValidator multibindingsMethodValidator;
-  private final Map<TypeElement, ValidationReport<TypeElement>> reports = new HashMap<>();
-
-  MultibindingsValidator(
-      Elements elements,
-      Types types,
-      Key.Factory keyFactory,
-      KeyFormatter keyFormatter,
-      MethodSignatureFormatter methodSignatureFormatter,
-      MultibindingsMethodValidator multibindingsMethodValidator) {
-    this.elements = elements;
-    this.types = types;
-    this.keyFactory = keyFactory;
-    this.keyFormatter = keyFormatter;
-    this.methodSignatureFormatter = methodSignatureFormatter;
-    this.multibindingsMethodValidator = multibindingsMethodValidator;
-    this.objectElement = elements.getTypeElement(Object.class.getCanonicalName());
-  }
-  
-  /**
-   * Returns a report containing validation errors for a {@link
-   * Multibindings @Multibindings}-annotated type.
-   */
-  public ValidationReport<TypeElement> validate(TypeElement multibindingsType) {
-    return reports.computeIfAbsent(multibindingsType, this::validateUncached);
-  }
-
-  /**
-   * Returns {@code true} if {@code multibindingsType} was already {@linkplain
-   * #validate(TypeElement) validated}.
-   */
-  boolean wasAlreadyValidated(TypeElement multibindingsType) {
-    return reports.containsKey(multibindingsType);
-  }
-
-  private ValidationReport<TypeElement> validateUncached(TypeElement multibindingsType) {
-    ValidationReport.Builder<TypeElement> validation = ValidationReport.about(multibindingsType);
-    if (!multibindingsType.getKind().equals(INTERFACE)) {
-      validation.addError(MUST_BE_INTERFACE, multibindingsType);
-    }
-    if (!multibindingsType.getTypeParameters().isEmpty()) {
-      validation.addError(MUST_NOT_HAVE_TYPE_PARAMETERS, multibindingsType);
-    }
-    Optional<BindingType> bindingType = bindingType(multibindingsType);
-    if (!bindingType.isPresent()) {
-      validation.addError(MUST_BE_IN_MODULE, multibindingsType);
-    }
-
-    ImmutableListMultimap.Builder<Key, ExecutableElement> methodsByKey =
-        ImmutableListMultimap.builder();
-    for (ExecutableElement method :
-        getLocalAndInheritedMethods(multibindingsType, types, elements)) {
-      // Skip methods in Object.
-      if (method.getEnclosingElement().equals(objectElement)) {
-        continue;
-      }
-      
-      ValidationReport<ExecutableElement> methodReport =
-          multibindingsMethodValidator.validate(method);
-      validation.addItems(methodReport.items());
-
-      if (methodReport.isClean() && bindingType.isPresent()) {
-        methodsByKey.put(
-            keyFactory.forMultibindsMethod(
-                bindingType.get(), asExecutable(method.asType()), method),
-            method);
-      }
-    }
-    for (Map.Entry<Key, Collection<ExecutableElement>> entry :
-        methodsByKey.build().asMap().entrySet()) {
-      Collection<ExecutableElement> methods = entry.getValue();
-      if (methods.size() > 1) {
-        Key key = entry.getKey();
-        validation.addError(tooManyMultibindingsMethodsForKey(key, methods), multibindingsType);
-      }
-    }
-    return validation.build();
-  }
-
-  private String tooManyMultibindingsMethodsForKey(Key key, Collection<ExecutableElement> methods) {
-    StringBuilder builder = new StringBuilder(tooManyMethodsForKey(keyFormatter.format(key)));
-    builder.append(':');
-    methodSignatureFormatter.formatIndentedList(builder, methods, 1, DUPLICATE_SIZE_LIMIT);
-    return builder.toString();
-  }
-
-  private static Optional<BindingType> bindingType(TypeElement multibindingsType) {
-    if (isAnnotationPresent(multibindingsType.getEnclosingElement(), Module.class)) {
-      return Optional.of(BindingType.PROVISION);
-    } else if (isAnnotationPresent(multibindingsType.getEnclosingElement(), ProducerModule.class)) {
-      return Optional.of(BindingType.PRODUCTION);
-    } else {
-      return Optional.empty();
-    }
-  }
-}
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java
index 35ae26c00..3be0aa9d9 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java
@@ -26,7 +26,6 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableSet;
 import dagger.Module;
-import dagger.Multibindings;
 import dagger.multibindings.Multibinds;
 import dagger.producers.ProducerModule;
 import java.lang.annotation.Annotation;
@@ -35,7 +34,7 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-/** A validator for {@link Multibinds} methods or methods in {@link Multibindings} interfaces. */
+/** A validator for {@link Multibinds} methods. */
 class MultibindsMethodValidator extends BindingMethodValidator {
 
   /** Creates a validator for {@link Multibinds @Multibinds} methods. */
diff --git a/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java b/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java
index 864e620f5..4d608f8c7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java
+++ b/compiler/src/main/java/dagger/internal/codegen/OptionalFactories.java
@@ -36,6 +36,7 @@
 import com.google.common.base.Function;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.FieldSpec;
@@ -53,6 +54,7 @@
 import java.util.Comparator;
 import java.util.Map;
 import java.util.TreeMap;
+import java.util.concurrent.Executor;
 import javax.inject.Provider;
 
 /** The nested class and static methods required by the component to implement optional bindings. */
@@ -324,15 +326,16 @@ private TypeSpec presentOptionalFactoryClass(PresentFactorySpec spec) {
   }
 
   /**
-   * An expression that uses {@link Futures#transform(ListenableFuture, Function)} to transform a
-   * {@code ListenableFuture<inputType>} into a {@code ListenableFuture<Optional<inputType>>}.
+   * An expression that uses {@link Futures#transform(ListenableFuture, Function, Executor)} to
+   * transform a {@code ListenableFuture<inputType>} into a {@code
+   * ListenableFuture<Optional<inputType>>}.
    *
    * @param inputFuture an expression of type {@code ListenableFuture<inputType>}
    */
   private static CodeBlock transformFutureToOptional(
       OptionalKind optionalKind, TypeName inputType, CodeBlock inputFuture) {
     return CodeBlock.of(
-        "$T.transform($L, $L)",
+        "$T.transform($L, $L, $T.directExecutor())",
         Futures.class,
         inputFuture,
         anonymousClassBuilder("")
@@ -347,7 +350,8 @@ private static CodeBlock transformFutureToOptional(
                     .addParameter(inputType, "input")
                     .addCode("return $L;", optionalKind.presentExpression(CodeBlock.of("input")))
                     .build())
-            .build());
+            .build(),
+        MoreExecutors.class);
   }
 
   /**
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index 7a2c2c586..44d656b2c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -23,6 +23,7 @@
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
+import static dagger.internal.codegen.GwtCompatibility.gwtIncompatibleAnnotation;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
@@ -214,6 +215,8 @@ ClassName nameGeneratedType(ProductionBinding binding) {
     factoryBuilder.addMethod(applyMethodBuilder.build());
     factoryBuilder.addMethod(executeMethodBuilder.build());
 
+    gwtIncompatibleAnnotation(binding).ifPresent(factoryBuilder::addAnnotation);
+
     // TODO(gak): write a sensible toString
     return Optional.of(factoryBuilder);
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 7f3f7086f..ef89fa930 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -294,28 +294,31 @@ ProvisionBinding forBuilderBinding(BuilderRequirementMethod method) {
     }
 
     ProvisionBinding forSubcomponentBuilderMethod(
-        ExecutableElement subcomponentBuilderMethod, TypeElement contributedBy) {
+            ExecutableElement subcomponentBuilderMethod, TypeElement contributedBy, TypeMirror application) {
       checkNotNull(subcomponentBuilderMethod);
       checkArgument(subcomponentBuilderMethod.getKind().equals(METHOD));
       checkArgument(subcomponentBuilderMethod.getParameters().isEmpty());
       DeclaredType declaredContainer = asDeclared(contributedBy.asType());
+      final DependencyRequest request = dependencyRequestFactory.plantDependency(application);
       return ProvisionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
           .ignoreStubGeneration(subcomponentBuilderMethod.getAnnotation(AllowStubGeneration.class) == null)
           .bindingElement(subcomponentBuilderMethod)
-          .key(
-              keyFactory.forSubcomponentBuilderMethod(subcomponentBuilderMethod, declaredContainer))
+          .key(keyFactory.forSubcomponentBuilderMethod(subcomponentBuilderMethod, declaredContainer))
           .bindingKind(Kind.SUBCOMPONENT_BUILDER)
+          .explicitDependencies(request)
           .build();
     }
 
     ProvisionBinding syntheticSubcomponentBuilder(
-        ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations) {
+            ImmutableSet<SubcomponentDeclaration> subcomponentDeclarations, TypeMirror application) {
       SubcomponentDeclaration subcomponentDeclaration = subcomponentDeclarations.iterator().next();
+      final DependencyRequest request = dependencyRequestFactory.plantDependency(application);
       return ProvisionBinding.builder()
           .contributionType(ContributionType.UNIQUE)
           .key(subcomponentDeclaration.key())
           .bindingKind(Kind.SUBCOMPONENT_BUILDER)
+          .explicitDependencies(request)
           .build();
     }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
index 3a8906faf..1d73fb369 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SourceFiles.java
@@ -1,15 +1,17 @@
 /*
  * Copyright (C) 2014 The Dagger Authors.
  *
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
- * in compliance with the License. You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
  *
  * http://www.apache.org/licenses/LICENSE-2.0
  *
- * Unless required by applicable law or agreed to in writing, software distributed under the License
- * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
- * or implied. See the License for the specific language governing permissions and limitations under
- * the License.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 package dagger.internal.codegen;
diff --git a/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java b/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java
index 4012d9cf9..0dc4918d8 100644
--- a/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/StubGenerator.java
@@ -13,11 +13,7 @@
 import javax.lang.model.element.Modifier;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
-import java.lang.annotation.Annotation;
 import java.util.*;
-
-import static dagger.internal.codegen.SourceFiles.DEPENDENCY_ORDERING;
-import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;
 import static dagger.internal.codegen.TypeNames.*;
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java b/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java
index 6899ca6d6..bc6fbb485 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TriggerComponentInfo.java
@@ -65,10 +65,9 @@ protected ParameterSpec getBuilderParameterSpec(ClassName builderClassName) {
         return ParameterSpec.builder(builderClassName, "builder").build();
     }
 
-    public static String resolveBuilderName(BindingGraph.Factory bindingGraphFactory, ComponentDescriptor descriptor) {
+    public static String resolveBuilderName(BindingGraph graph, BindingGraph parentGraph) {
 
-        ComponentDescriptor topDescriptor = getTopDescriptor(descriptor);
-        final BindingGraph parentGraph = bindingGraphFactory.create(topDescriptor);
+        final ComponentDescriptor descriptor = graph.componentDescriptor();
         final ImmutableBiMap<ComponentDescriptor, String> subcomponentNamesMap =
                 new ComponentWriter.UniqueSubcomponentNamesGenerator(parentGraph).generate();
 
@@ -82,13 +81,6 @@ public static String resolveBuilderName(BindingGraph.Factory bindingGraphFactory
         }
     }
 
-    private static ComponentDescriptor getTopDescriptor(ComponentDescriptor descriptor) {
-        while(descriptor.getParentDescriptor() != null) {
-            descriptor = descriptor.getParentDescriptor();
-        }
-        return descriptor;
-    }
-
     protected static String resolveSubcomponentBuilderName(ImmutableBiMap<ComponentDescriptor, String> subcomponentNamesMap,
                                                            ComponentDescriptor descriptor) {
         final String parentClassName = internalResolveClassName(subcomponentNamesMap, descriptor.getParentDescriptor());
diff --git a/compiler/src/main/java/dagger/internal/codegen/Util.java b/compiler/src/main/java/dagger/internal/codegen/Util.java
index 563d575a6..2aabb02e0 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Util.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Util.java
@@ -26,7 +26,6 @@
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.STATIC;
-
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Function;
@@ -42,9 +41,10 @@
 import dagger.multibindings.LongKey;
 import dagger.multibindings.StringKey;
 import dagger.producers.Produces;
-
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.function.Predicate;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import java.util.stream.Collector;
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ExecutableElement;
@@ -126,9 +126,6 @@ static boolean componentCanMakeNewInstances(TypeElement typeElement) {
                 return true;
             }
         }
-
-        // TODO(gak): still need checks for visibility
-
         return false;
     }
 
@@ -317,14 +314,14 @@ static ClassName getDelegateTypeName(Key key) {
 
         StringBuilder sb = new StringBuilder();
         if (qualifier.isPresent()) {
-            sb.append(capitalize(simpleQualifierName));
-            if (!simpleQualifierValue.isEmpty()) {
-                sb.append(capitalize(simpleQualifierValue));
+            sb.append(capitalize(simpleQualifierName).trim());
+            if (!simpleQualifierValue.trim().isEmpty()) {
+                sb.append(capitalize(simpleQualifierValue).trim());
             }else {
-                sb.append(capitalize(extractClassName(typeToString(returnType))));
+                sb.append(capitalize(extractClassName(typeToString(returnType))).trim());
             }
         }else {
-            sb.append(capitalize(extractClassName(typeToString(returnType))));
+            sb.append(capitalize(extractClassName(typeToString(returnType))).trim());
         }
 
         final ClassName name = ClassName.bestGuess(String.format("delegates.%sDelegate", sb.toString()));
@@ -372,6 +369,8 @@ static String getDelegateFieldName(Key key) {
             sb.append(lowerCaseFirstLetter(extractClassName(typeToString(returnType))));
         }
 
+        sb.append("Delegate");
+
         return sb.toString();
     }
 
@@ -621,7 +620,7 @@ public static ClassName getDaggerComponentClassName(Element component) {
 
     public static final String METHOD_NAME_GET_INJECTOR = "getInjector";
     public static final ClassName TYPENAME_INJECTOR = ClassName.bestGuess("injector.Injector");
-    public static final String SIMPLE_NAME_INJECTOR_APPLICATION = "DaggerApplication";
+    public static final String SIMPLE_NAME_INJECTOR_APPLICATION = "DaggerHookApplication";
     public static final String FIELDNAME_INJECTOR = "injector";
     public static final ClassName TYPENAME_INJECTOR_SPEC = ClassName.bestGuess("injector.InjectorSpec");
     public static final ClassName TYPENAME_ANDROID_APPLICATION = ClassName.bestGuess("android.app.Application");
diff --git a/compiler/src/main/java/dagger/internal/codegen/ValidationType.java b/compiler/src/main/java/dagger/internal/codegen/ValidationType.java
index eb9f27109..5d19dc17a 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ValidationType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ValidationType.java
@@ -1,18 +1,18 @@
 /*
-* Copyright (C) 2015 The Dagger Authors.
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 
 package dagger.internal.codegen;
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/package-info.java b/compiler/src/main/java/dagger/internal/codegen/package-info.java
index 0490adb8a..a80cc02be 100644
--- a/compiler/src/main/java/dagger/internal/codegen/package-info.java
+++ b/compiler/src/main/java/dagger/internal/codegen/package-info.java
@@ -13,6 +13,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 @CheckReturnValue
 package dagger.internal.codegen;
 
diff --git a/core/src/main/java/dagger/internal/doc-files/ReferenceReleasingProvider-statemachine.png b/compiler/src/main/java/dagger/internal/doc-files/ReferenceReleasingProvider-statemachine.png
similarity index 100%
rename from core/src/main/java/dagger/internal/doc-files/ReferenceReleasingProvider-statemachine.png
rename to compiler/src/main/java/dagger/internal/doc-files/ReferenceReleasingProvider-statemachine.png
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
deleted file mode 100644
index 9a2343ad9..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentBuilderTest.java
+++ /dev/null
@@ -1,961 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-
-import com.google.common.collect.ImmutableList;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-/** Tests for {@link dagger.Component.Builder} */
-@RunWith(JUnit4.class)
-public class ComponentBuilderTest {
-
-  private static final ErrorMessages.ComponentBuilderMessages MSGS =
-      ErrorMessages.ComponentBuilderMessages.INSTANCE;
-
-  @Test
-  public void testEmptyBuilder() {
-    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class SomeInjectableType {",
-        "  @Inject SomeInjectableType() {}",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  SomeInjectableType someInjectableType();",
-        "",
-        "  @Component.Builder",
-        "  static interface Builder {",
-        "     SimpleComponent build();",
-        "  }",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerSimpleComponent",
-            "package test;",
-            "",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerSimpleComponent implements SimpleComponent {",
-            "  private DaggerSimpleComponent(Builder builder) {",
-            "    assert builder != null;",
-            "  }",
-            "",
-            "  public static SimpleComponent.Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static SimpleComponent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public SomeInjectableType someInjectableType() {",
-            "    return new SomeInjectableType();",
-            "  }",
-            "",
-            "  private static final class Builder implements SimpleComponent.Builder {",
-            "    @Override",
-            "    public SimpleComponent build() {",
-            "      return new DaggerSimpleComponent(this);",
-            "    }",
-            "  }",
-            "}");
-    assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
-  }
-
-  @Test
-  public void testUsesBuildAndSetterNames() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides String string() { return null; }",
-        "}");
-
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = TestModule.class)",
-        "interface TestComponent {",
-        "  String string();",
-        "",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    Builder setTestModule(TestModule testModule);",
-        "    TestComponent create();",
-        "  }",
-        "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.Preconditions;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<String> stringProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static TestComponent.Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().create();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.stringProvider = TestModule_StringFactory.create(builder.testModule);",
-        "  }",
-        "",
-        "  @Override",
-        "  public String string() {",
-        "    return stringProvider.get();",
-        "  }",
-        "",
-        "  private static final class Builder implements TestComponent.Builder {",
-        "    private TestModule testModule;",
-        "",
-        "    @Override",
-        "    public TestComponent create() {",
-        "      if (testModule == null) {",
-        "        this.testModule = new TestModule();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    @Override",
-        "    public Builder setTestModule(TestModule testModule) {",
-        "      this.testModule = Preconditions.checkNotNull(testModule);",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
-  }
-
-  @Test
-  public void testIgnoresModulesNotInApi() {
-    JavaFileObject module1 = JavaFileObjects.forSourceLines("test.TestModule1",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule1 {",
-        "  @Provides String string() { return null; }",
-        "}");
-    JavaFileObject module2 = JavaFileObjects.forSourceLines("test.TestModule2",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule2 {",
-        "  @Provides Integer integer() { return null; }",
-        "}");
-
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = {TestModule1.class, TestModule2.class})",
-        "interface TestComponent {",
-        "  String string();",
-        "  Integer integer();",
-        "",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    Builder testModule1(TestModule1 testModule1);",
-        "    TestComponent build();",
-        "  }",
-        "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.Preconditions;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<String> stringProvider;",
-        "  private Provider<Integer> integerProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static TestComponent.Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.stringProvider = TestModule1_StringFactory.create(builder.testModule1);",
-        "    this.integerProvider = TestModule2_IntegerFactory.create(builder.testModule2);",
-        "  }",
-        "",
-        "  @Override",
-        "  public String string() {",
-        "    return stringProvider.get();",
-        "  }",
-        "",
-        "  @Override",
-        "  public Integer integer() {",
-        "    return integerProvider.get();",
-        "  }",
-        "",
-        "  private static final class Builder implements TestComponent.Builder {",
-        "    private TestModule1 testModule1;",
-        "    private TestModule2 testModule2;",
-        "",
-        "    @Override",
-        "    public TestComponent build() {",
-        "      if (testModule1 == null) {",
-        "        this.testModule1 = new TestModule1();",
-        "      }",
-        "      if (testModule2 == null) {",
-        "        this.testModule2 = new TestModule2();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    @Override",
-        "    public Builder testModule1(TestModule1 testModule1) {",
-        "      this.testModule1 = Preconditions.checkNotNull(testModule1);",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(module1, module2, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
-  }
-
-  @Test
-  public void testMoreThanOneBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  @Component.Builder",
-        "  static interface Builder {",
-        "     SimpleComponent build();",
-        "  }",
-        "",
-        "  @Component.Builder",
-        "  interface Builder2 {",
-        "     SimpleComponent build();",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(MSGS.moreThanOne(),
-            "[test.SimpleComponent.Builder, test.SimpleComponent.Builder2]"))
-        .in(componentFile);
-  }
-
-  @Test
-  public void testBuilderGenericsFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder<T> {",
-        "     SimpleComponent build();",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.generics())
-        .in(componentFile);
-  }
-
-  @Test
-  public void testBuilderNotInComponentFails() {
-    JavaFileObject builder = JavaFileObjects.forSourceLines("test.Builder",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component.Builder",
-        "interface Builder {}");
-    assertAbout(javaSource()).that(builder)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.mustBeInComponent())
-        .in(builder);
-  }
-
-  @Test
-  public void testBuilderMissingBuildMethodFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.missingBuildMethod())
-        .in(componentFile);
-  }
-
-  @Test
-  public void testPrivateBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  private interface Builder {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.isPrivate())
-        .in(componentFile);
-  }
-
-  @Test
-  public void testNonStaticBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  abstract class Builder {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.mustBeStatic())
-        .in(componentFile);
-  }
-
-  @Test
-  public void testNonAbstractBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  static class Builder {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.mustBeAbstract());
-  }
-
-  @Test
-  public void testBuilderOneCxtorWithArgsFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  static abstract class Builder {",
-        "    Builder(String unused) {}",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
-        .in(componentFile);
-  }
-
-  @Test
-  public void testBuilderMoreThanOneCxtorFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  static abstract class Builder {",
-        "    Builder() {}",
-        "    Builder(String unused) {}",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
-        .in(componentFile);
-  }
-
-  @Test
-  public void testBuilderEnumFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  enum Builder {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.mustBeClassOrInterface())
-        .in(componentFile);
-  }
-
-  @Test
-  public void testBuilderBuildReturnsWrongTypeFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    String build();",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.buildMustReturnComponentType())
-            .in(componentFile).onLine(10);
-  }
-
-  @Test
-  public void testInheritedBuilderBuildReturnsWrongTypeFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  interface Parent {",
-        "    String build();",
-        "  }",
-        "",
-        "  @Component.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
-            .in(componentFile).onLine(13);
-  }
-
-  @Test
-  public void testTwoBuildMethodsFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    SimpleComponent build();",
-        "    SimpleComponent create();",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(MSGS.twoBuildMethods(), "build()"))
-            .in(componentFile).onLine(11);
-  }
-
-  @Test
-  public void testInheritedTwoBuildMethodsFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  interface Parent {",
-        "    SimpleComponent build();",
-        "    SimpleComponent create();",
-        "  }",
-        "",
-        "  @Component.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.inheritedTwoBuildMethods(), "create()", "build()"))
-            .in(componentFile).onLine(14);
-  }
-
-  @Test
-  public void testMoreThanOneArgFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    SimpleComponent build();",
-        "    Builder set(String s, Integer i);",
-        "    Builder set(Number n, Double d);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.methodsMustTakeOneArg())
-            .in(componentFile).onLine(11)
-        .and().withErrorContaining(MSGS.methodsMustTakeOneArg())
-            .in(componentFile).onLine(12);
-  }
-
-  @Test
-  public void testInheritedMoreThanOneArgFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  interface Parent {",
-        "    SimpleComponent build();",
-        "    Builder set1(String s, Integer i);",
-        "  }",
-        "",
-        "  @Component.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.inheritedMethodsMustTakeOneArg(),
-                "set1(java.lang.String,java.lang.Integer)"))
-            .in(componentFile).onLine(14);
-  }
-
-  @Test
-  public void testSetterReturningNonVoidOrBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    SimpleComponent build();",
-        "    String set(Integer i);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())
-            .in(componentFile).onLine(11);
-  }
-
-  @Test
-  public void testInheritedSetterReturningNonVoidOrBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  interface Parent {",
-        "    SimpleComponent build();",
-        "    String set(Integer i);",
-        "  }",
-        "",
-        "  @Component.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(),
-                "set(java.lang.Integer)"))
-            .in(componentFile).onLine(14);
-  }
-
-  @Test
-  public void testGenericsOnSetterMethodFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    SimpleComponent build();",
-        "    <T> Builder set(T t);",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.methodsMayNotHaveTypeParameters())
-            .in(componentFile).onLine(11);
-  }
-
-  @Test
-  public void testGenericsOnInheritedSetterMethodFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "abstract class SimpleComponent {",
-        "  interface Parent {",
-        "    SimpleComponent build();",
-        "    <T> Builder set(T t);",
-        "  }",
-        "",
-        "  @Component.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.inheritedMethodsMayNotHaveTypeParameters(), "<T>set(T)"))
-            .in(componentFile).onLine(14);
-  }
-
-  @Test
-  public void testMultipleSettersPerTypeFails() {
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "final class TestModule {",
-            "  @Provides String s() { return \"\"; }",
-            "}");
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Provider;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "abstract class SimpleComponent {",
-            "  abstract String s();",
-            "",
-            "  @Component.Builder",
-            "  interface Builder {",
-            "    SimpleComponent build();",
-            "    void set1(TestModule s);",
-            "    void set2(TestModule s);",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(
-                MSGS.manyMethodsForType(),
-                "test.TestModule",
-                "[set1(test.TestModule), set2(test.TestModule)]"))
-        .in(componentFile)
-        .onLine(11);
-  }
-
-  @Test
-  public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "final class TestModule {",
-            "  @Provides String s() { return \"\"; }",
-            "}");
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Provider;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "abstract class SimpleComponent {",
-            "  abstract String s();",
-            "",
-            "  interface Parent<T> {",
-            "    void set1(T t);",
-            "  }",
-            "",
-            "  @Component.Builder",
-            "  interface Builder extends Parent<TestModule> {",
-            "    SimpleComponent build();",
-            "    void set2(TestModule s);",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(
-                MSGS.manyMethodsForType(), "test.TestModule", "[set1(T), set2(test.TestModule)]"))
-        .in(componentFile)
-        .onLine(15);
-  }
-
-  @Test
-  public void testExtraSettersFails() {
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "import javax.inject.Provider;",
-            "",
-            "@Component(modules = AbstractModule.class)",
-            "abstract class SimpleComponent {",
-            "  @Component.Builder",
-            "  interface Builder {",
-            "    SimpleComponent build();",
-            "    void abstractModule(AbstractModule abstractModule);",
-            "    void other(String s);",
-            "  }",
-            "}");
-    JavaFileObject abstractModule =
-        JavaFileObjects.forSourceLines(
-            "test.AbstractModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "abstract class AbstractModule {}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(componentFile, abstractModule))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(
-                MSGS.extraSetters(),
-                "[void test.SimpleComponent.Builder.abstractModule(test.AbstractModule), "
-                    + "void test.SimpleComponent.Builder.other(String)]"))
-        .in(componentFile)
-        .onLine(10);
-  }
-
-  @Test
-  public void testMissingSettersFail() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  TestModule(String unused) {}",
-        "  @Provides String s() { return null; }",
-        "}");
-    JavaFileObject module2File = JavaFileObjects.forSourceLines("test.Test2Module",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class Test2Module {",
-        "  @Provides Integer i() { return null; }",
-        "}");
-    JavaFileObject module3File = JavaFileObjects.forSourceLines("test.Test3Module",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class Test3Module {",
-        "  Test3Module(String unused) {}",
-        "  @Provides Double d() { return null; }",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = {TestModule.class, Test2Module.class, Test3Module.class},",
-        "           dependencies = OtherComponent.class)",
-        "interface TestComponent {",
-        "  String string();",
-        "  Integer integer();",
-        "",
-        "  @Component.Builder",
-        "  interface Builder {",
-        "    TestComponent create();",
-        "  }",
-        "}");
-    JavaFileObject otherComponent = JavaFileObjects.forSourceLines("test.OtherComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "interface OtherComponent {}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, module2File, module3File, componentFile, otherComponent))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            // Ignores Test2Module because we can construct it ourselves.
-            // TODO(sameb): Ignore Test3Module because it's not used within transitive dependencies.
-            String.format(MSGS.missingSetters(),
-                "[test.TestModule, test.Test3Module, test.OtherComponent]"))
-            .in(componentFile).onLine(12);
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
deleted file mode 100644
index b095819e5..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ /dev/null
@@ -1,2918 +0,0 @@
-/*
- * Copyright (C) 2014 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.testing.compile.CompilationSubject.assertThat;
-import static com.google.testing.compile.Compiler.javac;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-
-import com.google.auto.common.MoreElements;
-import com.google.common.base.Joiner;
-import com.google.common.base.Predicate;
-import com.google.common.base.Predicates;
-import com.google.common.collect.ImmutableSet;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
-import com.google.testing.compile.Compilation;
-import com.google.testing.compile.Compiler;
-import com.google.testing.compile.JavaFileObjects;
-import com.squareup.javapoet.CodeBlock;
-import dagger.MembersInjector;
-import java.io.IOException;
-import java.io.Writer;
-import java.lang.annotation.Annotation;
-import java.util.Set;
-import javax.annotation.processing.AbstractProcessor;
-import javax.annotation.processing.ProcessingEnvironment;
-import javax.annotation.processing.Processor;
-import javax.annotation.processing.RoundEnvironment;
-import javax.inject.Inject;
-import javax.lang.model.SourceVersion;
-import javax.lang.model.element.Element;
-import javax.lang.model.element.TypeElement;
-import javax.tools.JavaFileObject;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class ComponentProcessorTest {
-  private static final CodeBlock NPE_LITERAL =
-      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
-
-  @Test public void componentOnConcreteClass() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "final class NotAComponent {}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("interface");
-  }
-
-  @Test public void componentOnEnum() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "enum NotAComponent {",
-        "  INSTANCE",
-        "}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("interface");
-  }
-
-  @Test public void componentOnAnnotation() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "@interface NotAComponent {}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("interface");
-  }
-
-  @Test public void nonModuleModule() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = Object.class)",
-        "interface NotAComponent {}");
-    Compilation compilation = daggerCompiler().compile(componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("is not annotated with @Module");
-  }
-
-  @Test
-  public void componentWithInvalidModule() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.BadModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "abstract class BadModule {",
-            "  @Binds abstract Object noParameters();",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.BadComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = BadModule.class)",
-            "interface BadComponent {",
-            "  Object object();",
-            "}");
-    Compilation compilation = daggerCompiler().compile(module, component);
-    assertThat(compilation)
-        .hadErrorContaining("test.BadModule has errors")
-        .inFile(component)
-        .onLine(5);
-  }
-
-  @Test public void doubleBindingFromResolvedModules() {
-    JavaFileObject parent = JavaFileObjects.forSourceLines("test.ParentModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import java.util.List;",
-        "",
-        "@Module",
-        "abstract class ParentModule<A> {",
-        "  @Provides List<A> provideListB(A a) { return null; }",
-        "}");
-    JavaFileObject child = JavaFileObjects.forSourceLines("test.ChildModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "class ChildNumberModule extends ParentModule<Integer> {",
-        "  @Provides Integer provideInteger() { return null; }",
-        "}");
-    JavaFileObject another = JavaFileObjects.forSourceLines("test.AnotherModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import java.util.List;",
-        "",
-        "@Module",
-        "class AnotherModule {",
-        "  @Provides List<Integer> provideListOfInteger() { return null; }",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.BadComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import java.util.List;",
-        "",
-        "@Component(modules = {ChildNumberModule.class, AnotherModule.class})",
-        "interface BadComponent {",
-        "  List<Integer> listOfInteger();",
-        "}");
-
-    Compilation compilation = daggerCompiler().compile(parent, child, another, componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("java.util.List<java.lang.Integer> is bound multiple times");
-    assertThat(compilation)
-        .hadErrorContaining("@Provides List<Integer> test.ChildNumberModule.provideListB(Integer)");
-    assertThat(compilation)
-        .hadErrorContaining("@Provides List<Integer> test.AnotherModule.provideListOfInteger()");
-  }
-
-  @Test public void privateNestedClassWithWarningThatIsAnErrorInComponent() {
-    JavaFileObject outerClass = JavaFileObjects.forSourceLines("test.OuterClass",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class OuterClass {",
-        "  @Inject OuterClass(InnerClass innerClass) {}",
-        "",
-        "  private static final class InnerClass {",
-        "    @Inject InnerClass() {}",
-        "  }",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.BadComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "interface BadComponent {",
-        "  OuterClass outerClass();",
-        "}");
-    Compilation compilation =
-        daggerCompiler()
-            .withOptions("-Adagger.privateMemberValidation=WARNING")
-            .compile(outerClass, componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("Dagger does not support injection into private classes");
-  }
-
-  @Test public void simpleComponent() {
-    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class SomeInjectableType {",
-        "  @Inject SomeInjectableType() {}",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Lazy;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  SomeInjectableType someInjectableType();",
-        "  Lazy<SomeInjectableType> lazySomeInjectableType();",
-        "  Provider<SomeInjectableType> someInjectableTypeProvider();",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerSimpleComponent",
-            "package test;",
-            "",
-            "import dagger.Lazy;",
-            "import dagger.internal.DoubleCheck;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerSimpleComponent implements SimpleComponent {",
-            "  private DaggerSimpleComponent(Builder builder) {",
-            "    assert builder != null;",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static SimpleComponent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public SomeInjectableType someInjectableType() {",
-            "    return new SomeInjectableType();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
-            "    return DoubleCheck.lazy(SomeInjectableType_Factory.create());",
-            "  }",
-            "",
-            "  @Override",
-            "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
-            "    return SomeInjectableType_Factory.create();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public SimpleComponent build() {",
-            "      return new DaggerSimpleComponent(this);",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(injectableTypeFile, componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerSimpleComponent")
-        .hasSourceEquivalentTo(generatedComponent);
-  }
-
-  @Test public void componentWithScope() {
-    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Singleton",
-        "final class SomeInjectableType {",
-        "  @Inject SomeInjectableType() {}",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Lazy;",
-        "import javax.inject.Provider;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Singleton",
-        "@Component",
-        "interface SimpleComponent {",
-        "  SomeInjectableType someInjectableType();",
-        "  Lazy<SomeInjectableType> lazySomeInjectableType();",
-        "  Provider<SomeInjectableType> someInjectableTypeProvider();",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerSimpleComponent",
-            "package test;",
-            "",
-            "import dagger.Lazy;",
-            "import dagger.internal.DoubleCheck;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerSimpleComponent implements SimpleComponent {",
-            "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
-            "",
-            "  private DaggerSimpleComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static SimpleComponent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.someInjectableTypeProvider =",
-            "        DoubleCheck.provider(SomeInjectableType_Factory.create());",
-            "  }",
-            "",
-            "  @Override",
-            "  public SomeInjectableType someInjectableType() {",
-            "    return someInjectableTypeProvider.get();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
-            "    return DoubleCheck.lazy(someInjectableTypeProvider);",
-            "  }",
-            "",
-            "  @Override",
-            "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
-            "    return someInjectableTypeProvider;",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public SimpleComponent build() {",
-            "      return new DaggerSimpleComponent(this);",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(injectableTypeFile, componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerSimpleComponent")
-        .hasSourceEquivalentTo(generatedComponent);
-  }
-
-  @Test public void simpleComponentWithNesting() {
-    JavaFileObject nestedTypesFile = JavaFileObjects.forSourceLines("test.OuterType",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Inject;",
-        "",
-        "final class OuterType {",
-        "  static class A {",
-        "    @Inject A() {}",
-        "  }",
-        "  static class B {",
-        "    @Inject A a;",
-        "  }",
-        "  @Component interface SimpleComponent {",
-        "    A a();",
-        "    void inject(B b);",
-        "  }",
-        "}");
-
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerOuterType_SimpleComponent",
-            "package test;",
-            "",
-            "import dagger.MembersInjector;",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerOuterType_SimpleComponent",
-            "    implements OuterType.SimpleComponent {",
-            "  private MembersInjector<OuterType.B> bMembersInjector;",
-            "",
-            "  private DaggerOuterType_SimpleComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static OuterType.SimpleComponent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.bMembersInjector =",
-            "        OuterType_B_MembersInjector.create(OuterType_A_Factory.create());",
-            "  }",
-            "",
-            "  @Override",
-            "  public OuterType.A a() {",
-            "    return new OuterType.A();",
-            "  }",
-            "",
-            "  @Override",
-            "  public void inject(OuterType.B b) {",
-            "    bMembersInjector.injectMembers(b);",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public OuterType.SimpleComponent build() {",
-            "      return new DaggerOuterType_SimpleComponent(this);",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(nestedTypesFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerOuterType_SimpleComponent")
-        .hasSourceEquivalentTo(generatedComponent);
-  }
-
-  @Test public void componentWithModule() {
-    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class A {",
-        "  @Inject A(B b) {}",
-        "}");
-    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
-        "package test;",
-        "",
-        "interface B {}");
-    JavaFileObject cFile = JavaFileObjects.forSourceLines("test.C",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class C {",
-        "  @Inject C() {}",
-        "}");
-
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides B b(C c) { return null; }",
-        "}");
-
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component(modules = TestModule.class)",
-        "interface TestComponent {",
-        "  A a();",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<B> bProvider;",
-            "  private Provider<A> aProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.bProvider = TestModule_BFactory.create(builder.testModule,",
-            "        C_Factory.create());",
-            "    this.aProvider = A_Factory.create(bProvider);",
-            "  }",
-            "",
-            "  @Override",
-            "  public A a() {",
-            "    return new A(bProvider.get());",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private TestModule testModule;",
-            "",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      if (testModule == null) {",
-            "        this.testModule = new TestModule();",
-            "      }",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "",
-            "    public Builder testModule(TestModule testModule) {",
-            "      this.testModule = Preconditions.checkNotNull(testModule);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler().compile(aFile, bFile, cFile, moduleFile, componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerTestComponent")
-        .hasSourceEquivalentTo(generatedComponent);
-  }
-
-  @Test
-  public void componentWithAbstractModule() {
-    JavaFileObject aFile =
-        JavaFileObjects.forSourceLines(
-            "test.A",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "final class A {",
-            "  @Inject A(B b) {}",
-            "}");
-    JavaFileObject bFile =
-        JavaFileObjects.forSourceLines("test.B",
-            "package test;",
-            "",
-            "interface B {}");
-    JavaFileObject cFile =
-        JavaFileObjects.forSourceLines(
-            "test.C",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "final class C {",
-            "  @Inject C() {}",
-            "}");
-
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "abstract class TestModule {",
-            "  @Provides static B b(C c) { return null; }",
-            "}");
-
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Provider;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  A a();",
-            "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<B> bProvider;",
-            "  private Provider<A> aProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.bProvider = TestModule_BFactory.create(C_Factory.create());",
-            "    this.aProvider = A_Factory.create(bProvider);",
-            "  }",
-            "",
-            "  @Override",
-            "  public A a() {",
-            "    return new A(TestModule.b(new C()));",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler().compile(aFile, bFile, cFile, moduleFile, componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerTestComponent")
-        .hasSourceEquivalentTo(generatedComponent);
-  }
-
-  @Test public void transitiveModuleDeps() {
-    JavaFileObject always = JavaFileObjects.forSourceLines("test.AlwaysIncluded",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "",
-        "@Module",
-        "final class AlwaysIncluded {}");
-    JavaFileObject testModule = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "",
-        "@Module(includes = {DepModule.class, AlwaysIncluded.class})",
-        "final class TestModule extends ParentTestModule {}");
-    JavaFileObject parentTest = JavaFileObjects.forSourceLines("test.ParentTestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "",
-        "@Module(includes = {ParentTestIncluded.class, AlwaysIncluded.class})",
-        "class ParentTestModule {}");
-    JavaFileObject parentTestIncluded = JavaFileObjects.forSourceLines("test.ParentTestIncluded",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "",
-        "@Module(includes = AlwaysIncluded.class)",
-        "final class ParentTestIncluded {}");
-    JavaFileObject depModule = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "",
-        "@Module(includes = {RefByDep.class, AlwaysIncluded.class})",
-        "final class DepModule extends ParentDepModule {}");
-    JavaFileObject refByDep = JavaFileObjects.forSourceLines("test.RefByDep",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "",
-        "@Module(includes = AlwaysIncluded.class)",
-        "final class RefByDep extends ParentDepModule {}");
-    JavaFileObject parentDep = JavaFileObjects.forSourceLines("test.ParentDepModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "",
-        "@Module(includes = {ParentDepIncluded.class, AlwaysIncluded.class})",
-        "class ParentDepModule {}");
-    JavaFileObject parentDepIncluded = JavaFileObjects.forSourceLines("test.ParentDepIncluded",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "",
-        "@Module(includes = AlwaysIncluded.class)",
-        "final class ParentDepIncluded {}");
-
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component(modules = TestModule.class)",
-        "interface TestComponent {",
-        "}");
-    // Generated code includes all includes, but excludes the parent modules.
-    // The "always" module should only be listed once.
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.Preconditions;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    @Deprecated",
-        "    public Builder testModule(TestModule testModule) {",
-        "      Preconditions.checkNotNull(testModule)",
-        "      return this;",
-        "    }",
-        "",
-        "    @Deprecated",
-        "    public Builder parentTestIncluded(ParentTestIncluded parentTestIncluded) {",
-        "      Preconditions.checkNotNull(parentTestIncluded)",
-        "      return this;",
-        "    }",
-        "",
-        "    @Deprecated",
-        "    public Builder alwaysIncluded(AlwaysIncluded alwaysIncluded) {",
-        "      Preconditions.checkNotNull(alwaysIncluded)",
-        "      return this;",
-        "    }",
-        "",
-        "    @Deprecated",
-        "    public Builder depModule(DepModule depModule) {",
-        "      Preconditions.checkNotNull(depModule)",
-        "      return this;",
-        "    }",
-        "",
-        "    @Deprecated",
-        "    public Builder parentDepIncluded(ParentDepIncluded parentDepIncluded) {",
-        "      Preconditions.checkNotNull(parentDepIncluded)",
-        "      return this;",
-        "    }",
-        "",
-        "    @Deprecated",
-        "    public Builder refByDep(RefByDep refByDep) {",
-        "      Preconditions.checkNotNull(refByDep)",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
-    Compilation compilation =
-        daggerCompiler()
-            .compile(
-                always,
-                testModule,
-                parentTest,
-                parentTestIncluded,
-                depModule,
-                refByDep,
-                parentDep,
-                parentDepIncluded,
-                componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerTestComponent")
-        .hasSourceEquivalentTo(generatedComponent);
-  }
-
-  @Test
-  public void generatedTransitiveModule() {
-    JavaFileObject rootModule = JavaFileObjects.forSourceLines("test.RootModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "",
-        "@Module(includes = GeneratedModule.class)",
-        "final class RootModule {}");
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = RootModule.class)",
-        "interface TestComponent {}");
-    assertThat(daggerCompiler().compile(rootModule, component)).failed();
-    assertThat(
-            daggerCompiler(
-                    new GeneratingProcessor(
-                        "test.GeneratedModule",
-                        "package test;",
-                        "",
-                        "import dagger.Module;",
-                        "",
-                        "@Module",
-                        "final class GeneratedModule {}"))
-                .compile(rootModule, component))
-        .succeeded();
-  }
-
-  @Test
-  public void generatedModuleInSubcomponent() {
-    JavaFileObject subcomponent =
-        JavaFileObjects.forSourceLines(
-            "test.ChildComponent",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = GeneratedModule.class)",
-            "interface ChildComponent {}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface TestComponent {",
-            "  ChildComponent childComponent();",
-            "}");
-    assertThat(daggerCompiler().compile(subcomponent, component)).failed();
-    assertThat(
-            daggerCompiler(
-                    new GeneratingProcessor(
-                        "test.GeneratedModule",
-                        "package test;",
-                        "",
-                        "import dagger.Module;",
-                        "",
-                        "@Module",
-                        "final class GeneratedModule {}"))
-                .compile(subcomponent, component))
-        .succeeded();
-  }
-
-  @Test
-  public void subcomponentOmitsInheritedBindings() {
-    JavaFileObject parent =
-        JavaFileObjects.forSourceLines(
-            "test.Parent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = ParentModule.class)",
-            "interface Parent {",
-            "  Child child();",
-            "}");
-    JavaFileObject parentModule =
-        JavaFileObjects.forSourceLines(
-            "test.ParentModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.StringKey;",
-            "",
-            "@Module",
-            "class ParentModule {",
-            "  @Provides @IntoSet static Object parentObject() {",
-            "    return \"parent object\";",
-            "  }",
-            "",
-            "  @Provides @IntoMap @StringKey(\"parent key\") Object parentKeyObject() {",
-            "    return \"parent value\";",
-            "  }",
-            "}");
-    JavaFileObject child =
-        JavaFileObjects.forSourceLines(
-            "test.Child",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "import java.util.Map;",
-            "import java.util.Set;",
-            "",
-            "@Subcomponent",
-            "interface Child {",
-            "  Set<Object> objectSet();",
-            "  Map<String, Object> objectMap();",
-            "}");
-    JavaFileObject expected =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerParent",
-            "package test;",
-            "",
-            "import dagger.internal.MapFactory;",
-            "import dagger.internal.MapProviderFactory;",
-            "import dagger.internal.Preconditions;",
-            "import dagger.internal.SetFactory;",
-            "import java.util.Map;",
-            "import java.util.Set;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerParent implements Parent {",
-            "  private Provider<Object> parentKeyObjectProvider;",
-            "",
-            "  private DaggerParent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static Parent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.parentKeyObjectProvider =",
-            "        ParentModule_ParentKeyObjectFactory.create(builder.parentModule);",
-            "  }",
-            "",
-            "  @Override",
-            "  public Child child() {",
-            "    return new ChildImpl();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private ParentModule parentModule;",
-            "",
-            "    private Builder() {}",
-            "",
-            "    public Parent build() {",
-            "      if (parentModule == null) {",
-            "        this.parentModule = new ParentModule();",
-            "      }",
-            "      return new DaggerParent(this);",
-            "    }",
-            "",
-            "    public Builder parentModule(ParentModule parentModule) {",
-            "      this.parentModule = Preconditions.checkNotNull(parentModule);",
-            "      return this;",
-            "    }",
-            "  }",
-            "",
-            "  private final class ChildImpl implements Child {",
-            "    private Provider<Set<Object>> setOfObjectProvider;",
-            "    private Provider<Map<String, Provider<Object>>>",
-            "        mapOfStringAndProviderOfObjectProvider;",
-            "    private Provider<Map<String, Object>> mapOfStringAndObjectProvider;",
-            "",
-            "    private ChildImpl() {",
-            "      initialize();",
-            "    }",
-            "",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize() {",
-            "      this.setOfObjectProvider = SetFactory.<Object>builder(1, 0)",
-            "          .addProvider(ParentModule_ParentObjectFactory.create()).build();",
-            "      this.mapOfStringAndProviderOfObjectProvider =",
-            "          MapProviderFactory.<String, Object>builder(1)",
-            "              .put(\"parent key\", DaggerParent.this.parentKeyObjectProvider)",
-            "              .build();",
-            "      this.mapOfStringAndObjectProvider = MapFactory.create(",
-            "          mapOfStringAndProviderOfObjectProvider);",
-            "    }",
-            "",
-            "    @Override",
-            "    public Set<Object> objectSet() {",
-            "      return setOfObjectProvider.get();",
-            "    }",
-            "",
-            "    @Override",
-            "    public Map<String, Object> objectMap() {",
-            "      return mapOfStringAndObjectProvider.get();",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(parent, parentModule, child);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerParent")
-        .hasSourceEquivalentTo(expected);
-  }
-
-  @Test
-  public void subcomponentNotGeneratedIfNotUsedInGraph() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Parent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = ParentModule.class)",
-            "interface Parent {",
-            "  String notSubcomponent();",
-            "}");
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.Parent",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module(subcomponents = Child.class)",
-            "class ParentModule {",
-            "  @Provides static String notSubcomponent() { return new String(); }",
-            "}");
-
-    JavaFileObject subcomponent =
-        JavaFileObjects.forSourceLines(
-            "test.Child",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Child {",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    Child build();",
-            "  }",
-            "}");
-
-    JavaFileObject generatedComponentWithoutSubcomponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerParent",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerParent implements Parent {",
-            "",
-            "  private DaggerParent(Builder builder) {",
-            "    assert builder != null;",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static Parent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public String notSubcomponent() {",
-            "    return ParentModule.notSubcomponent();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public Parent build() {",
-            "      return new DaggerParent(this);",
-            "    }",
-            "",
-            "    @Deprecated",
-            "    public Builder parentModule(ParentModule parentModule) {",
-            "      Preconditions.checkNotNull(parentModule);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
-
-    Compilation compilation = daggerCompiler().compile(component, module, subcomponent);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerParent")
-        .hasSourceEquivalentTo(generatedComponentWithoutSubcomponent);
-  }
-
-  @Test
-  public void testDefaultPackage() {
-    JavaFileObject aClass = JavaFileObjects.forSourceLines("AClass", "class AClass {}");
-    JavaFileObject bClass = JavaFileObjects.forSourceLines("BClass",
-        "import javax.inject.Inject;",
-        "",
-        "class BClass {",
-        "  @Inject BClass(AClass a) {}",
-        "}");
-    JavaFileObject aModule = JavaFileObjects.forSourceLines("AModule",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module class AModule {",
-        "  @Provides AClass aClass() {",
-        "    return new AClass();",
-        "  }",
-        "}");
-    JavaFileObject component = JavaFileObjects.forSourceLines("SomeComponent",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = AModule.class)",
-        "interface SomeComponent {",
-        "  BClass bClass();",
-        "}");
-    assertThat(daggerCompiler().compile(aModule, aClass, bClass, component)).succeeded();
-  }
-
-  @Test public void setBindings() {
-    JavaFileObject emptySetModuleFile = JavaFileObjects.forSourceLines("test.EmptySetModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.multibindings.ElementsIntoSet;",
-        "import java.util.Collections;",
-        "import java.util.Set;",
-        "",
-        "@Module",
-        "final class EmptySetModule {",
-        "  @Provides @ElementsIntoSet Set<String> emptySet() { return Collections.emptySet(); }",
-        "}");
-    JavaFileObject setModuleFile = JavaFileObjects.forSourceLines("test.SetModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.multibindings.IntoSet;",
-        "",
-        "@Module",
-        "final class SetModule {",
-        "  @Provides @IntoSet String string() { return \"\"; }",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import java.util.Set;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component(modules = {EmptySetModule.class, SetModule.class})",
-        "interface TestComponent {",
-        "  Set<String> strings();",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            "import dagger.internal.SetFactory;",
-            "import java.util.Set;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<Set<String>> emptySetProvider;",
-            "  private Provider<String> stringProvider;",
-            "  private Provider<Set<String>> setOfStringProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.emptySetProvider =",
-            "        EmptySetModule_EmptySetFactory.create(builder.emptySetModule);",
-            "    this.stringProvider =",
-            "        SetModule_StringFactory.create(builder.setModule);",
-            "    this.setOfStringProvider = ",
-            "        SetFactory.<String>builder(1, 1)",
-            "            .addCollectionProvider(emptySetProvider)",
-            "            .addProvider(stringProvider)",
-            "            .build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Set<String> strings() {",
-            "    return setOfStringProvider.get();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private EmptySetModule emptySetModule;",
-            "    private SetModule setModule;",
-            "",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      if (emptySetModule == null) {",
-            "        this.emptySetModule = new EmptySetModule();",
-            "      }",
-            "      if (setModule == null) {",
-            "        this.setModule = new SetModule();",
-            "      }",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "",
-            "    public Builder emptySetModule(EmptySetModule emptySetModule) {",
-            "      this.emptySetModule = Preconditions.checkNotNull(emptySetModule);",
-            "      return this;",
-            "    }",
-            "",
-            "    public Builder setModule(SetModule setModule) {",
-            "      this.setModule = Preconditions.checkNotNull(setModule);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler().compile(emptySetModuleFile, setModuleFile, componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerTestComponent")
-        .hasSourceEquivalentTo(generatedComponent);
-  }
-
-  @Test public void membersInjection() {
-    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class SomeInjectableType {",
-        "  @Inject SomeInjectableType() {}",
-        "}");
-    JavaFileObject injectedTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectedType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class SomeInjectedType {",
-        "  @Inject SomeInjectableType injectedField;",
-        "  SomeInjectedType() {}",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Lazy;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  void inject(SomeInjectedType instance);",
-        "  SomeInjectedType injectAndReturn(SomeInjectedType instance);",
-        "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerSimpleComponent",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import javax.annotation.Generated;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerSimpleComponent implements SimpleComponent {",
-        "  private MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
-        "",
-        "  private DaggerSimpleComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static SimpleComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.someInjectedTypeMembersInjector =",
-        "        SomeInjectedType_MembersInjector.create(SomeInjectableType_Factory.create());",
-        "  }",
-        "",
-        "  @Override",
-        "  public void inject(SomeInjectedType instance) {",
-        "    someInjectedTypeMembersInjector.injectMembers(instance);",
-        "  }",
-        "",
-        "  @Override",
-        "  public SomeInjectedType injectAndReturn(SomeInjectedType instance) {",
-        "    someInjectedTypeMembersInjector.injectMembers(instance);",
-        "    return instance;",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public SimpleComponent build() {",
-        "      return new DaggerSimpleComponent(this);",
-        "    }",
-        "  }",
-        "}");
-    Compilation compilation =
-        daggerCompiler().compile(injectableTypeFile, injectedTypeFile, componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerSimpleComponent")
-        .hasSourceEquivalentTo(generatedComponent);
-  }
-
-  @Test public void componentInjection() {
-    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class SomeInjectableType {",
-        "  @Inject SomeInjectableType(SimpleComponent component) {}",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Lazy;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  SomeInjectableType someInjectableType();",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerSimpleComponent",
-            "package test;",
-            "",
-            "import dagger.internal.InstanceFactory;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerSimpleComponent implements SimpleComponent {",
-            "  private Provider<SimpleComponent> simpleComponentProvider;",
-            "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
-            "",
-            "  private DaggerSimpleComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static SimpleComponent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
-            "    this.someInjectableTypeProvider =",
-            "        SomeInjectableType_Factory.create(simpleComponentProvider);",
-            "  }",
-            "",
-            "  @Override",
-            "  public SomeInjectableType someInjectableType() {",
-            "    return new SomeInjectableType(simpleComponentProvider.get())",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public SimpleComponent build() {",
-            "      return new DaggerSimpleComponent(this);",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(injectableTypeFile, componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerSimpleComponent")
-        .hasSourceEquivalentTo(generatedComponent);
-  }
-
-  @Test public void membersInjectionInsideProvision() {
-    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class SomeInjectableType {",
-        "  @Inject SomeInjectableType() {}",
-        "}");
-    JavaFileObject injectedTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectedType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class SomeInjectedType {",
-        "  @Inject SomeInjectableType injectedField;",
-        "  @Inject SomeInjectedType() {}",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  SomeInjectedType createAndInject();",
-        "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerSimpleComponent",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerSimpleComponent implements SimpleComponent {",
-        "  private MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
-        "  private Provider<SomeInjectedType> someInjectedTypeProvider;",
-        "",
-        "  private DaggerSimpleComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static SimpleComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.someInjectedTypeMembersInjector =",
-        "        SomeInjectedType_MembersInjector.create(SomeInjectableType_Factory.create());",
-        "    this.someInjectedTypeProvider =",
-        "        SomeInjectedType_Factory.create(someInjectedTypeMembersInjector);",
-        "  }",
-        "",
-        "  @Override",
-        "  public SomeInjectedType createAndInject() {",
-        "    return someInjectedTypeProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public SimpleComponent build() {",
-        "      return new DaggerSimpleComponent(this);",
-        "    }",
-        "  }",
-        "}");
-    Compilation compilation =
-        daggerCompiler().compile(injectableTypeFile, injectedTypeFile, componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerSimpleComponent")
-        .hasSourceEquivalentTo(generatedComponent);
-  }
-
-  @Test public void injectionWithGenericBaseClass() {
-    JavaFileObject genericType = JavaFileObjects.forSourceLines("test.AbstractGenericType",
-        "package test;",
-        "",
-        "abstract class AbstractGenericType<T> {",
-        "}");
-    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class SomeInjectableType extends AbstractGenericType<String> {",
-        "  @Inject SomeInjectableType() {}",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  SomeInjectableType someInjectableType();",
-        "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerSimpleComponent",
-        "package test;",
-        "",
-        "import dagger.internal.MembersInjectors;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerSimpleComponent implements SimpleComponent {",
-        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
-        "",
-        "  private DaggerSimpleComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static SimpleComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.someInjectableTypeProvider =",
-        "        SomeInjectableType_Factory.create(MembersInjectors.<SomeInjectableType>noOp());",
-        "  }",
-        "",
-        "  @Override",
-        "  public SomeInjectableType someInjectableType() {",
-        "    return someInjectableTypeProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public SimpleComponent build() {",
-        "      return new DaggerSimpleComponent(this);",
-        "    }",
-        "  }",
-        "}");
-    Compilation compilation =
-        daggerCompiler().compile(genericType, injectableTypeFile, componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerSimpleComponent")
-        .hasSourceEquivalentTo(generatedComponent);
-  }
-
-  @Test public void componentDependency() {
-    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class A {",
-        "  @Inject A() {}",
-        "}");
-    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class B {",
-        "  @Inject B(A a) {}",
-        "}");
-    JavaFileObject aComponentFile = JavaFileObjects.forSourceLines("test.AComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Lazy;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface AComponent {",
-        "  A a();",
-        "}");
-    JavaFileObject bComponentFile = JavaFileObjects.forSourceLines("test.AComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Lazy;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component(dependencies = AComponent.class)",
-        "interface BComponent {",
-        "  B b();",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerBComponent",
-            "package test;",
-            "",
-            "import dagger.internal.Factory;",
-            "import dagger.internal.Preconditions;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerBComponent implements BComponent {",
-            "  private Provider<A> aProvider;",
-            "  private Provider<B> bProvider;",
-            "",
-            "  private DaggerBComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.aProvider = new Factory<A>() {",
-            "      private final AComponent aComponent = builder.aComponent;",
-            "      @Override public A get() {",
-            "        return Preconditions.checkNotNull(aComponent.a(), " + NPE_LITERAL + ");",
-            "      }",
-            "    };",
-            "    this.bProvider = B_Factory.create(aProvider);",
-            "  }",
-            "",
-            "  @Override",
-            "  public B b() {",
-            "    return new B(aProvider.get());",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private AComponent aComponent;",
-            "",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public BComponent build() {",
-            "      if (aComponent == null) {",
-            "        throw new IllegalStateException(AComponent.class.getCanonicalName()",
-            "            + \" must be set\");",
-            "      }",
-            "      return new DaggerBComponent(this);",
-            "    }",
-            "",
-            "    public Builder aComponent(AComponent aComponent) {",
-            "      this.aComponent = Preconditions.checkNotNull(aComponent);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler().compile(aFile, bFile, aComponentFile, bComponentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerBComponent")
-        .hasSourceEquivalentTo(generatedComponent);
-  }
-
-  @Test public void moduleNameCollision() {
-    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
-        "",
-        "public final class A {}");
-    JavaFileObject otherAFile = JavaFileObjects.forSourceLines("other.test.A",
-        "package other.test;",
-        "",
-        "public final class A {}");
-
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "public final class TestModule {",
-        "  @Provides A a() { return null; }",
-        "}");
-    JavaFileObject otherModuleFile = JavaFileObjects.forSourceLines("other.test.TestModule",
-        "package other.test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "public final class TestModule {",
-        "  @Provides A a() { return null; }",
-        "}");
-
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component(modules = {TestModule.class, other.test.TestModule.class})",
-        "interface TestComponent {",
-        "  A a();",
-        "  other.test.A otherA();",
-        "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.Preconditions;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<A> aProvider;",
-        "  private Provider<other.test.A> aProvider2;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.aProvider = TestModule_AFactory.create(builder.testModule);",
-        "    this.aProvider2 = other.test.TestModule_AFactory.create(builder.testModule2);",
-        "  }",
-        "",
-        "  @Override",
-        "  public A a() {",
-        "    return aProvider.get();",
-        "  }",
-        "",
-        "  @Override",
-        "  public other.test.A otherA() {",
-        "    return aProvider2.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private TestModule testModule;",
-        "    private other.test.TestModule testModule2;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      if (testModule == null) {",
-        "        this.testModule = new TestModule();",
-        "      }",
-        "      if (testModule2 == null) {",
-        "        this.testModule2 = new other.test.TestModule();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    public Builder testModule(TestModule testModule) {",
-        "      this.testModule = Preconditions.checkNotNull(testModule);",
-        "      return this;",
-        "    }",
-        "",
-        "    public Builder testModule(other.test.TestModule testModule) {",
-        "      this.testModule2 = Preconditions.checkNotNull(testModule);",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
-    Compilation compilation =
-        daggerCompiler().compile(aFile, otherAFile, moduleFile, otherModuleFile, componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerTestComponent")
-        .hasSourceEquivalentTo(generatedComponent);
-  }
-
-  @Test public void resolutionOrder() {
-    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class A {",
-        "  @Inject A(B b) {}",
-        "}");
-    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class B {",
-        "  @Inject B(C c) {}",
-        "}");
-    JavaFileObject cFile = JavaFileObjects.forSourceLines("test.C",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class C {",
-        "  @Inject C() {}",
-        "}");
-    JavaFileObject xFile = JavaFileObjects.forSourceLines("test.X",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class X {",
-        "  @Inject X(C c) {}",
-        "}");
-
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface TestComponent {",
-        "  A a();",
-        "  C c();",
-        "  X x();",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<B> bProvider;",
-            "  private Provider<A> aProvider;",
-            "  private Provider<X> xProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.bProvider = B_Factory.create(C_Factory.create());",
-            "    this.aProvider = A_Factory.create(bProvider);",
-            "    this.xProvider = X_Factory.create(C_Factory.create());",
-            "  }",
-            "",
-            "  @Override",
-            "  public A a() {",
-            "    return new A(new B(new C()));",
-            "  }",
-            "",
-            "  @Override",
-            "  public C c() {",
-            "    return new C();",
-            "  }",
-            "",
-            "  @Override",
-            "  public X x() {",
-            "    return new X(new C());",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(aFile, bFile, cFile, xFile, componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerTestComponent")
-        .hasSourceEquivalentTo(generatedComponent);
-  }
-
-  @Test public void simpleComponent_redundantComponentMethod() {
-    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class SomeInjectableType {",
-        "  @Inject SomeInjectableType() {}",
-        "}");
-    JavaFileObject componentSupertypeAFile = JavaFileObjects.forSourceLines("test.SupertypeA",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Lazy;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SupertypeA {",
-        "  SomeInjectableType someInjectableType();",
-        "}");
-    JavaFileObject componentSupertypeBFile = JavaFileObjects.forSourceLines("test.SupertypeB",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Lazy;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SupertypeB {",
-        "  SomeInjectableType someInjectableType();",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Lazy;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent extends SupertypeA, SupertypeB {",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerSimpleComponent",
-            "package test;",
-            "",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerSimpleComponent implements SimpleComponent {",
-            "  private DaggerSimpleComponent(Builder builder) {",
-            "    assert builder != null;",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static SimpleComponent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public SomeInjectableType someInjectableType() {",
-            "    return new SomeInjectableType();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public SimpleComponent build() {",
-            "      return new DaggerSimpleComponent(this);",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler()
-            .compile(
-                injectableTypeFile,
-                componentSupertypeAFile,
-                componentSupertypeBFile,
-                componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerSimpleComponent")
-        .hasSourceEquivalentTo(generatedComponent);
-  }
-
-  @Test public void simpleComponent_inheritedComponentMethodDep() {
-    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class SomeInjectableType {",
-        "  @Inject SomeInjectableType() {}",
-        "}");
-    JavaFileObject componentSupertype = JavaFileObjects.forSourceLines("test.Supertype",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Lazy;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface Supertype {",
-        "  SomeInjectableType someInjectableType();",
-        "}");
-    JavaFileObject depComponentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Lazy;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent extends Supertype {",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ComponentWithDep",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Lazy;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component(dependencies = SimpleComponent.class)",
-        "interface ComponentWithDep {",
-        "  SomeInjectableType someInjectableType();",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerSimpleComponent",
-            "package test;",
-            "",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerSimpleComponent implements SimpleComponent {",
-            "  private DaggerSimpleComponent(Builder builder) {",
-            "    assert builder != null;",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static SimpleComponent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public SomeInjectableType someInjectableType() {",
-            "    return new SomeInjectableType();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public SimpleComponent build() {",
-            "      return new DaggerSimpleComponent(this);",
-            "    }",
-            "  }",
-            "}");
-    Compilation compilation =
-        daggerCompiler()
-            .compile(injectableTypeFile, componentSupertype, depComponentFile, componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerSimpleComponent")
-        .hasSourceEquivalentTo(generatedComponent);
-  }
-
-  @Test public void wildcardGenericsRequiresAtProvides() {
-    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class A {",
-        "  @Inject A() {}",
-        "}");
-    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "import javax.inject.Provider;",
-        "",
-        "final class B<T> {",
-        "  @Inject B(T t) {}",
-        "}");
-    JavaFileObject cFile = JavaFileObjects.forSourceLines("test.C",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "import javax.inject.Provider;",
-        "",
-        "final class C {",
-        "  @Inject C(B<? extends A> bA) {}",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Lazy;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  C c();",
-        "}");
-    Compilation compilation = daggerCompiler().compile(aFile, bFile, cFile, componentFile);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "test.B<? extends test.A> cannot be provided without an @Provides-annotated method");
-  }
-
-  @Test
-  public void componentImplicitlyDependsOnGeneratedType() {
-    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class SomeInjectableType {",
-        "  @Inject SomeInjectableType(GeneratedType generatedType) {}",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "interface SimpleComponent {",
-        "  SomeInjectableType someInjectableType();",
-        "}");
-    Compilation compilation =
-        daggerCompiler(
-                new GeneratingProcessor(
-                    "test.GeneratedType",
-                    "package test;",
-                    "",
-                    "import javax.inject.Inject;",
-                    "",
-                    "final class GeneratedType {",
-                    "  @Inject GeneratedType() {}",
-                    "}"))
-            .compile(injectableTypeFile, componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation).generatedSourceFile("test.DaggerSimpleComponent");
-  }
-
-  @Test
-  public void componentSupertypeDependsOnGeneratedType() {
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface SimpleComponent extends SimpleComponentInterface {}");
-    JavaFileObject interfaceFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleComponentInterface",
-            "package test;",
-            "",
-            "interface SimpleComponentInterface {",
-            "  GeneratedType generatedType();",
-            "}");
-    Compilation compilation =
-        daggerCompiler(
-                new GeneratingProcessor(
-                    "test.GeneratedType",
-                    "package test;",
-                    "",
-                    "import javax.inject.Inject;",
-                    "",
-                    "final class GeneratedType {",
-                    "  @Inject GeneratedType() {}",
-                    "}"))
-            .compile(componentFile, interfaceFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation).generatedSourceFile("test.DaggerSimpleComponent");
-  }
-
-  @Test
-  @Ignore // modify this test as necessary while debugging for your situation.
-  @SuppressWarnings("unused")
-  public void genericTestToLetMeDebugInEclipse() {
-    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
-        "",
-         "import javax.inject.Inject;",
-         "",
-         "public final class A {",
-         "  @Inject A() {}",
-         "}");
-     JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
-         "package test;",
-         "",
-         "import javax.inject.Inject;",
-         "import javax.inject.Provider;",
-         "",
-         "public class B<T> {",
-         "  @Inject B() {}",
-         "}");
-     JavaFileObject dFile = JavaFileObjects.forSourceLines("test.sub.D",
-         "package test.sub;",
-         "",
-         "import javax.inject.Inject;",
-         "import javax.inject.Provider;",
-         "import test.B;",
-         "",
-         "public class D {",
-         "  @Inject D(B<A.InA> ba) {}",
-         "}");
-     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
-         "package test;",
-         "",
-         "import dagger.Component;",
-         "import dagger.Lazy;",
-         "",
-         "import javax.inject.Provider;",
-         "",
-         "@Component",
-         "interface SimpleComponent {",
-         "  B<A> d();",
-         "  Provider<B<A>> d2();",
-         "}");
-     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-         "test.DaggerSimpleComponent",
-         "package test;",
-         "",
-         "import javax.annotation.Generated;",
-         "import javax.inject.Provider;",
-         "",
-         GENERATED_ANNOTATION,
-         "public final class DaggerSimpleComponent implements SimpleComponent {",
-         "  private Provider<D> dProvider;",
-         "",
-         "  private DaggerSimpleComponent(Builder builder) {",
-         "    assert builder != null;",
-         "    initialize(builder);",
-         "  }",
-         "",
-         "  public static Builder builder() {",
-         "    return new Builder();",
-         "  }",
-         "",
-         "  public static SimpleComponent create() {",
-         "    return builder().build();",
-         "  }",
-         "",
-         "  @SuppressWarnings(\"unchecked\")",
-         "  private void initialize(final Builder builder) {",
-         "    this.dProvider = new D_Factory(B_Factory.INSTANCE);",
-         "  }",
-         "",
-         "  @Override",
-         "  public D d() {",
-         "    return dProvider.get();",
-         "  }",
-         "",
-         "  public static final class Builder {",
-         "    private Builder() {",
-         "    }",
-         "",
-         "    public SimpleComponent build() {",
-         "      return new DaggerSimpleComponent(this);",
-         "    }",
-         "  }",
-         "}");
-    Compilation compilation = daggerCompiler().compile(aFile, bFile, componentFile);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerSimpleComponent")
-        .hasSourceEquivalentTo(generatedComponent);
-   }
-
-  /**
-   * We warn when generating a {@link MembersInjector} for a type post-hoc (i.e., if Dagger wasn't
-   * invoked when compiling the type). But Dagger only generates {@link MembersInjector}s for types
-   * with {@link Inject @Inject} constructors if they have any injection sites, and it only
-   * generates them for types without {@link Inject @Inject} constructors if they have local
-   * (non-inherited) injection sites. So make sure we warn in only those cases where running the
-   * Dagger processor actually generates a {@link MembersInjector}.
-   */
-  @Test
-  public void unprocessedMembersInjectorNotes() {
-    Compilation compilation =
-        javac()
-            .withOptions(
-                "-Xlint:-processing",
-                 "-Adagger.warnIfInjectionFactoryNotGeneratedUpstream=enabled")
-            .withProcessors(
-                new ElementFilteringComponentProcessor(
-                    Predicates.not(
-                        element ->
-                            MoreElements.getPackage(element)
-                                .getQualifiedName()
-                                .contentEquals("test.inject"))))
-            .compile(
-                JavaFileObjects.forSourceLines(
-                    "test.TestComponent",
-                    "package test;",
-                    "",
-                    "import dagger.Component;",
-                    "",
-                    "@Component(modules = TestModule.class)",
-                    "interface TestComponent {",
-                    "  void inject(test.inject.NoInjectMemberNoConstructor object);",
-                    "  void inject(test.inject.NoInjectMemberWithConstructor object);",
-                    "  void inject(test.inject.LocalInjectMemberNoConstructor object);",
-                    "  void inject(test.inject.LocalInjectMemberWithConstructor object);",
-                    "  void inject(test.inject.ParentInjectMemberNoConstructor object);",
-                    "  void inject(test.inject.ParentInjectMemberWithConstructor object);",
-                    "}"),
-                JavaFileObjects.forSourceLines(
-                    "test.TestModule",
-                    "package test;",
-                    "",
-                    "import dagger.Module;",
-                    "import dagger.Provides;",
-                    "",
-                    "@Module",
-                    "class TestModule {",
-                    "  @Provides static Object object() {",
-                    "    return \"object\";",
-                    "  }",
-                    "}"),
-                JavaFileObjects.forSourceLines(
-                    "test.inject.NoInjectMemberNoConstructor",
-                    "package test.inject;",
-                    "",
-                    "public class NoInjectMemberNoConstructor {",
-                    "}"),
-                JavaFileObjects.forSourceLines(
-                    "test.inject.NoInjectMemberWithConstructor",
-                    "package test.inject;",
-                    "",
-                    "import javax.inject.Inject;",
-                    "",
-                    "public class NoInjectMemberWithConstructor {",
-                    "  @Inject NoInjectMemberWithConstructor() {}",
-                    "}"),
-                JavaFileObjects.forSourceLines(
-                    "test.inject.LocalInjectMemberNoConstructor",
-                    "package test.inject;",
-                    "",
-                    "import javax.inject.Inject;",
-                    "",
-                    "public class LocalInjectMemberNoConstructor {",
-                    "  @Inject Object object;",
-                    "}"),
-                JavaFileObjects.forSourceLines(
-                    "test.inject.LocalInjectMemberWithConstructor",
-                    "package test.inject;",
-                    "",
-                    "import javax.inject.Inject;",
-                    "",
-                    "public class LocalInjectMemberWithConstructor {",
-                    "  @Inject LocalInjectMemberWithConstructor() {}",
-                    "  @Inject Object object;",
-                    "}"),
-                JavaFileObjects.forSourceLines(
-                    "test.inject.ParentInjectMemberNoConstructor",
-                    "package test.inject;",
-                    "",
-                    "import javax.inject.Inject;",
-                    "",
-                    "public class ParentInjectMemberNoConstructor",
-                    "    extends LocalInjectMemberNoConstructor {}"),
-                JavaFileObjects.forSourceLines(
-                    "test.inject.ParentInjectMemberWithConstructor",
-                    "package test.inject;",
-                    "",
-                    "import javax.inject.Inject;",
-                    "",
-                    "public class ParentInjectMemberWithConstructor",
-                    "    extends LocalInjectMemberNoConstructor {",
-                    "  @Inject ParentInjectMemberWithConstructor() {}",
-                    "}"));
-
-    assertThat(compilation).succeededWithoutWarnings();
-    assertThat(compilation)
-        .hadNoteContaining(
-            "Generating a MembersInjector for "
-                + "test.inject.LocalInjectMemberNoConstructor. "
-                + "Prefer to run the dagger processor over that class instead.");
-    assertThat(compilation)
-        .hadNoteContaining(
-            "Generating a MembersInjector for "
-                + "test.inject.LocalInjectMemberWithConstructor. "
-                + "Prefer to run the dagger processor over that class instead.");
-    assertThat(compilation)
-        .hadNoteContaining(
-            "Generating a MembersInjector for "
-                + "test.inject.ParentInjectMemberWithConstructor. "
-                + "Prefer to run the dagger processor over that class instead.");
-    assertThat(compilation).hadNoteCount(3);
-  }
-
-  @Test
-  public void scopeAnnotationOnInjectConstructorNotValid() {
-    JavaFileObject aScope =
-        JavaFileObjects.forSourceLines(
-            "test.AScope",
-            "package test;",
-            "",
-            "import javax.inject.Scope;",
-            "",
-            "@Scope",
-            "@interface AScope {}");
-    JavaFileObject aClass =
-        JavaFileObjects.forSourceLines(
-            "test.AClass",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "final class AClass {",
-            "  @Inject @AScope AClass() {}",
-            "}");
-    Compilation compilation = daggerCompiler().compile(aScope, aClass);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("@Scope annotations are not allowed on @Inject constructors.")
-        .inFile(aClass)
-        .onLine(6);
-  }
-
-  @Test
-  public void attemptToInjectWildcardGenerics() {
-    JavaFileObject testComponent =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Lazy;",
-            "import javax.inject.Provider;",
-            "",
-            "@Component",
-            "interface TestComponent {",
-            "  Lazy<? extends Number> wildcardNumberLazy();",
-            "  Provider<? super Number> wildcardNumberProvider();",
-            "}");
-    Compilation compilation = daggerCompiler().compile(testComponent);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("wildcard type").inFile(testComponent).onLine(9);
-    assertThat(compilation).hadErrorContaining("wildcard type").inFile(testComponent).onLine(10);
-  }
-
-  @Test
-  public void unusedSubcomponents_dontResolveExtraBindingsInParentComponents() {
-    JavaFileObject foo =
-        JavaFileObjects.forSourceLines(
-            "test.Foo",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "import javax.inject.Singleton;",
-            "",
-            "@Singleton",
-            "class Foo {",
-            "  @Inject Foo() {}",
-            "}");
-
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "",
-            "@Module(subcomponents = Pruned.class)",
-            "class TestModule {}");
-
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Parent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Singleton;",
-            "",
-            "@Singleton",
-            "@Component(modules = TestModule.class)",
-            "interface Parent {}");
-
-    JavaFileObject prunedSubcomponent =
-        JavaFileObjects.forSourceLines(
-            "test.Pruned",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Pruned {",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    Pruned build();",
-            "  }",
-            "",
-            "  Foo foo();",
-            "}");
-    JavaFileObject generated =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerParent",
-            "package test;",
-            "",
-            "import dagger.internal.Preconditions;",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerParent implements Parent {",
-            "  private DaggerParent(Builder builder) {",
-            "    assert builder != null;",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static Parent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public Parent build() {",
-            "      return new DaggerParent(this);",
-            "    }",
-            "",
-            "    @Deprecated",
-            "    public Builder testModule(TestModule testModule) {",
-            "      Preconditions.checkNotNull(testModule);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
-
-    Compilation compilation = daggerCompiler().compile(foo, module, component, prunedSubcomponent);
-    assertThat(compilation).succeeded();
-    assertThat(compilation)
-        .generatedSourceFile("test.DaggerParent")
-        .hasSourceEquivalentTo(generated);
-  }
-
-  // TODO(b/34107586): Fix and enable test.
-  @Test
-  @Ignore
-  public void invalidComponentDependencies() {
-    JavaFileObject testComponent =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(dependencies = int.class)",
-            "interface TestComponent {}");
-    Compilation compilation = daggerCompiler().compile(testComponent);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("int is not a valid component dependency type");
-  }
-
-  @Test
-  public void invalidComponentModules() {
-    JavaFileObject testComponent =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = int.class)",
-            "interface TestComponent {}");
-    Compilation compilation = daggerCompiler().compile(testComponent);
-    assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("int is not a valid module type");
-  }
-
-  @Test
-  public void moduleInDependencies() {
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "final class TestModule {",
-            "  @Provides String s() { return null; }",
-            "}");
-    JavaFileObject testComponent =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(dependencies = TestModule.class)",
-            "interface TestComponent {}");
-    Compilation compilation = daggerCompiler().compile(testModule, testComponent);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("test.TestModule is a module, which cannot be a component dependency");
-  }
-
-  @Test
-  public void bindsInstanceInModule() {
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.BindsInstance;",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "abstract class TestModule {",
-            "  @BindsInstance abstract void str(String string);",
-            "}");
-    Compilation compilation = daggerCompiler().compile(testModule);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "@BindsInstance methods should not be included in @Modules. Did you mean @Binds");
-  }
-
-  @Test
-  public void bindsInstanceInComponent() {
-    JavaFileObject testComponent =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.BindsInstance;",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface TestComponent {",
-            "  @BindsInstance String s(String s);",
-            "}");
-    Compilation compilation = daggerCompiler().compile(testComponent);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "@BindsInstance methods should not be included in @Components. "
-                + "Did you mean to put it in a @Component.Builder?");
-  }
-
-  @Test
-  public void bindsInstanceNotAbstract() {
-    JavaFileObject notAbstract =
-        JavaFileObjects.forSourceLines(
-            "test.BindsInstanceNotAbstract",
-            "package test;",
-            "",
-            "import dagger.BindsInstance;",
-            "import dagger.Component;",
-            "",
-            "class BindsInstanceNotAbstract {",
-            "  @BindsInstance BindsInstanceNotAbstract bind(int unused) { return this; }",
-            "}");
-    Compilation compilation = daggerCompiler().compile(notAbstract);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("@BindsInstance methods must be abstract")
-        .inFile(notAbstract)
-        .onLine(7);
-  }
-
-  @Test
-  public void bindsInstanceNoParameters() {
-    JavaFileObject notAbstract =
-        JavaFileObjects.forSourceLines(
-            "test.BindsInstanceNoParameters",
-            "package test;",
-            "",
-            "import dagger.BindsInstance;",
-            "",
-            "interface BindsInstanceNoParameters {",
-            "  @BindsInstance void noParams();",
-            "}");
-    Compilation compilation = daggerCompiler().compile(notAbstract);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "@BindsInstance methods should have exactly one parameter for the bound type")
-        .inFile(notAbstract)
-        .onLine(6);
-  }
-
-  @Test
-  public void bindsInstanceManyParameters() {
-    JavaFileObject notAbstract =
-        JavaFileObjects.forSourceLines(
-            "test.BindsInstanceNoParameter",
-            "package test;",
-            "",
-            "import dagger.BindsInstance;",
-            "",
-            "interface BindsInstanceManyParameters {",
-            "  @BindsInstance void manyParams(int i, long l);",
-            "}");
-    Compilation compilation = daggerCompiler().compile(notAbstract);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining(
-            "@BindsInstance methods should have exactly one parameter for the bound type")
-        .inFile(notAbstract)
-        .onLine(6);
-  }
-
-  @Test
-  public void bindsInstanceFrameworkType() {
-    JavaFileObject bindsFrameworkType =
-        JavaFileObjects.forSourceLines(
-            "test.BindsInstanceFrameworkType",
-            "package test;",
-            "",
-            "import dagger.BindsInstance;",
-            "import dagger.producers.Producer;",
-            "import javax.inject.Provider;",
-            "",
-            "interface BindsInstanceFrameworkType {",
-            "  @BindsInstance void bindsProvider(Provider<Object> objectProvider);",
-            "  @BindsInstance void bindsProducer(Producer<Object> objectProducer);",
-            "}");
-    Compilation compilation = daggerCompiler().compile(bindsFrameworkType);
-    assertThat(compilation).failed();
-    assertThat(compilation)
-        .hadErrorContaining("@BindsInstance parameters may not be framework types")
-        .inFile(bindsFrameworkType)
-        .onLine(8);
-
-    assertThat(compilation)
-        .hadErrorContaining("@BindsInstance parameters may not be framework types")
-        .inFile(bindsFrameworkType)
-        .onLine(9);
-  }
-
-  private static Compiler daggerCompiler(Processor... extraProcessors) {
-    return javac().withProcessors(Lists.asList(new ComponentProcessor(), extraProcessors));
-  }
-
-  /**
-   * A {@link ComponentProcessor} that excludes elements using a {@link Predicate}.
-   */
-  private static final class ElementFilteringComponentProcessor extends AbstractProcessor {
-    private final ComponentProcessor componentProcessor = new ComponentProcessor();
-    private final Predicate<? super Element> filter;
-
-    /**
-     * Creates a {@link ComponentProcessor} that only processes elements that match {@code filter}.
-     */
-    public ElementFilteringComponentProcessor(Predicate<? super Element> filter) {
-      this.filter = filter;
-    }
-
-    @Override
-    public synchronized void init(ProcessingEnvironment processingEnv) {
-      super.init(processingEnv);
-      componentProcessor.init(processingEnv);
-    }
-
-    @Override
-    public Set<String> getSupportedAnnotationTypes() {
-      return componentProcessor.getSupportedAnnotationTypes();
-    }
-
-    @Override
-    public SourceVersion getSupportedSourceVersion() {
-      return componentProcessor.getSupportedSourceVersion();
-    }
-
-    @Override
-    public Set<String> getSupportedOptions() {
-      return componentProcessor.getSupportedOptions();
-    }
-
-    @Override
-    public boolean process(
-        Set<? extends TypeElement> annotations, final RoundEnvironment roundEnv) {
-      return componentProcessor.process(
-          annotations,
-          new RoundEnvironment() {
-            @Override
-            public boolean processingOver() {
-              return roundEnv.processingOver();
-            }
-
-            @Override
-            public Set<? extends Element> getRootElements() {
-              return Sets.filter(roundEnv.getRootElements(), filter);
-            }
-
-            @Override
-            public Set<? extends Element> getElementsAnnotatedWith(Class<? extends Annotation> a) {
-              return Sets.filter(roundEnv.getElementsAnnotatedWith(a), filter);
-            }
-
-            @Override
-            public Set<? extends Element> getElementsAnnotatedWith(TypeElement a) {
-              return Sets.filter(roundEnv.getElementsAnnotatedWith(a), filter);
-            }
-
-            @Override
-            public boolean errorRaised() {
-              return roundEnv.errorRaised();
-            }
-          });
-    }
-  }
-
-  /**
-   * A simple {@link Processor} that generates one source file.
-   */
-  private static final class GeneratingProcessor extends AbstractProcessor {
-    private final String generatedClassName;
-    private final String generatedSource;
-    private boolean processed;
-
-    GeneratingProcessor(String generatedClassName, String... source) {
-      this.generatedClassName = generatedClassName;
-      this.generatedSource = Joiner.on("\n").join(source);
-    }
-
-    @Override
-    public Set<String> getSupportedAnnotationTypes() {
-      return ImmutableSet.of("*");
-    }
-
-    @Override
-    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
-      if (!processed) {
-        processed = true;
-        try (Writer writer =
-                processingEnv.getFiler().createSourceFile(generatedClassName).openWriter()) {
-          writer.append(generatedSource);
-        } catch (IOException e) {
-          throw new RuntimeException(e);
-        }
-      }
-      return false;
-    }
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/DaggerModuleMethodSubject.java b/compiler/src/test/java/dagger/internal/codegen/DaggerModuleMethodSubject.java
deleted file mode 100644
index 171d36511..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/DaggerModuleMethodSubject.java
+++ /dev/null
@@ -1,187 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-
-import com.google.common.collect.FluentIterable;
-import com.google.common.collect.ImmutableList;
-import com.google.common.truth.FailureStrategy;
-import com.google.common.truth.Subject;
-import com.google.common.truth.SubjectFactory;
-import com.google.common.truth.Truth;
-import com.google.testing.compile.JavaFileObjects;
-import dagger.Module;
-import dagger.Multibindings;
-import dagger.producers.ProducerModule;
-import java.io.PrintWriter;
-import java.io.StringWriter;
-import java.util.Arrays;
-import java.util.List;
-import javax.tools.JavaFileObject;
-
-/** A {@link Truth} subject for testing Dagger module methods. */
-final class DaggerModuleMethodSubject extends Subject<DaggerModuleMethodSubject, String> {
-
-  /** A {@link Truth} subject factory for testing Dagger module methods. */
-  static final class Factory extends SubjectFactory<DaggerModuleMethodSubject, String> {
-
-    /** Starts a clause testing a Dagger {@link Module @Module} method. */
-    static DaggerModuleMethodSubject assertThatModuleMethod(String method) {
-      return assertAbout(daggerModuleMethod())
-          .that(method)
-          .withDeclaration("@Module abstract class %s { %s }");
-    }
-
-    /** Starts a clause testing a Dagger {@link ProducerModule @ProducerModule} method. */
-    static DaggerModuleMethodSubject assertThatProductionModuleMethod(String method) {
-      return assertAbout(daggerModuleMethod())
-          .that(method)
-          .withDeclaration("@ProducerModule abstract class %s { %s }");
-    }
-
-    /** Starts a clause testing a Dagger {@link Multibindings @Multibindings} interface method. */
-    static DaggerModuleMethodSubject assertThatMultibindingsMethod(String method) {
-      return assertAbout(daggerModuleMethod())
-          .that(method)
-          .withDeclaration("@Module abstract class %s { @Multibindings interface Empties { %s }}");
-    }
-
-    /** Starts a clause testing a method in an unannotated class. */
-    static DaggerModuleMethodSubject assertThatMethodInUnannotatedClass(String method) {
-      return assertAbout(daggerModuleMethod())
-          .that(method)
-          .withDeclaration("abstract class %s { %s }");
-    }
-
-    static Factory daggerModuleMethod() {
-      return new Factory();
-    }
-
-    private Factory() {}
-
-    @Override
-    public DaggerModuleMethodSubject getSubject(FailureStrategy fs, String that) {
-      return new DaggerModuleMethodSubject(fs, that);
-    }
-  }
-
-  private ImmutableList.Builder<String> imports =
-      new ImmutableList.Builder<String>()
-          .add(
-              "import dagger.*;",
-              "import dagger.multibindings.*;",
-              "import dagger.producers.*;",
-              "import java.util.*;",
-              "import javax.inject.*;");
-  private String declaration;
-  private ImmutableList<JavaFileObject> additionalSources = ImmutableList.of();
-
-  private DaggerModuleMethodSubject(FailureStrategy failureStrategy, String subject) {
-    super(failureStrategy, subject);
-  }
-
-  /**
-   * Imports classes and interfaces. Note that all types in the following packages are already
-   * imported:<ul>
-   * <li>{@code dagger.*}
-   * <li>{@code dagger.multibindings.*}
-   * <li>(@code dagger.producers.*}
-   * <li>{@code java.util.*}
-   * <li>{@code javax.inject.*}
-   * </ul>
-   */
-  DaggerModuleMethodSubject importing(Class<?>... imports) {
-    return importing(Arrays.asList(imports));
-  }
-
-  /**
-   * Imports classes and interfaces. Note that all types in the following packages are already
-   * imported:<ul>
-   * <li>{@code dagger.*}
-   * <li>{@code dagger.multibindings.*}
-   * <li>(@code dagger.producers.*}
-   * <li>{@code java.util.*}
-   * <li>{@code javax.inject.*}
-   * </ul>
-   */
-  DaggerModuleMethodSubject importing(List<? extends Class<?>> imports) {
-    imports.stream()
-        .map(clazz -> String.format("import %s;", clazz.getCanonicalName()))
-        .forEachOrdered(this.imports::add);
-    return this;
-  }
-
-  /**
-   * Sets the declaration of the module. Must be a string with two {@code %s} parameters. The first
-   * will be replaced with the name of the type, and the second with the method declaration, which
-   * must be within paired braces.
-   */
-  DaggerModuleMethodSubject withDeclaration(String declaration) {
-    this.declaration = declaration;
-    return this;
-  }
-
-  /** Additional source files that must be compiled with the module. */
-  DaggerModuleMethodSubject withAdditionalSources(JavaFileObject... sources) {
-    this.additionalSources = ImmutableList.copyOf(sources);
-    return this;
-  }
-
-  /**
-   * Fails if compiling the module with the method doesn't report an error at the method
-   * declaration whose message contains {@code errorSubstring}.
-   */
-  void hasError(String errorSubstring) {
-    String source = moduleSource();
-    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule", source);
-    assertAbout(javaSources())
-        .that(FluentIterable.from(additionalSources).append(module))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(errorSubstring)
-        .in(module)
-        .onLine(methodLine(source));
-  }
-
-  private int methodLine(String source) {
-    String beforeMethod = source.substring(0, source.indexOf(actual()));
-    int methodLine = 1;
-    for (int nextNewlineIndex = beforeMethod.indexOf('\n');
-        nextNewlineIndex >= 0;
-        nextNewlineIndex = beforeMethod.indexOf('\n', nextNewlineIndex + 1)) {
-      methodLine++;
-    }
-    return methodLine;
-  }
-
-  private String moduleSource() {
-    StringWriter stringWriter = new StringWriter();
-    PrintWriter writer = new PrintWriter(stringWriter);
-    writer.println("package test;");
-    writer.println();
-    for (String importLine : imports.build()) {
-      writer.println(importLine);
-    }
-    writer.println();
-    writer.printf(declaration, "TestModule", "\n" + actual() + "\n");
-    writer.println();
-    return stringWriter.toString();
-  }
-
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
deleted file mode 100644
index 83ad31d98..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/GraphValidationTest.java
+++ /dev/null
@@ -1,2534 +0,0 @@
-/*
- * Copyright (C) 2014 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubject.assertThat;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.ErrorMessages.nullableToNonNullable;
-
-import com.google.common.base.Joiner;
-import com.google.common.collect.ImmutableList;
-import com.google.testing.compile.JavaFileObjects;
-import java.util.Arrays;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class GraphValidationTest {
-  private static final JavaFileObject NULLABLE =
-      JavaFileObjects.forSourceLines(
-          "test.Nullable", // force one-string-per-line format
-          "package test;",
-          "",
-          "public @interface Nullable {}");
-
-  @Test public void componentOnConcreteClass() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.MyComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "interface MyComponent {",
-        "  Foo getFoo();",
-        "}");
-    JavaFileObject injectable = JavaFileObjects.forSourceLines("test.Foo",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "class Foo {",
-        "  @Inject Foo(Bar bar) {}",
-        "}");
-    JavaFileObject nonInjectable = JavaFileObjects.forSourceLines("test.Bar",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "interface Bar {}");
-    assertAbout(javaSources()).that(Arrays.asList(component, injectable, nonInjectable))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("test.Bar cannot be provided without an @Provides-annotated method.")
-            .in(component).onLine(7);
-  }
-
-  @Test public void componentProvisionWithNoDependencyChain() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestClass",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Qualifier;",
-            "",
-            "final class TestClass {",
-            "  @Qualifier @interface Q {}",
-            "  interface A {}",
-            "",
-            "  @Component()",
-            "  interface AComponent {",
-            "    A getA();",
-            "    @Q A qualifiedA();",
-            "  }",
-            "}");
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            "test.TestClass.A cannot be provided without an @Provides-annotated method.")
-        .in(component)
-        .onLine(12)
-        .and()
-        .withErrorContaining(
-            "@test.TestClass.Q test.TestClass.A "
-                + "cannot be provided without an @Provides-annotated method.")
-        .in(component)
-        .onLine(13);
-  }
-
-  @Test public void constructorInjectionWithoutAnnotation() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "final class TestClass {",
-        "  static class A {",
-        "    A() {}",
-        "  }",
-        "",
-        "  @Component()",
-        "  interface AComponent {",
-        "    A getA();",
-        "  }",
-        "}");
-    String expectedError = "test.TestClass.A cannot be provided without an "
-        + "@Inject constructor or from an @Provides-annotated method.";
-    assertAbout(javaSource()).that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(15);
-  }
-
-  @Test public void membersInjectWithoutProvision() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "final class TestClass {",
-        "  static class A {",
-        "    @Inject A() {}",
-        "  }",
-        "",
-        "  static class B {",
-        "    @Inject A a;",
-        "  }",
-        "",
-        "  @Component()",
-        "  interface AComponent {",
-        "    B getB();",
-        "  }",
-        "}");
-    String expectedError = "test.TestClass.B cannot be provided without an "
-        + "@Inject constructor or from an @Provides-annotated method. "
-        + "This type supports members injection but cannot be implicitly provided.";
-    assertAbout(javaSource()).that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(19);
-  }
-
-  @Test
-  public void membersInjectDependsOnUnboundedType() {
-    JavaFileObject injectsUnboundedType =
-        JavaFileObjects.forSourceLines(
-            "test.InjectsUnboundedType",
-            "package test;",
-            "",
-            "import dagger.MembersInjector;",
-            "import java.util.ArrayList;",
-            "import javax.inject.Inject;",
-            "",
-            "class InjectsUnboundedType {",
-            "  @Inject MembersInjector<ArrayList<?>> listInjector;",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface TestComponent {",
-            "  void injectsUnboundedType(InjectsUnboundedType injects);",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(injectsUnboundedType, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            Joiner.on('\n')
-                .join(
-                    "Type parameters must be bounded for members injection."
-                        + " ? required by java.util.ArrayList<?>, via:",
-                    "      dagger.MembersInjector<java.util.ArrayList<?>> is injected at",
-                    "          test.InjectsUnboundedType.listInjector",
-                    "      test.InjectsUnboundedType is injected at",
-                    "          test.TestComponent.injectsUnboundedType(injects)"))
-        .in(component)
-        .onLine(7);
-  }
-
-  @Test
-  public void invalidMembersInjection() {
-    JavaFileObject injected =
-        JavaFileObjects.forSourceLines(
-            "test.Injected",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "final class Injected {",
-            "  @Inject static Object object;",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface TestComponent {",
-            "  void inject(Injected injected);",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(injected, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("static fields")
-        .in(injected)
-        .onLine(6);
-  }
-
-  @Test public void cyclicDependency() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "final class Outer {",
-        "  static class A {",
-        "    @Inject A(C cParam) {}",
-        "  }",
-        "",
-        "  static class B {",
-        "    @Inject B(A aParam) {}",
-        "  }",
-        "",
-        "  static class C {",
-        "    @Inject C(B bParam) {}",
-        "  }",
-        "",
-        "  @Component()",
-        "  interface CComponent {",
-        "    C getC();",
-        "  }",
-        "}");
-
-    String expectedError =
-        Joiner.on('\n')
-            .join(
-                "Found a dependency cycle:",
-                "      test.Outer.C is injected at",
-                "          test.Outer.A.<init>(cParam)",
-                "      test.Outer.A is injected at",
-                "          test.Outer.B.<init>(aParam)",
-                "      test.Outer.B is injected at",
-                "          test.Outer.C.<init>(bParam)",
-                "      test.Outer.C is provided at",
-                "          test.Outer.CComponent.getC()");
-
-    assertAbout(javaSource()).that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(23);
-  }
-
-  @Test public void cyclicDependencyNotIncludingEntryPoint() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Outer",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "",
-            "final class Outer {",
-            "  static class A {",
-            "    @Inject A(C cParam) {}",
-            "  }",
-            "",
-            "  static class B {",
-            "    @Inject B(A aParam) {}",
-            "  }",
-            "",
-            "  static class C {",
-            "    @Inject C(B bParam) {}",
-            "  }",
-            "",
-            "  static class D {",
-            "    @Inject D(C cParam) {}",
-            "  }",
-            "",
-            "  @Component()",
-            "  interface DComponent {",
-            "    D getD();",
-            "  }",
-            "}");
-
-    String expectedError =
-        Joiner.on('\n')
-            .join(
-                "Found a dependency cycle:",
-                "      test.Outer.C is injected at",
-                "          test.Outer.A.<init>(cParam)",
-                "      test.Outer.A is injected at",
-                "          test.Outer.B.<init>(aParam)",
-                "      test.Outer.B is injected at",
-                "          test.Outer.C.<init>(bParam)",
-                "      test.Outer.C is injected at",
-                "          test.Outer.D.<init>(cParam)",
-                "      test.Outer.D is provided at",
-                "          test.Outer.DComponent.getD()");
-
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError)
-        .in(component)
-        .onLine(27);
-  }
-
-  @Test
-  public void cyclicDependencyNotBrokenByMapBinding() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Outer",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.MapKey;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "import java.util.Map;",
-            "import javax.inject.Inject;",
-            "",
-            "final class Outer {",
-            "  static class A {",
-            "    @Inject A(Map<String, C> cMap) {}",
-            "  }",
-            "",
-            "  static class B {",
-            "    @Inject B(A aParam) {}",
-            "  }",
-            "",
-            "  static class C {",
-            "    @Inject C(B bParam) {}",
-            "  }",
-            "",
-            "  @Component(modules = CModule.class)",
-            "  interface CComponent {",
-            "    C getC();",
-            "  }",
-            "",
-            "  @Module",
-            "  static class CModule {",
-            "    @Provides @IntoMap",
-            "    @StringKey(\"C\")",
-            "    static C c(C c) {",
-            "      return c;",
-            "    }",
-            "  }",
-            "",
-            "  @MapKey",
-            "  @interface StringKey {",
-            "    String value();",
-            "  }",
-            "}");
-
-    String expectedError =
-        Joiner.on('\n')
-            .join(
-                "Found a dependency cycle:",
-                "      test.Outer.C is injected at",
-                "          test.Outer.CModule.c(c)",
-                "      java.util.Map<java.lang.String,test.Outer.C> is injected at",
-                "          test.Outer.A.<init>(cMap)",
-                "      test.Outer.A is injected at",
-                "          test.Outer.B.<init>(aParam)",
-                "      test.Outer.B is injected at",
-                "          test.Outer.C.<init>(bParam)",
-                "      test.Outer.C is provided at",
-                "          test.Outer.CComponent.getC()");
-
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError)
-        .in(component)
-        .onLine(26);
-  }
-
-  @Test
-  public void cyclicDependencyWithSetBinding() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Outer",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "import java.util.Set;",
-            "import javax.inject.Inject;",
-            "",
-            "final class Outer {",
-            "  static class A {",
-            "    @Inject A(Set<C> cSet) {}",
-            "  }",
-            "",
-            "  static class B {",
-            "    @Inject B(A aParam) {}",
-            "  }",
-            "",
-            "  static class C {",
-            "    @Inject C(B bParam) {}",
-            "  }",
-            "",
-            "  @Component(modules = CModule.class)",
-            "  interface CComponent {",
-            "    C getC();",
-            "  }",
-            "",
-            "  @Module",
-            "  static class CModule {",
-            "    @Provides @IntoSet",
-            "    static C c(C c) {",
-            "      return c;",
-            "    }",
-            "  }",
-            "}");
-
-    String expectedError =
-        Joiner.on('\n')
-            .join(
-                "Found a dependency cycle:",
-                "      test.Outer.C is injected at",
-                "          test.Outer.CModule.c(c)",
-                "      java.util.Set<test.Outer.C> is injected at",
-                "          test.Outer.A.<init>(cSet)",
-                "      test.Outer.A is injected at",
-                "          test.Outer.B.<init>(aParam)",
-                "      test.Outer.B is injected at",
-                "          test.Outer.C.<init>(bParam)",
-                "      test.Outer.C is provided at",
-                "          test.Outer.CComponent.getC()");
-
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError)
-        .in(component)
-        .onLine(25);
-  }
-
-  @Test
-  public void falsePositiveCyclicDependencyIndirectionDetected() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Outer",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "import javax.inject.Provider;",
-            "",
-            "final class Outer {",
-            "  static class A {",
-            "    @Inject A(C cParam) {}",
-            "  }",
-            "",
-            "  static class B {",
-            "    @Inject B(A aParam) {}",
-            "  }",
-            "",
-            "  static class C {",
-            "    @Inject C(B bParam) {}",
-            "  }",
-            "",
-            "  static class D {",
-            "    @Inject D(Provider<C> cParam) {}",
-            "  }",
-            "",
-            "  @Component()",
-            "  interface DComponent {",
-            "    D getD();",
-            "  }",
-            "}");
-
-    String expectedError =
-        Joiner.on('\n')
-            .join(
-                "Found a dependency cycle:",
-                "      test.Outer.C is injected at",
-                "          test.Outer.A.<init>(cParam)",
-                "      test.Outer.A is injected at",
-                "          test.Outer.B.<init>(aParam)",
-                "      test.Outer.B is injected at",
-                "          test.Outer.C.<init>(bParam)",
-                "      javax.inject.Provider<test.Outer.C> is injected at",
-                "          test.Outer.D.<init>(cParam)",
-                "      test.Outer.D is provided at",
-                "          test.Outer.DComponent.getD()");
-
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError)
-        .in(component)
-        .onLine(28);
-  }
-
-  @Test
-  public void cyclicDependencyInSubcomponents() {
-    JavaFileObject parent =
-        JavaFileObjects.forSourceLines(
-            "test.Parent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface Parent {",
-            "  Child child();",
-            "}");
-    JavaFileObject child =
-        JavaFileObjects.forSourceLines(
-            "test.Child",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = ChildModule.class)",
-            "interface Child {",
-            "  Grandchild grandchild();",
-            "}");
-    JavaFileObject grandchild =
-        JavaFileObjects.forSourceLines(
-            "test.Grandchild",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = GrandchildModule.class)",
-            "interface Grandchild {",
-            "  String entry();",
-            "}");
-    JavaFileObject childModule =
-        JavaFileObjects.forSourceLines(
-            "test.ChildModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "abstract class ChildModule {",
-            "  @Provides static Object object(String string) {",
-            "    return string;",
-            "  }",
-            "}");
-    JavaFileObject grandchildModule =
-        JavaFileObjects.forSourceLines(
-            "test.GrandchildModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "abstract class GrandchildModule {",
-            "  @Provides static String string(Object object) {",
-            "    return object.toString();",
-            "  }",
-            "}");
-
-    String expectedError =
-        Joiner.on('\n')
-            .join(
-                "[test.Grandchild.entry()] Found a dependency cycle:",
-                "      java.lang.String is injected at",
-                "          test.ChildModule.object(string)",
-                "      java.lang.Object is injected at",
-                "          test.GrandchildModule.string(object)",
-                "      java.lang.String is provided at",
-                "          test.Grandchild.entry()");
-
-    assertAbout(javaSources())
-        .that(ImmutableList.of(parent, child, grandchild, childModule, grandchildModule))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError)
-        .in(child)
-        .onLine(6);
-  }
-
-  @Test
-  public void circularBindsMethods() {
-    JavaFileObject qualifier =
-        JavaFileObjects.forSourceLines(
-            "test.SomeQualifier",
-            "package test;",
-            "",
-            "import javax.inject.Qualifier;",
-            "",
-            "@Qualifier @interface SomeQualifier {}");
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "abstract class TestModule {",
-            "  @Binds abstract Object bindUnqualified(@SomeQualifier Object qualified);",
-            "  @Binds @SomeQualifier abstract Object bindQualified(Object unqualified);",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  Object unqualified();",
-            "  @SomeQualifier Object qualified();",
-            "}");
-
-    assertThat(qualifier, module, component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            "Found a dependency cycle:\n"
-                + "      java.lang.Object is injected at\n"
-                + "          test.TestModule.bindQualified(unqualified)\n"
-                + "      @test.SomeQualifier java.lang.Object is injected at\n"
-                + "          test.TestModule.bindUnqualified(qualified)\n"
-                + "      java.lang.Object is provided at\n"
-                + "          test.TestComponent.unqualified()")
-        .in(component)
-        .onLine(7)
-        .and()
-        .withErrorContaining(
-            "Found a dependency cycle:\n"
-                + "      @test.SomeQualifier java.lang.Object is injected at\n"
-                + "          test.TestModule.bindUnqualified(qualified)\n"
-                + "      java.lang.Object is injected at\n"
-                + "          test.TestModule.bindQualified(unqualified)\n"
-                + "      @test.SomeQualifier java.lang.Object is provided at\n"
-                + "          test.TestComponent.qualified()")
-        .in(component)
-        .onLine(8);
-  }
-
-  @Test
-  public void selfReferentialBinds() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "abstract class TestModule {",
-            "  @Binds abstract Object bindToSelf(Object sameKey);",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  Object selfReferential();",
-            "}");
-
-    assertThat(module, component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            // TODO(gak): cl/126230644 produces a better error message in this case. Here it isn't
-            // unclear what is going wrong.
-            "Found a dependency cycle:\n"
-                + "      java.lang.Object is injected at\n"
-                + "          test.TestModule.bindToSelf(sameKey)\n"
-                + "      java.lang.Object is provided at\n"
-                + "          test.TestComponent.selfReferential()")
-        .in(component)
-        .onLine(7);
-  }
-
-  @Test public void duplicateExplicitBindings_ProvidesAndComponentProvision() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "final class Outer {",
-        "  interface A {}",
-        "",
-        "  interface B {}",
-        "",
-        "  @Module",
-        "  static class AModule {",
-        "    @Provides String provideString() { return \"\"; }",
-        "    @Provides A provideA(String s) { return new A() {}; }",
-        "  }",
-        "",
-        "  @Component(modules = AModule.class)",
-        "  interface Parent {",
-        "    A getA();",
-        "  }",
-        "",
-        "  @Module",
-        "  static class BModule {",
-        "    @Provides B provideB(A a) { return new B() {}; }",
-        "  }",
-        "",
-        "  @Component(dependencies = Parent.class, modules = { BModule.class, AModule.class})",
-        "  interface Child {",
-        "    B getB();",
-        "  }",
-        "}");
-
-    String expectedError = "test.Outer.A is bound multiple times:\n"
-        + "      test.Outer.A test.Outer.Parent.getA()\n"
-        + "      @Provides test.Outer.A test.Outer.AModule.provideA(String)";
-
-    assertAbout(javaSource()).that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(30);
-  }
-
-  @Test public void duplicateExplicitBindings_TwoProvidesMethods() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "final class Outer {",
-        "  interface A {}",
-        "",
-        "  @Module",
-        "  static class Module1 {",
-        "    @Provides A provideA1() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class Module2 {",
-        "    @Provides String provideString() { return \"\"; }",
-        "    @Provides A provideA2(String s) { return new A() {}; }",
-        "  }",
-        "",
-        "  @Component(modules = { Module1.class, Module2.class})",
-        "  interface TestComponent {",
-        "    A getA();",
-        "  }",
-        "}");
-
-    String expectedError = "test.Outer.A is bound multiple times:\n"
-        + "      @Provides test.Outer.A test.Outer.Module1.provideA1()\n"
-        + "      @Provides test.Outer.A test.Outer.Module2.provideA2(String)";
-
-    assertAbout(javaSource()).that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(24);
-  }
-
-  @Test
-  public void duplicateExplicitBindings_ProvidesVsBinds() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Outer",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "",
-            "final class Outer {",
-            "  interface A {}",
-            "",
-            "  static final class B implements A {",
-            "    @Inject B() {}",
-            "  }",
-            "",
-            "  @Module",
-            "  static class Module1 {",
-            "    @Provides A provideA1() { return new A() {}; }",
-            "  }",
-            "",
-            "  @Module",
-            "  static abstract class Module2 {",
-            "    @Binds abstract A bindA2(B b);",
-            "  }",
-            "",
-            "  @Component(modules = { Module1.class, Module2.class})",
-            "  interface TestComponent {",
-            "    A getA();",
-            "  }",
-            "}");
-
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            Joiner.on("\n      ")
-                .join(
-                    "test.Outer.A is bound multiple times:",
-                    "@Provides test.Outer.A test.Outer.Module1.provideA1()",
-                    "@Binds test.Outer.A test.Outer.Module2.bindA2(test.Outer.B)"))
-        .in(component)
-        .onLine(28);
-  }
-
-  @Test public void duplicateExplicitBindings_MultipleProvisionTypes() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
-        "package test;",
-        "",
-        "import dagger.Binds;",
-        "import dagger.Component;",
-        "import dagger.MapKey;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.MapKey;",
-        "import dagger.multibindings.IntoMap;",
-        "import dagger.multibindings.IntoSet;",
-        "import java.util.HashMap;",
-        "import java.util.HashSet;",
-        "import java.util.Map;",
-        "import java.util.Set;",
-        "import javax.inject.Qualifier;",
-        "",
-        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-        "final class Outer {",
-        "  @MapKey(unwrapValue = true)",
-        "  @interface StringKey {",
-        "    String value();",
-        "  }",
-        "",
-        "  @Qualifier @interface SomeQualifier {}",
-        "",
-        "  @Module",
-        "  abstract static class TestModule1 {",
-        "    @Provides @IntoMap",
-        "    @StringKey(\"foo\")",
-        "    static String stringMapEntry() { return \"\"; }",
-        "",
-        "    @Binds @IntoMap @StringKey(\"bar\")",
-        "    abstract String bindStringMapEntry(@SomeQualifier String value);",
-        "",
-        "    @Provides @IntoSet static String stringSetElement() { return \"\"; }",
-        "    @Binds @IntoSet abstract String bindStringSetElement(@SomeQualifier String value);",
-        "",
-        "    @Provides @SomeQualifier static String provideSomeQualifiedString() { return \"\"; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class TestModule2 {",
-        "    @Provides Set<String> stringSet() { return new HashSet<String>(); }",
-        "",
-        "    @Provides Map<String, String> stringMap() {",
-        "      return new HashMap<String, String>();",
-        "    }",
-        "  }",
-        "",
-        "  @Component(modules = { TestModule1.class, TestModule2.class })",
-        "  interface TestComponent {",
-        "    Set<String> getStringSet();",
-        "    Map<String, String> getStringMap();",
-        "  }",
-        "}");
-
-    String expectedSetError =
-        "java.util.Set<java.lang.String> has incompatible bindings or declarations:\n"
-            + "      Set bindings and declarations:\n"
-            + "          @Provides @dagger.multibindings.IntoSet String "
-            + "test.Outer.TestModule1.stringSetElement()\n"
-            + "          @Binds @dagger.multibindings.IntoSet String "
-            + "test.Outer.TestModule1.bindStringSetElement(@test.Outer.SomeQualifier String)\n"
-            + "      Unique bindings and declarations:\n"
-            + "          @Provides Set<String> test.Outer.TestModule2.stringSet()";
-
-    String expectedMapError =
-        "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
-            + "or declarations:\n"
-            + "      Map bindings and declarations:\n"
-            + "          @Provides @dagger.multibindings.IntoMap "
-            + "@test.Outer.StringKey(\"foo\") String"
-            + " test.Outer.TestModule1.stringMapEntry()\n"
-            + "          @Binds @dagger.multibindings.IntoMap "
-            + "@test.Outer.StringKey(\"bar\") String"
-            + " test.Outer.TestModule1.bindStringMapEntry(@test.Outer.SomeQualifier String)\n"
-            + "      Unique bindings and declarations:\n"
-            + "          @Provides Map<String,String> test.Outer.TestModule2.stringMap()";
-
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedSetError)
-        .in(component)
-        .onLine(52)
-        .and()
-        .withErrorContaining(expectedMapError)
-        .in(component)
-        .onLine(53);
-  }
-
-  @Test
-  public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Outer",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Multibindings;",
-            "import dagger.Provides;",
-            "import java.util.HashMap;",
-            "import java.util.HashSet;",
-            "import java.util.Map;",
-            "import java.util.Set;",
-            "",
-            "final class Outer {",
-            "  @Module",
-            "  static class TestModule1 {",
-            "    @Multibindings",
-            "    interface Empties {",
-            "      Map<String, String> stringMap();",
-            "      Set<String> stringSet();",
-            "    }",
-            "  }",
-            "",
-            "  @Module",
-            "  static class TestModule2 {",
-            "    @Provides Set<String> stringSet() { return new HashSet<String>(); }",
-            "",
-            "    @Provides Map<String, String> stringMap() {",
-            "      return new HashMap<String, String>();",
-            "    }",
-            "  }",
-            "",
-            "  @Component(modules = { TestModule1.class, TestModule2.class })",
-            "  interface TestComponent {",
-            "    Set<String> getStringSet();",
-            "    Map<String, String> getStringMap();",
-            "  }",
-            "}");
-
-    String expectedSetError =
-        "java.util.Set<java.lang.String> has incompatible bindings or declarations:\n"
-            + "      Set bindings and declarations:\n"
-            + "          Set<String> test.Outer.TestModule1.Empties.stringSet()\n"
-            + "      Unique bindings and declarations:\n"
-            + "          @Provides Set<String> test.Outer.TestModule2.stringSet()";
-
-    String expectedMapError =
-        "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
-            + "or declarations:\n"
-            + "      Map bindings and declarations:\n"
-            + "          Map<String,String> test.Outer.TestModule1.Empties.stringMap()\n"
-            + "      Unique bindings and declarations:\n"
-            + "          @Provides Map<String,String> test.Outer.TestModule2.stringMap()";
-
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedSetError)
-        .in(component)
-        .onLine(35)
-        .and()
-        .withErrorContaining(expectedMapError)
-        .in(component)
-        .onLine(36);
-  }
-
-  @Test public void duplicateBindings_TruncateAfterLimit() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "final class Outer {",
-        "  interface A {}",
-        "",
-        "  @Module",
-        "  static class Module1 {",
-        "    @Provides A provideA() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class Module2 {",
-        "    @Provides A provideA() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class Module3 {",
-        "    @Provides A provideA() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class Module4 {",
-        "    @Provides A provideA() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class Module5 {",
-        "    @Provides A provideA() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class Module6 {",
-        "    @Provides A provideA() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class Module7 {",
-        "    @Provides A provideA() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class Module8 {",
-        "    @Provides A provideA() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class Module9 {",
-        "    @Provides A provideA() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class Module10 {",
-        "    @Provides A provideA() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class Module11 {",
-        "    @Provides A provideA() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Module",
-        "  static class Module12 {",
-        "    @Provides A provideA() { return new A() {}; }",
-        "  }",
-        "",
-        "  @Component(modules = {",
-        "    Module1.class,",
-        "    Module2.class,",
-        "    Module3.class,",
-        "    Module4.class,",
-        "    Module5.class,",
-        "    Module6.class,",
-        "    Module7.class,",
-        "    Module8.class,",
-        "    Module9.class,",
-        "    Module10.class,",
-        "    Module11.class,",
-        "    Module12.class",
-        "  })",
-        "  interface TestComponent {",
-        "    A getA();",
-        "  }",
-        "}");
-
-    String expectedError = "test.Outer.A is bound multiple times:\n"
-        + "      @Provides test.Outer.A test.Outer.Module1.provideA()\n"
-        + "      @Provides test.Outer.A test.Outer.Module2.provideA()\n"
-        + "      @Provides test.Outer.A test.Outer.Module3.provideA()\n"
-        + "      @Provides test.Outer.A test.Outer.Module4.provideA()\n"
-        + "      @Provides test.Outer.A test.Outer.Module5.provideA()\n"
-        + "      @Provides test.Outer.A test.Outer.Module6.provideA()\n"
-        + "      @Provides test.Outer.A test.Outer.Module7.provideA()\n"
-        + "      @Provides test.Outer.A test.Outer.Module8.provideA()\n"
-        + "      @Provides test.Outer.A test.Outer.Module9.provideA()\n"
-        + "      @Provides test.Outer.A test.Outer.Module10.provideA()\n"
-        + "      and 2 others";
-
-    assertAbout(javaSource()).that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedError).in(component).onLine(86);
-  }
-
-  @Test public void longChainOfDependencies() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestClass",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Lazy;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "import javax.inject.Named;",
-            "import javax.inject.Provider;",
-            "",
-            "final class TestClass {",
-            "  interface A {}",
-            "",
-            "  static class B {",
-            "    @Inject B(A a) {}",
-            "  }",
-            "",
-            "  static class C {",
-            "    @Inject B b;",
-            "    @Inject C(X x, B b) {}",
-            "  }",
-            "",
-            "  interface D { }",
-            "",
-            "  static class DImpl implements D {",
-            "    @Inject DImpl(C c, B b) {}",
-            "  }",
-            "",
-            "  static class X {",
-            "    @Inject X() {}",
-            "  }",
-            "",
-            "  @Module",
-            "  static class DModule {",
-            "    @Provides @Named(\"slim shady\") D d(X x1, DImpl impl, X x2) { return impl; }",
-            "  }",
-            "",
-            "  @Component(modules = { DModule.class })",
-            "  interface AComponent {",
-            "    @Named(\"slim shady\") D getFoo();",
-            "    C injectC(C c);",
-            "    Provider<C> cProvider();",
-            "    Lazy<C> lazyC();",
-            "    Provider<Lazy<C>> lazyCProvider();",
-            "  }",
-            "}");
-    String errorText = "test.TestClass.A cannot be provided without an @Provides-annotated method.";
-    String firstError =
-        Joiner.on("\n      ")
-            .join(
-                errorText,
-                "test.TestClass.A is injected at",
-                "    test.TestClass.B.<init>(a)",
-                "test.TestClass.B is injected at",
-                "    test.TestClass.C.b",
-                "test.TestClass.C is injected at",
-                "    test.TestClass.DImpl.<init>(c, )",
-                "test.TestClass.DImpl is injected at",
-                "    test.TestClass.DModule.d(, impl, )",
-                "@javax.inject.Named(\"slim shady\") test.TestClass.D is provided at",
-                "    test.TestClass.AComponent.getFoo()");
-    String otherErrorFormat =
-        Joiner.on("\n      ")
-            .join(
-                errorText,
-                "test.TestClass.A is injected at",
-                "    test.TestClass.B.<init>(a)",
-                "test.TestClass.B is injected at",
-                "    test.TestClass.C.b",
-                "test.TestClass.C is %s at",
-                "    test.TestClass.AComponent.%s");
-    assertAbout(javaSource())
-        .that(component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(firstError)
-        .in(component)
-        .onLine(40)
-        .and()
-        .withErrorContaining(String.format(otherErrorFormat, "injected", "injectC(c)"))
-        .in(component)
-        .onLine(41)
-        .and()
-        .withErrorContaining(String.format(otherErrorFormat, "provided", "cProvider()"))
-        .in(component)
-        .onLine(42)
-        .and()
-        .withErrorContaining(String.format(otherErrorFormat, "provided", "lazyC()"))
-        .in(component)
-        .onLine(43)
-        .and()
-        .withErrorContaining(String.format(otherErrorFormat, "provided", "lazyCProvider()"))
-        .in(component)
-        .onLine(44);
-  }
-
-  @Test
-  public void bindsMethodAppearsInTrace() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "TestComponent",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  TestInterface testInterface();",
-            "}");
-    JavaFileObject interfaceFile =
-        JavaFileObjects.forSourceLines("TestInterface", "interface TestInterface {}");
-    JavaFileObject implementationFile =
-        JavaFileObjects.forSourceLines(
-            "TestImplementation",
-            "import javax.inject.Inject;",
-            "",
-            "final class TestImplementation implements TestInterface {",
-            "  @Inject TestImplementation(String missingBinding) {}",
-            "}");
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "TestModule",
-            "import dagger.Binds;",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "interface TestModule {",
-            "  @Binds abstract TestInterface bindTestInterface(TestImplementation implementation);",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(component, module, interfaceFile, implementationFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            Joiner.on("\n      ")
-                .join(
-                    "java.lang.String cannot be provided without an @Inject constructor or from "
-                        + "an @Provides-annotated method.",
-                    "java.lang.String is injected at",
-                    "    TestImplementation.<init>(missingBinding)",
-                    "TestImplementation is injected at",
-                    "    TestModule.bindTestInterface(implementation)",
-                    "TestInterface is provided at",
-                    "    TestComponent.testInterface()"))
-        .in(component)
-        .onLine(5);
-  }
-
-  @Test
-  public void bindsMissingRightHandSide() {
-    JavaFileObject duplicates =
-        JavaFileObjects.forSourceLines(
-            "test.Duplicates",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.multibindings.IntKey;",
-            "import dagger.multibindings.IntoSet;",
-            "import dagger.multibindings.IntoMap;",
-            "import dagger.multibindings.LongKey;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "",
-            "interface Duplicates {",
-            "",
-            "  interface BoundTwice {}",
-            "",
-            "  class BoundImpl implements BoundTwice {",
-            "    @Inject BoundImpl() {}",
-            "  }",
-            "",
-            "  class NotBound implements BoundTwice {}",
-            "",
-            "  @Module",
-            "  abstract class DuplicatesModule {",
-            "    @Binds abstract BoundTwice bindWithResolvedKey(BoundImpl impl);",
-            "    @Binds abstract BoundTwice bindWithUnresolvedKey(NotBound notBound);",
-            "",
-            "    @Binds abstract Object bindObject(NotBound notBound);",
-            "",
-            "    @Binds @IntoSet abstract BoundTwice bindWithUnresolvedKey_set(NotBound notBound);",
-            "",
-            "    @Binds @IntoMap @IntKey(1)",
-            "    abstract BoundTwice bindWithUnresolvedKey_intMap(NotBound notBound);",
-            "",
-            "    @Provides @IntoMap @LongKey(2L)",
-            "    static BoundTwice provideWithUnresolvedKey_longMap(BoundImpl impl) {",
-            "      return impl;",
-            "    }",
-            "    @Binds @IntoMap @LongKey(2L)",
-            "    abstract BoundTwice bindWithUnresolvedKey_longMap(NotBound notBound);",
-            "  }",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.C",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import java.util.Set;",
-            "import java.util.Map;",
-            "import test.Duplicates.BoundTwice;",
-            "",
-            "@Component(modules = Duplicates.DuplicatesModule.class)",
-            "interface C {",
-            "  BoundTwice boundTwice();",
-            "  Object object();",
-            "  Set<BoundTwice> set();",
-            "  Map<Integer, BoundTwice> intMap();",
-            "  Map<Long, BoundTwice> longMap();",
-            "}");
-
-    assertThat(duplicates, component)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("test.Duplicates.BoundTwice is bound multiple times:")
-            .in(component).onLine(10)
-        .and().withErrorContaining("test.Duplicates.DuplicatesModule.bindWithUnresolvedKey")
-            .in(component).onLine(10)
-        .and().withErrorContaining("test.Duplicates.NotBound cannot be provided")
-            .in(component).onLine(11)
-        .and().withErrorContaining("test.Duplicates.NotBound cannot be provided")
-            .in(component).onLine(12)
-        .and().withErrorContaining("test.Duplicates.NotBound cannot be provided")
-            .in(component).onLine(13)
-        .and().withErrorContaining("same map key is bound more than once")
-            .in(component).onLine(14);
-  }
-
-  @Test public void resolvedParametersInDependencyTrace() {
-    JavaFileObject generic = JavaFileObjects.forSourceLines("test.Generic",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "import javax.inject.Provider;",
-        "",
-        "final class Generic<T> {",
-        "  @Inject Generic(T t) {}",
-        "}");
-    JavaFileObject testClass = JavaFileObjects.forSourceLines("test.TestClass",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "import java.util.List;",
-        "",
-        "final class TestClass {",
-        "  @Inject TestClass(List list) {}",
-        "}");
-    JavaFileObject usesTest = JavaFileObjects.forSourceLines("test.UsesTest",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class UsesTest {",
-        "  @Inject UsesTest(Generic<TestClass> genericTestClass) {}",
-        "}");
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "interface TestComponent {",
-        "  UsesTest usesTest();",
-        "}");
-    String expectedMsg =
-        Joiner.on("\n")
-            .join(
-                "java.util.List cannot be provided without an @Provides-annotated method.",
-                "      java.util.List is injected at",
-                "          test.TestClass.<init>(list)",
-                "      test.TestClass is injected at",
-                "          test.Generic.<init>(t)",
-                "      test.Generic<test.TestClass> is injected at",
-                "          test.UsesTest.<init>(genericTestClass)",
-                "      test.UsesTest is provided at",
-                "          test.TestComponent.usesTest()");
-    assertAbout(javaSources()).that(ImmutableList.of(generic, testClass, usesTest, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedMsg);
-  }
-
-  @Test public void resolvedVariablesInDependencyTrace() {
-    JavaFileObject generic = JavaFileObjects.forSourceLines("test.Generic",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "import javax.inject.Provider;",
-        "",
-        "final class Generic<T> {",
-        "  @Inject T t;",
-        "  @Inject Generic() {}",
-        "}");
-    JavaFileObject testClass = JavaFileObjects.forSourceLines("test.TestClass",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "import java.util.List;",
-        "",
-        "final class TestClass {",
-        "  @Inject TestClass(List list) {}",
-        "}");
-    JavaFileObject usesTest = JavaFileObjects.forSourceLines("test.UsesTest",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class UsesTest {",
-        "  @Inject UsesTest(Generic<TestClass> genericTestClass) {}",
-        "}");
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "interface TestComponent {",
-        "  UsesTest usesTest();",
-        "}");
-    String expectedMsg =
-        Joiner.on("\n")
-            .join(
-                "java.util.List cannot be provided without an @Provides-annotated method.",
-                "      java.util.List is injected at",
-                "          test.TestClass.<init>(list)",
-                "      test.TestClass is injected at",
-                "          test.Generic.t",
-                "      test.Generic<test.TestClass> is injected at",
-                "          test.UsesTest.<init>(genericTestClass)",
-                "      test.UsesTest is provided at",
-                "          test.TestComponent.usesTest()");
-    assertAbout(javaSources()).that(ImmutableList.of(generic, testClass, usesTest, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(expectedMsg);
-  }
-
-  @Test public void nullCheckForConstructorParameters() {
-    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class A {",
-        "  @Inject A(String string) {}",
-        "}");
-    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "@dagger.Module",
-        "final class TestModule {",
-        "  @Nullable @Provides String provideString() { return null; }",
-        "}");
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = TestModule.class)",
-        "interface TestComponent {",
-        "  A a();",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            nullableToNonNullable(
-                "java.lang.String",
-                "@test.Nullable @Provides String test.TestModule.provideString()"));
-
-    // but if we disable the validation, then it compiles fine.
-    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
-        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
-  }
-
-  @Test public void nullCheckForMembersInjectParam() {
-    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class A {",
-        "  @Inject A() {}",
-        "  @Inject void register(String string) {}",
-        "}");
-    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "@dagger.Module",
-        "final class TestModule {",
-        "  @Nullable @Provides String provideString() { return null; }",
-        "}");
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = TestModule.class)",
-        "interface TestComponent {",
-        "  A a();",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            nullableToNonNullable(
-                "java.lang.String",
-                "@test.Nullable @Provides String test.TestModule.provideString()"));
-
-    // but if we disable the validation, then it compiles fine.
-    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
-        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
-  }
-
-  @Test public void nullCheckForVariable() {
-    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class A {",
-        "  @Inject String string;",
-        "  @Inject A() {}",
-        "}");
-    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "@dagger.Module",
-        "final class TestModule {",
-        "  @Nullable @Provides String provideString() { return null; }",
-        "}");
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = TestModule.class)",
-        "interface TestComponent {",
-        "  A a();",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            nullableToNonNullable(
-                "java.lang.String",
-                "@test.Nullable @Provides String test.TestModule.provideString()"));
-
-    // but if we disable the validation, then it compiles fine.
-    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
-        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
-  }
-
-  @Test public void nullCheckForComponentReturn() {
-    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Provides;",
-        "import javax.inject.Inject;",
-        "",
-        "@dagger.Module",
-        "final class TestModule {",
-        "  @Nullable @Provides String provideString() { return null; }",
-        "}");
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(modules = TestModule.class)",
-        "interface TestComponent {",
-        "  String string();",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, module, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            nullableToNonNullable(
-                "java.lang.String",
-                "@test.Nullable @Provides String test.TestModule.provideString()"));
-
-    // but if we disable the validation, then it compiles fine.
-    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, module, component))
-        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
-  }
-
-  @Test
-  public void nullCheckForOptionalInstance() {
-    JavaFileObject a =
-        JavaFileObjects.forSourceLines(
-            "test.A",
-            "package test;",
-            "",
-            "import com.google.common.base.Optional;",
-            "import javax.inject.Inject;",
-            "",
-            "final class A {",
-            "  @Inject A(Optional<String> optional) {}",
-            "}");
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.BindsOptionalOf;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "",
-            "@dagger.Module",
-            "abstract class TestModule {",
-            "  @Nullable @Provides static String provideString() { return null; }",
-            "  @BindsOptionalOf abstract String optionalString();",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  A a();",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(NULLABLE, a, module, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            nullableToNonNullable(
-                "java.lang.String",
-                "@test.Nullable @Provides String test.TestModule.provideString()"));
-  }
-
-  @Test
-  public void nullCheckForOptionalProvider() {
-    JavaFileObject a =
-        JavaFileObjects.forSourceLines(
-            "test.A",
-            "package test;",
-            "",
-            "import com.google.common.base.Optional;",
-            "import javax.inject.Inject;",
-            "import javax.inject.Provider;",
-            "",
-            "final class A {",
-            "  @Inject A(Optional<Provider<String>> optional) {}",
-            "}");
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.BindsOptionalOf;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "",
-            "@dagger.Module",
-            "abstract class TestModule {",
-            "  @Nullable @Provides static String provideString() { return null; }",
-            "  @BindsOptionalOf abstract String optionalString();",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  A a();",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(NULLABLE, a, module, component))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
-  }
-
-  @Test
-  public void nullCheckForOptionalLazy() {
-    JavaFileObject a =
-        JavaFileObjects.forSourceLines(
-            "test.A",
-            "package test;",
-            "",
-            "import com.google.common.base.Optional;",
-            "import dagger.Lazy;",
-            "import javax.inject.Inject;",
-            "",
-            "final class A {",
-            "  @Inject A(Optional<Lazy<String>> optional) {}",
-            "}");
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.BindsOptionalOf;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "",
-            "@dagger.Module",
-            "abstract class TestModule {",
-            "  @Nullable @Provides static String provideString() { return null; }",
-            "  @BindsOptionalOf abstract String optionalString();",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  A a();",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(NULLABLE, a, module, component))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
-  }
-
-  @Test
-  public void nullCheckForOptionalProviderOfLazy() {
-    JavaFileObject a =
-        JavaFileObjects.forSourceLines(
-            "test.A",
-            "package test;",
-            "",
-            "import com.google.common.base.Optional;",
-            "import dagger.Lazy;",
-            "import javax.inject.Inject;",
-            "import javax.inject.Provider;",
-            "",
-            "final class A {",
-            "  @Inject A(Optional<Provider<Lazy<String>>> optional) {}",
-            "}");
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.BindsOptionalOf;",
-            "import dagger.Provides;",
-            "import javax.inject.Inject;",
-            "",
-            "@dagger.Module",
-            "abstract class TestModule {",
-            "  @Nullable @Provides static String provideString() { return null; }",
-            "  @BindsOptionalOf abstract String optionalString();",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  A a();",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(NULLABLE, a, module, component))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
-  }
-
-  @Test public void componentDependencyMustNotCycle_Direct() {
-    JavaFileObject shortLifetime = JavaFileObjects.forSourceLines("test.ComponentShort",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(dependencies = ComponentShort.class)",
-        "interface ComponentShort {",
-        "}");
-    String errorMessage =
-        "test.ComponentShort contains a cycle in its component dependencies:\n"
-            + "      test.ComponentShort";
-    assertAbout(javaSource())
-        .that(shortLifetime)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(errorMessage);
-  }
-
-  @Test public void componentDependencyMustNotCycle_Indirect() {
-    JavaFileObject longLifetime = JavaFileObjects.forSourceLines("test.ComponentLong",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(dependencies = ComponentMedium.class)",
-        "interface ComponentLong {",
-        "}");
-    JavaFileObject mediumLifetime = JavaFileObjects.forSourceLines("test.ComponentMedium",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(dependencies = ComponentLong.class)",
-        "interface ComponentMedium {",
-        "}");
-    JavaFileObject shortLifetime = JavaFileObjects.forSourceLines("test.ComponentShort",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component(dependencies = ComponentMedium.class)",
-        "interface ComponentShort {",
-        "}");
-    String longErrorMessage =
-        "test.ComponentLong contains a cycle in its component dependencies:\n"
-            + "      test.ComponentLong\n"
-            + "      test.ComponentMedium\n"
-            + "      test.ComponentLong";
-    String mediumErrorMessage =
-        "test.ComponentMedium contains a cycle in its component dependencies:\n"
-            + "      test.ComponentMedium\n"
-            + "      test.ComponentLong\n"
-            + "      test.ComponentMedium";
-    String shortErrorMessage =
-        "test.ComponentShort contains a cycle in its component dependencies:\n"
-            + "      test.ComponentMedium\n"
-            + "      test.ComponentLong\n"
-            + "      test.ComponentMedium\n"
-            + "      test.ComponentShort";
-    assertAbout(javaSources())
-        .that(ImmutableList.of(longLifetime, mediumLifetime, shortLifetime))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(longErrorMessage).in(longLifetime)
-        .and()
-        .withErrorContaining(mediumErrorMessage).in(mediumLifetime)
-        .and()
-        .withErrorContaining(shortErrorMessage).in(shortLifetime);
-  }
-
-  @Test
-  public void subcomponentBindingConflictsWithParent() {
-    JavaFileObject parentChildConflict =
-        JavaFileObjects.forSourceLines(
-            "test.ParentChildConflict",
-            "package test;",
-            "",
-            "import javax.inject.Qualifier;",
-            "",
-            "@Qualifier @interface ParentChildConflict {}");
-    JavaFileObject parentGrandchildConflict =
-        JavaFileObjects.forSourceLines(
-            "test.ParentGrandchildConflict",
-            "package test;",
-            "",
-            "import javax.inject.Qualifier;",
-            "",
-            "@Qualifier @interface ParentGrandchildConflict {}");
-    JavaFileObject childGrandchildConflict =
-        JavaFileObjects.forSourceLines(
-            "test.ChildGrandchildConflict",
-            "package test;",
-            "",
-            "import javax.inject.Qualifier;",
-            "",
-            "@Qualifier @interface ChildGrandchildConflict {}");
-
-    /* Some annotation processor implementations do not report more than one error per element. So
-     * separate parents for testing parent-conflicts-with-child and
-     * parent-conflicts-with-grandchild.
-     */
-    JavaFileObject parentConflictsWithChild =
-        JavaFileObjects.forSourceLines(
-            "test.ParentConflictsWithChild",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Component(modules = ParentConflictsWithChild.ParentModule.class)",
-            "interface ParentConflictsWithChild {",
-            "  @ParentChildConflict Object parentChildConflict();",
-            "",
-            "  Child child();",
-            "",
-            "  @Module",
-            "  static class ParentModule {",
-            "    @Provides @ParentChildConflict static Object parentChildConflict() {",
-            "      return \"parent\";",
-            "    }",
-            "  }",
-            "}");
-    JavaFileObject parentConflictsWithGrandchild =
-        JavaFileObjects.forSourceLines(
-            "test.ParentConflictsWithGrandchild",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Component(modules = ParentConflictsWithGrandchild.ParentModule.class)",
-            "interface ParentConflictsWithGrandchild {",
-            "  @ParentGrandchildConflict Object parentGrandchildConflict();",
-            "",
-            "  Child child();",
-            "",
-            "  @Module",
-            "  static class ParentModule {",
-            "    @Provides @ParentGrandchildConflict static Object parentGrandchildConflict() {",
-            "      return \"parent\";",
-            "    }",
-            "  }",
-            "}");
-    JavaFileObject child =
-        JavaFileObjects.forSourceLines(
-            "test.Child",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = Child.ChildModule.class)",
-            "interface Child {",
-            "  @ParentChildConflict Object parentChildConflict();",
-            "  @ChildGrandchildConflict Object childGrandchildConflict();",
-            "",
-            "  Grandchild grandchild();",
-            "",
-            "  @Module",
-            "  static class ChildModule {",
-            "    @Provides @ParentChildConflict static Object parentChildConflict() {",
-            "      return \"child\";",
-            "    }",
-            "",
-            "    @Provides @ChildGrandchildConflict static Object childGrandchildConflict() {",
-            "      return \"child\";",
-            "    }",
-            "  }",
-            "}");
-    JavaFileObject grandchild =
-        JavaFileObjects.forSourceLines(
-            "test.Grandchild",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = Grandchild.GrandchildModule.class)",
-            "interface Grandchild {",
-            "  @ParentChildConflict Object parentChildConflict();",
-            "  @ParentGrandchildConflict Object parentGrandchildConflict();",
-            "  @ChildGrandchildConflict Object childGrandchildConflict();",
-            "",
-            "  @Module",
-            "  static class GrandchildModule {",
-            "    @Provides @ParentGrandchildConflict static Object parentGrandchildConflict() {",
-            "      return \"grandchild\";",
-            "    }",
-            "",
-            "    @Provides @ChildGrandchildConflict static Object childGrandchildConflict() {",
-            "      return \"grandchild\";",
-            "    }",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(
-            ImmutableList.of(
-                parentChildConflict,
-                parentGrandchildConflict,
-                childGrandchildConflict,
-                parentConflictsWithChild,
-                parentConflictsWithGrandchild,
-                child,
-                grandchild))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            "[test.Child.parentChildConflict()] "
-                + "@test.ParentChildConflict java.lang.Object is bound multiple times:\n"
-                + "      @Provides @test.ParentChildConflict Object"
-                + " test.ParentConflictsWithChild.ParentModule.parentChildConflict()\n"
-                + "      @Provides @test.ParentChildConflict Object"
-                + " test.Child.ChildModule.parentChildConflict()")
-        .in(parentConflictsWithChild)
-        .onLine(8)
-        .and()
-        .withErrorContaining(
-            "[test.Grandchild.parentGrandchildConflict()] "
-                + "@test.ParentGrandchildConflict java.lang.Object is bound multiple times:\n"
-                + "      @Provides @test.ParentGrandchildConflict Object"
-                + " test.ParentConflictsWithGrandchild.ParentModule.parentGrandchildConflict()\n"
-                + "      @Provides @test.ParentGrandchildConflict Object"
-                + " test.Grandchild.GrandchildModule.parentGrandchildConflict()")
-        .in(parentConflictsWithGrandchild)
-        .onLine(8)
-        .and()
-        .withErrorContaining(
-            "[test.Grandchild.childGrandchildConflict()] "
-                + "@test.ChildGrandchildConflict java.lang.Object is bound multiple times:\n"
-                + "      @Provides @test.ChildGrandchildConflict Object"
-                + " test.Child.ChildModule.childGrandchildConflict()\n"
-                + "      @Provides @test.ChildGrandchildConflict Object"
-                + " test.Grandchild.GrandchildModule.childGrandchildConflict()")
-        .in(child)
-        .onLine(8);
-  }
-
-  @Test
-  public void subcomponentBindingConflictsWithParentWithNullableViolationAsWarning() {
-    JavaFileObject parentConflictsWithChild =
-        JavaFileObjects.forSourceLines(
-            "test.ParentConflictsWithChild",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import javax.annotation.Nullable;",
-            "",
-            "@Component(modules = ParentConflictsWithChild.ParentModule.class)",
-            "interface ParentConflictsWithChild {",
-            "  Child child();",
-            "",
-            "  @Module",
-            "  static class ParentModule {",
-            "    @Provides @Nullable static Object nullableParentChildConflict() {",
-            "      return \"parent\";",
-            "    }",
-            "  }",
-            "}");
-    JavaFileObject child =
-        JavaFileObjects.forSourceLines(
-            "test.Child",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = Child.ChildModule.class)",
-            "interface Child {",
-            "  Object parentChildConflictThatViolatesNullability();",
-            "",
-            "  @Module",
-            "  static class ChildModule {",
-            "    @Provides static Object nonNullableParentChildConflict() {",
-            "      return \"child\";",
-            "    }",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(parentConflictsWithChild, child))
-        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            "[test.Child.parentChildConflictThatViolatesNullability()] "
-                + "java.lang.Object is bound multiple times:\n"
-                + "      @Provides @javax.annotation.Nullable Object"
-                + " test.ParentConflictsWithChild.ParentModule.nullableParentChildConflict()\n"
-                + "      @Provides Object"
-                + " test.Child.ChildModule.nonNullableParentChildConflict()")
-        .in(parentConflictsWithChild)
-        .onLine(9);
-  }
-
-  @Test
-  public void bindingUsedOnlyInSubcomponentDependsOnBindingOnlyInSubcomponent() {
-    JavaFileObject parent =
-        JavaFileObjects.forSourceLines(
-            "Parent",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = ParentModule.class)",
-            "interface Parent {",
-            "  Child child();",
-            "}");
-    JavaFileObject parentModule =
-        JavaFileObjects.forSourceLines(
-            "ParentModule",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class ParentModule {",
-            "  @Provides static Object needsString(String string) {",
-            "    return \"needs string: \" + string;",
-            "  }",
-            "}");
-    JavaFileObject child =
-        JavaFileObjects.forSourceLines(
-            "Child",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = ChildModule.class)",
-            "interface Child {",
-            "  String string();",
-            "  Object needsString();",
-            "}");
-    JavaFileObject childModule =
-        JavaFileObjects.forSourceLines(
-            "ChildModule",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class ChildModule {",
-            "  @Provides static String string() {",
-            "    return \"child string\";",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(parent, parentModule, child, childModule))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("[Child.needsString()] java.lang.String cannot be provided")
-        .in(parent)
-        .onLine(4);
-  }
-
-  @Test
-  public void multibindingContributionBetweenAncestorComponentAndEntrypointComponent() {
-    JavaFileObject parent =
-        JavaFileObjects.forSourceLines(
-            "Parent",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = ParentModule.class)",
-            "interface Parent {",
-            "  Child child();",
-            "}");
-    JavaFileObject child =
-        JavaFileObjects.forSourceLines(
-            "Child",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = ChildModule.class)",
-            "interface Child {",
-            "  Grandchild grandchild();",
-            "}");
-    JavaFileObject grandchild =
-        JavaFileObjects.forSourceLines(
-            "Grandchild",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Grandchild {",
-            "  Object object();",
-            "}");
-
-    JavaFileObject parentModule =
-        JavaFileObjects.forSourceLines(
-            "ParentModule",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "class ParentModule {",
-            "  @Provides static Object dependsOnSet(Set<String> strings) {",
-            "    return \"needs strings: \" + strings;",
-            "  }",
-            "",
-            "  @Provides @IntoSet static String contributesToSet() {",
-            "    return \"parent string\";",
-            "  }",
-            "",
-            "  @Provides int missingDependency(double dub) {",
-            "    return 4;",
-            "  }",
-            "}");
-    JavaFileObject childModule =
-        JavaFileObjects.forSourceLines(
-            "ChildModule",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoSet;",
-            "",
-            "@Module",
-            "class ChildModule {",
-            "  @Provides @IntoSet static String contributesToSet(int i) {",
-            "    return \"\" + i;",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(parent, parentModule, child, childModule, grandchild))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("[Grandchild.object()] java.lang.Double cannot be provided")
-        .in(parent)
-        .onLine(4);
-  }
-
-  @Test
-  public void missingReleasableReferenceManager() {
-    JavaFileObject testScope =
-        JavaFileObjects.forSourceLines(
-            "test.TestScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@CanReleaseReferences",
-            "@BadMetadata",
-            "@Scope",
-            "@Retention(RUNTIME)",
-            "@interface TestScope {}");
-    JavaFileObject otherScope =
-        JavaFileObjects.forSourceLines(
-            "test.OtherScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@CanReleaseReferences",
-            "@Scope",
-            "@Retention(RUNTIME)",
-            "@interface OtherScope {}");
-    JavaFileObject yetAnotherScope =
-        JavaFileObjects.forSourceLines(
-            "test.YetAnotherScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@CanReleaseReferences",
-            "@Scope",
-            "@Retention(RUNTIME)",
-            "@interface YetAnotherScope {}");
-    JavaFileObject testMetadata =
-        JavaFileObjects.forSourceLines(
-            "test.TestMetadata",
-            "package test;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "",
-            "@CanReleaseReferences",
-            "@interface TestMetadata {}");
-    JavaFileObject badMetadata =
-        JavaFileObjects.forSourceLines(
-            "test.BadMetadata", // force one-string-per-line format
-            "package test;",
-            "",
-            "@interface BadMetadata {}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.ReleasableReferenceManager;",
-            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
-            "",
-            "@TestScope",
-            "@YetAnotherScope",
-            "@Component",
-            "interface TestComponent {",
-            "  @ForReleasableReferences(OtherScope.class)",
-            "  ReleasableReferenceManager otherManager();",
-            "",
-            "  @ForReleasableReferences(TestScope.class)",
-            "  TypedReleasableReferenceManager<TestMetadata> typedManager();",
-            "",
-            "  @ForReleasableReferences(TestScope.class)",
-            "  TypedReleasableReferenceManager<BadMetadata> badManager();",
-            "}");
-    assertAbout(javaSources())
-        .that(
-            ImmutableList.of(
-                testScope, otherScope, yetAnotherScope, testMetadata, badMetadata, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            "There is no binding for "
-                + "@dagger.releasablereferences.ForReleasableReferences(test.OtherScope.class) "
-                + "dagger.releasablereferences.ReleasableReferenceManager "
-                + "because no component in test.TestComponent's component hierarchy is annotated "
-                + "with @test.OtherScope. "
-                + "The available reference-releasing scopes are "
-                + "[@test.TestScope, @test.YetAnotherScope].")
-        .in(component)
-        .onLine(13)
-        .and()
-        .withErrorContaining(
-            "There is no binding for "
-                + "@dagger.releasablereferences.ForReleasableReferences(test.TestScope.class) "
-                + "dagger.releasablereferences.TypedReleasableReferenceManager<test.TestMetadata> "
-                + "because test.TestScope is not annotated with @test.TestMetadata")
-        .in(component)
-        .onLine(16)
-        .and()
-        .withErrorContaining(
-            "There is no binding for "
-                + "@dagger.releasablereferences.ForReleasableReferences(test.TestScope.class) "
-                + "dagger.releasablereferences.TypedReleasableReferenceManager<test.BadMetadata> "
-                + "because test.BadMetadata is not annotated with "
-                + "@dagger.releasablereferences.CanReleaseReferences")
-        .in(component)
-        .onLine(19);
-  }
-
-  @Test
-  public void releasableReferenceManagerConflict() {
-    JavaFileObject testScope =
-        JavaFileObjects.forSourceLines(
-            "test.TestScope",
-            "package test;",
-            "",
-            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "import java.lang.annotation.Retention;",
-            "import javax.inject.Scope;",
-            "",
-            "@TestMetadata",
-            "@CanReleaseReferences",
-            "@Scope",
-            "@Retention(RUNTIME)",
-            "@interface TestScope {}");
-    JavaFileObject testMetadata =
-        JavaFileObjects.forSourceLines(
-            "test.TestMetadata",
-            "package test;",
-            "",
-            "import dagger.releasablereferences.CanReleaseReferences;",
-            "",
-            "@CanReleaseReferences",
-            "@interface TestMetadata {}");
-
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.ReleasableReferenceManager;",
-            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "abstract class TestModule {",
-            "  @Provides @ForReleasableReferences(TestScope.class)",
-            "  static ReleasableReferenceManager rrm() {",
-            "    return null;",
-            "  }",
-            "",
-            "  @Provides @ForReleasableReferences(TestScope.class)",
-            "  static TypedReleasableReferenceManager<TestMetadata> typedRrm() {",
-            "    return null;",
-            "  }",
-            "",
-            "  @Provides",
-            "  static Set<ReleasableReferenceManager> rrmSet() {",
-            "    return null;",
-            "  }",
-            "",
-            "  @Provides",
-            "  static Set<TypedReleasableReferenceManager<TestMetadata>> typedRrmSet() {",
-            "    return null;",
-            "  }",
-            "}");
-
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.releasablereferences.ForReleasableReferences;",
-            "import dagger.releasablereferences.ReleasableReferenceManager;",
-            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
-            "import java.util.Set;",
-            "",
-            "@TestScope",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  @ForReleasableReferences(TestScope.class)",
-            "  ReleasableReferenceManager testManager();",
-            "",
-            "  @ForReleasableReferences(TestScope.class)",
-            "  TypedReleasableReferenceManager<TestMetadata> typedManager();",
-            "",
-            "  Set<ReleasableReferenceManager> managers();",
-            "  Set<TypedReleasableReferenceManager<TestMetadata>> typedManagers();",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(testScope, testMetadata, testModule, component))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(
-                error(
-                    "@%1$s.ForReleasableReferences(test.TestScope.class) "
-                        + "%1$s.ReleasableReferenceManager is bound multiple times:",
-                    "@Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
-                        + "%1$s.ReleasableReferenceManager test.TestModule.rrm()",
-                    "binding for "
-                        + "@%1$s.ForReleasableReferences(value = test.TestScope.class) "
-                        + "%1$s.ReleasableReferenceManager from the scope declaration"),
-                "dagger.releasablereferences"))
-        .in(component)
-        .onLine(13)
-        .and()
-        .withErrorContaining(
-            String.format(
-                error(
-                    "@%1$s.ForReleasableReferences(test.TestScope.class) "
-                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
-                        + "is bound multiple times:",
-                    "@Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
-                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
-                        + "test.TestModule.typedRrm()",
-                    "binding for "
-                        + "@%1$s.ForReleasableReferences(value = test.TestScope.class) "
-                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
-                        + "from the scope declaration"),
-                "dagger.releasablereferences"))
-        .in(component)
-        .onLine(16)
-        .and()
-        .withErrorContaining(
-            error(
-                "java.util.Set<dagger.releasablereferences.ReleasableReferenceManager> "
-                    + "is bound multiple times:",
-                "@Provides "
-                    + "Set<dagger.releasablereferences.ReleasableReferenceManager> "
-                    + "test.TestModule.rrmSet()",
-                "Dagger-generated binding for "
-                    + "Set<dagger.releasablereferences.ReleasableReferenceManager>"))
-        .in(component)
-        .onLine(18)
-        .and()
-        .withErrorContaining(
-            String.format(
-                error(
-                    "java.util.Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>> "
-                        + "is bound multiple times:",
-                    "@Provides "
-                        + "Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>> "
-                        + "test.TestModule.typedRrmSet()",
-                    "Dagger-generated binding for "
-                        + "Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>>"),
-                "dagger.releasablereferences"))
-        .in(component)
-        .onLine(19);
-  }
-
-  private String error(String... lines) {
-    return Joiner.on("\n      ").join(lines);
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java b/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java
deleted file mode 100644
index b57fcb3a1..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/InaccessibleTypeTest.java
+++ /dev/null
@@ -1,275 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-
-import com.google.common.collect.ImmutableList;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class InaccessibleTypeTest {
-  @Test public void basicInjectedType() {
-    JavaFileObject noDepClassFile = JavaFileObjects.forSourceLines("foreign.NoDepClass",
-        "package foreign;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "public final class NoDepClass {",
-        "  @Inject NoDepClass() {}",
-        "}");
-    JavaFileObject publicClassFile = JavaFileObjects.forSourceLines("foreign.PublicClass",
-        "package foreign;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "public final class PublicClass {",
-        "  @Inject PublicClass(NonPublicClass1 dep1, NonPublicClass2 dep2, NoDepClass dep3) {}",
-        "}");
-    JavaFileObject nonPublicClass1File = JavaFileObjects.forSourceLines("foreign.NonPublicClass1",
-        "package foreign;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class NonPublicClass1 {",
-        "  @Inject NonPublicClass1(NoDepClass dep) {}",
-        "}");
-    JavaFileObject nonPublicClass2File = JavaFileObjects.forSourceLines("foreign.NonPublicClass2",
-        "package foreign;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class NonPublicClass2 {",
-        "  @Inject NonPublicClass2(NoDepClass dep) {}",
-        "}");
-
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import foreign.PublicClass;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface TestComponent {",
-        "  PublicClass publicClass();",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import foreign.NoDepClass_Factory;",
-            "import foreign.NonPublicClass1_Factory;",
-            "import foreign.NonPublicClass2_Factory;",
-            "import foreign.PublicClass;",
-            "import foreign.PublicClass_Factory;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  @SuppressWarnings(\"rawtypes\")",
-            "  private Provider nonPublicClass1Provider;",
-            "  @SuppressWarnings(\"rawtypes\")",
-            "  private Provider nonPublicClass2Provider;",
-            "  private Provider<PublicClass> publicClassProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.nonPublicClass1Provider =",
-            "        NonPublicClass1_Factory.create(NoDepClass_Factory.create());",
-            "    this.nonPublicClass2Provider =",
-            "        NonPublicClass2_Factory.create(NoDepClass_Factory.create());",
-            "    this.publicClassProvider = PublicClass_Factory.create(",
-            "        nonPublicClass1Provider,",
-            "        nonPublicClass2Provider,",
-            "        NoDepClass_Factory.create());",
-            "  }",
-            "",
-            "  @Override",
-            "  public PublicClass publicClass() {",
-            "    return PublicClass_Factory.newPublicClass(",
-            "        NonPublicClass1_Factory.newNonPublicClass1(",
-            "            NoDepClass_Factory.newNoDepClass()),",
-            "        NonPublicClass2_Factory.newNonPublicClass2(",
-            "            NoDepClass_Factory.newNoDepClass()),",
-            "        NoDepClass_Factory.newNoDepClass());",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(
-            ImmutableList.of(
-                noDepClassFile,
-                publicClassFile,
-                nonPublicClass1File,
-                nonPublicClass2File,
-                componentFile))
-        .withCompilerOptions(
-            "-Xlint:-processing",
-            "-Xlint:rawtypes",
-            "-Xlint:unchecked",
-            "-Werror")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(generatedComponent);
-  }
-
-  @Test public void memberInjectedType() {
-    JavaFileObject noDepClassFile = JavaFileObjects.forSourceLines("test.NoDepClass",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "public final class NoDepClass {",
-        "  @Inject NoDepClass() {}",
-        "}");
-    JavaFileObject aClassFile = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
-        "",
-        "import foreign.B;",
-        "import javax.inject.Inject;",
-        "",
-        "final class A extends B {",
-        "  @Inject NoDepClass dep;",
-        "}");
-    JavaFileObject bClassFile = JavaFileObjects.forSourceLines("foreign.B",
-        "package foreign;",
-        "",
-        "import test.NoDepClass;",
-        "import javax.inject.Inject;",
-        "",
-        "public class B extends C {",
-        "  @Inject NoDepClass dep;",
-        "}");
-    JavaFileObject cClassFile = JavaFileObjects.forSourceLines("foreign.C",
-        "package foreign;",
-        "",
-        "import test.D;",
-        "import test.NoDepClass;",
-        "import javax.inject.Inject;",
-        "",
-        "class C extends D {",
-        "  @Inject NoDepClass dep;",
-        "}");
-    JavaFileObject dClassFile = JavaFileObjects.forSourceLines("test.D",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "public class D {",
-        "  @Inject NoDepClass dep;",
-        "}");
-
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface TestComponent {",
-        "  void injectA(A a);",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.MembersInjector;",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private MembersInjector<A> aMembersInjector;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "     this.aMembersInjector = A_MembersInjector.create(NoDepClass_Factory.create());",
-            "  }",
-            "",
-            "  @Override",
-            "  public void injectA(A a) {",
-            "    aMembersInjector.injectMembers(a);",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(
-            ImmutableList.of(
-                noDepClassFile, aClassFile, bClassFile, cClassFile, dClassFile, componentFile))
-        .withCompilerOptions(
-            "-Xlint:-processing",
-            "-Xlint:rawtypes",
-            "-Xlint:unchecked",
-            "-Werror")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(generatedComponent);
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
deleted file mode 100644
index 46ffa2f60..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/MapBindingComponentProcessorTest.java
+++ /dev/null
@@ -1,880 +0,0 @@
-/*
- * Copyright (C) 2014 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-
-import com.google.auto.value.processor.AutoAnnotationProcessor;
-import com.google.common.collect.ImmutableList;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class MapBindingComponentProcessorTest {
-
-  @Test
-  public void mapBindingsWithEnumKey() {
-    JavaFileObject mapModuleOneFile =
-        JavaFileObjects
-            .forSourceLines("test.MapModuleOne",
-                "package test;",
-                "",
-                "import dagger.Module;",
-                "import dagger.Provides;",
-                "import dagger.multibindings.IntoMap;",
-                "",
-                "@Module",
-                "final class MapModuleOne {",
-                "  @Provides @IntoMap @PathKey(PathEnum.ADMIN) Handler provideAdminHandler() {",
-                "    return new AdminHandler();",
-                "  }",
-                "}");
-    JavaFileObject mapModuleTwoFile =
-        JavaFileObjects
-            .forSourceLines("test.MapModuleTwo",
-                "package test;",
-                "",
-                "import dagger.Module;",
-                "import dagger.Provides;",
-                "import dagger.multibindings.IntoMap;",
-                "",
-                "@Module",
-                "final class MapModuleTwo {",
-                "  @Provides @IntoMap @PathKey(PathEnum.LOGIN) Handler provideLoginHandler() {",
-                "    return new LoginHandler();",
-                "  }",
-                "}");
-    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
-        "package test;",
-        "import dagger.MapKey;",
-        "import java.lang.annotation.Retention;",
-        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-        "",
-        "@MapKey(unwrapValue = true)",
-        "@Retention(RUNTIME)",
-        "public @interface PathKey {",
-        "  PathEnum value();",
-        "}");
-    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
-        "package test;",
-        "",
-        "public enum PathEnum {",
-        "    ADMIN,",
-        "    LOGIN;",
-        "}");
-
-    JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler",
-        "package test;",
-        "",
-        "interface Handler {}");
-    JavaFileObject LoginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
-        "package test;",
-        "",
-        "class LoginHandler implements Handler {",
-        "  public LoginHandler() {}",
-        "}");
-    JavaFileObject AdminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
-        "package test;",
-        "",
-        "class AdminHandler implements Handler {",
-        "  public AdminHandler() {}",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import java.util.Map;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
-        "interface TestComponent {",
-        "  Map<PathEnum, Provider<Handler>> dispatcher();",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.internal.MapProviderFactory;",
-            "import dagger.internal.Preconditions;",
-            "import java.util.Map;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<Handler> provideAdminHandlerProvider;",
-            "  private Provider<Handler> provideLoginHandlerProvider;",
-            "  private Provider<Map<PathEnum, Provider<Handler>>>",
-            "      mapOfPathEnumAndProviderOfHandlerProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.provideAdminHandlerProvider =",
-            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-            "    this.provideLoginHandlerProvider =",
-            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-            "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
-            "        MapProviderFactory.<PathEnum, Handler>builder(2)",
-            "            .put(PathEnum.ADMIN, provideAdminHandlerProvider)",
-            "            .put(PathEnum.LOGIN, provideLoginHandlerProvider)",
-            "            .build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<PathEnum, Provider<Handler>> dispatcher() {",
-            "    return mapOfPathEnumAndProviderOfHandlerProvider.get();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private MapModuleOne mapModuleOne;",
-            "    private MapModuleTwo mapModuleTwo;",
-            "",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      if (mapModuleOne == null) {",
-            "        this.mapModuleOne = new MapModuleOne();",
-            "      }",
-            "      if (mapModuleTwo == null) {",
-            "        this.mapModuleTwo = new MapModuleTwo();",
-            "      }",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "",
-            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-            "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
-            "      return this;",
-            "    }",
-            "",
-            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-            "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(mapModuleOneFile,
-            mapModuleTwoFile,
-            enumKeyFile,
-            pathEnumFile,
-            HandlerFile,
-            LoginHandlerFile,
-            AdminHandlerFile,
-            componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(generatedComponent);
-  }
-
-  @Test
-  public void mapBindingsWithStringKey() {
-    JavaFileObject mapModuleOneFile =
-        JavaFileObjects
-            .forSourceLines("test.MapModuleOne",
-                "package test;",
-                "",
-                "import dagger.Module;",
-                "import dagger.Provides;",
-                "import dagger.multibindings.StringKey;",
-                "import dagger.multibindings.IntoMap;",
-                "",
-                "@Module",
-                "final class MapModuleOne {",
-                "  @Provides @IntoMap @StringKey(\"Admin\") Handler provideAdminHandler() {",
-                "    return new AdminHandler();",
-                "  }",
-                "}");
-    JavaFileObject mapModuleTwoFile =
-        JavaFileObjects
-            .forSourceLines("test.MapModuleTwo",
-                "package test;",
-                "",
-                "import dagger.Module;",
-                "import dagger.Provides;",
-                "import dagger.multibindings.IntoMap;",
-                "import dagger.multibindings.StringKey;",
-                "",
-                "@Module",
-                "final class MapModuleTwo {",
-                "  @Provides @IntoMap @StringKey(\"Login\") Handler provideLoginHandler() {",
-                "    return new LoginHandler();",
-                "  }",
-                "}");
-    JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler",
-        "package test;",
-        "",
-        "interface Handler {}");
-    JavaFileObject LoginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
-        "package test;",
-        "",
-        "class LoginHandler implements Handler {",
-        "  public LoginHandler() {}",
-        "}");
-    JavaFileObject AdminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
-        "package test;",
-        "",
-        "class AdminHandler implements Handler {",
-        "  public AdminHandler() {}",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import java.util.Map;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
-        "interface TestComponent {",
-        "  Map<String, Provider<Handler>> dispatcher();",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.internal.MapProviderFactory;",
-            "import dagger.internal.Preconditions;",
-            "import java.util.Map;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<Handler> provideAdminHandlerProvider;",
-            "  private Provider<Handler> provideLoginHandlerProvider;",
-            "  private Provider<Map<String, Provider<Handler>>>",
-            "      mapOfStringAndProviderOfHandlerProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.provideAdminHandlerProvider =",
-            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-            "    this.provideLoginHandlerProvider =",
-            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-            "    this.mapOfStringAndProviderOfHandlerProvider =",
-            "        MapProviderFactory.<String, Handler>builder(2)",
-            "            .put(\"Admin\", provideAdminHandlerProvider)",
-            "            .put(\"Login\", provideLoginHandlerProvider)",
-            "            .build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<String, Provider<Handler>> dispatcher() {",
-            "    return mapOfStringAndProviderOfHandlerProvider.get();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private MapModuleOne mapModuleOne;",
-            "    private MapModuleTwo mapModuleTwo;",
-            "",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      if (mapModuleOne == null) {",
-            "        this.mapModuleOne = new MapModuleOne();",
-            "      }",
-            "      if (mapModuleTwo == null) {",
-            "        this.mapModuleTwo = new MapModuleTwo();",
-            "      }",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "",
-            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-            "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
-            "      return this;",
-            "    }",
-            "",
-            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-            "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(mapModuleOneFile,
-            mapModuleTwoFile,
-            HandlerFile,
-            LoginHandlerFile,
-            AdminHandlerFile,
-            componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(generatedComponent);
-  }
-
-  @Test
-  public void mapBindingsWithWrappedKey() {
-    JavaFileObject mapModuleOneFile =
-        JavaFileObjects
-            .forSourceLines("test.MapModuleOne",
-                "package test;",
-                "",
-                "import dagger.Module;",
-                "import dagger.Provides;",
-                "import dagger.multibindings.IntoMap;",
-                "",
-                "@Module",
-                "final class MapModuleOne {",
-                "  @Provides @IntoMap",
-                "  @WrappedClassKey(Integer.class) Handler provideAdminHandler() {",
-                "    return new AdminHandler();",
-                "  }",
-                "}");
-    JavaFileObject mapModuleTwoFile =
-        JavaFileObjects
-            .forSourceLines("test.MapModuleTwo",
-                "package test;",
-                "",
-                "import dagger.Module;",
-                "import dagger.Provides;",
-                "import dagger.multibindings.IntoMap;",
-                "",
-                "@Module",
-                "final class MapModuleTwo {",
-                "  @Provides @IntoMap",
-                "  @WrappedClassKey(Long.class) Handler provideLoginHandler() {",
-                "    return new LoginHandler();",
-                "  }",
-                "}");
-    JavaFileObject wrappedClassKeyFile = JavaFileObjects.forSourceLines("test.WrappedClassKey",
-        "package test;",
-        "import dagger.MapKey;",
-        "import java.lang.annotation.Retention;",
-        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-        "",
-        "@MapKey(unwrapValue = false)",
-        "@Retention(RUNTIME)",
-        "public @interface WrappedClassKey {",
-        "  Class<?> value();",
-        "}");
-    JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler",
-        "package test;",
-        "",
-        "interface Handler {}");
-    JavaFileObject LoginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
-        "package test;",
-        "",
-        "class LoginHandler implements Handler {",
-        "  public LoginHandler() {}",
-        "}");
-    JavaFileObject AdminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
-        "package test;",
-        "",
-        "class AdminHandler implements Handler {",
-        "  public AdminHandler() {}",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import java.util.Map;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
-        "interface TestComponent {",
-        "  Map<WrappedClassKey, Provider<Handler>> dispatcher();",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.internal.MapProviderFactory;",
-            "import dagger.internal.Preconditions;",
-            "import java.util.Map;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<Handler> provideAdminHandlerProvider;",
-            "  private Provider<Handler> provideLoginHandlerProvider;",
-            "  private Provider<Map<WrappedClassKey, Provider<Handler>>>",
-            "      mapOfWrappedClassKeyAndProviderOfHandlerProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.provideAdminHandlerProvider =",
-            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-            "    this.provideLoginHandlerProvider =",
-            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-            "    this.mapOfWrappedClassKeyAndProviderOfHandlerProvider =",
-            "        MapProviderFactory.<WrappedClassKey, Handler>builder(2)",
-            "            .put(WrappedClassKeyCreator.createWrappedClassKey(Integer.class),",
-            "                provideAdminHandlerProvider)",
-            "            .put(WrappedClassKeyCreator.createWrappedClassKey(Long.class),",
-            "                provideLoginHandlerProvider)",
-            "            .build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<WrappedClassKey, Provider<Handler>> dispatcher() {",
-            "    return mapOfWrappedClassKeyAndProviderOfHandlerProvider.get();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private MapModuleOne mapModuleOne;",
-            "    private MapModuleTwo mapModuleTwo;",
-            "",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      if (mapModuleOne == null) {",
-            "        this.mapModuleOne = new MapModuleOne();",
-            "      }",
-            "      if (mapModuleTwo == null) {",
-            "        this.mapModuleTwo = new MapModuleTwo();",
-            "      }",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "",
-            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-            "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
-            "      return this;",
-            "    }",
-            "",
-            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-            "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(mapModuleOneFile,
-            mapModuleTwoFile,
-            wrappedClassKeyFile,
-            HandlerFile,
-            LoginHandlerFile,
-            AdminHandlerFile,
-            componentFile))
-        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(generatedComponent);
-  }
-
-  @Test
-  public void mapBindingsWithNonProviderValue() {
-    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.multibindings.IntoMap;",
-        "",
-        "@Module",
-        "final class MapModuleOne {",
-        "  @Provides @IntoMap @PathKey(PathEnum.ADMIN) Handler provideAdminHandler() {",
-        "    return new AdminHandler();",
-        "  }",
-        "}");
-    JavaFileObject mapModuleTwoFile = JavaFileObjects.forSourceLines("test.MapModuleTwo",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.multibindings.IntoMap;",
-        "",
-        "@Module",
-        "final class MapModuleTwo {",
-        "  @Provides @IntoMap @PathKey(PathEnum.LOGIN) Handler provideLoginHandler() {",
-        "    return new LoginHandler();",
-        "  }",
-        "}");
-    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
-        "package test;",
-        "import dagger.MapKey;",
-        "import java.lang.annotation.Retention;",
-        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-        "",
-        "@MapKey(unwrapValue = true)",
-        "@Retention(RUNTIME)",
-        "public @interface PathKey {",
-        "  PathEnum value();",
-        "}");
-    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
-        "package test;",
-        "",
-        "public enum PathEnum {",
-        "    ADMIN,",
-        "    LOGIN;",
-        "}");
-    JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler",
-        "package test;",
-        "",
-        "interface Handler {}");
-    JavaFileObject LoginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
-        "package test;",
-        "",
-        "class LoginHandler implements Handler {",
-        "  public LoginHandler() {}",
-        "}");
-    JavaFileObject AdminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
-        "package test;",
-        "",
-        "class AdminHandler implements Handler {",
-        "  public AdminHandler() {}",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import java.util.Map;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
-        "interface TestComponent {",
-        "  Map<PathEnum, Handler> dispatcher();",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.internal.MapFactory;",
-            "import dagger.internal.MapProviderFactory;",
-            "import dagger.internal.Preconditions;",
-            "import java.util.Map;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<Handler> provideAdminHandlerProvider;",
-            "  private Provider<Handler> provideLoginHandlerProvider;",
-            "  private Provider<Map<PathEnum, Provider<Handler>>>",
-            "      mapOfPathEnumAndProviderOfHandlerProvider;",
-            "  private Provider<Map<PathEnum, Handler>> mapOfPathEnumAndHandlerProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.provideAdminHandlerProvider =",
-            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-            "    this.provideLoginHandlerProvider =",
-            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-            "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
-            "        MapProviderFactory.<PathEnum, Handler>builder(2)",
-            "            .put(PathEnum.ADMIN, provideAdminHandlerProvider)",
-            "            .put(PathEnum.LOGIN, provideLoginHandlerProvider)",
-            "            .build();",
-            "    this.mapOfPathEnumAndHandlerProvider =",
-            "        MapFactory.create(mapOfPathEnumAndProviderOfHandlerProvider);",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<PathEnum, Handler> dispatcher() {",
-            "    return mapOfPathEnumAndHandlerProvider.get();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private MapModuleOne mapModuleOne;",
-            "    private MapModuleTwo mapModuleTwo;",
-            "",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      if (mapModuleOne == null) {",
-            "        this.mapModuleOne = new MapModuleOne();",
-            "      }",
-            "      if (mapModuleTwo == null) {",
-            "        this.mapModuleTwo = new MapModuleTwo();",
-            "      }",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "",
-            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-            "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
-            "      return this;",
-            "    }",
-            "",
-            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-            "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(mapModuleOneFile,
-            mapModuleTwoFile,
-            enumKeyFile,
-            pathEnumFile,
-            HandlerFile,
-            LoginHandlerFile,
-            AdminHandlerFile,
-            componentFile)).
-        processedWith(new ComponentProcessor())
-            .compilesWithoutError()
-            .and().generatesSources(generatedComponent);
-  }
-
-  @Test
-  public void injectMapWithoutMapBinding() {
-    JavaFileObject mapModuleFile = JavaFileObjects.forSourceLines("test.MapModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import java.util.HashMap;",
-        "import java.util.Map;",
-        "",
-        "@Module",
-        "final class MapModule {",
-        "  @Provides Map<String, String> provideAMap() {",
-        "    Map<String, String> map = new HashMap<String, String>();",
-        "    map.put(\"Hello\", \"World\");",
-        "    return map;",
-        "  }",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import java.util.Map;",
-        "",
-        "@Component(modules = {MapModule.class})",
-        "interface TestComponent {",
-        "  Map<String, String> dispatcher();",
-        "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.Preconditions;",
-        "import java.util.Map;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<Map<String, String>> provideAMapProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.provideAMapProvider = MapModule_ProvideAMapFactory.create(builder.mapModule);",
-        "  }",
-        "",
-        "  @Override",
-        "  public Map<String, String> dispatcher() {",
-        "    return provideAMapProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private MapModule mapModule;",
-        "",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      if (mapModule == null) {",
-        "        this.mapModule = new MapModule();",
-        "      }",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "",
-        "    public Builder mapModule(MapModule mapModule) {",
-        "      this.mapModule = Preconditions.checkNotNull(mapModule);",
-        "      return this;",
-        "    }",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(mapModuleFile,componentFile))
-        .processedWith(new ComponentProcessor()).compilesWithoutError()
-        .and().generatesSources(generatedComponent);
-  }
-
-  @Test
-  public void mapBindingsWithDuplicateKeys() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.MapModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.StringKey;",
-            "import dagger.multibindings.IntoMap;",
-            "",
-            "@Module",
-            "final class MapModule {",
-            "  @Provides @IntoMap @StringKey(\"AKey\") Object provideObjectForAKey() {",
-            "    return \"one\";",
-            "  }",
-            "",
-            "  @Provides @IntoMap @StringKey(\"AKey\") Object provideObjectForAKeyAgain() {",
-            "    return \"one again\";",
-            "  }",
-            "}");
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import java.util.Map;",
-            "import javax.inject.Provider;",
-            "",
-            "@Component(modules = {MapModule.class})",
-            "interface TestComponent {",
-            "  Map<String, Object> objects();",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(module, componentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("The same map key is bound more than once")
-        .and()
-        .withErrorContaining("provideObjectForAKey()")
-        .and()
-        .withErrorContaining("provideObjectForAKeyAgain()")
-        .and()
-        .withErrorCount(1);
-  }
-
-  @Test
-  public void mapBindingsWithInconsistentKeyAnnotations() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.MapModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.StringKey;",
-            "import dagger.multibindings.IntoMap;",
-            "",
-            "@Module",
-            "final class MapModule {",
-            "  @Provides @IntoMap @StringKey(\"AKey\") Object provideObjectForAKey() {",
-            "    return \"one\";",
-            "  }",
-            "",
-            "  @Provides @IntoMap @StringKeyTwo(\"BKey\") Object provideObjectForBKey() {",
-            "    return \"two\";",
-            "  }",
-            "}");
-    JavaFileObject stringKeyTwoFile =
-        JavaFileObjects.forSourceLines(
-            "test.StringKeyTwo",
-            "package test;",
-            "",
-            "import dagger.MapKey;",
-            "",
-            "@MapKey(unwrapValue = true)",
-            "public @interface StringKeyTwo {",
-            "  String value();",
-            "}");
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import java.util.Map;",
-            "",
-            "@Component(modules = {MapModule.class})",
-            "interface TestComponent {",
-            "  Map<String, Object> objects();",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(module, stringKeyTwoFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("uses more than one @MapKey annotation type")
-        .and()
-        .withErrorContaining("provideObjectForAKey()")
-        .and()
-        .withErrorContaining("provideObjectForBKey()")
-        .and()
-        .withErrorCount(1);
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
deleted file mode 100644
index a271187ef..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/MapKeyProcessorTest.java
+++ /dev/null
@@ -1,521 +0,0 @@
-/*
- * Copyright (C) 2014 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubject.assertThat;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-
-import com.google.auto.value.processor.AutoAnnotationProcessor;
-import com.google.common.collect.ImmutableList;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class MapKeyProcessorTest {
-  @Test
-  public void mapKeyCreatorFile() {
-    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
-        "package test;",
-        "import dagger.MapKey;",
-        "import java.lang.annotation.Retention;",
-        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-        "",
-        "@MapKey(unwrapValue = false)",
-        "@Retention(RUNTIME)",
-        "public @interface PathKey {",
-        "  PathEnum value();",
-        "  String relativePath() default \"Defaultpath\";",
-        "}");
-    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
-        "package test;",
-        "",
-        "public enum PathEnum {",
-        "    ADMIN,",
-        "    LOGIN;",
-        "}");
-    JavaFileObject generatedKeyCreator =
-        JavaFileObjects.forSourceLines(
-            "test.PathKeyCreator",
-            "package test;",
-            "",
-            "import com.google.auto.value.AutoAnnotation;",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class PathKeyCreator {",
-            "  private PathKeyCreator() {}",
-            "",
-            "  @AutoAnnotation",
-            "  public static PathKey createPathKey(PathEnum value, String relativePath) {",
-            "    return new AutoAnnotation_PathKeyCreator_createPathKey(value, relativePath);",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(enumKeyFile, pathEnumFile))
-        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(generatedKeyCreator);
-  }
-
-  @Test
-  public void nestedMapKeyCreatorFile() {
-    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.Container",
-        "package test;",
-        "import dagger.MapKey;",
-        "import java.lang.annotation.Retention;",
-        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-        "",
-        "public interface Container {",
-        "@MapKey(unwrapValue = false)",
-        "@Retention(RUNTIME)",
-        "public @interface PathKey {",
-        "  PathEnum value();",
-        "  String relativePath() default \"Defaultpath\";",
-        "}",
-        "}");
-    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
-        "package test;",
-        "",
-        "public enum PathEnum {",
-        "    ADMIN,",
-        "    LOGIN;",
-        "}");
-    JavaFileObject generatedKeyCreator =
-        JavaFileObjects.forSourceLines(
-            "test.Container_PathKeyCreator",
-            "package test;",
-            "",
-            "import com.google.auto.value.AutoAnnotation;",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class Container_PathKeyCreator {",
-            "  private Container_PathKeyCreator() {}",
-            "",
-            "  @AutoAnnotation",
-            "  public static Container.PathKey createPathKey("
-                + "PathEnum value, String relativePath) {",
-            "    return new AutoAnnotation_Container_PathKeyCreator_createPathKey(",
-            "        value, relativePath);",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(enumKeyFile, pathEnumFile))
-        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(generatedKeyCreator);
-  }
-
-  @Test
-  public void mapKeyComponentFileWithDisorderedKeyField() {
-    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.multibindings.IntoMap;",
-        "",
-        "@Module",
-        "final class MapModuleOne {",
-        "  @Provides",
-        "  @IntoMap",
-        "  @PathKey(relativePath = \"AdminPath\", value = PathEnum.ADMIN)",
-        "  Handler provideAdminHandler() {",
-        "    return new AdminHandler();",
-        "  }",
-        "}");
-    JavaFileObject mapModuleTwoFile =JavaFileObjects.forSourceLines("test.MapModuleTwo",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.multibindings.IntoMap;",
-        "",
-        "@Module",
-        "final class MapModuleTwo {",
-        "  @Provides",
-        "  @IntoMap",
-        "  @PathKey(value = PathEnum.LOGIN, relativePath = \"LoginPath\")",
-        "  Handler provideLoginHandler() {",
-        "    return new LoginHandler();",
-        "  }",
-        "}");
-    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
-        "package test;",
-        "import dagger.MapKey;",
-        "import java.lang.annotation.Retention;",
-        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-        "",
-        "@MapKey(unwrapValue = false)",
-        "@Retention(RUNTIME)",
-        "public @interface PathKey {",
-        "  PathEnum value();",
-        "  String relativePath() default \"DefaultPath\";",
-        "}");
-    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
-        "package test;",
-        "",
-        "public enum PathEnum {",
-        "    ADMIN,",
-        "    LOGIN;",
-        "}");
-    JavaFileObject handlerFile = JavaFileObjects.forSourceLines("test.Handler",
-        "package test;",
-        "",
-        "interface Handler {}");
-    JavaFileObject loginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
-        "package test;",
-        "",
-        "class LoginHandler implements Handler {",
-        "  public LoginHandler() {}",
-        "}");
-    JavaFileObject adminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
-        "package test;",
-        "",
-        "class AdminHandler implements Handler {",
-        "  public AdminHandler() {}",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import java.util.Map;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
-        "interface TestComponent {",
-        "  Map<PathKey, Provider<Handler>> dispatcher();",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.internal.MapProviderFactory;",
-            "import dagger.internal.Preconditions;",
-            "import java.util.Map;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<Handler> provideAdminHandlerProvider;",
-            "  private Provider<Handler> provideLoginHandlerProvider;",
-            "  private Provider<Map<PathKey, Provider<Handler>>>",
-            "      mapOfPathKeyAndProviderOfHandlerProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.provideAdminHandlerProvider =",
-            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-            "    this.provideLoginHandlerProvider =",
-            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-            "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
-            "        MapProviderFactory.<PathKey, Handler>builder(2)",
-            "            .put(PathKeyCreator.createPathKey(PathEnum.ADMIN, \"AdminPath\"),",
-            "                provideAdminHandlerProvider)",
-            "            .put(PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
-            "                provideLoginHandlerProvider)",
-            "            .build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<PathKey, Provider<Handler>> dispatcher() {",
-            "    return mapOfPathKeyAndProviderOfHandlerProvider.get();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private MapModuleOne mapModuleOne;",
-            "    private MapModuleTwo mapModuleTwo;",
-            "",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      if (mapModuleOne == null) {",
-            "        this.mapModuleOne = new MapModuleOne();",
-            "      }",
-            "      if (mapModuleTwo == null) {",
-            "        this.mapModuleTwo = new MapModuleTwo();",
-            "      }",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "",
-            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-            "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
-            "      return this;",
-            "    }",
-            "",
-            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-            "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(
-            ImmutableList.of(
-                mapModuleOneFile,
-                mapModuleTwoFile,
-                enumKeyFile,
-                pathEnumFile,
-                handlerFile,
-                loginHandlerFile,
-                adminHandlerFile,
-                componentFile))
-        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(generatedComponent);
-  }
-
-  @Test
-  public void mapKeyComponentFileWithDefaultField() {
-    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.multibindings.IntoMap;",
-        "",
-        "@Module",
-        "final class MapModuleOne {",
-        "  @Provides",
-        "  @IntoMap",
-        "  @PathKey(value = PathEnum.ADMIN) Handler provideAdminHandler() {",
-        "    return new AdminHandler();",
-        "  }",
-        "}");
-    JavaFileObject mapModuleTwoFile =JavaFileObjects.forSourceLines("test.MapModuleTwo",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.multibindings.IntoMap;",
-        "",
-        "@Module",
-        "final class MapModuleTwo {",
-        "  @Provides",
-        "  @IntoMap",
-        "  @PathKey(value = PathEnum.LOGIN, relativePath = \"LoginPath\")",
-        "  Handler provideLoginHandler() {",
-        "    return new LoginHandler();",
-        "  }",
-        "}");
-    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
-        "package test;",
-        "import dagger.MapKey;",
-        "import java.lang.annotation.Retention;",
-        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
-        "",
-        "@MapKey(unwrapValue = false)",
-        "@Retention(RUNTIME)",
-        "public @interface PathKey {",
-        "  PathEnum value();",
-        "  String relativePath() default \"DefaultPath\";",
-        "}");
-    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
-        "package test;",
-        "",
-        "public enum PathEnum {",
-        "    ADMIN,",
-        "    LOGIN;",
-        "}");
-    JavaFileObject handlerFile = JavaFileObjects.forSourceLines("test.Handler",
-        "package test;",
-        "",
-        "interface Handler {}");
-    JavaFileObject loginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
-        "package test;",
-        "",
-        "class LoginHandler implements Handler {",
-        "  public LoginHandler() {}",
-        "}");
-    JavaFileObject adminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
-        "package test;",
-        "",
-        "class AdminHandler implements Handler {",
-        "  public AdminHandler() {}",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import java.util.Map;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
-        "interface TestComponent {",
-        "  Map<PathKey, Provider<Handler>> dispatcher();",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.internal.MapProviderFactory;",
-            "import dagger.internal.Preconditions;",
-            "import java.util.Map;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private Provider<Handler> provideAdminHandlerProvider;",
-            "  private Provider<Handler> provideLoginHandlerProvider;",
-            "  private Provider<Map<PathKey, Provider<Handler>>>",
-            "      mapOfPathKeyAndProviderOfHandlerProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.provideAdminHandlerProvider =",
-            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
-            "    this.provideLoginHandlerProvider =",
-            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
-            "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
-            "        MapProviderFactory.<PathKey, Handler>builder(2)",
-            "            .put(PathKeyCreator.createPathKey(PathEnum.ADMIN, \"DefaultPath\"),",
-            "                provideAdminHandlerProvider)",
-            "            .put(PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
-            "                provideLoginHandlerProvider)",
-            "            .build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Map<PathKey, Provider<Handler>> dispatcher() {",
-            "    return mapOfPathKeyAndProviderOfHandlerProvider.get();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private MapModuleOne mapModuleOne;",
-            "    private MapModuleTwo mapModuleTwo;",
-            "",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestComponent build() {",
-            "      if (mapModuleOne == null) {",
-            "        this.mapModuleOne = new MapModuleOne();",
-            "      }",
-            "      if (mapModuleTwo == null) {",
-            "        this.mapModuleTwo = new MapModuleTwo();",
-            "      }",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "",
-            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
-            "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
-            "      return this;",
-            "    }",
-            "",
-            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
-            "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
-            "      return this;",
-            "    }",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(
-            ImmutableList.of(
-                mapModuleOneFile,
-                mapModuleTwoFile,
-                enumKeyFile,
-                pathEnumFile,
-                handlerFile,
-                loginHandlerFile,
-                adminHandlerFile,
-                componentFile))
-        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(generatedComponent);
-  }
-
-  @Test
-  public void mapKeyWithDefaultValue() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.MapModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.multibindings.IntoMap;",
-            "",
-            "@Module",
-            "final class MapModule {",
-            "  @Provides",
-            "  @IntoMap",
-            "  @BoolKey int provideFalseValue() {",
-            "    return -1;",
-            "  }",
-            "",
-            "  @Provides",
-            "  @IntoMap",
-            "  @BoolKey(true) int provideTrueValue() {",
-            "    return 1;",
-            "  }",
-            "}");
-    JavaFileObject mapKey =
-        JavaFileObjects.forSourceLines(
-            "test.BoolKey",
-            "package test;",
-            "",
-            "import dagger.MapKey;",
-            "",
-            "@MapKey",
-            "@interface BoolKey {",
-            "  boolean value() default false;",
-            "}");
-    assertThat(module, mapKey)
-        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
-        .compilesWithoutError();
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java b/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
deleted file mode 100644
index 34ee72c2f..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/MembersInjectionTest.java
+++ /dev/null
@@ -1,1117 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubject.assertThat;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-import static javax.tools.StandardLocation.CLASS_OUTPUT;
-
-import com.google.common.base.Joiner;
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-import com.google.testing.compile.JavaFileObjects;
-import java.io.IOException;
-import java.io.Writer;
-import java.util.Set;
-import javax.annotation.processing.AbstractProcessor;
-import javax.annotation.processing.RoundEnvironment;
-import javax.lang.model.element.TypeElement;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class MembersInjectionTest {
-  @Test
-  public void parentClass_noInjectedMembers() {
-    JavaFileObject childFile = JavaFileObjects.forSourceLines("test.Child",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "public final class Child extends Parent {",
-        "  @Inject Child() {}",
-        "}");
-    JavaFileObject parentFile = JavaFileObjects.forSourceLines("test.Parent",
-        "package test;",
-        "",
-        "public abstract class Parent {}");
-
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "",
-        "@Component",
-        "interface TestComponent {",
-        "  Child child();",
-        "}");
-    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
-        "test.DaggerTestComponent",
-        "package test;",
-        "",
-        "import dagger.internal.MembersInjectors;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class DaggerTestComponent implements TestComponent {",
-        "  private Provider<Child> childProvider;",
-        "",
-        "  private DaggerTestComponent(Builder builder) {",
-        "    assert builder != null;",
-        "    initialize(builder);",
-        "  }",
-        "",
-        "  public static Builder builder() {",
-        "    return new Builder();",
-        "  }",
-        "",
-        "  public static TestComponent create() {",
-        "    return builder().build();",
-        "  }",
-        "",
-        "  @SuppressWarnings(\"unchecked\")",
-        "  private void initialize(final Builder builder) {",
-        "    this.childProvider =",
-        "        Child_Factory.create(MembersInjectors.<Child>noOp());",
-        "  }",
-        "",
-        "  @Override",
-        "  public Child child() {",
-        "    return childProvider.get();",
-        "  }",
-        "",
-        "  public static final class Builder {",
-        "    private Builder() {",
-        "    }",
-        "",
-        "    public TestComponent build() {",
-        "      return new DaggerTestComponent(this);",
-        "    }",
-        "  }",
-        "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(childFile, parentFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
-  }
-
-  @Test
-  public void parentClass_injectedMembersInSupertype() {
-    JavaFileObject childFile = JavaFileObjects.forSourceLines("test.Child",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "public final class Child extends Parent {",
-        "  @Inject Child() {}",
-        "}");
-    JavaFileObject parentFile = JavaFileObjects.forSourceLines("test.Parent",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "public abstract class Parent {",
-        "  @Inject Dep dep;",
-        "}");
-    JavaFileObject depFile = JavaFileObjects.forSourceLines("test.Dep",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class Dep {",
-        "  @Inject Dep() {}",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "",
-        "@Component",
-        "interface TestComponent {",
-        "  Child child();",
-        "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestComponent",
-            "package test;",
-            "",
-            "import dagger.MembersInjector;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestComponent implements TestComponent {",
-            "  private MembersInjector<Child> childMembersInjector;",
-            "  private Provider<Child> childProvider;",
-            "",
-            "  private DaggerTestComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestComponent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.childMembersInjector = Child_MembersInjector.create(Dep_Factory.create());",
-            "    this.childProvider = Child_Factory.create(childMembersInjector);",
-            "  }",
-            "",
-            "  @Override",
-            "  public Child child() {",
-            "    return childProvider.get();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public TestComponent build() {",
-            "      return new DaggerTestComponent(this);",
-            "    }",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(childFile, parentFile, depFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(generatedComponent);
-  }
-
-  @Test public void fieldAndMethodGenerics() {
-    JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericClass",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "class GenericClass<A, B> {",
-        "  @Inject A a;",
-        "",
-        "  @Inject GenericClass() {}",
-        "",
-        " @Inject void register(B b) {}",
-        "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines(
-        "test.GenericClass_MembersInjector",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class GenericClass_MembersInjector<A, B>",
-        "    implements MembersInjector<GenericClass<A, B>> {",
-        "  private final Provider<A> aProvider;",
-        "  private final Provider<B> bProvider;",
-        "",
-        "  public GenericClass_MembersInjector(Provider<A> aProvider, Provider<B> bProvider) {",
-        "    assert aProvider != null;",
-        "    this.aProvider = aProvider;",
-        "    assert bProvider != null;",
-        "    this.bProvider = bProvider;",
-        "  }",
-        "",
-        "  public static <A, B> MembersInjector<GenericClass<A, B>> create(",
-        "      Provider<A> aProvider, Provider<B> bProvider) {",
-        "    return new GenericClass_MembersInjector<A, B>(aProvider, bProvider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public void injectMembers(GenericClass<A, B> instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    instance.a = aProvider.get();",
-        "    instance.register(bProvider.get());",
-        "  }",
-        "",
-        "  public static <A, B> void injectA(GenericClass<A, B> instance, Provider<A> aProvider) {",
-        "    instance.a = aProvider.get();",
-        "  }",
-        "",
-        "  public static <A, B> void injectRegister(",
-        "      GenericClass<A, B> instance, Provider<B> bProvider) {",
-        "    instance.register(bProvider.get());",
-        "  }",
-        "",
-        "}");
-    assertAbout(javaSource())
-        .that(file)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expected);
-  }
-
-  @Test public void subclassedGenericMembersInjectors() {
-    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class A {",
-        "  @Inject A() {}",
-        "}");
-    JavaFileObject a2 = JavaFileObjects.forSourceLines("test.A2",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class A2 {",
-        "  @Inject A2() {}",
-        "}");
-    JavaFileObject parent = JavaFileObjects.forSourceLines("test.Parent",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "class Parent<X, Y> {",
-        "  @Inject X x;",
-        "  @Inject Y y;",
-        "  @Inject A2 a2;",
-        "",
-        "  @Inject Parent() {}",
-        "}");
-    JavaFileObject child = JavaFileObjects.forSourceLines("test.Child",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "class Child<T> extends Parent<T, A> {",
-        "  @Inject A a;",
-        "  @Inject T t;",
-        "",
-        "  @Inject Child() {}",
-        "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines(
-        "test.Child_MembersInjector",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class Child_MembersInjector<T>",
-        "    implements MembersInjector<Child<T>> {",
-        "  private final Provider<T> tAndXProvider;",
-        "  private final Provider<A> aAndYProvider;",
-        "  private final Provider<A2> a2Provider;",
-        "",
-        "  public Child_MembersInjector(",
-        "      Provider<T> tAndXProvider, Provider<A> aAndYProvider, Provider<A2> a2Provider) {",
-        "    assert tAndXProvider != null;",
-        "    this.tAndXProvider = tAndXProvider;",
-        "    assert aAndYProvider != null;",
-        "    this.aAndYProvider = aAndYProvider;",
-        "    assert a2Provider != null;",
-        "    this.a2Provider = a2Provider;",
-        "  }",
-        "",
-        "  public static <T> MembersInjector<Child<T>> create(",
-        "      Provider<T> tAndXProvider, Provider<A> aAndYProvider, Provider<A2> a2Provider) {",
-        "    return new Child_MembersInjector<T>(tAndXProvider, aAndYProvider, a2Provider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public void injectMembers(Child<T> instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    ((Parent) instance).x = tAndXProvider.get();",
-        "    ((Parent) instance).y = aAndYProvider.get();",
-        "    ((Parent) instance).a2 = a2Provider.get();",
-        "    instance.a = aAndYProvider.get();",
-        "    instance.t = tAndXProvider.get();",
-        "  }",
-        "",
-        "  public static <T> void injectA(Child<T> instance, Provider<A> aProvider) {",
-        "    instance.a = aProvider.get();",
-        "  }",
-        "",
-        "  public static <T> void injectT(Child<T> instance, Provider<T> tProvider) {",
-        "    instance.t = tProvider.get();",
-        "  }",
-        "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(a, a2, parent, child))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expected);
-  }
-
-  @Test public void fieldInjection() {
-    JavaFileObject file = JavaFileObjects.forSourceLines("test.FieldInjection",
-        "package test;",
-        "",
-        "import dagger.Lazy;",
-        "import javax.inject.Inject;",
-        "import javax.inject.Provider;",
-        "",
-        "class FieldInjection {",
-        "  @Inject String string;",
-        "  @Inject Lazy<String> lazyString;",
-        "  @Inject Provider<String> stringProvider;",
-        "}");
-    JavaFileObject expected =
-        JavaFileObjects.forSourceLines(
-            "test.FieldInjection_MembersInjector",
-            "package test;",
-            "",
-            "import dagger.MembersInjector;",
-            "import dagger.internal.DoubleCheck;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class FieldInjection_MembersInjector",
-            "    implements MembersInjector<FieldInjection> {",
-            "  private final Provider<String> stringProvider;",
-            "",
-            "  public FieldInjection_MembersInjector(Provider<String> stringProvider) {",
-            "    assert stringProvider != null;",
-            "    this.stringProvider = stringProvider;",
-            "  }",
-            "",
-            "  public static MembersInjector<FieldInjection> create(Provider<String> stringProvider) {",
-            "    return new FieldInjection_MembersInjector(stringProvider);",
-            "  }",
-            "",
-            "  @Override",
-            "  public void injectMembers(FieldInjection instance) {",
-            "    if (instance == null) {",
-            "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-            "    }",
-            "    instance.string = stringProvider.get();",
-            "    instance.lazyString = DoubleCheck.lazy(stringProvider);",
-            "    instance.stringProvider = stringProvider;",
-            "  }",
-            "",
-            "  public static void injectString(",
-            "      FieldInjection instance, Provider<String> stringProvider) {",
-            "    instance.string = stringProvider.get();",
-            "  }",
-            "",
-            "  public static void injectLazyString(",
-            "      FieldInjection instance, Provider<String> lazyStringProvider) {",
-            "    instance.lazyString = DoubleCheck.lazy(lazyStringProvider);",
-            "  }",
-            "",
-            "  public static void injectStringProvider(",
-            "      FieldInjection instance, Provider<String> stringProvider) {",
-            "    instance.stringProvider = stringProvider;",
-            "  }",
-            "}");
-    assertAbout(javaSource())
-        .that(file)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expected);
-  }
-
-  @Test public void methodInjection() {
-    JavaFileObject file = JavaFileObjects.forSourceLines("test.MethodInjection",
-        "package test;",
-        "",
-        "import dagger.Lazy;",
-        "import javax.inject.Inject;",
-        "import javax.inject.Provider;",
-        "",
-        "class MethodInjection {",
-        "  @Inject void noArgs() {}",
-        "  @Inject void oneArg(String string) {}",
-        "  @Inject void manyArgs(",
-        "      String string, Lazy<String> lazyString, Provider<String> stringProvider) {}",
-        "}");
-    JavaFileObject expected =
-        JavaFileObjects.forSourceLines(
-            "test.MethodInjection_MembersInjector",
-            "package test;",
-            "",
-            "import dagger.MembersInjector;",
-            "import dagger.internal.DoubleCheck;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class MethodInjection_MembersInjector",
-            "     implements MembersInjector<MethodInjection> {",
-            "",
-            "  private final Provider<String> stringProvider;",
-            "",
-            "  public MethodInjection_MembersInjector(Provider<String> stringProvider) {",
-            "    assert stringProvider != null;",
-            "    this.stringProvider = stringProvider;",
-            "  }",
-            "",
-            "  public static MembersInjector<MethodInjection> create(",
-            "      Provider<String> stringProvider) {",
-            "    return new MethodInjection_MembersInjector(stringProvider);",
-            "  }",
-            "",
-            "  @Override",
-            "  public void injectMembers(MethodInjection instance) {",
-            "    if (instance == null) {",
-            "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-            "    }",
-            "    instance.noArgs();",
-            "    instance.oneArg(stringProvider.get());",
-            "    instance.manyArgs(",
-            "        stringProvider.get(),",
-            "        DoubleCheck.lazy(stringProvider),",
-            "        stringProvider);",
-            "  }",
-            "",
-            "  public static void injectNoArgs(MethodInjection instance) {",
-            "    instance.noArgs();",
-            "  }",
-            "",
-            "  public static void injectOneArg(",
-            "      MethodInjection instance, Provider<String> stringProvider) {",
-            "    instance.oneArg(stringProvider.get());",
-            "  }",
-            "",
-            "  public static void injectManyArgs(",
-            "      MethodInjection instance,",
-            "      Provider<String> stringProvider,",
-            "      Provider<String> lazyStringProvider,",
-            "      Provider<String> stringProvider2) {",
-            "    instance.manyArgs(",
-            "        stringProvider.get(),",
-            "        DoubleCheck.lazy(lazyStringProvider),",
-            "        stringProvider2);",
-            "  }",
-            "}");
-    assertAbout(javaSource())
-        .that(file)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expected);
-  }
-
-  @Test
-  public void mixedMemberInjection() {
-    JavaFileObject file = JavaFileObjects.forSourceLines(
-        "test.MixedMemberInjection",
-        "package test;",
-        "",
-        "import dagger.Lazy;",
-        "import javax.inject.Inject;",
-        "import javax.inject.Provider;",
-        "",
-        "class MixedMemberInjection {",
-        "  @Inject String string;",
-        "  @Inject void setString(String s) {}",
-        "  @Inject Object object;",
-        "  @Inject void setObject(Object o) {}",
-        "}");
-    JavaFileObject expected = JavaFileObjects.forSourceLines(
-        "test.MixedMemberInjection_MembersInjector",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class MixedMemberInjection_MembersInjector",
-        "    implements MembersInjector<MixedMemberInjection> {",
-        "",
-        "  private final Provider<String> stringAndSProvider;",
-        "  private final Provider<Object> objectAndOProvider;",
-        "",
-        "  public MixedMemberInjection_MembersInjector(",
-        "      Provider<String> stringAndSProvider,",
-        "      Provider<Object> objectAndOProvider) {",
-        "    assert stringAndSProvider != null;",
-        "    this.stringAndSProvider = stringAndSProvider;",
-        "    assert objectAndOProvider != null;",
-        "    this.objectAndOProvider = objectAndOProvider;",
-        "  }",
-        "",
-        "  public static MembersInjector<MixedMemberInjection> create(",
-        "      Provider<String> stringAndSProvider,",
-        "      Provider<Object> objectAndOProvider) {",
-        "    return new MixedMemberInjection_MembersInjector(",
-        "        stringAndSProvider, objectAndOProvider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public void injectMembers(MixedMemberInjection instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    instance.string = stringAndSProvider.get();",
-        "    instance.object = objectAndOProvider.get();",
-        "    instance.setString(stringAndSProvider.get());",
-        "    instance.setObject(objectAndOProvider.get());",
-        "  }",
-        "",
-        "  public static void injectString(",
-        "      MixedMemberInjection instance, Provider<String> stringProvider) {",
-        "    instance.string = stringProvider.get();",
-        "  }",
-        "",
-        "  public static void injectObject(",
-        "      MixedMemberInjection instance, Provider<Object> objectProvider) {",
-        "    instance.object = objectProvider.get();",
-        "  }",
-        "",
-        "  public static void injectSetString(",
-        "      MixedMemberInjection instance, Provider<String> sProvider) {",
-        "    instance.setString(sProvider.get());",
-        "  }",
-        "",
-        "  public static void injectSetObject(",
-        "      MixedMemberInjection instance, Provider<Object> oProvider) {",
-        "    instance.setObject(oProvider.get());",
-        "  }",
-        "}");
-    assertAbout(javaSource())
-        .that(file)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expected);
-  }
-
-  @Test public void injectConstructorAndMembersInjection() {
-    JavaFileObject file = JavaFileObjects.forSourceLines("test.AllInjections",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "class AllInjections {",
-        "  @Inject String s;",
-        "  @Inject AllInjections(String s) {}",
-        "  @Inject void s(String s) {}",
-        "}");
-    JavaFileObject expectedMembersInjector = JavaFileObjects.forSourceLines(
-        "test.AllInjections_MembersInjector",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class AllInjections_MembersInjector ",
-        "    implements MembersInjector<AllInjections> {",
-        "",
-        "  private final Provider<String> sProvider;",
-        "",
-        "  public AllInjections_MembersInjector(Provider<String> sProvider) {",
-        "    assert sProvider != null;",
-        "    this.sProvider = sProvider;",
-        "  }",
-        "",
-        "  public static MembersInjector<AllInjections> create(Provider<String> sProvider) {",
-        "      return new AllInjections_MembersInjector(sProvider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public void injectMembers(AllInjections instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    instance.s = sProvider.get();",
-        "    instance.s(sProvider.get());",
-        "  }",
-        "",
-        "  public static void injectS(AllInjections instance, Provider<String> sProvider) {",
-        "    instance.s = sProvider.get();",
-        "  }",
-        "}");
-    assertAbout(javaSource())
-        .that(file)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedMembersInjector);
-  }
-
-  @Test public void supertypeMembersInjection() {
-    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
-        "package test;",
-        "",
-        "class A {}");
-    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "class B extends A {",
-        "  @Inject String s;",
-        "}");
-    JavaFileObject expectedMembersInjector = JavaFileObjects.forSourceLines(
-        "test.AllInjections_MembersInjector",
-        "package test;",
-        "",
-        "import dagger.MembersInjector;",
-        "import javax.annotation.Generated;",
-        "import javax.inject.Provider;",
-        "",
-        GENERATED_ANNOTATION,
-        "public final class B_MembersInjector implements MembersInjector<B> {",
-        "  private final Provider<String> sProvider;",
-        "",
-        "  public B_MembersInjector(Provider<String> sProvider) {",
-        "    assert sProvider != null;",
-        "    this.sProvider = sProvider;",
-        "  }",
-        "",
-        "  public static MembersInjector<B> create(Provider<String> sProvider) {",
-        "      return new B_MembersInjector(sProvider);",
-        "  }",
-        "",
-        "  @Override",
-        "  public void injectMembers(B instance) {",
-        "    if (instance == null) {",
-        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-        "    }",
-        "    instance.s = sProvider.get();",
-        "  }",
-        "",
-        "  public static void injectS(B instance, Provider<String> sProvider) {",
-        "    instance.s = sProvider.get();",
-        "  }",
-        "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(aFile, bFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedMembersInjector);
-  }
-
-  @Test
-  public void simpleComponentWithNesting() {
-    JavaFileObject nestedTypesFile = JavaFileObjects.forSourceLines(
-          "test.OuterType",
-          "package test;",
-          "",
-          "import dagger.Component;",
-          "import javax.inject.Inject;",
-          "",
-          "final class OuterType {",
-          "  static class A {",
-          "    @Inject A() {}",
-          "  }",
-          "  static class B {",
-          "    @Inject A a;",
-          "  }",
-          "  @Component interface SimpleComponent {",
-          "    A a();",
-          "    void inject(B b);",
-          "  }",
-          "}");
-    JavaFileObject bMembersInjector = JavaFileObjects.forSourceLines(
-          "test.OuterType_B_MembersInjector",
-          "package test;",
-          "",
-          "import dagger.MembersInjector;",
-          "import javax.annotation.Generated;",
-          "import javax.inject.Provider;",
-          "",
-          GENERATED_ANNOTATION,
-          "public final class OuterType_B_MembersInjector",
-          "    implements MembersInjector<OuterType.B> {",
-          "  private final Provider<OuterType.A> aProvider;",
-          "",
-          "  public OuterType_B_MembersInjector(Provider<OuterType.A> aProvider) {",
-          "    assert aProvider != null;",
-          "    this.aProvider = aProvider;",
-          "  }",
-          "",
-          "  public static MembersInjector<OuterType.B> create(Provider<OuterType.A> aProvider) {",
-          "    return new OuterType_B_MembersInjector(aProvider);",
-          "  }",
-          "",
-          "  @Override",
-          "  public void injectMembers(OuterType.B instance) {",
-          "    if (instance == null) {",
-          "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-          "    }",
-          "    instance.a = aProvider.get();",
-          "  }",
-          "",
-          "  public static void injectA(OuterType.B instance, Provider<OuterType.A> aProvider) {",
-          "    instance.a = aProvider.get();",
-          "  }",
-          "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(nestedTypesFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(bMembersInjector);
-  }
-
-  @Test
-  public void componentWithNestingAndGeneratedType() {
-    JavaFileObject nestedTypesFile =
-        JavaFileObjects.forSourceLines(
-            "test.OuterType",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Inject;",
-            "",
-            "final class OuterType {",
-            "  @Inject GeneratedType generated;",
-            "  static class A {",
-            "    @Inject A() {}",
-            "  }",
-            "  static class B {",
-            "    @Inject A a;",
-            "  }",
-            "  @Component interface SimpleComponent {",
-            "    A a();",
-            "    void inject(B b);",
-            "  }",
-            "}");
-    JavaFileObject bMembersInjector =
-        JavaFileObjects.forSourceLines(
-            "test.OuterType_B_MembersInjector",
-            "package test;",
-            "",
-            "import dagger.MembersInjector;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class OuterType_B_MembersInjector",
-            "    implements MembersInjector<OuterType.B> {",
-            "  private final Provider<OuterType.A> aProvider;",
-            "",
-            "  public OuterType_B_MembersInjector(Provider<OuterType.A> aProvider) {",
-            "    assert aProvider != null;",
-            "    this.aProvider = aProvider;",
-            "  }",
-            "",
-            "  public static MembersInjector<OuterType.B> create(Provider<OuterType.A> aProvider) {",
-            "    return new OuterType_B_MembersInjector(aProvider);",
-            "  }",
-            "",
-            "  @Override",
-            "  public void injectMembers(OuterType.B instance) {",
-            "    if (instance == null) {",
-            "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
-            "    }",
-            "    instance.a = aProvider.get();",
-            "  }",
-            "",
-            "  public static void injectA(OuterType.B instance, Provider<OuterType.A> aProvider) {",
-            "    instance.a = aProvider.get();",
-            "  }",
-            "}");
-    assertAbout(javaSource())
-        .that(nestedTypesFile)
-        .processedWith(
-            new ComponentProcessor(),
-            new AbstractProcessor() {
-              private boolean done;
-
-              @Override
-              public Set<String> getSupportedAnnotationTypes() {
-                return ImmutableSet.of("*");
-              }
-
-              @Override
-              public boolean process(
-                  Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
-                if (!done) {
-                  done = true;
-                  try (Writer writer =
-                          processingEnv
-                              .getFiler()
-                              .createSourceFile("test.GeneratedType")
-                              .openWriter()) {
-                    writer.write(
-                        Joiner.on('\n')
-                            .join(
-                                "package test;",
-                                "",
-                                "import javax.inject.Inject;",
-                                "",
-                                "class GeneratedType {",
-                                "  @Inject GeneratedType() {}",
-                                "}"));
-                  } catch (IOException e) {
-                    throw new RuntimeException(e);
-                  }
-                }
-                return false;
-              }
-            })
-        .compilesWithoutError()
-        .and()
-        .generatesSources(bMembersInjector);
-  }
-
-  @Test
-  public void lowerCaseNamedMembersInjector_forLowerCaseType() {
-    JavaFileObject foo =
-        JavaFileObjects.forSourceLines(
-            "test.foo",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class foo {",
-            "  @Inject String string;",
-            "}");
-    JavaFileObject fooModule =
-        JavaFileObjects.forSourceLines(
-            "test.fooModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "class fooModule {",
-            "  @Provides String string() { return \"foo\"; }",
-            "}");
-    JavaFileObject fooComponent =
-        JavaFileObjects.forSourceLines(
-            "test.fooComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = fooModule.class)",
-            "interface fooComponent {",
-            "  void inject(foo target);",
-            "}");
-
-    assertAbout(javaSources())
-        .that(ImmutableList.of(foo, fooModule, fooComponent))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesFileNamed(CLASS_OUTPUT, "test", "foo_MembersInjector.class");
-  }
-
-  @Test
-  public void fieldInjectionForShadowedMember() {
-    JavaFileObject foo =
-        JavaFileObjects.forSourceLines(
-            "test.Foo",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class Foo {",
-            "  @Inject Foo() {}",
-            "}");
-    JavaFileObject bar =
-        JavaFileObjects.forSourceLines(
-            "test.Bar",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class Bar {",
-            "  @Inject Bar() {}",
-            "}");
-    JavaFileObject parent =
-        JavaFileObjects.forSourceLines(
-            "test.Parent",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class Parent { ",
-            "  @Inject Foo object;",
-            "}");
-    JavaFileObject child =
-        JavaFileObjects.forSourceLines(
-            "test.Child",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "class Child extends Parent { ",
-            "  @Inject Bar object;",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.C",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface C { ",
-            "  void inject(Child child);",
-            "}");
-
-    JavaFileObject expectedMembersInjector =
-        JavaFileObjects.forSourceLines(
-            "test.Child_MembersInjector",
-            "package test;",
-            "",
-            "import dagger.MembersInjector;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class Child_MembersInjector implements MembersInjector<Child> {",
-            "  private final Provider<Foo> objectProvider;",
-            "  private final Provider<Bar> objectProvider2;",
-            "",
-            "  public Child_MembersInjector(",
-            "        Provider<Foo> objectProvider, Provider<Bar> objectProvider2) {",
-            "    assert objectProvider != null;",
-            "    this.objectProvider = objectProvider;",
-            "    assert objectProvider2 != null;",
-            "    this.objectProvider2 = objectProvider2;",
-            "  }",
-            "",
-            "  public static MembersInjector<Child> create(",
-            "      Provider<Foo> objectProvider, Provider<Bar> objectProvider2) {",
-            "    return new Child_MembersInjector(objectProvider, objectProvider2);",
-            "  }",
-            "",
-            "  @Override",
-            "  public void injectMembers(Child instance) {",
-            "    if (instance == null) {",
-            "      throw new NullPointerException(",
-            "          \"Cannot inject members into a null reference\");",
-            "    }",
-            "    ((Parent) instance).object = objectProvider.get();",
-            "    instance.object = objectProvider2.get();",
-            "  }",
-            "",
-            "  public static void injectObject(Child instance, Provider<Bar> objectProvider) {",
-            "    instance.object = objectProvider.get();",
-            "  }",
-            "}");
-
-    assertAbout(javaSources())
-        .that(ImmutableList.of(foo, bar, parent, child, component))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(expectedMembersInjector);
-  }
-
-  @Test public void privateNestedClassError() {
-    JavaFileObject file = JavaFileObjects.forSourceLines("test.OuterClass",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class OuterClass {",
-        "  private static final class InnerClass {",
-        "    @Inject int field;",
-        "  }",
-        "}");
-    assertAbout(javaSource())
-        .that(file)
-        .processedWith(new ComponentProcessor()).failsToCompile()
-        .withErrorContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(6);
-  }
-
-  @Test public void privateNestedClassWarning() {
-    JavaFileObject file = JavaFileObjects.forSourceLines("test.OuterClass",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class OuterClass {",
-        "  private static final class InnerClass {",
-        "    @Inject int field;",
-        "  }",
-        "}");
-    assertAbout(javaSource())
-        .that(file)
-        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .withWarningContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(6);
-  }
-
-  @Test public void privateSuperclassIsOkIfNotInjectedInto() {
-    JavaFileObject file = JavaFileObjects.forSourceLines("test.OuterClass",
-        "package test;",
-        "",
-        "import javax.inject.Inject;",
-        "",
-        "final class OuterClass {",
-        "  private static class BaseClass {}",
-        "",
-        "  static final class DerivedClass extends BaseClass {",
-        "    @Inject int field;",
-        "  }",
-        "}");
-    assertAbout(javaSource())
-        .that(file)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
-  }
-
-  @Test public void rawFrameworkTypes() {
-    JavaFileObject file =
-        JavaFileObjects.forSourceLines(
-            "test.RawFrameworkTypes",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import javax.inject.Inject;",
-            "import javax.inject.Provider;",
-            "",
-            "class RawProviderField {",
-            "  @Inject Provider fieldWithRawProvider;",
-            "}",
-            "",
-            "class RawProviderParameter {",
-            "  @Inject void methodInjection(Provider rawProviderParameter) {}",
-            "}",
-            "",
-            "@Component",
-            "interface C {",
-            "  void inject(RawProviderField rawProviderField);",
-            "  void inject(RawProviderParameter rawProviderParameter);",
-            "}");
-    assertThat(file)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("javax.inject.Provider cannot be provided").in(file).onLine(17)
-        .and()
-        .withErrorContaining("javax.inject.Provider cannot be provided").in(file).onLine(18);
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/ModuleValidatorTest.java
deleted file mode 100644
index e3b1a2ebb..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/ModuleValidatorTest.java
+++ /dev/null
@@ -1,318 +0,0 @@
-/*
- * Copyright (C) 2016 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.testing.compile.CompilationSubject.assertThat;
-import static com.google.testing.compile.JavaSourcesSubject.assertThat;
-import static dagger.internal.codegen.Compilers.daggerCompiler;
-import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;
-
-import com.google.testing.compile.JavaFileObjects;
-import dagger.Module;
-import dagger.producers.ProducerModule;
-import java.lang.annotation.Annotation;
-import java.util.Arrays;
-import java.util.Collection;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.Parameterized;
-
-@RunWith(Parameterized.class)
-public final class ModuleValidatorTest {
-
-  @Parameterized.Parameters(name = "{0}")
-  public static Collection<Object[]> parameters() {
-    return Arrays.asList(new Object[][] {{ModuleType.MODULE}, {ModuleType.PRODUCER_MODULE}});
-  }
-
-  private enum ModuleType {
-    MODULE(Module.class),
-    PRODUCER_MODULE(ProducerModule.class),
-    ;
-
-    private final Class<? extends Annotation> annotation;
-
-    ModuleType(Class<? extends Annotation> annotation) {
-      this.annotation = annotation;
-    }
-
-    String annotationWithSubcomponent(String subcomponent) {
-      return String.format("@%s(subcomponents = %s)", annotation.getSimpleName(), subcomponent);
-    }
-
-    String importStatement() {
-      return String.format("import %s;", annotation.getName());
-    }
-
-    String simpleName() {
-      return annotation.getSimpleName();
-    }
-  }
-
-  private final ModuleType moduleType;
-
-  public ModuleValidatorTest(ModuleType moduleType) {
-    this.moduleType = moduleType;
-  }
-
-  @Test
-  public void moduleSubcomponents_notASubcomponent() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            moduleType.importStatement(),
-            "",
-            moduleType.annotationWithSubcomponent("NotASubcomponent.class"),
-            "class TestModule {}");
-    JavaFileObject notASubcomponent =
-        JavaFileObjects.forSourceLines(
-            "test.NotASubcomponent", "package test;", "", "class NotASubcomponent {}");
-    assertThat(module, notASubcomponent)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            "test.NotASubcomponent is not a @Subcomponent or @ProductionSubcomponent")
-        .in(module)
-        .onLine(5);
-  }
-
-  @Test
-  public void moduleSubcomponents_listsSubcomponentBuilder() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            moduleType.importStatement(),
-            "",
-            moduleType.annotationWithSubcomponent("Sub.Builder.class"),
-            "class TestModule {}");
-    JavaFileObject subcomponent =
-        JavaFileObjects.forSourceLines(
-            "test.Sub",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Sub {",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    Sub build();",
-            "  }",
-            "}");
-    assertThat(module, subcomponent)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            "test.Sub.Builder is a @Subcomponent.Builder. Did you mean to use test.Sub?")
-        .in(module)
-        .onLine(5);
-  }
-
-  @Test
-  public void moduleSubcomponents_listsProductionSubcomponentBuilder() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            moduleType.importStatement(),
-            "",
-            moduleType.annotationWithSubcomponent("Sub.Builder.class"),
-            "class TestModule {}");
-    JavaFileObject subcomponent =
-        JavaFileObjects.forSourceLines(
-            "test.Sub",
-            "package test;",
-            "",
-            "import dagger.producers.ProductionSubcomponent;",
-            "",
-            "@ProductionSubcomponent",
-            "interface Sub {",
-            "  @ProductionSubcomponent.Builder",
-            "  interface Builder {",
-            "    Sub build();",
-            "  }",
-            "}");
-    assertThat(module, subcomponent)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            "test.Sub.Builder is a @ProductionSubcomponent.Builder. Did you mean to use test.Sub?")
-        .in(module)
-        .onLine(5);
-  }
-
-  @Test
-  public void moduleSubcomponents_noSubcomponentBuilder() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            moduleType.importStatement(),
-            "",
-            moduleType.annotationWithSubcomponent("NoBuilder.class"),
-            "class TestModule {}");
-    JavaFileObject subcomponent =
-        JavaFileObjects.forSourceLines(
-            "test.NoBuilder",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface NoBuilder {}");
-    assertThat(module, subcomponent)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            "test.NoBuilder doesn't have a @Subcomponent.Builder, which is required when used "
-                + "with @"
-                + moduleType.simpleName()
-                + ".subcomponents")
-        .in(module)
-        .onLine(5);
-  }
-
-  @Test
-  public void moduleSubcomponents_noProductionSubcomponentBuilder() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            moduleType.importStatement(),
-            "",
-            moduleType.annotationWithSubcomponent("NoBuilder.class"),
-            "class TestModule {}");
-    JavaFileObject subcomponent =
-        JavaFileObjects.forSourceLines(
-            "test.NoBuilder",
-            "package test;",
-            "",
-            "import dagger.producers.ProductionSubcomponent;",
-            "",
-            "@ProductionSubcomponent",
-            "interface NoBuilder {}");
-    assertThat(module, subcomponent)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            "test.NoBuilder doesn't have a @ProductionSubcomponent.Builder, which is required "
-                + "when used with @"
-                + moduleType.simpleName()
-                + ".subcomponents")
-        .in(module)
-        .onLine(5);
-  }
-
-  @Test
-  public void moduleSubcomponentsAreTypes() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "",
-            "@Module(subcomponents = int.class)",
-            "class TestModule {}");
-    assertThat(module)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("int is not a valid subcomponent type")
-        .in(module)
-        .onLine(5);
-  }
-  
-  @Test
-  public void tooManyAnnotations() {
-    assertThatModuleMethod(
-            "@BindsOptionalOf @Multibinds abstract Set<Object> tooManyAnnotations();")
-        .hasError("is annotated with more than one of");
-  }
-
-  @Test
-  public void invalidIncludedModule() {
-    JavaFileObject badModule =
-        JavaFileObjects.forSourceLines(
-            "test.BadModule",
-            "package test;",
-            "",
-            "import dagger.Binds;",
-            "import dagger.Module;",
-            "",
-            "@Module",
-            "abstract class BadModule {",
-            "  @Binds abstract Object noParameters();",
-            "}");
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.IncludesBadModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "",
-            "@Module(includes = BadModule.class)",
-            "abstract class IncludesBadModule {}");
-    assertThat(daggerCompiler().compile(badModule, module))
-        .hadErrorContaining("test.BadModule has errors")
-        .inFile(module)
-        .onLine(5);
-  }
-
-  @Test
-  public void invalidNestedMultibindingsType() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.IncludesBadMultibindings",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Multibindings;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "abstract class IncludesBadMultibindings {",
-            "  @Provides static String string() { return \"a string\"; }",
-            "",
-            "  @Multibindings interface BadMultibindings {",
-            "    String notASetOrMap();",
-            "  }",
-            "}");
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = IncludesBadMultibindings.class)",
-            "interface TestComponent {",
-            "  String aString();",
-            "}");
-    assertThat(daggerCompiler().compile(module, component))
-        .hadErrorContaining("test.IncludesBadMultibindings has errors")
-        .inFile(component)
-        .onLine(5);
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
deleted file mode 100644
index 95248e4c3..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/MultibindingsValidatorTest.java
+++ /dev/null
@@ -1,399 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMultibindingsMethod;
-import static java.util.Arrays.asList;
-
-import com.google.testing.compile.JavaFileObjects;
-import javax.inject.Qualifier;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class MultibindingsValidatorTest {
-
-  private static final JavaFileObject SOME_QUALIFIER =
-      JavaFileObjects.forSourceLines(
-          "test.SomeQualifier",
-          "package test;",
-          "",
-          "import javax.inject.Qualifier;",
-          "",
-          "@Qualifier",
-          "@interface SomeQualifier {}");
-
-  private static final JavaFileObject OTHER_QUALIFIER =
-      JavaFileObjects.forSourceLines(
-          "test.OtherQualifier",
-          "package test;",
-          "",
-          "import javax.inject.Qualifier;",
-          "",
-          "@Qualifier",
-          "@interface OtherQualifier {}");
-
-  @Test
-  public void abstractClass() {
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Multibindings;",
-            "import java.util.Map;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "class TestModule {",
-            "  @Multibindings",
-            "  static abstract class Empties {",
-            "    abstract Set<Object> emptySet();",
-            "    @SomeQualifier abstract Set<Object> emptyQualifiedSet();",
-            "    abstract Map<String, Object> emptyMap();",
-            "    @SomeQualifier abstract Map<String, Object> emptyQualifiedMap();",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(asList(testModule, SOME_QUALIFIER))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("@Multibindings can be applied only to interfaces")
-        .in(testModule)
-        .onLine(11);
-  }
-
-  @Test
-  public void concreteClass() {
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Multibindings;",
-            "import java.util.Map;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "class TestModule {",
-            "  @Multibindings",
-            "  static class Empties {",
-            "    Set<Object> emptySet() { return null; }",
-            "    @SomeQualifier Set<Object> emptyQualifiedSet() { return null; }",
-            "    Map<String, Object> emptyMap() { return null; }",
-            "    @SomeQualifier Map<String, Object> emptyQualifiedMap() { return null; }",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(asList(testModule, SOME_QUALIFIER))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("@Multibindings can be applied only to interfaces")
-        .in(testModule)
-        .onLine(11);
-  }
-
-  @Test
-  public void interfaceHasTypeParameters() {
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Multibindings;",
-            "import java.util.Map;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "class TestModule {",
-            "  @Multibindings",
-            "  interface Empties<T> {",
-            "    Set<T> emptySet();",
-            "    @SomeQualifier Set<T> emptyQualifiedSet();",
-            "    Map<String, T> emptyMap();",
-            "    @SomeQualifier Map<String, T> emptyQualifiedMap();",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(asList(testModule, SOME_QUALIFIER))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("@Multibindings types must not have type parameters")
-        .in(testModule)
-        .onLine(11);
-  }
-
-  @Test
-  public void topLevel() {
-    JavaFileObject testInterface =
-        JavaFileObjects.forSourceLines(
-            "test.TestInterface",
-            "package test;",
-            "",
-            "import dagger.Multibindings;",
-            "import java.util.Map;",
-            "import java.util.Set;",
-            "",
-            "@Multibindings",
-            "interface Empties {",
-            "  Set<Object> emptySet();",
-            "  @SomeQualifier Set<Object> emptyQualifiedSet();",
-            "  Map<String, Object> emptyMap();",
-            "  @SomeQualifier Map<String, Object> emptyQualifiedMap();",
-            "}");
-    assertAbout(javaSources())
-        .that(asList(testInterface, SOME_QUALIFIER))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            "@Multibindings types must be nested within a @Module or @ProducerModule")
-        .in(testInterface)
-        .onLine(8);
-  }
-
-  @Test
-  public void notWithinModule() {
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Multibindings;",
-            "import java.util.Map;",
-            "import java.util.Set;",
-            "",
-            "class TestModule {",
-            "  @Multibindings",
-            "  interface Empties {",
-            "    Set<Object> emptySet();",
-            "    @SomeQualifier Set<Object> emptyQualifiedSet();",
-            "    Map<String, Object> emptyMap();",
-            "    @SomeQualifier Map<String, Object> emptyQualifiedMap();",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(asList(testModule, SOME_QUALIFIER))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            "@Multibindings types must be nested within a @Module or @ProducerModule")
-        .in(testModule)
-        .onLine(9);
-  }
-
-  @Test
-  public void voidMethod() {
-    assertThatMultibindingsMethod("void voidMethod();")
-        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
-  }
-
-  @Test
-  public void primitiveMethod() {
-    assertThatMultibindingsMethod("int primitive();")
-        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
-  }
-
-  @Test
-  public void rawMap() {
-    assertThatMultibindingsMethod("Map rawMap();")
-        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
-  }
-
-  @Test
-  public void wildcardMap() {
-    assertThatMultibindingsMethod("Map<?, ?> wildcardMap();")
-        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
-  }
-
-  @Test
-  public void providerMap() {
-    assertThatMultibindingsMethod("Map<String, Provider<Object>> providerMap();")
-        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
-  }
-
-  @Test
-  public void producerMap() {
-    assertThatMultibindingsMethod("Map<String, Producer<Object>> producerMap();")
-        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
-  }
-
-  @Test
-  public void producedMap() {
-    assertThatMultibindingsMethod("Map<String, Produced<Object>> producedMap();")
-        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
-  }
-
-  @Test
-  public void rawSet() {
-    assertThatMultibindingsMethod("Set rawSet();")
-        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
-  }
-
-  @Test
-  public void wildcardSet() {
-    assertThatMultibindingsMethod("Set<?> wildcardSet();")
-        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
-  }
-
-  @Test
-  public void providerSet() {
-    assertThatMultibindingsMethod("Set<Provider<Object>> providerSet();")
-        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
-  }
-
-  @Test
-  public void producerSet() {
-    assertThatMultibindingsMethod("Set<Producer<Object>> producerSet();")
-        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
-  }
-
-  @Test
-  public void producedSet() {
-    assertThatMultibindingsMethod("Set<Produced<Object>> producedSet();")
-        .hasError("@Multibindings methods must return Map<K, V> or Set<T>");
-  }
-
-  @Test
-  public void overqualifiedSet() {
-    assertThatMultibindingsMethod(
-            "@SomeQualifier @OtherQualifier Set<Object> tooManyQualifiersSet();")
-        .importing(SomeQualifier.class, OtherQualifier.class)
-        .hasError("Cannot use more than one @Qualifier");
-  }
-
-  @Test
-  public void overqualifiedMap() {
-    assertThatMultibindingsMethod(
-            "@SomeQualifier @OtherQualifier Map<String, Object> tooManyQualifiersMap();")
-        .importing(SomeQualifier.class, OtherQualifier.class)
-        .hasError("Cannot use more than one @Qualifier");
-  }
-
-  @Test
-  public void hasParameters() {
-    assertThatMultibindingsMethod("Set<String> parameters(Object param);")
-        .hasError("@Multibindings methods cannot have parameters");
-  }
-
-  @Test
-  public void badMethodsOnSupertype() {
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Multibindings;",
-            "import dagger.producers.Produced;",
-            "import dagger.producers.Producer;",
-            "import java.util.Map;",
-            "import java.util.Set;",
-            "import javax.inject.Provider;",
-            "",
-            "@Module",
-            "class TestModule {",
-            "  interface BaseEmpties {",
-            "    void voidMethod();",
-            "  }",
-            "",
-            "  @Multibindings",
-            "  interface Empties extends BaseEmpties {}",
-            "}");
-    assertAbout(javaSources())
-        .that(asList(testModule, SOME_QUALIFIER, OTHER_QUALIFIER))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            "[test.TestModule.BaseEmpties.voidMethod()] "
-                + "@Multibindings methods must return Map<K, V> or Set<T>")
-        .in(testModule)
-        .onLine(18);
-  }
-
-  @Test
-  public void duplicateKeys() {
-    JavaFileObject testModule =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Multibindings;",
-            "import java.util.Map;",
-            "import java.util.Set;",
-            "",
-            "@Module",
-            "class TestModule {",
-            "  @Multibindings",
-            "  interface EmptySets {",
-            "    Set<Object> emptySet();",
-            "    Set<Object> emptySet2();",
-            "  }",
-            "",
-            "  @Multibindings",
-            "  interface EmptyQualifiedSets {",
-            "    @SomeQualifier Set<Object> emptyQualifiedSet();",
-            "    @SomeQualifier Set<Object> emptyQualifiedSet2();",
-            "  }",
-            "",
-            "  @Multibindings",
-            "  interface EmptyMaps {",
-            "    Map<String, Object> emptyMap();",
-            "    Map<String, Object> emptyMap2();",
-            "  }",
-            "",
-            "  @Multibindings",
-            "  interface EmptyQualifiedMaps {",
-            "    @SomeQualifier Map<String, Object> emptyQualifiedMap();",
-            "    @SomeQualifier Map<String, Object> emptyQualifiedMap2();",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(asList(testModule, SOME_QUALIFIER))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Too many @Multibindings methods for Set<Object>:")
-        .in(testModule)
-        .onLine(11)
-        .and()
-        .withErrorContaining("Too many @Multibindings methods for @test.SomeQualifier Set<Object>:")
-        .in(testModule)
-        .onLine(17)
-        .and()
-        .withErrorContaining("Too many @Multibindings methods for Map<String,Provider<Object>>:")
-        .in(testModule)
-        .onLine(23)
-        .and()
-        .withErrorContaining(
-            "Too many @Multibindings methods for @test.SomeQualifier Map<String,Provider<Object>>:")
-        .in(testModule)
-        .onLine(29);
-  }
-
-  @Qualifier
-  public @interface SomeQualifier {}
-
-  @Qualifier
-  public @interface OtherQualifier {}
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
deleted file mode 100644
index ce65429c3..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ /dev/null
@@ -1,529 +0,0 @@
-/*
- * Copyright (C) 2014 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-// TODO(beder): Merge the error-handling tests with the ModuleFactoryGeneratorTest.
-package dagger.internal.codegen;
-
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;
-import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatProductionModuleMethod;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
-import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SCOPE;
-import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-
-import com.google.common.collect.ImmutableList;
-import com.google.common.util.concurrent.ListenableFuture;
-import com.google.testing.compile.JavaFileObjects;
-import javax.inject.Qualifier;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class ProducerModuleFactoryGeneratorTest {
-
-  private String formatErrorMessage(String msg) {
-    return String.format(msg, "Produces");
-  }
-
-  private String formatModuleErrorMessage(String msg) {
-    return String.format(msg, "Produces", "ProducerModule");
-  }
-
-  @Test public void producesMethodNotInModule() {
-    assertThatMethodInUnannotatedClass("@Produces String produceString() { return null; }")
-        .hasError(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE));
-  }
-
-  @Test public void producesMethodAbstract() {
-    assertThatProductionModuleMethod("@Produces abstract String produceString();")
-        .hasError(formatErrorMessage(BINDING_METHOD_ABSTRACT));
-  }
-
-  @Test public void producesMethodPrivate() {
-    assertThatProductionModuleMethod("@Produces private String produceString() { return null; }")
-        .hasError(formatErrorMessage(BINDING_METHOD_PRIVATE));
-  }
-
-  @Test public void producesMethodReturnVoid() {
-    assertThatProductionModuleMethod("@Produces void produceNothing() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
-  }
-
-  @Test
-  public void producesProvider() {
-    assertThatProductionModuleMethod("@Produces Provider<String> produceProvider() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
-  }
-
-  @Test
-  public void producesLazy() {
-    assertThatProductionModuleMethod("@Produces Lazy<String> produceLazy() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
-  }
-
-  @Test
-  public void producesMembersInjector() {
-    assertThatProductionModuleMethod(
-            "@Produces MembersInjector<String> produceMembersInjector() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
-  }
-
-  @Test
-  public void producesProducer() {
-    assertThatProductionModuleMethod("@Produces Producer<String> produceProducer() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
-  }
-
-  @Test
-  public void producesProduced() {
-    assertThatProductionModuleMethod("@Produces Produced<String> produceProduced() {}")
-        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
-  }
-
-  @Test public void producesMethodReturnRawFuture() {
-    assertThatProductionModuleMethod("@Produces ListenableFuture produceRaw() {}")
-        .importing(ListenableFuture.class)
-        .hasError(PRODUCES_METHOD_RAW_FUTURE);
-  }
-
-  @Test public void producesMethodReturnWildcardFuture() {
-    assertThatProductionModuleMethod("@Produces ListenableFuture<?> produceRaw() {}")
-        .importing(ListenableFuture.class)
-        .hasError(PRODUCES_METHOD_RETURN_TYPE);
-  }
-
-  @Test public void producesMethodWithTypeParameter() {
-    assertThatProductionModuleMethod("@Produces <T> String produceString() { return null; }")
-        .hasError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));
-  }
-
-  @Test public void producesMethodSetValuesWildcard() {
-    assertThatProductionModuleMethod(
-            "@Produces @ElementsIntoSet Set<?> produceWildcard() { return null; }")
-        .hasError(PRODUCES_METHOD_RETURN_TYPE);
-  }
-
-  @Test public void producesMethodSetValuesRawSet() {
-    assertThatProductionModuleMethod(
-            "@Produces @ElementsIntoSet Set produceSomething() { return null; }")
-        .hasError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
-  }
-
-  @Test public void producesMethodSetValuesNotASet() {
-    assertThatProductionModuleMethod(
-            "@Produces @ElementsIntoSet List<String> produceStrings() { return null; }")
-        .hasError(PRODUCES_METHOD_SET_VALUES_RETURN_SET);
-  }
-
-  @Test public void producesMethodSetValuesWildcardInFuture() {
-    assertThatProductionModuleMethod(
-            "@Produces @ElementsIntoSet "
-                + "ListenableFuture<Set<?>> produceWildcard() { return null; }")
-        .importing(ListenableFuture.class)
-        .hasError(PRODUCES_METHOD_RETURN_TYPE);
-  }
-
-  @Test public void producesMethodSetValuesFutureRawSet() {
-    assertThatProductionModuleMethod(
-            "@Produces @ElementsIntoSet ListenableFuture<Set> produceSomething() { return null; }")
-        .importing(ListenableFuture.class)
-        .hasError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
-  }
-
-  @Test public void producesMethodSetValuesFutureNotASet() {
-    assertThatProductionModuleMethod(
-            "@Produces @ElementsIntoSet "
-                + "ListenableFuture<List<String>> produceStrings() { return null; }")
-        .importing(ListenableFuture.class)
-        .hasError(PRODUCES_METHOD_SET_VALUES_RETURN_SET);
-  }
-
-  @Test public void multipleProducesMethodsWithSameName() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces Object produce(int i) {",
-        "    return i;",
-        "  }",
-        "",
-        "  @Produces String produce() {",
-        "    return \"\";",
-        "  }",
-        "}");
-    String errorMessage = String.format(BINDING_METHOD_WITH_SAME_NAME, "Produces");
-    assertAbout(javaSource()).that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(errorMessage).in(moduleFile).onLine(8)
-        .and().withErrorContaining(errorMessage).in(moduleFile).onLine(12);
-  }
-
-  @Test
-  public void producesMethodThrowsThrowable() {
-    assertThatProductionModuleMethod("@Produces int produceInt() throws Throwable { return 0; }")
-        .hasError(
-            "@Produces methods may only throw unchecked exceptions or exceptions subclassing "
-                + "Exception");
-  }
-
-  @Test public void producesMethodWithScope() {
-    assertThatProductionModuleMethod("@Produces @Singleton String str() { return \"\"; }")
-        .hasError(PRODUCES_METHOD_SCOPE);
-  }
-
-  @Test
-  public void privateModule() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.Enclosing",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "",
-        "final class Enclosing {",
-        "  @ProducerModule private static final class PrivateModule {",
-        "  }",
-        "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Modules cannot be private.")
-        .in(moduleFile).onLine(6);
-  }
-
-  @Test
-  public void enclosedInPrivateModule() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.Enclosing",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "",
-        "final class Enclosing {",
-        "  private static final class PrivateEnclosing {",
-        "    @ProducerModule static final class TestModule {",
-        "    }",
-        "  }",
-        "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("Modules cannot be enclosed in private types.")
-        .in(moduleFile).onLine(7);
-  }
-
-  @Test
-  public void includesNonModule() {
-    JavaFileObject xFile =
-        JavaFileObjects.forSourceLines("test.X", "package test;", "", "public final class X {}");
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.FooModule",
-            "package test;",
-            "",
-            "import dagger.producers.ProducerModule;",
-            "",
-            "@ProducerModule(includes = X.class)",
-            "public final class FooModule {",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(xFile, moduleFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(
-                ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED,
-                "X",
-                "one of @Module, @ProducerModule"));
-  }
-
-  @Test
-  public void publicModuleNonPublicIncludes() {
-    JavaFileObject publicModuleFile = JavaFileObjects.forSourceLines("test.PublicModule",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "",
-        "@ProducerModule(includes = {",
-        "    NonPublicModule1.class, OtherPublicModule.class, NonPublicModule2.class",
-        "})",
-        "public final class PublicModule {",
-        "}");
-    JavaFileObject nonPublicModule1File = JavaFileObjects.forSourceLines("test.NonPublicModule1",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "",
-        "@ProducerModule",
-        "final class NonPublicModule1 {",
-        "}");
-    JavaFileObject nonPublicModule2File = JavaFileObjects.forSourceLines("test.NonPublicModule2",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "",
-        "@ProducerModule",
-        "final class NonPublicModule2 {",
-        "}");
-    JavaFileObject otherPublicModuleFile = JavaFileObjects.forSourceLines("test.OtherPublicModule",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "",
-        "@ProducerModule",
-        "public final class OtherPublicModule {",
-        "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(
-            publicModuleFile, nonPublicModule1File, nonPublicModule2File, otherPublicModuleFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("This module is public, but it includes non-public "
-            + "(or effectively non-public) modules. "
-            + "Either reduce the visibility of this module or make "
-            + "test.NonPublicModule1 and test.NonPublicModule2 public.")
-        .in(publicModuleFile).onLine(8);
-  }
-
-  @Test public void argumentNamedModuleCompiles() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces String produceString(int module) {",
-        "    return null;",
-        "  }",
-        "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
-  }
-
-  @Test public void singleProducesMethodNoArgsFuture() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "",
-        "@ProducerModule",
-        "final class TestModule {",
-        "  @Produces ListenableFuture<String> produceString() {",
-        "    return null;",
-        "  }",
-        "}");
-    JavaFileObject factoryFile =
-        JavaFileObjects.forSourceLines(
-            "TestModule_ProduceStringFactory",
-            "package test;",
-            "",
-            "import com.google.common.util.concurrent.AsyncFunction;",
-            "import com.google.common.util.concurrent.Futures;",
-            "import com.google.common.util.concurrent.ListenableFuture;",
-            "import dagger.producers.internal.AbstractProducer;",
-            "import dagger.producers.monitoring.ProducerToken;",
-            "import dagger.producers.monitoring.ProductionComponentMonitor;",
-            "import java.util.concurrent.Executor;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class TestModule_ProduceStringFactory",
-            "    extends AbstractProducer<String>",
-            "    implements AsyncFunction<Void, String>, Executor {",
-            "  private final TestModule module;",
-            "  private final Provider<Executor> executorProvider;",
-            "  private final Provider<ProductionComponentMonitor> monitorProvider;",
-            "",
-            "  public TestModule_ProduceStringFactory(",
-            "      TestModule module,",
-            "      Provider<Executor> executorProvider,",
-            "      Provider<ProductionComponentMonitor> monitorProvider) {",
-            "    super(",
-            "        monitorProvider,",
-            "        ProducerToken.create(TestModule_ProduceStringFactory.class));",
-            "    assert module != null;",
-            "    this.module = module;",
-            "    assert executorProvider != null;",
-            "    this.executorProvider = executorProvider;",
-            "    assert monitorProvider != null;",
-            "    this.monitorProvider = monitorProvider;",
-            "  }",
-            "",
-            "  @Override protected ListenableFuture<String> compute() {",
-            "    return Futures.transformAsync(",
-            "        Futures.<Void>immediateFuture(null), this, this);",
-            "  }",
-            "",
-            "  @Deprecated",
-            "  @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
-            "    assert monitor != null :",
-            "        \"apply() may only be called internally from compute(); \"",
-            "        + \"if it's called explicitly, the monitor might be null\";",
-            "    monitor.methodStarting();",
-            "    try {",
-            "      return TestModule_ProduceStringFactory.this.module.produceString();",
-            "    } finally {",
-            "      monitor.methodFinished();",
-            "    }",
-            "  }",
-            "",
-            "  @Deprecated",
-            "  @Override public void execute(Runnable runnable) {",
-            "    assert monitor != null :",
-            "        \"execute() may only be called internally from compute(); \"",
-            "        + \"if it's called explicitly, the monitor might be null\";",
-            "    monitor.ready();",
-            "    executorProvider.get().execute(runnable);",
-            "  }",
-            "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(factoryFile);
-  }
-
-  @Test
-  public void singleProducesMethodNoArgsFutureWithProducerName() {
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import com.google.common.util.concurrent.Futures;",
-            "import com.google.common.util.concurrent.ListenableFuture;",
-            "import dagger.producers.ProducerModule;",
-            "import dagger.producers.Produces;",
-            "",
-            "@ProducerModule",
-            "final class TestModule {",
-            "  @Produces ListenableFuture<String> produceString() {",
-            "    return Futures.immediateFuture(\"\");",
-            "  }",
-            "}");
-    JavaFileObject factoryFile =
-        JavaFileObjects.forSourceLines(
-            "TestModule_ProduceStringFactory",
-            "package test;",
-            "",
-            "import com.google.common.util.concurrent.AsyncFunction;",
-            "import com.google.common.util.concurrent.Futures;",
-            "import com.google.common.util.concurrent.ListenableFuture;",
-            "import dagger.producers.internal.AbstractProducer;",
-            "import dagger.producers.monitoring.ProducerToken;",
-            "import dagger.producers.monitoring.ProductionComponentMonitor;",
-            "import java.util.concurrent.Executor;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class TestModule_ProduceStringFactory",
-            "    extends AbstractProducer<String>",
-            "    implements AsyncFunction<Void, String>, Executor {",
-            "  private final TestModule module;",
-            "  private final Provider<Executor> executorProvider;",
-            "  private final Provider<ProductionComponentMonitor> monitorProvider;",
-            "",
-            "  public TestModule_ProduceStringFactory(",
-            "      TestModule module,",
-            "      Provider<Executor> executorProvider,",
-            "      Provider<ProductionComponentMonitor> monitorProvider) {",
-            "    super(",
-            "        monitorProvider,",
-            "        ProducerToken.create(\"test.TestModule#produceString\"));",
-            "    assert module != null;",
-            "    this.module = module;",
-            "    assert executorProvider != null;",
-            "    this.executorProvider = executorProvider;",
-            "    assert monitorProvider != null;",
-            "    this.monitorProvider = monitorProvider;",
-            "  }",
-            "",
-            "  @Override protected ListenableFuture<String> compute() {",
-            "    return Futures.transformAsync(",
-            "      Futures.<Void>immediateFuture(null), this, this);",
-            "  }",
-            "",
-            "  @Deprecated",
-            "  @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
-            "    assert monitor != null :",
-            "        \"apply() may only be called internally from compute(); \"",
-            "        + \"if it's called explicitly, the monitor might be null\";",
-            "    monitor.methodStarting();",
-            "    try {",
-            "      return TestModule_ProduceStringFactory.this.module.produceString();",
-            "    } finally {",
-            "      monitor.methodFinished();",
-            "    }",
-            "  }",
-            "",
-            "  @Deprecated",
-            "  @Override public void execute(Runnable runnable) {",
-            "    assert monitor != null :",
-            "        \"execute() may only be called internally from compute(); \"",
-            "        + \"if it's called explicitly, the monitor might be null\";",
-            "    monitor.ready();",
-            "    executorProvider.get().execute(runnable);",
-            "  }",
-            "}");
-    assertAbout(javaSource())
-        .that(moduleFile)
-        .withCompilerOptions("-Adagger.writeProducerNameInToken=ENABLED")
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(factoryFile);
-  }
-
-  @Test public void producesMethodMultipleQualifiers() {
-    assertThatProductionModuleMethod(
-            "@Produces @QualifierA @QualifierB abstract String produceString() { return null; }")
-        .importing(ListenableFuture.class, QualifierA.class, QualifierB.class)
-        .hasError(BINDING_METHOD_MULTIPLE_QUALIFIERS);
-  }
-  
-  @Qualifier
-  public @interface QualifierA {}
-
-  @Qualifier
-  public @interface QualifierB {}
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
deleted file mode 100644
index 1a1bb6474..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ /dev/null
@@ -1,372 +0,0 @@
-/*
- * Copyright (C) 2014 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-
-import com.google.common.collect.ImmutableList;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class ProductionComponentProcessorTest {
-  @Test public void componentOnConcreteClass() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
-        "package test;",
-        "",
-        "import dagger.producers.ProductionComponent;",
-        "",
-        "@ProductionComponent",
-        "final class NotAComponent {}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("interface");
-  }
-
-  @Test public void componentOnEnum() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
-        "package test;",
-        "",
-        "import dagger.producers.ProductionComponent;",
-        "",
-        "@ProductionComponent",
-        "enum NotAComponent {",
-        "  INSTANCE",
-        "}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("interface");
-  }
-
-  @Test public void componentOnAnnotation() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
-        "package test;",
-        "",
-        "import dagger.producers.ProductionComponent;",
-        "",
-        "@ProductionComponent",
-        "@interface NotAComponent {}");
-    assertAbout(javaSource()).that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("interface");
-  }
-
-  @Test public void nonModuleModule() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
-        "package test;",
-        "",
-        "import dagger.producers.ProductionComponent;",
-        "",
-        "@ProductionComponent(modules = Object.class)",
-        "interface NotAComponent {}");
-    assertAbout(javaSource())
-        .that(componentFile)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("is not annotated with one of @Module, @ProducerModule");
-  }
-
-  @Test
-  public void dependsOnProductionExecutor() {
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.ExecutorModule",
-            "package test;",
-            "",
-            "import com.google.common.util.concurrent.MoreExecutors;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.producers.Production;",
-            "import java.util.concurrent.Executor;",
-            "",
-            "@Module",
-            "final class ExecutorModule {",
-            "  @Provides @Production Executor executor() {",
-            "    return MoreExecutors.directExecutor();",
-            "  }",
-            "}");
-    JavaFileObject producerModuleFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleModule",
-            "package test;",
-            "",
-            "import dagger.producers.ProducerModule;",
-            "import dagger.producers.Produces;",
-            "import dagger.producers.Production;",
-            "import java.util.concurrent.Executor;",
-            "",
-            "@ProducerModule",
-            "final class SimpleModule {",
-            "  @Produces String str(@Production Executor executor) {",
-            "    return \"\";",
-            "  }",
-            "}");
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.SimpleComponent",
-            "package test;",
-            "",
-            "import com.google.common.util.concurrent.ListenableFuture;",
-            "import dagger.producers.ProductionComponent;",
-            "import java.util.concurrent.Executor;",
-            "",
-            "@ProductionComponent(modules = {ExecutorModule.class, SimpleModule.class})",
-            "interface SimpleComponent {",
-            "  ListenableFuture<String> str();",
-            "",
-            "  @ProductionComponent.Builder",
-            "  interface Builder {",
-            "    SimpleComponent build();",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, producerModuleFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("may not depend on the production executor");
-  }
-
-  @Test
-  public void simpleComponent() {
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.TestClass",
-            "package test;",
-            "",
-            "import com.google.common.util.concurrent.ListenableFuture;",
-            "import com.google.common.util.concurrent.MoreExecutors;",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "import dagger.producers.ProducerModule;",
-            "import dagger.producers.Produces;",
-            "import dagger.producers.Production;",
-            "import dagger.producers.ProductionComponent;",
-            "import java.util.concurrent.Executor;",
-            "import javax.inject.Inject;",
-            "",
-            "final class TestClass {",
-            "  static final class C {",
-            "    @Inject C() {}",
-            "  }",
-            "",
-            "  interface A {}",
-            "  interface B {}",
-            "",
-            "  @Module",
-            "  static final class BModule {",
-            "    @Provides B b(C c) {",
-            "      return null;",
-            "    }",
-            "",
-            "    @Provides @Production Executor executor() {",
-            "      return MoreExecutors.directExecutor();",
-            "    }",
-            "  }",
-            "",
-            "  @ProducerModule",
-            "  static final class AModule {",
-            "    @Produces ListenableFuture<A> a(B b) {",
-            "      return null;",
-            "    }",
-            "  }",
-            "",
-            "  @ProductionComponent(modules = {AModule.class, BModule.class})",
-            "  interface SimpleComponent {",
-            "    ListenableFuture<A> a();",
-            "  }",
-            "}");
-    JavaFileObject generatedComponent =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerTestClass_SimpleComponent",
-            "package test;",
-            "",
-            "import com.google.common.util.concurrent.ListenableFuture;",
-            "import dagger.internal.DoubleCheck;",
-            "import dagger.internal.InstanceFactory;",
-            "import dagger.internal.Preconditions;",
-            "import dagger.internal.SetFactory;",
-            "import dagger.producers.Producer;",
-            "import dagger.producers.internal.Producers;",
-            "import dagger.producers.monitoring.ProductionComponentMonitor;",
-            "import java.util.concurrent.Executor;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerTestClass_SimpleComponent",
-            "    implements TestClass.SimpleComponent {",
-            "  private Provider<Executor> executorProvider;",
-            "  private Provider<Executor> executorProvider2;",
-            "  private Provider<TestClass.SimpleComponent> simpleComponentProvider;",
-            "  private Provider<ProductionComponentMonitor> monitorProvider;",
-            "  private Provider<TestClass.B> bProvider;",
-            "  private Producer<TestClass.A> aProducer;",
-            "  private Producer<TestClass.B> bProducer;",
-            "",
-            "  private DaggerTestClass_SimpleComponent(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static TestClass.SimpleComponent create() {",
-            "    return builder().build()",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.executorProvider =",
-            "        TestClass_BModule_ExecutorFactory.create(builder.bModule);",
-            "     this.executorProvider2 =",
-            "         DoubleCheck.provider(",
-            "             TestClass_SimpleComponent_ProductionExecutorModule_ExecutorFactory",
-            "                 .create(executorProvider));",
-            "    this.simpleComponentProvider =",
-            "        InstanceFactory.<TestClass.SimpleComponent>create(this);",
-            "    this.monitorProvider =",
-            "        DoubleCheck.provider(",
-            "            TestClass_SimpleComponent_MonitoringModule_MonitorFactory.create(",
-            "                simpleComponentProvider,",
-            "                SetFactory.<ProductionComponentMonitor.Factory>empty());",
-            "    this.bProvider = TestClass_BModule_BFactory.create(",
-            "        builder.bModule, TestClass_C_Factory.create());",
-            "    this.bProducer = Producers.producerFromProvider(bProvider);",
-            "    this.aProducer = new TestClass_AModule_AFactory(",
-            "        builder.aModule,",
-            "        executorProvider2,",
-            "        monitorProvider,",
-            "        bProducer);",
-            "  }",
-            "",
-            "  @Override",
-            "  public ListenableFuture<TestClass.A> a() {",
-            "    return aProducer.get();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private TestClass.BModule bModule;",
-            "    private TestClass.AModule aModule;",
-            "",
-            "    private Builder() {",
-            "    }",
-            "",
-            "    public TestClass.SimpleComponent build() {",
-            "      if (bModule == null) {",
-            "        this.bModule = new TestClass.BModule();",
-            "      }",
-            "      if (aModule == null) {",
-            "        this.aModule = new TestClass.AModule();",
-            "      }",
-            "      return new DaggerTestClass_SimpleComponent(this);",
-            "    }",
-            "",
-            "    public Builder aModule(TestClass.AModule aModule) {",
-            "      this.aModule = Preconditions.checkNotNull(aModule);",
-            "      return this;",
-            "    }",
-            "",
-            "    public Builder bModule(TestClass.BModule bModule) {",
-            "      this.bModule = Preconditions.checkNotNull(bModule);",
-            "      return this;",
-            "    }",
-            "",
-            "    @Deprecated",
-            "    public Builder testClass_SimpleComponent_ProductionExecutorModule(",
-            "        TestClass_SimpleComponent_ProductionExecutorModule",
-            "        testClass_SimpleComponent_ProductionExecutorModule) {",
-            "      Preconditions.checkNotNull(testClass_SimpleComponent_ProductionExecutorModule);",
-            "      return this;",
-            "    }",
-            "}");
-    assertAbout(javaSource()).that(component)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and().generatesSources(generatedComponent);
-  }
-
-  @Test public void nullableProducersAreNotErrors() {
-    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
-        "package test;",
-        "",
-        "import com.google.common.util.concurrent.ListenableFuture;",
-        "import com.google.common.util.concurrent.MoreExecutors;",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import dagger.producers.ProducerModule;",
-        "import dagger.producers.Produces;",
-        "import dagger.producers.Production;",
-        "import dagger.producers.ProductionComponent;",
-        "import java.util.concurrent.Executor;",
-        "import javax.annotation.Nullable;",
-        "import javax.inject.Inject;",
-        "",
-        "final class TestClass {",
-        "  interface A {}",
-        "  interface B {}",
-        "  interface C {}",
-        "",
-        "  @Module",
-        "  static final class CModule {",
-        "    @Provides @Nullable C c() {",
-        "      return null;",
-        "    }",
-        "",
-        "    @Provides @Production Executor executor() {",
-        "      return MoreExecutors.directExecutor();",
-        "    }",
-        "  }",
-        "",
-        "  @ProducerModule",
-        "  static final class ABModule {",
-        "    @Produces @Nullable B b(@Nullable C c) {",
-        "      return null;",
-        "    }",
-
-        "    @Produces @Nullable ListenableFuture<A> a(B b) {",  // NOTE: B not injected as nullable
-        "      return null;",
-        "    }",
-        "  }",
-        "",
-        "  @ProductionComponent(modules = {ABModule.class, CModule.class})",
-        "  interface SimpleComponent {",
-        "    ListenableFuture<A> a();",
-        "  }",
-        "}");
-    assertAbout(javaSource()).that(component)
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .withWarningContaining("@Nullable on @Produces methods does not do anything")
-        .in(component)
-        .onLine(33)
-        .and()
-        .withWarningContaining("@Nullable on @Produces methods does not do anything")
-        .in(component)
-        .onLine(36);
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/RepeatedModuleValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/RepeatedModuleValidationTest.java
deleted file mode 100644
index 978dc6b3e..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/RepeatedModuleValidationTest.java
+++ /dev/null
@@ -1,121 +0,0 @@
-package dagger.internal.codegen;
-
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-
-import com.google.common.collect.ImmutableList;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public class RepeatedModuleValidationTest {
-  private static final JavaFileObject MODULE_FILE =
-      JavaFileObjects.forSourceLines(
-          "test.TestModule",
-          "package test;",
-          "",
-          "import dagger.Module;",
-          "",
-          "@Module",
-          "final class TestModule {}");
-
-  @Test
-  public void moduleRepeatedInSubcomponentFactoryMethod() {
-    JavaFileObject subcomponentFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestSubcomponent",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = TestModule.class)",
-            "interface TestSubcomponent {",
-            "}");
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  TestSubcomponent newTestSubcomponent(TestModule module);",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("TestModule is present in test.TestComponent.")
-        .in(componentFile)
-        .onLine(7)
-        .atColumn(51);
-  }
-
-  @Test
-  public void moduleRepeatedInSubcomponentBuilderMethod() {
-    JavaFileObject subcomponentFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestSubcomponent",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = TestModule.class)",
-            "interface TestSubcomponent {",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    Builder testModule(TestModule testModule);",
-            "    TestSubcomponent build();",
-            "  }",
-            "}");
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  TestSubcomponent.Builder newTestSubcomponentBuilder();",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
-    // TODO(gak): assert about the warning when we have that ability
-  }
-
-  @Test
-  public void moduleRepeatedButNotPassed() {
-    JavaFileObject subcomponentFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestSubcomponent",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = TestModule.class)",
-            "interface TestSubcomponent {",
-            "}");
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface TestComponent {",
-            "  TestSubcomponent newTestSubcomponent();",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError();
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
deleted file mode 100644
index 01389933f..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
+++ /dev/null
@@ -1,842 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-
-import com.google.common.base.Joiner;
-import com.google.common.collect.ImmutableList;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-/** Tests for {@link dagger.Subcomponent.Builder} validation. */
-@RunWith(JUnit4.class)
-public class SubcomponentBuilderValidationTest {
-
-  private static final ErrorMessages.SubcomponentBuilderMessages MSGS =
-      new ErrorMessages.SubcomponentBuilderMessages();
-
-  @Test
-  public void testRefSubcomponentAndSubBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface ParentComponent {",
-        "  ChildComponent child();",
-        "  ChildComponent.Builder builder();",
-        "}");
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "interface ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  static interface Builder {",
-        "    ChildComponent build();",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(MSGS.moreThanOneRefToSubcomponent(),
-            "test.ChildComponent", "[child(), builder()]"))
-        .in(componentFile);
-  }
-
-  @Test
-  public void testRefSubBuilderTwiceFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface ParentComponent {",
-        "  ChildComponent.Builder builder1();",
-        "  ChildComponent.Builder builder2();",
-        "}");
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "interface ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  static interface Builder {",
-        "    ChildComponent build();",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(MSGS.moreThanOneRefToSubcomponent(),
-            "test.ChildComponent", "[builder1(), builder2()]"))
-        .in(componentFile);
-  }
-
-  @Test
-  public void testMoreThanOneBuilderFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface ParentComponent {",
-        "  ChildComponent.Builder1 build();",
-        "}");
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "interface ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  static interface Builder1 {",
-        "    ChildComponent build();",
-        "  }",
-        "",
-        "  @Subcomponent.Builder",
-        "  static interface Builder2 {",
-        "    ChildComponent build();",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(MSGS.moreThanOne(),
-            "[test.ChildComponent.Builder1, test.ChildComponent.Builder2]"))
-        .in(childComponentFile);
-  }
-
-  @Test
-  public void testBuilderGenericsFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface ParentComponent {",
-        "  ChildComponent.Builder1 build();",
-        "}");
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "interface ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  interface Builder<T> {",
-        "     ChildComponent build();",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.generics())
-        .in(childComponentFile);
-  }
-
-  @Test
-  public void testBuilderNotInComponentFails() {
-    JavaFileObject builder = JavaFileObjects.forSourceLines("test.Builder",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent.Builder",
-        "interface Builder {}");
-    assertAbout(javaSource()).that(builder)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.mustBeInComponent())
-        .in(builder);
-  }
-
-  @Test
-  public void testBuilderMissingBuildMethodFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface ParentComponent {",
-        "  ChildComponent.Builder1 build();",
-        "}");
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "interface ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  interface Builder {}",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.missingBuildMethod())
-        .in(childComponentFile);
-  }
-
-  @Test
-  public void testPrivateBuilderFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  private interface Builder {}",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.isPrivate())
-        .in(childComponentFile);
-  }
-
-  @Test
-  public void testNonStaticBuilderFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  abstract class Builder {}",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.mustBeStatic())
-        .in(childComponentFile);
-  }
-
-  @Test
-  public void testNonAbstractBuilderFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  static class Builder {}",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.mustBeAbstract())
-        .in(childComponentFile);
-  }
-
-  @Test
-  public void testBuilderOneCxtorWithArgsFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  static abstract class Builder {",
-        "    Builder(String unused) {}",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
-        .in(childComponentFile);
-  }
-
-  @Test
-  public void testBuilderMoreThanOneCxtorFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  static abstract class Builder {",
-        "    Builder() {}",
-        "    Builder(String unused) {}",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
-        .in(childComponentFile);
-  }
-
-  @Test
-  public void testBuilderEnumFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  enum Builder {}",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.mustBeClassOrInterface())
-        .in(childComponentFile);
-  }
-
-  @Test
-  public void testBuilderBuildReturnsWrongTypeFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  interface Builder {",
-        "    String build();",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.buildMustReturnComponentType())
-            .in(childComponentFile).onLine(9);
-  }
-
-  @Test
-  public void testInheritedBuilderBuildReturnsWrongTypeFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  interface Parent {",
-        "    String build();",
-        "  }",
-        "",
-        "  @Subcomponent.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
-            .in(childComponentFile).onLine(12);
-  }
-
-  @Test
-  public void testTwoBuildMethodsFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  interface Builder {",
-        "    ChildComponent build();",
-        "    ChildComponent create();",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(String.format(MSGS.twoBuildMethods(), "build()"))
-            .in(childComponentFile).onLine(10);
-  }
-
-  @Test
-  public void testInheritedTwoBuildMethodsFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  interface Parent {",
-        "    ChildComponent build();",
-        "    ChildComponent create();",
-        "  }",
-        "",
-        "  @Subcomponent.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.inheritedTwoBuildMethods(), "create()", "build()"))
-            .in(childComponentFile).onLine(13);
-  }
-
-  @Test
-  public void testMoreThanOneArgFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  interface Builder {",
-        "    ChildComponent build();",
-        "    Builder set(String s, Integer i);",
-        "    Builder set(Number n, Double d);",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.methodsMustTakeOneArg())
-            .in(childComponentFile).onLine(10)
-        .and().withErrorContaining(MSGS.methodsMustTakeOneArg())
-            .in(childComponentFile).onLine(11);
-  }
-
-  @Test
-  public void testInheritedMoreThanOneArgFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  interface Parent {",
-        "    ChildComponent build();",
-        "    Builder set1(String s, Integer i);",
-        "  }",
-        "",
-        "  @Subcomponent.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.inheritedMethodsMustTakeOneArg(),
-                "set1(java.lang.String,java.lang.Integer)"))
-            .in(childComponentFile).onLine(13);
-  }
-
-  @Test
-  public void testSetterReturningNonVoidOrBuilderFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  interface Builder {",
-        "    ChildComponent build();",
-        "    String set(Integer i);",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())
-            .in(childComponentFile).onLine(10);
-  }
-
-  @Test
-  public void testInheritedSetterReturningNonVoidOrBuilderFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  interface Parent {",
-        "    ChildComponent build();",
-        "    String set(Integer i);",
-        "  }",
-        "",
-        "  @Subcomponent.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(),
-                "set(java.lang.Integer)"))
-            .in(childComponentFile).onLine(13);
-  }
-
-  @Test
-  public void testGenericsOnSetterMethodFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  interface Builder {",
-        "    ChildComponent build();",
-        "    <T> Builder set(T t);",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(MSGS.methodsMayNotHaveTypeParameters())
-            .in(childComponentFile).onLine(10);
-  }
-
-  @Test
-  public void testGenericsOnInheritedSetterMethodFails() {
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "abstract class ChildComponent {",
-        "  interface Parent {",
-        "    ChildComponent build();",
-        "    <T> Builder set(T t);",
-        "  }",
-        "",
-        "  @Subcomponent.Builder",
-        "  interface Builder extends Parent {}",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.inheritedMethodsMayNotHaveTypeParameters(), "<T>set(T)"))
-            .in(childComponentFile).onLine(13);
-  }
-
-  @Test
-  public void testMultipleSettersPerTypeFails() {
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "final class TestModule {",
-            "  @Provides String s() { return \"\"; }",
-            "}");
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.ParentComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface ParentComponent {",
-            "  ChildComponent.Builder childComponentBuilder();",
-            "}");
-    JavaFileObject childComponentFile =
-        JavaFileObjects.forSourceLines(
-            "test.ChildComponent",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = TestModule.class)",
-            "abstract class ChildComponent {",
-            "  abstract String s();",
-            "",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    ChildComponent build();",
-            "    void set1(TestModule s);",
-            "    void set2(TestModule s);",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(
-                MSGS.manyMethodsForType(),
-                "test.TestModule",
-                "[set1(test.TestModule), set2(test.TestModule)]"))
-        .in(childComponentFile)
-        .onLine(10);
-  }
-
-  @Test
-  public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
-    JavaFileObject moduleFile =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "final class TestModule {",
-            "  @Provides String s() { return \"\"; }",
-            "}");
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.ParentComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface ParentComponent {",
-            "  ChildComponent.Builder childComponentBuilder();",
-            "}");
-    JavaFileObject childComponentFile =
-        JavaFileObjects.forSourceLines(
-            "test.ChildComponent",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = TestModule.class)",
-            "abstract class ChildComponent {",
-            "  abstract String s();",
-            "",
-            "  interface Parent<T> {",
-            "    void set1(T t);",
-            "  }",
-            "",
-            "  @Subcomponent.Builder",
-            "  interface Builder extends Parent<TestModule> {",
-            "    ChildComponent build();",
-            "    void set2(TestModule s);",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(
-                MSGS.manyMethodsForType(), "test.TestModule", "[set1(T), set2(test.TestModule)]"))
-        .in(childComponentFile)
-        .onLine(14);
-  }
-
-  @Test
-  public void testMultipleSettersPerBoundInstanceTypeFails() {
-    JavaFileObject componentFile =
-        JavaFileObjects.forSourceLines(
-            "test.ParentComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface ParentComponent {",
-            "  ChildComponent.Builder childComponentBuilder();",
-            "}");
-    JavaFileObject childComponentFile =
-        JavaFileObjects.forSourceLines(
-            "test.ChildComponent",
-            "package test;",
-            "",
-            "import dagger.BindsInstance;",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface ChildComponent {",
-            "  String s();",
-            "",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    ChildComponent build();",
-            "    @BindsInstance void set1(String s);",
-            "    @BindsInstance void set2(String s);",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            Joiner.on("\n      ")
-                .join(
-                    "java.lang.String is bound multiple times:",
-                    "@BindsInstance void test.ChildComponent.Builder.set1(String)",
-                    "@BindsInstance void test.ChildComponent.Builder.set2(String)"))
-        .in(childComponentFile)
-        .onLine(8);
-  }
-
-  @Test
-  public void testExtraSettersFails() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface ParentComponent {",
-        "  ChildComponent.Builder build();",
-        "}");
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "interface ChildComponent {",
-        "  @Subcomponent.Builder",
-        "  interface Builder {",
-        "    ChildComponent build();",
-        "    void set1(String s);",
-        "    void set2(Integer s);",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            String.format(MSGS.extraSetters(),
-                  "[void test.ChildComponent.Builder.set1(String),"
-                  + " void test.ChildComponent.Builder.set2(Integer)]"))
-            .in(childComponentFile).onLine(8);
-  }
-
-  @Test
-  public void testMissingSettersFail() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  TestModule(String unused) {}",
-        "  @Provides String s() { return null; }",
-        "}");
-    JavaFileObject module2File = JavaFileObjects.forSourceLines("test.Test2Module",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class Test2Module {",
-        "  @Provides Integer i() { return null; }",
-        "}");
-    JavaFileObject module3File = JavaFileObjects.forSourceLines("test.Test3Module",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class Test3Module {",
-        "  Test3Module(String unused) {}",
-        "  @Provides Double d() { return null; }",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Provider;",
-        "",
-        "@Component",
-        "interface ParentComponent {",
-        "  ChildComponent.Builder build();",
-        "}");
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent(modules = {TestModule.class, Test2Module.class, Test3Module.class})",
-        "interface ChildComponent {",
-        "  String string();",
-        "  Integer integer();",
-        "",
-        "  @Subcomponent.Builder",
-        "  interface Builder {",
-        "    ChildComponent create();",
-        "  }",
-        "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile,
-            module2File,
-            module3File,
-            componentFile,
-            childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            // Ignores Test2Module because we can construct it ourselves.
-            // TODO(sameb): Ignore Test3Module because it's not used within transitive dependencies.
-            String.format(MSGS.missingSetters(), "[test.TestModule, test.Test3Module]"))
-            .in(childComponentFile).onLine(11);
-  }
-}
diff --git a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java b/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
deleted file mode 100644
index fb3a38873..000000000
--- a/compiler/src/test/java/dagger/internal/codegen/SubcomponentValidationTest.java
+++ /dev/null
@@ -1,1034 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.internal.codegen;
-
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubject.assertThat;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-
-import com.google.common.collect.ImmutableList;
-import com.google.testing.compile.JavaFileObjects;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public final class SubcomponentValidationTest {
-  @Test public void factoryMethod_missingModulesWithParameters() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "interface TestComponent {",
-        "  ChildComponent newChildComponent();",
-        "}");
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent(modules = ModuleWithParameters.class)",
-        "interface ChildComponent {",
-        "  Object object();",
-        "}");
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ModuleWithParameters",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class ModuleWithParameters {",
-        "  private final Object object;",
-        "",
-        "  ModuleWithParameters(Object object) {",
-        "    this.object = object;",
-        "  }",
-        "",
-        "  @Provides Object object() {",
-        "    return object;",
-        "  }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile, moduleFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            "test.ChildComponent requires modules which have no visible default constructors. "
-                + "Add the following modules as parameters to this method: "
-                + "test.ModuleWithParameters")
-        .in(componentFile).onLine(7);
-  }
-
-  @Test public void factoryMethod_nonModuleParameter() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "interface TestComponent {",
-        "  ChildComponent newChildComponent(String someRandomString);",
-        "}");
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "interface ChildComponent {}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            "Subcomponent factory methods may only accept modules, but java.lang.String is not.")
-        .in(componentFile).onLine(7).atColumn(43);
-  }
-
-  @Test public void factoryMethod_duplicateParameter() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "",
-        "@Module",
-        "final class TestModule {}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "interface TestComponent {",
-        "  ChildComponent newChildComponent(TestModule testModule1, TestModule testModule2);",
-        "}");
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent(modules = TestModule.class)",
-        "interface ChildComponent {}");
-    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            "A module may only occur once an an argument in a Subcomponent factory method, "
-                + "but test.TestModule was already passed.")
-        .in(componentFile).onLine(7).atColumn(71);
-  }
-
-  @Test public void factoryMethod_superflouousModule() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "",
-        "@Module",
-        "final class TestModule {}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "interface TestComponent {",
-        "  ChildComponent newChildComponent(TestModule testModule);",
-        "}");
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "interface ChildComponent {}");
-    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
-    .processedWith(new ComponentProcessor())
-    .failsToCompile()
-    .withErrorContaining(
-        "test.TestModule is present as an argument to the test.ChildComponent factory method, but "
-            + "is not one of the modules used to implement the subcomponent.")
-                .in(componentFile).onLine(7);
-  }
-
-  @Test public void missingBinding() {
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "",
-        "@Module",
-        "final class TestModule {",
-        "  @Provides String provideString(int i) {",
-        "    return Integer.toString(i);",
-        "  }",
-        "}");
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "",
-        "@Component",
-        "interface TestComponent {",
-        "  ChildComponent newChildComponent();",
-        "}");
-    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent(modules = TestModule.class)",
-        "interface ChildComponent {",
-        "  String getString();",
-        "}");
-    assertAbout(javaSources())
-        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining(
-            "[test.ChildComponent.getString()] "
-                + "java.lang.Integer cannot be provided without an @Inject constructor or from an "
-                + "@Provides-annotated method")
-        .in(componentFile)
-        .onLine(6);
-  }
-
-  @Test public void subcomponentOnConcreteType() {
-    JavaFileObject subcomponentFile = JavaFileObjects.forSourceLines("test.NotASubcomponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent",
-        "final class NotASubcomponent {}");
-    assertAbout(javaSources()).that(ImmutableList.of(subcomponentFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("interface");
-  }
-
-  @Test public void scopeMismatch() {
-    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
-        "package test;",
-        "",
-        "import dagger.Component;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Component",
-        "@Singleton",
-        "interface ParentComponent {",
-        "  ChildComponent childComponent();",
-        "}");
-    JavaFileObject subcomponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
-        "package test;",
-        "",
-        "import dagger.Subcomponent;",
-        "",
-        "@Subcomponent(modules = ChildModule.class)",
-        "interface ChildComponent {",
-        "  Object getObject();",
-        "}");
-    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ChildModule",
-        "package test;",
-        "",
-        "import dagger.Module;",
-        "import dagger.Provides;",
-        "import javax.inject.Singleton;",
-        "",
-        "@Module",
-        "final class ChildModule {",
-        "  @Provides @Singleton Object provideObject() { return null; }",
-        "}");
-    assertAbout(javaSources()).that(ImmutableList.of(componentFile, subcomponentFile, moduleFile))
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("@Singleton");
-  }
-
-  @Test
-  public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent() {
-    JavaFileObject parentComponentFile =
-        JavaFileObjects.forSourceLines(
-            "test.ParentComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface ParentComponent {",
-            "  ChildComponent childComponent();",
-            "  Dep1 getDep1();",
-            "  Dep2 getDep2();",
-            "}");
-    JavaFileObject childComponentFile =
-        JavaFileObjects.forSourceLines(
-            "test.ChildComponent",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent(modules = ChildModule.class)",
-            "interface ChildComponent {",
-            "  Object getObject();",
-            "}");
-    JavaFileObject childModuleFile =
-        JavaFileObjects.forSourceLines(
-            "test.ChildModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module",
-            "final class ChildModule {",
-            "  @Provides Object provideObject(A a) { return null; }",
-            "}");
-    JavaFileObject aFile =
-        JavaFileObjects.forSourceLines(
-            "test.A",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "final class A {",
-            "  @Inject public A(NeedsDep1 a, Dep1 b, Dep2 c) { }",
-            "  @Inject public void methodA() { }",
-            "}");
-    JavaFileObject needsDep1File =
-        JavaFileObjects.forSourceLines(
-            "test.NeedsDep1",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "final class NeedsDep1 {",
-            "  @Inject public NeedsDep1(Dep1 d) { }",
-            "}");
-    JavaFileObject dep1File =
-        JavaFileObjects.forSourceLines(
-            "test.Dep1",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "final class Dep1 {",
-            "  @Inject public Dep1() { }",
-            "  @Inject public void dep1Method() { }",
-            "}");
-    JavaFileObject dep2File =
-        JavaFileObjects.forSourceLines(
-            "test.Dep2",
-            "package test;",
-            "",
-            "import javax.inject.Inject;",
-            "",
-            "final class Dep2 {",
-            "  @Inject public Dep2() { }",
-            "  @Inject public void dep2Method() { }",
-            "}");
-
-    JavaFileObject componentGeneratedFile =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerParentComponent",
-            "package test;",
-            "",
-            "import dagger.MembersInjector;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerParentComponent implements ParentComponent {",
-            "  private MembersInjector<Dep1> dep1MembersInjector;",
-            "  private Provider<Dep1> dep1Provider;",
-            "  private MembersInjector<Dep2> dep2MembersInjector;",
-            "  private Provider<Dep2> dep2Provider;",
-            "",
-            "  private DaggerParentComponent(Builder builder) {  ",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {  ",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static ParentComponent create() {  ",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {  ",
-            "    this.dep1MembersInjector = Dep1_MembersInjector.create();",
-            "    this.dep1Provider = Dep1_Factory.create(dep1MembersInjector);",
-            "    this.dep2MembersInjector = Dep2_MembersInjector.create();",
-            "    this.dep2Provider = Dep2_Factory.create(dep2MembersInjector);",
-            "  }",
-            "",
-            "  @Override",
-            "  public Dep1 getDep1() {  ",
-            "    return dep1Provider.get();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Dep2 getDep2() {  ",
-            "    return dep2Provider.get();",
-            "  }",
-            "",
-            "  @Override",
-            "  public ChildComponent childComponent() {  ",
-            "    return new ChildComponentImpl();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {  ",
-            "    }",
-            "  ",
-            "    public ParentComponent build() {  ",
-            "      return new DaggerParentComponent(this);",
-            "    }",
-            "  }",
-            "",
-            "  private final class ChildComponentImpl implements ChildComponent {",
-            "    private final ChildModule childModule;",
-            "    private MembersInjector<A> aMembersInjector;",
-            "    private Provider<NeedsDep1> needsDep1Provider;",
-            "    private Provider<A> aProvider;",
-            "    private Provider<Object> provideObjectProvider;",
-            "  ",
-            "    private ChildComponentImpl() {  ",
-            "      this.childModule = new ChildModule();",
-            "      initialize();",
-            "    }",
-            "",
-            "    @SuppressWarnings(\"unchecked\")",
-            "    private void initialize() {  ",
-            "      this.aMembersInjector = A_MembersInjector.create();",
-            "      this.needsDep1Provider = NeedsDep1_Factory.create(",
-            "          DaggerParentComponent.this.dep1Provider);",
-            "      this.aProvider = A_Factory.create(",
-            "          aMembersInjector,",
-            "          needsDep1Provider,",
-            "          DaggerParentComponent.this.dep1Provider,",
-            "          DaggerParentComponent.this.dep2Provider);",
-            "      this.provideObjectProvider = ChildModule_ProvideObjectFactory.create(",
-            "          childModule, aProvider);",
-            "    }",
-            "  ",
-            "    @Override",
-            "    public Object getObject() {  ",
-            "      return provideObjectProvider.get();",
-            "    }",
-            "  }",
-            "}");
-    assertAbout(javaSources())
-        .that(
-            ImmutableList.of(
-                parentComponentFile,
-                childComponentFile,
-                childModuleFile,
-                aFile,
-                needsDep1File,
-                dep1File,
-                dep2File))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(componentGeneratedFile);
-  }
-
-  @Test
-  public void multipleSubcomponentsWithSameSimpleNamesCanExistInSameComponent() {
-    JavaFileObject parent =
-        JavaFileObjects.forSourceLines(
-            "test.ParentComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface ParentComponent {",
-            "  Foo.Sub newFooSubcomponent();",
-            "  NoConflict newNoConflictSubcomponent();",
-            "}");
-    JavaFileObject foo =
-        JavaFileObjects.forSourceLines(
-            "test.Foo",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "interface Foo {",
-            "  @Subcomponent interface Sub {",
-            "    Bar.Sub newBarSubcomponent();",
-            "  }",
-            "}");
-    JavaFileObject bar =
-        JavaFileObjects.forSourceLines(
-            "test.Bar",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "interface Bar {",
-            "  @Subcomponent interface Sub {",
-            "    test.subpackage.Sub newSubcomponentInSubpackage();",
-            "  }",
-            "}");
-    JavaFileObject baz =
-        JavaFileObjects.forSourceLines(
-            "test.subpackage.Sub",
-            "package test.subpackage;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent public interface Sub {}");
-    JavaFileObject noConflict =
-        JavaFileObjects.forSourceLines(
-            "test.NoConflict",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent interface NoConflict {}");
-
-    JavaFileObject componentGeneratedFile =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerParentComponent",
-            "package test;",
-            "",
-            "import javax.annotation.Generated;",
-            "import test.subpackage.Sub;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerParentComponent implements ParentComponent {",
-            "  private DaggerParentComponent(Builder builder) {",
-            "    assert builder != null;",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static ParentComponent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Foo.Sub newFooSubcomponent() {",
-            "    return new Foo_SubImpl();",
-            "  }",
-            "",
-            "  @Override",
-            "  public NoConflict newNoConflictSubcomponent() {",
-            "    return new NoConflictImpl();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public ParentComponent build() {",
-            "      return new DaggerParentComponent(this);",
-            "    }",
-            "  }",
-            "",
-            "  private final class Foo_SubImpl implements Foo.Sub {",
-            "",
-            "    private Foo_SubImpl() {}",
-            "",
-            "    @Override",
-            "    public Bar.Sub newBarSubcomponent() {",
-            "      return new Bar_SubImpl();",
-            "    }",
-            "",
-            "    private final class Bar_SubImpl implements Bar.Sub {",
-            "",
-            "      private Bar_SubImpl() {}",
-            "",
-            "      @Override",
-            "      public Sub newSubcomponentInSubpackage() {",
-            "        return new subpackage_SubImpl();",
-            "      }",
-            "",
-            "      private final class subpackage_SubImpl implements Sub {",
-            "        private subpackage_SubImpl() {}",
-            "      }",
-            "    }",
-            "  }",
-            "  private final class NoConflictImpl implements NoConflict {",
-            "    private NoConflictImpl() {}",
-            "  }",
-            "}");
-
-    assertAbout(javaSources())
-        .that(ImmutableList.of(parent, foo, bar, baz, noConflict))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(componentGeneratedFile);
-  }
-
-  @Test
-  public void subcomponentSimpleNamesDisambiguated() {
-    JavaFileObject parent =
-        JavaFileObjects.forSourceLines(
-            "test.ParentComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface ParentComponent {",
-            "  Sub newSubcomponent();",
-            "}");
-    JavaFileObject sub =
-        JavaFileObjects.forSourceLines(
-            "test.Sub",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent interface Sub {",
-            "  test.deep.many.levels.that.match.test.Sub newDeepSubcomponent();",
-            "}");
-    JavaFileObject deepSub =
-        JavaFileObjects.forSourceLines(
-            "test.deep.many.levels.that.match.test.Sub",
-            "package test.deep.many.levels.that.match.test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent public interface Sub {}");
-
-    JavaFileObject componentGeneratedFile =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerParentComponent",
-            "package test;",
-            "",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerParentComponent implements ParentComponent {",
-            "  private DaggerParentComponent(Builder builder) {",
-            "    assert builder != null;",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static ParentComponent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Sub newSubcomponent() {",
-            "    return new test_SubImpl();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public ParentComponent build() {",
-            "      return new DaggerParentComponent(this);",
-            "    }",
-            "  }",
-            "",
-            "  private final class test_SubImpl implements Sub {",
-            "",
-            "    private test_SubImpl() {}",
-            "",
-            "    @Override",
-            "    public test.deep.many.levels.that.match.test.Sub newDeepSubcomponent() {",
-            "      return new match_test_SubImpl();",
-            "    }",
-            "",
-            "    private final class match_test_SubImpl implements ",
-            "        test.deep.many.levels.that.match.test.Sub {",
-            "      private match_test_SubImpl() {}",
-            "    }",
-            "  }",
-            "}");
-
-    assertAbout(javaSources())
-        .that(ImmutableList.of(parent, sub, deepSub))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(componentGeneratedFile);
-  }
-
-  @Test
-  public void subcomponentImplNameUsesFullyQualifiedClassNameIfNecessary() {
-    JavaFileObject parent =
-        JavaFileObjects.forSourceLines(
-            "test.ParentComponent",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface ParentComponent {",
-            "  top1.a.b.c.d.E.F.Sub top1();",
-            "  top2.a.b.c.d.E.F.Sub top2();",
-            "}");
-    JavaFileObject top1 =
-        JavaFileObjects.forSourceLines(
-            "top1.a.b.c.d.E",
-            "package top1.a.b.c.d;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "public interface E {",
-            "  interface F {",
-            "    @Subcomponent interface Sub {}",
-            "  }",
-            "}");
-    JavaFileObject top2 =
-        JavaFileObjects.forSourceLines(
-            "top2.a.b.c.d.E",
-            "package top2.a.b.c.d;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "public interface E {",
-            "  interface F {",
-            "    @Subcomponent interface Sub {}",
-            "  }",
-            "}");
-
-    JavaFileObject componentGeneratedFile =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerParentComponent",
-            "package test;",
-            "",
-            "import javax.annotation.Generated;",
-            "import top1.a.b.c.d.E;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerParentComponent implements ParentComponent {",
-            "  private DaggerParentComponent(Builder builder) {",
-            "    assert builder != null;",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static ParentComponent create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public E.F.Sub top1() {",
-            "    return new top1_a_b_c_d_E_F_SubImpl();",
-            "  }",
-            "",
-            "  @Override",
-            "  public top2.a.b.c.d.E.F.Sub top2() {",
-            "    return new top2_a_b_c_d_E_F_SubImpl();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public ParentComponent build() {",
-            "      return new DaggerParentComponent(this);",
-            "    }",
-            "  }",
-            "",
-            "  private final class top1_a_b_c_d_E_F_SubImpl implements E.F.Sub {",
-            "    private top1_a_b_c_d_E_F_SubImpl() {}",
-            "  }",
-            "  private final class top2_a_b_c_d_E_F_SubImpl implements top2.a.b.c.d.E.F.Sub {",
-            "    private top2_a_b_c_d_E_F_SubImpl() {}",
-            "  }",
-            "}");
-
-    assertAbout(javaSources())
-        .that(ImmutableList.of(parent, top1, top2))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(componentGeneratedFile);
-  }
-
-  @Test
-  public void parentComponentNameShouldNotBeDisambiguatedWhenItConflictsWithASubcomponent() {
-    JavaFileObject parent =
-        JavaFileObjects.forSourceLines(
-            "test.C",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component",
-            "interface C {",
-            "  test.Foo.C newFooC();",
-            "}");
-    JavaFileObject subcomponentWithSameSimpleNameAsParent =
-        JavaFileObjects.forSourceLines(
-            "test.Foo",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "interface Foo {",
-            "  @Subcomponent interface C {}",
-            "}");
-
-    JavaFileObject componentGeneratedFile =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerC",
-            "package test;",
-            "",
-            "import javax.annotation.Generated;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerC implements C {",
-            "  private DaggerC(Builder builder) {",
-            "    assert builder != null;",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static C create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @Override",
-            "  public Foo.C newFooC() {",
-            "    return new Foo_CImpl();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public C build() {",
-            "      return new DaggerC(this);",
-            "    }",
-            "  }",
-            "",
-            "  private final class Foo_CImpl implements Foo.C {",
-            "    private Foo_CImpl() {}",
-            "  }",
-            "}");
-
-    assertAbout(javaSources())
-        .that(ImmutableList.of(parent, subcomponentWithSameSimpleNameAsParent))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(componentGeneratedFile);
-  }
-
-  @Test
-  public void subcomponentBuilderNamesShouldNotConflict() {
-    JavaFileObject parent =
-        JavaFileObjects.forSourceLines(
-            "test.C",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "import dagger.Subcomponent;",
-            "",
-            "@Component",
-            "interface C {",
-            "  Foo.Sub.Builder fooBuilder();",
-            "  Bar.Sub.Builder barBuilder();",
-            "",
-            "  interface Foo {",
-            "    @Subcomponent",
-            "    interface Sub {",
-            "      @Subcomponent.Builder",
-            "      interface Builder {",
-            "        Sub build();",
-            "      }",
-            "    }",
-            "  }",
-            "",
-            "  interface Bar {",
-            "    @Subcomponent",
-            "    interface Sub {",
-            "      @Subcomponent.Builder",
-            "      interface Builder {",
-            "        Sub build();",
-            "      }",
-            "    }",
-            "  }",
-            "}");
-    JavaFileObject componentGeneratedFile =
-        JavaFileObjects.forSourceLines(
-            "test.DaggerC",
-            "package test;",
-            "",
-            "import dagger.internal.Factory;",
-            "import javax.annotation.Generated;",
-            "import javax.inject.Provider;",
-            "",
-            GENERATED_ANNOTATION,
-            "public final class DaggerC implements C {",
-            "",
-            "  private Provider<C.Foo.Sub.Builder> fooBuilderProvider;",
-            "  private Provider<C.Bar.Sub.Builder> barBuilderProvider;",
-            "",
-            "  private DaggerC(Builder builder) {",
-            "    assert builder != null;",
-            "    initialize(builder);",
-            "  }",
-            "",
-            "  public static Builder builder() {",
-            "    return new Builder();",
-            "  }",
-            "",
-            "  public static C create() {",
-            "    return builder().build();",
-            "  }",
-            "",
-            "  @SuppressWarnings(\"unchecked\")",
-            "  private void initialize(final Builder builder) {",
-            "    this.fooBuilderProvider = ",
-            "        new Factory<C.Foo.Sub.Builder>() {",
-            "          @Override",
-            "          public C.Foo.Sub.Builder get() {",
-            "            return new Foo_SubBuilder();",
-            "          }",
-            "        };",
-            "",
-            "    this.barBuilderProvider = ",
-            "        new Factory<C.Bar.Sub.Builder>() {",
-            "          @Override",
-            "          public C.Bar.Sub.Builder get() {",
-            "            return new Bar_SubBuilder();",
-            "          }",
-            "        };",
-            "  }",
-            "",
-            "  @Override",
-            "  public C.Foo.Sub.Builder fooBuilder() {",
-            "    return fooBuilderProvider.get();",
-            "  }",
-            "",
-            "  @Override",
-            "  public C.Bar.Sub.Builder barBuilder() {",
-            "    return barBuilderProvider.get();",
-            "  }",
-            "",
-            "  public static final class Builder {",
-            "    private Builder() {}",
-            "",
-            "    public C build() {",
-            "      return new DaggerC(this);",
-            "    }",
-            "  }",
-            "",
-            "  private final class Foo_SubBuilder implements C.Foo.Sub.Builder {",
-            "    @Override",
-            "    public C.Foo.Sub build() {",
-            "      return new Foo_SubImpl(this);",
-            "    }",
-            "  }",
-            "",
-            "  private final class Foo_SubImpl implements C.Foo.Sub {",
-            "    private Foo_SubImpl(Foo_SubBuilder builder) {",
-            "      assert builder != null;",
-            "    }",
-            "  }",
-            "",
-            "  private final class Bar_SubBuilder implements C.Bar.Sub.Builder {",
-            "    @Override",
-            "    public C.Bar.Sub build() {",
-            "      return new Bar_SubImpl(this);",
-            "    }",
-            "  }",
-            "",
-            "  private final class Bar_SubImpl implements C.Bar.Sub {",
-            "    private Bar_SubImpl(Bar_SubBuilder builder) {",
-            "      assert builder != null;",
-            "    }",
-            "  }",
-            "}");
-
-    assertAbout(javaSources())
-        .that(ImmutableList.of(parent))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(componentGeneratedFile);
-  }
-
-  @Test
-  public void duplicateBindingWithSubcomponentDeclaration() {
-    JavaFileObject module =
-        JavaFileObjects.forSourceLines(
-            "test.TestModule",
-            "package test;",
-            "",
-            "import dagger.Module;",
-            "import dagger.Provides;",
-            "",
-            "@Module(subcomponents = Sub.class)",
-            "class TestModule {",
-            "  @Provides Sub.Builder providesConflictsWithModuleSubcomponents() { return null; }",
-            "  @Provides Object usesSubcomponentBuilder(Sub.Builder builder) {",
-            "    return builder.toString();",
-            "  }",
-            "}");
-
-    JavaFileObject subcomponent =
-        JavaFileObjects.forSourceLines(
-            "test.Sub",
-            "package test;",
-            "",
-            "import dagger.Subcomponent;",
-            "",
-            "@Subcomponent",
-            "interface Sub {",
-            "  @Subcomponent.Builder",
-            "  interface Builder {",
-            "    Sub build();",
-            "  }",
-            "}");
-
-    JavaFileObject component =
-        JavaFileObjects.forSourceLines(
-            "test.Sub",
-            "package test;",
-            "",
-            "import dagger.Component;",
-            "",
-            "@Component(modules = TestModule.class)",
-            "interface C {",
-            "  Object dependsOnBuilder();",
-            "}");
-
-    assertThat(module, component, subcomponent)
-        .processedWith(new ComponentProcessor())
-        .failsToCompile()
-        .withErrorContaining("test.Sub.Builder is bound multiple times:")
-        .and()
-        .withErrorContaining(
-            "@Provides test.Sub.Builder test.TestModule.providesConflictsWithModuleSubcomponents()")
-        .and()
-        .withErrorContaining("@Module(subcomponents = test.Sub.class) for test.TestModule");
-  }
-}
diff --git a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java b/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
deleted file mode 100644
index da1eca604..000000000
--- a/compiler/src/test/java/dagger/tests/integration/operation/PrimitiveInjectionTest.java
+++ /dev/null
@@ -1,139 +0,0 @@
-/**
- * Copyright (C) 2013 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.tests.integration.operation;
-
-import static com.google.common.truth.Truth.assertAbout;
-import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
-import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
-import static java.util.Arrays.asList;
-
-import com.google.testing.compile.JavaFileObjects;
-import dagger.internal.codegen.ComponentProcessor;
-import javax.tools.JavaFileObject;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-
-@RunWith(JUnit4.class)
-public final class PrimitiveInjectionTest {
-
-  // TODO(cgruber): Use @test.ForTest to qualify primitives once qualifier equivalence is working.
-  /*
-  JavaFileObject annotation = JavaFileObjects.forSourceLines("test.ForTest",
-      "package test;",
-      "import javax.inject.Qualifier;",
-      "@Qualifier",
-      "public @interface ForTest {",
-      "}");
-  */
-
-  // TODO(cgruber): Expand test to support more primitive types when b/15512877 is fixed.
-  JavaFileObject primitiveInjectable = JavaFileObjects.forSourceLines("test.PrimitiveInjectable",
-      "package test;",
-      "import javax.inject.Inject;",
-      "class PrimitiveInjectable {",
-      "  @Inject PrimitiveInjectable(int ignored) {}",
-      "}");
-
-  JavaFileObject primitiveModule =
-      JavaFileObjects.forSourceLines(
-          "test.PrimitiveModule",
-          "package test;",
-          "import dagger.Module;",
-          "import dagger.Provides;",
-          "@Module",
-          "class PrimitiveModule {",
-          "  @Provides static int primitiveInt() { return Integer.MAX_VALUE; }",
-          "}");
-
-  JavaFileObject component = JavaFileObjects.forSourceLines("test.PrimitiveComponent",
-      "package test;",
-      "import dagger.Component;",
-      "import dagger.Provides;",
-      "@Component(modules = PrimitiveModule.class)",
-      "interface PrimitiveComponent {",
-      "  int primitiveInt();",
-      "  PrimitiveInjectable primitiveInjectable();",
-      "}");
-
-  JavaFileObject expectedComponent =
-      JavaFileObjects.forSourceLines(
-          "test.DaggerPrimitiveComponent",
-          "package test;",
-          "",
-          "import dagger.internal.Preconditions;",
-          "import javax.annotation.Generated;",
-          "import javax.inject.Provider;",
-          "",
-          GENERATED_ANNOTATION,
-          "public final class DaggerPrimitiveComponent implements PrimitiveComponent {",
-          "  private Provider<PrimitiveInjectable> primitiveInjectableProvider;",
-          "",
-          "  private DaggerPrimitiveComponent(Builder builder) {",
-          "    assert builder != null;",
-          "    initialize(builder);",
-          "  }",
-          "",
-          "  public static Builder builder() {",
-          "    return new Builder();",
-          "  }",
-          "",
-          "  public static PrimitiveComponent create() {",
-          "    return builder().build();",
-          "  }",
-          "",
-          "  @SuppressWarnings(\"unchecked\")",
-          "  private void initialize(final Builder builder) {",
-          "    this.primitiveInjectableProvider = PrimitiveInjectable_Factory.create(",
-          "        PrimitiveModule_PrimitiveIntFactory.create());",
-          "  }",
-          "",
-          "  @Override",
-          "  public int primitiveInt() {",
-          "    return PrimitiveModule.primitiveInt();",
-          "  }",
-          "",
-          "  @Override",
-          "  public PrimitiveInjectable primitiveInjectable() {",
-          "    return new PrimitiveInjectable(PrimitiveModule.primitiveInt());",
-          "  }",
-          "",
-          "  public static final class Builder {",
-          "",
-          "    private Builder() {}",
-          "",
-          "    public PrimitiveComponent build() {",
-          "      return new DaggerPrimitiveComponent(this);",
-          "    }",
-          "",
-          "    @Deprecated",
-          "    public Builder primitiveModule(PrimitiveModule primitiveModule) {",
-          "      Preconditions.checkNotNull(primitiveModule);",
-          "      return this;",
-          "    }",
-          "  }",
-          "}");
-
-  @Test public void primitiveArrayTypesAllInjected() {
-    assertAbout(javaSources())
-        .that(asList(component, primitiveInjectable, primitiveModule))
-        .processedWith(new ComponentProcessor())
-        .compilesWithoutError()
-        .and()
-        .generatesSources(expectedComponent);
-  }
-}
diff --git a/core/BUILD b/core/BUILD
deleted file mode 100644
index bd2407ecd..000000000
--- a/core/BUILD
+++ /dev/null
@@ -1,44 +0,0 @@
-# Copyright (C) 2017 The Dagger Authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-# Description:
-#   A JSR-330 compliant dependency injection system for android and java
-
-package(default_visibility = ["//:src"])
-
-load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX", "DOCLINT_REFERENCES")
-load("//:test_defs.bzl", "GenJavaTests")
-
-java_library(
-    name = "core",
-    plugins = [
-        # TODO(cgruber): Enable Beta checker.
-    ],
-    exports = ["//core/src/main/java/dagger:core"],
-)
-
-GenJavaTests(
-    name = "core_tests",
-    srcs = glob(["src/test/java/**/*.java"]),
-    javacopts = DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
-    deps = [
-        ":core",
-        "//third_party:guava",
-        "//third_party:jsr330_inject",
-        "//third_party:junit",
-        "//third_party:truth",
-    ],
-)
-
-test_suite(name = "AllTests")
diff --git a/core/src/main/java/dagger/ActivityComponent.java b/core/src/main/java/dagger/ActivityComponent.java
new file mode 100644
index 000000000..fabba2310
--- /dev/null
+++ b/core/src/main/java/dagger/ActivityComponent.java
@@ -0,0 +1,3 @@
+package dagger;
+
+public interface ActivityComponent<A> extends BaseComponent<A> {}
diff --git a/core/src/main/java/dagger/ActivityComponentBuilder.java b/core/src/main/java/dagger/ActivityComponentBuilder.java
new file mode 100644
index 000000000..c7db4f597
--- /dev/null
+++ b/core/src/main/java/dagger/ActivityComponentBuilder.java
@@ -0,0 +1,3 @@
+package dagger;
+
+public interface ActivityComponentBuilder<C extends ActivityComponent> extends BaseComponentBuilder<C> {}
diff --git a/core/src/main/java/dagger/BUILD b/core/src/main/java/dagger/BUILD
deleted file mode 100644
index bf28e6584..000000000
--- a/core/src/main/java/dagger/BUILD
+++ /dev/null
@@ -1,33 +0,0 @@
-# Copyright (C) 2017 The Dagger Authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-# Description:
-#   A JSR-330 compliant dependency injection system for android and java
-
-package(default_visibility = ["//:src"])
-
-load(
-    "//:build_defs.bzl",
-    "DOCLINT_HTML_AND_SYNTAX",
-    "JAVA_6_SOURCE_LEVEL",
-    "PRE_JAVA_8_INFERENCE_OPTS",
-)
-
-java_library(
-    name = "core",
-    srcs = glob(["**/*.java"]),
-    javacopts = PRE_JAVA_8_INFERENCE_OPTS + JAVA_6_SOURCE_LEVEL + DOCLINT_HTML_AND_SYNTAX,
-    exports = ["//third_party:jsr330_inject"],
-    deps = ["//third_party:jsr330_inject"],
-)
diff --git a/core/src/main/java/dagger/BaseComponent.java b/core/src/main/java/dagger/BaseComponent.java
new file mode 100644
index 000000000..17fd34e7e
--- /dev/null
+++ b/core/src/main/java/dagger/BaseComponent.java
@@ -0,0 +1,5 @@
+package dagger;
+
+import dagger.MembersInjector;
+
+public interface BaseComponent<A> extends MembersInjector<A> {}
diff --git a/core/src/main/java/dagger/BaseComponentBuilder.java b/core/src/main/java/dagger/BaseComponentBuilder.java
new file mode 100644
index 000000000..6a64cf1bf
--- /dev/null
+++ b/core/src/main/java/dagger/BaseComponentBuilder.java
@@ -0,0 +1,5 @@
+package dagger;
+
+public interface BaseComponentBuilder<C extends BaseComponent> {
+    C build();
+}
diff --git a/core/src/main/java/dagger/ComponentBuilder.java b/core/src/main/java/dagger/ComponentBuilder.java
new file mode 100644
index 000000000..dbdb8f5de
--- /dev/null
+++ b/core/src/main/java/dagger/ComponentBuilder.java
@@ -0,0 +1,43 @@
+package dagger;
+
+import java.util.Map;
+
+import javax.inject.Provider;
+
+public class ComponentBuilder<P> {
+
+    private final Map<Class<?>, Provider<P>> builders;
+
+    public ComponentBuilder(Map<Class<?>, Provider<P>> builders) {
+        this.builders = builders;
+    }
+
+    public <A, C extends BaseComponent<A>, T extends BaseComponentBuilder<C>> C getComponent(Class<T> clazz,
+                                                                                             A injectable,
+                                                                                             Config<A, C, T> config) {
+        T builder = (T) builders.get(injectable.getClass()).get();
+        C component = config.configure(builder).build();
+        component.injectMembers(injectable);
+        return component;
+    }
+
+    public <A, C extends BaseComponent<A>, T extends BaseComponentBuilder<C>> C getComponent(Class<T> clazz,
+                                                                                             A injectable) {
+        T builder = (T) builders.get(injectable.getClass()).get();
+        C component = builder.build();
+        component.injectMembers(injectable);
+        return component;
+    }
+
+    public <A, C extends BaseComponent<A>, T extends BaseComponentBuilder<C>> C getComponent(A injectable) {
+        T builder = (T) builders.get(injectable.getClass()).get();
+        C component = builder.build();
+        component.injectMembers(injectable);
+        return component;
+    }
+
+    public interface Config<A, C extends BaseComponent<A>, T extends BaseComponentBuilder<C>> {
+        T configure(T builder);
+    }
+
+}
diff --git a/core/src/main/java/dagger/FragmentComponent.java b/core/src/main/java/dagger/FragmentComponent.java
new file mode 100644
index 000000000..b10c8773d
--- /dev/null
+++ b/core/src/main/java/dagger/FragmentComponent.java
@@ -0,0 +1,3 @@
+package dagger;
+
+public interface FragmentComponent<F> extends BaseComponent<F> {}
diff --git a/core/src/main/java/dagger/FragmentComponentBuilder.java b/core/src/main/java/dagger/FragmentComponentBuilder.java
new file mode 100644
index 000000000..b08570dca
--- /dev/null
+++ b/core/src/main/java/dagger/FragmentComponentBuilder.java
@@ -0,0 +1,3 @@
+package dagger;
+
+public interface FragmentComponentBuilder<C extends FragmentComponent> extends BaseComponentBuilder<C>{}
diff --git a/core/src/main/java/dagger/Lazy.java b/core/src/main/java/dagger/Lazy.java
index a5ad92e98..d4408fa78 100644
--- a/core/src/main/java/dagger/Lazy.java
+++ b/core/src/main/java/dagger/Lazy.java
@@ -18,9 +18,11 @@
 
 /**
  * A handle to a lazily-computed value. Each {@code Lazy} computes its value on
- * the first call to {@code get()} and remembers that same value for all
+ * the first call to {@link #get()} and remembers that same value for all
  * subsequent calls to {@code get()}.
  *
+ * <p>All implementations are expected to be thread-safe and compute their value at most once.
+ *
  * <h2>Example</h2>
  * The differences between <strong>direct injection</strong>, <strong>provider
  * injection</strong> and <strong>lazy injection</strong> are best demonstrated
diff --git a/core/src/main/java/dagger/MapKey.java b/core/src/main/java/dagger/MapKey.java
index 7440ea30c..89307be15 100644
--- a/core/src/main/java/dagger/MapKey.java
+++ b/core/src/main/java/dagger/MapKey.java
@@ -19,16 +19,14 @@
 import static java.lang.annotation.ElementType.ANNOTATION_TYPE;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 import java.util.Map;
 
 /**
- * Identifies annotation types that are used to associate keys with values returned by
- * {@linkplain Provides provider methods} in order to compose a {@linkplain
- * dagger.multibindings.IntoMap map}.
+ * Identifies annotation types that are used to associate keys with values returned by {@linkplain
+ * Provides provider methods} in order to compose a {@linkplain dagger.multibindings.IntoMap map}.
  *
  * <p>Every provider method annotated with {@code @Provides} and {@code @IntoMap} must also have an
  * annotation that identifies the key for that map entry. That annotation's type must be annotated
@@ -36,8 +34,8 @@
  *
  * <p>Typically, the key annotation has a single member, whose value is used as the map key.
  *
- * <p>For example, to add an entry to a {@code Map<SomeEnum, Integer>} with key
- * {@code SomeEnum.FOO}, you could use an annotation called {@code @SomeEnumKey}:
+ * <p>For example, to add an entry to a {@code Map<SomeEnum, Integer>} with key {@code
+ * SomeEnum.FOO}, you could use an annotation called {@code @SomeEnumKey}:
  *
  * <pre><code>
  * {@literal @}MapKey
@@ -65,7 +63,7 @@
  *
  * <p>If {@code unwrapValue} is true, the annotation's single member can be any type except an
  * array.
- * 
+ *
  * <p>See {@link dagger.multibindings} for standard unwrapped map key annotations for keys that are
  * boxed primitives, strings, or classes.
  *
@@ -102,13 +100,11 @@
  * <p>(Note that there must be a class {@code MyMapKeyImpl} that implements {@code MyMapKey} in
  * order to call {@link Map#get(Object)} on the provided map.)
  *
- * @see <a href="http://google.github.io/dagger/multibindings#map-multibindings">Map
- *      multibinding</a>
+ * @see <a href="https://google.github.io/dagger/multibindings#map-multibindings">Map multibinding</a>
  */
 @Documented
 @Target(ANNOTATION_TYPE)
 @Retention(RUNTIME)
-@Beta
 public @interface MapKey {
   /**
    * True to use the value of the single member of the annotated annotation as the map key; false
diff --git a/core/src/main/java/dagger/MembersInjector.java b/core/src/main/java/dagger/MembersInjector.java
index 510f476a9..9fb7d26b2 100644
--- a/core/src/main/java/dagger/MembersInjector.java
+++ b/core/src/main/java/dagger/MembersInjector.java
@@ -33,9 +33,9 @@
    * Injects dependencies into the fields and methods of {@code instance}. Ignores the presence or
    * absence of an injectable constructor.
    *
-   * <p>Whenever the object graph creates an instance, it performs this injection automatically
-   * (after first performing constructor injection), so if you're able to let the object graph
-   * create all your objects for you, you'll never need to use this method.
+   * <p>Whenever a {@link Component} creates an instance, it performs this injection automatically
+   * (after first performing constructor injection), so if you're able to let the component create
+   * all your objects for you, you'll never need to use this method.
    *
    * @param instance into which members are to be injected
    * @throws NullPointerException if {@code instance} is {@code null}
diff --git a/core/src/main/java/dagger/Multibindings.java b/core/src/main/java/dagger/Multibindings.java
deleted file mode 100644
index c544e092f..000000000
--- a/core/src/main/java/dagger/Multibindings.java
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger;
-
-import static java.lang.annotation.ElementType.TYPE;
-
-import dagger.internal.Beta;
-import java.lang.annotation.Documented;
-import java.lang.annotation.Target;
-
-/**
- * Annotates interfaces that declare multibindings.
- *
- * <p>You can declare that a multibound set or map is bound by nesting a
- * {@code @Multibindings}-annotated interface within a module, with methods that return the sets or
- * maps you want to declare.
- *
- * <p>You do not have to use {@code @Multibindings} for sets or maps that have at least one
- * contribution, but you do have to declare them if they may be empty.
- *
- * <pre><code>
- * {@literal @Module}
- * class MyModule {
- *   {@literal @Multibindings}
- *   interface MyMultibindings {
- *     {@literal Set<Foo>} aSet();
- *     {@literal @MyQualifier Set<Foo>} aQualifiedSet();
- *     {@literal Map<String, Foo>} aMap();
- *     {@literal @MyQualifier Map<String, Foo>} aQualifiedMap();
- *   }
- *
- *   {@literal @Provides}
- *   static Object usesMultibindings(
- *       {@literal Set<Foo>} set, {@literal @MyQualifier Map<String, Foo>} map) {
- *     return 
- *   }
- * }
- * </code></pre>
- *
- * <p>All methods on the interface and any supertypes (except for methods on {@link Object}) are
- * used to declare multibindings. The names of the interface and its methods are ignored. A given
- * set or map multibinding can be declared any number of times without error. Dagger never
- * implements the interface or calls any of its methods.
- *
- * @see <a href="http://google.github.io/dagger/multibindings">Multibindings</a>
- */
-@Documented
-@Target(TYPE)
-@Beta
-public @interface Multibindings {}
diff --git a/core/src/main/java/dagger/Reusable.java b/core/src/main/java/dagger/Reusable.java
index 34610e5a4..6b2314579 100644
--- a/core/src/main/java/dagger/Reusable.java
+++ b/core/src/main/java/dagger/Reusable.java
@@ -16,9 +16,9 @@
 
 package dagger;
 
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
 import dagger.internal.Beta;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import javax.inject.Scope;
@@ -29,7 +29,7 @@
  * <p>{@code @Reusable} is useful when you want to limit the number of provisions of a type, but
  * there is no specific lifetime over which there must be only one instance.
  *
- * @see <a href="http://google.github.io/dagger/users-guide.html#reusable-scope">Reusable Scope</a>
+ * @see <a href="https://google.github.io/dagger/users-guide.html#reusable-scope">Reusable Scope</a>
  */
 @Documented
 @Beta
diff --git a/core/src/main/java/dagger/di/ActivityComponent.java b/core/src/main/java/dagger/di/ActivityComponent.java
deleted file mode 100644
index 9bd16f62a..000000000
--- a/core/src/main/java/dagger/di/ActivityComponent.java
+++ /dev/null
@@ -1,3 +0,0 @@
-package dagger.di;
-
-public interface ActivityComponent<A> extends BaseComponent<A> {}
diff --git a/core/src/main/java/dagger/di/ActivityComponentBuilder.java b/core/src/main/java/dagger/di/ActivityComponentBuilder.java
deleted file mode 100644
index 6c12c40a1..000000000
--- a/core/src/main/java/dagger/di/ActivityComponentBuilder.java
+++ /dev/null
@@ -1,3 +0,0 @@
-package dagger.di;
-
-public interface ActivityComponentBuilder<C extends ActivityComponent> extends BaseComponentBuilder<C> {}
diff --git a/core/src/main/java/dagger/di/BaseComponent.java b/core/src/main/java/dagger/di/BaseComponent.java
deleted file mode 100644
index 4ba15ad43..000000000
--- a/core/src/main/java/dagger/di/BaseComponent.java
+++ /dev/null
@@ -1,5 +0,0 @@
-package dagger.di;
-
-import dagger.MembersInjector;
-
-public interface BaseComponent<A> extends MembersInjector<A> {}
diff --git a/core/src/main/java/dagger/di/BaseComponentBuilder.java b/core/src/main/java/dagger/di/BaseComponentBuilder.java
deleted file mode 100644
index 88e7bdbf6..000000000
--- a/core/src/main/java/dagger/di/BaseComponentBuilder.java
+++ /dev/null
@@ -1,5 +0,0 @@
-package dagger.di;
-
-public interface BaseComponentBuilder<C extends BaseComponent> {
-    C build();
-}
diff --git a/core/src/main/java/dagger/di/ComponentBuilder.java b/core/src/main/java/dagger/di/ComponentBuilder.java
deleted file mode 100644
index 972ec8306..000000000
--- a/core/src/main/java/dagger/di/ComponentBuilder.java
+++ /dev/null
@@ -1,43 +0,0 @@
-package dagger.di;
-
-import java.util.Map;
-
-import javax.inject.Provider;
-
-public class ComponentBuilder<P> {
-
-    private final Map<Class<?>, Provider<P>> builders;
-
-    public ComponentBuilder(Map<Class<?>, Provider<P>> builders) {
-        this.builders = builders;
-    }
-
-    public <A, C extends BaseComponent<A>, T extends BaseComponentBuilder<C>> C getComponent(Class<T> clazz,
-                                                                                             A injectable,
-                                                                                             Config<A, C, T> config) {
-        T builder = (T) builders.get(injectable.getClass()).get();
-        C component = config.configure(builder).build();
-        component.injectMembers(injectable);
-        return component;
-    }
-
-    public <A, C extends BaseComponent<A>, T extends BaseComponentBuilder<C>> C getComponent(Class<T> clazz,
-                                                                                             A injectable) {
-        T builder = (T) builders.get(injectable.getClass()).get();
-        C component = builder.build();
-        component.injectMembers(injectable);
-        return component;
-    }
-
-    public <A, C extends BaseComponent<A>, T extends BaseComponentBuilder<C>> C getComponent(A injectable) {
-        T builder = (T) builders.get(injectable.getClass()).get();
-        C component = builder.build();
-        component.injectMembers(injectable);
-        return component;
-    }
-
-    public interface Config<A, C extends BaseComponent<A>, T extends BaseComponentBuilder<C>> {
-        T configure(T builder);
-    }
-
-}
diff --git a/core/src/main/java/dagger/di/FragmentComponent.java b/core/src/main/java/dagger/di/FragmentComponent.java
deleted file mode 100644
index aa1def100..000000000
--- a/core/src/main/java/dagger/di/FragmentComponent.java
+++ /dev/null
@@ -1,3 +0,0 @@
-package dagger.di;
-
-public interface FragmentComponent<F> extends BaseComponent<F> {}
diff --git a/core/src/main/java/dagger/di/FragmentComponentBuilder.java b/core/src/main/java/dagger/di/FragmentComponentBuilder.java
deleted file mode 100644
index 46db086ee..000000000
--- a/core/src/main/java/dagger/di/FragmentComponentBuilder.java
+++ /dev/null
@@ -1,3 +0,0 @@
-package dagger.di;
-
-public interface FragmentComponentBuilder<C extends FragmentComponent> extends BaseComponentBuilder<C>{}
diff --git a/core/src/main/java/dagger/internal/DoubleCheck.java b/core/src/main/java/dagger/internal/DoubleCheck.java
index 04630d8b1..e4a074b40 100644
--- a/core/src/main/java/dagger/internal/DoubleCheck.java
+++ b/core/src/main/java/dagger/internal/DoubleCheck.java
@@ -51,7 +51,8 @@ public T get() {
           Object currentInstance = instance;
           if (currentInstance != UNINITIALIZED && currentInstance != result) {
             throw new IllegalStateException("Scoped provider was invoked recursively returning "
-                + "different results: " + currentInstance + " & " + result);
+                + "different results: " + currentInstance + " & " + result + ". This is likely "
+                + "due to a circular dependency.");
           }
           instance = result;
           /* Null out the reference to the provider. We are never going to need it again, so we
diff --git a/core/src/main/java/dagger/internal/Preconditions.java b/core/src/main/java/dagger/internal/Preconditions.java
index 7ac5026cc..99e180530 100644
--- a/core/src/main/java/dagger/internal/Preconditions.java
+++ b/core/src/main/java/dagger/internal/Preconditions.java
@@ -50,6 +50,36 @@
     return reference;
   }
 
+  /**
+   * Ensures that an object reference passed as a parameter to the calling method is not null.
+   *
+   * @param reference an object reference
+   * @param errorMessageTemplate a template for the exception message should the check fail. The
+   *     message is formed by replacing the single {@code %s} placeholder in the template with
+   *     {@code errorMessageArg}.
+   * @param errorMessageArg the argument to be substituted into the message template. Converted to a
+   *     string using {@link String#valueOf(Object)}.
+   * @return the non-null reference that was validated
+   * @throws NullPointerException if {@code reference} is null
+   * @throws IllegalArgumentException if {@code errorMessageTemplate} doesn't contain exactly one
+   *     "%s"
+   */
+  public static <T> T checkNotNull(
+      T reference, String errorMessageTemplate, Object errorMessageArg) {
+    if (reference == null) {
+      // Poor-persons version of String.format, which is not GWT-compatible
+      if (!errorMessageTemplate.contains("%s")) {
+        throw new IllegalArgumentException("errorMessageTemplate has no format specifiers");
+      }
+      if (errorMessageTemplate.indexOf("%s") != errorMessageTemplate.lastIndexOf("%s")) {
+        throw new IllegalArgumentException(
+            "errorMessageTemplate has more than one format specifier");
+      }
+      throw new NullPointerException(
+          errorMessageTemplate.replaceFirst("%s", String.valueOf(errorMessageArg)));
+    }
+    return reference;
+  }
+
   private Preconditions() {}
 }
-
diff --git a/core/src/main/java/dagger/internal/ReferenceReleasingProvider.java b/core/src/main/java/dagger/internal/ReferenceReleasingProvider.java
index 56c9df14c..30a9cb4b5 100644
--- a/core/src/main/java/dagger/internal/ReferenceReleasingProvider.java
+++ b/core/src/main/java/dagger/internal/ReferenceReleasingProvider.java
@@ -28,14 +28,14 @@
  * <p>The provider can be in any one of four states at a time:
  *
  * <ul>
- * <li>In <b>uninitialized</b> state, the provider's strong reference and its weak reference are
- *     both {@code null}.
- * <li>In <b>cleared</b> state, the strong reference is {@code null}, and the weak reference's value
- *     is {@code null}.
- * <li>In <b>strong-reference</b> state, the strong reference refers to the stored object, and the
- *     weak reference is {@code null}.
- * <li>In <b>weak-reference</b> state, the strong reference is {@code null}, and the weak
- *     reference's value is not {@code null}.
+ *   <li>In <b>uninitialized</b> state, the provider's strong reference and its weak reference are
+ *       both {@code null}.
+ *   <li>In <b>cleared</b> state, the strong reference is {@code null}, and the weak reference's
+ *       value is {@code null}.
+ *   <li>In <b>strong-reference</b> state, the strong reference refers to the stored object, and the
+ *       weak reference is {@code null}.
+ *   <li>In <b>weak-reference</b> state, the strong reference is {@code null}, and the weak
+ *       reference's value is not {@code null}.
  * </ul>
  *
  * <p>The provider starts in <b>uninitialized</b> state.
@@ -54,8 +54,7 @@
  *
  * <p><img src="doc-files/ReferenceReleasingProvider-statemachine.png">
  *
- * @see <a href="http://google.github.io/dagger/users-guide.html#releasable-references">Releasable
- *     references</a>
+ * @see <a href="https://google.github.io/dagger/users-guide.html#releasable-references">Releasable references</a>
  */
 @GwtIncompatible
 public final class ReferenceReleasingProvider<T> implements Provider<T> {
diff --git a/core/src/main/java/dagger/internal/ReferenceReleasingProviderManager.java b/core/src/main/java/dagger/internal/ReferenceReleasingProviderManager.java
index 083de46b0..9be7c342a 100644
--- a/core/src/main/java/dagger/internal/ReferenceReleasingProviderManager.java
+++ b/core/src/main/java/dagger/internal/ReferenceReleasingProviderManager.java
@@ -29,8 +29,7 @@
  * A {@link ReleasableReferenceManager} that forwards calls to a dynamic set of weakly-referenced
  * {@link ReferenceReleasingProvider}s.
  *
- * @see <a href="http://google.github.io/dagger/users-guide.html#releasable-references">Releasable
- *     references</a>
+ * @see <a href="https://google.github.io/dagger/users-guide.html#releasable-references">Releasable references</a>
  */
 @GwtIncompatible
 public final class ReferenceReleasingProviderManager implements ReleasableReferenceManager {
diff --git a/core/src/main/java/dagger/multibindings/ClassKey.java b/core/src/main/java/dagger/multibindings/ClassKey.java
index 22a055827..ac255457c 100644
--- a/core/src/main/java/dagger/multibindings/ClassKey.java
+++ b/core/src/main/java/dagger/multibindings/ClassKey.java
@@ -20,7 +20,6 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 import dagger.MapKey;
-import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
@@ -31,7 +30,6 @@
  * <p>If your map's keys can be constrained, consider using a custom annotation instead, with a
  * member whose type is {@code Class<? extends Something>}.
  */
-@Beta
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
diff --git a/core/src/main/java/dagger/multibindings/ElementsIntoSet.java b/core/src/main/java/dagger/multibindings/ElementsIntoSet.java
index 84ae395d3..72cc86d1d 100644
--- a/core/src/main/java/dagger/multibindings/ElementsIntoSet.java
+++ b/core/src/main/java/dagger/multibindings/ElementsIntoSet.java
@@ -28,8 +28,7 @@
  * Set<T>} produced from the accumulation of values will be immutable. An example use is to provide
  * a default empty set binding, which is otherwise not possible using {@link IntoSet}.
  *
- * @see <a href="http://google.github.io/dagger/multibindings#set-multibindings">Set
- *      multibinding</a>
+ * @see <a href="https://google.github.io/dagger/multibindings#set-multibindings">Set multibinding</a>
  */
 @Documented
 @Target(METHOD)
diff --git a/core/src/main/java/dagger/multibindings/IntKey.java b/core/src/main/java/dagger/multibindings/IntKey.java
index 12ebc10d9..55e79a1bf 100644
--- a/core/src/main/java/dagger/multibindings/IntKey.java
+++ b/core/src/main/java/dagger/multibindings/IntKey.java
@@ -20,13 +20,11 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 import dagger.MapKey;
-import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
 /** A {@link MapKey} annotation for maps with {@code int} keys. */
-@Beta
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
diff --git a/core/src/main/java/dagger/multibindings/IntoMap.java b/core/src/main/java/dagger/multibindings/IntoMap.java
index 7a2619c8f..3066b5801 100644
--- a/core/src/main/java/dagger/multibindings/IntoMap.java
+++ b/core/src/main/java/dagger/multibindings/IntoMap.java
@@ -19,22 +19,19 @@
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
 /**
- * The method's return type forms the type argument for the value of a
- * {@code Map<K, Provider<V>>}, and the combination of the annotated key and the returned value
- * is contributed to the map as a key/value pair. The {@code Map<K, Provider<V>>} produced from
- * the accumulation of values will be immutable.
+ * The method's return type forms the type argument for the value of a {@code Map<K, Provider<V>>},
+ * and the combination of the annotated key and the returned value is contributed to the map as a
+ * key/value pair. The {@code Map<K, Provider<V>>} produced from the accumulation of values will be
+ * immutable.
  *
- * @see <a href="http://google.github.io/dagger/multibindings#map-multibindings">Map
- *      multibinding</a>
+ * @see <a href="https://google.github.io/dagger/multibindings#map-multibindings">Map multibinding</a>
  */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
-@Beta
 public @interface IntoMap {}
diff --git a/core/src/main/java/dagger/multibindings/IntoSet.java b/core/src/main/java/dagger/multibindings/IntoSet.java
index 08dc2c82b..f42860f67 100644
--- a/core/src/main/java/dagger/multibindings/IntoSet.java
+++ b/core/src/main/java/dagger/multibindings/IntoSet.java
@@ -24,13 +24,11 @@
 import java.lang.annotation.Target;
 
 /**
- * The method's return type forms the generic type argument of a {@code Set<T>}, and the
- * returned value is contributed to the set. The object graph will pass dependencies to the
- * method as parameters. The {@code Set<T>} produced from the accumulation of values will be
- * immutable.
+ * The method's return type forms the generic type argument of a {@code Set<T>}, and the returned
+ * value is contributed to the set. The object graph will pass dependencies to the method as
+ * parameters. The {@code Set<T>} produced from the accumulation of values will be immutable.
  *
- * @see <a href="http://google.github.io/dagger/multibindings#set-multibindings">Set
- *      multibinding</a>
+ * @see <a href="https://google.github.io/dagger/multibindings#set-multibindings">Set multibinding</a>
  */
 @Documented
 @Target(METHOD)
diff --git a/core/src/main/java/dagger/multibindings/LongKey.java b/core/src/main/java/dagger/multibindings/LongKey.java
index a8d6ab64e..71d0fe116 100644
--- a/core/src/main/java/dagger/multibindings/LongKey.java
+++ b/core/src/main/java/dagger/multibindings/LongKey.java
@@ -20,13 +20,11 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 import dagger.MapKey;
-import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
 /** A {@link MapKey} annotation for maps with {@code long} keys. */
-@Beta
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
diff --git a/core/src/main/java/dagger/multibindings/Multibinds.java b/core/src/main/java/dagger/multibindings/Multibinds.java
index 4ce886c5a..1517b2698 100644
--- a/core/src/main/java/dagger/multibindings/Multibinds.java
+++ b/core/src/main/java/dagger/multibindings/Multibinds.java
@@ -19,7 +19,6 @@
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
-import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
@@ -35,10 +34,10 @@
  *
  * <pre><code>
  *   {@literal @Module} abstract class MyModule {
- *     {@literal @Multibinds Set<Foo> aSet();}
- *     {@literal @Multibinds @MyQualifier Set<Foo> aQualifiedSet();}
- *     {@literal @Multibinds Map<String, Foo> aMap();}
- *     {@literal @Multibinds @MyQualifier Map<String, Foo> aQualifiedMap();}
+ *     {@literal @Multibinds abstract Set<Foo> aSet();}
+ *     {@literal @Multibinds abstract @MyQualifier Set<Foo> aQualifiedSet();}
+ *     {@literal @Multibinds abstract Map<String, Foo> aMap();}
+ *     {@literal @Multibinds abstract @MyQualifier Map<String, Foo> aQualifiedMap();}
  *
  *     {@literal @Provides}
  *     {@literal static Object usesMultibindings(Set<Foo> set, @MyQualifier Map<String, Foo> map}) {
@@ -47,12 +46,11 @@
  *   }</code></pre>
  *
  * <p>A given set or map multibinding can be declared any number of times without error. Dagger
- * never implements calls any {@code @Multibinds} methods.
+ * never implements or calls any {@code @Multibinds} methods.
  *
- * @see <a href="http://google.github.io/dagger/multibindings">Multibindings</a>
+ * @see <a href="https://google.github.io/dagger/multibindings">Multibindings</a>
  */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
-@Beta
 public @interface Multibinds {}
diff --git a/core/src/main/java/dagger/multibindings/StringKey.java b/core/src/main/java/dagger/multibindings/StringKey.java
index 40d48c87c..5dad8e3e9 100644
--- a/core/src/main/java/dagger/multibindings/StringKey.java
+++ b/core/src/main/java/dagger/multibindings/StringKey.java
@@ -20,13 +20,11 @@
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
 import dagger.MapKey;
-import dagger.internal.Beta;
 import java.lang.annotation.Documented;
 import java.lang.annotation.Retention;
 import java.lang.annotation.Target;
 
 /** A {@link MapKey} annotation for maps with {@link String} keys. */
-@Beta
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
diff --git a/core/src/main/java/dagger/multibindings/package-info.java b/core/src/main/java/dagger/multibindings/package-info.java
index fdf64d211..e806d9ec6 100644
--- a/core/src/main/java/dagger/multibindings/package-info.java
+++ b/core/src/main/java/dagger/multibindings/package-info.java
@@ -18,8 +18,6 @@
  * This package contains the API by which Dagger allows you to bind several objects into a
  * collection that can be injected without depending directly on each of the individual bindings.
  *
- * @see <a href="http://google.github.io/dagger/multibindings">Multibindings in the Dagger
- *      User's Guide</a>
+ * @see <a href="https://google.github.io/dagger/multibindings">Multibindings in the Dagger User's Guide</a>
  */
-
 package dagger.multibindings;
diff --git a/core/src/main/java/dagger/package-info.java b/core/src/main/java/dagger/package-info.java
index 92e1fc9ad..a5dd42987 100644
--- a/core/src/main/java/dagger/package-info.java
+++ b/core/src/main/java/dagger/package-info.java
@@ -15,21 +15,19 @@
  */
 
 /**
- * This package contains the public API for the <a href="http://google.github.io/dagger/">Dagger
- * 2</a> dependency injection framework.  By building upon
- * <a href="https://jcp.org/en/jsr/detail?id=330">JSR 330</a>, Dagger 2 provides an
- * annotation-driven API for dependency injection whose implementation is entirely generated at
- * compile time by <a href="http://en.wikipedia.org/wiki/Java_annotation#Processing">annotation
- * processors</a>.
+ * This package contains the public API for the <a href="https://google.github.io/dagger/">Dagger 2</a> dependency
+ * injection framework. By building upon <a href="https://jcp.org/en/jsr/detail?id=330">JSR 330</a>,
+ * Dagger 2 provides an annotation-driven API for dependency injection whose implementation is
+ * entirely generated at compile time by <a
+ * href="http://en.wikipedia.org/wiki/Java_annotation#Processing">annotation processors</a>.
  *
  * <p>The entry point into the API is the {@link Component}, which annotates abstract types for
- * Dagger 2 to implement.  The dependency graph is configured using using annotations such as
- * {@link Module}, {@link Provides} and {@link javax.inject.Inject}.
+ * Dagger 2 to implement. The dependency graph is configured using using annotations such as {@link
+ * Module}, {@link Provides} and {@link javax.inject.Inject}.
  *
  * <p>{@code dagger.internal.codegen.ComponentProcessor} is the processor responsible for generating
- * the implementation.  Dagger uses the annotation procesor
- * {@linkplain java.util.ServiceLoader service loader} to automatically configure the processor, so
- * explict build configuration shouldn't be necessary.
+ * the implementation. Dagger uses the annotation procesor {@linkplain java.util.ServiceLoader
+ * service loader} to automatically configure the processor, so explict build configuration
+ * shouldn't be necessary.
  */
-
 package dagger;
diff --git a/core/src/main/java/dagger/releasablereferences/CanReleaseReferences.java b/core/src/main/java/dagger/releasablereferences/CanReleaseReferences.java
index 7877c47a2..a0890af3d 100644
--- a/core/src/main/java/dagger/releasablereferences/CanReleaseReferences.java
+++ b/core/src/main/java/dagger/releasablereferences/CanReleaseReferences.java
@@ -26,8 +26,8 @@
 /**
  * Annotates {@linkplain javax.inject.Scope scope annotations} to indicate that references to
  * objects stored within that scope can be <a
- * href="http://google.github.io/dagger/users-guide.html#releasable-references">released</a> during
- * the lifetime of the scope.
+ * href="https://google.github.io/dagger/users-guide.html#releasable-references">released</a> during the lifetime
+ * of the scope.
  *
  * <p>A scope can release references if it is annotated with {@code CanReleaseReferences} or if it
  * is annotated with an annotation that itself is annotated with {@code CanReleaseReferences}.
diff --git a/core/src/main/java/dagger/releasablereferences/ForReleasableReferences.java b/core/src/main/java/dagger/releasablereferences/ForReleasableReferences.java
index ef1b653bd..e11adb227 100644
--- a/core/src/main/java/dagger/releasablereferences/ForReleasableReferences.java
+++ b/core/src/main/java/dagger/releasablereferences/ForReleasableReferences.java
@@ -68,8 +68,7 @@
  * <p><b>Note:</b>Releasable references uses Java's {@link java.lang.ref.WeakReference}, and so is
  * not compatible with <a href="http://www.gwtproject.org/">GWT</a>.
  *
- * @see <a href="http://google.github.io/dagger/users-guide.html#releasable-references">Releasable
- *     references</a>
+ * @see <a href="https://google.github.io/dagger/users-guide.html#releasable-references">Releasable references</a>
  * @since 2.8
  */
 @Beta
diff --git a/core/src/main/java/dagger/releasablereferences/ReleasableReferenceManager.java b/core/src/main/java/dagger/releasablereferences/ReleasableReferenceManager.java
index 829fd4c41..0c5acf050 100644
--- a/core/src/main/java/dagger/releasablereferences/ReleasableReferenceManager.java
+++ b/core/src/main/java/dagger/releasablereferences/ReleasableReferenceManager.java
@@ -23,9 +23,8 @@
 import javax.inject.Provider;
 
 /**
- * An object that can <a
- * href="http://google.github.io/dagger/users-guide.html#releasable-references">release or restore
- * strong references</a> held in a {@link CanReleaseReferences @CanReleaseReferences} scope.
+ * An object that can <a href="https://google.github.io/dagger/users-guide.html#releasable-references">release or
+ * restore strong references</a> held in a {@link CanReleaseReferences @CanReleaseReferences} scope.
  *
  * <p>Your top-level component can provide a {@link
  * ForReleasableReferences @ForReleasableReferences(Foo.class)} {@link ReleasableReferenceManager}
diff --git a/core/src/main/java/dagger/releasablereferences/package-info.java b/core/src/main/java/dagger/releasablereferences/package-info.java
index d0d29edbd..a306bdbdc 100644
--- a/core/src/main/java/dagger/releasablereferences/package-info.java
+++ b/core/src/main/java/dagger/releasablereferences/package-info.java
@@ -15,14 +15,13 @@
  */
 
 /**
- * This package contains the API by which Dagger allows you
- * <a href="http://google.github.io/dagger/users-guide.html#releasable-references">release
- * references</a> held within some scopes.
- * 
+ * This package contains the API by which Dagger allows you <a
+ * href="https://google.github.io/dagger/users-guide.html#releasable-references">release references</a> held within
+ * some scopes.
+ *
  * <p><b>Note:</b>Releasable references uses Java's {@link java.lang.ref.WeakReference}, and so is
  * not compatible with <a href="http://www.gwtproject.org/">GWT</a>.
  *
  * @since 2.8
  */
-
 package dagger.releasablereferences;
diff --git a/examples/android-activity-graphs/README.md b/examples/android-activity-graphs/README.md
deleted file mode 100644
index ac3680bb5..000000000
--- a/examples/android-activity-graphs/README.md
+++ /dev/null
@@ -1,24 +0,0 @@
-Example: Android Activity Graphs
-================================
-
-Building on top of the simple Android example, this example demonstrates how it is possible to
-create child graphs for each activity which extend from the global graph.
-
-Some of the advantages of the activity scope:
-
- * Provides the ability to inject objects which require the activity to be constructed.
- * Allows for the use of singletons on a per-activity basis. This is a great way to manage a
-   resource that is shared by a bunch of fragments in an activity.
- * Keeps the global object graph clear of things that can be used only by activities.
-
-While this example only shows the presence of an activity scope, you should be able to see the
-potential for other useful scopes that can be used. For example, having a dedicated object graph
-for the current user session is a great way to manage data that is tied to the currently logged-in
-user.
-
-_Note: The app does not actually do anything when it is run. It is only to show how you can
- structure Dagger within an Android app_
-
-_Note: The app is in transition to Dagger 2 and may not reflect recommended patterns.  Before
- we release Dagger 2.0 it will, but until this note is removed, please do not rely on this
- example as a strong recommendation._
diff --git a/examples/android-activity-graphs/src/main/AndroidManifest.xml b/examples/android-activity-graphs/src/main/AndroidManifest.xml
index 234406dfa..c150e8a2f 100644
--- a/examples/android-activity-graphs/src/main/AndroidManifest.xml
+++ b/examples/android-activity-graphs/src/main/AndroidManifest.xml
@@ -1,18 +1,10 @@
 <?xml version="1.0" encoding="utf-8"?>
-
-<manifest xmlns:android="http://schemas.android.com/apk/res/android"
-    android:versionCode="1"
-    android:versionName="1.0.0"
-    package="com.example.dagger.activitygraphs">
+<manifest xmlns:android="http://schemas.android.com/apk/res/android" android:versionCode="1" android:versionName="1.0.0" package="com.example.dagger.activitygraphs">
 
   <uses-sdk android:minSdkVersion="4" android:targetSdkVersion="17"/>
 
-  <application
-      android:label="app_name"
-      android:name=".DemoApplication">
-    <activity
-        android:label="app_name"
-        android:name=".ui.HomeActivity">
+  <application android:label="app_name" android:name=".DemoApplication">
+    <activity android:label="app_name" android:name=".ui.HomeActivity">
       <intent-filter>
         <action android:name="android.intent.action.MAIN"/>
         <category android:name="android.intent.category.LAUNCHER"/>
@@ -20,4 +12,4 @@
       </intent-filter>
     </activity>
   </application>
-</manifest>
+</manifest>
\ No newline at end of file
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AbstractActivityComponent.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AbstractActivityComponent.java
index 70fbde88b..3d84a4707 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AbstractActivityComponent.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/AbstractActivityComponent.java
@@ -17,6 +17,7 @@
 package com.example.dagger.activitygraphs;
 
 import android.app.Activity;
+import com.example.dagger.activitygraphs.ui.PerActivity;
 import dagger.Component;
 
 /**
@@ -29,7 +30,7 @@
   Activity activity(); // Expose the activity to sub-graphs.
   @Component.Builder
   interface Builder {
-    Builder moduleActivity(ActivityModule module);
+    //Builder moduleActivity(ActivityModule module);
     Builder component(ApplicationComponent component);
     AbstractActivityComponent build();
   }
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
index a5761280f..a155296c9 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ActivityModule.java
@@ -1,78 +1,7 @@
-/*
- * Copyright (C) 2013 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
 package com.example.dagger.activitygraphs;
 
-import android.app.Activity;
 import dagger.Module;
-import dagger.Provides;
-import dagger.multibindings.IntoMap;
-import dagger.multibindings.IntoSet;
-import dagger.multibindings.StringKey;
-
-import javax.inject.Named;
-import java.util.Arrays;
-import java.util.List;
 
-/**
- * A module to wrap the Activity state and expose it to the graph.
- */
 @Module
 public class ActivityModule {
-  private final Activity activity;
-
-  public ActivityModule(Activity activity) {
-    this.activity = activity;
-  }
-
-  /**
-   * Expose the activity to dependents in the graph.
-   */
-  @Provides @PerActivity Activity activity() {
-    return activity;
-  }
-
-  @Provides
-  @StringKey("AAA")
-  @IntoMap
-  public String aString() {
-    return "A";
-  }
-
-  @Provides
-  @StringKey("BBB")
-  @IntoMap
-  public String bString() {
-    return "B";
-  }
-
-  @Provides
-  @Named("AnyString")
-  public String cString() {
-    return "C";
-  }
-
-  @Provides
-  public String dString() {
-    return "D";
-  }
-
-  @Provides
-  public List<String> list() {
-    return Arrays.asList("A", "B", "C");
-  }
-
 }
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
index cbee801ef..b508e96e4 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/DemoApplication.java
@@ -16,15 +16,11 @@
 
 package com.example.dagger.activitygraphs;
 
-import android.app.Activity;
-import android.app.Application;
 import android.location.LocationManager;
-import com.example.dagger.activitygraphs.ui.HomeComponent;
 import dagger.Injector;
 import dagger.Provides;
 import dagger.ProvidesComponent;
 import dagger.ProvidesModule;
-import injector.InjectorSpec;
 
 import javax.inject.Inject;
 
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/PerActivity.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/PerActivity.java
deleted file mode 100644
index f4700161c..000000000
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/PerActivity.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2013 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.example.dagger.activitygraphs;
-
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import java.lang.annotation.Retention;
-import javax.inject.Scope;
-
-/**
- * A scoping annotation to permit objects whose lifetime should
- * conform to the life of the activity to be memoized in the
- * correct component.
- */
-@Scope
-@Retention(RUNTIME)
-public @interface PerActivity {
-}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/ActivityTitleController.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/ActivityTitleController.java
deleted file mode 100644
index 6352d837f..000000000
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/ActivityTitleController.java
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- * Copyright (C) 2013 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.example.dagger.activitygraphs.ui;
-
-import android.app.Activity;
-import com.example.dagger.activitygraphs.PerActivity;
-import javax.inject.Inject;
-
-/**
- * A simple abstraction which provides the ability to set the title on an activity.
- * <p>
- * Fragments should not directly modify any part of an activity outside of the view or dialog that
- * it creates. This class provides a way for fragments to inject a controller that will allow for
- * control of the activity title. While not exceedingly useful in practice, this concept could be
- * expanded to things like facilitating control over the action bar, dialogs, notifications, etc.
- */
-@PerActivity
-public class ActivityTitleController {
-  private final Activity activity;
-
-  @Inject public ActivityTitleController(Activity activity) {
-    this.activity = activity;
-  }
-
-  public void setTitle(CharSequence title) {
-    activity.setTitle(title);
-  }
-}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
index 150610739..65e65dd87 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeActivity.java
@@ -19,7 +19,7 @@
 import android.location.LocationManager;
 import android.os.Bundle;
 import android.support.v4.app.FragmentActivity;
-import com.example.dagger.activitygraphs.ActivityModule;
+//import com.example.dagger.activitygraphs.ActivityModule;
 import com.example.dagger.activitygraphs.DemoApplication;
 import com.example.dagger.activitygraphs.SomeClass;
 import dagger.Lazy;
@@ -47,10 +47,10 @@
 
   HomeComponent component() {
     if (component == null) {
-      component = DaggerHomeComponent.builder()
+      /*component = DaggerHomeComponent.builder()
           .componentApplication(((DemoApplication) getApplication()).component())
           .moduleActivity(new ActivityModule(this))
-          .build();
+          .build();*/
     }
     return component;
   }
@@ -61,7 +61,7 @@ HomeComponent component() {
 
     if (savedInstanceState == null) {
       getSupportFragmentManager().beginTransaction()
-          .add(android.R.id.content, new HomeFragment())
+          //.add(android.R.id.content, new HomeFragment())
           .commit();
     }
 
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeComponent.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeComponent.java
index 604bd4ae7..d390f9787 100644
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeComponent.java
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeComponent.java
@@ -19,14 +19,13 @@
 import com.example.dagger.activitygraphs.AbstractActivityComponent;
 import com.example.dagger.activitygraphs.ActivityModule;
 import com.example.dagger.activitygraphs.ApplicationComponent;
-import com.example.dagger.activitygraphs.PerActivity;
 import dagger.Component;
 
 @PerActivity
 @Component(dependencies = ApplicationComponent.class, modules = ActivityModule.class)
 public interface HomeComponent extends AbstractActivityComponent {
   void inject(HomeActivity homeActivity);
-  void inject(HomeFragment homeFragment);
+  //void inject(HomeFragment homeFragment);
   @Component.Builder
   interface Builder {
     Builder moduleActivity(ActivityModule activityModule);
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeFragment.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeFragment.java
deleted file mode 100644
index 37d6383c2..000000000
--- a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/HomeFragment.java
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2013 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.example.dagger.activitygraphs.ui;
-
-import static android.view.Gravity.CENTER;
-
-import android.os.Bundle;
-import android.support.v4.app.Fragment;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.TextView;
-import javax.inject.Inject;
-
-public class HomeFragment extends Fragment {
-  @Inject ActivityTitleController titleController;
-
-  @Override public void onActivityCreated(Bundle savedInstanceState) {
-    super.onActivityCreated(savedInstanceState);
-    ((HomeActivity) getActivity()).component().inject(this);
-  }
-
-  @Override public View onCreateView(LayoutInflater inflater, ViewGroup container,
-      Bundle savedInstanceState) {
-    TextView tv = new TextView(getActivity());
-    tv.setGravity(CENTER);
-    tv.setText("Hello, World");
-    return tv;
-  }
-
-  @Override public void onResume() {
-    super.onResume();
-
-    // Fragments should not modify things outside of their own view. Use an external controller to
-    // ask the activity to change its title.
-    titleController.setTitle("Home Fragment");
-  }
-}
diff --git a/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/PerActivity.java b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/PerActivity.java
new file mode 100644
index 000000000..fe3e2b5d8
--- /dev/null
+++ b/examples/android-activity-graphs/src/main/java/com/example/dagger/activitygraphs/ui/PerActivity.java
@@ -0,0 +1,10 @@
+package com.example.dagger.activitygraphs.ui;
+
+import javax.inject.Scope;
+
+/**
+ * Created by Andy on 06.06.2017.
+ */
+@Scope
+public @interface PerActivity {
+}
diff --git a/examples/android-simple/README.md b/examples/android-simple/README.md
deleted file mode 100644
index 944d01533..000000000
--- a/examples/android-simple/README.md
+++ /dev/null
@@ -1,17 +0,0 @@
-Example: Android Simple
-=======================
-
-This example demonstrates how to structure an Android application with Dagger.
-
-A custom `Application` class is used to manage a global object graph of objects. Modules are
-assembled with a `getModules` method on the application that can be overridden to add additional
-modules in development versions of your applications or in tests.
-
-Injection of activities is done automatically in a base activity.
-
-_Note: The app does not actually do anything when it is run. It is only to show how you can
- structure Dagger within an Android app_
-
-_Note: The app is in transition to Dagger 2 and may not reflect recommended patterns.  Before
- we release Dagger 2.0 it will, but until this note is removed, please do not rely on this
- example as a strong recommendation._
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/Components.java b/examples/android-simple/src/main/java/com/example/dagger/simple/Components.java
index 624c95874..130595894 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/Components.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/Components.java
@@ -1,6 +1,5 @@
 package com.example.dagger.simple;
 
-import com.example.dagger.simple.ui.HomeActivity;
 import dagger.Component;
 import javax.inject.Singleton;
 
@@ -11,8 +10,8 @@
     @Component(modules = {AndroidModule.class, SingletonModule.class})
     public interface ApplicationComponent {
         //void inject(DemoApplication1 application);
-        void inject(HomeActivity homeActivity);
-        void inject(DemoActivity demoActivity);
+        //void inject(HomeActivity homeActivity);
+        //void inject(DemoActivity demoActivity);
         void inject(DemoApplication1 app);
 
         @Component.Builder
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoActivity.java b/examples/android-simple/src/main/java/com/example/dagger/simple/DemoActivity.java
deleted file mode 100644
index 507cf35ea..000000000
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/DemoActivity.java
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Copyright (C) 2013 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.example.dagger.simple;
-
-import android.app.Activity;
-import android.os.Bundle;
-
-public abstract class DemoActivity extends Activity {
-  @Override protected void onCreate(Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-    // Perform injection so that when this call returns all dependencies will be available for use.
-    ((DemoApplication1) getApplication()).component().inject(this);
-  }
-}
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/ForApplication.java b/examples/android-simple/src/main/java/com/example/dagger/simple/ForApplication.java
index 517843efd..3ac41b9dc 100644
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/ForApplication.java
+++ b/examples/android-simple/src/main/java/com/example/dagger/simple/ForApplication.java
@@ -1,26 +1,10 @@
-/*
- * Copyright (C) 2013 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
 package com.example.dagger.simple;
 
-import static java.lang.annotation.RetentionPolicy.RUNTIME;
-
-import java.lang.annotation.Retention;
 import javax.inject.Qualifier;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
 
-@Qualifier @Retention(RUNTIME)
+@Retention(RetentionPolicy.RUNTIME)
+@Qualifier
 public @interface ForApplication {
 }
diff --git a/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java b/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java
deleted file mode 100644
index a4c2c040d..000000000
--- a/examples/android-simple/src/main/java/com/example/dagger/simple/ui/HomeActivity.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (C) 2013 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.example.dagger.simple.ui;
-
-import android.location.LocationManager;
-import android.os.Bundle;
-import android.util.Log;
-import com.example.dagger.simple.DemoActivity;
-import com.example.dagger.simple.DemoApplication1;
-import javax.inject.Inject;
-
-public class HomeActivity extends DemoActivity {
-  @Inject LocationManager locationManager;
-
-  @Override protected void onCreate(Bundle savedInstanceState) {
-    super.onCreate(savedInstanceState);
-    ((DemoApplication1) getApplication()).component().inject(this);
-
-    // TODO do something with the injected dependencies here!
-    Log.d("HomeActivity", locationManager.toString());
-  }
-}
diff --git a/examples/simple/src/main/java/coffee/App.java b/examples/simple/src/main/java/coffee/App.java
index 08390d926..197e2c69c 100644
--- a/examples/simple/src/main/java/coffee/App.java
+++ b/examples/simple/src/main/java/coffee/App.java
@@ -1,6 +1,6 @@
 package coffee;
 
-public class App extends DaggerApplication {
+public class App extends DaggerHookApplication {
 
     @Override
     public void onCreate() {
diff --git a/examples/simple/src/main/java/coffee/CoffeeApp.java b/examples/simple/src/main/java/coffee/CoffeeApp.java
index bfdae9ac7..24b1ce699 100644
--- a/examples/simple/src/main/java/coffee/CoffeeApp.java
+++ b/examples/simple/src/main/java/coffee/CoffeeApp.java
@@ -1,11 +1,7 @@
 package coffee;
 
-import dagger.Component;
-import dagger.Module;
-import dagger.ProvidesModule;
-import dagger.Subcomponent;
+import dagger.*;
 
-import javax.inject.Named;
 import javax.inject.Singleton;
 
 public class CoffeeApp {
@@ -16,6 +12,7 @@
     Thermosiphon thermosiphon();
     @Component.Builder
     interface Builder {
+      @BindsInstance Builder app(App app);
       Builder dripCoffeeModule(DripCoffeeModule module);
       Coffee build();
     }
diff --git a/grpc/src/main/java/dagger/grpc/server/CallScoped.java b/grpc/src/main/java/dagger/grpc/server/CallScoped.java
new file mode 100644
index 000000000..a477f9d29
--- /dev/null
+++ b/grpc/src/main/java/dagger/grpc/server/CallScoped.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server;
+
+import java.lang.annotation.Documented;
+import javax.inject.Scope;
+
+/**
+ * A scope that lasts as long as a single gRPC {@link io.grpc.ServerCall}.
+ */
+@Scope
+@Documented
+public @interface CallScoped {}
diff --git a/grpc/src/main/java/dagger/grpc/server/CurrentContextModule.java b/grpc/src/main/java/dagger/grpc/server/CurrentContextModule.java
new file mode 100644
index 000000000..c11753762
--- /dev/null
+++ b/grpc/src/main/java/dagger/grpc/server/CurrentContextModule.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server;
+
+import dagger.Module;
+import dagger.Provides;
+import io.grpc.Context;
+
+/**
+ * Provides the current {@link Context}.
+ */
+@Module
+public final class CurrentContextModule {
+
+  @Provides
+  static Context currentContext() {
+    return Context.current();
+  }
+}
diff --git a/grpc/src/main/java/dagger/grpc/server/ForGrpcService.java b/grpc/src/main/java/dagger/grpc/server/ForGrpcService.java
new file mode 100644
index 000000000..33a83ad73
--- /dev/null
+++ b/grpc/src/main/java/dagger/grpc/server/ForGrpcService.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server;
+
+import java.lang.annotation.Documented;
+import javax.inject.Qualifier;
+
+/**
+ * Qualifies some per-service types provided by {@link dagger.Module}s generated by {@link
+ * GrpcService}.
+ */
+@Documented
+@Qualifier
+public @interface ForGrpcService {
+
+  /** The gRPC service class. */
+  Class<?> value();
+}
diff --git a/grpc/src/main/java/dagger/grpc/server/GrpcCallMetadataModule.java b/grpc/src/main/java/dagger/grpc/server/GrpcCallMetadataModule.java
new file mode 100644
index 000000000..8d474d965
--- /dev/null
+++ b/grpc/src/main/java/dagger/grpc/server/GrpcCallMetadataModule.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import dagger.Module;
+import dagger.Provides;
+import io.grpc.Metadata;
+
+/**
+ * Provides {@link Metadata} about a gRPC call.
+ */
+@Module
+public final class GrpcCallMetadataModule {
+  private final Metadata metadata;
+
+  public GrpcCallMetadataModule(Metadata metadata) {
+    this.metadata = checkNotNull(metadata);
+  }
+
+  @Provides
+  Metadata provideHeaders() {
+    return metadata;
+  }
+}
diff --git a/grpc/src/main/java/dagger/grpc/server/GrpcService.java b/grpc/src/main/java/dagger/grpc/server/GrpcService.java
new file mode 100644
index 000000000..a7461951d
--- /dev/null
+++ b/grpc/src/main/java/dagger/grpc/server/GrpcService.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Target;
+
+/**
+ * Annotates a class that implements a gRPC service.
+ *
+ * <p>Generates several types when annotating a class {@code Foo}:
+ *
+ * <ul>
+ * <li>Interfaces {@code FooComponent} and {@code FooComponent.Factory}.
+ * <li>{@linkplain dagger.Module Modules} {@code FooGrpcProxyModule} and {@code
+ *     FooGrpcServiceModule}.
+ * </ul>
+ *
+ * <p>To use these types to configure a server:
+ *
+ * <ol>
+ * <li>Create a {@linkplain dagger.Subcomponent subcomponent} that implements {@code FooComponent}
+ *     and installs {@code FooGrpcServiceModule}.
+ * <li>Install {@link NettyServerModule} or another {@link ServerModule} subclass and {@code
+ *     FooGrpcProxyModule} into your {@link javax.inject.Singleton @Singleton} {@linkplain
+ *     dagger.Component component}.
+ * <li>Bind an implementation of {@code FooComponent.Factory} in your {@link
+ *     javax.inject.Singleton @Singleton} {@linkplain dagger.Component component}. The
+ *     implementation will typically inject the {@link javax.inject.Singleton @Singleton}
+ *     {@linkplain dagger.Component component} and call subcomponent factory methods to instantiate
+ *     the correct subcomponent.
+ * </ol>
+ */
+@Documented
+@Target(ElementType.TYPE)
+public @interface GrpcService {
+  /** The class that gRPC generates from the proto service definition. */
+  Class<?> grpcClass();
+}
diff --git a/grpc/src/main/java/dagger/grpc/server/InProcessServerModule.java b/grpc/src/main/java/dagger/grpc/server/InProcessServerModule.java
new file mode 100644
index 000000000..fd93382f2
--- /dev/null
+++ b/grpc/src/main/java/dagger/grpc/server/InProcessServerModule.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+import dagger.Module;
+import dagger.Provides;
+import io.grpc.Server;
+import io.grpc.ServerBuilder;
+import io.grpc.inprocess.InProcessServerBuilder;
+import javax.inject.Singleton;
+
+/**
+ * Installing this module into a {@link Singleton @Singleton} component means the component can
+ * provide a {@link Server} that serves {@linkplain InProcessServerBuilder in-process} requests.
+ */
+@Module(includes = ServerModule.class)
+public final class InProcessServerModule {
+
+  private final String name;
+
+  private InProcessServerModule(String name) {
+    this.name = checkNotNull(name);
+  }
+
+  /**
+   * Creates a module that provides a server that binds to a given name
+   *
+   * @param name the identity of the server for clients to connect to
+   */
+  public static InProcessServerModule serverNamed(String name) {
+    return new InProcessServerModule(name);
+  }
+
+  @Provides
+  ServerBuilder<?> serverBuilder() {
+    return InProcessServerBuilder.forName(name);
+  }
+}
diff --git a/grpc/src/main/java/dagger/grpc/server/NettyServerModule.java b/grpc/src/main/java/dagger/grpc/server/NettyServerModule.java
new file mode 100644
index 000000000..4361d6229
--- /dev/null
+++ b/grpc/src/main/java/dagger/grpc/server/NettyServerModule.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server;
+
+import dagger.Module;
+import dagger.Provides;
+import io.grpc.Server;
+import io.grpc.ServerBuilder;
+import io.grpc.netty.NettyServerBuilder;
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import javax.inject.Singleton;
+
+/**
+ * Installing this module into a {@link Singleton @Singleton} component means the component can
+ * provide a {@linkplain NettyServerBuilder Netty}-based {@link Server}.
+ */
+@Module(includes = ServerModule.class)
+public final class NettyServerModule {
+
+  private final SocketAddress socketAddress;
+
+  private NettyServerModule(SocketAddress socketAddress) {
+    this.socketAddress = socketAddress;
+  }
+
+  /**
+   * A module that binds to {@code port} on the wildcard address.
+   */
+  public static NettyServerModule bindingToPort(int port) {
+    return new NettyServerModule(new InetSocketAddress(port));
+  }
+
+  /**
+   * A module that binds to {@code socketAddress}.
+   */
+  public static NettyServerModule bindingTo(SocketAddress socketAddress) {
+    return new NettyServerModule(socketAddress);
+  }
+
+  @Provides
+  ServerBuilder<?> serverBuilder() {
+    return NettyServerBuilder.forAddress(socketAddress);
+  }
+}
diff --git a/grpc/src/main/java/dagger/grpc/server/ProxyServerCallHandler.java b/grpc/src/main/java/dagger/grpc/server/ProxyServerCallHandler.java
new file mode 100644
index 000000000..751d8cae0
--- /dev/null
+++ b/grpc/src/main/java/dagger/grpc/server/ProxyServerCallHandler.java
@@ -0,0 +1,191 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server;
+
+import io.grpc.Metadata;
+import io.grpc.MethodDescriptor;
+import io.grpc.MethodDescriptor.Marshaller;
+import io.grpc.ServerCall;
+import io.grpc.ServerCall.Listener;
+import io.grpc.ServerCallHandler;
+import io.grpc.ServerMethodDefinition;
+import io.grpc.ServerServiceDefinition;
+import io.grpc.Status;
+import java.io.InputStream;
+
+/**
+ * A {@link ServerCallHandler} that handles calls for a particular method by delegating to a handler
+ * in a {@link ServerServiceDefinition} returned by a factory.
+ *
+ * @param <RequestT> the type of the request payloads
+ * @param <ResponseT> the type of the response payloads
+ */
+public final class ProxyServerCallHandler<RequestT, ResponseT>
+    implements ServerCallHandler<InputStream, InputStream> {
+
+  /**
+   * A factory for the {@link ServerServiceDefinition} that a {@link ProxyServerCallHandler}
+   * delegates to.
+   */
+  public interface ServiceDefinitionFactory {
+    /**
+     * Returns a service definition that contains a {@link ServerCallHandler} for the
+     * {@link ProxyServerCallHandler}'s method.
+     */
+    ServerServiceDefinition getServiceDefinition(Metadata headers);
+  }
+
+  private final MethodDescriptor<RequestT, ResponseT> delegateMethodDescriptor;
+  private final ServiceDefinitionFactory delegateServiceDefinitionFactory;
+
+  /**
+   * Returns a proxy method definition for {@code methodDescriptor}.
+   *
+   * @param delegateServiceDefinitionFactory factory for the delegate service definition
+   */
+  public static <RequestT, ResponseT> ServerMethodDefinition<InputStream, InputStream> proxyMethod(
+      MethodDescriptor<RequestT, ResponseT> delegateMethodDescriptor,
+      ServiceDefinitionFactory delegateServiceDefinitionFactory) {
+    return ServerMethodDefinition.create(
+        MethodDescriptor.create(
+            delegateMethodDescriptor.getType(),
+            delegateMethodDescriptor.getFullMethodName(),
+            IDENTITY_MARSHALLER,
+            IDENTITY_MARSHALLER),
+        new ProxyServerCallHandler<>(delegateMethodDescriptor, delegateServiceDefinitionFactory));
+  }
+
+  ProxyServerCallHandler(
+      MethodDescriptor<RequestT, ResponseT> delegateMethodDescriptor,
+      ServiceDefinitionFactory delegateServiceDefinitionFactory) {
+    this.delegateMethodDescriptor = delegateMethodDescriptor;
+    this.delegateServiceDefinitionFactory = delegateServiceDefinitionFactory;
+  }
+
+  @Override
+  public Listener<InputStream> startCall(
+      ServerCall<InputStream, InputStream> call,
+      Metadata headers) {
+    ServerMethodDefinition<RequestT, ResponseT> delegateMethod = getMethodDefinition(headers);
+    Listener<RequestT> delegateListener =
+        delegateMethod
+            .getServerCallHandler()
+            .startCall(new ServerCallAdapter(call, delegateMethod.getMethodDescriptor()), headers);
+    return new ServerCallListenerAdapter(delegateListener);
+  }
+
+  @SuppressWarnings("unchecked") // Method definition is the correct type.
+  private ServerMethodDefinition<RequestT, ResponseT> getMethodDefinition(Metadata headers) {
+    String fullMethodName = delegateMethodDescriptor.getFullMethodName();
+    for (ServerMethodDefinition<?, ?> methodDefinition :
+        delegateServiceDefinitionFactory.getServiceDefinition(headers).getMethods()) {
+      if (methodDefinition.getMethodDescriptor().getFullMethodName().equals(fullMethodName)) {
+        return (ServerMethodDefinition<RequestT, ResponseT>) methodDefinition;
+      }
+    }
+    throw new IllegalStateException("Could not find " + fullMethodName);
+  }
+
+  private static final Marshaller<InputStream> IDENTITY_MARSHALLER =
+      new Marshaller<InputStream>() {
+        @Override
+        public InputStream stream(InputStream value) {
+          return value;
+        }
+
+        @Override
+        public InputStream parse(InputStream stream) {
+          return stream;
+        }
+      };
+
+  /** A {@link Listener} that adapts {@code Listener<RequestT>} to {@code Listener<InputStream>}. */
+  private final class ServerCallListenerAdapter extends Listener<InputStream> {
+
+    private final Listener<RequestT> delegate;
+
+    public ServerCallListenerAdapter(Listener<RequestT> delegate) {
+      this.delegate = delegate;
+    }
+
+    @Override
+    public void onMessage(InputStream message) {
+      delegate.onMessage(delegateMethodDescriptor.parseRequest(message));
+    }
+
+    @Override
+    public void onHalfClose() {
+      delegate.onHalfClose();
+    }
+
+    @Override
+    public void onCancel() {
+      delegate.onCancel();
+    }
+
+    @Override
+    public void onComplete() {
+      delegate.onComplete();
+    }
+  }
+
+  /**
+   * A {@link ServerCall} that adapts {@code ServerCall<InputStream>} to {@code
+   * ServerCall<ResponseT>}.
+   */
+  final class ServerCallAdapter extends ServerCall<RequestT, ResponseT> {
+
+    private final ServerCall<InputStream, InputStream> delegate;
+    private final MethodDescriptor<RequestT, ResponseT> method;
+
+    ServerCallAdapter(ServerCall<InputStream, InputStream> delegate,
+        MethodDescriptor<RequestT, ResponseT> method) {
+      this.delegate = delegate;
+      this.method = method;
+    }
+
+    @Override
+    public MethodDescriptor<RequestT, ResponseT> getMethodDescriptor() {
+      return method;
+    }
+
+    @Override
+    public void request(int numMessages) {
+      delegate.request(numMessages);
+    }
+
+    @Override
+    public void sendHeaders(Metadata headers) {
+      delegate.sendHeaders(headers);
+    }
+
+    @Override
+    public void sendMessage(ResponseT message) {
+      delegate.sendMessage(delegateMethodDescriptor.streamResponse(message));
+    }
+
+    @Override
+    public void close(Status status, Metadata trailers) {
+      delegate.close(status, trailers);
+    }
+
+    @Override
+    public boolean isCancelled() {
+      return delegate.isCancelled();
+    }
+  }
+}
diff --git a/grpc/src/main/java/dagger/grpc/server/README.md b/grpc/src/main/java/dagger/grpc/server/README.md
new file mode 100644
index 000000000..ffcfd0d19
--- /dev/null
+++ b/grpc/src/main/java/dagger/grpc/server/README.md
@@ -0,0 +1,10 @@
+# Dagger-gRPC on the Server
+
+This package contains the public types used to create gRPC server applications
+using google.github.io/dagger.
+
+It is maintained by the Dagger team.
+
+It is in development, and is planned for open-source release as part of Dagger.
+
+See user documentation at google.github.io/dagger-grpc.
diff --git a/grpc/src/main/java/dagger/grpc/server/ServerModule.java b/grpc/src/main/java/dagger/grpc/server/ServerModule.java
new file mode 100644
index 000000000..f03f99797
--- /dev/null
+++ b/grpc/src/main/java/dagger/grpc/server/ServerModule.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server;
+
+import dagger.Module;
+import dagger.Provides;
+import io.grpc.Server;
+import io.grpc.ServerBuilder;
+import io.grpc.ServerServiceDefinition;
+import java.util.Set;
+import javax.inject.Singleton;
+
+/**
+ * Provides a {@link Singleton @Singleton} {@link Server}.
+ */
+@Module
+public final class ServerModule {
+
+  @Provides
+  @Singleton
+  static Server provideServer(
+      ServerBuilder<?> serverBuilder, Set<ServerServiceDefinition> serviceDefinitions) {
+    for (ServerServiceDefinition serverServiceDefinition : serviceDefinitions) {
+      serverBuilder.addService(serverServiceDefinition);
+    }
+    return serverBuilder.build();
+  }
+}
diff --git a/grpc/src/main/java/dagger/grpc/server/processor/GrpcServiceModel.java b/grpc/src/main/java/dagger/grpc/server/processor/GrpcServiceModel.java
new file mode 100644
index 000000000..5188b61a1
--- /dev/null
+++ b/grpc/src/main/java/dagger/grpc/server/processor/GrpcServiceModel.java
@@ -0,0 +1,189 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server.processor;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
+import static com.google.auto.common.MoreElements.getAnnotationMirror;
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.base.Joiner;
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import dagger.grpc.server.ForGrpcService;
+import dagger.grpc.server.GrpcService;
+import dagger.grpc.server.processor.SourceGenerator.IoGrpc;
+import javax.annotation.Generated;
+import javax.annotation.processing.Messager;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.AnnotationValue;
+import javax.lang.model.element.AnnotationValueVisitor;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.SimpleAnnotationValueVisitor7;
+import javax.lang.model.util.Types;
+import javax.tools.Diagnostic.Kind;
+
+class GrpcServiceModel {
+
+  private static final String GRPC_SERVICE_PARAMETER_NAME = "grpcClass";
+
+  private final Types types;
+  private final Elements elements;
+  private final Messager messager;
+  final TypeElement serviceImplementation;
+  final ClassName serviceImplementationClassName;
+  final ClassName serviceDefinitionTypeName;
+  final ClassName proxyModuleName;
+  final ClassName serviceDefinitionTypeFactoryName;
+  final ClassName serviceModuleName;
+  final ClassName unscopedServiceModuleName;
+
+  GrpcServiceModel(ProcessingEnvironment processingEnv, TypeElement serviceImplementation) {
+    this.types = processingEnv.getTypeUtils();
+    this.elements = processingEnv.getElementUtils();
+    this.messager = processingEnv.getMessager();
+    this.serviceImplementation = serviceImplementation;
+    this.serviceImplementationClassName = ClassName.get(serviceImplementation);
+    this.serviceDefinitionTypeName = peerClassWithSuffix("ServiceDefinition");
+    this.serviceDefinitionTypeFactoryName = serviceDefinitionTypeName.nestedClass("Factory");
+    this.proxyModuleName = peerClassWithSuffix("GrpcProxyModule");
+    this.serviceModuleName = peerClassWithSuffix("GrpcServiceModule");
+    this.unscopedServiceModuleName = peerClassWithSuffix("UnscopedGrpcServiceModule");
+  }
+
+  /**
+   * Returns the name of a top-level class in the same package as the service implementation
+   * class, whose name is the simple name of the service implementation class and its enclosing
+   * classes, joined with underscores, and appended with {@code suffix}.
+   */
+  private ClassName peerClassWithSuffix(String suffix) {
+    return serviceImplementationClassName.peerClass(
+        Joiner.on('_').join(serviceImplementationClassName.simpleNames()) + suffix);
+  }
+
+  String packageName() {
+    return serviceImplementationClassName.packageName();
+  }
+
+  public boolean validate() {
+    AnnotationValue argument =
+        getAnnotationValue(grpcServiceAnnotation(), GRPC_SERVICE_PARAMETER_NAME);
+    return argument.accept(
+        new SimpleAnnotationValueVisitor7<Boolean, AnnotationValue>(false) {
+          @Override
+          public Boolean visitType(TypeMirror type, AnnotationValue value) {
+            return validateGrpcClass(type, value);
+          }
+        },
+        argument);
+  }
+
+  private AnnotationMirror grpcServiceAnnotation() {
+    return getAnnotationMirror(serviceImplementation, GrpcService.class).get();
+  }
+
+  /** Returns the gRPC service class declared by {@link GrpcService#grpcClass()}. */
+  protected final TypeElement grpcClass() {
+    AnnotationValue argument =
+        getAnnotationValue(grpcServiceAnnotation(), GRPC_SERVICE_PARAMETER_NAME);
+    return GET_TYPE_ELEMENT_FROM_VALUE.visit(argument, argument);
+  }
+
+  /**
+   * Returns the annotation spec for the {@link Generated @Generated} annotation to add to any
+   * type generated by this processor.
+   */
+  protected final AnnotationSpec generatedAnnotation() {
+    return AnnotationSpec.builder(Generated.class)
+        .addMember(
+            "value",
+            "$S",
+            String.format(
+                "@%s annotation on %s",
+                GrpcService.class.getCanonicalName(), serviceImplementationClassName))
+        .build();
+  }
+
+  /**
+   * Returns the annotation spec for a {@link ForGrpcService} annotation whose value is the
+   * gRPC-generated service class.
+   */
+  protected final AnnotationSpec forGrpcService() {
+    return AnnotationSpec.builder(ForGrpcService.class)
+        .addMember("value", "$T.class", grpcClass())
+        .build();
+  }
+
+  protected final String subcomponentServiceDefinitionMethodName() {
+    return UPPER_CAMEL.to(LOWER_CAMEL, simpleServiceName()) + "ServiceDefinition";
+  }
+
+  private String simpleServiceName() {
+    return grpcClass().getSimpleName().toString().replaceFirst("Grpc$", "");
+  }
+
+  private TypeElement serviceImplBase(TypeMirror service) {
+    ClassName serviceClassName = ClassName.get(MoreTypes.asTypeElement(service));
+    ClassName serviceImplBaseName = serviceClassName.nestedClass(simpleServiceName() + "ImplBase");
+    return elements.getTypeElement(serviceImplBaseName.toString());
+  }
+
+  private boolean validateGrpcClass(TypeMirror type, AnnotationValue value) {
+    TypeElement serviceImplBase = serviceImplBase(type);
+    if (serviceImplBase == null || !types.isSubtype(serviceImplBase.asType(), bindableService())) {
+      messager.printMessage(
+          Kind.ERROR,
+          String.format("%s is not a gRPC service class", type),
+          serviceImplementation,
+          grpcServiceAnnotation(),
+          value);
+      return false;
+    }
+    if (!(types.isSubtype(serviceImplementation.asType(), serviceImplBase.asType()))) {
+      messager.printMessage(
+          Kind.ERROR,
+          String.format(
+              "%s must extend %s", serviceImplementation, serviceImplBase.getQualifiedName()),
+          serviceImplementation,
+          grpcServiceAnnotation(),
+          value);
+      return false;
+    }
+    return true;
+  }
+
+  private TypeMirror bindableService() {
+    return elements.getTypeElement(IoGrpc.BINDABLE_SERVICE.toString()).asType();
+  }
+
+  static final AnnotationValueVisitor<TypeElement, AnnotationValue> GET_TYPE_ELEMENT_FROM_VALUE =
+      new SimpleAnnotationValueVisitor7<TypeElement, AnnotationValue>() {
+        @Override
+        public TypeElement visitType(TypeMirror t, AnnotationValue p) {
+          return MoreTypes.asTypeElement(t);
+        }
+
+        @Override
+        protected TypeElement defaultAction(Object o, AnnotationValue p) {
+          throw new IllegalArgumentException("Expected " + p + " to be a class");
+        }
+      };
+}
diff --git a/grpc/src/main/java/dagger/grpc/server/processor/GrpcServiceModuleGenerator.java b/grpc/src/main/java/dagger/grpc/server/processor/GrpcServiceModuleGenerator.java
new file mode 100644
index 000000000..ab8bcafc9
--- /dev/null
+++ b/grpc/src/main/java/dagger/grpc/server/processor/GrpcServiceModuleGenerator.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server.processor;
+
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static com.squareup.javapoet.WildcardTypeName.subtypeOf;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import dagger.grpc.server.GrpcService;
+import java.util.List;
+
+/**
+ * An object that generates the non-proxying service definition module for a {@link
+ * GrpcService}-annotated service implementation.
+ */
+final class GrpcServiceModuleGenerator extends SourceGenerator {
+
+  private static final TypeName LIST_OF_INTERCEPTORS = ParameterizedTypeName.get(
+      ClassName.get(List.class), subtypeOf(IoGrpc.SERVER_INTERCEPTOR));
+  
+  private final GrpcServiceModel grpcServiceModel;
+
+  GrpcServiceModuleGenerator(GrpcServiceModel grpcServiceModel) {
+    super(grpcServiceModel.packageName());
+    this.grpcServiceModel = grpcServiceModel;
+  }
+
+  @Override
+  protected TypeSpec createType() {
+    return classBuilder(grpcServiceModel.serviceModuleName)
+        .addJavadoc(
+            "Install this module in the {@link $T @Singleton} server component\n",
+            JavaxInject.singleton().type)
+        .addJavadoc(
+            "or in the subcomponent that implements {@link $T}.\n",
+            grpcServiceModel.serviceDefinitionTypeName)
+        .addAnnotation(grpcServiceModel.generatedAnnotation())
+        .addAnnotation(Dagger.module())
+        .addModifiers(PUBLIC, FINAL)
+        .addMethod(provideServiceDefinition())
+        .build();
+  }
+
+  /**
+   * Returns the {@link dagger.Provides @Provides} method for the {@link
+   * io.grpc.ServerServiceDefinition} for the service.
+   */
+  private MethodSpec provideServiceDefinition() {
+    return methodBuilder("serviceDefinition")
+        .addAnnotation(Dagger.provides())
+        .addAnnotation(grpcServiceModel.forGrpcService())
+        .addModifiers(STATIC)
+        .returns(IoGrpc.SERVER_SERVICE_DEFINITION)
+        .addParameter(grpcServiceModel.serviceImplementationClassName, "implementation")
+        .addParameter(
+            ParameterSpec.builder(LIST_OF_INTERCEPTORS, "interceptors")
+                .addAnnotation(grpcServiceModel.forGrpcService())
+                .build())
+        .addStatement(
+            "$T serviceDefinition = implementation.bindService()", IoGrpc.SERVER_SERVICE_DEFINITION)
+        .addStatement(
+            "return $T.intercept(serviceDefinition, interceptors)", IoGrpc.SERVER_INTERCEPTORS)
+        .build();
+  }
+}
diff --git a/grpc/src/main/java/dagger/grpc/server/processor/GrpcServiceProcessor.java b/grpc/src/main/java/dagger/grpc/server/processor/GrpcServiceProcessor.java
new file mode 100644
index 000000000..917d99365
--- /dev/null
+++ b/grpc/src/main/java/dagger/grpc/server/processor/GrpcServiceProcessor.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server.processor;
+
+import static javax.lang.model.util.ElementFilter.typesIn;
+
+import com.google.auto.common.BasicAnnotationProcessor;
+import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
+import com.google.auto.service.AutoService;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.SetMultimap;
+import com.google.googlejavaformat.java.filer.FormattingFiler;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.JavaFile;
+import dagger.grpc.server.GrpcService;
+import java.io.IOException;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.annotation.processing.Processor;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+import javax.tools.Diagnostic.Kind;
+
+/**
+ * Generates code from types annotated with {@link GrpcService @GrpcService}.
+ *
+ * @see <a href="google.github.io/dagger-grpc">google.github.io/dagger-grpc</a>
+ */
+@AutoService(Processor.class)
+public class GrpcServiceProcessor extends BasicAnnotationProcessor implements ProcessingStep {
+
+  @Override
+  protected ImmutableList<GrpcServiceProcessor> initSteps() {
+    return ImmutableList.of(this);
+  }
+
+  @Override
+  public ImmutableSet<Class<GrpcService>> annotations() {
+    return ImmutableSet.of(GrpcService.class);
+  }
+
+  @Override
+  public SourceVersion getSupportedSourceVersion() {
+    return SourceVersion.latest();
+  }
+
+  @Override
+  public Set<Element> process(
+      SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
+    for (TypeElement element : typesIn(elementsByAnnotation.get(GrpcService.class))) {
+      GrpcServiceModel grpcServiceModel = new GrpcServiceModel(processingEnv, element);
+      if (grpcServiceModel.validate()) {
+        write(new ServiceDefinitionTypeGenerator(grpcServiceModel), element);
+        write(new ProxyModuleGenerator(grpcServiceModel), element);
+        write(new GrpcServiceModuleGenerator(grpcServiceModel), element);
+        write(new UnscopedGrpcServiceModuleGenerator(grpcServiceModel), element);
+      }
+    }
+    return ImmutableSet.of();
+  }
+
+  private void write(SourceGenerator grpcServiceTypeWriter, final TypeElement element) {
+    JavaFile javaFile = grpcServiceTypeWriter.javaFile();
+    ClassName outputClassName = ClassName.get(javaFile.packageName, javaFile.typeSpec.name);
+    try {
+      javaFile.writeTo(new FormattingFiler(processingEnv.getFiler()));
+    } catch (IOException e) {
+      processingEnv
+          .getMessager()
+          .printMessage(
+              Kind.ERROR, String.format("Error writing %s: %s", outputClassName, e), element);
+    }
+  }
+}
diff --git a/grpc/src/main/java/dagger/grpc/server/processor/ProxyModuleGenerator.java b/grpc/src/main/java/dagger/grpc/server/processor/ProxyModuleGenerator.java
new file mode 100644
index 000000000..68fb6ce46
--- /dev/null
+++ b/grpc/src/main/java/dagger/grpc/server/processor/ProxyModuleGenerator.java
@@ -0,0 +1,150 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server.processor;
+
+import static com.google.auto.common.MoreElements.hasModifiers;
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+import static javax.lang.model.util.ElementFilter.fieldsIn;
+
+import com.google.common.base.Predicate;
+import com.google.common.collect.FluentIterable;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
+import com.squareup.javapoet.TypeName;
+import com.squareup.javapoet.TypeSpec;
+import dagger.grpc.server.GrpcService;
+import javax.lang.model.element.VariableElement;
+
+/**
+ * An object that generates the proxying service definition module for a {@link
+ * GrpcService}-annotated service implementation.
+ */
+final class ProxyModuleGenerator extends SourceGenerator {
+
+  private final GrpcServiceModel grpcServiceModel;
+
+  ProxyModuleGenerator(GrpcServiceModel grpcServiceModel) {
+    super(grpcServiceModel.packageName());
+    this.grpcServiceModel = grpcServiceModel;
+  }
+
+  @Override
+  protected TypeSpec createType() {
+    return classBuilder(grpcServiceModel.proxyModuleName)
+        .addModifiers(PUBLIC, FINAL)
+        .addJavadoc(
+            "Install this module in the {@link $T @Singleton} server component.\n",
+            JavaxInject.singleton().type)
+        .addAnnotation(grpcServiceModel.generatedAnnotation())
+        .addAnnotation(Dagger.module())
+        .addMethod(provideServiceDefinitionContribution())
+        .addMethod(provideServiceDefinitionFactory())
+        .build();
+  }
+
+  /**
+   * Returns the {@link dagger.Provides @Provides} method for the proxying {@link
+   * io.grpc.ServerServiceDefinition}.
+   */
+  private MethodSpec provideServiceDefinitionContribution() {
+    MethodSpec.Builder method =
+        methodBuilder("serviceDefinition")
+            .addAnnotation(Dagger.provides())
+            .addAnnotation(Dagger.intoSet())
+            .addAnnotation(JavaxInject.singleton())
+            .addModifiers(STATIC)
+            .returns(IoGrpc.SERVER_SERVICE_DEFINITION)
+            .addParameter(
+                ParameterSpec.builder(
+                        Dagger.GrpcServer.SERVICE_DEFINITION_FACTORY, "serviceDefinitionFactory")
+                    .addAnnotation(grpcServiceModel.forGrpcService())
+                    .build())
+            .addCode(
+                "return $T.builder($T.SERVICE_NAME)",
+                IoGrpc.SERVER_SERVICE_DEFINITION,
+                grpcServiceModel.grpcClass());
+    for (VariableElement methodDescriptorField : methodDescriptorFields()) {
+      method.addCode(
+          ".addMethod($T.proxyMethod($T.$N, serviceDefinitionFactory))",
+          Dagger.GrpcServer.PROXY_SERVER_CALL_HANDLER,
+          grpcServiceModel.grpcClass(),
+          methodDescriptorField.getSimpleName());
+    }
+    method.addCode(".build();");
+    return method.build();
+  }
+
+  /**
+   * Returns he {@link io.grpc.MethodDescriptor} {@code *_METHOD} fields on the class enclosing the
+   * service interface.
+   */
+  private FluentIterable<VariableElement> methodDescriptorFields() {
+    return FluentIterable.from(fieldsIn(grpcServiceModel.grpcClass().getEnclosedElements()))
+        .filter(hasModifiers(PUBLIC, STATIC))
+        .filter(
+            new Predicate<VariableElement>() {
+              @Override
+              public boolean apply(VariableElement element) {
+                TypeName typeName = TypeName.get(element.asType());
+                return typeName instanceof ParameterizedTypeName
+                    && ((ParameterizedTypeName) typeName).rawType.equals(IoGrpc.METHOD_DESCRIPTOR);
+              }
+            });
+  }
+
+  /**
+   * Returns the {@link dagger.Provides @Provides} method for the {@link
+   * dagger.grpc.server.ProxyServerCallHandler.ServiceDefinitionFactory} used by the proxy.
+   */
+  private MethodSpec provideServiceDefinitionFactory() {
+    return methodBuilder("serviceDefinitionFactory")
+        .addAnnotation(Dagger.provides())
+        .addAnnotation(grpcServiceModel.forGrpcService())
+        .addModifiers(STATIC)
+        .returns(Dagger.GrpcServer.SERVICE_DEFINITION_FACTORY)
+        .addParameter(grpcServiceModel.serviceDefinitionTypeFactoryName, "factory", FINAL)
+        .addStatement("return $L", anonymousServiceDefinitionFactory())
+        .build();
+  }
+
+  /**
+   * Returns the anonymous inner class that implements the {@link
+   * dagger.grpc.server.ProxyServerCallHandler.ServiceDefinitionFactory} used by the proxy.
+   */
+  private TypeSpec anonymousServiceDefinitionFactory() {
+    return anonymousClassBuilder("")
+        .addSuperinterface(Dagger.GrpcServer.SERVICE_DEFINITION_FACTORY)
+        .addMethod(
+            methodBuilder("getServiceDefinition")
+                .addAnnotation(Override.class)
+                .addModifiers(PUBLIC)
+                .returns(IoGrpc.SERVER_SERVICE_DEFINITION)
+                .addParameter(IoGrpc.METADATA, "headers")
+                .addStatement(
+                    "return factory.grpcService(new $T(headers)).$N()",
+                    Dagger.GrpcServer.GRPC_CALL_METADATA_MODULE,
+                    grpcServiceModel.subcomponentServiceDefinitionMethodName())
+                .build())
+        .build();
+  }
+}
diff --git a/grpc/src/main/java/dagger/grpc/server/processor/ServiceDefinitionTypeGenerator.java b/grpc/src/main/java/dagger/grpc/server/processor/ServiceDefinitionTypeGenerator.java
new file mode 100644
index 000000000..5d5ccbd98
--- /dev/null
+++ b/grpc/src/main/java/dagger/grpc/server/processor/ServiceDefinitionTypeGenerator.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server.processor;
+
+import static com.squareup.javapoet.MethodSpec.methodBuilder;
+import static com.squareup.javapoet.TypeSpec.interfaceBuilder;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+
+import com.squareup.javapoet.TypeSpec;
+import dagger.grpc.server.GrpcService;
+
+/**
+ * An object that generates the component supertype interface for a {@link GrpcService}-annotated
+ * service implementation.
+ */
+final class ServiceDefinitionTypeGenerator extends SourceGenerator {
+
+  private final GrpcServiceModel grpcServiceModel;
+
+  ServiceDefinitionTypeGenerator(GrpcServiceModel grpcServiceModel) {
+    super(grpcServiceModel.packageName());
+    this.grpcServiceModel = grpcServiceModel;
+  }
+
+  @Override
+  protected TypeSpec createType() {
+    TypeSpec.Builder type =
+        interfaceBuilder(grpcServiceModel.serviceDefinitionTypeName.simpleName())
+            .addJavadoc("A component must implement this interface.\n")
+            .addAnnotation(grpcServiceModel.generatedAnnotation())
+            .addModifiers(PUBLIC);
+    type.addType(
+        interfaceBuilder(grpcServiceModel.serviceDefinitionTypeFactoryName.simpleName())
+            .addModifiers(PUBLIC, STATIC)
+            .addMethod(
+                methodBuilder("grpcService")
+                    .addModifiers(PUBLIC, ABSTRACT)
+                    .returns(grpcServiceModel.serviceDefinitionTypeName)
+                    .addParameter(
+                        Dagger.GrpcServer.GRPC_CALL_METADATA_MODULE, "grpcCallMetadataModule")
+                    .build())
+            .build());
+    type.addMethod(
+        methodBuilder(grpcServiceModel.subcomponentServiceDefinitionMethodName())
+            .addModifiers(PUBLIC, ABSTRACT)
+            .returns(IoGrpc.SERVER_SERVICE_DEFINITION)
+            .addAnnotation(grpcServiceModel.forGrpcService())
+            .build());
+    return type.build();
+  }
+}
diff --git a/grpc/src/main/java/dagger/grpc/server/processor/SourceGenerator.java b/grpc/src/main/java/dagger/grpc/server/processor/SourceGenerator.java
new file mode 100644
index 000000000..806d6e6f1
--- /dev/null
+++ b/grpc/src/main/java/dagger/grpc/server/processor/SourceGenerator.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server.processor;
+
+import com.squareup.javapoet.AnnotationSpec;
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.JavaFile;
+import com.squareup.javapoet.TypeSpec;
+
+/**
+ * An object that generates one top-level type.
+ */
+abstract class SourceGenerator {
+
+  private final String packageName;
+
+  protected SourceGenerator(String packageName) {
+    this.packageName = packageName;
+  }
+
+  public JavaFile javaFile() {
+    return JavaFile.builder(packageName, createType()).build();
+  }
+
+  /**
+   * Creates the type to write.
+   */
+  protected abstract TypeSpec createType();
+
+  /** Class names and annotation specs for types in the {@link dagger} package. */
+  protected static final class Dagger {
+    private Dagger() {}
+
+    static AnnotationSpec binds() {
+      return AnnotationSpec.builder(ClassName.get("dagger", "Binds")).build();
+    }
+
+    static AnnotationSpec intoSet() {
+      return AnnotationSpec.builder(ClassName.get("dagger.multibindings", "IntoSet")).build();
+    }
+
+    static AnnotationSpec provides() {
+      return AnnotationSpec.builder(ClassName.get("dagger", "Provides")).build();
+    }
+
+    /** A {@code @dagger.Module} annotation that includes the given module classes. */
+    static AnnotationSpec module(ClassName... includedModules) {
+      AnnotationSpec.Builder module = AnnotationSpec.builder(ClassName.get("dagger", "Module"));
+      for (ClassName includedModule : includedModules) {
+        module.addMember("includes", "$T.class", includedModule);
+      }
+      return module.build();
+    }
+
+    /** Class names and annotation specs for types in the {@link dagger.grpc} package. */
+    protected static final class GrpcServer {
+      private GrpcServer() {}
+
+      static final ClassName PROXY_SERVER_CALL_HANDLER =
+          ClassName.get("dagger.grpc.server", "ProxyServerCallHandler");
+
+      static final ClassName GRPC_CALL_METADATA_MODULE =
+          ClassName.get("dagger.grpc.server", "GrpcCallMetadataModule");
+
+      static final ClassName SERVICE_DEFINITION_FACTORY =
+          PROXY_SERVER_CALL_HANDLER.nestedClass("ServiceDefinitionFactory");
+    }
+  }
+
+  /** Class names and annotation specs for types in the {@link io.grpc} package. */
+  protected static final class IoGrpc {
+    private IoGrpc() {}
+
+    static final ClassName BINDABLE_SERVICE = ClassName.get("io.grpc", "BindableService");
+    static final ClassName METADATA = ClassName.get("io.grpc", "Metadata");
+    static final ClassName METHOD_DESCRIPTOR = ClassName.get("io.grpc", "MethodDescriptor");
+    static final ClassName SERVER_INTERCEPTOR =
+        ClassName.get("io.grpc", "ServerInterceptor");
+    static final ClassName SERVER_INTERCEPTORS =
+        ClassName.get("io.grpc", "ServerInterceptors");
+    static final ClassName SERVER_SERVICE_DEFINITION =
+        ClassName.get("io.grpc", "ServerServiceDefinition");
+  }
+
+  /** Class names and annotation specs for types in the {@link javax.inject} package. */
+  protected static final class JavaxInject {
+    private JavaxInject() {}
+
+    static AnnotationSpec inject() {
+      return AnnotationSpec.builder(ClassName.get("javax.inject", "Inject")).build();
+    }
+
+    static AnnotationSpec singleton() {
+      return AnnotationSpec.builder(ClassName.get("javax.inject", "Singleton")).build();
+    }
+  }
+}
diff --git a/grpc/src/main/java/dagger/grpc/server/processor/UnscopedGrpcServiceModuleGenerator.java b/grpc/src/main/java/dagger/grpc/server/processor/UnscopedGrpcServiceModuleGenerator.java
new file mode 100644
index 000000000..12f93e459
--- /dev/null
+++ b/grpc/src/main/java/dagger/grpc/server/processor/UnscopedGrpcServiceModuleGenerator.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.server.processor;
+
+import static com.google.common.base.CaseFormat.LOWER_CAMEL;
+import static com.google.common.base.CaseFormat.UPPER_CAMEL;
+import static com.squareup.javapoet.MethodSpec.constructorBuilder;
+import static com.squareup.javapoet.TypeSpec.classBuilder;
+import static javax.lang.model.element.Modifier.ABSTRACT;
+import static javax.lang.model.element.Modifier.FINAL;
+import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PUBLIC;
+import static javax.lang.model.element.Modifier.STATIC;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.TypeSpec;
+import dagger.grpc.server.GrpcService;
+
+/**
+ * An object that generates the unscoped-proxying service definition module for a {@link
+ * GrpcService}-annotated service implementation.
+ */
+final class UnscopedGrpcServiceModuleGenerator extends SourceGenerator {
+
+  private final GrpcServiceModel grpcServiceModel;
+
+  UnscopedGrpcServiceModuleGenerator(GrpcServiceModel grpcServiceModel) {
+    super(grpcServiceModel.packageName());
+    this.grpcServiceModel = grpcServiceModel;
+  }
+
+  @Override
+  protected TypeSpec createType() {
+    ClassName unscopedComponentFactory =
+        grpcServiceModel.unscopedServiceModuleName.nestedClass(
+            grpcServiceModel.serviceImplementationClassName.simpleName() + "ComponentFactory");
+    return classBuilder(grpcServiceModel.unscopedServiceModuleName)
+        .addJavadoc(
+            "Install this module in the {@link $T @Singleton} server component\n",
+            JavaxInject.singleton().type)
+        .addJavadoc("if it implements {@link $T}.\n", grpcServiceModel.serviceDefinitionTypeName)
+        .addAnnotation(grpcServiceModel.generatedAnnotation())
+        .addAnnotation(
+            Dagger.module(grpcServiceModel.proxyModuleName, grpcServiceModel.serviceModuleName))
+        .addModifiers(PUBLIC, ABSTRACT)
+        .addType(unscopedComponentFactory(unscopedComponentFactory.simpleName()))
+        .addMethod(bindSubcomponentFactory(unscopedComponentFactory))
+        .addMethod(constructorBuilder().addModifiers(PRIVATE).build())
+        .build();
+  }
+  
+  /**
+   * Returns the class that implements the component factory type by returning the singleton
+   * component itself.
+   */
+  private TypeSpec unscopedComponentFactory(String simpleName) {
+    return TypeSpec.classBuilder(simpleName)
+        .addModifiers(STATIC, FINAL)
+        .addSuperinterface(grpcServiceModel.serviceDefinitionTypeFactoryName)
+        .addField(grpcServiceModel.serviceDefinitionTypeName, "component", PRIVATE, FINAL)
+        .addMethod(
+            MethodSpec.constructorBuilder()
+                .addAnnotation(JavaxInject.inject())
+                .addParameter(grpcServiceModel.serviceDefinitionTypeName, "component")
+                .addStatement("this.component = component")
+                .build())
+        .addMethod(
+            MethodSpec.methodBuilder("grpcService")
+                .addAnnotation(Override.class)
+                .addModifiers(PUBLIC)
+                .returns(grpcServiceModel.serviceDefinitionTypeName)
+                .addParameter(Dagger.GrpcServer.GRPC_CALL_METADATA_MODULE, "grpcCallMetadataModule")
+                .addStatement("return component")
+                .build())
+        .build();
+  }
+
+  /**
+   * Returns the {@link dagger.Binds @Binds} method that binds the component factory type to the
+   * {@linkplain #unscopedComponentFactory(String) unscoped component factory implementation class}.
+   */
+  private MethodSpec bindSubcomponentFactory(ClassName unscopedComponentFactory) {
+    return MethodSpec.methodBuilder(
+            UPPER_CAMEL.to(
+                LOWER_CAMEL, grpcServiceModel.serviceDefinitionTypeFactoryName.simpleName()))
+        .addAnnotation(Dagger.binds())
+        .addModifiers(ABSTRACT)
+        .returns(grpcServiceModel.serviceDefinitionTypeFactoryName)
+        .addParameter(unscopedComponentFactory, "factory")
+        .build();
+  }
+}
diff --git a/gwt/BUILD b/gwt/BUILD
new file mode 100644
index 000000000..b348e06b3
--- /dev/null
+++ b/gwt/BUILD
@@ -0,0 +1,24 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   GWT-specific files for Dagger
+
+package(default_visibility = ["//:src"])
+
+java_library(
+    name = "gwt",
+    resource_strip_prefix = "gwt/",
+    resources = glob(["**/*.gwt.xml"]),
+)
diff --git a/gwt/src/main/resources/dagger/Dagger.gwt.xml b/gwt/dagger/Dagger.gwt.xml
similarity index 100%
rename from gwt/src/main/resources/dagger/Dagger.gwt.xml
rename to gwt/dagger/Dagger.gwt.xml
diff --git a/gwt/src/main/resources/javax/inject/Inject.gwt.xml b/gwt/javax/inject/Inject.gwt.xml
similarity index 100%
rename from gwt/src/main/resources/javax/inject/Inject.gwt.xml
rename to gwt/javax/inject/Inject.gwt.xml
diff --git a/javatests/dagger/BUILD b/javatests/dagger/BUILD
new file mode 100644
index 000000000..ae7aeb021
--- /dev/null
+++ b/javatests/dagger/BUILD
@@ -0,0 +1,34 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   A JSR-330 compliant dependency injection system for android and java
+
+package(default_visibility = ["//:src"])
+
+load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX", "DOCLINT_REFERENCES")
+load("//:test_defs.bzl", "GenJavaTests")
+
+GenJavaTests(
+    name = "core_tests",
+    srcs = glob(["**/*.java"]),
+    javacopts = DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
+    deps = [
+        "//java/dagger:core",
+        "//third_party:guava",
+        "//third_party:jsr330_inject",
+        "//third_party:junit",
+        "//third_party:truth",
+    ],
+)
diff --git a/javatests/dagger/android/AndroidInjectionTest.java b/javatests/dagger/android/AndroidInjectionTest.java
new file mode 100644
index 000000000..ec5be117b
--- /dev/null
+++ b/javatests/dagger/android/AndroidInjectionTest.java
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import android.app.Activity;
+import android.app.Application;
+import android.app.Fragment;
+import org.robolectric.RobolectricTestRunner;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+import org.robolectric.util.FragmentTestUtil;
+
+@Config(manifest = Config.NONE)
+@RunWith(RobolectricTestRunner.class)
+public final class AndroidInjectionTest {
+
+  // Most positive tests are performed in javatests/dagger/android/support/functional, but
+  // Robolectric's support for framework fragments is lacking, so we supplement those tests here:
+  public static class InjectableFragment extends Fragment {
+    String tag;
+  }
+
+  private static AndroidInjector<Fragment> fakeFragmentInjector(String tag) {
+    return instance -> {
+      if (instance instanceof InjectableFragment) {
+        ((InjectableFragment) instance).tag = tag;
+      }
+    };
+  }
+
+  public static class ApplicationInjectsFragment extends Application
+      implements HasFragmentInjector {
+    @Override
+    public AndroidInjector<Fragment> fragmentInjector() {
+      return fakeFragmentInjector("injected by app");
+    }
+  }
+
+  @Config(manifest = Config.NONE, application = ApplicationInjectsFragment.class)
+  @Test
+  public void fragmentInjectedByApplication() {
+    Activity activity = Robolectric.setupActivity(Activity.class);
+    InjectableFragment fragment = new InjectableFragment();
+    activity.getFragmentManager().beginTransaction().add(fragment, "tag").commit();
+
+    AndroidInjection.inject(fragment);
+
+    assertThat(fragment.tag).isEqualTo("injected by app");
+  }
+
+  public static class ActivityInjectsFragment extends Activity implements HasFragmentInjector {
+    @Override
+    public AndroidInjector<Fragment> fragmentInjector() {
+      return fakeFragmentInjector("injected by activity");
+    }
+  }
+
+  @Config(manifest = Config.NONE, application = ApplicationInjectsFragment.class)
+  @Test
+  public void fragmentInjectedByActivity() {
+    ActivityInjectsFragment activity = Robolectric.setupActivity(ActivityInjectsFragment.class);
+    InjectableFragment fragment = new InjectableFragment();
+    activity.getFragmentManager().beginTransaction().add(fragment, "tag").commit();
+
+    AndroidInjection.inject(fragment);
+
+    assertThat(fragment.tag).isEqualTo("injected by activity");
+  }
+
+  public static class ParentFragmentInjectsChildFragment extends Fragment
+      implements HasFragmentInjector {
+    @Override
+    public AndroidInjector<Fragment> fragmentInjector() {
+      return fakeFragmentInjector("injected by parent fragment");
+    }
+  }
+
+  @Config(manifest = Config.NONE, application = ApplicationInjectsFragment.class)
+  @Test
+  public void fragmentInjectedByParentFragment() {
+    ActivityInjectsFragment activity = Robolectric.setupActivity(ActivityInjectsFragment.class);
+    ParentFragmentInjectsChildFragment parentFragment = new ParentFragmentInjectsChildFragment();
+    InjectableFragment childFragment = new InjectableFragment();
+
+    activity.getFragmentManager().beginTransaction().add(parentFragment, "tag").commit();
+    parentFragment
+        .getChildFragmentManager()
+        .beginTransaction()
+        .add(childFragment, "child-tag")
+        .commit();
+    AndroidInjection.inject(childFragment);
+
+    assertThat(childFragment.tag).isEqualTo("injected by parent fragment");
+  }
+
+  @Test
+  public void injectActivity_applicationDoesntImplementHasActivityInjector() {
+    Activity activity = Robolectric.setupActivity(Activity.class);
+
+    try {
+      AndroidInjection.inject(activity);
+      fail();
+    } catch (Exception e) {
+      assertThat(e)
+          .hasMessageThat()
+          .contains("Application does not implement dagger.android.HasActivityInjector");
+    }
+  }
+
+  @Test
+  public void injectFragment_hasFragmentInjectorNotFound() {
+    Fragment fragment = new Fragment();
+    FragmentTestUtil.startFragment(fragment);
+
+    try {
+      AndroidInjection.inject(fragment);
+      fail();
+    } catch (Exception e) {
+      assertThat(e).hasMessageThat().contains("No injector was found");
+    }
+  }
+
+  private static class ApplicationReturnsNull extends Application
+      implements HasActivityInjector, HasFragmentInjector {
+    @Override
+    public AndroidInjector<Activity> activityInjector() {
+      return null;
+    }
+
+    @Override
+    public AndroidInjector<Fragment> fragmentInjector() {
+      return null;
+    }
+  }
+
+  @Test
+  @Config(manifest = Config.NONE, application = ApplicationReturnsNull.class)
+  public void activityInjector_returnsNull() {
+    Activity activity = Robolectric.setupActivity(Activity.class);
+
+    try {
+      AndroidInjection.inject(activity);
+      fail();
+    } catch (Exception e) {
+      assertThat(e).hasMessageThat().contains("activityInjector() returned null");
+    }
+  }
+
+  @Test
+  @Config(manifest = Config.NONE, application = ApplicationReturnsNull.class)
+  public void fragmentInjector_returnsNull() {
+    Fragment fragment = new Fragment();
+    FragmentTestUtil.startFragment(fragment);
+
+    try {
+      AndroidInjection.inject(fragment);
+      fail();
+    } catch (Exception e) {
+      assertThat(e).hasMessageThat().contains("fragmentInjector() returned null");
+    }
+  }
+
+  @Test
+  public void injectActivity_nullInput() {
+    try {
+      AndroidInjection.inject((Activity) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessageThat().contains("activity");
+    }
+  }
+
+  @Test
+  public void injectFragment_nullInput() {
+    try {
+      AndroidInjection.inject((Fragment) null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessageThat().contains("fragment");
+    }
+  }
+}
diff --git a/javatests/dagger/android/BUILD b/javatests/dagger/android/BUILD
new file mode 100644
index 000000000..cf47d8be9
--- /dev/null
+++ b/javatests/dagger/android/BUILD
@@ -0,0 +1,34 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Description:
+#   Tests for Dagger's Android integrations
+
+package(default_visibility = ["//:src"])
+
+load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX")
+load("//:test_defs.bzl", "GenRobolectricTests")
+
+GenRobolectricTests(
+    name = "android_tests",
+    srcs = glob(["*.java"]),
+    javacopts = DOCLINT_HTML_AND_SYNTAX,
+    deps = [
+        "//:dagger_with_compiler",
+        "//java/dagger/android",
+        "//third_party:guava",
+        "//third_party:junit",
+        "//third_party:truth",
+    ],
+)
diff --git a/javatests/dagger/android/DispatchingAndroidInjectorTest.java b/javatests/dagger/android/DispatchingAndroidInjectorTest.java
new file mode 100644
index 000000000..2d1e6132c
--- /dev/null
+++ b/javatests/dagger/android/DispatchingAndroidInjectorTest.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import android.app.Activity;
+import org.robolectric.RobolectricTestRunner;
+import dagger.android.DispatchingAndroidInjector.InvalidInjectorBindingException;
+import java.util.HashMap;
+import java.util.Map;
+import javax.inject.Provider;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.annotation.Config;
+
+@Config(manifest = Config.NONE)
+@RunWith(RobolectricTestRunner.class)
+public final class DispatchingAndroidInjectorTest {
+  private DispatchingAndroidInjector<Activity> dispatchingAndroidInjector;
+
+  @Before
+  public void setup() {
+    Map<Class<? extends Activity>, Provider<AndroidInjector.Factory<? extends Activity>>>
+        injectorFactories = new HashMap<>();
+    injectorFactories.put(FooActivity.class, FooInjector.Factory::new);
+    injectorFactories.put(ReturnsNullActivity.class, () -> null);
+    injectorFactories.put(WrongActivity.class, FooInjector.Factory::new);
+    dispatchingAndroidInjector = new DispatchingAndroidInjector<>(injectorFactories);
+  }
+
+  @Test
+  public void maybeInject_returnsTrue_ifMatchingInjectorExists() {
+    FooActivity fooActivity = Robolectric.setupActivity(FooActivity.class);
+    assertThat(dispatchingAndroidInjector.maybeInject(fooActivity)).isTrue();
+  }
+
+  @Test
+  public void maybeInject_returnsFalse_ifNoMatchingInjectorExists() {
+    BarActivity barActivity = Robolectric.setupActivity(BarActivity.class);
+    assertThat(dispatchingAndroidInjector.maybeInject(barActivity)).isFalse();
+  }
+
+  @Test
+  public void throwsIfFactoryCreateReturnsNull() {
+    ReturnsNullActivity returnsNullActivity = Robolectric.setupActivity(ReturnsNullActivity.class);
+
+    try {
+      dispatchingAndroidInjector.maybeInject(returnsNullActivity);
+      fail("Expected NullPointerException");
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test
+  public void throwsIfClassMismatched() {
+    WrongActivity wrongActivity = Robolectric.setupActivity(WrongActivity.class);
+
+    try {
+      dispatchingAndroidInjector.maybeInject(wrongActivity);
+      fail("Expected InvalidInjectorBindingException");
+    } catch (InvalidInjectorBindingException expected) {
+    }
+  }
+
+  static class FooActivity extends Activity {}
+
+  static class BarActivity extends Activity {}
+
+  static class ReturnsNullActivity extends Activity {}
+
+  static class WrongActivity extends Activity {}
+
+  static class FooInjector implements AndroidInjector<FooActivity> {
+    @Override
+    public void inject(FooActivity instance) {}
+
+    static class Factory implements AndroidInjector.Factory<FooActivity> {
+      @Override
+      public AndroidInjector<FooActivity> create(FooActivity activity) {
+        return new FooInjector();
+      }
+    }
+  }
+}
diff --git a/javatests/dagger/android/functional/AndroidMemorySensitiveReferenceManagerTest.java b/javatests/dagger/android/functional/AndroidMemorySensitiveReferenceManagerTest.java
new file mode 100644
index 000000000..076de40fc
--- /dev/null
+++ b/javatests/dagger/android/functional/AndroidMemorySensitiveReferenceManagerTest.java
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.functional;
+
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
+import static com.google.common.truth.Truth.assertThat;
+import static dagger.android.functional.AndroidMemorySensitiveReferenceManagerTest.AllWeakReferencesCleared.allWeakReferencesCleared;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.testing.GcFinalization;
+import com.google.common.testing.GcFinalization.FinalizationPredicate;
+import org.robolectric.RobolectricTestRunner;
+import java.lang.ref.WeakReference;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/** Functional tests of {@link dagger.android.AndroidMemorySensitiveReferenceManager}. */
+@RunWith(RobolectricTestRunner.class)
+public final class AndroidMemorySensitiveReferenceManagerTest {
+
+  private TestModule testModule;
+  private TestComponent component;
+
+  @Before
+  public void setUp() {
+    testModule = new TestModule();
+    component = DaggerTestComponent.builder().testModule(testModule).build();
+  }
+
+  @Test
+  public void scoped() {
+    assertThat(component.releasedWhenUiHidden()).isSameAs(component.releasedWhenUiHidden());
+    assertThat(component.releasedWhenModerate()).isSameAs(component.releasedWhenModerate());
+    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(1);
+    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
+  }
+
+  @Test
+  public void onTrimMemory_aboveThresholds() {
+    component.releasedWhenUiHidden();
+    component.releasedWhenModerate();
+
+    component.manager().onTrimMemory(TRIM_MEMORY_COMPLETE);
+    GcFinalization.awaitDone(
+        allWeakReferencesCleared(
+            component.releasedWhenUiHidden(), component.releasedWhenModerate()));
+
+    assertThat(component.releasedWhenUiHidden()).isSameAs(component.releasedWhenUiHidden());
+    assertThat(component.releasedWhenModerate()).isSameAs(component.releasedWhenModerate());
+    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(2);
+    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(2);
+  }
+
+  @Test
+  public void onTrimMemory_atOneThresholdBelowAnother() {
+    component.releasedWhenUiHidden();
+    component.releasedWhenModerate();
+
+    component.manager().onTrimMemory(TRIM_MEMORY_UI_HIDDEN);
+    GcFinalization.awaitDone(allWeakReferencesCleared(component.releasedWhenUiHidden()));
+
+    assertThat(component.releasedWhenUiHidden()).isSameAs(component.releasedWhenUiHidden());
+    assertThat(component.releasedWhenModerate()).isSameAs(component.releasedWhenModerate());
+    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(2);
+    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
+  }
+
+  @Test
+  public void onTrimMemory_belowThresholds() {
+    component.releasedWhenUiHidden();
+    component.releasedWhenModerate();
+    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(1);
+    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
+
+    component.manager().onTrimMemory(TRIM_MEMORY_RUNNING_MODERATE);
+    GcFinalization.awaitDone(allWeakReferencesCleared(new Object()));
+
+    assertThat(component.releasedWhenUiHidden()).isSameAs(component.releasedWhenUiHidden());
+    assertThat(component.releasedWhenModerate()).isSameAs(component.releasedWhenModerate());
+    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(1);
+    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
+  }
+
+  @Test
+  public void onTrimMemory_restore() {
+    component.releasedWhenUiHidden();
+    component.releasedWhenModerate();
+    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(1);
+    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
+
+    component.manager().onTrimMemory(TRIM_MEMORY_UI_HIDDEN);
+    component.manager().onTrimMemory(TRIM_MEMORY_RUNNING_MODERATE);
+    GcFinalization.awaitDone(allWeakReferencesCleared(new Object()));
+
+    assertThat(component.releasedWhenUiHidden()).isSameAs(component.releasedWhenUiHidden());
+    assertThat(component.releasedWhenModerate()).isSameAs(component.releasedWhenModerate());
+    assertThat(testModule.releasedWhenUiHiddenCalls).isEqualTo(1);
+    assertThat(testModule.releasedWhenModerateCalls).isEqualTo(1);
+  }
+
+  static final class AllWeakReferencesCleared implements FinalizationPredicate {
+
+    private final ImmutableList<WeakReference<Object>> references;
+
+    AllWeakReferencesCleared(ImmutableList<WeakReference<Object>> references) {
+      this.references = references;
+    }
+
+    @Override
+    public boolean isDone() {
+      for (WeakReference<Object> reference : references) {
+        if (reference.get() != null) {
+          return false;
+        }
+      }
+      return true;
+    }
+
+    static AllWeakReferencesCleared allWeakReferencesCleared(Object... objects) {
+      ImmutableList.Builder<WeakReference<Object>> referencesBuilder = ImmutableList.builder();
+      for (Object object : objects) {
+        referencesBuilder.add(new WeakReference<>(object));
+      }
+      return new AllWeakReferencesCleared(referencesBuilder.build());
+    }
+  }
+}
diff --git a/javatests/dagger/android/functional/BUILD b/javatests/dagger/android/functional/BUILD
new file mode 100644
index 000000000..cfe46e194
--- /dev/null
+++ b/javatests/dagger/android/functional/BUILD
@@ -0,0 +1,53 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   Functional test code for Dagger-Android
+
+package(default_visibility = ["//:src"])
+
+load(
+    "//:build_defs.bzl",
+    "DOCLINT_HTML_AND_SYNTAX",
+)
+load("//:test_defs.bzl", "GenRobolectricTests")
+
+# Sample code to be tested in functional tests.
+android_library(
+    name = "code_under_test",
+    srcs = glob(
+        ["*.java"],
+        exclude = ["*Test.java"],
+    ),
+    javacopts = DOCLINT_HTML_AND_SYNTAX,
+    deps = [
+        # NOTE: This should not depend on Guava or jsr305 to ensure that Dagger can be
+        # used without a Guava and jsr305 deps.
+        "//:dagger_with_compiler",
+        "//:android",
+    ],
+)
+
+GenRobolectricTests(
+    name = "android_functional_tests",
+    srcs = glob(["*Test.java"]),
+    javacopts = DOCLINT_HTML_AND_SYNTAX,
+    deps = [
+        ":code_under_test",
+        "//third_party:guava",
+        "//third_party:guava_testlib",
+        "//third_party:junit",
+        "//third_party:truth",
+    ],
+)
diff --git a/javatests/dagger/android/functional/InScope.java b/javatests/dagger/android/functional/InScope.java
new file mode 100644
index 000000000..295ee069c
--- /dev/null
+++ b/javatests/dagger/android/functional/InScope.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.functional;
+
+import java.lang.annotation.Annotation;
+import javax.inject.Qualifier;
+
+@Qualifier
+@interface InScope {
+  Class<? extends Annotation> value();
+}
diff --git a/javatests/dagger/android/functional/ReleaseWhenModerate.java b/javatests/dagger/android/functional/ReleaseWhenModerate.java
new file mode 100644
index 000000000..c8971b42d
--- /dev/null
+++ b/javatests/dagger/android/functional/ReleaseWhenModerate.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.functional;
+
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_MODERATE;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import dagger.android.ReleaseReferencesAt;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import javax.inject.Scope;
+
+@Documented
+@Retention(RUNTIME)
+@Target({TYPE, METHOD})
+@ReleaseReferencesAt(TRIM_MEMORY_MODERATE)
+@Scope
+@interface ReleaseWhenModerate {}
diff --git a/javatests/dagger/android/functional/ReleaseWhenUiHidden.java b/javatests/dagger/android/functional/ReleaseWhenUiHidden.java
new file mode 100644
index 000000000..ca22db44a
--- /dev/null
+++ b/javatests/dagger/android/functional/ReleaseWhenUiHidden.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.functional;
+
+import static android.content.ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
+import static java.lang.annotation.ElementType.METHOD;
+import static java.lang.annotation.ElementType.TYPE;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import dagger.android.ReleaseReferencesAt;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+import javax.inject.Scope;
+
+@Documented
+@Retention(RUNTIME)
+@Target({TYPE, METHOD})
+@ReleaseReferencesAt(TRIM_MEMORY_UI_HIDDEN)
+@Scope
+@interface ReleaseWhenUiHidden {}
diff --git a/javatests/dagger/android/functional/TestComponent.java b/javatests/dagger/android/functional/TestComponent.java
new file mode 100644
index 000000000..03d40755b
--- /dev/null
+++ b/javatests/dagger/android/functional/TestComponent.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.functional;
+
+import dagger.Component;
+import dagger.android.AndroidMemorySensitiveReferenceManager;
+import javax.inject.Singleton;
+
+@Singleton
+@ReleaseWhenUiHidden
+@ReleaseWhenModerate
+@Component(modules = TestModule.class)
+interface TestComponent {
+  AndroidMemorySensitiveReferenceManager manager();
+
+  @InScope(ReleaseWhenUiHidden.class)
+  Object releasedWhenUiHidden();
+
+  @InScope(ReleaseWhenModerate.class)
+  Object releasedWhenModerate();
+}
diff --git a/javatests/dagger/android/functional/TestModule.java b/javatests/dagger/android/functional/TestModule.java
new file mode 100644
index 000000000..dd3adaa0b
--- /dev/null
+++ b/javatests/dagger/android/functional/TestModule.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.functional;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class TestModule {
+  int releasedWhenUiHiddenCalls;
+  int releasedWhenModerateCalls;
+
+  @Provides
+  @ReleaseWhenUiHidden
+  @InScope(ReleaseWhenUiHidden.class)
+  Object releasedWhenUiHidden() {
+    ++releasedWhenUiHiddenCalls;
+    return new Object();
+  }
+
+  @Provides
+  @ReleaseWhenModerate
+  @InScope(ReleaseWhenModerate.class)
+  Object releasedWhenModerate() {
+    ++releasedWhenModerateCalls;
+    return new Object();
+  }
+}
diff --git a/javatests/dagger/android/support/AndroidSupportInjectionTest.java b/javatests/dagger/android/support/AndroidSupportInjectionTest.java
new file mode 100644
index 000000000..243bc38de
--- /dev/null
+++ b/javatests/dagger/android/support/AndroidSupportInjectionTest.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import android.app.Application;
+import android.support.v4.app.Fragment;
+import org.robolectric.RobolectricTestRunner;
+import dagger.android.AndroidInjector;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.support.v4.SupportFragmentTestUtil;
+
+@Config(manifest = Config.NONE)
+@RunWith(RobolectricTestRunner.class)
+public final class AndroidSupportInjectionTest {
+  @Test
+  public void injectFragment_simpleApplication() {
+    Fragment fragment = new Fragment();
+    SupportFragmentTestUtil.startFragment(fragment);
+
+    try {
+      AndroidSupportInjection.inject(fragment);
+      fail();
+    } catch (Exception e) {
+      assertThat(e).hasMessageThat().contains("No injector was found");
+    }
+  }
+
+  private static class ApplicationReturnsNull extends Application
+      implements HasSupportFragmentInjector {
+    @Override
+    public AndroidInjector<Fragment> supportFragmentInjector() {
+      return null;
+    }
+  }
+
+  @Test
+  @Config(manifest = Config.NONE, application = ApplicationReturnsNull.class)
+  public void fragmentInjector_returnsNull() {
+    Fragment fragment = new Fragment();
+    SupportFragmentTestUtil.startFragment(fragment);
+
+    try {
+      AndroidSupportInjection.inject(fragment);
+      fail();
+    } catch (Exception e) {
+      assertThat(e).hasMessageThat().contains("supportFragmentInjector() returned null");
+    }
+  }
+
+  @Test
+  public void injectFragment_nullInput() {
+    try {
+      AndroidSupportInjection.inject(null);
+      fail();
+    } catch (NullPointerException e) {
+      assertThat(e).hasMessageThat().contains("fragment");
+    }
+  }
+}
diff --git a/javatests/dagger/android/support/BUILD b/javatests/dagger/android/support/BUILD
new file mode 100644
index 000000000..c194709bf
--- /dev/null
+++ b/javatests/dagger/android/support/BUILD
@@ -0,0 +1,37 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Description:
+#   Tests for Dagger's Android and Support library integrations
+
+package(default_visibility = ["//:src"])
+
+load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX")
+load("//:test_defs.bzl", "GenRobolectricTests")
+
+GenRobolectricTests(
+    name = "android-support-tests",
+    srcs = glob(["*.java"]),
+    javacopts = DOCLINT_HTML_AND_SYNTAX,
+    deps = [
+        "//:dagger_with_compiler",
+        "//java/dagger/android",
+        "//java/dagger/android/support",
+        "//third_party:guava",
+        "//third_party:junit",
+        "//third_party:truth",
+        "@androidsdk//com.android.support:appcompat-v7-25.0.0",
+        "@androidsdk//com.android.support:support-v4-25.0.0",
+    ],
+)
diff --git a/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java b/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
new file mode 100644
index 000000000..f3779bf0c
--- /dev/null
+++ b/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
@@ -0,0 +1,222 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import android.app.Activity;
+import android.app.Service;
+import android.content.BroadcastReceiver;
+import android.content.ContentProvider;
+import android.support.v4.app.Fragment;
+import dagger.Binds;
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.android.ActivityKey;
+import dagger.android.AndroidInjector;
+import dagger.android.BroadcastReceiverKey;
+import dagger.android.ContentProviderKey;
+import dagger.android.ServiceKey;
+import dagger.android.support.AndroidSupportInjectionModule;
+import dagger.android.support.DaggerApplication;
+import dagger.android.support.FragmentKey;
+import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.BroadcastReceiverSubcomponent.BroadcastReceiverModule;
+import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.ContentProviderSubcomponent.ContentProviderModule;
+import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.IntentServiceSubcomponent.IntentServiceModule;
+import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.ServiceSubcomponent.ServiceModule;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+
+public final class AllControllersAreDirectChildrenOfApplication extends DaggerApplication {
+
+  @Override
+  protected AndroidInjector<AllControllersAreDirectChildrenOfApplication> applicationInjector() {
+    return DaggerAllControllersAreDirectChildrenOfApplication_ApplicationComponent.create();
+  }
+
+  @Component(
+    modules = {ApplicationComponent.ApplicationModule.class, AndroidSupportInjectionModule.class}
+  )
+  interface ApplicationComponent
+      extends AndroidInjector<AllControllersAreDirectChildrenOfApplication> {
+    @Module(
+      subcomponents = {
+        ActivitySubcomponent.class,
+        ParentFragmentSubcomponent.class,
+        ChildFragmentSubcomponent.class,
+        ServiceSubcomponent.class,
+        IntentServiceSubcomponent.class,
+        BroadcastReceiverSubcomponent.class,
+        ContentProviderSubcomponent.class
+      }
+    )
+    abstract class ApplicationModule {
+      @Provides
+      @IntoSet
+      static Class<?> addToComponentHierarchy() {
+        return ApplicationComponent.class;
+      }
+
+      @Binds
+      @IntoMap
+      @ActivityKey(TestActivity.class)
+      abstract AndroidInjector.Factory<? extends Activity> bindFactoryForTestActivity(
+          ActivitySubcomponent.Builder builder);
+
+      @Binds
+      @IntoMap
+      @FragmentKey(TestParentFragment.class)
+      abstract AndroidInjector.Factory<? extends Fragment> bindFactoryForParentFragment(
+          ParentFragmentSubcomponent.Builder builder);
+
+      @Binds
+      @IntoMap
+      @FragmentKey(TestChildFragment.class)
+      abstract AndroidInjector.Factory<? extends Fragment> bindFactoryForChildFragment(
+          ChildFragmentSubcomponent.Builder builder);
+
+      @Binds
+      @IntoMap
+      @ServiceKey(TestService.class)
+      abstract AndroidInjector.Factory<? extends Service> bindFactoryForService(
+          ServiceSubcomponent.Builder builder);
+
+      @Binds
+      @IntoMap
+      @ServiceKey(TestIntentService.class)
+      abstract AndroidInjector.Factory<? extends Service> bindFactoryForIntentService(
+          IntentServiceSubcomponent.Builder builder);
+
+      @Binds
+      @IntoMap
+      @BroadcastReceiverKey(TestBroadcastReceiver.class)
+      abstract AndroidInjector.Factory<? extends BroadcastReceiver> bindFactoryForBroadcastReceiver(
+          BroadcastReceiverSubcomponent.Builder builder);
+
+      @Binds
+      @IntoMap
+      @ContentProviderKey(TestContentProvider.class)
+      abstract AndroidInjector.Factory<? extends ContentProvider> bindFactoryForContentProvider(
+          ContentProviderSubcomponent.Builder builder);
+    }
+
+    @Subcomponent(modules = ActivitySubcomponent.ActivityModule.class)
+    interface ActivitySubcomponent extends AndroidInjector<TestActivity> {
+      @Module
+      abstract class ActivityModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return ActivitySubcomponent.class;
+        }
+      }
+
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestActivity> {}
+    }
+
+    @Subcomponent(modules = ParentFragmentSubcomponent.ParentFragmentModule.class)
+    interface ParentFragmentSubcomponent extends AndroidInjector<TestParentFragment> {
+      @Module
+      abstract class ParentFragmentModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return ParentFragmentSubcomponent.class;
+        }
+      }
+
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestParentFragment> {}
+    }
+
+    @Subcomponent(modules = ChildFragmentSubcomponent.ChildFragmentModule.class)
+    interface ChildFragmentSubcomponent extends AndroidInjector<TestChildFragment> {
+      @Module
+      abstract class ChildFragmentModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return ChildFragmentSubcomponent.class;
+        }
+      }
+
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestChildFragment> {}
+    }
+
+    @Subcomponent(modules = ServiceModule.class)
+    interface ServiceSubcomponent extends AndroidInjector<TestService> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestService> {}
+
+      @Module
+      abstract class ServiceModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return ServiceSubcomponent.class;
+        }
+      }
+    }
+
+    @Subcomponent(modules = IntentServiceModule.class)
+    interface IntentServiceSubcomponent extends AndroidInjector<TestIntentService> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestIntentService> {}
+
+      @Module
+      abstract class IntentServiceModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return IntentServiceSubcomponent.class;
+        }
+      }
+    }
+
+    @Subcomponent(modules = BroadcastReceiverModule.class)
+    interface BroadcastReceiverSubcomponent extends AndroidInjector<TestBroadcastReceiver> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestBroadcastReceiver> {}
+
+      @Module
+      abstract class BroadcastReceiverModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return BroadcastReceiverSubcomponent.class;
+        }
+      }
+    }
+
+    @Subcomponent(modules = ContentProviderModule.class)
+    interface ContentProviderSubcomponent extends AndroidInjector<TestContentProvider> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestContentProvider> {}
+
+      @Module
+      abstract class ContentProviderModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return ContentProviderSubcomponent.class;
+        }
+      }
+    }
+  }
+}
diff --git a/javatests/dagger/android/support/functional/AndroidManifest.xml b/javatests/dagger/android/support/functional/AndroidManifest.xml
new file mode 100644
index 000000000..1ace8cb8f
--- /dev/null
+++ b/javatests/dagger/android/support/functional/AndroidManifest.xml
@@ -0,0 +1,24 @@
+<!--
+  ~ Copyright (C) 2017 The Dagger Authors.
+  ~
+  ~ Licensed under the Apache License, Version 2.0 (the "License");
+  ~ you may not use this file except in compliance with the License.
+  ~ You may obtain a copy of the License at
+  ~
+  ~ http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS,
+  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ See the License for the specific language governing permissions and
+  ~ limitations under the License.
+  -->
+<manifest xmlns:android="http://schemas.android.com/apk/res/android"
+  package="dagger.android.support.functional">
+
+  <application android:theme="@style/Theme.AppCompat">
+    <activity android:name="dagger.android.support.functional.ParentOfFragmentActivity"/>
+    <activity android:name="dagger.android.support.functional.SiblingOfFragmentActivity"/>
+    <activity android:name="dagger.android.support.functional.InjectedWithoutSubcomponentActivity"/>
+  </application>
+</manifest>
diff --git a/javatests/dagger/android/support/functional/BUILD b/javatests/dagger/android/support/functional/BUILD
new file mode 100644
index 000000000..4fe820383
--- /dev/null
+++ b/javatests/dagger/android/support/functional/BUILD
@@ -0,0 +1,52 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Description:
+#   Functional test code for Dagger-Android
+
+package(default_visibility = ["//:src"])
+
+android_library(
+    name = "functional",
+    srcs = glob(
+        ["*.java"],
+        exclude = ["*Test.java"],
+    ),
+    manifest = "AndroidManifest.xml",
+    resource_files = glob(["res/**"]),
+    deps = [
+        "//:android",
+        "//:android-support",
+        "//:dagger_with_compiler",
+        "//third_party:guava",
+        "@androidsdk//com.android.support:appcompat-v7-25.0.0",
+        "@androidsdk//com.android.support:support-v4-25.0.0",
+    ],
+)
+
+load("//:test_defs.bzl", "GenRobolectricTests")
+
+GenRobolectricTests(
+    name = "functional_tests",
+    srcs = glob(["*Test.java"]),
+    deps = [
+        ":functional",
+        "//:android",
+        "//:android-support",
+        "//:dagger_with_compiler",
+        "//third_party:junit",
+        "//third_party:truth",
+        "@androidsdk//com.android.support:support-v4-25.0.0",
+    ],
+)
diff --git a/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java b/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
new file mode 100644
index 000000000..6e60b4f92
--- /dev/null
+++ b/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
@@ -0,0 +1,222 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import android.app.Activity;
+import android.app.Service;
+import android.content.BroadcastReceiver;
+import android.content.ContentProvider;
+import android.support.v4.app.Fragment;
+import dagger.Binds;
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.android.ActivityKey;
+import dagger.android.AndroidInjector;
+import dagger.android.BroadcastReceiverKey;
+import dagger.android.ContentProviderKey;
+import dagger.android.ServiceKey;
+import dagger.android.support.AndroidSupportInjectionModule;
+import dagger.android.support.DaggerApplication;
+import dagger.android.support.FragmentKey;
+import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.BroadcastReceiverSubcomponent.BroadcastReceiverModule;
+import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.ContentProviderSubcomponent.ContentProviderModule;
+import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.IntentServiceSubcomponent.IntentServiceModule;
+import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.ServiceSubcomponent.ServiceModule;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+
+public final class ComponentStructureFollowsControllerStructureApplication
+    extends DaggerApplication {
+
+  @Override
+  protected AndroidInjector<? extends DaggerApplication> applicationInjector() {
+    return DaggerComponentStructureFollowsControllerStructureApplication_ApplicationComponent
+        .create();
+  }
+
+  @Component(
+    modules = {ApplicationComponent.ApplicationModule.class, AndroidSupportInjectionModule.class}
+  )
+  interface ApplicationComponent
+      extends AndroidInjector<ComponentStructureFollowsControllerStructureApplication> {
+    @Module(
+      subcomponents = {
+        ActivitySubcomponent.class,
+        ServiceSubcomponent.class,
+        IntentServiceSubcomponent.class,
+        BroadcastReceiverSubcomponent.class,
+        ContentProviderSubcomponent.class,
+      }
+    )
+    abstract class ApplicationModule {
+      @Provides
+      @IntoSet
+      static Class<?> addToComponentHierarchy() {
+        return ApplicationComponent.class;
+      }
+
+      @Binds
+      @IntoMap
+      @ActivityKey(TestActivity.class)
+      abstract AndroidInjector.Factory<? extends Activity> bindFactoryForTestActivity(
+          ActivitySubcomponent.Builder builder);
+
+      @Binds
+      @IntoMap
+      @ServiceKey(TestService.class)
+      abstract AndroidInjector.Factory<? extends Service> bindFactoryForService(
+          ServiceSubcomponent.Builder builder);
+
+      @Binds
+      @IntoMap
+      @ServiceKey(TestIntentService.class)
+      abstract AndroidInjector.Factory<? extends Service> bindFactoryForIntentService(
+          IntentServiceSubcomponent.Builder builder);
+
+      @Binds
+      @IntoMap
+      @BroadcastReceiverKey(TestBroadcastReceiver.class)
+      abstract AndroidInjector.Factory<? extends BroadcastReceiver> bindFactoryForBroadcastReceiver(
+          BroadcastReceiverSubcomponent.Builder builder);
+
+      @Binds
+      @IntoMap
+      @ContentProviderKey(TestContentProvider.class)
+      abstract AndroidInjector.Factory<? extends ContentProvider> bindFactoryForContentProvider(
+          ContentProviderSubcomponent.Builder builder);
+    }
+
+    @Subcomponent(modules = ActivitySubcomponent.ActivityModule.class)
+    interface ActivitySubcomponent extends AndroidInjector<TestActivity> {
+      @Module(subcomponents = ParentFragmentSubcomponent.class)
+      abstract class ActivityModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return ActivitySubcomponent.class;
+        }
+
+        @Binds
+        @IntoMap
+        @FragmentKey(TestParentFragment.class)
+        abstract AndroidInjector.Factory<? extends Fragment> bindFactoryForParentFragment(
+            ParentFragmentSubcomponent.Builder builder);
+      }
+
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestActivity> {}
+
+      @Subcomponent(modules = ParentFragmentSubcomponent.ParentFragmentModule.class)
+      interface ParentFragmentSubcomponent extends AndroidInjector<TestParentFragment> {
+        @Module(subcomponents = ChildFragmentSubcomponent.class)
+        abstract class ParentFragmentModule {
+          @Provides
+          @IntoSet
+          static Class<?> addToComponentHierarchy() {
+            return ParentFragmentSubcomponent.class;
+          }
+
+          @Binds
+          @IntoMap
+          @FragmentKey(TestChildFragment.class)
+          abstract AndroidInjector.Factory<? extends Fragment> bindFactoryForChildFragment(
+              ChildFragmentSubcomponent.Builder builder);
+        }
+
+        @Subcomponent.Builder
+        abstract class Builder extends AndroidInjector.Builder<TestParentFragment> {}
+
+        @Subcomponent(modules = ChildFragmentSubcomponent.ChildFragmentModule.class)
+        interface ChildFragmentSubcomponent extends AndroidInjector<TestChildFragment> {
+          @Module
+          abstract class ChildFragmentModule {
+            @Provides
+            @IntoSet
+            static Class<?> addToComponentHierarchy() {
+              return ChildFragmentSubcomponent.class;
+            }
+          }
+
+          @Subcomponent.Builder
+          abstract class Builder extends AndroidInjector.Builder<TestChildFragment> {}
+        }
+      }
+    }
+
+    @Subcomponent(modules = ServiceModule.class)
+    interface ServiceSubcomponent extends AndroidInjector<TestService> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestService> {}
+
+      @Module
+      abstract class ServiceModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return ServiceSubcomponent.class;
+        }
+      }
+    }
+
+    @Subcomponent(modules = IntentServiceModule.class)
+    interface IntentServiceSubcomponent extends AndroidInjector<TestIntentService> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestIntentService> {}
+
+      @Module
+      abstract class IntentServiceModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return IntentServiceSubcomponent.class;
+        }
+      }
+    }
+
+    @Subcomponent(modules = BroadcastReceiverModule.class)
+    interface BroadcastReceiverSubcomponent extends AndroidInjector<TestBroadcastReceiver> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestBroadcastReceiver> {}
+
+      @Module
+      abstract class BroadcastReceiverModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return BroadcastReceiverSubcomponent.class;
+        }
+      }
+    }
+
+    @Subcomponent(modules = ContentProviderModule.class)
+    interface ContentProviderSubcomponent extends AndroidInjector<TestContentProvider> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<TestContentProvider> {}
+
+      @Module
+      abstract class ContentProviderModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return ContentProviderSubcomponent.class;
+        }
+      }
+    }
+  }
+}
diff --git a/javatests/dagger/android/support/functional/InjectorsTest.java b/javatests/dagger/android/support/functional/InjectorsTest.java
new file mode 100644
index 000000000..578f19b10
--- /dev/null
+++ b/javatests/dagger/android/support/functional/InjectorsTest.java
@@ -0,0 +1,219 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import android.content.Intent;
+import android.content.res.Configuration;
+import org.robolectric.RobolectricTestRunner;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.Robolectric;
+import org.robolectric.RuntimeEnvironment;
+import org.robolectric.android.controller.ActivityController;
+import org.robolectric.annotation.Config;
+
+@RunWith(RobolectricTestRunner.class)
+public class InjectorsTest {
+  private static final String MANIFEST =
+      "//javatests/dagger/android/support/functional"
+          + ":functional/AndroidManifest.xml";
+
+  private ActivityController<TestActivity> activityController;
+  private TestActivity activity;
+  private TestParentFragment parentFragment;
+  private TestChildFragment childFragment;
+  private TestService service;
+  private TestIntentService intentService;
+  private TestBroadcastReceiver broadcastReceiver;
+  private TestContentProvider contentProvider;
+
+  @Before
+  public void setUp() {
+    activityController = Robolectric.buildActivity(TestActivity.class);
+    activity = activityController.setup().get();
+    parentFragment =
+        (TestParentFragment)
+            activity.getSupportFragmentManager().findFragmentByTag("parent-fragment");
+    childFragment =
+        (TestChildFragment)
+            parentFragment.getChildFragmentManager().findFragmentByTag("child-fragment");
+
+    service = Robolectric.buildService(TestService.class).create().get();
+    intentService = Robolectric.buildIntentService(TestIntentService.class).create().get();
+
+    broadcastReceiver = new TestBroadcastReceiver();
+    broadcastReceiver.onReceive(RuntimeEnvironment.application, new Intent());
+
+    contentProvider = Robolectric.setupContentProvider(TestContentProvider.class);
+  }
+
+  @Test
+  @Config(
+    manifest = MANIFEST,
+    application = ComponentStructureFollowsControllerStructureApplication.class
+  )
+  public void componentStructureFollowsControllerStructure() {
+    assertThat(activity.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ActivitySubcomponent.class);
+    assertThat(parentFragment.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ActivitySubcomponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ActivitySubcomponent.ParentFragmentSubcomponent.class);
+    assertThat(childFragment.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ActivitySubcomponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ActivitySubcomponent.ParentFragmentSubcomponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ActivitySubcomponent.ParentFragmentSubcomponent.ChildFragmentSubcomponent.class);
+
+    assertThat(service.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ServiceSubcomponent.class);
+    assertThat(intentService.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .IntentServiceSubcomponent.class);
+
+    assertThat(broadcastReceiver.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .BroadcastReceiverSubcomponent.class);
+
+    assertThat(contentProvider.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .ContentProviderSubcomponent.class);
+
+    changeConfiguration();
+  }
+
+  @Test
+  @Config(manifest = MANIFEST, application = AllControllersAreDirectChildrenOfApplication.class)
+  public void allControllersAreDirectChildrenOfApplication() {
+    assertThat(activity.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.ActivitySubcomponent
+                .class);
+    assertThat(parentFragment.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent
+                .ParentFragmentSubcomponent.class);
+    assertThat(childFragment.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent
+                .ChildFragmentSubcomponent.class);
+
+    assertThat(service.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.ServiceSubcomponent
+                .class);
+    assertThat(intentService.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent
+                .IntentServiceSubcomponent.class);
+
+    assertThat(broadcastReceiver.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent
+                .BroadcastReceiverSubcomponent.class);
+
+    assertThat(contentProvider.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent
+                .ContentProviderSubcomponent.class);
+
+    changeConfiguration();
+  }
+
+  @Test
+  @Config(manifest = MANIFEST, application = UsesGeneratedModulesApplication.class)
+  public void usesGeneratedModules() {
+    assertThat(activity.componentHierarchy)
+        .containsExactly(
+            UsesGeneratedModulesApplication.ApplicationComponent.class,
+            UsesGeneratedModulesApplication.DummyActivitySubcomponent.class);
+    assertThat(parentFragment.componentHierarchy)
+        .containsExactly(
+            UsesGeneratedModulesApplication.ApplicationComponent.class,
+            UsesGeneratedModulesApplication.DummyParentFragmentSubcomponent.class);
+    assertThat(childFragment.componentHierarchy)
+        .containsExactly(
+            UsesGeneratedModulesApplication.ApplicationComponent.class,
+            UsesGeneratedModulesApplication.DummyChildFragmentSubcomponent.class);
+
+    assertThat(service.componentHierarchy)
+        .containsExactly(
+            UsesGeneratedModulesApplication.ApplicationComponent.class,
+            UsesGeneratedModulesApplication.DummyServiceSubcomponent.class);
+    assertThat(intentService.componentHierarchy)
+        .containsExactly(
+            UsesGeneratedModulesApplication.ApplicationComponent.class,
+            UsesGeneratedModulesApplication.DummyIntentServiceSubcomponent.class);
+
+    assertThat(broadcastReceiver.componentHierarchy)
+        .containsExactly(
+            UsesGeneratedModulesApplication.ApplicationComponent.class,
+            UsesGeneratedModulesApplication.DummyBroadcastReceiverSubcomponent.class);
+
+    assertThat(contentProvider.componentHierarchy)
+        .containsExactly(
+            UsesGeneratedModulesApplication.ApplicationComponent.class,
+            UsesGeneratedModulesApplication.DummyContentProviderSubcomponent.class);
+
+    changeConfiguration();
+
+    TestActivityWithScope activityWithScope =
+        Robolectric.setupActivity(TestActivityWithScope.class);
+    assertThat(activityWithScope.scopedStringProvider.get())
+        .isSameAs(activityWithScope.scopedStringProvider.get());
+  }
+
+  // https://github.com/google/dagger/issues/598
+  private void changeConfiguration() {
+    Configuration oldConfiguration = activity.getResources().getConfiguration();
+    Configuration newConfiguration = new Configuration(oldConfiguration);
+    newConfiguration.orientation =
+        oldConfiguration.orientation == Configuration.ORIENTATION_LANDSCAPE
+            ? Configuration.ORIENTATION_PORTRAIT
+            : Configuration.ORIENTATION_LANDSCAPE;
+    activityController.configurationChange(newConfiguration);
+  }
+}
diff --git a/javatests/dagger/android/support/functional/TestActivity.java b/javatests/dagger/android/support/functional/TestActivity.java
new file mode 100644
index 000000000..b36c37a99
--- /dev/null
+++ b/javatests/dagger/android/support/functional/TestActivity.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import android.os.Bundle;
+import dagger.android.support.DaggerAppCompatActivity;
+import java.util.Set;
+import javax.inject.Inject;
+
+public final class TestActivity extends DaggerAppCompatActivity {
+  @Inject Set<Class<?>> componentHierarchy;
+
+  @Override
+  protected void onCreate(Bundle savedInstanceState) {
+    super.onCreate(savedInstanceState);
+<<<<<<< HEAD:examples/android-simple/src/main/java/com/example/dagger/simple/DemoActivity.java
+    // Perform injection so that when this call returns all dependencies will be available for use.
+    ((DemoApplication1) getApplication()).component().inject(this);
+=======
+
+    setContentView(R.layout.activity_layout);
+
+    getSupportFragmentManager()
+        .beginTransaction()
+        .add(new TestParentFragment(), "parent-fragment")
+        .commit();
+>>>>>>> upstream/master:javatests/dagger/android/support/functional/TestActivity.java
+  }
+}
diff --git a/javatests/dagger/android/support/functional/TestActivityWithScope.java b/javatests/dagger/android/support/functional/TestActivityWithScope.java
new file mode 100644
index 000000000..d7cb89143
--- /dev/null
+++ b/javatests/dagger/android/support/functional/TestActivityWithScope.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import dagger.android.support.DaggerAppCompatActivity;
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+public final class TestActivityWithScope extends DaggerAppCompatActivity {
+  @Inject Provider<String> scopedStringProvider;
+}
diff --git a/javatests/dagger/android/support/functional/TestBroadcastReceiver.java b/javatests/dagger/android/support/functional/TestBroadcastReceiver.java
new file mode 100644
index 000000000..edf93fef1
--- /dev/null
+++ b/javatests/dagger/android/support/functional/TestBroadcastReceiver.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import dagger.android.DaggerBroadcastReceiver;
+import java.util.Set;
+import javax.inject.Inject;
+
+public final class TestBroadcastReceiver extends DaggerBroadcastReceiver {
+  @Inject Set<Class<?>> componentHierarchy;
+}
diff --git a/javatests/dagger/android/support/functional/TestChildFragment.java b/javatests/dagger/android/support/functional/TestChildFragment.java
new file mode 100644
index 000000000..781c57809
--- /dev/null
+++ b/javatests/dagger/android/support/functional/TestChildFragment.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import dagger.android.support.DaggerFragment;
+import java.util.Set;
+import javax.inject.Inject;
+
+public final class TestChildFragment extends DaggerFragment {
+  @Inject Set<Class<?>> componentHierarchy;
+}
diff --git a/javatests/dagger/android/support/functional/TestContentProvider.java b/javatests/dagger/android/support/functional/TestContentProvider.java
new file mode 100644
index 000000000..1668ce647
--- /dev/null
+++ b/javatests/dagger/android/support/functional/TestContentProvider.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.net.Uri;
+import android.support.annotation.Nullable;
+import dagger.android.DaggerContentProvider;
+import java.util.Set;
+import javax.inject.Inject;
+
+public final class TestContentProvider extends DaggerContentProvider {
+  @Inject
+  Set<Class<?>> componentHierarchy;
+
+  @Nullable
+  @Override
+  public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,
+      String sortOrder) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Nullable
+  @Override
+  public String getType(Uri uri) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Nullable
+  @Override
+  public Uri insert(Uri uri, ContentValues values) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public int delete(Uri uri, String selection, String[] selectionArgs) {
+    throw new UnsupportedOperationException();
+  }
+
+  @Override
+  public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
+    throw new UnsupportedOperationException();
+  }
+}
diff --git a/javatests/dagger/android/support/functional/TestIntentService.java b/javatests/dagger/android/support/functional/TestIntentService.java
new file mode 100644
index 000000000..dc301d493
--- /dev/null
+++ b/javatests/dagger/android/support/functional/TestIntentService.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import android.content.Intent;
+import dagger.android.DaggerIntentService;
+import java.util.Set;
+import javax.inject.Inject;
+
+public final class TestIntentService extends DaggerIntentService {
+  @Inject Set<Class<?>> componentHierarchy;
+
+  public TestIntentService(String name) {
+    super(name);
+  }
+
+  @Override
+  protected void onHandleIntent(Intent intent) {}
+}
diff --git a/javatests/dagger/android/support/functional/TestParentFragment.java b/javatests/dagger/android/support/functional/TestParentFragment.java
new file mode 100644
index 000000000..6d2d6f47d
--- /dev/null
+++ b/javatests/dagger/android/support/functional/TestParentFragment.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import android.content.Context;
+import dagger.android.support.DaggerFragment;
+import java.util.Set;
+import javax.inject.Inject;
+
+public final class TestParentFragment extends DaggerFragment {
+  @Inject Set<Class<?>> componentHierarchy;
+
+  @Override
+  public void onAttach(Context context) {
+    super.onAttach(context);
+    getChildFragmentManager()
+        .beginTransaction()
+        .add(new TestChildFragment(), "child-fragment")
+        .commit();
+  }
+}
diff --git a/javatests/dagger/android/support/functional/TestService.java b/javatests/dagger/android/support/functional/TestService.java
new file mode 100644
index 000000000..d3c6dc1cc
--- /dev/null
+++ b/javatests/dagger/android/support/functional/TestService.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import android.content.Intent;
+import android.os.IBinder;
+import android.os.IInterface;
+import android.os.Parcel;
+import android.os.RemoteException;
+import dagger.android.DaggerService;
+import java.io.FileDescriptor;
+import java.util.Set;
+import javax.inject.Inject;
+
+public final class TestService extends DaggerService {
+  @Inject Set<Class<?>> componentHierarchy;
+
+  @Override
+  public IBinder onBind(Intent intent) {
+    return new MockBinder();
+  }
+
+  private static class MockBinder implements IBinder {
+    @Override
+    public String getInterfaceDescriptor() throws RemoteException {
+      return null;
+    }
+
+    @Override
+    public boolean pingBinder() {
+      return false;
+    }
+
+    @Override
+    public boolean isBinderAlive() {
+      return false;
+    }
+
+    @Override
+    public IInterface queryLocalInterface(String descriptor) {
+      return null;
+    }
+
+    @Override
+    public void dump(FileDescriptor fd, String[] args) throws RemoteException {}
+
+    @Override
+    public void dumpAsync(FileDescriptor fd, String[] args) throws RemoteException {}
+
+    @Override
+    public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
+      return false;
+    }
+
+    @Override
+    public void linkToDeath(DeathRecipient recipient, int flags) throws RemoteException {}
+
+    @Override
+    public boolean unlinkToDeath(DeathRecipient recipient, int flags) {
+      return false;
+    }
+  }
+}
diff --git a/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java b/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java
new file mode 100644
index 000000000..ff43e3959
--- /dev/null
+++ b/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java
@@ -0,0 +1,166 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.android.AndroidInjector;
+import dagger.android.ContributesAndroidInjector;
+import dagger.android.support.AndroidSupportInjectionModule;
+import dagger.android.support.DaggerApplication;
+import dagger.multibindings.IntoSet;
+import java.lang.annotation.Retention;
+import java.util.UUID;
+import javax.inject.Scope;
+
+public final class UsesGeneratedModulesApplication extends DaggerApplication {
+
+  @Override
+  protected AndroidInjector<? extends DaggerApplication> applicationInjector() {
+    return DaggerUsesGeneratedModulesApplication_ApplicationComponent.create();
+  }
+
+  @Component(modules = {ApplicationModule.class, AndroidSupportInjectionModule.class})
+  interface ApplicationComponent extends AndroidInjector<UsesGeneratedModulesApplication> {}
+
+  @Module
+  abstract static class ApplicationModule {
+    @Provides
+    @IntoSet
+    static Class<?> addToComponentHierarchy() {
+      return ApplicationComponent.class;
+    }
+
+    @ActivityScope
+    @ContributesAndroidInjector(modules = ActivityScopedModule.class)
+    abstract TestActivityWithScope contributeTestActivityWithScopeInjector();
+
+    @ContributesAndroidInjector(modules = DummyActivitySubcomponent.AddToHierarchy.class)
+    abstract TestActivity contributeTestActivityInjector();
+
+    @ContributesAndroidInjector(modules = DummyParentFragmentSubcomponent.AddToHierarchy.class)
+    abstract TestParentFragment contributeTestParentFragmentInjector();
+
+    @ContributesAndroidInjector(modules = DummyChildFragmentSubcomponent.AddToHierarchy.class)
+    abstract TestChildFragment contributeTestChildFragmentInjector();
+
+    @ContributesAndroidInjector(modules = DummyServiceSubcomponent.AddToHierarchy.class)
+    abstract TestService contributeTestServiceInjector();
+
+    @ContributesAndroidInjector(modules = DummyIntentServiceSubcomponent.AddToHierarchy.class)
+    abstract TestIntentService contributeTestIntentServiceInjector();
+
+    @ContributesAndroidInjector(modules = DummyBroadcastReceiverSubcomponent.AddToHierarchy.class)
+    abstract TestBroadcastReceiver contributeTestBroadcastReceiverInjector();
+
+    @ContributesAndroidInjector(modules = DummyContentProviderSubcomponent.AddToHierarchy.class)
+    abstract TestContentProvider contributeTestContentProviderInjector();
+  }
+
+  @Retention(RUNTIME)
+  @Scope
+  @interface ActivityScope {}
+
+  @Module
+  static class ActivityScopedModule {
+    @Provides
+    @ActivityScope
+    static String provideScopedString() {
+      return UUID.randomUUID().toString();
+    }
+  }
+
+  interface DummyActivitySubcomponent {
+    @Module
+    abstract class AddToHierarchy {
+      @Provides
+      @IntoSet
+      static Class<?> addDummyValueToComponentHierarchy() {
+        return DummyActivitySubcomponent.class;
+      }
+    }
+  }
+
+  interface DummyParentFragmentSubcomponent {
+    @Module
+    abstract class AddToHierarchy {
+      @Provides
+      @IntoSet
+      static Class<?> addDummyValueToComponentHierarchy() {
+        return DummyParentFragmentSubcomponent.class;
+      }
+    }
+  }
+
+  interface DummyChildFragmentSubcomponent {
+    @Module
+    abstract class AddToHierarchy {
+      @Provides
+      @IntoSet
+      static Class<?> addDummyValueToComponentHierarchy() {
+        return DummyChildFragmentSubcomponent.class;
+      }
+    }
+  }
+
+  interface DummyServiceSubcomponent {
+    @Module
+    abstract class AddToHierarchy {
+      @Provides
+      @IntoSet
+      static Class<?> addDummyValueToComponentHierarchy() {
+        return DummyServiceSubcomponent.class;
+      }
+    }
+  }
+
+  interface DummyIntentServiceSubcomponent {
+    @Module
+    abstract class AddToHierarchy {
+      @Provides
+      @IntoSet
+      static Class<?> addDummyValueToComponentHierarchy() {
+        return DummyIntentServiceSubcomponent.class;
+      }
+    }
+  }
+
+  interface DummyBroadcastReceiverSubcomponent {
+    @Module
+    abstract class AddToHierarchy {
+      @Provides
+      @IntoSet
+      static Class<?> addDummyValueToComponentHierarchy() {
+        return DummyBroadcastReceiverSubcomponent.class;
+      }
+    }
+  }
+
+  interface DummyContentProviderSubcomponent {
+    @Module
+    abstract class AddToHierarchy {
+      @Provides
+      @IntoSet
+      static Class<?> addDummyValueToComponentHierarchy() {
+        return DummyContentProviderSubcomponent.class;
+      }
+    }
+  }
+}
diff --git a/javatests/dagger/android/support/functional/res/layout/activity_layout.xml b/javatests/dagger/android/support/functional/res/layout/activity_layout.xml
new file mode 100644
index 000000000..d886d971d
--- /dev/null
+++ b/javatests/dagger/android/support/functional/res/layout/activity_layout.xml
@@ -0,0 +1,21 @@
+<!--
+  ~ Copyright (C) 2016 The Dagger Authors.
+  ~
+  ~  Licensed under the Apache License, Version 2.0 (the "License");
+  ~  you may not use this file except in compliance with the License.
+  ~  You may obtain a copy of the License at
+  ~
+  ~  http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~  Unless required by applicable law or agreed to in writing, software
+  ~  distributed under the License is distributed on an "AS IS" BASIS,
+  ~  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~  See the License for the specific language governing permissions and
+  ~  limitations under the License.
+  -->
+
+<FrameLayout
+  xmlns:android="http://schemas.android.com/apk/res/android"
+  android:id="@+id/fragment_container"
+  android:layout_width="match_parent"
+  android:layout_height="match_parent" />
diff --git a/javatests/dagger/functional/A.java b/javatests/dagger/functional/A.java
new file mode 100644
index 000000000..c295dc1ef
--- /dev/null
+++ b/javatests/dagger/functional/A.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import javax.inject.Inject;
+
+class A {
+  @Inject A() {}
+}
diff --git a/javatests/dagger/functional/AbstractMembersInjectingBaseClass.java b/javatests/dagger/functional/AbstractMembersInjectingBaseClass.java
new file mode 100644
index 000000000..fcab3184a
--- /dev/null
+++ b/javatests/dagger/functional/AbstractMembersInjectingBaseClass.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import javax.inject.Inject;
+
+abstract class AbstractMembersInjectingBaseClass {
+  @Inject Thing thing;
+}
+
diff --git a/javatests/dagger/functional/AbstractMiddleClassWithoutMembers.java b/javatests/dagger/functional/AbstractMiddleClassWithoutMembers.java
new file mode 100644
index 000000000..4ff55ebb3
--- /dev/null
+++ b/javatests/dagger/functional/AbstractMiddleClassWithoutMembers.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+abstract class AbstractMiddleClassWithoutMembers extends AbstractMembersInjectingBaseClass {
+}
+
diff --git a/javatests/dagger/functional/B.java b/javatests/dagger/functional/B.java
new file mode 100644
index 000000000..55d05af9d
--- /dev/null
+++ b/javatests/dagger/functional/B.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import javax.inject.Inject;
+
+class B {
+  @Inject B() {}
+}
diff --git a/javatests/dagger/functional/BUILD b/javatests/dagger/functional/BUILD
new file mode 100644
index 000000000..ee51856f2
--- /dev/null
+++ b/javatests/dagger/functional/BUILD
@@ -0,0 +1,48 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   Functional tests for Dagger
+
+package(default_visibility = ["//:src"])
+
+load(
+    "//:build_defs.bzl",
+    "DOCLINT_HTML_AND_SYNTAX",
+    "SOURCE_7_TARGET_7",
+)
+load("//:test_defs.bzl", "GenJavaTests")
+
+GenJavaTests(
+    name = "functional_tests",
+    srcs = glob(
+        ["**/*.java"],
+    ),
+    javacopts = DOCLINT_HTML_AND_SYNTAX,
+    lib_javacopts = SOURCE_7_TARGET_7,
+    # NOTE: This should not depend on Guava or jsr305 to ensure that Dagger can be
+    # used without Guava and jsr305 deps.
+    test_only_deps = [
+        "//third_party:guava_testlib",
+        "//third_party:guava",
+        "//third_party:truth",
+        "//third_party:junit",
+    ],
+    deps = [
+        "//:dagger_with_compiler",
+        "//third_party:auto_factory",
+        "//third_party:auto_value",
+        "//third_party:jsr330_inject",
+    ],
+)
diff --git a/javatests/dagger/functional/BasicAbstractClassComponent.java b/javatests/dagger/functional/BasicAbstractClassComponent.java
new file mode 100644
index 000000000..2bd849daf
--- /dev/null
+++ b/javatests/dagger/functional/BasicAbstractClassComponent.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Component;
+
+/**
+ * This component tests behavior equivalent to {@link BasicComponent}, but as an abstract class
+ * rather than an interface.
+ */
+@Component(modules = {PrimitivesModule.class, NullableModule.class})
+abstract class BasicAbstractClassComponent implements BasicComponent {
+  void throwAParty() {
+    throw new RuntimeException("Paaarrrrrtaaaaaaaay!");
+  }
+}
diff --git a/javatests/dagger/functional/BasicComponent.java b/javatests/dagger/functional/BasicComponent.java
new file mode 100644
index 000000000..ac5f098eb
--- /dev/null
+++ b/javatests/dagger/functional/BasicComponent.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Component;
+import dagger.Lazy;
+import dagger.MembersInjector;
+import dagger.functional.NullableModule.Nullable;
+import javax.inject.Provider;
+
+@Component(modules = {PrimitivesModule.class, NullableModule.class})
+interface BasicComponent extends Injector<Thing> {
+  byte getByte();
+  char getChar();
+  short getShort();
+  int getInt();
+  long getLong();
+  boolean getBoolean();
+  float getFloat();
+  double getDouble();
+
+  Byte getBoxedByte();
+  Character getBoxedChar();
+  Short getBoxedShort();
+  Integer getBoxedInt();
+  Long getBoxedLong();
+  Boolean getBoxedBoolean();
+  Float getBoxedFloat();
+  Double getBoxedDouble();
+
+  Provider<Byte> getByteProvider();
+  Provider<Character> getCharProvider();
+  Provider<Short> getShortProvider();
+  Provider<Integer> getIntProvider();
+  Provider<Long> getLongProvider();
+  Provider<Boolean> getBooleanProvider();
+  Provider<Float> getFloatProvider();
+  Provider<Double> getDoubleProvider();
+
+  byte[] getByteArray();
+  char[] getCharArray();
+  short[] getShortArray();
+  int[] getIntArray();
+  long[] getLongArray();
+  boolean[] getBooleanArray();
+  float[] getFloatArray();
+  double[] getDoubleArray();
+
+  Provider<byte[]> getByteArrayProvider();
+  Provider<char[]> getCharArrayProvider();
+  Provider<short[]> getShortArrayProvider();
+  Provider<int[]> getIntArrayProvider();
+  Provider<long[]> getLongArrayProvider();
+  Provider<boolean[]> getBooleanArrayProvider();
+  Provider<float[]> getFloatArrayProvider();
+  Provider<double[]> getDoubleArrayProvider();
+
+  Object noOpMembersInjection(Object obviouslyDoesNotHaveMembersToInject);
+
+  Thing thing();
+  InjectedThing injectedThing();
+  Provider<InjectedThing> injectedThingProvider();
+  Lazy<InjectedThing> lazyInjectedThing();
+  Provider<Lazy<InjectedThing>> lazyInjectedThingProvider();
+  MembersInjector<InjectedThing> injectedThingMembersInjector();
+  
+  @Nullable Object nullObject();
+  Provider<Object> nullObjectProvider();
+  Lazy<Object> lazyNullObject();
+
+  TypeWithInheritedMembersInjection typeWithInheritedMembersInjection();
+  MembersInjector<TypeWithInheritedMembersInjection>
+      typeWithInheritedMembersInjectionMembersInjector();
+}
diff --git a/javatests/dagger/functional/BasicTest.java b/javatests/dagger/functional/BasicTest.java
new file mode 100644
index 000000000..26f277e43
--- /dev/null
+++ b/javatests/dagger/functional/BasicTest.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import static com.google.common.truth.Truth.assertThat;
+import static dagger.functional.PrimitivesModule.BOUND_BOOLEAN;
+import static dagger.functional.PrimitivesModule.BOUND_BOOLEAN_ARRAY;
+import static dagger.functional.PrimitivesModule.BOUND_BYTE;
+import static dagger.functional.PrimitivesModule.BOUND_BYTE_ARRAY;
+import static dagger.functional.PrimitivesModule.BOUND_CHAR;
+import static dagger.functional.PrimitivesModule.BOUND_CHAR_ARRAY;
+import static dagger.functional.PrimitivesModule.BOUND_DOUBLE;
+import static dagger.functional.PrimitivesModule.BOUND_DOUBLE_ARRAY;
+import static dagger.functional.PrimitivesModule.BOUND_FLOAT;
+import static dagger.functional.PrimitivesModule.BOUND_FLOAT_ARRAY;
+import static dagger.functional.PrimitivesModule.BOUND_INT;
+import static dagger.functional.PrimitivesModule.BOUND_INT_ARRAY;
+import static dagger.functional.PrimitivesModule.BOUND_LONG;
+import static dagger.functional.PrimitivesModule.BOUND_LONG_ARRAY;
+import static dagger.functional.PrimitivesModule.BOUND_SHORT;
+import static dagger.functional.PrimitivesModule.BOUND_SHORT_ARRAY;
+
+import dagger.Lazy;
+import javax.inject.Provider;
+import org.junit.experimental.theories.DataPoint;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+@RunWith(Theories.class)
+public class BasicTest {
+  @DataPoint
+  public static final BasicComponent basicComponent = DaggerBasicComponent.create();
+  @DataPoint
+  public static final BasicComponent abstractClassBasicComponent =
+      DaggerBasicAbstractClassComponent.create();
+
+  @Theory public void primitives(BasicComponent basicComponent) {
+    assertThat(basicComponent.getByte()).isEqualTo(BOUND_BYTE);
+    assertThat(basicComponent.getChar()).isEqualTo(BOUND_CHAR);
+    assertThat(basicComponent.getShort()).isEqualTo(BOUND_SHORT);
+    assertThat(basicComponent.getInt()).isEqualTo(BOUND_INT);
+    assertThat(basicComponent.getLong()).isEqualTo(BOUND_LONG);
+    assertThat(basicComponent.getBoolean()).isEqualTo(BOUND_BOOLEAN);
+    assertThat(basicComponent.getFloat()).isWithin(0).of(BOUND_FLOAT);
+    assertThat(basicComponent.getDouble()).isWithin(0).of(BOUND_DOUBLE);
+  }
+
+  @Theory public void boxedPrimitives(BasicComponent basicComponent) {
+    assertThat(basicComponent.getBoxedByte()).isEqualTo(new Byte(BOUND_BYTE));
+    assertThat(basicComponent.getBoxedChar()).isEqualTo(new Character(BOUND_CHAR));
+    assertThat(basicComponent.getBoxedShort()).isEqualTo(new Short(BOUND_SHORT));
+    assertThat(basicComponent.getBoxedInt()).isEqualTo(new Integer(BOUND_INT));
+    assertThat(basicComponent.getBoxedLong()).isEqualTo(new Long(BOUND_LONG));
+    assertThat(basicComponent.getBoxedBoolean()).isEqualTo(new Boolean(BOUND_BOOLEAN));
+    assertThat(basicComponent.getBoxedFloat()).isWithin(0).of(BOUND_FLOAT);
+    assertThat(basicComponent.getBoxedDouble()).isWithin(0).of(BOUND_DOUBLE);
+  }
+
+  @Theory public void boxedPrimitiveProviders(BasicComponent basicComponent) {
+    assertThat(basicComponent.getByteProvider().get()).isEqualTo(new Byte(BOUND_BYTE));
+    assertThat(basicComponent.getCharProvider().get()).isEqualTo(new Character(BOUND_CHAR));
+    assertThat(basicComponent.getShortProvider().get()).isEqualTo(new Short(BOUND_SHORT));
+    assertThat(basicComponent.getIntProvider().get()).isEqualTo(new Integer(BOUND_INT));
+    assertThat(basicComponent.getLongProvider().get()).isEqualTo(new Long(BOUND_LONG));
+    assertThat(basicComponent.getBooleanProvider().get()).isEqualTo(new Boolean(BOUND_BOOLEAN));
+    assertThat(basicComponent.getFloatProvider().get()).isWithin(0).of(BOUND_FLOAT);
+    assertThat(basicComponent.getDoubleProvider().get()).isWithin(0).of(BOUND_DOUBLE);
+  }
+
+  @Theory public void primitiveArrays(BasicComponent basicComponent) {
+    assertThat(basicComponent.getByteArray()).isSameAs(BOUND_BYTE_ARRAY);
+    assertThat(basicComponent.getCharArray()).isSameAs(BOUND_CHAR_ARRAY);
+    assertThat(basicComponent.getShortArray()).isSameAs(BOUND_SHORT_ARRAY);
+    assertThat(basicComponent.getIntArray()).isSameAs(BOUND_INT_ARRAY);
+    assertThat(basicComponent.getLongArray()).isSameAs(BOUND_LONG_ARRAY);
+    assertThat(basicComponent.getBooleanArray()).isSameAs(BOUND_BOOLEAN_ARRAY);
+    assertThat(basicComponent.getFloatArray()).isSameAs(BOUND_FLOAT_ARRAY);
+    assertThat(basicComponent.getDoubleArray()).isSameAs(BOUND_DOUBLE_ARRAY);
+  }
+
+  @Theory public void primitiveArrayProviders(BasicComponent basicComponent) {
+    assertThat(basicComponent.getByteArrayProvider().get()).isSameAs(BOUND_BYTE_ARRAY);
+    assertThat(basicComponent.getCharArrayProvider().get()).isSameAs(BOUND_CHAR_ARRAY);
+    assertThat(basicComponent.getShortArrayProvider().get()).isSameAs(BOUND_SHORT_ARRAY);
+    assertThat(basicComponent.getIntArrayProvider().get()).isSameAs(BOUND_INT_ARRAY);
+    assertThat(basicComponent.getLongArrayProvider().get()).isSameAs(BOUND_LONG_ARRAY);
+    assertThat(basicComponent.getBooleanArrayProvider().get()).isSameAs(BOUND_BOOLEAN_ARRAY);
+    assertThat(basicComponent.getFloatArrayProvider().get()).isSameAs(BOUND_FLOAT_ARRAY);
+    assertThat(basicComponent.getDoubleArrayProvider().get()).isSameAs(BOUND_DOUBLE_ARRAY);
+  }
+
+  @Theory public void noOpMembersInjection(BasicComponent basicComponent) {
+    Object object = new Object();
+    assertThat(basicComponent.noOpMembersInjection(object)).isSameAs(object);
+  }
+
+  @Theory public void basicObject_noDeps(BasicComponent basicComponent) {
+    assertThat(basicComponent.thing()).isNotNull();
+  }
+
+  @Theory public void inheritedMembersInjection(BasicComponent basicComponent) {
+    assertThat(basicComponent.typeWithInheritedMembersInjection().thing).isNotNull();
+  }
+  
+  @Theory
+  public void nullableInjection(BasicComponent basicComponent) {
+    assertThat(basicComponent.nullObject()).isNull();
+    assertThat(basicComponent.nullObjectProvider().get()).isNull();
+    assertThat(basicComponent.lazyNullObject().get()).isNull();
+  }
+  
+  @Theory
+  public void providerOfLazy(BasicComponent basicComponent) {
+    Provider<Lazy<InjectedThing>> lazyInjectedThingProvider =
+        basicComponent.lazyInjectedThingProvider();
+    Lazy<InjectedThing> lazyInjectedThing1 = lazyInjectedThingProvider.get();
+    Lazy<InjectedThing> lazyInjectedThing2 = lazyInjectedThingProvider.get();
+    assertThat(lazyInjectedThing2).isNotSameAs(lazyInjectedThing1);
+    assertThat(lazyInjectedThing1.get()).isSameAs(lazyInjectedThing1.get());
+    assertThat(lazyInjectedThing2.get()).isSameAs(lazyInjectedThing2.get());
+    assertThat(lazyInjectedThing2.get()).isNotSameAs(lazyInjectedThing1.get());
+  }
+}
diff --git a/javatests/dagger/functional/BooleanKey.java b/javatests/dagger/functional/BooleanKey.java
new file mode 100644
index 000000000..28e1c086a
--- /dev/null
+++ b/javatests/dagger/functional/BooleanKey.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = true)
+@interface BooleanKey {
+  boolean value();
+}
diff --git a/javatests/dagger/functional/BoundedGenericComponent.java b/javatests/dagger/functional/BoundedGenericComponent.java
new file mode 100644
index 000000000..270316ea8
--- /dev/null
+++ b/javatests/dagger/functional/BoundedGenericComponent.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Component;
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+
+@Component(modules = BoundedGenericModule.class)
+interface BoundedGenericComponent {
+  BoundedGenerics<Integer, ArrayList<String>, LinkedList<CharSequence>, Integer, List<Integer>>
+      bounds1();
+  BoundedGenerics<Double, LinkedList<String>, LinkedList<Comparable<String>>, Double, Set<Double>>
+      bounds2();
+}
diff --git a/javatests/dagger/functional/BoundedGenericModule.java b/javatests/dagger/functional/BoundedGenericModule.java
new file mode 100644
index 000000000..b630cd65b
--- /dev/null
+++ b/javatests/dagger/functional/BoundedGenericModule.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Module;
+import dagger.Provides;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+
+@Module
+class BoundedGenericModule {
+
+  @Provides
+  Integer provideInteger() {
+    return 1;
+  }
+
+  @Provides
+  Double provideDouble() {
+    return 2d;
+  }
+
+  @Provides
+  ArrayList<String> provideArrayListString() {
+    ArrayList<String> list = new ArrayList<>();
+    list.add("arrayListOfString");
+    return list;
+  }
+
+  @Provides
+  LinkedList<String> provideLinkedListString() {
+    LinkedList<String> list = new LinkedList<>();
+    list.add("linkedListOfString");
+    return list;
+  }
+
+  @Provides
+  LinkedList<CharSequence> provideLinkedListCharSeq() {
+    LinkedList<CharSequence> list = new LinkedList<>();
+    list.add("linkedListOfCharSeq");
+    return list;
+  }
+
+  @Provides
+  @SuppressWarnings("unchecked")
+  LinkedList<Comparable<String>> provideArrayListOfComparableString() {
+    LinkedList<Comparable<String>> list = new LinkedList<>();
+    list.add("arrayListOfComparableOfString");
+    return list;
+  }
+
+  @Provides
+  List<Integer> provideListOfInteger() {
+    LinkedList<Integer> list = new LinkedList<>();
+    list.add(3);
+    return list;
+  }
+
+  @Provides
+  Set<Double> provideSetOfDouble() {
+    Set<Double> set = new HashSet<>();
+    set.add(4d);
+    return set;
+  }
+}
diff --git a/javatests/dagger/functional/BoundedGenerics.java b/javatests/dagger/functional/BoundedGenerics.java
new file mode 100644
index 000000000..812cd0454
--- /dev/null
+++ b/javatests/dagger/functional/BoundedGenerics.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import java.util.List;
+import javax.inject.Inject;
+
+class BoundedGenerics<A extends Number & Comparable<? super A>, 
+      B extends List<? extends CharSequence>,
+      C extends List<? super String>,
+      D extends A,
+      E extends Iterable<D>> {
+  
+  final A a;
+  final B b;
+  final C c;
+  final D d;
+  final E e;
+  
+  @Inject BoundedGenerics(A a, B b, C c, D d, E e) {
+    this.a = a;
+    this.b = b;
+    this.c = c;
+    this.d = d;
+    this.e = e;
+  }
+
+}
diff --git a/javatests/dagger/functional/ByteKey.java b/javatests/dagger/functional/ByteKey.java
new file mode 100644
index 000000000..f0ee7ecee
--- /dev/null
+++ b/javatests/dagger/functional/ByteKey.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = true)
+@interface ByteKey {
+  byte value();
+}
diff --git a/javatests/dagger/functional/CharKey.java b/javatests/dagger/functional/CharKey.java
new file mode 100644
index 000000000..3e1278529
--- /dev/null
+++ b/javatests/dagger/functional/CharKey.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = true)
+@interface CharKey {
+  char value();
+}
diff --git a/javatests/dagger/functional/ChildDoubleModule.java b/javatests/dagger/functional/ChildDoubleModule.java
new file mode 100644
index 000000000..cff8f0b7b
--- /dev/null
+++ b/javatests/dagger/functional/ChildDoubleModule.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Module;
+import dagger.Provides;
+import java.util.ArrayList;
+import java.util.List;
+
+@Module
+class ChildDoubleModule extends ParentModule<Double, String, List<Double>> {
+
+  @Provides Double provideDouble() {
+    return 3d;
+  }
+
+  @Provides List<Double> provideListOfDouble() {
+    List<Double> list = new ArrayList<>();
+    list.add(4d);
+    return list;
+  }
+
+}
diff --git a/javatests/dagger/functional/ChildIntegerModule.java b/javatests/dagger/functional/ChildIntegerModule.java
new file mode 100644
index 000000000..45c7c1a4a
--- /dev/null
+++ b/javatests/dagger/functional/ChildIntegerModule.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Module;
+import dagger.Provides;
+import java.util.ArrayList;
+import java.util.List;
+
+@Module
+class ChildIntegerModule extends ParentModule<Integer, String, List<Integer>> {
+
+  @Provides Integer provideInteger() {
+    return 1;
+  }
+
+  @Provides List<Integer> provideListOfInteger() {
+    List<Integer> list = new ArrayList<>();
+    list.add(2);
+    return list;
+  }
+
+}
diff --git a/javatests/dagger/functional/ComplexGenerics.java b/javatests/dagger/functional/ComplexGenerics.java
new file mode 100644
index 000000000..9309583b3
--- /dev/null
+++ b/javatests/dagger/functional/ComplexGenerics.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Lazy;
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+class ComplexGenerics {
+  
+  final Generic2<Generic<A>> g2ga;
+  final Lazy<Generic2<Generic<A>>> g2gaLazy;
+  final Provider<Generic2<Generic<A>>> g2gaProvider;
+  final Generic2<Generic<B>> g2gb;
+  final Lazy<Generic2<Generic<B>>> g2gbLazy;
+  final Provider<Generic2<Generic<B>>> g2gbProvider;
+  final Generic2<A> g2a;
+  final Generic<Generic2<A>> gg2a;
+  final Generic<Generic2<B>> gg2b;
+  
+  @Inject ComplexGenerics(
+      Generic2<Generic<A>> g2ga,
+      Lazy<Generic2<Generic<A>>> g2gaLazy,
+      Provider<Generic2<Generic<A>>> g2gaProvider,
+      Generic2<Generic<B>> g2gb,
+      Lazy<Generic2<Generic<B>>> g2gbLazy,
+      Provider<Generic2<Generic<B>>> g2gbProvider,
+      Generic2<A> g2a,
+      Generic<Generic2<A>> gg2a,
+      Generic<Generic2<B>> gg2b) {
+    this.g2ga = g2ga;
+    this.g2gaLazy = g2gaLazy;
+    this.g2gaProvider = g2gaProvider;
+    this.g2gb = g2gb;
+    this.g2gbLazy = g2gbLazy;
+    this.g2gbProvider = g2gbProvider;
+    this.g2a = g2a;
+    this.gg2a = gg2a;
+    this.gg2b = gg2b;
+  }
+}
diff --git a/javatests/dagger/functional/ComponentDependsOnGeneratedCode.java b/javatests/dagger/functional/ComponentDependsOnGeneratedCode.java
new file mode 100644
index 000000000..9c44c5c90
--- /dev/null
+++ b/javatests/dagger/functional/ComponentDependsOnGeneratedCode.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Component;
+
+/**
+ * A component that indirectly depends on code generated by another processor, in this case
+ * {@link com.google.auto.factory.AutoFactory}. Neither this type nor its immediately referenced
+ * types are generated, but {@link NeedsFactory} depends on the generated
+ * {@link NeedsFactory_SomethingFactory}.
+ *
+ */
+@Component
+interface ComponentDependsOnGeneratedCode {
+  NeedsFactory needsFactory();
+}
diff --git a/javatests/dagger/functional/ComponentSupertypeDependsOnGeneratedCode.java b/javatests/dagger/functional/ComponentSupertypeDependsOnGeneratedCode.java
new file mode 100644
index 000000000..a26292a34
--- /dev/null
+++ b/javatests/dagger/functional/ComponentSupertypeDependsOnGeneratedCode.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Component;
+
+/**
+ * A component whose supertype depends on code generated by another processor, in this case
+ * {@link com.google.auto.factory.AutoFactory}.
+ *
+ */
+@Component
+interface ComponentSupertypeDependsOnGeneratedCode
+    extends ComponentSupertypeDependsOnGeneratedCodeInterface {}
diff --git a/javatests/dagger/functional/ComponentSupertypeDependsOnGeneratedCodeInterface.java b/javatests/dagger/functional/ComponentSupertypeDependsOnGeneratedCodeInterface.java
new file mode 100644
index 000000000..7744d1991
--- /dev/null
+++ b/javatests/dagger/functional/ComponentSupertypeDependsOnGeneratedCodeInterface.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+interface ComponentSupertypeDependsOnGeneratedCodeInterface {
+  NeedsFactory_SomethingFactory somethingFactory();
+}
diff --git a/javatests/dagger/functional/ComponentWithReusableBindings.java b/javatests/dagger/functional/ComponentWithReusableBindings.java
new file mode 100644
index 000000000..17484c68a
--- /dev/null
+++ b/javatests/dagger/functional/ComponentWithReusableBindings.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Reusable;
+import dagger.Subcomponent;
+import javax.inject.Qualifier;
+
+@Component(modules = ComponentWithReusableBindings.ReusableBindingsModule.class)
+interface ComponentWithReusableBindings {
+
+  @Qualifier
+  @interface InParent {}
+
+  @Qualifier
+  @interface InChildren {}
+
+  @InParent
+  Object reusableInParent();
+
+  ChildOne childOne();
+
+  ChildTwo childTwo();
+
+  @Subcomponent
+  interface ChildOne {
+    @InParent
+    Object reusableInParent();
+
+    @InChildren
+    Object reusableInChild();
+  }
+
+  @Subcomponent
+  interface ChildTwo {
+    @InParent
+    Object reusableInParent();
+
+    @InChildren
+    Object reusableInChild();
+  }
+
+  @Module
+  static class ReusableBindingsModule {
+    @Provides
+    @Reusable
+    @InParent
+    static Object inParent() {
+      return new Object();
+    }
+
+    @Provides
+    @Reusable
+    @InChildren
+    static Object inChildren() {
+      return new Object();
+    }
+  }
+}
diff --git a/javatests/dagger/functional/ComponentsWithNestedModules.java b/javatests/dagger/functional/ComponentsWithNestedModules.java
new file mode 100644
index 000000000..a42dd73cf
--- /dev/null
+++ b/javatests/dagger/functional/ComponentsWithNestedModules.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Component;
+import dagger.Module;
+
+// https://github.com/google/dagger/issues/279
+public class ComponentsWithNestedModules {
+  @Component(modules = RegularComponent.SharedModule.class)
+  public interface RegularComponent {
+    @Module class SharedModule {}
+  }
+
+  @Component(modules = ExtendsRegularComponent.SharedModule.class)
+  public interface ExtendsRegularComponent extends RegularComponent {
+    @Module(includes = RegularComponent.SharedModule.class)
+    class SharedModule {}
+  }
+}
diff --git a/javatests/dagger/functional/DependsOnGeneratedCodeTest.java b/javatests/dagger/functional/DependsOnGeneratedCodeTest.java
new file mode 100644
index 000000000..ca7631ff5
--- /dev/null
+++ b/javatests/dagger/functional/DependsOnGeneratedCodeTest.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * @see <a href="http://b/19435358">Bug 19435358</a>
+ */
+@RunWith(JUnit4.class)
+public class DependsOnGeneratedCodeTest {
+  @Test public void testComponentDependsOnGeneratedCode() {
+    assertThat(DaggerComponentDependsOnGeneratedCode.create().needsFactory()).isNotNull();
+  }
+}
diff --git a/javatests/dagger/functional/Generic.java b/javatests/dagger/functional/Generic.java
new file mode 100644
index 000000000..9e77efe08
--- /dev/null
+++ b/javatests/dagger/functional/Generic.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import javax.inject.Inject;
+
+public class Generic<T> {
+  final T t;
+
+  @Inject public Generic(T t) {
+    this.t = t;
+  }
+}
diff --git a/javatests/dagger/functional/Generic2.java b/javatests/dagger/functional/Generic2.java
new file mode 100644
index 000000000..f53c0f86c
--- /dev/null
+++ b/javatests/dagger/functional/Generic2.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import javax.inject.Inject;
+
+public class Generic2<T> {
+  final T t;
+
+  @Inject Generic2(T t) {
+    this.t = t;
+  }
+}
diff --git a/javatests/dagger/functional/GenericChild.java b/javatests/dagger/functional/GenericChild.java
new file mode 100644
index 000000000..bb7330edf
--- /dev/null
+++ b/javatests/dagger/functional/GenericChild.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import javax.inject.Inject;
+
+class GenericChild<T> extends GenericParent<T, B> {
+  
+  A registeredA;
+  T registeredT;
+  
+  @Inject GenericChild() {}
+  
+  @Inject A a;
+  @Inject T t;
+  
+  @Inject void registerA(A a) { this.registeredA = a; }
+  @Inject void registerT(T t) { this.registeredT = t; }
+
+}
diff --git a/javatests/dagger/functional/GenericComponent.java b/javatests/dagger/functional/GenericComponent.java
new file mode 100644
index 000000000..239179b15
--- /dev/null
+++ b/javatests/dagger/functional/GenericComponent.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Component;
+import dagger.functional.sub.Exposed;
+import dagger.functional.sub.PublicSubclass;
+
+@Component(modules = {ChildDoubleModule.class, ChildIntegerModule.class})
+interface GenericComponent {
+  ReferencesGeneric referencesGeneric();
+  GenericDoubleReferences<A> doubleGenericA();
+  GenericDoubleReferences<B> doubleGenericB();
+  ComplexGenerics complexGenerics();
+  GenericNoDeps<A> noDepsA();
+  GenericNoDeps<B> noDepsB();
+
+  void injectA(GenericChild<A> childA);
+  void injectB(GenericChild<B> childB);
+
+  Exposed exposed();
+  PublicSubclass publicSubclass();
+  
+  Iterable<Integer> iterableInt();
+  Iterable<Double> iterableDouble();
+}
diff --git a/javatests/dagger/functional/GenericDoubleReferences.java b/javatests/dagger/functional/GenericDoubleReferences.java
new file mode 100644
index 000000000..ff79a9829
--- /dev/null
+++ b/javatests/dagger/functional/GenericDoubleReferences.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import javax.inject.Inject;
+
+class GenericDoubleReferences<T> {
+  final T t;
+  final T t2;
+  final Thing a;
+  final Thing a2;
+
+  @Inject GenericDoubleReferences(T t, Thing a, T t2, Thing a2) {
+    this.t = t;
+    this.a = a;
+    this.t2 = t2;
+    this.a2 = a2;
+  }
+}
diff --git a/javatests/dagger/functional/GenericNoDeps.java b/javatests/dagger/functional/GenericNoDeps.java
new file mode 100644
index 000000000..c3f38b4de
--- /dev/null
+++ b/javatests/dagger/functional/GenericNoDeps.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import javax.inject.Inject;
+
+class GenericNoDeps<T> {
+  
+  @Inject GenericNoDeps() {}
+
+}
diff --git a/javatests/dagger/functional/GenericParent.java b/javatests/dagger/functional/GenericParent.java
new file mode 100644
index 000000000..658530e52
--- /dev/null
+++ b/javatests/dagger/functional/GenericParent.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+class GenericParent<X, Y> {
+  
+  Provider<X> registeredX;
+  Y registeredY;
+  B registeredB;
+  
+  @Inject GenericParent() {}
+  
+  @Inject Provider<X> x;
+  @Inject Y y;
+  @Inject B b;
+  
+  @Inject
+  void registerX(Provider<X> x) {
+    this.registeredX = x;
+  }
+  @Inject void registerY(Y y) { this.registeredY = y; }
+  @Inject void registerB(B b) { this.registeredB = b; }
+}
diff --git a/javatests/dagger/functional/GenericTest.java b/javatests/dagger/functional/GenericTest.java
new file mode 100644
index 000000000..be17446ef
--- /dev/null
+++ b/javatests/dagger/functional/GenericTest.java
@@ -0,0 +1,160 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.assertEquals;
+
+import dagger.functional.sub.Exposed;
+import dagger.functional.sub.PublicSubclass;
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Set;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class GenericTest {
+
+  @Test public void testGenericComponentCreate() {
+    GenericComponent component = DaggerGenericComponent.create();
+    assertThat(component).isNotNull();
+  }
+  
+  @Test public void testGenericSimpleReferences() {
+    GenericComponent component = DaggerGenericComponent.create();
+    assertThat(component.referencesGeneric().genericA.t).isNotNull();    
+  }
+  
+  @Test public void testGenericDoubleReferences() {
+    GenericComponent component = DaggerGenericComponent.create();
+    GenericDoubleReferences<A> doubleA = component.doubleGenericA();
+    assertThat(doubleA.a).isNotNull();
+    assertThat(doubleA.a2).isNotNull();
+    assertThat(doubleA.t).isNotNull();
+    assertThat(doubleA.t2).isNotNull();
+
+    GenericDoubleReferences<B> doubleB = component.doubleGenericB();
+    assertThat(doubleB.a).isNotNull();
+    assertThat(doubleB.a2).isNotNull();
+    assertThat(doubleB.t).isNotNull();
+    assertThat(doubleB.t2).isNotNull();
+  }
+  
+  @Test public void complexGenerics() {
+    GenericComponent component = DaggerGenericComponent.create();
+    // validate these can be called w/o exceptions.
+    component.complexGenerics();
+  }
+  
+  @Test public void noDepsGenerics() {
+    GenericComponent component = DaggerGenericComponent.create();
+    // validate these can be called w/o exceptions.
+    component.noDepsA();
+    component.noDepsB();
+  }
+  
+  @Test public void boundedGenerics() {
+    BoundedGenericModule expected = new BoundedGenericModule();
+    BoundedGenericComponent component = DaggerBoundedGenericComponent.create();
+    BoundedGenerics<Integer, ArrayList<String>, LinkedList<CharSequence>, Integer, List<Integer>>
+        b1 = component.bounds1();
+    assertEquals(expected.provideInteger(), b1.a);
+    assertEquals(expected.provideArrayListString(), b1.b);
+    assertEquals(expected.provideLinkedListCharSeq(), b1.c);
+    assertEquals(expected.provideInteger(), b1.d);
+    assertEquals(expected.provideListOfInteger(), b1.e);
+
+    BoundedGenerics<Double, LinkedList<String>, LinkedList<Comparable<String>>, Double, Set<Double>>
+        b2 = component.bounds2();
+    assertEquals(expected.provideDouble(), b2.a);
+    assertEquals(expected.provideLinkedListString(), b2.b);
+    assertEquals(expected.provideArrayListOfComparableString(), b2.c);
+    assertEquals(expected.provideDouble(), b2.d);
+    assertEquals(expected.provideSetOfDouble(), b2.e);
+  }
+  
+  @Test public void membersInjections() {
+    GenericComponent component = DaggerGenericComponent.create();
+    GenericChild<A> childA = new GenericChild<A>();
+    component.injectA(childA);
+    assertThat(childA.a).isNotNull();
+    assertThat(childA.b).isNotNull();
+    assertThat(childA.registeredA).isNotNull();
+    assertThat(childA.registeredB).isNotNull();
+    assertThat(childA.registeredT).isNotNull();
+    assertThat(childA.registeredX).isNotNull();
+    assertThat(childA.registeredY).isNotNull();
+    
+    GenericChild<B> childB = new GenericChild<B>();
+    component.injectB(childB);
+    assertThat(childB.a).isNotNull();
+    assertThat(childB.b).isNotNull();
+    assertThat(childB.registeredA).isNotNull();
+    assertThat(childB.registeredB).isNotNull();
+    assertThat(childB.registeredT).isNotNull();
+    assertThat(childB.registeredX).isNotNull();
+    assertThat(childB.registeredY).isNotNull();
+  }
+  
+  @Test public void packagePrivateTypeParameterDependencies() {
+    GenericComponent component = DaggerGenericComponent.create();
+    Exposed exposed = component.exposed();
+    assertThat(exposed.gpp.t).isNotNull();
+    assertThat(exposed.gpp2).isNotNull();
+  }
+  
+  @SuppressWarnings("rawtypes")
+  @Test public void publicSubclassWithPackagePrivateTypeParameterOfSuperclass() {
+    GenericComponent component = DaggerGenericComponent.create();
+    PublicSubclass publicSubclass = component.publicSubclass();
+    assertThat(((Generic)publicSubclass).t).isNotNull();
+  }
+
+  @Test public void singletonScopesAppliesToEachResolvedType() {
+    SingletonGenericComponent component = DaggerSingletonGenericComponent.create();
+    ScopedGeneric<A> a = component.scopedGenericA();
+    assertThat(a).isSameAs(component.scopedGenericA());
+    assertThat(a.t).isNotNull();
+
+    ScopedGeneric<B> b = component.scopedGenericB();
+    assertThat(b).isSameAs(component.scopedGenericB());
+    assertThat(b.t).isNotNull();
+
+    assertThat(a).isNotSameAs(b);
+  }
+
+  @Test // See https://github.com/google/dagger/issues/671
+  public void scopedSimpleGenerics() {
+    SingletonGenericComponent component = DaggerSingletonGenericComponent.create();
+    ScopedSimpleGeneric<A> a = component.scopedSimpleGenericA();
+    assertThat(a).isSameAs(component.scopedSimpleGenericA());
+
+    ScopedSimpleGeneric<B> b = component.scopedSimpleGenericB();
+    assertThat(b).isSameAs(component.scopedSimpleGenericB());
+
+    assertThat(a).isNotSameAs(b);
+  }
+  
+  @Test public void genericModules() {
+    GenericComponent component = DaggerGenericComponent.create();
+    assertThat(component.iterableInt()).containsExactly(1, 2).inOrder();
+    assertThat(component.iterableDouble()).containsExactly(3d, 4d).inOrder();
+  }
+}
diff --git a/javatests/dagger/functional/InjectedThing.java b/javatests/dagger/functional/InjectedThing.java
new file mode 100644
index 000000000..c518faafc
--- /dev/null
+++ b/javatests/dagger/functional/InjectedThing.java
@@ -0,0 +1,231 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Lazy;
+import dagger.MembersInjector;
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+@SuppressWarnings("unused")
+final class InjectedThing {
+  @Inject byte primitiveByte;
+  @Inject char primitiveChar;
+  @Inject short primitiveShort;
+  @Inject int primitiveInt;
+  @Inject long primitiveLong;
+  @Inject boolean primitiveBoolean;
+  @Inject float primitiveFloat;
+  @Inject double primitiveDouble;
+
+  @Inject Provider<Byte> byteProvider;
+  @Inject Provider<Character> charProvider;
+  @Inject Provider<Short> shortProvider;
+  @Inject Provider<Integer> intProvider;
+  @Inject Provider<Long> longProvider;
+  @Inject Provider<Boolean> booleanProvider;
+  @Inject Provider<Float> floatProvider;
+  @Inject Provider<Double> doubleProvider;
+
+  @Inject Lazy<Byte> lazyByte;
+  @Inject Lazy<Character> lazyChar;
+  @Inject Lazy<Short> lazyShort;
+  @Inject Lazy<Integer> lazyInt;
+  @Inject Lazy<Long> lazyLong;
+  @Inject Lazy<Boolean> lazyBoolean;
+  @Inject Lazy<Float> lazyFloat;
+  @Inject Lazy<Double> lazyDouble;
+
+  @Inject Byte boxedBype;
+  @Inject Character boxedChar;
+  @Inject Short boxedShort;
+  @Inject Integer boxedInt;
+  @Inject Long boxedLong;
+  @Inject Boolean boxedBoolean;
+  @Inject Float boxedFloat;
+  @Inject Double boxedDouble;
+
+  @Inject byte[] byteArray;
+  @Inject char[] charArray;
+  @Inject short[] shortArray;
+  @Inject int[] intArray;
+  @Inject long[] longArray;
+  @Inject boolean[] booleanArray;
+  @Inject float[] floatArray;
+  @Inject double[] doubleArray;
+
+  @Inject Provider<byte[]> byteArrayProvider;
+  @Inject Provider<char[]> charArrayProvider;
+  @Inject Provider<short[]> shortArrayProvider;
+  @Inject Provider<int[]> intArrayProvider;
+  @Inject Provider<long[]> longArrayProvider;
+  @Inject Provider<boolean[]> booleanArrayProvider;
+  @Inject Provider<float[]> floatArrayProvider;
+  @Inject Provider<double[]> doubleArrayProvider;
+
+  @Inject Lazy<byte[]> lazyByteArray;
+  @Inject Lazy<char[]> lazyCharArray;
+  @Inject Lazy<short[]> lazyShortArray;
+  @Inject Lazy<int[]> lazyIntArray;
+  @Inject Lazy<long[]> lazyLongArray;
+  @Inject Lazy<boolean[]> lazyBooleanArray;
+  @Inject Lazy<float[]> lazy;
+  @Inject Lazy<double[]> lazyDoubleArray;
+
+  @Inject Thing thing;
+  @Inject Provider<Thing> thingProvider;
+  @Inject Lazy<Thing> lazyThing;
+  @Inject Provider<Lazy<Thing>> lazyThingProvider;
+  @Inject MembersInjector<Thing> thingMembersInjector;
+
+  @Inject InjectedThing(
+      byte primitiveByte,
+      char primitiveChar,
+      short primitiveShort,
+      int primitiveInt,
+      long primitiveLong,
+      boolean primitiveBoolean,
+      float primitiveFloat,
+      double primitiveDouble,
+
+      Provider<Byte> byteProvider,
+      Provider<Character> charProvider,
+      Provider<Short> shortProvider,
+      Provider<Integer> intProvider,
+      Provider<Long> longProvider,
+      Provider<Boolean> booleanProvider,
+      Provider<Float> floatProvider,
+      Provider<Double> doubleProvider,
+
+      Lazy<Byte> lazyByte,
+      Lazy<Character> lazyChar,
+      Lazy<Short> lazyShort,
+      Lazy<Integer> lazyInt,
+      Lazy<Long> lazyLong,
+      Lazy<Boolean> lazyBoolean,
+      Lazy<Float> lazyFloat,
+      Lazy<Double> lazyDouble,
+
+      Byte boxedBype,
+      Character boxedChar,
+      Short boxedShort,
+      Integer boxedInt,
+      Long boxedLong,
+      Boolean boxedBoolean,
+      Float boxedFloat,
+      Double boxedDouble,
+
+      byte[] byteArray,
+      char[] charArray,
+      short[] shortArray,
+      int[] intArray,
+      long[] longArray,
+      boolean[] booleanArray,
+      float[] floatArray,
+      double[] doubleArray,
+
+      Provider<byte[]> byteArrayProvider,
+      Provider<char[]> charArrayProvider,
+      Provider<short[]> shortArrayProvider,
+      Provider<int[]> intArrayProvider,
+      Provider<long[]> longArrayProvider,
+      Provider<boolean[]> booleanArrayProvider,
+      Provider<float[]> floatArrayProvider,
+      Provider<double[]> doubleArrayProvider,
+
+      Lazy<byte[]> lazyByteArray,
+      Lazy<char[]> lazyCharArray,
+      Lazy<short[]> lazyShortArray,
+      Lazy<int[]> lazyIntArray,
+      Lazy<long[]> lazyLongArray,
+      Lazy<boolean[]> lazyBooleanArray,
+      Lazy<float[]> lazy,
+      Lazy<double[]> lazyDoubleArray,
+
+      Thing thing,
+      Provider<Thing> thingProvider,
+      Lazy<Thing> lazyThing,
+      MembersInjector<Thing> thingMembersInjector) {}
+
+  @Inject void primitiveByte(byte primitiveByte) {}
+  @Inject void primitiveChar(char primitiveChar) {}
+  @Inject void primitiveShort(short primitiveShort) {}
+  @Inject void primitiveInt(int primitiveInt) {}
+  @Inject void primitiveLong(long primitiveLong) {}
+  @Inject void primitiveBoolean(boolean primitiveBoolean) {}
+  @Inject void primitiveFloat(float primitiveFloat) {}
+  @Inject void primitiveDouble(double primitiveDouble) {}
+
+  @Inject void byteProvider(Provider<Byte> byteProvider) {}
+  @Inject void charProvider(Provider<Character> charProvider) {}
+  @Inject void shortProvider(Provider<Short> shortProvider) {}
+  @Inject void intProvider(Provider<Integer> intProvider) {}
+  @Inject void longProvider(Provider<Long> longProvider) {}
+  @Inject void booleanProvider(Provider<Boolean> booleanProvider) {}
+  @Inject void floatProvider(Provider<Float> floatProvider) {}
+  @Inject void doubleProvider(Provider<Double> doubleProvider) {}
+
+  @Inject void lazyByte(Lazy<Byte> lazyByte) {}
+  @Inject void lazyChar(Lazy<Character> lazyChar) {}
+  @Inject void lazyShort(Lazy<Short> lazyShort) {}
+  @Inject void lazyInt(Lazy<Integer> lazyInt) {}
+  @Inject void lazyLong(Lazy<Long> lazyLong) {}
+  @Inject void lazyBoolean(Lazy<Boolean> lazyBoolean) {}
+  @Inject void lazyFloat(Lazy<Float> lazyFloat) {}
+  @Inject void lazyDouble(Lazy<Double> lazyDouble) {}
+
+  @Inject void boxedBype(Byte boxedBype) {}
+  @Inject void boxedChar(Character boxedChar) {}
+  @Inject void boxedShort(Short boxedShort) {}
+  @Inject void boxedInt(Integer boxedInt) {}
+  @Inject void boxedLong(Long boxedLong) {}
+  @Inject void boxedBoolean(Boolean boxedBoolean) {}
+  @Inject void boxedFloat(Float boxedFloat) {}
+  @Inject void boxedDouble(Double boxedDouble) {}
+
+  @Inject void byteArray(byte[] byteArray) {}
+  @Inject void charArray(char[] charArray) {}
+  @Inject void shortArray(short[] shortArray) {}
+  @Inject void intArray(int[] intArray) {}
+  @Inject void longArray(long[] longArray) {}
+  @Inject void booleanArray(boolean[] booleanArray) {}
+  @Inject void floatArray(float[] floatArray) {}
+  @Inject void doubleArray(double[] doubleArray) {}
+
+  @Inject void byteArrayProvider(Provider<byte[]> byteArrayProvider) {}
+  @Inject void charArrayProvider(Provider<char[]> charArrayProvider) {}
+  @Inject void shortArrayProvider(Provider<short[]> shortArrayProvider) {}
+  @Inject void intArrayProvider(Provider<int[]> intArrayProvider) {}
+  @Inject void longArrayProvider(Provider<long[]> longArrayProvider) {}
+  @Inject void booleanArrayProvider(Provider<boolean[]> booleanArrayProvider) {}
+  @Inject void floatArrayProvider(Provider<float[]> floatArrayProvider) {}
+  @Inject void doubleArrayProvider(Provider<double[]> doubleArrayProvider) {}
+
+  @Inject void lazyByteArray(Lazy<byte[]> lazyByteArray) {}
+  @Inject void lazyCharArray(Lazy<char[]> lazyCharArray) {}
+  @Inject void lazyShortArray(Lazy<short[]> lazyShortArray) {}
+  @Inject void lazyIntArray(Lazy<int[]> lazyIntArray) {}
+  @Inject void lazyLongArray(Lazy<long[]> lazyLongArray) {}
+  @Inject void lazyBooleanArray(Lazy<boolean[]> lazyBooleanArray) {}
+  @Inject void lazy(Lazy<float[]> lazy) {}
+  @Inject void lazyDoubleArray(Lazy<double[]> lazyDoubleArray) {}
+
+  @Inject void thing(Thing thing) {}
+  @Inject void thingProvider(Provider<Thing> thingProvider) {}
+  @Inject void lazyThing(Lazy<Thing> lazyThing) {}
+  @Inject void thingMembersInjector(MembersInjector<Thing> thingMembersInjector) {}
+}
diff --git a/javatests/dagger/functional/Injector.java b/javatests/dagger/functional/Injector.java
new file mode 100644
index 000000000..d001f93b2
--- /dev/null
+++ b/javatests/dagger/functional/Injector.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Lazy;
+import dagger.MembersInjector;
+import javax.inject.Provider;
+
+/**
+ * A simple interface that exercises all forms of injection for a given type.
+ */
+interface Injector<T> {
+  T instance();
+  Provider<T> provider();
+  Lazy<T> lazy();
+  MembersInjector<T> membersInjector();
+  void injectMembers(T t);
+  T injectMembersAndReturn(T t);
+}
diff --git a/javatests/dagger/functional/ModuleIncludesCollectedFromModuleSuperclasses.java b/javatests/dagger/functional/ModuleIncludesCollectedFromModuleSuperclasses.java
new file mode 100644
index 000000000..fb18b6ddf
--- /dev/null
+++ b/javatests/dagger/functional/ModuleIncludesCollectedFromModuleSuperclasses.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+
+/**
+ * This tests that @Module.includes are traversed for supertypes of a module.
+ */
+final class ModuleIncludesCollectedFromModuleSuperclasses {
+  @Component(modules = TopLevelModule.class)
+  interface C {
+    Foo<String> foo();
+    int includedInTopLevelModule();
+    String includedFromModuleInheritance();
+  }
+
+  @Module(includes = IncludedTopLevel.class)
+  static class TopLevelModule extends FooModule<String> {}
+
+  static class Foo<T> {}
+
+  @Module(includes = IncludedFromModuleInheritance.class)
+  abstract static class FooModule<T> extends FooCreator {
+    @Provides Foo<T> fooOfT() {
+      return createFoo();
+    }
+  }
+
+  static class FooCreator {
+    <T> Foo<T> createFoo() {
+      return new Foo<T>();
+    }
+  }
+
+  @Module
+  static class IncludedTopLevel {
+    @Provides int i() {
+      return 123;
+    }
+  }
+
+  @Module
+  static class IncludedFromModuleInheritance {
+    @Provides String inheritedProvision() {
+      return "inherited";
+    }
+  }
+}
diff --git a/javatests/dagger/functional/ModuleWithConflictingNames.java b/javatests/dagger/functional/ModuleWithConflictingNames.java
new file mode 100644
index 000000000..43dd58e17
--- /dev/null
+++ b/javatests/dagger/functional/ModuleWithConflictingNames.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+/**
+ * Module with bindings that might result in generated factories with conflicting field and
+ * parameter names.
+ */
+@Module
+final class ModuleWithConflictingNames {
+  @Provides
+  static Object object(int foo, Provider<String> fooProvider) {
+    return foo + fooProvider.get();
+  }
+
+  /**
+   * A class that might result in a generated factory with conflicting field and parameter names.
+   */
+  static class InjectedClassWithConflictingNames {
+    final int foo;
+    final Provider<String> fooProvider;
+
+    @Inject
+    InjectedClassWithConflictingNames(int foo, Provider<String> fooProvider) {
+      this.foo = foo;
+      this.fooProvider = fooProvider;
+    }
+  }
+}
diff --git a/javatests/dagger/functional/MultibindingComponent.java b/javatests/dagger/functional/MultibindingComponent.java
new file mode 100644
index 000000000..60ed5cf0d
--- /dev/null
+++ b/javatests/dagger/functional/MultibindingComponent.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Component;
+import dagger.functional.sub.ContributionsModule;
+import dagger.multibindings.StringKey;
+import java.util.Collection;
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Named;
+import javax.inject.Provider;
+
+@Component(
+  modules = {MultibindingModule.class, MultibindsModule.class, ContributionsModule.class},
+  dependencies = MultibindingDependency.class
+)
+interface MultibindingComponent {
+  Map<String, String> map();
+  Map<String, String[]> mapOfArrays();
+  Map<String, Provider<String>> mapOfProviders();
+  Set<String> mapKeys();
+  Collection<String> mapValues();
+  Set<Integer> set();
+  Map<NestedAnnotationContainer.NestedWrappedKey, String> nestedKeyMap();
+  Map<Class<? extends Number>, String> numberClassKeyMap();
+  Map<Class<?>, String> classKeyMap();
+  Map<Long, String> longKeyMap();
+  Map<Integer, String> integerKeyMap();
+  Map<Short, String> shortKeyMap();
+  Map<Byte, String> byteKeyMap();
+  Map<Boolean, String> booleanKeyMap();
+  Map<Character, String> characterKeyMap();
+  Map<StringKey, String> unwrappedAnnotationKeyMap();
+  Map<WrappedAnnotationKey, String> wrappedAnnotationKeyMap();
+  @Named("complexQualifier") Set<String> complexQualifierStringSet();
+  Set<Object> emptySet();
+
+  @Named("complexQualifier")
+  Set<Object> emptyQualifiedSet();
+
+  Map<String, Object> emptyMap();
+
+  @Named("complexQualifier")
+  Map<String, Object> emptyQualifiedMap();
+
+  Set<CharSequence> maybeEmptySet();
+
+  @Named("complexQualifier")
+  Set<CharSequence> maybeEmptyQualifiedSet();
+
+  Map<String, CharSequence> maybeEmptyMap();
+
+  @Named("complexQualifier")
+  Map<String, CharSequence> maybeEmptyQualifiedMap();
+}
diff --git a/javatests/dagger/functional/MultibindingDependency.java b/javatests/dagger/functional/MultibindingDependency.java
new file mode 100644
index 000000000..424005107
--- /dev/null
+++ b/javatests/dagger/functional/MultibindingDependency.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+interface MultibindingDependency {
+  double doubleDependency();
+}
diff --git a/javatests/dagger/functional/MultibindingModule.java b/javatests/dagger/functional/MultibindingModule.java
new file mode 100644
index 000000000..e16762810
--- /dev/null
+++ b/javatests/dagger/functional/MultibindingModule.java
@@ -0,0 +1,242 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.ClassKey;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntKey;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+import dagger.multibindings.LongKey;
+import dagger.multibindings.StringKey;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Named;
+import javax.inject.Provider;
+
+@Module
+class MultibindingModule {
+  @Provides
+  @IntoMap
+  @StringKey("foo")
+  static String provideFooKey(@SuppressWarnings("unused") double doubleDependency) {
+    return "foo value";
+  }
+
+  @Provides
+  @IntoMap
+  @StringKey("bar")
+  static String provideBarKey() {
+    return "bar value";
+  }
+
+  @Provides
+  @IntoMap
+  @StringKey("foo")
+  static String[] provideFooArrayValue(@SuppressWarnings("unused") double doubleDependency) {
+    return new String[] {"foo1", "foo2"};
+  }
+
+  @Provides
+  @IntoMap
+  @StringKey("bar")
+  static String[] provideBarArrayValue() {
+    return new String[] {"bar1", "bar2"};
+  }
+
+  @Provides
+  @IntoSet
+  static int provideFiveToSet() {
+    return 5;
+  }
+
+  @Provides
+  @IntoSet
+  static int provideSixToSet() {
+    return 6;
+  }
+
+  @Provides
+  @ElementsIntoSet
+  static Set<Integer> provideElementsIntoSet() {
+    Set<Integer> set = new HashSet<>();
+    set.add(-101);
+    set.add(-102);
+    return set;
+  }
+
+  @Provides
+  static Set<String> provideMapKeys(Map<String, Provider<String>> map) {
+    return map.keySet();
+  }
+
+  @Provides
+  static Collection<String> provideMapValues(Map<String, String> map) {
+    return map.values();
+  }
+
+  @Provides
+  @IntoMap
+  @NestedAnnotationContainer.NestedWrappedKey(Integer.class)
+  static String valueForInteger() {
+    return "integer";
+  }
+
+  @Provides
+  @IntoMap
+  @NestedAnnotationContainer.NestedWrappedKey(Long.class)
+  static String valueForLong() {
+    return "long";
+  }
+
+  @Provides
+  @IntoMap
+  @ClassKey(Integer.class)
+  static String valueForClassInteger() {
+    return "integer";
+  }
+
+  @Provides
+  @IntoMap
+  @ClassKey(Long.class)
+  static String valueForClassLong() {
+    return "long";
+  }
+
+  @Provides
+  @IntoMap
+  @NumberClassKey(BigDecimal.class)
+  static String valueForNumberClassBigDecimal() {
+    return "bigdecimal";
+  }
+
+  @Provides
+  @IntoMap
+  @NumberClassKey(BigInteger.class)
+  static String valueForNumberClassBigInteger() {
+    return "biginteger";
+  }
+
+  @Provides
+  @IntoMap
+  @LongKey(100)
+  static String valueFor100Long() {
+    return "100 long";
+  }
+
+  @Provides
+  @IntoMap
+  @IntKey(100)
+  static String valueFor100Int() {
+    return "100 int";
+  }
+
+  @Provides
+  @IntoMap
+  @ShortKey(100)
+  static String valueFor100Short() {
+    return "100 short";
+  }
+
+  @Provides
+  @IntoMap
+  @ByteKey(100)
+  static String valueFor100Byte() {
+    return "100 byte";
+  }
+
+  @Provides
+  @IntoMap
+  @BooleanKey(true)
+  static String valueForTrue() {
+    return "true";
+  }
+
+  @Provides
+  @IntoMap
+  @CharKey('a')
+  static String valueForA() {
+    return "a char";
+  }
+
+  @Provides
+  @IntoMap
+  @CharKey('\n')
+  static String valueForNewline() {
+    return "newline char";
+  }
+
+  @Provides
+  @IntoMap
+  @UnwrappedAnnotationKey(@StringKey("foo\n"))
+  static String valueForUnwrappedAnnotationKeyFoo() {
+    return "foo annotation";
+  }
+
+  @Provides
+  @IntoMap
+  @WrappedAnnotationKey(
+    value = @StringKey("foo"),
+    integers = {1, 2, 3},
+    annotations = {},
+    classes = {Long.class, Integer.class}
+  )
+  static String valueForWrappedAnnotationKeyFoo() {
+    return "wrapped foo annotation";
+  }
+
+  @Provides
+  @IntoSet
+  @Named("complexQualifier")
+  static String valueForComplexQualifierSet() {
+    return "foo";
+  }
+
+  @Provides
+  @IntoSet
+  static CharSequence setContribution() {
+    return "foo";
+  }
+
+  @Provides
+  @IntoSet
+  @Named("complexQualifier")
+  static CharSequence qualifiedSetContribution() {
+    return "qualified foo";
+  }
+
+  @Provides
+  @IntoMap
+  @StringKey("key")
+  static CharSequence mapContribution() {
+    return "foo value";
+  }
+
+  @Provides
+  @IntoMap
+  @Named("complexQualifier")
+  @StringKey("key")
+  static CharSequence qualifiedMapContribution() {
+    return "qualified foo value";
+  }
+}
diff --git a/javatests/dagger/functional/MultibindingTest.java b/javatests/dagger/functional/MultibindingTest.java
new file mode 100644
index 000000000..d99e46d12
--- /dev/null
+++ b/javatests/dagger/functional/MultibindingTest.java
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.auto.value.AutoAnnotation;
+import dagger.multibindings.ClassKey;
+import dagger.multibindings.StringKey;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.Map;
+import javax.inject.Provider;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for {@link MultibindingComponent}. */
+@RunWith(JUnit4.class)
+public class MultibindingTest {
+
+  private final MultibindingComponent multibindingComponent =
+      DaggerMultibindingComponent.builder().multibindingDependency(() -> 0.0).build();
+
+  @Test public void map() {
+    Map<String, String> map = multibindingComponent.map();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsEntry("foo", "foo value");
+    assertThat(map).containsEntry("bar", "bar value");
+  }
+
+  @Test public void mapOfArrays() {
+    Map<String, String[]> map = multibindingComponent.mapOfArrays();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsKey("foo");
+    assertThat(map.get("foo")).asList().containsExactly("foo1", "foo2").inOrder();
+    assertThat(map).containsKey("bar");
+    assertThat(map.get("bar")).asList().containsExactly("bar1", "bar2").inOrder();
+  }
+
+  @Test public void mapOfProviders() {
+    Map<String, Provider<String>> mapOfProviders = multibindingComponent.mapOfProviders();
+    assertThat(mapOfProviders).hasSize(2);
+    assertThat(mapOfProviders.get("foo").get()).isEqualTo("foo value");
+    assertThat(mapOfProviders.get("bar").get()).isEqualTo("bar value");
+  }
+
+  @Test public void mapKeysAndValues() {
+    assertThat(multibindingComponent.mapKeys())
+        .containsExactly("foo", "bar");
+    assertThat(multibindingComponent.mapValues())
+        .containsExactly("foo value", "bar value");
+  }
+
+  @Test public void nestedKeyMap() {
+    assertThat(multibindingComponent.nestedKeyMap())
+        .containsExactly(
+            nestedWrappedKey(Integer.class), "integer", nestedWrappedKey(Long.class), "long");
+  }
+
+  @Test
+  public void unwrappedAnnotationKeyMap() {
+    assertThat(multibindingComponent.unwrappedAnnotationKeyMap())
+        .containsExactly(testStringKey("foo\n"), "foo annotation");
+  }
+
+  @Test
+  public void wrappedAnnotationKeyMap() {
+    @SuppressWarnings("unchecked")
+    Class<? extends Number>[] classes = new Class[] {Long.class, Integer.class};
+    assertThat(multibindingComponent.wrappedAnnotationKeyMap())
+        .containsExactly(
+            testWrappedAnnotationKey(
+                testStringKey("foo"), new int[] {1, 2, 3}, new ClassKey[] {}, classes),
+            "wrapped foo annotation");
+  }
+
+  @Test
+  public void booleanKeyMap() {
+    assertThat(multibindingComponent.booleanKeyMap()).containsExactly(true, "true");
+  }
+
+  @Test
+  public void byteKeyMap() {
+    assertThat(multibindingComponent.byteKeyMap()).containsExactly((byte) 100, "100 byte");
+  }
+
+  @Test
+  public void charKeyMap() {
+    assertThat(multibindingComponent.characterKeyMap())
+        .containsExactly('a', "a char", '\n', "newline char");
+  }
+
+  @Test
+  public void classKeyMap() {
+    assertThat(multibindingComponent.classKeyMap())
+        .containsExactly(Integer.class, "integer", Long.class, "long");
+  }
+
+  @Test
+  public void numberClassKeyMap() {
+    assertThat(multibindingComponent.numberClassKeyMap())
+        .containsExactly(BigDecimal.class, "bigdecimal", BigInteger.class, "biginteger");
+  }
+
+  @Test
+  public void intKeyMap() {
+    assertThat(multibindingComponent.integerKeyMap()).containsExactly(100, "100 int");
+  }
+
+  @Test
+  public void longKeyMap() {
+    assertThat(multibindingComponent.longKeyMap()).containsExactly((long) 100, "100 long");
+  }
+
+  @Test
+  public void shortKeyMap() {
+    assertThat(multibindingComponent.shortKeyMap()).containsExactly((short) 100, "100 short");
+  }
+
+  @Test public void setBindings() {
+    assertThat(multibindingComponent.set())
+        .containsExactly(-90, -17, -1, 5, 6, 832, 1742, -101, -102);
+  }
+
+  @Test
+  public void complexQualifierSet() {
+    assertThat(multibindingComponent.complexQualifierStringSet()).containsExactly("foo");
+  }
+
+  @Test
+  public void emptySet() {
+    assertThat(multibindingComponent.emptySet()).isEmpty();
+  }
+
+  @Test
+  public void emptyQualifiedSet() {
+    assertThat(multibindingComponent.emptyQualifiedSet()).isEmpty();
+  }
+
+  @Test
+  public void emptyMap() {
+    assertThat(multibindingComponent.emptyMap()).isEmpty();
+  }
+
+  @Test
+  public void emptyQualifiedMap() {
+    assertThat(multibindingComponent.emptyQualifiedMap()).isEmpty();
+  }
+
+  @Test
+  public void maybeEmptySet() {
+    assertThat(multibindingComponent.maybeEmptySet()).containsExactly("foo");
+  }
+
+  @Test
+  public void maybeEmptyQualifiedSet() {
+    assertThat(multibindingComponent.maybeEmptyQualifiedSet()).containsExactly("qualified foo");
+  }
+
+  @Test
+  public void maybeEmptyMap() {
+    assertThat(multibindingComponent.maybeEmptyMap()).containsEntry("key", "foo value");
+  }
+
+  @Test
+  public void maybeEmptyQualifiedMap() {
+    assertThat(multibindingComponent.maybeEmptyQualifiedMap())
+        .containsEntry("key", "qualified foo value");
+  }
+
+  @AutoAnnotation
+  static StringKey testStringKey(String value) {
+    return new AutoAnnotation_MultibindingTest_testStringKey(value);
+  }
+
+  @AutoAnnotation
+  static NestedAnnotationContainer.NestedWrappedKey nestedWrappedKey(Class<?> value) {
+    return new AutoAnnotation_MultibindingTest_nestedWrappedKey(value);
+  }
+
+  @AutoAnnotation
+  static WrappedAnnotationKey testWrappedAnnotationKey(
+      StringKey value, int[] integers, ClassKey[] annotations, Class<? extends Number>[] classes) {
+    return new AutoAnnotation_MultibindingTest_testWrappedAnnotationKey(
+        value, integers, annotations, classes);
+  }
+}
diff --git a/javatests/dagger/functional/MultibindsModule.java b/javatests/dagger/functional/MultibindsModule.java
new file mode 100644
index 000000000..65ba7c82d
--- /dev/null
+++ b/javatests/dagger/functional/MultibindsModule.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Module;
+import dagger.multibindings.Multibinds;
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Named;
+
+/**
+ * A module that uses {@link Multibinds @Multibinds}-annotated abstract methods to declare
+ * multibindings.
+ */
+@Module
+abstract class MultibindsModule {
+
+  @Multibinds
+  abstract Set<Object> emptySet();
+
+  @Multibinds
+  abstract Map<String, Object> emptyMap();
+
+  @Multibinds
+  abstract Set<CharSequence> set();
+
+  @Multibinds
+  abstract Map<String, CharSequence> map();
+
+  @Multibinds
+  @Named("complexQualifier")
+  abstract Set<Object> emptyQualifiedSet();
+
+  @Multibinds
+  @Named("complexQualifier")
+  abstract Map<String, Object> emptyQualifiedMap();
+
+  @Multibinds
+  @Named("complexQualifier")
+  abstract Set<CharSequence> qualifiedSet();
+
+  @Multibinds
+  @Named("complexQualifier")
+  abstract Map<String, CharSequence> qualifiedMap();
+}
diff --git a/javatests/dagger/functional/NeedsFactory.java b/javatests/dagger/functional/NeedsFactory.java
new file mode 100644
index 000000000..2ea01ec69
--- /dev/null
+++ b/javatests/dagger/functional/NeedsFactory.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import com.google.auto.factory.AutoFactory;
+import javax.inject.Inject;
+
+class NeedsFactory {
+  @Inject
+  NeedsFactory(@SuppressWarnings("unused") NeedsFactory_SomethingFactory somethingFactory) {}
+
+  @AutoFactory
+  static class Something {}
+}
+
diff --git a/javatests/dagger/functional/NestedAnnotationContainer.java b/javatests/dagger/functional/NestedAnnotationContainer.java
new file mode 100644
index 000000000..a2b61fa13
--- /dev/null
+++ b/javatests/dagger/functional/NestedAnnotationContainer.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.MapKey;
+
+public final class NestedAnnotationContainer {
+
+  @MapKey(unwrapValue = false)
+  @interface NestedWrappedKey {
+    Class<?> value();
+  }
+}
diff --git a/javatests/dagger/functional/NestedTest.java b/javatests/dagger/functional/NestedTest.java
new file mode 100644
index 000000000..c1e21b23e
--- /dev/null
+++ b/javatests/dagger/functional/NestedTest.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class NestedTest {
+  @Test public void nestedFoo() {
+    OuterClassFoo.NestedComponent nestedFoo = DaggerOuterClassFoo_NestedComponent.create();
+    assertThat(nestedFoo.thing()).isNotNull();
+  }
+
+  @Test public void nestedBar() {
+    OuterClassBar.NestedComponent nestedBar = DaggerOuterClassBar_NestedComponent.create();
+    assertThat(nestedBar.injectedThing()).isNotNull();
+  }
+}
diff --git a/javatests/dagger/functional/NonComponentDependencyComponent.java b/javatests/dagger/functional/NonComponentDependencyComponent.java
new file mode 100644
index 000000000..ee679fae9
--- /dev/null
+++ b/javatests/dagger/functional/NonComponentDependencyComponent.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Component;
+import dagger.functional.sub.OtherThing;
+import javax.inject.Inject;
+
+@Component(dependencies = {NonComponentDependencyComponent.ThingComponent.class})
+interface NonComponentDependencyComponent {
+  ThingTwo thingTwo();
+
+  static class ThingTwo {
+    @SuppressWarnings("unused")
+    @Inject
+    ThingTwo(
+        Thing thing,
+        NonComponentDependencyComponent nonComponentDependencyComponent,
+        NonComponentDependencyComponent.ThingComponent thingComponent) {}
+  }
+
+  // A non-component interface which this interface depends upon.
+  interface ThingComponent {
+    Thing thing();
+  }
+
+  // The implementation for that interface.
+  static class ThingComponentImpl implements ThingComponent {
+    @Override
+    public Thing thing() {
+      return new Thing(new OtherThing(1));
+    }
+  }
+}
diff --git a/javatests/dagger/functional/NonComponentDependencyTest.java b/javatests/dagger/functional/NonComponentDependencyTest.java
new file mode 100644
index 000000000..436183fbb
--- /dev/null
+++ b/javatests/dagger/functional/NonComponentDependencyTest.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class NonComponentDependencyTest {
+  @Test public void testThing() {
+    NonComponentDependencyComponent component =
+        DaggerNonComponentDependencyComponent.builder()
+            .thingComponent(new NonComponentDependencyComponent.ThingComponentImpl())
+            .build();
+    assertThat(component).isNotNull();
+    assertThat(component.thingTwo()).isNotNull();
+  }
+}
diff --git a/javatests/dagger/functional/NullableModule.java b/javatests/dagger/functional/NullableModule.java
new file mode 100644
index 000000000..406024f17
--- /dev/null
+++ b/javatests/dagger/functional/NullableModule.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class NullableModule {
+  /**
+   * A {@code Nullable} that isn't {@link javax.annotation.Nullable}, to ensure that Dagger can be
+   * built without depending on JSR-305.
+   */
+  @interface Nullable {}
+
+  @Provides
+  @Nullable
+  static Object nullObject() {
+    return null;
+  }
+}
diff --git a/javatests/dagger/functional/NumberClassKey.java b/javatests/dagger/functional/NumberClassKey.java
new file mode 100644
index 000000000..5909a9fb4
--- /dev/null
+++ b/javatests/dagger/functional/NumberClassKey.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = true)
+@interface NumberClassKey {
+  Class<? extends Number> value();
+}
diff --git a/javatests/dagger/functional/OuterClassBar.java b/javatests/dagger/functional/OuterClassBar.java
new file mode 100644
index 000000000..b455595b2
--- /dev/null
+++ b/javatests/dagger/functional/OuterClassBar.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Component;
+
+final class OuterClassBar {
+  @Component(modules = PrimitivesModule.class)
+  interface NestedComponent {
+    InjectedThing injectedThing();
+  }
+}
diff --git a/javatests/dagger/functional/OuterClassFoo.java b/javatests/dagger/functional/OuterClassFoo.java
new file mode 100644
index 000000000..213bd804c
--- /dev/null
+++ b/javatests/dagger/functional/OuterClassFoo.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Component;
+
+final class OuterClassFoo {
+  @Component(modules = PrimitivesModule.class)
+  interface NestedComponent {
+    Thing thing();
+  }
+}
diff --git a/javatests/dagger/functional/ParentModule.java b/javatests/dagger/functional/ParentModule.java
new file mode 100644
index 000000000..8bd4fea3e
--- /dev/null
+++ b/javatests/dagger/functional/ParentModule.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Module;
+import dagger.Provides;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+
+@Module
+abstract class ParentModule<A extends Number & Comparable<A>, B, C extends Iterable<A>> {
+  @Provides Iterable<A> provideIterableOfAWithC(A a, C c) {
+    List<A> list = new ArrayList<>();
+    list.add(a);
+    for (A elt : c) {
+      list.add(elt);
+    }
+    return list;
+  }
+
+  @Provides static char provideNonGenericBindingInParameterizedModule() {
+    return 'c';
+  }
+
+  @Provides
+  static List<Set<String>> provideStaticGenericTypeWithNoTypeParametersInParameterizedModule() {
+    return new ArrayList<>();
+  }
+}
diff --git a/javatests/dagger/functional/PrimitivesModule.java b/javatests/dagger/functional/PrimitivesModule.java
new file mode 100644
index 000000000..7b7203bc4
--- /dev/null
+++ b/javatests/dagger/functional/PrimitivesModule.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class PrimitivesModule {
+  static final byte BOUND_BYTE = -41;
+  static final char BOUND_CHAR = 'g';
+  static final short BOUND_SHORT = 21840;
+  static final int BOUND_INT = 1894833693;
+  static final long BOUND_LONG = -4369839828653523584L;
+  static final boolean BOUND_BOOLEAN = true;
+  static final float BOUND_FLOAT = (float) 0.9964542;
+  static final double BOUND_DOUBLE = 0.12681322049667765;
+
+  /*
+   * While we can't ensure that these constants stay constant, this is a test so we're just going to
+   * keep our fingers crossed that we're not going to be jerks.
+   */
+  static final byte[] BOUND_BYTE_ARRAY =  {1, 2, 3};
+  static final char[] BOUND_CHAR_ARRAY = {'g', 'a', 'k'};
+  static final short[] BOUND_SHORT_ARRAY = {2, 4};
+  static final int[] BOUND_INT_ARRAY = {3, 1, 2};
+  static final long[] BOUND_LONG_ARRAY = {1, 1, 2, 3, 5};
+  static final boolean[] BOUND_BOOLEAN_ARRAY = {false, true, false, false};
+  static final float[] BOUND_FLOAT_ARRAY = {(float) 0.1, (float) 0.01, (float) 0.001};
+  static final double[] BOUND_DOUBLE_ARRAY = {0.2, 0.02, 0.002};
+
+  @Provides static byte provideByte() {
+    return BOUND_BYTE;
+  }
+
+  @Provides static char provideChar() {
+    return BOUND_CHAR;
+  }
+
+  @Provides static short provideShort() {
+    return BOUND_SHORT;
+  }
+
+  @Provides static int provideInt() {
+    return BOUND_INT;
+  }
+
+  @Provides static long provideLong() {
+    return BOUND_LONG;
+  }
+
+  @Provides static boolean provideBoolean() {
+    return BOUND_BOOLEAN;
+  }
+
+  @Provides static float provideFloat() {
+    return BOUND_FLOAT;
+  }
+
+  @Provides static double boundDouble() {
+    return BOUND_DOUBLE;
+  }
+
+  @Provides static byte[] provideByteArray() {
+    return BOUND_BYTE_ARRAY;
+  }
+
+  @Provides static char[] provideCharArray() {
+    return BOUND_CHAR_ARRAY;
+  }
+
+  @Provides static short[] provideShortArray() {
+    return BOUND_SHORT_ARRAY;
+  }
+
+  @Provides static int[] provideIntArray() {
+    return BOUND_INT_ARRAY;
+  }
+
+  @Provides static long[] provideLongArray() {
+    return BOUND_LONG_ARRAY;
+  }
+
+  @Provides static boolean[] provideBooleanArray() {
+    return BOUND_BOOLEAN_ARRAY;
+  }
+
+  @Provides static float[] provideFloatArray() {
+    return BOUND_FLOAT_ARRAY;
+  }
+
+  @Provides static double[] boundDoubleArray() {
+    return BOUND_DOUBLE_ARRAY;
+  }
+}
diff --git a/javatests/dagger/functional/ReferencesGeneric.java b/javatests/dagger/functional/ReferencesGeneric.java
new file mode 100644
index 000000000..c83dbcced
--- /dev/null
+++ b/javatests/dagger/functional/ReferencesGeneric.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import javax.inject.Inject;
+
+class ReferencesGeneric {
+  final Generic<A> genericA;
+  
+  @Inject ReferencesGeneric(Generic<A> genericA) {
+    this.genericA = genericA;
+  }
+}
diff --git a/javatests/dagger/functional/ReleasableReferencesComponents.java b/javatests/dagger/functional/ReleasableReferencesComponents.java
new file mode 100644
index 000000000..4717e8970
--- /dev/null
+++ b/javatests/dagger/functional/ReleasableReferencesComponents.java
@@ -0,0 +1,225 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import static dagger.functional.ReleasableReferencesComponents.Thing.thing;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import com.google.auto.value.AutoValue;
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.multibindings.ClassKey;
+import dagger.multibindings.IntoMap;
+import dagger.releasablereferences.CanReleaseReferences;
+import dagger.releasablereferences.ForReleasableReferences;
+import dagger.releasablereferences.ReleasableReferenceManager;
+import dagger.releasablereferences.TypedReleasableReferenceManager;
+import java.lang.annotation.Retention;
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Scope;
+
+final class ReleasableReferencesComponents {
+
+  interface ThingComponent {
+    /**
+     * A map whose keys are the scope annotations for each value. For unscoped values, the key is
+     * the module that contains the unscoped binding. So for {@link Parent}, the unscoped {@link
+     * Thing}'s key is {@link ParentModule ParentModule.class}; for {@link Child}, it is {@link
+     * ChildModule ChildModule.class}.
+     */
+    Map<Class<?>, Thing> things();
+  }
+
+  @ParentRegularScope
+  @ParentReleasableScope1
+  @ParentReleasableScope2
+  @Component(modules = ParentModule.class)
+  interface Parent extends ThingComponent {
+
+    Set<ReleasableReferenceManager> managers();
+
+    Set<TypedReleasableReferenceManager<Metadata1>> typedReleasableReferenceManagers1();
+
+    Set<TypedReleasableReferenceManager<Metadata2>> typedReleasableReferenceManagers2();
+
+    @ForReleasableReferences(ParentReleasableScope1.class)
+    ReleasableReferenceManager parentReleasableScope1Manager();
+
+    @ForReleasableReferences(ParentReleasableScope2.class)
+    ReleasableReferenceManager parentReleasableScope2Manager();
+
+    @ForReleasableReferences(ParentReleasableScope2.class)
+    TypedReleasableReferenceManager<Metadata1> parentReleasableScope2TypedReferenceManager();
+
+    @ForReleasableReferences(ChildReleasableScope1.class)
+    ReleasableReferenceManager childReleasableScope1Manager();
+
+    @ForReleasableReferences(ChildReleasableScope2.class)
+    ReleasableReferenceManager childReleasableScope2Manager();
+
+    @ForReleasableReferences(ChildReleasableScope2.class)
+    TypedReleasableReferenceManager<Metadata1> childReleasableScope2TypedReferenceManager1();
+
+    @ForReleasableReferences(ChildReleasableScope2.class)
+    TypedReleasableReferenceManager<Metadata2> childReleasableScope2TypedReferenceManager2();
+
+    Child child();
+  }
+
+  @AutoValue
+  abstract static class Thing {
+    abstract int count();
+
+    static Thing thing(int count) {
+      return new AutoValue_ReleasableReferencesComponents_Thing(count);
+    }
+  }
+
+  @ChildRegularScope
+  @ChildReleasableScope1
+  @ChildReleasableScope2
+  @ChildReleasableScope3
+  @Subcomponent(modules = ChildModule.class)
+  interface Child extends ThingComponent {}
+
+  @CanReleaseReferences
+  @interface Metadata1 {
+    String value();
+  }
+
+  @CanReleaseReferences
+  @interface Metadata2 {
+    String value();
+  }
+
+  @Retention(RUNTIME)
+  @Scope
+  @interface ParentRegularScope {}
+
+  @Retention(RUNTIME)
+  @Scope
+  @interface ChildRegularScope {}
+
+  @Retention(RUNTIME)
+  @CanReleaseReferences
+  @Scope
+  @interface ParentReleasableScope1 {}
+
+  @Retention(RUNTIME)
+  @Metadata1("ParentReleasableScope2")
+  @Scope
+  @interface ParentReleasableScope2 {}
+
+  @Retention(RUNTIME)
+  @Metadata2("ChildReleasableScope1")
+  @Scope
+  @interface ChildReleasableScope1 {}
+
+  @Retention(RUNTIME)
+  @Metadata1("ChildReleasableScope2.1")
+  @Metadata2("ChildReleasableScope2.2")
+  @Scope
+  @interface ChildReleasableScope2 {}
+
+  @Retention(RUNTIME)
+  @Metadata1("ChildReleasableScope3.1")
+  @Metadata2("ChildReleasableScope3.2")
+  @CanReleaseReferences
+  @Scope
+  @interface ChildReleasableScope3 {}
+
+  @Module
+  static final class ParentModule {
+    private int unscopedCount;
+    private int regularScopeCount;
+    private int releasableScope1Count;
+    private int releasableScope2Count;
+
+    @Provides
+    @IntoMap
+    @ClassKey(ParentModule.class)
+    Thing parentUnscopedThing() {
+      return thing(++unscopedCount);
+    }
+
+    @Provides
+    @IntoMap
+    @ClassKey(ParentRegularScope.class)
+    @ParentRegularScope
+    Thing regularScopedThing() {
+      return thing(++regularScopeCount);
+    }
+
+    @Provides
+    @IntoMap
+    @ClassKey(ParentReleasableScope1.class)
+    @ParentReleasableScope1
+    Thing releasableScope1Thing() {
+      return thing(++releasableScope1Count);
+    }
+
+    @Provides
+    @IntoMap
+    @ClassKey(ParentReleasableScope2.class)
+    @ParentReleasableScope2
+    Thing releasableScope2Thing() {
+      return thing(++releasableScope2Count);
+    }
+  }
+
+  @Module
+  static final class ChildModule {
+    private int unscopedCount;
+    private int regularScopeCount;
+    private int releasableScope1Count;
+    private int releasableScope2Count;
+
+    @Provides
+    @IntoMap
+    @ClassKey(ChildModule.class)
+    Thing childUnscopedThing() {
+      return thing(++unscopedCount);
+    }
+
+    @Provides
+    @IntoMap
+    @ClassKey(ChildRegularScope.class)
+    @ChildRegularScope
+    Thing regularScopedThing() {
+      return thing(++regularScopeCount);
+    }
+
+    @Provides
+    @IntoMap
+    @ClassKey(ChildReleasableScope1.class)
+    @ChildReleasableScope1
+    Thing releasableScope1Thing() {
+      return thing(++releasableScope1Count);
+    }
+
+    @Provides
+    @IntoMap
+    @ClassKey(ChildReleasableScope2.class)
+    @ChildReleasableScope2
+    Thing releasableScope2Thing() {
+      return thing(++releasableScope2Count);
+    }
+  }
+}
diff --git a/javatests/dagger/functional/ReleasableReferencesComponentsTest.java b/javatests/dagger/functional/ReleasableReferencesComponentsTest.java
new file mode 100644
index 000000000..2e30791f3
--- /dev/null
+++ b/javatests/dagger/functional/ReleasableReferencesComponentsTest.java
@@ -0,0 +1,381 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import static com.google.common.truth.Truth.assertThat;
+import static dagger.functional.ReleasableReferencesComponents.Thing.thing;
+
+import com.google.auto.value.AutoAnnotation;
+import com.google.common.base.Function;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ListMultimap;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Multimaps;
+import com.google.common.testing.GcFinalization;
+import com.google.common.testing.GcFinalization.FinalizationPredicate;
+import dagger.functional.ReleasableReferencesComponents.Child;
+import dagger.functional.ReleasableReferencesComponents.ChildModule;
+import dagger.functional.ReleasableReferencesComponents.ChildRegularScope;
+import dagger.functional.ReleasableReferencesComponents.ChildReleasableScope1;
+import dagger.functional.ReleasableReferencesComponents.ChildReleasableScope2;
+import dagger.functional.ReleasableReferencesComponents.ChildReleasableScope3;
+import dagger.functional.ReleasableReferencesComponents.Metadata1;
+import dagger.functional.ReleasableReferencesComponents.Parent;
+import dagger.functional.ReleasableReferencesComponents.ParentModule;
+import dagger.functional.ReleasableReferencesComponents.ParentRegularScope;
+import dagger.functional.ReleasableReferencesComponents.ParentReleasableScope1;
+import dagger.functional.ReleasableReferencesComponents.ParentReleasableScope2;
+import dagger.functional.ReleasableReferencesComponents.Thing;
+import dagger.functional.ReleasableReferencesComponents.ThingComponent;
+import dagger.releasablereferences.ReleasableReferenceManager;
+import dagger.releasablereferences.TypedReleasableReferenceManager;
+import java.lang.annotation.Annotation;
+import java.lang.ref.WeakReference;
+import java.util.Map;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class ReleasableReferencesComponentsTest {
+
+  private Parent component;
+  private ParentAsserts parentAsserts;
+  private ChildAsserts childAsserts;
+
+  @Before
+  public void setUp() {
+    component = DaggerReleasableReferencesComponents_Parent.create();
+    parentAsserts = new ParentAsserts(component);
+    childAsserts = parentAsserts.newChildAsserts();
+  }
+
+  @Test
+  public void releasableReferenceManagers() {
+    ImmutableMap<Class<? extends Annotation>, ReleasableReferenceManager> managers =
+        Maps.uniqueIndex(
+            component.managers(),
+            new Function<ReleasableReferenceManager, Class<? extends Annotation>>() {
+              @Override
+              public Class<? extends Annotation> apply(
+                  ReleasableReferenceManager releasableReferenceManager) {
+                return releasableReferenceManager.scope();
+              }
+            });
+    assertThat(managers)
+        .containsEntry(ParentReleasableScope1.class, component.parentReleasableScope1Manager());
+    assertThat(managers)
+        .containsEntry(ParentReleasableScope2.class, component.parentReleasableScope2Manager());
+    assertThat(managers)
+        .containsEntry(ChildReleasableScope1.class, component.childReleasableScope1Manager());
+    assertThat(managers)
+        .containsEntry(ChildReleasableScope2.class, component.childReleasableScope2Manager());
+    // Should contain a manager for ChildReleasableScope3 even though
+    // @ForReleasableReferences(Scope5.class) isn't needed.
+    assertThat(managers).containsKey(ChildReleasableScope3.class);
+  }
+
+  @Test
+  public void setOfTypedReleasableReferenceManagers() {
+    ListMultimap<Class<? extends Annotation>, Metadata1> managers =
+        Multimaps.transformValues(
+            Multimaps.index(
+                component.typedReleasableReferenceManagers1(),
+                new Function<TypedReleasableReferenceManager<?>, Class<? extends Annotation>>() {
+                  @Override
+                  public Class<? extends Annotation> apply(
+                      TypedReleasableReferenceManager<?> releasableReferenceManager) {
+                    return releasableReferenceManager.scope();
+                  }
+                }),
+            new Function<TypedReleasableReferenceManager<Metadata1>, Metadata1>() {
+              @Override
+              public Metadata1 apply(TypedReleasableReferenceManager<Metadata1> manager) {
+                return manager.metadata();
+              }
+            });
+    assertThat(managers)
+        .containsEntry(ParentReleasableScope2.class, metadata1("ParentReleasableScope2"));
+    assertThat(managers)
+        .containsEntry(ChildReleasableScope2.class, metadata1("ChildReleasableScope2.1"));
+    assertThat(managers)
+        .containsEntry(ChildReleasableScope3.class, metadata1("ChildReleasableScope3.1"));
+  }
+
+  @AutoAnnotation
+  static Metadata1 metadata1(String value) {
+    return new AutoAnnotation_ReleasableReferencesComponentsTest_metadata1(value);
+  }
+
+  @Test
+  public void basicScopingWorks() {
+    assertBindingCallCounts();
+    // assert again to make sure that the scoped bindings aren't called again
+    assertBindingCallCounts();
+  }
+
+  @Test
+  public void releaseThenGc() {
+    assertBindingCallCounts();
+    component.parentReleasableScope1Manager().releaseStrongReferences(); // release scope 1
+    assertBindingCallCounts(); // no change to scoped bindings
+    gcAndWaitUntilWeakReferencesCleared(
+        ParentModule.class, ChildModule.class, ParentReleasableScope1.class); // GC
+    parentAsserts.expectedCallsForParentReleasableScope1Thing++; // expect scope 1 bindings again
+    assertBindingCallCounts();
+  }
+
+  @Test
+  public void releaseThenRestoreThenGcThenRelease() {
+    assertBindingCallCounts();
+    component.parentReleasableScope2Manager().releaseStrongReferences(); // release scope 2
+    assertBindingCallCounts(); // no change to scoped bindings
+    component.parentReleasableScope2Manager().restoreStrongReferences(); // restore scope 2
+    assertBindingCallCounts(); // no change to scoped bindings
+    gcAndWaitUntilWeakReferencesCleared(ParentModule.class, ChildModule.class); // GC
+    assertBindingCallCounts(); // no change to scoped bindings
+
+    // Releasing again and GCing again means the binding is executed again.
+    component.parentReleasableScope2Manager().releaseStrongReferences(); // release scope 2
+    assertBindingCallCounts(); // no change to scoped bindings
+    gcAndWaitUntilWeakReferencesCleared(
+        ParentModule.class, ChildModule.class, ParentReleasableScope2.class); // GC
+    parentAsserts.expectedCallsForParentReleasableScope2Thing++; // expect scope 2 bindings again
+    assertBindingCallCounts();
+  }
+
+  @Test
+  public void subcomponentReleaseThenGc() {
+    assertBindingCallCounts();
+    component.childReleasableScope1Manager().releaseStrongReferences(); // release scope 3
+    assertBindingCallCounts(); // no change to scoped bindings
+    gcAndWaitUntilWeakReferencesCleared(
+        ParentModule.class, ChildModule.class, ChildReleasableScope1.class); // GC
+    childAsserts.expectedCallsForChildReleasableScope1Thing++; // expect scope 3 bindings again
+    assertBindingCallCounts();
+  }
+
+  @Test
+  public void subcomponentReleaseThenRestoreThenGcThenRelease() {
+    assertBindingCallCounts();
+    component.childReleasableScope2Manager().releaseStrongReferences(); // release scope 4
+    assertBindingCallCounts(); // no change to scoped bindings
+    component.childReleasableScope2Manager().restoreStrongReferences(); // restore scope 4
+    gcAndWaitUntilWeakReferencesCleared(ParentModule.class, ChildModule.class); // GC
+    assertBindingCallCounts(); // no change to scoped bindings
+    component.childReleasableScope2Manager().releaseStrongReferences(); // release scope 4
+    gcAndWaitUntilWeakReferencesCleared(
+        ParentModule.class, ChildModule.class, ChildReleasableScope2.class); // GC
+    childAsserts.expectedCallsForChildReleasableScope2Thing++; // expect scope 4 bindings again
+    assertBindingCallCounts();
+  }
+
+  @Test
+  public void twoInstancesOfSameSubcomponent() {
+    // Two instances of the same subcomponent.
+    ChildAsserts child2Asserts = parentAsserts.newChildAsserts();
+    childAsserts.assertBindingCallCounts();
+    child2Asserts.assertBindingCallCounts();
+
+    component.childReleasableScope1Manager().releaseStrongReferences(); // release scope 3
+    childAsserts.assertBindingCallCounts(); // no change to scoped bindings in child 1
+    child2Asserts.assertBindingCallCounts(); // no change to scoped bindings in child 2
+    gcAndWaitUntilWeakReferencesCleared(
+        ParentModule.class, ChildModule.class, ChildReleasableScope1.class); // GC
+    childAsserts.expectedCallsForChildReleasableScope1Thing++; // expect scope 3 bindings again
+    childAsserts.assertBindingCallCounts(); // when calling child.things()
+    child2Asserts.expectedCallsForChildReleasableScope1Thing++; // expect scope 3 bindings yet again
+    child2Asserts.assertBindingCallCounts(); // when calling child2.things()
+  }
+
+  private void assertBindingCallCounts() {
+    parentAsserts.assertBindingCallCounts();
+    childAsserts.assertBindingCallCounts();
+  }
+
+  /**
+   * Tries to run garbage collection, and waits for the {@link WeakReference}s to the {@link Thing}s
+   * in the maps last returned by {@link Parent#things()} and {@link Child#things()} for {@code
+   * keys} to be cleared.
+   */
+  void gcAndWaitUntilWeakReferencesCleared(final Class<?>... keys) {
+    GcFinalization.awaitDone(
+        new FinalizationPredicate() {
+          @Override
+          public boolean isDone() {
+            for (Class<?> key : keys) {
+              if (parentAsserts.weakThingReferenceUncollected(key)
+                  || childAsserts.weakThingReferenceUncollected(key)) {
+                return false;
+              }
+            }
+            return true;
+          }
+        });
+  }
+
+  /**
+   * Asserts that the map of {@link Thing}s in a {@link ThingComponent} matches expected values. Can
+   * also tell when certain values in the map have been finalized.
+   */
+  private abstract static class ThingAsserts {
+
+    private final ThingComponent component;
+    private ImmutableMap<Class<?>, WeakReference<Thing>> weakThings = ImmutableMap.of();
+
+    protected ThingAsserts(ThingComponent component) {
+      this.component = component;
+    }
+
+    /**
+     * Asserts that {@code component.things()} returns an expected map. Each time this is called,
+     * the current values in the map are wrapped in {@link WeakReference}s so we can {@linkplain
+     * #weakThingReferenceUncollected(Object) check whether they've been cleared} later.
+     */
+    final void assertBindingCallCounts() {
+      Map<Class<?>, Thing> things = component.things();
+      assertThat(things).containsExactlyEntriesIn(expectedThingMap());
+      weakThings =
+          ImmutableMap.copyOf(
+              Maps.transformValues(
+                  things,
+                  new Function<Thing, WeakReference<Thing>>() {
+                    @Override
+                    public WeakReference<Thing> apply(Thing thing) {
+                      return new WeakReference<>(thing);
+                    }
+                  }));
+    }
+
+    /** Returns the expected map. */
+    protected abstract ImmutableMap<Class<?>, Thing> expectedThingMap();
+
+    /**
+     * Returns {@code true} if the {@link WeakReference} to the {@link Thing} in the map returned by
+     * the last call to {@link #assertBindingCallCounts()} for the given key has not been cleared.
+     */
+    boolean weakThingReferenceUncollected(Object key) {
+      WeakReference<Thing> weakThing = weakThings.get(key);
+      return weakThing != null && weakThing.get() != null;
+    }
+  }
+
+  /** Asserts for the {@link Thing}s returned by {@link Parent#things()}. */
+  private static final class ParentAsserts extends ThingAsserts {
+    final Parent parent;
+
+    /**
+     * The number of times we expect the {@code @Provides @IntoMap @ClassKey(ParentModule.class)
+     * Thing} provider to have been called.
+     */
+    int expectedCallsForParentUnscopedThing;
+
+    /**
+     * The number of times we expect the
+     * {@code @Provides @IntoMap @ClassKey(ParentRegularScope.class) Thing} provider to have been
+     * called.
+     */
+    int expectedCallsForParentRegularScopeThing = 1;
+
+    /**
+     * The number of times we expect the
+     * {@code @Provides @IntoMap @ClassKey(ParentReleasableScope1.class) Thing} provider to have
+     * been called.
+     */
+    int expectedCallsForParentReleasableScope1Thing = 1;
+
+    /**
+     * The number of times we expect the
+     * {@code @Provides @IntoMap @ClassKey(ParentReleasableScope2.class) Thing} provider to have
+     * been called.
+     */
+    int expectedCallsForParentReleasableScope2Thing = 1;
+
+    ParentAsserts(Parent parent) {
+      super(parent);
+      this.parent = parent;
+    }
+
+    /**
+     * Returns an object that can make assertions for the {@link Thing}s returned by {@link
+     * Child#things()}.
+     */
+    ChildAsserts newChildAsserts() {
+      return new ChildAsserts(this, parent.child());
+    }
+
+    @Override
+    protected ImmutableMap<Class<?>, Thing> expectedThingMap() {
+      ++expectedCallsForParentUnscopedThing; // unscoped Thing @Provides method is always called
+      return ImmutableMap.of(
+          ParentModule.class, thing(expectedCallsForParentUnscopedThing),
+          ParentRegularScope.class, thing(expectedCallsForParentRegularScopeThing),
+          ParentReleasableScope1.class, thing(expectedCallsForParentReleasableScope1Thing),
+          ParentReleasableScope2.class, thing(expectedCallsForParentReleasableScope2Thing));
+    }
+  }
+
+  /** Asserts for the {@link Thing}s returned by {@link Child#things()}. */
+  private static final class ChildAsserts extends ThingAsserts {
+    final ParentAsserts parentAsserts;
+
+    /**
+     * The number of times we expect the {@code @Provides @IntoMap @ClassKey(ChildModule.class)
+     * Thing} provider to have been called.
+     */
+    int expectedCallsForChildUnscopedThing;
+
+    /**
+     * The number of times we expect the
+     * {@code @Provides @IntoMap @ClassKey(ChildRegularScope.class) Thing} provider to have been
+     * called.
+     */
+    int expectedCallsForChildRegularScopeThing = 1;
+
+    /**
+     * The number of times we expect the
+     * {@code @Provides @IntoMap @ClassKey(ChildReleasableScope1.class) Thing} provider to have been
+     * called.
+     */
+    int expectedCallsForChildReleasableScope1Thing = 1;
+
+    /**
+     * The number of times we expect the
+     * {@code @Provides @IntoMap @ClassKey(ChildReleasableScope2.class) Thing} provider to have been
+     * called.
+     */
+    int expectedCallsForChildReleasableScope2Thing = 1;
+
+    ChildAsserts(ParentAsserts parentAsserts, Child child) {
+      super(child);
+      this.parentAsserts = parentAsserts;
+    }
+
+    @Override
+    protected ImmutableMap<Class<?>, Thing> expectedThingMap() {
+      ++expectedCallsForChildUnscopedThing; // unscoped Thing @Provides method is always called
+      return new ImmutableMap.Builder<Class<?>, Thing>()
+          .putAll(parentAsserts.expectedThingMap())
+          .put(ChildModule.class, thing(expectedCallsForChildUnscopedThing))
+          .put(ChildRegularScope.class, thing(expectedCallsForChildRegularScopeThing))
+          .put(ChildReleasableScope1.class, thing(expectedCallsForChildReleasableScope1Thing))
+          .put(ChildReleasableScope2.class, thing(expectedCallsForChildReleasableScope2Thing))
+          .build();
+    }
+  }
+}
diff --git a/javatests/dagger/functional/ReusableTest.java b/javatests/dagger/functional/ReusableTest.java
new file mode 100644
index 000000000..8149ff46f
--- /dev/null
+++ b/javatests/dagger/functional/ReusableTest.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.functional.ComponentWithReusableBindings.ChildOne;
+import dagger.functional.ComponentWithReusableBindings.ChildTwo;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ReusableTest {
+  @Test
+  public void testReusable() {
+    ComponentWithReusableBindings parent = DaggerComponentWithReusableBindings.create();
+    ChildOne childOne = parent.childOne();
+    ChildTwo childTwo = parent.childTwo();
+
+    Object reusableInParent = parent.reusableInParent();
+    assertThat(parent.reusableInParent()).isSameAs(reusableInParent);
+    assertThat(childOne.reusableInParent()).isSameAs(reusableInParent);
+    assertThat(childTwo.reusableInParent()).isSameAs(reusableInParent);
+
+    Object reusableFromChildOne = childOne.reusableInChild();
+    assertThat(childOne.reusableInChild()).isSameAs(reusableFromChildOne);
+
+    Object reusableFromChildTwo = childTwo.reusableInChild();
+    assertThat(childTwo.reusableInChild()).isSameAs(reusableFromChildTwo);
+
+    assertThat(reusableFromChildTwo).isNotSameAs(reusableFromChildOne);
+  }
+}
diff --git a/javatests/dagger/functional/ScopedGeneric.java b/javatests/dagger/functional/ScopedGeneric.java
new file mode 100644
index 000000000..da7e157e6
--- /dev/null
+++ b/javatests/dagger/functional/ScopedGeneric.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+@Singleton
+class ScopedGeneric<T> { 
+  final T t;  
+  @Inject ScopedGeneric(T t) {
+    this.t = t;
+  }  
+}
diff --git a/javatests/dagger/functional/ScopedSimpleGeneric.java b/javatests/dagger/functional/ScopedSimpleGeneric.java
new file mode 100644
index 000000000..8e48eba27
--- /dev/null
+++ b/javatests/dagger/functional/ScopedSimpleGeneric.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+/**
+ * An {@link Inject Inject}ed generic class with no dependencies. Its factory class will have a
+ * generic {@code create()} method returning an object whose type parameters cannot be inferred from
+ * its arguments. Since it's scoped, the initialization of its field in a generated component must
+ * use a raw {@link javax.inject.Provider} in order to allow casting from {@code
+ * Provider<ScopedSimpleGeneric<Object>>} to {@code Provider<ScopedSimpleGeneric<Foo>>}.
+ */
+@Singleton
+class ScopedSimpleGeneric<T> {
+  @Inject
+  ScopedSimpleGeneric() {}
+}
diff --git a/javatests/dagger/functional/ShortKey.java b/javatests/dagger/functional/ShortKey.java
new file mode 100644
index 000000000..3d81d8f39
--- /dev/null
+++ b/javatests/dagger/functional/ShortKey.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.MapKey;
+
+@MapKey(unwrapValue = true)
+@interface ShortKey {
+  short value();
+}
diff --git a/javatests/dagger/functional/SingletonGenericComponent.java b/javatests/dagger/functional/SingletonGenericComponent.java
new file mode 100644
index 000000000..d9823cde7
--- /dev/null
+++ b/javatests/dagger/functional/SingletonGenericComponent.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.Component;
+import javax.inject.Singleton;
+
+@Singleton
+@Component
+interface SingletonGenericComponent {
+  
+  ScopedGeneric<A> scopedGenericA();
+
+  ScopedGeneric<B> scopedGenericB();
+  
+  ScopedSimpleGeneric<A> scopedSimpleGenericA();
+
+  ScopedSimpleGeneric<B> scopedSimpleGenericB();
+
+}
diff --git a/javatests/dagger/functional/SomeQualifier.java b/javatests/dagger/functional/SomeQualifier.java
new file mode 100644
index 000000000..126398cf1
--- /dev/null
+++ b/javatests/dagger/functional/SomeQualifier.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
+
+@Documented
+@Retention(RUNTIME)
+@Qualifier
+public @interface SomeQualifier {}
diff --git a/javatests/dagger/functional/Thing.java b/javatests/dagger/functional/Thing.java
new file mode 100644
index 000000000..b51b96ac1
--- /dev/null
+++ b/javatests/dagger/functional/Thing.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.functional.sub.OtherThing;
+import javax.inject.Inject;
+
+final class Thing {
+  @Inject Thing(@SuppressWarnings("unused") OtherThing unused) {}
+}
diff --git a/javatests/dagger/functional/TypeWithInheritedMembersInjection.java b/javatests/dagger/functional/TypeWithInheritedMembersInjection.java
new file mode 100644
index 000000000..b74f34842
--- /dev/null
+++ b/javatests/dagger/functional/TypeWithInheritedMembersInjection.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import javax.inject.Inject;
+
+final class TypeWithInheritedMembersInjection extends AbstractMiddleClassWithoutMembers {
+  @Inject TypeWithInheritedMembersInjection() {}
+}
+
diff --git a/javatests/dagger/functional/UnwrappedAnnotationKey.java b/javatests/dagger/functional/UnwrappedAnnotationKey.java
new file mode 100644
index 000000000..e9298f2bb
--- /dev/null
+++ b/javatests/dagger/functional/UnwrappedAnnotationKey.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.MapKey;
+import dagger.multibindings.StringKey;
+
+@MapKey(unwrapValue = true)
+@interface UnwrappedAnnotationKey {
+  StringKey value();
+}
diff --git a/javatests/dagger/functional/WrappedAnnotationKey.java b/javatests/dagger/functional/WrappedAnnotationKey.java
new file mode 100644
index 000000000..02561115a
--- /dev/null
+++ b/javatests/dagger/functional/WrappedAnnotationKey.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional;
+
+import dagger.MapKey;
+import dagger.multibindings.ClassKey;
+import dagger.multibindings.StringKey;
+
+@MapKey(unwrapValue = false)
+@interface WrappedAnnotationKey {
+  StringKey value();
+  int[] integers();
+  ClassKey[] annotations();
+  Class<? extends Number>[] classes();
+}
diff --git a/javatests/dagger/functional/binds/BindsCollectionsWithoutMultibindingsTest.java b/javatests/dagger/functional/binds/BindsCollectionsWithoutMultibindingsTest.java
new file mode 100644
index 000000000..f97dca7d8
--- /dev/null
+++ b/javatests/dagger/functional/binds/BindsCollectionsWithoutMultibindingsTest.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.binds;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.collect.ImmutableMap;
+import dagger.Binds;
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class BindsCollectionsWithoutMultibindingsTest {
+  @Module
+  abstract static class M {
+    @Provides
+    static HashSet<String> provideHashSet() {
+      HashSet<String> set = new HashSet<>();
+      set.add("binds");
+      set.add("set");
+      return set;
+    }
+
+    @Binds
+    abstract Set<String> bindStringSet(HashSet<String> set);
+
+    @Provides
+    static HashMap<String, String> provideHashMap() {
+      HashMap<String, String> map = new HashMap<>();
+      map.put("binds", "map");
+      map.put("without", "multibindings");
+      return map;
+    }
+
+    @Binds
+    abstract Map<String, String> bindStringMap(HashMap<String, String> map);
+  }
+
+  @Component(modules = M.class)
+  interface C {
+    Set<String> set();
+
+    Map<String, String> map();
+  }
+
+  @Test
+  public void works() {
+    C component = DaggerBindsCollectionsWithoutMultibindingsTest_C.create();
+
+    assertThat(component.set()).containsExactly("binds", "set");
+    assertThat(component.map())
+        .containsExactlyEntriesIn(
+            ImmutableMap.of(
+                "binds", "map",
+                "without", "multibindings"));
+  }
+}
diff --git a/javatests/dagger/functional/binds/BindsTest.java b/javatests/dagger/functional/binds/BindsTest.java
new file mode 100644
index 000000000..2881091f2
--- /dev/null
+++ b/javatests/dagger/functional/binds/BindsTest.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.binds;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.collect.ImmutableMap;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class BindsTest {
+
+  private TestComponent component;
+
+  @Before
+  public void setUp() {
+    component = DaggerTestComponent.create();
+  }
+
+  @Test
+  public void bindDelegates() {
+    assertThat(component.object()).isInstanceOf(FooOfStrings.class);
+    assertThat(component.fooOfStrings()).isInstanceOf(FooOfStrings.class);
+    assertThat(component.fooOfObjects()).isInstanceOf(FooOfObjects.class);
+    assertThat(component.fooOfIntegers()).isNotNull();
+  }
+
+  @Test
+  public void bindWithScope() {
+    assertThat(component.qualifiedFooOfStrings())
+        .isSameAs(component.qualifiedFooOfStrings());
+  }
+
+  @Test
+  public void multibindings() {
+    assertThat(component.foosOfNumbers()).hasSize(2);
+    assertThat(component.objects()).hasSize(3);
+    assertThat(component.charSequences()).hasSize(5);
+
+    assertThat(component.integerObjectMap())
+        .containsExactlyEntriesIn(
+            ImmutableMap.of(123, "123-string", 456, "456-string", 789, "789-string"));
+    assertThat(component.integerProviderOfObjectMap()).hasSize(3);
+    assertThat(component.integerProviderOfObjectMap().get(123).get()).isEqualTo("123-string");
+    assertThat(component.integerProviderOfObjectMap().get(456).get()).isEqualTo("456-string");
+    assertThat(component.integerProviderOfObjectMap().get(789).get()).isEqualTo("789-string");
+
+    assertThat(component.qualifiedIntegerObjectMap()).hasSize(1);
+
+    assertThat(component.primitiveSet()).containsExactly(100);
+    assertThat(component.primitiveValueMap()).containsExactly(10, 100);
+  }
+}
diff --git a/javatests/dagger/functional/binds/Foo.java b/javatests/dagger/functional/binds/Foo.java
new file mode 100644
index 000000000..12b0e4e44
--- /dev/null
+++ b/javatests/dagger/functional/binds/Foo.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.binds;
+
+/**
+ * This is the type that will be bound.  We throw in generics just to complicate the test.
+ */
+interface Foo<T> {}
diff --git a/javatests/dagger/functional/binds/FooOfObjects.java b/javatests/dagger/functional/binds/FooOfObjects.java
new file mode 100644
index 000000000..c50f2fa09
--- /dev/null
+++ b/javatests/dagger/functional/binds/FooOfObjects.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.binds;
+
+import javax.inject.Inject;
+
+final class FooOfObjects implements Foo<Object> {
+  @Inject FooOfObjects() {}
+}
diff --git a/javatests/dagger/functional/binds/FooOfStrings.java b/javatests/dagger/functional/binds/FooOfStrings.java
new file mode 100644
index 000000000..42fc704af
--- /dev/null
+++ b/javatests/dagger/functional/binds/FooOfStrings.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.binds;
+
+import javax.inject.Inject;
+
+final class FooOfStrings implements Foo<String> {
+  @Inject
+  FooOfStrings() {}
+}
diff --git a/javatests/dagger/functional/binds/InterfaceModule.java b/javatests/dagger/functional/binds/InterfaceModule.java
new file mode 100644
index 000000000..e9d36c0bd
--- /dev/null
+++ b/javatests/dagger/functional/binds/InterfaceModule.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.binds;
+
+import dagger.Binds;
+import dagger.Module;
+
+@Module
+interface InterfaceModule {
+  @Binds Foo<Object> bindFooOfObjects(FooOfObjects impl);
+}
diff --git a/javatests/dagger/functional/binds/SimpleBindingModule.java b/javatests/dagger/functional/binds/SimpleBindingModule.java
new file mode 100644
index 000000000..e1d522771
--- /dev/null
+++ b/javatests/dagger/functional/binds/SimpleBindingModule.java
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.binds;
+
+import dagger.Binds;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Reusable;
+import dagger.functional.SomeQualifier;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntKey;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.TreeSet;
+import javax.inject.Named;
+import javax.inject.Singleton;
+
+@Module(includes = InterfaceModule.class)
+abstract class SimpleBindingModule {
+  @Binds
+  abstract Object bindObject(FooOfStrings impl);
+
+  @Binds
+  @Reusable
+  @SomeQualifier
+  abstract Object bindReusableObject(FooOfStrings impl);
+
+  @Binds
+  abstract Foo<String> bindFooOfStrings(FooOfStrings impl);
+
+  @Binds
+  abstract Foo<? extends Number> bindFooOfNumbers(Foo<Integer> fooOfIntegers);
+
+  @Binds
+  @Singleton
+  @SomeQualifier
+  abstract Foo<String> bindQualifiedFooOfStrings(FooOfStrings impl);
+
+  @Provides
+  static Foo<Integer> provideFooOfIntegers() {
+    return new Foo<Integer>() {};
+  }
+
+  @Provides
+  static Foo<Double> provideFooOfDoubles() {
+    return new Foo<Double>() {};
+  }
+
+  @Binds
+  @IntoSet
+  abstract Foo<? extends Number> bindFooOfIntegersIntoSet(Foo<Integer> fooOfIntegers);
+
+  @Binds
+  @IntoSet
+  abstract Foo<? extends Number> bindFooExtendsNumberIntoSet(Foo<Double> fooOfDoubles);
+
+  @Binds
+  @ElementsIntoSet
+  abstract Set<Object> bindSetOfFooNumbersToObjects(Set<Foo<? extends Number>> setOfFooNumbers);
+
+  @Binds
+  @IntoSet
+  abstract Object bindFooOfStringsIntoSetOfObjects(FooOfStrings impl);
+
+  @Provides
+  static HashSet<String> provideStringHashSet() {
+    return new HashSet<>(Arrays.asList("hash-string1", "hash-string2"));
+  }
+
+  @Provides
+  static TreeSet<CharSequence> provideCharSequenceTreeSet() {
+    return new TreeSet<CharSequence>(Arrays.asList("tree-charSequence1", "tree-charSequence2"));
+  }
+
+  @Provides
+  static Collection<CharSequence> provideCharSequenceCollection() {
+    return Arrays.<CharSequence>asList("list-charSequence");
+  }
+
+  @Binds
+  @ElementsIntoSet
+  abstract Set<CharSequence> bindHashSetOfStrings(HashSet<String> set);
+
+  @Binds
+  @ElementsIntoSet
+  abstract Set<CharSequence> bindTreeSetOfCharSequences(TreeSet<CharSequence> set);
+
+  @Binds
+  @ElementsIntoSet
+  abstract Set<CharSequence> bindCollectionOfCharSequences(Collection<CharSequence> collection);
+
+  @Binds
+  @IntoMap
+  @IntKey(123)
+  abstract Object bind123ForMap(@Named("For-123") String string);
+
+  @Binds
+  @IntoMap
+  @IntKey(456)
+  abstract Object bind456ForMap(@Named("For-456") String string);
+
+  @Provides
+  @IntoMap
+  @IntKey(789)
+  static Object provide789ForMap() {
+    return "789-string";
+  }
+
+  @Binds
+  @SomeQualifier
+  abstract int primitiveToPrimitive(int intValue);
+
+  @Binds
+  @IntoSet
+  abstract int intValueIntoSet(int intValue);
+
+  @Binds
+  @IntoMap
+  @IntKey(10)
+  abstract int intValueIntoMap(int intValue);
+
+  @Provides
+  static int intValue() {
+    return 100;
+  }
+
+  @Binds
+  @IntoMap
+  @IntKey(123)
+  @SomeQualifier
+  abstract Object bindFooOfStringsIntoQualifiedMap(FooOfStrings fooOfStrings);
+  
+  @Provides
+  @Named("For-123")
+  static String provide123String() {
+    return "123-string";
+  }
+
+  @Provides
+  @Named("For-456")
+  static String provide456String() {
+    return "456-string";
+  }
+}
diff --git a/javatests/dagger/functional/binds/TestComponent.java b/javatests/dagger/functional/binds/TestComponent.java
new file mode 100644
index 000000000..3299dc832
--- /dev/null
+++ b/javatests/dagger/functional/binds/TestComponent.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.binds;
+
+import dagger.Component;
+import dagger.functional.SomeQualifier;
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Provider;
+import javax.inject.Singleton;
+
+@Singleton
+@Component(modules = SimpleBindingModule.class)
+public interface TestComponent {
+  Object object();
+
+  @SomeQualifier
+  Object reusableObject();
+
+  Foo<String> fooOfStrings();
+
+  Foo<Object> fooOfObjects();
+
+  @SomeQualifier
+  Foo<String> qualifiedFooOfStrings();
+
+  Foo<Integer> fooOfIntegers();
+
+  Set<Foo<? extends Number>> foosOfNumbers();
+
+  Set<Object> objects();
+
+  Set<CharSequence> charSequences();
+
+  Map<Integer, Object> integerObjectMap();
+
+  Map<Integer, Provider<Object>> integerProviderOfObjectMap();
+
+  @SomeQualifier Map<Integer, Object> qualifiedIntegerObjectMap();
+
+  @SomeQualifier int uniquePrimitive();
+
+  Set<Integer> primitiveSet();
+
+  Map<Integer, Integer> primitiveValueMap();
+}
diff --git a/javatests/dagger/functional/builder/BuildMethodCovariantReturn.java b/javatests/dagger/functional/builder/BuildMethodCovariantReturn.java
new file mode 100644
index 000000000..b55981f4e
--- /dev/null
+++ b/javatests/dagger/functional/builder/BuildMethodCovariantReturn.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builder;
+
+import dagger.Component;
+
+@Component
+interface BuildMethodCovariantReturn {
+
+  @Component.Builder
+  interface Builder {
+    Object build();
+  }
+}
diff --git a/javatests/dagger/functional/builder/BuildMethodCovariantReturnInherited.java b/javatests/dagger/functional/builder/BuildMethodCovariantReturnInherited.java
new file mode 100644
index 000000000..07ebbc8e6
--- /dev/null
+++ b/javatests/dagger/functional/builder/BuildMethodCovariantReturnInherited.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builder;
+
+import dagger.Component;
+
+interface BuildMethodCovariantReturnInherited {
+  @Component
+  interface Simple {
+    interface BuilderSupertype {
+      Object build();
+    }
+
+    @Component.Builder
+    interface Builder extends BuilderSupertype {}
+  }
+
+  interface ComponentSupertype {}
+
+  @Component
+  interface GenericBuilderType extends ComponentSupertype {
+    interface GenericBuilderSupertype<T> {
+      T build();
+    }
+
+    @Component.Builder
+    interface Builder extends GenericBuilderSupertype<ComponentSupertype> {}
+  }
+
+  interface ParameterizedComponentSupertype<T> {}
+
+  @Component
+  interface GenericComponentSupertypeAndBuilderSupertype
+      extends ParameterizedComponentSupertype<Object> {
+
+    interface GenericBuilderSupertype<T> {
+      ParameterizedComponentSupertype<T> build();
+    }
+
+    @Component.Builder
+    interface Builder extends GenericBuilderSupertype<Object> {}
+  }
+}
diff --git a/javatests/dagger/functional/builder/BuilderTest.java b/javatests/dagger/functional/builder/BuilderTest.java
new file mode 100644
index 000000000..d5c066fd6
--- /dev/null
+++ b/javatests/dagger/functional/builder/BuilderTest.java
@@ -0,0 +1,267 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builder;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class BuilderTest {
+
+  @Test public void interfaceBuilder() {
+    TestComponentWithBuilderInterface.Builder builder =
+        DaggerTestComponentWithBuilderInterface.builder();
+
+    // Make sure things fail if we don't set our required modules.
+    try {
+      builder.build();
+      fail();
+    } catch(IllegalStateException expected) {}
+    
+    builder.intModule(new IntModuleIncludingDoubleAndFloat(1))
+        .stringModule(new StringModule("sam"))
+        .depComponent(new DepComponent() {});
+    builder.doubleModule(new DoubleModule());
+    // Don't set other modules -- make sure it works.
+    
+    TestComponentWithBuilderInterface component = builder.build();
+    assertThat(component.s()).isEqualTo("sam");
+    assertThat(component.i()).isEqualTo(1);
+    assertThat(component.d()).isWithin(0).of(4.2d);
+    assertThat(component.f()).isWithin(0).of(5.5f);
+    assertThat(component.l()).isEqualTo(6L);
+  }
+
+  @Test public void abstractClassBuilder() {
+    TestComponentWithBuilderAbstractClass.Builder builder =
+        TestComponentWithBuilderAbstractClass.builder();
+
+    // Make sure things fail if we don't set our required modules.
+    try {
+      builder.build();
+      fail();
+    } catch(IllegalStateException expected) {}
+    
+    builder.intModule(new IntModuleIncludingDoubleAndFloat(1))
+        .stringModule(new StringModule("sam"))
+        .depComponent(new DepComponent() {});
+    builder.doubleModule(new DoubleModule());
+    // Don't set other modules -- make sure it works.
+    
+    TestComponentWithBuilderAbstractClass component = builder.build();
+    assertThat(component.s()).isEqualTo("sam");
+    assertThat(component.i()).isEqualTo(1);
+    assertThat(component.d()).isWithin(0).of(4.2d);
+    assertThat(component.f()).isWithin(0).of(5.5f);
+    assertThat(component.l()).isEqualTo(6L);
+  }
+
+  @Test public void interfaceGenericBuilder() {
+    TestComponentWithGenericBuilderInterface.Builder builder =
+        DaggerTestComponentWithGenericBuilderInterface.builder();
+
+    // Make sure things fail if we don't set our required modules.
+    try {
+      builder.build();
+      fail();
+    } catch(IllegalStateException expected) {}
+    
+    builder.setM2(new IntModuleIncludingDoubleAndFloat(1))
+        .setM1(new StringModule("sam"))
+        .depComponent(new DepComponent() {});
+    builder.doubleModule(new DoubleModule());
+    // Don't set other modules -- make sure it works.
+    
+    TestComponentWithGenericBuilderInterface component = builder.build();
+    assertThat(component.s()).isEqualTo("sam");
+    assertThat(component.i()).isEqualTo(1);
+    assertThat(component.d()).isWithin(0).of(4.2d);
+    assertThat(component.f()).isWithin(0).of(5.5f);
+    assertThat(component.l()).isEqualTo(6L);
+  }
+
+  @Test public void abstractClassGenericBuilder() {
+    TestComponentWithGenericBuilderAbstractClass.Builder builder =
+        DaggerTestComponentWithGenericBuilderAbstractClass.builder();
+
+    // Make sure things fail if we don't set our required modules.
+    try {
+      builder.build();
+      fail();
+    } catch(IllegalStateException expected) {}
+    
+    builder.setM2(new IntModuleIncludingDoubleAndFloat(1))
+        .setM1(new StringModule("sam"))
+        .depComponent(new DepComponent() {});
+    builder.doubleModule(new DoubleModule());
+    // Don't set other modules -- make sure it works.
+    
+    TestComponentWithGenericBuilderAbstractClass component = builder.build();
+    assertThat(component.s()).isEqualTo("sam");
+    assertThat(component.i()).isEqualTo(1);
+    assertThat(component.d()).isWithin(0).of(4.2d);
+    assertThat(component.f()).isWithin(0).of(5.5f);
+    assertThat(component.l()).isEqualTo(6L);
+  }
+  
+  @Test public void subcomponents_interface() {
+    ParentComponent parent = DaggerParentComponent.create();    
+    TestChildComponentWithBuilderInterface.Builder builder1 = parent.childInterfaceBuilder();
+    try {
+      builder1.build();
+      fail();
+    } catch(IllegalStateException expected) {}
+    
+    builder1.setM2(new IntModuleIncludingDoubleAndFloat(1))
+        .setM1(new StringModule("sam"))
+        .set(new ByteModule((byte)7));
+    builder1.set(new FloatModule());
+    TestChildComponentWithBuilderInterface child1 = builder1.build();
+    assertThat(child1.s()).isEqualTo("sam");
+    assertThat(child1.i()).isEqualTo(1);
+    assertThat(child1.d()).isWithin(0).of(4.2d);
+    assertThat(child1.f()).isWithin(0).of(5.5f);
+    assertThat(child1.l()).isEqualTo(6L);
+    assertThat(child1.b()).isEqualTo((byte)7);
+  }
+  
+  @Test public void subcomponents_abstractclass() {
+    ParentComponent parent = DaggerParentComponent.create();
+    TestChildComponentWithBuilderAbstractClass.Builder builder2 =
+        parent.childAbstractClassBuilder();
+    try {
+      builder2.build();
+      fail();
+    } catch(IllegalStateException expected) {}
+    
+    builder2.setM2(new IntModuleIncludingDoubleAndFloat(10))
+        .setM1(new StringModule("tara"))
+        .set(new ByteModule((byte)70));
+    builder2.set(new FloatModule());
+    TestChildComponentWithBuilderAbstractClass child2 = builder2.build();
+    assertThat(child2.s()).isEqualTo("tara");
+    assertThat(child2.i()).isEqualTo(10);
+    assertThat(child2.d()).isWithin(0).of(4.2d);
+    assertThat(child2.f()).isWithin(0).of(5.5f);
+    assertThat(child2.l()).isEqualTo(6L);
+    assertThat(child2.b()).isEqualTo((byte)70);
+  }
+    
+  @Test
+  public void grandchildren() {
+    ParentComponent parent = DaggerParentComponent.create();
+    MiddleChild middle1 = parent.middleBuilder().set(new StringModule("sam")).build();
+    Grandchild grandchild1 =
+        middle1.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(21)).build();
+    Grandchild grandchild2 =
+        middle1.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(22)).build();
+    
+    assertThat(middle1.s()).isEqualTo("sam");
+    assertThat(grandchild1.i()).isEqualTo(21);
+    assertThat(grandchild1.s()).isEqualTo("sam");
+    assertThat(grandchild2.i()).isEqualTo(22);
+    assertThat(grandchild2.s()).isEqualTo("sam");
+
+    // Make sure grandchildren from newer children have no relation to the older ones.
+    MiddleChild middle2 = parent.middleBuilder().set(new StringModule("tara")).build();
+    Grandchild grandchild3 =
+        middle2.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(23)).build();
+    Grandchild grandchild4 =
+        middle2.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(24)).build();
+    
+    assertThat(middle2.s()).isEqualTo("tara");
+    assertThat(grandchild3.i()).isEqualTo(23);
+    assertThat(grandchild3.s()).isEqualTo("tara");
+    assertThat(grandchild4.i()).isEqualTo(24);
+    assertThat(grandchild4.s()).isEqualTo("tara");
+  }
+  
+  @Test
+  public void diamondGrandchildren() {
+    ParentComponent parent = DaggerParentComponent.create();
+    MiddleChild middle = parent.middleBuilder().set(new StringModule("sam")).build();
+    OtherMiddleChild other = parent.otherBuilder().set(new StringModule("tara")).build();
+    
+    Grandchild middlegrand =
+        middle.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(21)).build();
+    Grandchild othergrand =
+        other.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(22)).build();
+    
+    assertThat(middle.s()).isEqualTo("sam");
+    assertThat(other.s()).isEqualTo("tara");
+    assertThat(middlegrand.s()).isEqualTo("sam");
+    assertThat(othergrand.s()).isEqualTo("tara");
+    assertThat(middlegrand.i()).isEqualTo(21);
+    assertThat(othergrand.i()).isEqualTo(22);
+  }
+  
+  @Test
+  public void genericSubcomponentMethod() {
+    ParentOfGenericComponent parent =
+        DaggerParentOfGenericComponent.builder().stringModule(new StringModule("sam")).build();
+    Grandchild.Builder builder = parent.subcomponentBuilder();
+    Grandchild child = builder.set(new IntModuleIncludingDoubleAndFloat(21)).build();
+    assertThat(child.s()).isEqualTo("sam");
+    assertThat(child.i()).isEqualTo(21);
+  }
+  
+  @Test
+  public void requireSubcomponentBuilderProviders() {
+    ParentComponent parent = DaggerParentComponent.create();
+    MiddleChild middle =
+        parent
+            .requiresMiddleChildBuilder()
+            .subcomponentBuilderProvider()
+            .get()
+            .set(new StringModule("sam"))
+            .build();
+    Grandchild grandchild =
+        middle
+            .requiresGrandchildBuilder()
+            .subcomponentBuilderProvider()
+            .get()
+            .set(new IntModuleIncludingDoubleAndFloat(12))
+            .build();
+    assertThat(middle.s()).isEqualTo("sam");
+    assertThat(grandchild.i()).isEqualTo(12);
+    assertThat(grandchild.s()).isEqualTo("sam");
+  }
+  
+  @Test
+  public void requireSubcomponentBuilders() {
+    ParentComponent parent = DaggerParentComponent.create();
+    MiddleChild middle =
+        parent
+            .requiresMiddleChildBuilder()
+            .subcomponentBuilder()
+            .set(new StringModule("sam"))
+            .build();
+    Grandchild grandchild =
+        middle
+            .requiresGrandchildBuilder()
+            .subcomponentBuilder()
+            .set(new IntModuleIncludingDoubleAndFloat(12))
+            .build();
+    assertThat(middle.s()).isEqualTo("sam");
+    assertThat(grandchild.i()).isEqualTo(12);
+    assertThat(grandchild.s()).isEqualTo("sam");
+  }
+}
diff --git a/javatests/dagger/functional/builder/ByteModule.java b/javatests/dagger/functional/builder/ByteModule.java
new file mode 100644
index 000000000..4b6602f10
--- /dev/null
+++ b/javatests/dagger/functional/builder/ByteModule.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class ByteModule {
+  final byte b;
+
+  ByteModule(byte b) {
+    this.b = b;
+  }
+  
+  @Provides byte b() { return b; }
+}
diff --git a/javatests/dagger/functional/builder/DepComponent.java b/javatests/dagger/functional/builder/DepComponent.java
new file mode 100644
index 000000000..6e85c7a21
--- /dev/null
+++ b/javatests/dagger/functional/builder/DepComponent.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builder;
+
+import dagger.Component;
+
+@Component
+interface DepComponent {
+}
diff --git a/javatests/dagger/functional/builder/DoubleModule.java b/javatests/dagger/functional/builder/DoubleModule.java
new file mode 100644
index 000000000..d1be37c29
--- /dev/null
+++ b/javatests/dagger/functional/builder/DoubleModule.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class DoubleModule {
+  @Provides
+  double d() {
+    return 4.2d;
+  }
+}
diff --git a/javatests/dagger/functional/builder/FloatModule.java b/javatests/dagger/functional/builder/FloatModule.java
new file mode 100644
index 000000000..d9990c0d9
--- /dev/null
+++ b/javatests/dagger/functional/builder/FloatModule.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class FloatModule {  
+  @Provides
+  float f() {
+    return 5.5f;
+  }
+}
diff --git a/javatests/dagger/functional/builder/GenericParent.java b/javatests/dagger/functional/builder/GenericParent.java
new file mode 100644
index 000000000..9563103dd
--- /dev/null
+++ b/javatests/dagger/functional/builder/GenericParent.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builder;
+
+interface GenericParent<B> {  
+  B subcomponentBuilder();
+}
diff --git a/javatests/dagger/functional/builder/Grandchild.java b/javatests/dagger/functional/builder/Grandchild.java
new file mode 100644
index 000000000..45fe2130f
--- /dev/null
+++ b/javatests/dagger/functional/builder/Grandchild.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builder;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = IntModuleIncludingDoubleAndFloat.class)
+interface Grandchild {
+  int i();
+  String s();
+
+  @Subcomponent.Builder
+  interface Builder {
+    Grandchild build();
+    Builder set(IntModuleIncludingDoubleAndFloat intModule);
+  }
+}
diff --git a/javatests/dagger/functional/builder/IntModuleIncludingDoubleAndFloat.java b/javatests/dagger/functional/builder/IntModuleIncludingDoubleAndFloat.java
new file mode 100644
index 000000000..37f5ad777
--- /dev/null
+++ b/javatests/dagger/functional/builder/IntModuleIncludingDoubleAndFloat.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module(includes = { DoubleModule.class, FloatModule.class })
+class IntModuleIncludingDoubleAndFloat {
+  final int integer;
+
+  IntModuleIncludingDoubleAndFloat(int integer) {
+    this.integer = integer;
+  }
+  
+  @Provides
+  int integer() {
+    return integer;
+  }
+}
diff --git a/javatests/dagger/functional/builder/LongModule.java b/javatests/dagger/functional/builder/LongModule.java
new file mode 100644
index 000000000..7b777ecb5
--- /dev/null
+++ b/javatests/dagger/functional/builder/LongModule.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class LongModule {  
+  @Provides
+  long l() {
+    return 6L;
+  }
+}
diff --git a/javatests/dagger/functional/builder/MiddleChild.java b/javatests/dagger/functional/builder/MiddleChild.java
new file mode 100644
index 000000000..762e2a040
--- /dev/null
+++ b/javatests/dagger/functional/builder/MiddleChild.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builder;
+
+import dagger.Subcomponent;
+
+@MiddleScope
+@Subcomponent(modules = StringModule.class)
+interface MiddleChild {
+  String s();
+  
+  Grandchild.Builder grandchildBuilder();
+  
+  RequiresSubcomponentBuilder<Grandchild.Builder> requiresGrandchildBuilder();
+  
+  @Subcomponent.Builder
+  interface Builder {
+    MiddleChild build();
+    Builder set(StringModule stringModule);
+  }
+}
diff --git a/javatests/dagger/functional/builder/MiddleScope.java b/javatests/dagger/functional/builder/MiddleScope.java
new file mode 100644
index 000000000..ac63626e2
--- /dev/null
+++ b/javatests/dagger/functional/builder/MiddleScope.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builder;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Retention;
+import javax.inject.Scope;
+
+@Scope
+@Retention(RUNTIME)
+@interface MiddleScope {
+
+}
diff --git a/javatests/dagger/functional/builder/OtherMiddleChild.java b/javatests/dagger/functional/builder/OtherMiddleChild.java
new file mode 100644
index 000000000..7ecc01465
--- /dev/null
+++ b/javatests/dagger/functional/builder/OtherMiddleChild.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builder;
+
+import dagger.Subcomponent;
+
+@MiddleScope
+@Subcomponent(modules = {StringModule.class, LongModule.class})
+interface OtherMiddleChild {
+  long l();
+  String s();
+  
+  Grandchild.Builder grandchildBuilder();
+  
+  @Subcomponent.Builder
+  interface Builder {
+    OtherMiddleChild build();
+    Builder set(StringModule stringModule);
+  }
+}
diff --git a/javatests/dagger/functional/builder/ParentComponent.java b/javatests/dagger/functional/builder/ParentComponent.java
new file mode 100644
index 000000000..425ba9a04
--- /dev/null
+++ b/javatests/dagger/functional/builder/ParentComponent.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builder;
+
+import dagger.Component;
+import javax.inject.Singleton;
+
+@Singleton
+@Component
+interface ParentComponent {  
+  TestChildComponentWithBuilderAbstractClass.Builder childAbstractClassBuilder();
+  TestChildComponentWithBuilderInterface.Builder childInterfaceBuilder();
+  
+  MiddleChild.Builder middleBuilder();
+  OtherMiddleChild.Builder otherBuilder();
+  
+  RequiresSubcomponentBuilder<MiddleChild.Builder> requiresMiddleChildBuilder();
+}
diff --git a/javatests/dagger/functional/builder/ParentOfGenericComponent.java b/javatests/dagger/functional/builder/ParentOfGenericComponent.java
new file mode 100644
index 000000000..daeb7d99f
--- /dev/null
+++ b/javatests/dagger/functional/builder/ParentOfGenericComponent.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builder;
+
+import dagger.Component;
+import javax.inject.Singleton;
+
+@Component(modules = StringModule.class)
+@Singleton
+interface ParentOfGenericComponent extends GenericParent<Grandchild.Builder> {}
diff --git a/javatests/dagger/functional/builder/PrivateConstructors.java b/javatests/dagger/functional/builder/PrivateConstructors.java
new file mode 100644
index 000000000..da9f7e2c8
--- /dev/null
+++ b/javatests/dagger/functional/builder/PrivateConstructors.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builder;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+import dagger.multibindings.StringKey;
+
+import javax.inject.Named;
+import java.util.Arrays;
+import java.util.List;
+
+final class PrivateConstructors {
+  @Module
+  static final class M {
+    @Provides
+    static String provideString() {
+      return "str";
+    }
+
+    private M() {}
+  }
+
+  @Component(modules = M.class)
+  interface C {
+    String string();
+
+    @Component.Builder
+    interface Builder {
+      // M should not be required, even though the constructor is inaccessible
+      C build();
+    }
+  }
+
+  @Provides
+  @StringKey("AAA")
+  @IntoMap
+  public String aString() {
+    return "A";
+  }
+
+  @Provides
+  @StringKey("BBB")
+  @IntoMap
+  public String bString() {
+    return "B";
+  }
+
+  @Provides
+  @Named("AnyString")
+  public String cString() {
+    return "C";
+  }
+
+  @Provides
+  public String dString() {
+    return "D";
+  }
+
+  @Provides
+  public List<String> list() {
+    return Arrays.asList("A", "B", "C");
+  }
+
+}
diff --git a/javatests/dagger/functional/builder/RequiresSubcomponentBuilder.java b/javatests/dagger/functional/builder/RequiresSubcomponentBuilder.java
new file mode 100644
index 000000000..a8dfa219d
--- /dev/null
+++ b/javatests/dagger/functional/builder/RequiresSubcomponentBuilder.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builder;
+
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+class RequiresSubcomponentBuilder<B> {
+  private final Provider<B> subcomponentBuilderProvider;
+  private final B subcomponentBuilder;
+
+  @Inject
+  RequiresSubcomponentBuilder(Provider<B> subcomponentBuilderProvider, B subcomponentBuilder) {
+    this.subcomponentBuilderProvider = subcomponentBuilderProvider;
+    this.subcomponentBuilder = subcomponentBuilder;
+  }
+
+  Provider<B> subcomponentBuilderProvider() {
+    return subcomponentBuilderProvider;
+  }
+  
+  B subcomponentBuilder() {
+    return subcomponentBuilder;
+  }
+}
diff --git a/javatests/dagger/functional/builder/StringModule.java b/javatests/dagger/functional/builder/StringModule.java
new file mode 100644
index 000000000..9fbaa5b43
--- /dev/null
+++ b/javatests/dagger/functional/builder/StringModule.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class StringModule {
+  final String string;
+
+  StringModule(String string) {
+    this.string = string;
+  }
+  
+  @Provides
+  String string() {
+    return string;
+  }
+}
diff --git a/javatests/dagger/functional/builder/TestChildComponentWithBuilderAbstractClass.java b/javatests/dagger/functional/builder/TestChildComponentWithBuilderAbstractClass.java
new file mode 100644
index 000000000..1527a44ee
--- /dev/null
+++ b/javatests/dagger/functional/builder/TestChildComponentWithBuilderAbstractClass.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builder;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class,
+    LongModule.class, ByteModule.class})
+interface TestChildComponentWithBuilderAbstractClass {
+  String s();
+  int i();
+  long l();
+  float f();
+  double d();
+  byte b();
+ 
+  abstract class SharedBuilder<B, C, M1, M2> {
+    abstract C build(); // Test resolving return type of build()
+    abstract B setM1(M1 m1); // Test resolving return type & param of setter
+    abstract SharedBuilder<B, C, M1, M2> setM2(M2 m2); // Test being overridden
+    abstract void setM3(DoubleModule doubleModule);  // Test being overridden
+    abstract SharedBuilder<B, C, M1, M2> set(FloatModule floatModule); // Test returning supertype.
+  }
+  
+  @Subcomponent.Builder
+  abstract class Builder extends SharedBuilder<Builder, TestChildComponentWithBuilderAbstractClass,
+      StringModule, IntModuleIncludingDoubleAndFloat> {
+    @Override abstract Builder setM2(IntModuleIncludingDoubleAndFloat m2); // Test covariance
+    @Override abstract void setM3(DoubleModule doubleModule); // Test simple overrides allowed    
+    abstract void set(ByteModule byteModule);
+    
+    // Note we're missing LongModule -- it's implicit
+  }
+}
diff --git a/javatests/dagger/functional/builder/TestChildComponentWithBuilderInterface.java b/javatests/dagger/functional/builder/TestChildComponentWithBuilderInterface.java
new file mode 100644
index 000000000..a02b1a176
--- /dev/null
+++ b/javatests/dagger/functional/builder/TestChildComponentWithBuilderInterface.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builder;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class,
+    LongModule.class, ByteModule.class})
+interface TestChildComponentWithBuilderInterface {
+  String s();
+  int i();
+  long l();
+  float f();
+  double d();
+  byte b();
+  
+  interface SharedBuilder<B, C, M1, M2> {
+    C build(); // Test resolving return type of build()
+    B setM1(M1 m1); // Test resolving return type & param of setter
+    SharedBuilder<B, C, M1, M2> setM2(M2 m2); // Test being overridden
+    void setM3(DoubleModule doubleModule);  // Test being overridden
+    SharedBuilder<B, C, M1, M2> set(FloatModule floatModule); // Test return type is supertype.
+  }
+  
+  @Subcomponent.Builder
+  interface Builder extends SharedBuilder<Builder, TestChildComponentWithBuilderInterface,
+      StringModule, IntModuleIncludingDoubleAndFloat> {
+    @Override Builder setM2(IntModuleIncludingDoubleAndFloat m2); // Test covariant overrides
+    @Override void setM3(DoubleModule doubleModule); // Test simple overrides allowed    
+    void set(ByteModule byteModule);
+    
+    // Note we're missing LongModule -- it's implicit
+  }
+}
diff --git a/javatests/dagger/functional/builder/TestComponentWithBuilderAbstractClass.java b/javatests/dagger/functional/builder/TestComponentWithBuilderAbstractClass.java
new file mode 100644
index 000000000..636c8f40f
--- /dev/null
+++ b/javatests/dagger/functional/builder/TestComponentWithBuilderAbstractClass.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builder;
+
+import dagger.Component;
+
+@Component(
+    modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class, LongModule.class},
+    dependencies = DepComponent.class)
+abstract class TestComponentWithBuilderAbstractClass {
+  
+  static Builder builder() {
+    return DaggerTestComponentWithBuilderAbstractClass.builder();
+  }
+  
+  abstract String s();
+  abstract int i();
+  abstract long l();
+  abstract float f();
+  abstract double d();
+  
+
+  static abstract class SharedBuilder {
+    // Make sure we use the overriding signature.
+    abstract Object build();
+    
+    Object stringModule(@SuppressWarnings("unused") StringModule stringModule) {
+      return null;
+    } 
+
+    SharedBuilder ignoredLongModule(@SuppressWarnings("unused") LongModule longModule) {
+      return null;
+    }
+    
+  }
+  
+  @Component.Builder
+  static abstract class Builder extends SharedBuilder {
+    @Override abstract TestComponentWithBuilderAbstractClass build(); // Narrowing return type
+    @Override abstract Builder stringModule(StringModule stringModule); // Make abstract & narrow
+    abstract Builder intModule(IntModuleIncludingDoubleAndFloat intModule);
+    abstract void doubleModule(DoubleModule doubleModule); // Module w/o args
+    abstract void depComponent(DepComponent depComponent);
+
+    Builder ignoredIntModule(
+        @SuppressWarnings("unused") IntModuleIncludingDoubleAndFloat intModule) {
+      return null;
+    }    
+    
+    // Note we're missing LongModule & FloatModule -- they/re implicit
+  }
+}
diff --git a/javatests/dagger/functional/builder/TestComponentWithBuilderInterface.java b/javatests/dagger/functional/builder/TestComponentWithBuilderInterface.java
new file mode 100644
index 000000000..ba55090ad
--- /dev/null
+++ b/javatests/dagger/functional/builder/TestComponentWithBuilderInterface.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builder;
+
+import dagger.Component;
+
+@Component(
+    modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class, LongModule.class},
+    dependencies = DepComponent.class)
+interface TestComponentWithBuilderInterface {
+  String s();
+  int i();
+  long l();
+  float f();
+  double d();
+  
+  interface SharedBuilder {
+    // Make sure we use the overriding signature.
+    Object build();
+    Object stringModule(StringModule m1); 
+  }
+  
+  @Component.Builder
+  interface Builder extends SharedBuilder {
+    @Override TestComponentWithBuilderInterface build(); // Narrowing return type
+    @Override Builder stringModule(StringModule stringModule); // Narrowing return type
+    Builder intModule(IntModuleIncludingDoubleAndFloat intModule);
+    void doubleModule(DoubleModule doubleModule); // Module w/o args
+    void depComponent(DepComponent depComponent);
+    
+    // Note we're missing LongModule & FloatModule -- they/re implicit
+  }
+}
diff --git a/javatests/dagger/functional/builder/TestComponentWithGenericBuilderAbstractClass.java b/javatests/dagger/functional/builder/TestComponentWithGenericBuilderAbstractClass.java
new file mode 100644
index 000000000..5324957c4
--- /dev/null
+++ b/javatests/dagger/functional/builder/TestComponentWithGenericBuilderAbstractClass.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builder;
+
+import dagger.Component;
+
+@Component(
+    modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class, LongModule.class},
+    dependencies = DepComponent.class)
+interface TestComponentWithGenericBuilderAbstractClass {
+  String s();
+  int i();
+  long l();
+  float f();
+  double d();
+  
+  static abstract class SharedBuilder<B, C, M1, M2> {
+    abstract C build(); // Test resolving return type of build()
+    abstract B setM1(M1 m1); // Test resolving return type & param of setter
+    abstract SharedBuilder<B, C, M1, M2> setM2(M2 m2); // Test being overridden
+    abstract void doubleModule(DoubleModule doubleModule);  // Test being overridden
+    abstract SharedBuilder<B, C, M1, M2> depComponent(FloatModule floatModule); // Test return type
+  }
+  
+  @Component.Builder
+  static abstract class Builder extends SharedBuilder<Builder,
+      TestComponentWithGenericBuilderAbstractClass, StringModule,
+      IntModuleIncludingDoubleAndFloat> {
+    @Override abstract Builder setM2(IntModuleIncludingDoubleAndFloat m2); // Test covariant overrides
+    @Override abstract void doubleModule(DoubleModule module3); // Test simple overrides allowed    
+    abstract void depComponent(DepComponent depComponent);
+    
+    // Note we're missing LongModule & FloatModule -- they're implicit
+  }
+}
diff --git a/javatests/dagger/functional/builder/TestComponentWithGenericBuilderInterface.java b/javatests/dagger/functional/builder/TestComponentWithGenericBuilderInterface.java
new file mode 100644
index 000000000..8e30c7803
--- /dev/null
+++ b/javatests/dagger/functional/builder/TestComponentWithGenericBuilderInterface.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builder;
+
+import dagger.Component;
+
+@Component(
+    modules = {StringModule.class, IntModuleIncludingDoubleAndFloat.class, LongModule.class},
+    dependencies = DepComponent.class)
+interface TestComponentWithGenericBuilderInterface {
+  String s();
+  int i();
+  long l();
+  float f();
+  double d();
+  
+  interface SharedBuilder<B, C, M1, M2> {
+    C build(); // Test resolving return type of build()
+    B setM1(M1 m1); // Test resolving return type & param of setter
+    SharedBuilder<B, C, M1, M2> setM2(M2 m2); // Test being overridden
+    void doubleModule(DoubleModule doubleModule);  // Test being overridden
+    SharedBuilder<B, C, M1, M2> set(FloatModule floatModule); // Test return type is supertype.
+  }
+  
+  @Component.Builder
+  interface Builder extends SharedBuilder<Builder, TestComponentWithGenericBuilderInterface,
+      StringModule, IntModuleIncludingDoubleAndFloat> {
+    @Override Builder setM2(IntModuleIncludingDoubleAndFloat m2); // Test covariant overrides allowed
+    @Override void doubleModule(DoubleModule module3); // Test simple overrides allowed    
+    void depComponent(DepComponent depComponent);
+    
+    // Note we're missing M5 -- that's implicit.
+  }
+}
diff --git a/javatests/dagger/functional/builderbinds/BuilderBindsTest.java b/javatests/dagger/functional/builderbinds/BuilderBindsTest.java
new file mode 100644
index 000000000..4cafeac96
--- /dev/null
+++ b/javatests/dagger/functional/builderbinds/BuilderBindsTest.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builderbinds;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import dagger.functional.builderbinds.TestComponent.Builder;
+import java.util.Arrays;
+import java.util.Collections;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class BuilderBindsTest {
+
+  @Test
+  public void builderBinds() {
+    TestComponent.Builder builder =
+        DaggerTestComponent.builder()
+            .count(5)
+            .l(10L)
+            .input("foo")
+            .nullableInput("bar")
+            .listOfString(Arrays.asList("x", "y", "z"));
+    builder.boundInSubtype(20);
+    TestComponent component = builder.build();
+    assertThat(component.count()).isEqualTo(5);
+    assertThat(component.input()).isEqualTo("foo");
+    assertThat(component.nullableInput()).isEqualTo("bar");
+    assertThat(component.listOfString()).containsExactly("x", "y", "z").inOrder();
+  }
+
+  @Test
+  public void builderBindsNullableWithNull() {
+    Builder builder =
+        DaggerTestComponent.builder()
+            .count(5)
+            .l(10L)
+            .input("foo")
+            .nullableInput(null)
+            .listOfString(Collections.<String>emptyList());
+    builder.boundInSubtype(20);
+    TestComponent component = builder.build();
+
+    assertThat(component.count()).isEqualTo(5);
+    assertThat(component.input()).isEqualTo("foo");
+    assertThat(component.nullableInput()).isNull();
+    assertThat(component.listOfString()).isEmpty();
+  }
+
+  @Test
+  public void builderBindsNonNullableWithNull() {
+    try {
+      DaggerTestComponent.builder().count(5).l(10L).input(null);
+      fail("expected NullPointerException");
+    } catch (NullPointerException expected) {
+    }
+  }
+
+  @Test
+  public void builderBindsPrimitiveNotSet() {
+    try {
+      TestComponent.Builder builder =
+          DaggerTestComponent.builder()
+              .l(10L)
+              .input("foo")
+              .nullableInput("bar")
+              .listOfString(Collections.<String>emptyList());
+      builder.boundInSubtype(20);
+      builder.build();
+      fail("expected IllegalStateException");
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test
+  public void builderBindsNonNullableNotSet() {
+    try {
+      TestComponent.Builder builder =
+          DaggerTestComponent.builder()
+              .count(5)
+              .l(10L)
+              .nullableInput("foo")
+              .listOfString(Collections.<String>emptyList());
+      builder.boundInSubtype(20);
+      builder.build();
+      fail("expected IllegalStateException");
+    } catch (IllegalStateException expected) {
+    }
+  }
+
+  @Test
+  public void builderBindsNullableNotSet() {
+    Builder builder =
+        DaggerTestComponent.builder()
+            .count(5)
+            .l(10L)
+            .input("foo")
+            .listOfString(Collections.<String>emptyList());
+    builder.boundInSubtype(20);
+    TestComponent component = builder.build();
+    assertThat(component.count()).isEqualTo(5);
+    assertThat(component.input()).isEqualTo("foo");
+    assertThat(component.nullableInput()).isNull();
+    assertThat(component.listOfString()).isEmpty();
+  }
+}
diff --git a/javatests/dagger/functional/builderbinds/BuilderSupertype.java b/javatests/dagger/functional/builderbinds/BuilderSupertype.java
new file mode 100644
index 000000000..5828f9da8
--- /dev/null
+++ b/javatests/dagger/functional/builderbinds/BuilderSupertype.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builderbinds;
+
+import dagger.BindsInstance;
+import javax.inject.Named;
+
+interface BuilderSupertype {
+  @BindsInstance
+  void boundInSubtype(@Named("subtype") int subtype);
+}
diff --git a/javatests/dagger/functional/builderbinds/Nullable.java b/javatests/dagger/functional/builderbinds/Nullable.java
new file mode 100644
index 000000000..7924484e6
--- /dev/null
+++ b/javatests/dagger/functional/builderbinds/Nullable.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builderbinds;
+
+@interface Nullable {}
diff --git a/javatests/dagger/functional/builderbinds/TestComponent.java b/javatests/dagger/functional/builderbinds/TestComponent.java
new file mode 100644
index 000000000..23a32b1d9
--- /dev/null
+++ b/javatests/dagger/functional/builderbinds/TestComponent.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.builderbinds;
+
+import dagger.BindsInstance;
+import dagger.Component;
+import java.util.List;
+import javax.inject.Named;
+
+@Component
+interface TestComponent {
+  int count();
+
+  long l();
+
+  @Named("input")
+  String input();
+
+  @Nullable
+  @Named("nullable input")
+  String nullableInput();
+
+  List<String> listOfString();
+
+  @Named("subtype")
+  int boundInSubtype();
+
+  @Component.Builder
+  interface Builder extends BuilderSupertype {
+    @BindsInstance
+    Builder count(int count);
+
+    @BindsInstance
+    Builder l(long l);
+
+    @BindsInstance
+    Builder input(@Named("input") String input);
+
+    @BindsInstance
+    Builder nullableInput(@Nullable @Named("nullable input") String nullableInput);
+
+    @BindsInstance
+    Builder listOfString(List<String> listOfString);
+
+    TestComponent build();
+  }
+}
diff --git a/javatests/dagger/functional/cycle/CycleTest.java b/javatests/dagger/functional/cycle/CycleTest.java
new file mode 100644
index 000000000..2e3d0c94c
--- /dev/null
+++ b/javatests/dagger/functional/cycle/CycleTest.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.cycle;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.functional.cycle.Cycles.A;
+import dagger.functional.cycle.Cycles.C;
+import dagger.functional.cycle.Cycles.ChildCycleComponent;
+import dagger.functional.cycle.Cycles.CycleComponent;
+import dagger.functional.cycle.Cycles.CycleMapComponent;
+import dagger.functional.cycle.Cycles.S;
+import dagger.functional.cycle.Cycles.SelfCycleComponent;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class CycleTest {
+  @Test
+  public void providerIndirectionSelfCycle() {
+    SelfCycleComponent selfCycleComponent = DaggerCycles_SelfCycleComponent.create();
+    S s = selfCycleComponent.s();
+    assertThat(s.sProvider.get()).isNotNull();
+  }
+
+  @Test
+  public void providerIndirectionCycle() {
+    CycleComponent cycleComponent = DaggerCycles_CycleComponent.create();
+    A a = cycleComponent.a();
+    C c = cycleComponent.c();
+    assertThat(c.aProvider.get()).isNotNull();
+    assertThat(a.b.c.aProvider.get()).isNotNull();
+    assertThat(a.e.d.b.c.aProvider.get()).isNotNull();
+  }
+
+  @Test
+  public void lazyIndirectionSelfCycle() {
+    SelfCycleComponent selfCycleComponent = DaggerCycles_SelfCycleComponent.create();
+    S s = selfCycleComponent.s();
+    assertThat(s.sLazy.get()).isNotNull();
+  }
+
+  @Test
+  public void lazyIndirectionCycle() {
+    CycleComponent cycleComponent = DaggerCycles_CycleComponent.create();
+    A a = cycleComponent.a();
+    C c = cycleComponent.c();
+    assertThat(c.aLazy.get()).isNotNull();
+    assertThat(a.b.c.aLazy.get()).isNotNull();
+    assertThat(a.e.d.b.c.aLazy.get()).isNotNull();
+  }
+  
+  @Test
+  public void subcomponentIndirectionCycle() {
+    ChildCycleComponent childCycleComponent = DaggerCycles_CycleComponent.create().child();
+    A a = childCycleComponent.a();
+    assertThat(a.b.c.aProvider.get()).isNotNull();
+    assertThat(a.e.d.b.c.aProvider.get()).isNotNull();
+  }
+  
+  @Test
+  public void providerMapIndirectionCycle() {
+    CycleMapComponent cycleMapComponent = DaggerCycles_CycleMapComponent.create();
+    assertThat(cycleMapComponent.y()).isNotNull();
+    assertThat(cycleMapComponent.y().mapOfProvidersOfX).containsKey("X");
+    assertThat(cycleMapComponent.y().mapOfProvidersOfX.get("X")).isNotNull();
+    assertThat(cycleMapComponent.y().mapOfProvidersOfX.get("X").get()).isNotNull();
+    assertThat(cycleMapComponent.y().mapOfProvidersOfX.get("X").get().y).isNotNull();
+    assertThat(cycleMapComponent.y().mapOfProvidersOfX).hasSize(1);
+    assertThat(cycleMapComponent.y().mapOfProvidersOfY).containsKey("Y");
+    assertThat(cycleMapComponent.y().mapOfProvidersOfY.get("Y")).isNotNull();
+    assertThat(cycleMapComponent.y().mapOfProvidersOfY.get("Y").get()).isNotNull();
+    assertThat(cycleMapComponent.y().mapOfProvidersOfY.get("Y").get().mapOfProvidersOfX).hasSize(1);
+    assertThat(cycleMapComponent.y().mapOfProvidersOfY.get("Y").get().mapOfProvidersOfY).hasSize(1);
+    assertThat(cycleMapComponent.y().mapOfProvidersOfY).hasSize(1);
+  }
+}
diff --git a/javatests/dagger/functional/cycle/Cycles.java b/javatests/dagger/functional/cycle/Cycles.java
new file mode 100644
index 000000000..2f4cd28f4
--- /dev/null
+++ b/javatests/dagger/functional/cycle/Cycles.java
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.cycle;
+
+import dagger.Binds;
+import dagger.Component;
+import dagger.Lazy;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.StringKey;
+import java.util.Map;
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+/**
+ * Cycle classes used for testing cyclic dependencies.
+ *
+ * <pre>
+ * {@literal A  (E  D  B  C  Provider<A>, Lazy<A>), (B  C  Provider<A>, Lazy<A>)}
+ * {@literal S  Provider<S>, Lazy<S>}
+ * </pre>
+ *
+ * @author Tony Bentancur
+ * @since 2.0
+ */
+final class Cycles {
+  private Cycles() {}
+
+  static class A {
+    public final B b;
+    public final E e;
+
+    @Inject
+    A(E e, B b) {
+      this.e = e;
+      this.b = b;
+    }
+  }
+
+  static class B {
+    public final C c;
+
+    @Inject
+    B(C c) {
+      this.c = c;
+    }
+  }
+
+  static class C {
+    public final Provider<A> aProvider;
+    @Inject public Lazy<A> aLazy;
+    @Inject public Provider<Lazy<A>> aLazyProvider;
+
+    @Inject
+    C(Provider<A> aProvider) {
+      this.aProvider = aProvider;
+    }
+  }
+
+  static class D {
+    public final B b;
+
+    @Inject
+    D(B b) {
+      this.b = b;
+    }
+  }
+
+  static class E {
+    public final D d;
+
+    @Inject
+    E(D d) {
+      this.d = d;
+    }
+  }
+
+  static class S {
+    public final Provider<S> sProvider;
+    @Inject public Lazy<S> sLazy;
+
+    @Inject
+    S(Provider<S> sProvider) {
+      this.sProvider = sProvider;
+    }
+  }
+
+  static class X {
+    public final Y y;
+
+    @Inject
+    X(Y y) {
+      this.y = y;
+    }
+  }
+
+  static class Y {
+    public final Map<String, Provider<X>> mapOfProvidersOfX;
+    public final Map<String, Provider<Y>> mapOfProvidersOfY;
+
+    @Inject
+    Y(Map<String, Provider<X>> mapOfProvidersOfX, Map<String, Provider<Y>> mapOfProvidersOfY) {
+      this.mapOfProvidersOfX = mapOfProvidersOfX;
+      this.mapOfProvidersOfY = mapOfProvidersOfY;
+    }
+  }
+
+  @Module
+  abstract static class CycleMapModule {
+    @Binds
+    @IntoMap
+    @StringKey("X")
+    abstract X x(X x);
+
+    @Binds
+    @IntoMap
+    @StringKey("Y")
+    abstract Y y(Y y);
+  }
+
+  @SuppressWarnings("dependency-cycle")
+  @Component(modules = CycleMapModule.class)
+  interface CycleMapComponent {
+    Y y();
+  }
+
+  @SuppressWarnings("dependency-cycle")
+  @Component(modules = CycleModule.class)
+  interface CycleComponent {
+    A a();
+
+    C c();
+
+    ChildCycleComponent child();
+  }
+
+  @Module
+  static class CycleModule {
+    @Provides
+    static Object provideObjectWithCycle(@SuppressWarnings("unused") Provider<Object> object) {
+      return "object";
+    }
+  }
+
+  @SuppressWarnings("dependency-cycle")
+  @Component
+  interface SelfCycleComponent {
+    S s();
+  }
+
+  @Subcomponent
+  interface ChildCycleComponent {
+    @SuppressWarnings("dependency-cycle")
+    A a();
+
+    @SuppressWarnings("dependency-cycle")
+    Object object();
+  }
+}
diff --git a/javatests/dagger/functional/cycle/LongCycle.java b/javatests/dagger/functional/cycle/LongCycle.java
new file mode 100644
index 000000000..1b3fb2484
--- /dev/null
+++ b/javatests/dagger/functional/cycle/LongCycle.java
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.cycle;
+
+import dagger.Component;
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+/**
+ * Component with a long enough cycle such that the initialization of a provider happens in a
+ * separate {@code initialize} method from the one where it is used as a delegated factory.
+ *
+ */
+// Each nested class's constructor has an intentionally unused parameter.
+@SuppressWarnings("unused")
+final class LongCycle {
+  static class Class1 { @Inject Class1(Class2 class2) {} }
+  static class Class2 { @Inject Class2(Class3 class3) {} }
+  static class Class3 { @Inject Class3(Class4 class4) {} }
+  static class Class4 { @Inject Class4(Class5 class5) {} }
+  static class Class5 { @Inject Class5(Class6 class6) {} }
+  static class Class6 { @Inject Class6(Class7 class7) {} }
+  static class Class7 { @Inject Class7(Class8 class8) {} }
+  static class Class8 { @Inject Class8(Class9 class9) {} }
+  static class Class9 { @Inject Class9(Class10 class10) {} }
+  static class Class10 { @Inject Class10(Class11 class11) {} }
+  static class Class11 { @Inject Class11(Class12 class12) {} }
+  static class Class12 { @Inject Class12(Class13 class13) {} }
+  static class Class13 { @Inject Class13(Class14 class14) {} }
+  static class Class14 { @Inject Class14(Class15 class15) {} }
+  static class Class15 { @Inject Class15(Class16 class16) {} }
+  static class Class16 { @Inject Class16(Class17 class17) {} }
+  static class Class17 { @Inject Class17(Class18 class18) {} }
+  static class Class18 { @Inject Class18(Class19 class19) {} }
+  static class Class19 { @Inject Class19(Class20 class20) {} }
+  static class Class20 { @Inject Class20(Class21 class21) {} }
+  static class Class21 { @Inject Class21(Class22 class22) {} }
+  static class Class22 { @Inject Class22(Class23 class23) {} }
+  static class Class23 { @Inject Class23(Class24 class24) {} }
+  static class Class24 { @Inject Class24(Class25 class25) {} }
+  static class Class25 { @Inject Class25(Class26 class26) {} }
+  static class Class26 { @Inject Class26(Class27 class27) {} }
+  static class Class27 { @Inject Class27(Class28 class28) {} }
+  static class Class28 { @Inject Class28(Class29 class29) {} }
+  static class Class29 { @Inject Class29(Class30 class30) {} }
+  static class Class30 { @Inject Class30(Class31 class31) {} }
+  static class Class31 { @Inject Class31(Class32 class32) {} }
+  static class Class32 { @Inject Class32(Class33 class33) {} }
+  static class Class33 { @Inject Class33(Class34 class34) {} }
+  static class Class34 { @Inject Class34(Class35 class35) {} }
+  static class Class35 { @Inject Class35(Class36 class36) {} }
+  static class Class36 { @Inject Class36(Class37 class37) {} }
+  static class Class37 { @Inject Class37(Class38 class38) {} }
+  static class Class38 { @Inject Class38(Class39 class39) {} }
+  static class Class39 { @Inject Class39(Class40 class40) {} }
+  static class Class40 { @Inject Class40(Class41 class41) {} }
+  static class Class41 { @Inject Class41(Class42 class42) {} }
+  static class Class42 { @Inject Class42(Class43 class43) {} }
+  static class Class43 { @Inject Class43(Class44 class44) {} }
+  static class Class44 { @Inject Class44(Class45 class45) {} }
+  static class Class45 { @Inject Class45(Class46 class46) {} }
+  static class Class46 { @Inject Class46(Class47 class47) {} }
+  static class Class47 { @Inject Class47(Class48 class48) {} }
+  static class Class48 { @Inject Class48(Class49 class49) {} }
+  static class Class49 { @Inject Class49(Class50 class50) {} }
+  static class Class50 { @Inject Class50(Class51 class51) {} }
+  static class Class51 { @Inject Class51(Class52 class52) {} }
+  static class Class52 { @Inject Class52(Class53 class53) {} }
+  static class Class53 { @Inject Class53(Class54 class54) {} }
+  static class Class54 { @Inject Class54(Class55 class55) {} }
+  static class Class55 { @Inject Class55(Class56 class56) {} }
+  static class Class56 { @Inject Class56(Class57 class57) {} }
+  static class Class57 { @Inject Class57(Class58 class58) {} }
+  static class Class58 { @Inject Class58(Class59 class59) {} }
+  static class Class59 { @Inject Class59(Class60 class60) {} }
+  static class Class60 { @Inject Class60(Class61 class61) {} }
+  static class Class61 { @Inject Class61(Class62 class62) {} }
+  static class Class62 { @Inject Class62(Class63 class63) {} }
+  static class Class63 { @Inject Class63(Class64 class64) {} }
+  static class Class64 { @Inject Class64(Class65 class65) {} }
+  static class Class65 { @Inject Class65(Class66 class66) {} }
+  static class Class66 { @Inject Class66(Class67 class67) {} }
+  static class Class67 { @Inject Class67(Class68 class68) {} }
+  static class Class68 { @Inject Class68(Class69 class69) {} }
+  static class Class69 { @Inject Class69(Class70 class70) {} }
+  static class Class70 { @Inject Class70(Class71 class71) {} }
+  static class Class71 { @Inject Class71(Class72 class72) {} }
+  static class Class72 { @Inject Class72(Class73 class73) {} }
+  static class Class73 { @Inject Class73(Class74 class74) {} }
+  static class Class74 { @Inject Class74(Class75 class75) {} }
+  static class Class75 { @Inject Class75(Class76 class76) {} }
+  static class Class76 { @Inject Class76(Class77 class77) {} }
+  static class Class77 { @Inject Class77(Class78 class78) {} }
+  static class Class78 { @Inject Class78(Class79 class79) {} }
+  static class Class79 { @Inject Class79(Class80 class80) {} }
+  static class Class80 { @Inject Class80(Class81 class81) {} }
+  static class Class81 { @Inject Class81(Class82 class82) {} }
+  static class Class82 { @Inject Class82(Class83 class83) {} }
+  static class Class83 { @Inject Class83(Class84 class84) {} }
+  static class Class84 { @Inject Class84(Class85 class85) {} }
+  static class Class85 { @Inject Class85(Class86 class86) {} }
+  static class Class86 { @Inject Class86(Class87 class87) {} }
+  static class Class87 { @Inject Class87(Class88 class88) {} }
+  static class Class88 { @Inject Class88(Class89 class89) {} }
+  static class Class89 { @Inject Class89(Class90 class90) {} }
+  static class Class90 { @Inject Class90(Class91 class91) {} }
+  static class Class91 { @Inject Class91(Class92 class92) {} }
+  static class Class92 { @Inject Class92(Class93 class93) {} }
+  static class Class93 { @Inject Class93(Class94 class94) {} }
+  static class Class94 { @Inject Class94(Class95 class95) {} }
+  static class Class95 { @Inject Class95(Class96 class96) {} }
+  static class Class96 { @Inject Class96(Class97 class97) {} }
+  static class Class97 { @Inject Class97(Class98 class98) {} }
+  static class Class98 { @Inject Class98(Class99 class99) {} }
+  static class Class99 { @Inject Class99(Class100 class100) {} }
+  static class Class100 { @Inject Class100(Class101 class101) {} }
+  static class Class101 { @Inject Class101(Provider<Class1> class1Provider) {} }
+
+  @SuppressWarnings("dependency-cycle")
+  @Component
+  interface LongCycleComponent {
+    Class1 class1();
+  }
+
+  private LongCycle() {}
+}
diff --git a/javatests/dagger/functional/cycle/LongCycleTest.java b/javatests/dagger/functional/cycle/LongCycleTest.java
new file mode 100644
index 000000000..fd5439556
--- /dev/null
+++ b/javatests/dagger/functional/cycle/LongCycleTest.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.cycle;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.functional.cycle.LongCycle.LongCycleComponent;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class LongCycleTest {
+  
+  /**
+   * Tests a cycle long enough that the real factory is created in a separate initialize method from
+   * the delegate factory.
+   */
+  @Test
+  public void longCycle() {
+    LongCycleComponent longCycleComponent = DaggerLongCycle_LongCycleComponent.create();
+    assertThat(longCycleComponent.class1()).isNotNull();
+  }
+
+  /**
+   * Fails if {@link LongCycleComponent} doesn't have a long enough cycle to make sure the real
+   * factory is created in a separate method from the delegate factory.
+   */
+  @Test
+  public void longCycleHasMoreThanOneInitializeMethod() throws NoSuchMethodException {
+    DaggerLongCycle_LongCycleComponent.class
+        .getDeclaredMethod("initialize2", DaggerLongCycle_LongCycleComponent.Builder.class);
+  }
+}
diff --git a/javatests/dagger/functional/guava/BUILD b/javatests/dagger/functional/guava/BUILD
new file mode 100644
index 000000000..d7c0c7389
--- /dev/null
+++ b/javatests/dagger/functional/guava/BUILD
@@ -0,0 +1,35 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   Functional tests for Dagger that depend on Guava
+
+package(default_visibility = ["//:src"])
+
+load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX")
+load("//:test_defs.bzl", "GenJavaTests")
+
+GenJavaTests(
+    name = "guava_tests",
+    srcs = glob(["**/*.java"]),
+    javacopts = DOCLINT_HTML_AND_SYNTAX,
+    deps = [
+        "//:dagger_with_compiler",
+        "//third_party:auto_value",
+        "//third_party:guava",
+        "//third_party:jsr330_inject",
+        "//third_party:junit",
+        "//third_party:truth",
+    ],
+)
diff --git a/javatests/dagger/functional/guava/OptionalBindingComponents.java b/javatests/dagger/functional/guava/OptionalBindingComponents.java
new file mode 100644
index 000000000..d2bb7d203
--- /dev/null
+++ b/javatests/dagger/functional/guava/OptionalBindingComponents.java
@@ -0,0 +1,149 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.guava;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
+import dagger.BindsOptionalOf;
+import dagger.Component;
+import dagger.Lazy;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.functional.tck.CarShop;
+
+import java.lang.annotation.Retention;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+
+/** Classes to support testing {@code BindsOptionalOf} functionality. */
+public final class OptionalBindingComponents {
+
+  /** A qualifier. */
+  @Qualifier
+  @Retention(RUNTIME)
+  public @interface SomeQualifier {}
+
+  /** A value object that contains various optionally-bound objects. */
+  @AutoValue
+  public abstract static class Values {
+    abstract Optional<Value> optionalInstance();
+
+    abstract Optional<Provider<Value>> optionalProvider();
+
+    abstract Optional<Lazy<Value>> optionalLazy();
+
+    abstract Optional<Provider<Lazy<Value>>> optionalLazyProvider();
+  }
+
+  // Default access so that it's inaccessible to OptionalBindingComponentsWithInaccessibleTypes.
+  enum Value {
+    VALUE,
+    QUALIFIED_VALUE
+  }
+
+  static final class InjectedThing {
+    @Inject
+    InjectedThing() {}
+  }
+
+  /** Binds optionals and {@link Values}. */
+  @Module
+  public abstract static class OptionalBindingModule {
+    @BindsOptionalOf
+    abstract Value value();
+
+    @BindsOptionalOf
+    @SomeQualifier abstract Value qualifiedValue();
+
+    // Valid because it's qualified.
+    @BindsOptionalOf
+    @SomeQualifier abstract InjectedThing qualifiedInjectedThing();
+
+    @Provides
+    static Values values(
+        Optional<Value> optionalInstance,
+        Optional<Provider<Value>> optionalProvider,
+        Optional<Lazy<Value>> optionalLazy,
+        Optional<Provider<Lazy<Value>>> optionalLazyProvider) {
+      return new AutoValue_OptionalBindingComponents_Values(
+          optionalInstance, optionalProvider, optionalLazy, optionalLazyProvider);
+    }
+
+    @Provides
+    @SomeQualifier
+    static Values qualifiedValues(
+        @SomeQualifier Optional<Value> optionalInstance,
+        @SomeQualifier Optional<Provider<Value>> optionalProvider,
+        @SomeQualifier Optional<Lazy<Value>> optionalLazy,
+        @SomeQualifier Optional<Provider<Lazy<Value>>> optionalLazyProvider) {
+      return new AutoValue_OptionalBindingComponents_Values(
+          optionalInstance, optionalProvider, optionalLazy, optionalLazyProvider);
+    }
+  }
+
+  /** Binds {@link Value}. */
+  @Module
+  public abstract static class ConcreteBindingModule {
+    /** @param cycle to demonstrate that optional {@link Provider} injection can break cycles */
+    @Provides
+    static Value value(Optional<Provider<Value>> cycle) {
+      return Value.VALUE;
+    }
+
+    @Provides
+    @SomeQualifier static Value qualifiedValue() {
+      return Value.QUALIFIED_VALUE;
+    }
+  }
+
+  /** Interface for components used to test optional bindings. */
+  public interface OptionalBindingComponent {
+    Values values();
+
+    @SomeQualifier
+    Values qualifiedValues();
+  }
+
+  @Component(modules = OptionalBindingModule.class)
+  interface AbsentOptionalBindingComponent extends OptionalBindingComponent {
+    PresentOptionalBindingSubcomponent presentChild();
+    @Component.Builder
+    interface Builder {
+      AbsentOptionalBindingComponent build();
+    }
+  }
+
+  @Component(modules = {OptionalBindingModule.class, ConcreteBindingModule.class})
+  interface PresentOptionalBindingComponent extends OptionalBindingComponent {
+    @Component.Builder
+    interface Builder {
+      PresentOptionalBindingComponent build();
+    }
+  }
+
+  @Subcomponent(modules = ConcreteBindingModule.class)
+  interface PresentOptionalBindingSubcomponent extends OptionalBindingComponent {
+    @Subcomponent.Builder
+    interface Builder {
+      PresentOptionalBindingSubcomponent build();
+    }
+  }
+}
diff --git a/javatests/dagger/functional/guava/OptionalBindingComponentsAbsentTest.java b/javatests/dagger/functional/guava/OptionalBindingComponentsAbsentTest.java
new file mode 100644
index 000000000..d563acea8
--- /dev/null
+++ b/javatests/dagger/functional/guava/OptionalBindingComponentsAbsentTest.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.guava;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.functional.guava.OptionalBindingComponents.AbsentOptionalBindingComponent;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for absent optional bindings. */
+@RunWith(JUnit4.class)
+public final class OptionalBindingComponentsAbsentTest {
+  private AbsentOptionalBindingComponent absent;
+
+  @Before
+  public void setUp() {
+    absent = DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create();
+  }
+
+  @Test
+  public void optional() {
+    assertThat(absent.values().optionalInstance()).isAbsent();
+  }
+
+  @Test
+  public void optionalProvider() {
+    assertThat(absent.values().optionalProvider()).isAbsent();
+  }
+
+  @Test
+  public void optionalLazy() {
+    assertThat(absent.values().optionalLazy()).isAbsent();
+  }
+
+  @Test
+  public void optionalLazyProvider() {
+    assertThat(absent.values().optionalLazyProvider()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptional() {
+    assertThat(absent.qualifiedValues().optionalInstance()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptionalProvider() {
+    assertThat(absent.qualifiedValues().optionalProvider()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptionalLazy() {
+    assertThat(absent.qualifiedValues().optionalLazy()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptionalLazyProvider() {
+    assertThat(absent.qualifiedValues().optionalLazyProvider()).isAbsent();
+  }
+}
diff --git a/javatests/dagger/functional/guava/OptionalBindingComponentsPresentTest.java b/javatests/dagger/functional/guava/OptionalBindingComponentsPresentTest.java
new file mode 100644
index 000000000..cc0832a93
--- /dev/null
+++ b/javatests/dagger/functional/guava/OptionalBindingComponentsPresentTest.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.guava;
+
+import static com.google.common.truth.Truth.assertThat;
+import static dagger.functional.guava.OptionalBindingComponents.Value.QUALIFIED_VALUE;
+import static dagger.functional.guava.OptionalBindingComponents.Value.VALUE;
+
+import com.google.common.collect.ImmutableList;
+import dagger.functional.guava.OptionalBindingComponents.OptionalBindingComponent;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+/** Tests for present optional bindings. */
+@RunWith(Parameterized.class)
+public final class OptionalBindingComponentsPresentTest {
+
+  @Parameters(name = "{0}")
+  public static Iterable<Object[]> parameters() {
+    return ImmutableList.copyOf(
+        new Object[][] {
+          {DaggerOptionalBindingComponents_PresentOptionalBindingComponent.create()},
+          {DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create().presentChild()},
+        });
+  }
+
+  private final OptionalBindingComponent component;
+
+  public OptionalBindingComponentsPresentTest(OptionalBindingComponent component) {
+    this.component = component;
+  }
+
+  @Test
+  public void optionalProvider() {
+    assertThat(component.values().optionalProvider().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void optionalLazy() {
+    assertThat(component.values().optionalLazy().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void optionalLazyProvider() {
+    assertThat(component.values().optionalLazyProvider().get().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void qualifiedOptional() {
+    assertThat(component.qualifiedValues().optionalInstance()).hasValue(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void qualifiedOptionalProvider() {
+    assertThat(component.qualifiedValues().optionalProvider().get().get())
+        .isEqualTo(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void qualifiedOptionalLazy() {
+    assertThat(component.qualifiedValues().optionalLazy().get().get()).isEqualTo(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void qualifiedOptionalLazyProvider() {
+    assertThat(component.qualifiedValues().optionalLazyProvider().get().get().get())
+        .isEqualTo(QUALIFIED_VALUE);
+  }
+}
diff --git a/javatests/dagger/functional/guava/a/OptionalBindingComponentsWithInaccessibleTypes.java b/javatests/dagger/functional/guava/a/OptionalBindingComponentsWithInaccessibleTypes.java
new file mode 100644
index 000000000..73008aa6e
--- /dev/null
+++ b/javatests/dagger/functional/guava/a/OptionalBindingComponentsWithInaccessibleTypes.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.guava.a;
+
+import dagger.Component;
+import dagger.functional.guava.OptionalBindingComponents;
+import dagger.functional.guava.OptionalBindingComponents.ConcreteBindingModule;
+import dagger.functional.guava.OptionalBindingComponents.OptionalBindingComponent;
+import dagger.functional.guava.OptionalBindingComponents.OptionalBindingModule;
+
+final class OptionalBindingComponentsWithInaccessibleTypes {
+
+  @Component(modules = OptionalBindingModule.class)
+  interface AbsentOptionalBindingComponent extends OptionalBindingComponent {
+    @Component.Builder
+    interface Builder {
+      AbsentOptionalBindingComponent build();
+    }
+  }
+
+  @Component(modules = {OptionalBindingModule.class, ConcreteBindingModule.class})
+  interface PresentOptionalBindingComponent extends OptionalBindingComponent {
+    @Component.Builder
+    interface Builder {
+      PresentOptionalBindingComponent build();
+    }
+  }
+}
diff --git a/javatests/dagger/functional/guava/a/OptionalBindingComponentsWithInaccessibleTypesTest.java b/javatests/dagger/functional/guava/a/OptionalBindingComponentsWithInaccessibleTypesTest.java
new file mode 100644
index 000000000..6be593cbd
--- /dev/null
+++ b/javatests/dagger/functional/guava/a/OptionalBindingComponentsWithInaccessibleTypesTest.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.guava.a;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for optional bindings that include types inaccessible to the component. */
+@RunWith(JUnit4.class)
+public class OptionalBindingComponentsWithInaccessibleTypesTest {
+  @Test
+  public void components() {
+    DaggerOptionalBindingComponentsWithInaccessibleTypes_AbsentOptionalBindingComponent.create();
+    DaggerOptionalBindingComponentsWithInaccessibleTypes_PresentOptionalBindingComponent.create();
+  }
+}
diff --git a/javatests/dagger/functional/gwt/GwtIncompatibles.java b/javatests/dagger/functional/gwt/GwtIncompatibles.java
new file mode 100644
index 000000000..d65f1169b
--- /dev/null
+++ b/javatests/dagger/functional/gwt/GwtIncompatibles.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.gwt;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import dagger.Module;
+import dagger.Provides;
+import java.lang.annotation.Retention;
+import javax.inject.Inject;
+
+interface GwtIncompatibles {
+  @Retention(RUNTIME)
+  @interface GwtIncompatible {}
+
+  @GwtIncompatible
+  class OnClass {
+    @Inject
+    OnClass() {}
+  }
+
+  class OnConstructor {
+    @Inject
+    @GwtIncompatible
+    OnConstructor() {}
+  }
+
+  @GwtIncompatible
+  class OuterClass {
+    static class OnOuterClass {
+      @Inject
+      OnOuterClass() {}
+    }
+  }
+
+  @GwtIncompatible
+  class MembersInjectedType {
+    @Inject String string;
+  }
+
+  @GwtIncompatible
+  @Module
+  class OnModule {
+    @Provides
+    static String onModule() {
+      return "on module";
+    }
+  }
+
+  @Module
+  class OnMethod {
+    @GwtIncompatible
+    @Provides
+    static String onMethod() {
+      return "on method";
+    }
+  }
+}
diff --git a/javatests/dagger/functional/gwt/GwtIncompatiblesTest.java b/javatests/dagger/functional/gwt/GwtIncompatiblesTest.java
new file mode 100644
index 000000000..c038e1dc1
--- /dev/null
+++ b/javatests/dagger/functional/gwt/GwtIncompatiblesTest.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.gwt;
+
+import dagger.functional.gwt.GwtIncompatibles.GwtIncompatible;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for {@code @GwtIncompatible} bindings. */
+@RunWith(JUnit4.class)
+public class GwtIncompatiblesTest {
+  @Test
+  public void testIncompatible() {
+    assertGwtIncompatible(GwtIncompatibles_OnClass_Factory.class);
+    assertGwtIncompatible(GwtIncompatibles_OnConstructor_Factory.class);
+    assertGwtIncompatible(GwtIncompatibles_OuterClass_OnOuterClass_Factory.class);
+
+    assertGwtIncompatible(GwtIncompatibles_MembersInjectedType_MembersInjector.class);
+
+    assertGwtIncompatible(GwtIncompatibles_OnModule_OnModuleFactory.class);
+    assertGwtIncompatible(GwtIncompatibles_OnMethod_OnMethodFactory.class);
+  }
+
+  private void assertGwtIncompatible(Class<?> clazz) {
+    boolean gwtIncompatible = clazz.getAnnotation(GwtIncompatible.class) != null;
+    if (!gwtIncompatible) {
+      throw new AssertionError(clazz.getCanonicalName() + " is not @GwtIncompatible");
+    }
+  }
+}
diff --git a/javatests/dagger/functional/jdk8/BUILD b/javatests/dagger/functional/jdk8/BUILD
new file mode 100644
index 000000000..5cb4013bd
--- /dev/null
+++ b/javatests/dagger/functional/jdk8/BUILD
@@ -0,0 +1,36 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   Functional tests for Dagger that depend on Guava
+
+package(default_visibility = ["//:src"])
+
+load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX")
+load("//:test_defs.bzl", "GenJavaTests")
+
+GenJavaTests(
+    name = "jdk8_tests",
+    srcs = glob(["**/*.java"]),
+    javacopts = DOCLINT_HTML_AND_SYNTAX,
+    test_only_deps = [
+        "//third_party:guava",
+        "//third_party:junit",
+        "//third_party:truth8",
+    ],
+    deps = [
+        "//:dagger_with_compiler",
+        "//third_party:auto_value",
+    ],
+)
diff --git a/javatests/dagger/functional/jdk8/OptionalBindingComponents.java b/javatests/dagger/functional/jdk8/OptionalBindingComponents.java
new file mode 100644
index 000000000..6a0c1caf5
--- /dev/null
+++ b/javatests/dagger/functional/jdk8/OptionalBindingComponents.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.jdk8;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import com.google.auto.value.AutoValue;
+import dagger.BindsOptionalOf;
+import dagger.Component;
+import dagger.Lazy;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+
+import java.lang.annotation.Retention;
+import java.util.Optional;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+
+/** Classes to support testing {@code BindsOptionalOf} functionality. */
+public final class OptionalBindingComponents {
+
+  /** A qualifier. */
+  @Qualifier
+  @Retention(RUNTIME)
+  public @interface SomeQualifier {}
+
+  /** A value object that contains various optionally-bound objects. */
+  @AutoValue
+  public abstract static class Values {
+    abstract Optional<Value> optionalInstance();
+
+    abstract Optional<Provider<Value>> optionalProvider();
+
+    abstract Optional<Lazy<Value>> optionalLazy();
+
+    abstract Optional<Provider<Lazy<Value>>> optionalLazyProvider();
+  }
+
+  // Default access so that it's inaccessible to OptionalBindingComponentsWithInaccessibleTypes.
+  enum Value {
+    VALUE,
+    QUALIFIED_VALUE
+  }
+
+  static final class InjectedThing {
+    @Inject
+    InjectedThing() {}
+  }
+
+  /** Binds optionals and {@link Values}. */
+  @Module
+  public abstract static class OptionalBindingModule {
+    @BindsOptionalOf
+    abstract Value value();
+
+    @BindsOptionalOf
+    @SomeQualifier abstract Value qualifiedValue();
+
+    // Valid because it's qualified.
+    @BindsOptionalOf
+    @SomeQualifier abstract InjectedThing qualifiedInjectedThing();
+
+    @Provides
+    static Values values(
+        Optional<Value> optionalInstance,
+        Optional<Provider<Value>> optionalProvider,
+        Optional<Lazy<Value>> optionalLazy,
+        Optional<Provider<Lazy<Value>>> optionalLazyProvider) {
+      return new AutoValue_OptionalBindingComponents_Values(
+          optionalInstance, optionalProvider, optionalLazy, optionalLazyProvider);
+    }
+
+    @Provides
+    @SomeQualifier
+    static Values qualifiedValues(
+        @SomeQualifier Optional<Value> optionalInstance,
+        @SomeQualifier Optional<Provider<Value>> optionalProvider,
+        @SomeQualifier Optional<Lazy<Value>> optionalLazy,
+        @SomeQualifier Optional<Provider<Lazy<Value>>> optionalLazyProvider) {
+      return new AutoValue_OptionalBindingComponents_Values(
+          optionalInstance, optionalProvider, optionalLazy, optionalLazyProvider);
+    }
+  }
+
+  /** Binds {@link Value}. */
+  @Module
+  public abstract static class ConcreteBindingModule {
+    /** @param cycle to demonstrate that optional {@link Provider} injection can break cycles */
+    @Provides
+    static Value value(Optional<Provider<Value>> cycle) {
+      return Value.VALUE;
+    }
+
+    @Provides
+    @SomeQualifier static Value qualifiedValue() {
+      return Value.QUALIFIED_VALUE;
+    }
+  }
+
+  /** Interface for components used to test optional bindings. */
+  public interface OptionalBindingComponent {
+    Values values();
+
+    @SomeQualifier
+    Values qualifiedValues();
+  }
+
+  @Component(modules = OptionalBindingModule.class)
+  interface EmptyOptionalBindingComponent extends OptionalBindingComponent {
+    PresentOptionalBindingSubcomponent presentChild();
+    @Component.Builder
+    interface Builder {
+      EmptyOptionalBindingComponent build();
+    }
+  }
+
+  @Component(modules = {OptionalBindingModule.class, ConcreteBindingModule.class})
+  interface PresentOptionalBindingComponent extends OptionalBindingComponent {
+    @Component.Builder
+    interface Builder {
+      PresentOptionalBindingComponent build();
+    }
+  }
+
+  @Subcomponent(modules = ConcreteBindingModule.class)
+  interface PresentOptionalBindingSubcomponent extends OptionalBindingComponent {
+    @Subcomponent.Builder
+    interface Builder {
+      PresentOptionalBindingSubcomponent build();
+    }
+  }
+}
diff --git a/javatests/dagger/functional/jdk8/OptionalBindingComponentsEmptyTest.java b/javatests/dagger/functional/jdk8/OptionalBindingComponentsEmptyTest.java
new file mode 100644
index 000000000..21bdd3c85
--- /dev/null
+++ b/javatests/dagger/functional/jdk8/OptionalBindingComponentsEmptyTest.java
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.jdk8;
+
+import static com.google.common.truth.Truth8.assertThat;
+
+import dagger.functional.jdk8.OptionalBindingComponents.EmptyOptionalBindingComponent;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for absent optional bindings. */
+@RunWith(JUnit4.class)
+public final class OptionalBindingComponentsEmptyTest {
+  private EmptyOptionalBindingComponent component;
+
+  @Before
+  public void setUp() {
+    component = DaggerOptionalBindingComponents_EmptyOptionalBindingComponent.create();
+  }
+
+  @Test
+  public void optional() {
+    assertThat(component.values().optionalInstance()).isEmpty();
+  }
+
+  @Test
+  public void optionalProvider() {
+    assertThat(component.values().optionalProvider()).isEmpty();
+  }
+
+  @Test
+  public void optionalLazy() {
+    assertThat(component.values().optionalLazy()).isEmpty();
+  }
+
+  @Test
+  public void optionalLazyProvider() {
+    assertThat(component.values().optionalLazyProvider()).isEmpty();
+  }
+
+  @Test
+  public void qualifiedOptional() {
+    assertThat(component.qualifiedValues().optionalInstance()).isEmpty();
+  }
+
+  @Test
+  public void qualifiedOptionalProvider() {
+    assertThat(component.qualifiedValues().optionalProvider()).isEmpty();
+  }
+
+  @Test
+  public void qualifiedOptionalLazy() {
+    assertThat(component.qualifiedValues().optionalLazy()).isEmpty();
+  }
+
+  @Test
+  public void qualifiedOptionalLazyProvider() {
+    assertThat(component.qualifiedValues().optionalLazyProvider()).isEmpty();
+  }
+}
diff --git a/javatests/dagger/functional/jdk8/OptionalBindingComponentsPresentTest.java b/javatests/dagger/functional/jdk8/OptionalBindingComponentsPresentTest.java
new file mode 100644
index 000000000..f2a52ad80
--- /dev/null
+++ b/javatests/dagger/functional/jdk8/OptionalBindingComponentsPresentTest.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.jdk8;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth8.assertThat;
+import static dagger.functional.jdk8.OptionalBindingComponents.Value.QUALIFIED_VALUE;
+import static dagger.functional.jdk8.OptionalBindingComponents.Value.VALUE;
+
+import com.google.common.collect.ImmutableList;
+import dagger.functional.jdk8.OptionalBindingComponents.OptionalBindingComponent;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+/** Tests for present optional bindings. */
+@RunWith(Parameterized.class)
+public final class OptionalBindingComponentsPresentTest {
+
+  @Parameters(name = "{0}")
+  public static Iterable<Object[]> parameters() {
+    return ImmutableList.copyOf(
+        new Object[][] {
+          {DaggerOptionalBindingComponents_PresentOptionalBindingComponent.create()},
+          {DaggerOptionalBindingComponents_EmptyOptionalBindingComponent.create().presentChild()},
+        });
+  }
+
+  private final OptionalBindingComponent component;
+
+  public OptionalBindingComponentsPresentTest(OptionalBindingComponent component) {
+    this.component = component;
+  }
+
+  @Test
+  public void optionalProvider() {
+    assertThat(component.values().optionalProvider().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void optionalLazy() {
+    assertThat(component.values().optionalLazy().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void optionalLazyProvider() {
+    assertThat(component.values().optionalLazyProvider().get().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void qualifiedOptional() {
+    assertThat(component.qualifiedValues().optionalInstance()).hasValue(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void qualifiedOptionalProvider() {
+    assertThat(component.qualifiedValues().optionalProvider().get().get())
+        .isEqualTo(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void qualifiedOptionalLazy() {
+    assertThat(component.qualifiedValues().optionalLazy().get().get()).isEqualTo(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void qualifiedOptionalLazyProvider() {
+    assertThat(component.qualifiedValues().optionalLazyProvider().get().get().get())
+        .isEqualTo(QUALIFIED_VALUE);
+  }
+}
diff --git a/javatests/dagger/functional/jdk8/a/OptionalBindingComponentsWithInaccessibleTypes.java b/javatests/dagger/functional/jdk8/a/OptionalBindingComponentsWithInaccessibleTypes.java
new file mode 100644
index 000000000..be76a144a
--- /dev/null
+++ b/javatests/dagger/functional/jdk8/a/OptionalBindingComponentsWithInaccessibleTypes.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.jdk8.a;
+
+import dagger.Component;
+import dagger.functional.jdk8.OptionalBindingComponents.ConcreteBindingModule;
+import dagger.functional.jdk8.OptionalBindingComponents.OptionalBindingComponent;
+import dagger.functional.jdk8.OptionalBindingComponents.OptionalBindingModule;
+
+final class OptionalBindingComponentsWithInaccessibleTypes {
+
+  @Component(modules = OptionalBindingModule.class)
+  interface EmptyOptionalBindingComponent extends OptionalBindingComponent {
+    @Component.Builder
+    interface Builder {
+      EmptyOptionalBindingComponent build();
+    }
+  }
+
+  @Component(modules = {OptionalBindingModule.class, ConcreteBindingModule.class})
+  interface PresentOptionalBindingComponent extends OptionalBindingComponent {
+    @Component.Builder
+    interface Builder {
+      PresentOptionalBindingComponent build();
+    }
+  }
+}
diff --git a/javatests/dagger/functional/jdk8/a/OptionalBindingComponentsWithInaccessibleTypesTest.java b/javatests/dagger/functional/jdk8/a/OptionalBindingComponentsWithInaccessibleTypesTest.java
new file mode 100644
index 000000000..8e2687a36
--- /dev/null
+++ b/javatests/dagger/functional/jdk8/a/OptionalBindingComponentsWithInaccessibleTypesTest.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.jdk8.a;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for optional bindings that include types inaccessible to the component. */
+@RunWith(JUnit4.class)
+public class OptionalBindingComponentsWithInaccessibleTypesTest {
+  @Test
+  public void components() {
+    DaggerOptionalBindingComponentsWithInaccessibleTypes_EmptyOptionalBindingComponent.create();
+    DaggerOptionalBindingComponentsWithInaccessibleTypes_PresentOptionalBindingComponent.create();
+  }
+}
diff --git a/javatests/dagger/functional/membersinject/ChildOfArrayOfParentOfStringArray.java b/javatests/dagger/functional/membersinject/ChildOfArrayOfParentOfStringArray.java
new file mode 100644
index 000000000..61bef719c
--- /dev/null
+++ b/javatests/dagger/functional/membersinject/ChildOfArrayOfParentOfStringArray.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.membersinject;
+
+class ChildOfArrayOfParentOfStringArray extends
+    MembersInjectGenericParent<MembersInjectGenericParent<String[]>[]> {
+}
diff --git a/javatests/dagger/functional/membersinject/ChildOfPrimitiveIntArray.java b/javatests/dagger/functional/membersinject/ChildOfPrimitiveIntArray.java
new file mode 100644
index 000000000..154bcffd6
--- /dev/null
+++ b/javatests/dagger/functional/membersinject/ChildOfPrimitiveIntArray.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.membersinject;
+
+class ChildOfPrimitiveIntArray extends MembersInjectGenericParent<int[]> {
+
+}
diff --git a/javatests/dagger/functional/membersinject/ChildOfStringArray.java b/javatests/dagger/functional/membersinject/ChildOfStringArray.java
new file mode 100644
index 000000000..d8bab7cf5
--- /dev/null
+++ b/javatests/dagger/functional/membersinject/ChildOfStringArray.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.membersinject;
+
+class ChildOfStringArray extends MembersInjectGenericParent<String[]> {
+
+}
diff --git a/javatests/dagger/functional/membersinject/MembersInjectComponent.java b/javatests/dagger/functional/membersinject/MembersInjectComponent.java
new file mode 100644
index 000000000..ed261130e
--- /dev/null
+++ b/javatests/dagger/functional/membersinject/MembersInjectComponent.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.membersinject;
+
+import dagger.Component;
+
+@Component(modules = {MembersInjectModule.class})
+interface MembersInjectComponent {
+  
+  void inject(ChildOfStringArray subfoo);
+  void inject(ChildOfArrayOfParentOfStringArray subfoo);
+  void inject(ChildOfPrimitiveIntArray subfoo);
+  void inject(RawFrameworkTypes rawFrameworkTypes);
+
+}
diff --git a/javatests/dagger/functional/membersinject/MembersInjectGenericParent.java b/javatests/dagger/functional/membersinject/MembersInjectGenericParent.java
new file mode 100644
index 000000000..351934898
--- /dev/null
+++ b/javatests/dagger/functional/membersinject/MembersInjectGenericParent.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.membersinject;
+
+import javax.inject.Inject;
+
+class MembersInjectGenericParent<T> {
+  
+  @Inject T t; 
+
+}
diff --git a/javatests/dagger/functional/membersinject/MembersInjectModule.java b/javatests/dagger/functional/membersinject/MembersInjectModule.java
new file mode 100644
index 000000000..d60a7d1e8
--- /dev/null
+++ b/javatests/dagger/functional/membersinject/MembersInjectModule.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.membersinject;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class MembersInjectModule {
+  
+  @Provides String[] provideStringArray() { return new String[10]; }
+  
+  @Provides int[] provideIntArray() { return new int[10]; }
+  
+  @SuppressWarnings("unchecked")
+  @Provides MembersInjectGenericParent<String[]>[] provideFooArrayOfStringArray() { return new MembersInjectGenericParent[10]; }
+
+}
diff --git a/javatests/dagger/functional/membersinject/MembersInjectTest.java b/javatests/dagger/functional/membersinject/MembersInjectTest.java
new file mode 100644
index 000000000..0617fd5e5
--- /dev/null
+++ b/javatests/dagger/functional/membersinject/MembersInjectTest.java
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.membersinject;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.MembersInjector;
+import dagger.functional.multipackage.DaggerMembersInjectionVisibilityComponent;
+import dagger.functional.multipackage.MembersInjectionVisibilityComponent;
+import dagger.functional.multipackage.a.AGrandchild;
+import dagger.functional.multipackage.a.AParent;
+import dagger.functional.multipackage.b.BChild;
+import javax.inject.Provider;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class MembersInjectTest {
+  @Test public void testMembersInject_arrays() {
+    MembersInjectComponent component = DaggerMembersInjectComponent.builder().build();
+
+    ChildOfStringArray childOfStringArray = new ChildOfStringArray();
+    component.inject(childOfStringArray);
+  }
+
+  @Test public void testMembersInject_nestedArrays() {
+    MembersInjectComponent component = DaggerMembersInjectComponent.builder().build();
+
+    ChildOfArrayOfParentOfStringArray childOfArrayOfParentOfStringArray =
+        new ChildOfArrayOfParentOfStringArray();
+    component.inject(childOfArrayOfParentOfStringArray);
+  }
+
+  @Test public void testMembersInject_primitives() {
+    MembersInjectComponent component = DaggerMembersInjectComponent.builder().build();
+
+    ChildOfPrimitiveIntArray childOfPrimitiveIntArray = new ChildOfPrimitiveIntArray();
+    component.inject(childOfPrimitiveIntArray);
+  }
+
+  @Test
+  public void testMembersInject_overrides() {
+    MembersInjectionVisibilityComponent component =
+        DaggerMembersInjectionVisibilityComponent.create();
+    AParent aParent = new AParent();
+    component.inject(aParent);
+    assertThat(aParent.aParentField()).isNotNull();
+    assertThat(aParent.aParentMethod()).isNotNull();
+
+    BChild aChild = new BChild();
+    component.inject(aChild);
+    assertThat(aChild.aParentField()).isNotNull();
+    assertThat(aChild.aParentMethod()).isNull();
+    assertThat(aChild.aChildField()).isNotNull();
+    assertThat(aChild.aChildMethod()).isNotNull();
+
+    AGrandchild aGrandchild = new AGrandchild();
+    component.inject(aGrandchild);
+    assertThat(aGrandchild.aParentField()).isNotNull();
+    assertThat(aGrandchild.aParentMethod()).isNotNull();
+    assertThat(aGrandchild.aChildField()).isNotNull();
+    assertThat(aGrandchild.aChildMethod()).isNull();
+    assertThat(aGrandchild.aGrandchildField()).isNotNull();
+    assertThat(aGrandchild.aGrandchildMethod()).isNotNull();
+  }
+
+  @Test
+  public void testNonRequestedMembersInjector() {
+    NonRequestedChild child = new NonRequestedChild();
+    Provider<String> provider =
+        new Provider<String>() {
+          @Override
+          public String get() {
+            return "field!";
+          }
+        };
+    MembersInjector<NonRequestedChild> injector = new NonRequestedChild_MembersInjector(provider);
+    injector.injectMembers(child);
+    assertThat(child.t).isEqualTo("field!");
+  }
+}
diff --git a/javatests/dagger/functional/membersinject/NonRequestedChild.java b/javatests/dagger/functional/membersinject/NonRequestedChild.java
new file mode 100644
index 000000000..a06047397
--- /dev/null
+++ b/javatests/dagger/functional/membersinject/NonRequestedChild.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.membersinject;
+
+import javax.inject.Inject;
+
+/**
+ * A class that should not be requested by any component, to ensure that we still generate a members
+ * injector for it.
+ */
+class NonRequestedChild extends MembersInjectGenericParent<String> {
+  @Inject
+  NonRequestedChild() {}
+}
diff --git a/javatests/dagger/functional/membersinject/RawFrameworkTypes.java b/javatests/dagger/functional/membersinject/RawFrameworkTypes.java
new file mode 100644
index 000000000..21806135a
--- /dev/null
+++ b/javatests/dagger/functional/membersinject/RawFrameworkTypes.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.membersinject;
+
+import dagger.Lazy;
+import dagger.MembersInjector;
+import javax.inject.Provider;
+
+// https://github.com/google/dagger/issues/419
+@SuppressWarnings({"rawtypes", "unused"})
+class RawFrameworkTypes {
+  void nonInjectMethodWithARawProvider(Provider rawProvider) {}
+  void nonInjectMethodWithARawLazy(Lazy rawLazy) {}
+  void nonInjectMethodWithARawMembersInjector(MembersInjector rawMembersInjector) {}
+}
diff --git a/javatests/dagger/functional/multipackage/FooComponent.java b/javatests/dagger/functional/multipackage/FooComponent.java
new file mode 100644
index 000000000..ef5b8d591
--- /dev/null
+++ b/javatests/dagger/functional/multipackage/FooComponent.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multipackage;
+
+import dagger.Component;
+import dagger.functional.multipackage.a.AModule;
+import dagger.functional.multipackage.a.UsesInaccessible;
+import dagger.functional.multipackage.a.UsesInaccessibleInGenericsOnly;
+import dagger.functional.multipackage.sub.FooChildComponent;
+import java.util.Set;
+
+/**
+ * A component that tests the interaction between subcomponents, multiple packages, and
+ * multibindings. Specifically, we want:
+ * <ul>
+ * <li>A set binding with some contributions in the parent component, and some in the subcomponent.
+ * <li>The contributions come from different packages, but not the package of either component.
+ * <li>The set binding is requested in the subcomponent through a binding from a separate package.
+ * <li>No binding in the subcomponent, that's in the subcomponent's package, directly uses any
+ *     binding from the component's package.
+ * </ul>
+ */
+// NOTE(beder): Be careful about changing any bindings in either this component or the subcomponent.
+// Even adding a binding might stop this test from testing what it's supposed to test.
+@Component(modules = {AModule.class})
+interface FooComponent {
+  Set<String> setOfString();
+
+  FooChildComponent fooChildComponent();
+
+  UsesInaccessible usesInaccessible();
+
+  UsesInaccessibleInGenericsOnly accessibleConstructorUsesInaccessibleInGenericsOnly();
+}
diff --git a/javatests/dagger/functional/multipackage/MembersInjectionVisibilityComponent.java b/javatests/dagger/functional/multipackage/MembersInjectionVisibilityComponent.java
new file mode 100644
index 000000000..32b9c5ef4
--- /dev/null
+++ b/javatests/dagger/functional/multipackage/MembersInjectionVisibilityComponent.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multipackage;
+
+import dagger.Component;
+import dagger.functional.multipackage.a.AGrandchild;
+import dagger.functional.multipackage.a.AModule;
+import dagger.functional.multipackage.a.AParent;
+import dagger.functional.multipackage.b.BChild;
+
+/**
+ * A component that tests members injection across packages and subclasses.
+ */
+@Component(modules = {AModule.class})
+public interface MembersInjectionVisibilityComponent {
+  void inject(AParent aParent);
+
+  void inject(BChild aChild);
+
+  void inject(AGrandchild aGrandchild);
+}
diff --git a/javatests/dagger/functional/multipackage/MultibindsComponent.java b/javatests/dagger/functional/multipackage/MultibindsComponent.java
new file mode 100644
index 000000000..dbeeed8ee
--- /dev/null
+++ b/javatests/dagger/functional/multipackage/MultibindsComponent.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multipackage;
+
+import dagger.Component;
+import dagger.functional.multipackage.a.AMultibindsModule;
+import dagger.functional.multipackage.a.UsesInaccessible;
+
+/**
+ * A component that tests the interaction between multiple packages and {@code @Multibinding}s.
+ * Specifically, we want:
+ *
+ * <ul>
+ * <li>A {@code @Multibinding} for an empty set of a type not accessible from this package.
+ * <li>A {@code @Multibinding} for an empty map of a type not accessible from this package.
+ * <li>A public type that injects the empty set and map of inaccessible objects.
+ * </ul>
+ */
+@Component(modules = {AMultibindsModule.class})
+interface MultibindsComponent {
+  UsesInaccessible usesInaccessible();
+}
diff --git a/javatests/dagger/functional/multipackage/a/AGrandchild.java b/javatests/dagger/functional/multipackage/a/AGrandchild.java
new file mode 100644
index 000000000..ffb03d5c9
--- /dev/null
+++ b/javatests/dagger/functional/multipackage/a/AGrandchild.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multipackage.a;
+
+import dagger.functional.multipackage.b.BChild;
+import javax.inject.Inject;
+
+public class AGrandchild extends BChild {
+
+  @Inject APackagePrivateObject aGrandchildField;
+
+  private APackagePrivateObject aGrandchildMethod;
+
+  @Inject
+  void aGrandchildMethod(APackagePrivateObject aGrandchildMethod) {
+    this.aGrandchildMethod = aGrandchildMethod;
+  }
+
+  @Override
+  @Inject
+  protected void aParentMethod(APublicObject aParentMethod) {
+    super.aParentMethod(aParentMethod);
+  }
+
+  @SuppressWarnings("OverridesJavaxInjectableMethod")
+  @Override
+  protected void aChildMethod(APublicObject aChildMethod) {
+    super.aChildMethod(aChildMethod);
+  }
+
+  public APackagePrivateObject aGrandchildField() {
+    return aGrandchildField;
+  }
+
+  public APackagePrivateObject aGrandchildMethod() {
+    return aGrandchildMethod;
+  }
+}
diff --git a/javatests/dagger/functional/multipackage/a/AModule.java b/javatests/dagger/functional/multipackage/a/AModule.java
new file mode 100644
index 000000000..9f6a7c548
--- /dev/null
+++ b/javatests/dagger/functional/multipackage/a/AModule.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multipackage.a;
+
+import dagger.Binds;
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+import dagger.multibindings.StringKey;
+import java.util.HashSet;
+import java.util.Set;
+
+@Module
+public abstract class AModule {
+  @Provides
+  @IntoSet
+  static String provideString() {
+    return "a";
+  }
+
+  @Binds
+  @IntoSet
+  abstract Inaccessible provideInaccessible(Inaccessible inaccessible);
+
+  @Provides
+  @ElementsIntoSet
+  static Set<Inaccessible> provideSetOfInaccessibles() {
+    return new HashSet<>();
+  }
+
+  @Binds
+  @IntoMap
+  @StringKey("inaccessible")
+  abstract Inaccessible provideInaccessibleToMap(Inaccessible inaccessible);
+}
diff --git a/javatests/dagger/functional/multipackage/a/AMultibindsModule.java b/javatests/dagger/functional/multipackage/a/AMultibindsModule.java
new file mode 100644
index 000000000..bcf28c9e4
--- /dev/null
+++ b/javatests/dagger/functional/multipackage/a/AMultibindsModule.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multipackage.a;
+
+import dagger.Module;
+import dagger.multibindings.Multibinds;
+import java.util.Map;
+import java.util.Set;
+
+/** A module that {@code @Multibinds} a set and a map of {@link Inaccessible}. */
+@Module
+public abstract class AMultibindsModule {
+  @Multibinds
+  abstract Set<Inaccessible> inaccessibleSet();
+
+  @Multibinds
+  abstract Map<String, Inaccessible> inaccessibleMap();
+}
diff --git a/javatests/dagger/functional/multipackage/a/APackagePrivateObject.java b/javatests/dagger/functional/multipackage/a/APackagePrivateObject.java
new file mode 100644
index 000000000..f674b8206
--- /dev/null
+++ b/javatests/dagger/functional/multipackage/a/APackagePrivateObject.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multipackage.a;
+
+import javax.inject.Inject;
+
+class APackagePrivateObject {
+
+  @Inject
+  APackagePrivateObject() {}
+}
diff --git a/javatests/dagger/functional/multipackage/a/AParent.java b/javatests/dagger/functional/multipackage/a/AParent.java
new file mode 100644
index 000000000..de99ffdab
--- /dev/null
+++ b/javatests/dagger/functional/multipackage/a/AParent.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multipackage.a;
+
+import javax.inject.Inject;
+
+public class AParent {
+
+  @Inject APackagePrivateObject aParentField;
+
+  private APublicObject aParentMethod;
+
+  @Inject
+  protected void aParentMethod(APublicObject aParentMethod) {
+    this.aParentMethod = aParentMethod;
+  }
+
+  public APackagePrivateObject aParentField() {
+    return aParentField;
+  }
+
+  public APublicObject aParentMethod() {
+    return aParentMethod;
+  }
+}
diff --git a/javatests/dagger/functional/multipackage/a/APublicObject.java b/javatests/dagger/functional/multipackage/a/APublicObject.java
new file mode 100644
index 000000000..6c8572169
--- /dev/null
+++ b/javatests/dagger/functional/multipackage/a/APublicObject.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multipackage.a;
+
+import javax.inject.Inject;
+
+public class APublicObject {
+
+  @Inject
+  APublicObject() {}
+}
diff --git a/javatests/dagger/functional/multipackage/a/Inaccessible.java b/javatests/dagger/functional/multipackage/a/Inaccessible.java
new file mode 100644
index 000000000..30e286118
--- /dev/null
+++ b/javatests/dagger/functional/multipackage/a/Inaccessible.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multipackage.a;
+
+import javax.inject.Inject;
+
+final class Inaccessible {
+  @Inject Inaccessible() {}
+}
\ No newline at end of file
diff --git a/javatests/dagger/functional/multipackage/a/UsesInaccessible.java b/javatests/dagger/functional/multipackage/a/UsesInaccessible.java
new file mode 100644
index 000000000..745bb1dc9
--- /dev/null
+++ b/javatests/dagger/functional/multipackage/a/UsesInaccessible.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multipackage.a;
+
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Inject;
+
+@SuppressWarnings("unused")
+public class UsesInaccessible {
+  @Inject
+  public UsesInaccessible(
+      Inaccessible inaccessible,
+      Set<Inaccessible> inaccessibleSet,
+      Map<String, Inaccessible> inaccessibleMap) {}
+}
diff --git a/javatests/dagger/functional/multipackage/a/UsesInaccessibleInGenericsOnly.java b/javatests/dagger/functional/multipackage/a/UsesInaccessibleInGenericsOnly.java
new file mode 100644
index 000000000..a69aa56f5
--- /dev/null
+++ b/javatests/dagger/functional/multipackage/a/UsesInaccessibleInGenericsOnly.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multipackage.a;
+
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Inject;
+
+@SuppressWarnings("unused")
+public class UsesInaccessibleInGenericsOnly {
+  @Inject
+  public UsesInaccessibleInGenericsOnly(
+      Set<Inaccessible> inaccessibleSet, Map<String, Inaccessible> inaccessibleMap) {}
+}
diff --git a/javatests/dagger/functional/multipackage/b/BChild.java b/javatests/dagger/functional/multipackage/b/BChild.java
new file mode 100644
index 000000000..fe5da6677
--- /dev/null
+++ b/javatests/dagger/functional/multipackage/b/BChild.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multipackage.b;
+
+import dagger.functional.multipackage.a.AParent;
+import dagger.functional.multipackage.a.APublicObject;
+import javax.inject.Inject;
+
+public class BChild extends AParent {
+
+  @Inject BPackagePrivateObject aChildField;
+
+  private APublicObject aChildMethod;
+
+  @Inject
+  protected void aChildMethod(APublicObject aChildMethod) {
+    this.aChildMethod = aChildMethod;
+  }
+
+  @SuppressWarnings("OverridesJavaxInjectableMethod")
+  @Override
+  protected void aParentMethod(APublicObject aParentMethod) {
+    super.aParentMethod(aParentMethod);
+  }
+
+  public BPackagePrivateObject aChildField() {
+    return aChildField;
+  }
+
+  public APublicObject aChildMethod() {
+    return aChildMethod;
+  }
+}
diff --git a/javatests/dagger/functional/multipackage/b/BModule.java b/javatests/dagger/functional/multipackage/b/BModule.java
new file mode 100644
index 000000000..6edf4bfc9
--- /dev/null
+++ b/javatests/dagger/functional/multipackage/b/BModule.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multipackage.b;
+
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.IntoSet;
+
+@Module
+public final class BModule {
+  @Provides
+  @IntoSet
+  static String provideString() {
+    return "b";
+  }
+}
diff --git a/javatests/dagger/functional/multipackage/b/BPackagePrivateObject.java b/javatests/dagger/functional/multipackage/b/BPackagePrivateObject.java
new file mode 100644
index 000000000..b785a4aab
--- /dev/null
+++ b/javatests/dagger/functional/multipackage/b/BPackagePrivateObject.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multipackage.b;
+
+import javax.inject.Inject;
+
+class BPackagePrivateObject {
+
+  @Inject
+  BPackagePrivateObject() {}
+}
diff --git a/javatests/dagger/functional/multipackage/c/CModule.java b/javatests/dagger/functional/multipackage/c/CModule.java
new file mode 100644
index 000000000..df257addd
--- /dev/null
+++ b/javatests/dagger/functional/multipackage/c/CModule.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multipackage.c;
+
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.IntoSet;
+
+@Module
+public final class CModule {
+  @Provides
+  @IntoSet
+  static String provideString() {
+    return "c";
+  }
+}
diff --git a/javatests/dagger/functional/multipackage/d/DModule.java b/javatests/dagger/functional/multipackage/d/DModule.java
new file mode 100644
index 000000000..c98d647db
--- /dev/null
+++ b/javatests/dagger/functional/multipackage/d/DModule.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multipackage.d;
+
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.IntoSet;
+
+@Module
+public final class DModule {
+  @Provides
+  @IntoSet
+  static String provideString() {
+    return "d";
+  }
+}
diff --git a/javatests/dagger/functional/multipackage/foo/Foo.java b/javatests/dagger/functional/multipackage/foo/Foo.java
new file mode 100644
index 000000000..1c06aa5f8
--- /dev/null
+++ b/javatests/dagger/functional/multipackage/foo/Foo.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multipackage.foo;
+
+import java.util.Set;
+import javax.inject.Inject;
+
+public final class Foo<T> {
+  public final Set<String> strings;
+
+  @Inject Foo(Set<String> strings) {
+    this.strings = strings;
+  }
+}
diff --git a/javatests/dagger/functional/multipackage/grandsub/FooGrandchildComponent.java b/javatests/dagger/functional/multipackage/grandsub/FooGrandchildComponent.java
new file mode 100644
index 000000000..171b92a0c
--- /dev/null
+++ b/javatests/dagger/functional/multipackage/grandsub/FooGrandchildComponent.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multipackage.grandsub;
+
+import dagger.Subcomponent;
+import dagger.functional.multipackage.d.DModule;
+import dagger.functional.multipackage.foo.Foo;
+
+@Subcomponent(modules = DModule.class)
+public interface FooGrandchildComponent {
+  Foo<FooGrandchildComponent> foo();
+}
diff --git a/javatests/dagger/functional/multipackage/sub/FooChildComponent.java b/javatests/dagger/functional/multipackage/sub/FooChildComponent.java
new file mode 100644
index 000000000..b4f138983
--- /dev/null
+++ b/javatests/dagger/functional/multipackage/sub/FooChildComponent.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.multipackage.sub;
+
+import dagger.Subcomponent;
+import dagger.functional.multipackage.b.BModule;
+import dagger.functional.multipackage.c.CModule;
+import dagger.functional.multipackage.foo.Foo;
+import dagger.functional.multipackage.grandsub.FooGrandchildComponent;
+
+@Subcomponent(modules = {BModule.class, CModule.class})
+public interface FooChildComponent {
+  Foo<FooChildComponent> foo();
+
+  FooGrandchildComponent fooGrandchildComponent();
+}
diff --git a/javatests/dagger/functional/nullables/NullComponent.java b/javatests/dagger/functional/nullables/NullComponent.java
new file mode 100644
index 000000000..8d8d757b3
--- /dev/null
+++ b/javatests/dagger/functional/nullables/NullComponent.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.nullables;
+
+import dagger.Component;
+import javax.inject.Provider;
+
+@Component(modules = NullModule.class)
+interface NullComponent {
+  NullFoo nullFoo();
+  @Nullable String string();
+  Provider<String> stringProvider();
+  Number number();
+  Provider<Number> numberProvider();
+}
diff --git a/javatests/dagger/functional/nullables/NullComponentWithDependency.java b/javatests/dagger/functional/nullables/NullComponentWithDependency.java
new file mode 100644
index 000000000..dfb4b8243
--- /dev/null
+++ b/javatests/dagger/functional/nullables/NullComponentWithDependency.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.nullables;
+
+import dagger.Component;
+import javax.inject.Provider;
+
+@Component(dependencies = NullComponent.class)
+interface NullComponentWithDependency {
+  @Nullable String string();
+  Provider<String> stringProvider();
+  Number number();
+  Provider<Number> numberProvider();
+}
diff --git a/javatests/dagger/functional/nullables/NullFoo.java b/javatests/dagger/functional/nullables/NullFoo.java
new file mode 100644
index 000000000..b3f9a67af
--- /dev/null
+++ b/javatests/dagger/functional/nullables/NullFoo.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.nullables;
+
+import javax.inject.Inject;
+import javax.inject.Provider;
+
+class NullFoo {
+  final String string;
+  final Provider<String> stringProvider;
+  final Number number;
+  final Provider<Number> numberProvider;
+
+  @Inject
+  NullFoo(@Nullable String string,
+      Provider<String> stringProvider,
+      Number number,
+      Provider<Number> numberProvider) {
+    this.string = string;
+    this.stringProvider = stringProvider;
+    this.number = number;
+    this.numberProvider = numberProvider;
+  }
+
+  String methodInjectedString;
+  Provider<String> methodInjectedStringProvider;
+  Number methodInjectedNumber;
+  Provider<Number> methodInjectedNumberProvider;
+  @Inject void inject(@Nullable String string,
+      Provider<String> stringProvider,
+      Number number,
+      Provider<Number> numberProvider) {
+    this.methodInjectedString = string;
+    this.methodInjectedStringProvider = stringProvider;
+    this.methodInjectedNumber = number;
+    this.methodInjectedNumberProvider = numberProvider;
+  }
+
+  @Nullable @Inject String fieldInjectedString;
+  @Inject Provider<String> fieldInjectedStringProvider;
+  @Inject Number fieldInjectedNumber;
+  @Inject Provider<Number> fieldInjectedNumberProvider;
+}
diff --git a/javatests/dagger/functional/nullables/NullModule.java b/javatests/dagger/functional/nullables/NullModule.java
new file mode 100644
index 000000000..00f35fd43
--- /dev/null
+++ b/javatests/dagger/functional/nullables/NullModule.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.nullables;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+class NullModule {
+  Number numberValue = null;
+
+  @Nullable
+  @Provides
+  String provideNullableString() {
+    return null;
+  }
+
+  @Provides
+  Number provideNumber() {
+    return numberValue;
+  }
+}
diff --git a/javatests/dagger/functional/nullables/NullabilityTest.java b/javatests/dagger/functional/nullables/NullabilityTest.java
new file mode 100644
index 000000000..e232d8534
--- /dev/null
+++ b/javatests/dagger/functional/nullables/NullabilityTest.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.nullables;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import javax.inject.Provider;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class NullabilityTest {
+  @Test public void testNullability_provides() {
+    NullModule module = new NullModule();
+    NullComponent component = DaggerNullComponent.builder().nullModule(module).build();
+
+    // Can't construct NullFoo because it depends on Number, and Number was null.
+    try {
+      component.nullFoo();
+      fail();
+    } catch (NullPointerException npe) {
+      assertThat(npe).hasMessage("Cannot return null from a non-@Nullable @Provides method");
+    }
+
+    // set number to non-null so we can create
+    module.numberValue = 1;
+    NullFoo nullFoo = component.nullFoo();
+
+    // Then set it back to null so we can test its providers.
+    module.numberValue = null;
+    validate(true, nullFoo.string, nullFoo.stringProvider, nullFoo.numberProvider);
+    validate(true, nullFoo.methodInjectedString, nullFoo.methodInjectedStringProvider,
+        nullFoo.methodInjectedNumberProvider);
+    validate(true, nullFoo.fieldInjectedString, nullFoo.fieldInjectedStringProvider,
+        nullFoo.fieldInjectedNumberProvider);
+  }
+  
+  @Test public void testNullability_components() {
+    NullComponent nullComponent = new NullComponent() {      
+      @Override public Provider<String> stringProvider() {
+        return new Provider<String>() {
+          @Override public String get() {
+            return null;
+          }
+        };
+      }
+      
+      @Override public String string() {
+        return null;
+      }
+      
+      @Override public Provider<Number> numberProvider() {
+        return new Provider<Number>() {
+          @Override public Number get() {
+            return null;
+          }
+        };
+      }
+      
+      @Override public Number number() {
+        return null;
+      }
+      
+      @Override public NullFoo nullFoo() {
+        return null;
+      }
+    };
+    NullComponentWithDependency component =
+        DaggerNullComponentWithDependency.builder().nullComponent(nullComponent).build();
+    validate(false, component.string(), component.stringProvider(), component.numberProvider());
+    
+    // Also validate that the component's number() method fails
+    try {
+      component.number();
+      fail();
+    } catch (NullPointerException npe) {
+      assertThat(npe).hasMessage("Cannot return null from a non-@Nullable component method");
+    }
+  }
+
+  private void validate(boolean fromProvides,
+      String string,
+      Provider<String> stringProvider,
+      Provider<Number> numberProvider) {
+    assertThat(string).isNull();
+    assertThat(numberProvider).isNotNull();
+    try {
+      numberProvider.get();
+      fail();
+    } catch(NullPointerException npe) {
+      assertThat(npe).hasMessage("Cannot return null from a non-@Nullable "
+          + (fromProvides ? "@Provides" : "component") + " method");
+    }
+    assertThat(stringProvider.get()).isNull();
+  }
+}
diff --git a/javatests/dagger/functional/nullables/Nullable.java b/javatests/dagger/functional/nullables/Nullable.java
new file mode 100644
index 000000000..cbfb98a9a
--- /dev/null
+++ b/javatests/dagger/functional/nullables/Nullable.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.nullables;
+
+@interface Nullable {}
diff --git a/javatests/dagger/functional/producers/BUILD b/javatests/dagger/functional/producers/BUILD
new file mode 100644
index 000000000..44e1fba86
--- /dev/null
+++ b/javatests/dagger/functional/producers/BUILD
@@ -0,0 +1,43 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   Functional tests for Dagger Producers
+
+package(default_visibility = ["//:src"])
+
+load(
+    "//:build_defs.bzl",
+    "DOCLINT_HTML_AND_SYNTAX",
+    "DOCLINT_REFERENCES",
+    "SOURCE_7_TARGET_7",
+)
+load("//:test_defs.bzl", "GenJavaTests")
+
+GenJavaTests(
+    name = "producers-functional-tests",
+    srcs = glob(["**/*.java"]),
+    javacopts = SOURCE_7_TARGET_7 + DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
+    deps = [
+        "//:producers_with_compiler",
+        "//third_party:auto_value",
+        "//third_party:guava",
+        "//third_party:jsr330_inject",
+        "//third_party:junit",
+        "//third_party:mockito",
+        "//third_party:truth",
+    ],
+)
+
+test_suite(name = "AllTests")
diff --git a/javatests/dagger/functional/producers/DependedComponent.java b/javatests/dagger/functional/producers/DependedComponent.java
new file mode 100644
index 000000000..9a4947a18
--- /dev/null
+++ b/javatests/dagger/functional/producers/DependedComponent.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers;
+
+import dagger.Component;
+
+@Component(modules = DependedModule.class)
+interface DependedComponent {
+  String getGreeting();
+}
+
diff --git a/javatests/dagger/functional/producers/DependedModule.java b/javatests/dagger/functional/producers/DependedModule.java
new file mode 100644
index 000000000..89ca4fcc7
--- /dev/null
+++ b/javatests/dagger/functional/producers/DependedModule.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class DependedModule {
+  @Provides
+  String provideGreeting() {
+    return "Hello world!";
+  }
+}
diff --git a/javatests/dagger/functional/producers/DependedProducerModule.java b/javatests/dagger/functional/producers/DependedProducerModule.java
new file mode 100644
index 000000000..c25d4e827
--- /dev/null
+++ b/javatests/dagger/functional/producers/DependedProducerModule.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers;
+
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+
+@ProducerModule
+final class DependedProducerModule {
+
+  @Produces
+  int produceNumberOfGreetings() {
+    return 2;
+  }
+}
diff --git a/javatests/dagger/functional/producers/DependedProductionComponent.java b/javatests/dagger/functional/producers/DependedProductionComponent.java
new file mode 100644
index 000000000..d5ebc4f50
--- /dev/null
+++ b/javatests/dagger/functional/producers/DependedProductionComponent.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+
+@ProductionComponent(modules = {ExecutorModule.class, DependedProducerModule.class})
+interface DependedProductionComponent {
+  ListenableFuture<Integer> numGreetings();
+}
+
diff --git a/javatests/dagger/functional/producers/DependentComponent.java b/javatests/dagger/functional/producers/DependentComponent.java
new file mode 100644
index 000000000..364676c5a
--- /dev/null
+++ b/javatests/dagger/functional/producers/DependentComponent.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+import java.util.List;
+
+@ProductionComponent(
+  modules = {ExecutorModule.class, DependentProducerModule.class},
+  dependencies = {DependedComponent.class, DependedProductionComponent.class}
+)
+interface DependentComponent {
+  ListenableFuture<List<String>> greetings();
+}
diff --git a/javatests/dagger/functional/producers/DependentProducerModule.java b/javatests/dagger/functional/producers/DependentProducerModule.java
new file mode 100644
index 000000000..56b66f55f
--- /dev/null
+++ b/javatests/dagger/functional/producers/DependentProducerModule.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers;
+
+import com.google.common.base.Ascii;
+import com.google.common.collect.ImmutableList;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import java.util.List;
+
+@ProducerModule
+final class DependentProducerModule {
+  @Produces
+  ListenableFuture<List<String>> greetings(Integer numGreetings, String greeting) {
+    List<String> greetings = ImmutableList.of(
+        String.valueOf(numGreetings), greeting, Ascii.toUpperCase(greeting));
+    return Futures.immediateFuture(greetings);
+  }
+}
diff --git a/javatests/dagger/functional/producers/DependentTest.java b/javatests/dagger/functional/producers/DependentTest.java
new file mode 100644
index 000000000..920d753a3
--- /dev/null
+++ b/javatests/dagger/functional/producers/DependentTest.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class DependentTest {
+  @Test public void dependentComponent() throws Exception {
+    DependentComponent dependentComponent =
+        DaggerDependentComponent.builder()
+            .dependedProductionComponent(DaggerDependedProductionComponent.create())
+            .dependedComponent(DaggerDependedComponent.create())
+            .build();
+    assertThat(dependentComponent).isNotNull();
+    assertThat(dependentComponent.greetings().get()).containsExactly(
+        "2", "Hello world!", "HELLO WORLD!");
+  }
+
+  @Test public void reuseBuilderWithDependentComponent() throws Exception {
+    DaggerDependentComponent.Builder dependentComponentBuilder = DaggerDependentComponent.builder();
+
+    DependentComponent componentUsingComponents =
+        dependentComponentBuilder
+            .dependedProductionComponent(DaggerDependedProductionComponent.create())
+            .dependedComponent(DaggerDependedComponent.create())
+            .build();
+
+    DependentComponent componentUsingJavaImpls = dependentComponentBuilder
+        .dependedProductionComponent(new DependedProductionComponent() {
+          @Override public ListenableFuture<Integer> numGreetings() {
+            return Futures.immediateFuture(3);
+          }
+        })
+        .dependedComponent(new DependedComponent() {
+          @Override public String getGreeting() {
+            return "Goodbye world!";
+          }
+        })
+        .build();
+
+    assertThat(componentUsingJavaImpls.greetings().get()).containsExactly(
+        "3", "Goodbye world!", "GOODBYE WORLD!");
+    assertThat(componentUsingComponents.greetings().get()).containsExactly(
+        "2", "Hello world!", "HELLO WORLD!");
+
+  }
+}
diff --git a/javatests/dagger/functional/producers/ExecutorModule.java b/javatests/dagger/functional/producers/ExecutorModule.java
new file mode 100644
index 000000000..5f8bfbf10
--- /dev/null
+++ b/javatests/dagger/functional/producers/ExecutorModule.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers;
+
+import com.google.common.util.concurrent.MoreExecutors;
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.Production;
+import java.util.concurrent.Executor;
+
+/**
+ * A module that provides an optionally user-defined executor for a production component, defaulting
+ * to the direct executor.
+ */
+@Module
+public final class ExecutorModule {
+  private final Executor executor;
+
+  public ExecutorModule() {
+    this(MoreExecutors.directExecutor());
+  }
+
+  public ExecutorModule(Executor executor) {
+    this.executor = executor;
+  }
+
+  @Provides
+  @Production
+  Executor executor() {
+    return executor;
+  }
+}
diff --git a/javatests/dagger/functional/producers/ProducerFactoryTest.java b/javatests/dagger/functional/producers/ProducerFactoryTest.java
new file mode 100644
index 000000000..d974613a3
--- /dev/null
+++ b/javatests/dagger/functional/producers/ProducerFactoryTest.java
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Matchers.any;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.when;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import com.google.common.util.concurrent.SettableFuture;
+import dagger.producers.Producer;
+import dagger.producers.monitoring.ProducerMonitor;
+import dagger.producers.monitoring.ProducerToken;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executor;
+import javax.inject.Provider;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(JUnit4.class)
+public class ProducerFactoryTest {
+  @Mock private ProductionComponentMonitor componentMonitor;
+  private ProducerMonitor monitor;
+  private Provider<Executor> executorProvider;
+  private Provider<ProductionComponentMonitor> componentMonitorProvider;
+
+  @Before
+  public void setUpMocks() {
+    MockitoAnnotations.initMocks(this);
+    monitor = Mockito.mock(ProducerMonitor.class, Mockito.CALLS_REAL_METHODS);
+    when(componentMonitor.producerMonitorFor(any(ProducerToken.class))).thenReturn(monitor);
+    // TODO(beder): Use Providers.of when available.
+    executorProvider =
+        new Provider<Executor>() {
+          @Override
+          public Executor get() {
+            return MoreExecutors.directExecutor();
+          }
+        };
+    componentMonitorProvider =
+        new Provider<ProductionComponentMonitor>() {
+          @Override
+          public ProductionComponentMonitor get() {
+            return componentMonitor;
+          }
+        };
+  }
+
+  @Test
+  public void noArgMethod() throws Exception {
+    ProducerToken token = ProducerToken.create(SimpleProducerModule_StrFactory.class);
+    Producer<String> producer =
+        new SimpleProducerModule_StrFactory(executorProvider, componentMonitorProvider);
+    assertThat(producer.get().get()).isEqualTo("str");
+    InOrder order = inOrder(componentMonitor, monitor);
+    order.verify(componentMonitor).producerMonitorFor(token);
+    order.verify(monitor).methodStarting();
+    order.verify(monitor).methodFinished();
+    order.verify(monitor).succeeded("str");
+    order.verifyNoMoreInteractions();
+  }
+
+  @Test
+  public void singleArgMethod() throws Exception {
+    SettableFuture<Integer> intFuture = SettableFuture.create();
+    Producer<Integer> intProducer = producerOfFuture(intFuture);
+    Producer<String> producer =
+        new SimpleProducerModule_StrWithArgFactory(
+            executorProvider, componentMonitorProvider, intProducer);
+    assertThat(producer.get().isDone()).isFalse();
+    intFuture.set(42);
+    assertThat(producer.get().get()).isEqualTo("str with arg");
+  }
+
+  @Test
+  public void successMonitor() throws Exception {
+    ProducerToken token = ProducerToken.create(SimpleProducerModule_SettableFutureStrFactory.class);
+
+    SettableFuture<String> strFuture = SettableFuture.create();
+    SettableFuture<SettableFuture<String>> strFutureFuture = SettableFuture.create();
+    Producer<SettableFuture<String>> strFutureProducer = producerOfFuture(strFutureFuture);
+    Producer<String> producer =
+        new SimpleProducerModule_SettableFutureStrFactory(
+            executorProvider, componentMonitorProvider, strFutureProducer);
+    assertThat(producer.get().isDone()).isFalse();
+
+    InOrder order = inOrder(componentMonitor, monitor);
+    order.verify(componentMonitor).producerMonitorFor(token);
+
+    strFutureFuture.set(strFuture);
+    order.verify(monitor).methodStarting();
+    order.verify(monitor).methodFinished();
+    assertThat(producer.get().isDone()).isFalse();
+
+    strFuture.set("monkey");
+    assertThat(producer.get().get()).isEqualTo("monkey");
+    order.verify(monitor).succeeded("monkey");
+
+    order.verifyNoMoreInteractions();
+  }
+
+  @Test
+  public void failureMonitor() throws Exception {
+    ProducerToken token = ProducerToken.create(SimpleProducerModule_SettableFutureStrFactory.class);
+
+    SettableFuture<String> strFuture = SettableFuture.create();
+    SettableFuture<SettableFuture<String>> strFutureFuture = SettableFuture.create();
+    Producer<SettableFuture<String>> strFutureProducer = producerOfFuture(strFutureFuture);
+    Producer<String> producer =
+        new SimpleProducerModule_SettableFutureStrFactory(
+            executorProvider, componentMonitorProvider, strFutureProducer);
+    assertThat(producer.get().isDone()).isFalse();
+
+    InOrder order = inOrder(componentMonitor, monitor);
+    order.verify(componentMonitor).producerMonitorFor(token);
+
+    strFutureFuture.set(strFuture);
+    order.verify(monitor).methodStarting();
+    order.verify(monitor).methodFinished();
+    assertThat(producer.get().isDone()).isFalse();
+
+    Throwable t = new RuntimeException("monkey");
+    strFuture.setException(t);
+    try {
+      producer.get().get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isSameAs(t);
+      order.verify(monitor).failed(t);
+    }
+
+    order.verifyNoMoreInteractions();
+  }
+
+  @Test
+  public void failureMonitorDueToThrowingProducer() throws Exception {
+    ProducerToken token = ProducerToken.create(SimpleProducerModule_ThrowingProducerFactory.class);
+
+    Producer<String> producer =
+        new SimpleProducerModule_ThrowingProducerFactory(
+            executorProvider, componentMonitorProvider);
+    assertThat(producer.get().isDone()).isTrue();
+
+    InOrder order = inOrder(componentMonitor, monitor);
+    order.verify(componentMonitor).producerMonitorFor(token);
+
+    order.verify(monitor).methodStarting();
+    order.verify(monitor).methodFinished();
+
+    try {
+      producer.get().get();
+      fail();
+    } catch (ExecutionException e) {
+      order.verify(monitor).failed(e.getCause());
+    }
+
+    order.verifyNoMoreInteractions();
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void nullComponentMonitorProvider() throws Exception {
+    new SimpleProducerModule_StrFactory(executorProvider, null);
+  }
+
+  private static <T> Producer<T> producerOfFuture(final ListenableFuture<T> future) {
+    return new Producer<T>() {
+      @Override
+      public ListenableFuture<T> get() {
+        return future;
+      }
+    };
+  }
+}
diff --git a/javatests/dagger/functional/producers/ProvidesInProducerModule.java b/javatests/dagger/functional/producers/ProvidesInProducerModule.java
new file mode 100644
index 000000000..6e3b41f91
--- /dev/null
+++ b/javatests/dagger/functional/producers/ProvidesInProducerModule.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.MoreExecutors;
+import dagger.Provides;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.Production;
+import dagger.producers.ProductionComponent;
+import java.util.concurrent.Executor;
+
+final class ProvidesInProducerModule {
+  @ProducerModule
+  static class OnlyModule {
+    @Provides
+    @Production
+    static Executor provideExecutor() {
+      return MoreExecutors.directExecutor();
+    }
+
+    @Produces
+    static String produceString() {
+      return "produced";
+    }
+  }
+
+  @ProductionComponent(modules = OnlyModule.class)
+  interface C {
+    ListenableFuture<String> string();
+  }
+}
diff --git a/javatests/dagger/functional/producers/Request.java b/javatests/dagger/functional/producers/Request.java
new file mode 100644
index 000000000..d4020c806
--- /dev/null
+++ b/javatests/dagger/functional/producers/Request.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers;
+
+import javax.inject.Inject;
+
+final class Request {
+  private final String name;
+
+  @Inject
+  Request() {
+    this.name = "Request";
+  }
+
+  String name() {
+    return this.name;
+  }
+}
diff --git a/javatests/dagger/functional/producers/Response.java b/javatests/dagger/functional/producers/Response.java
new file mode 100644
index 000000000..ca5c0c2c6
--- /dev/null
+++ b/javatests/dagger/functional/producers/Response.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers;
+
+final class Response {
+  private final String data;
+
+  Response(String data) {
+    this.data = data;
+  }
+
+  String data() {
+    return this.data;
+  }
+}
diff --git a/javatests/dagger/functional/producers/ResponseModule.java b/javatests/dagger/functional/producers/ResponseModule.java
new file mode 100644
index 000000000..9a5e25d57
--- /dev/null
+++ b/javatests/dagger/functional/producers/ResponseModule.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class ResponseModule {
+  @Provides
+  static int requestNumber() {
+    return 5;
+  }
+}
diff --git a/javatests/dagger/functional/producers/ResponseProducerModule.java b/javatests/dagger/functional/producers/ResponseProducerModule.java
new file mode 100644
index 000000000..7b76ae297
--- /dev/null
+++ b/javatests/dagger/functional/producers/ResponseProducerModule.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers;
+
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Lazy;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+
+@ProducerModule(includes = ResponseModule.class)
+final class ResponseProducerModule {
+  @Qualifier
+  @interface RequestsProducerAndProduced {}
+
+  @Produces
+  static ListenableFuture<String> greeting() {
+    return Futures.immediateFuture("Hello");
+  }
+
+  @Produces
+  @RequestsProducerAndProduced
+  static ListenableFuture<String> intermediateGreeting(
+      // TODO(beder): Allow Producer and Provider of the same type (which would force the binding
+      // to be a provision binding), and add validation for that.
+      @SuppressWarnings("unused") String greeting,
+      Producer<String> greetingProducer,
+      @SuppressWarnings("unused") Produced<String> greetingProduced,
+      @SuppressWarnings("unused") Provider<Integer> requestNumberProvider,
+      @SuppressWarnings("unused") Lazy<Integer> requestNumberLazy) {
+    return greetingProducer.get();
+  }
+
+  @Produces
+  static Response response(
+      @RequestsProducerAndProduced String greeting, Request request, int requestNumber) {
+    return new Response(String.format("%s, %s #%d!", greeting, request.name(), requestNumber));
+  }
+}
diff --git a/javatests/dagger/functional/producers/SimpleComponent.java b/javatests/dagger/functional/producers/SimpleComponent.java
new file mode 100644
index 000000000..4b0af7f03
--- /dev/null
+++ b/javatests/dagger/functional/producers/SimpleComponent.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+
+@ProductionComponent(modules = {ExecutorModule.class, ResponseProducerModule.class})
+interface SimpleComponent {
+  ListenableFuture<Response> response();
+}
diff --git a/javatests/dagger/functional/producers/SimpleProducerModule.java b/javatests/dagger/functional/producers/SimpleProducerModule.java
new file mode 100644
index 000000000..b0c523da4
--- /dev/null
+++ b/javatests/dagger/functional/producers/SimpleProducerModule.java
@@ -0,0 +1,281 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.SettableFuture;
+import dagger.Lazy;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoSet;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import java.io.IOException;
+import java.util.Set;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+
+/**
+ * A module that contains various signatures of produces methods. This is not used in any
+ * components.
+ */
+@ProducerModule
+final class SimpleProducerModule {
+  @Qualifier @interface Qual {
+    int value();
+  }
+
+  // Unique bindings.
+
+  @Produces
+  @Qual(-2)
+  static ListenableFuture<String> throwingProducer() {
+    throw new RuntimeException("monkey");
+  }
+
+  @Produces
+  @Qual(-1)
+  static ListenableFuture<String> settableFutureStr(SettableFuture<String> future) {
+    return future;
+  }
+
+  @Produces
+  @Qual(0)
+  static String str() {
+    return "str";
+  }
+
+  @Produces
+  @Qual(1)
+  static ListenableFuture<String> futureStr() {
+    return Futures.immediateFuture("future str");
+  }
+
+  @Produces
+  @Qual(2)
+  static String strWithArg(@SuppressWarnings("unused") int i) {
+    return "str with arg";
+  }
+
+  @Produces
+  @Qual(3)
+  static ListenableFuture<String> futureStrWithArg(@SuppressWarnings("unused") int i) {
+    return Futures.immediateFuture("future str with arg");
+  }
+
+  @Produces
+  @Qual(4)
+  @SuppressWarnings("unused") // unthrown exception for test
+  static String strThrowingException() throws IOException {
+    return "str throwing exception";
+  }
+
+  @Produces
+  @Qual(5)
+  @SuppressWarnings("unused") // unthrown exception for test
+  static ListenableFuture<String> futureStrThrowingException() throws IOException {
+    return Futures.immediateFuture("future str throwing exception");
+  }
+
+  @Produces
+  @Qual(6)
+  @SuppressWarnings("unused") // unthrown exception for test, unused parameter for test
+  static String strWithArgThrowingException(int i) throws IOException {
+    return "str with arg throwing exception";
+  }
+
+  @Produces
+  @Qual(7)
+  @SuppressWarnings("unused") // unthrown exception for test, unused parameter for test
+  static ListenableFuture<String> futureStrWithArgThrowingException(int i) throws IOException {
+    return Futures.immediateFuture("future str with arg throwing exception");
+  }
+
+  @Produces
+  @Qual(8)
+  static String strWithArgs(
+      @SuppressWarnings("unused") int i,
+      @SuppressWarnings("unused") Produced<Double> b,
+      @SuppressWarnings("unused") Producer<Object> c,
+      @SuppressWarnings("unused") Provider<Boolean> d) {
+    return "str with args";
+  }
+
+  @Produces
+  @Qual(9)
+  @SuppressWarnings("unused") // unthrown exception for test, unused parameters for test
+  static String strWithArgsThrowingException(
+      int i, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) throws IOException {
+    return "str with args throwing exception";
+  }
+
+  @Produces
+  @Qual(10)
+  static ListenableFuture<String> futureStrWithArgs(
+      @SuppressWarnings("unused") int i,
+      @SuppressWarnings("unused") Produced<Double> b,
+      @SuppressWarnings("unused") Producer<Object> c,
+      @SuppressWarnings("unused") Provider<Boolean> d) {
+    return Futures.immediateFuture("future str with args");
+  }
+
+  @Produces
+  @Qual(11)
+  @SuppressWarnings("unused") // unthrown exception for test, unused parameter for test
+  static ListenableFuture<String> futureStrWithArgsThrowingException(
+      int i, Produced<Double> b, Producer<Object> c, Provider<Boolean> d) throws IOException {
+    return Futures.immediateFuture("str with args throwing exception");
+  }
+
+  @Produces
+  @Qual(12)
+  static String strWithFrameworkTypeArgs(
+      @SuppressWarnings("unused") @Qual(1) int i,
+      @SuppressWarnings("unused") @Qual(1) Provider<Integer> iProvider,
+      @SuppressWarnings("unused") @Qual(1) Lazy<Integer> iLazy,
+      @SuppressWarnings("unused") @Qual(2) int j,
+      @SuppressWarnings("unused") @Qual(2) Produced<Integer> jProduced,
+      @SuppressWarnings("unused") @Qual(2) Producer<Integer> jProducer,
+      @SuppressWarnings("unused") @Qual(3) Produced<Integer> kProduced,
+      @SuppressWarnings("unused") @Qual(3) Producer<Integer> kProducer) {
+    return "str with framework type args";
+  }
+
+  // Set bindings.
+
+  @Produces
+  @IntoSet
+  static String setOfStrElement() {
+    return "set of str element";
+  }
+
+  @Produces
+  @IntoSet
+  @SuppressWarnings("unused") // unthrown exception for test
+  static String setOfStrElementThrowingException() throws IOException {
+    return "set of str element throwing exception";
+  }
+
+  @Produces
+  @IntoSet
+  static ListenableFuture<String> setOfStrFutureElement() {
+    return Futures.immediateFuture("set of str element");
+  }
+
+  @Produces
+  @IntoSet
+  @SuppressWarnings("unused") // unthrown exception for test
+  static ListenableFuture<String> setOfStrFutureElementThrowingException() throws IOException {
+    return Futures.immediateFuture("set of str element throwing exception");
+  }
+
+  @Produces
+  @IntoSet
+  static String setOfStrElementWithArg(@SuppressWarnings("unused") int i) {
+    return "set of str element with arg";
+  }
+
+  @Produces
+  @IntoSet
+  @SuppressWarnings("unused") // unthrown exception for test, unused parameter for test
+  static String setOfStrElementWithArgThrowingException(int i) throws IOException {
+    return "set of str element with arg throwing exception";
+  }
+
+  @Produces
+  @IntoSet
+  static ListenableFuture<String> setOfStrFutureElementWithArg(@SuppressWarnings("unused") int i) {
+    return Futures.immediateFuture("set of str element with arg");
+  }
+
+  @Produces
+  @IntoSet
+  @SuppressWarnings("unused") // unthrown exception for test, unused parameter for test
+  static ListenableFuture<String> setOfStrFutureElementWithArgThrowingException(int i)
+      throws IOException {
+    return Futures.immediateFuture("set of str element with arg throwing exception");
+  }
+
+  @Produces
+  @ElementsIntoSet
+  static Set<String> setOfStrValues() {
+    return ImmutableSet.of("set of str 1", "set of str 2");
+  }
+
+  @Produces
+  @ElementsIntoSet
+  @SuppressWarnings("unused") // unthrown exception for test
+  static Set<String> setOfStrValuesThrowingException() throws IOException {
+    return ImmutableSet.of("set of str 1", "set of str 2 throwing exception");
+  }
+
+  @Produces
+  @ElementsIntoSet
+  static ListenableFuture<Set<String>> setOfStrFutureValues() {
+    return Futures.<Set<String>>immediateFuture(ImmutableSet.of("set of str 1", "set of str 2"));
+  }
+
+  @Produces
+  @ElementsIntoSet
+  @SuppressWarnings("unused") // unthrown exception for test
+  static ListenableFuture<Set<String>> setOfStrFutureValuesThrowingException() throws IOException {
+    return Futures.<Set<String>>immediateFuture(
+        ImmutableSet.of("set of str 1", "set of str 2 throwing exception"));
+  }
+
+  @Produces
+  @ElementsIntoSet
+  static Set<String> setOfStrValuesWithArg(@SuppressWarnings("unused") int i) {
+    return ImmutableSet.of("set of str with arg 1", "set of str with arg 2");
+  }
+
+  @Produces
+  @ElementsIntoSet
+  @SuppressWarnings("unused") // unthrown exception for test, unused parameter for test
+  static Set<String> setOfStrValuesWithArgThrowingException(int i) throws IOException {
+    return ImmutableSet.of("set of str with arg 1", "set of str with arg 2 throwing exception");
+  }
+
+  @Produces
+  @ElementsIntoSet
+  static ListenableFuture<Set<String>> setOfStrFutureValuesWithArg(
+      @SuppressWarnings("unused") int i) {
+    return Futures.<Set<String>>immediateFuture(
+        ImmutableSet.of("set of str with arg 1", "set of str with arg 2"));
+  }
+
+  @Produces
+  @ElementsIntoSet
+  @SuppressWarnings("unused") // unthrown exception for test, unused parameter for test
+  static ListenableFuture<Set<String>> setOfStrFutureValuesWithArgThrowingException(int i)
+      throws IOException {
+    return Futures.<Set<String>>immediateFuture(
+        ImmutableSet.of("set of str with arg 1", "set of str with arg 2 throwing exception"));
+  }
+
+  /**
+   * A binding method that might result in a generated factory with conflicting field and parameter
+   * names.
+   */
+  @Produces
+  static Object object(int foo, Provider<String> fooProvider) {
+    return foo + fooProvider.get();
+  }
+}
diff --git a/javatests/dagger/functional/producers/SimpleTest.java b/javatests/dagger/functional/producers/SimpleTest.java
new file mode 100644
index 000000000..e20d09825
--- /dev/null
+++ b/javatests/dagger/functional/producers/SimpleTest.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class SimpleTest {
+  @Test public void testSimpleComponent() throws Exception {
+    SimpleComponent simpleComponent = DaggerSimpleComponent.create();
+    assertThat(simpleComponent).isNotNull();
+    assertThat(simpleComponent.response().get().data()).isEqualTo("Hello, Request #5!");
+  }
+}
diff --git a/javatests/dagger/functional/producers/badexecutor/BadExecutorTest.java b/javatests/dagger/functional/producers/badexecutor/BadExecutorTest.java
new file mode 100644
index 000000000..90bbca156
--- /dev/null
+++ b/javatests/dagger/functional/producers/badexecutor/BadExecutorTest.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.badexecutor;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.ListeningExecutorService;
+import com.google.common.util.concurrent.MoreExecutors;
+import dagger.functional.producers.ExecutorModule;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.RejectedExecutionException;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** This test verifies behavior when the executor throws {@link RejectedExecutionException}. */
+@RunWith(JUnit4.class)
+public final class BadExecutorTest {
+  private SimpleComponent component;
+
+  @Before
+  public void setUpComponent() {
+    ComponentDependency dependency =
+        new ComponentDependency() {
+          @Override
+          public ListenableFuture<Double> doubleDep() {
+            return Futures.immediateFuture(42.0);
+          }
+        };
+    ListeningExecutorService executorService = MoreExecutors.newDirectExecutorService();
+    component =
+        DaggerSimpleComponent.builder()
+            .executorModule(new ExecutorModule(executorService))
+            .componentDependency(dependency)
+            .build();
+    executorService.shutdown();
+  }
+
+  @Test
+  public void rejectNoArgMethod() throws Exception {
+    try {
+      component.noArgStr().get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(RejectedExecutionException.class);
+    }
+  }
+
+  @Test
+  public void rejectSingleArgMethod() throws Exception {
+    try {
+      component.singleArgInt().get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(RejectedExecutionException.class);
+    }
+  }
+
+  @Test
+  public void rejectSingleArgFromComponentDepMethod() throws Exception {
+    try {
+      component.singleArgBool().get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).isInstanceOf(RejectedExecutionException.class);
+    }
+  }
+
+  @Test
+  public void doNotRejectComponentDepMethod() throws Exception {
+    assertThat(component.doubleDep().get()).isWithin(0).of(42.0);
+  }
+}
diff --git a/javatests/dagger/functional/producers/badexecutor/ComponentDependency.java b/javatests/dagger/functional/producers/badexecutor/ComponentDependency.java
new file mode 100644
index 000000000..97974e5ff
--- /dev/null
+++ b/javatests/dagger/functional/producers/badexecutor/ComponentDependency.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.badexecutor;
+
+import com.google.common.util.concurrent.ListenableFuture;
+
+interface ComponentDependency {
+  ListenableFuture<Double> doubleDep();
+}
diff --git a/javatests/dagger/functional/producers/badexecutor/SimpleComponent.java b/javatests/dagger/functional/producers/badexecutor/SimpleComponent.java
new file mode 100644
index 000000000..ea58125d6
--- /dev/null
+++ b/javatests/dagger/functional/producers/badexecutor/SimpleComponent.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.badexecutor;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.functional.producers.ExecutorModule;
+import dagger.producers.ProductionComponent;
+
+/**
+ * A component that contains entry points that exercise different execution paths, for verifying the
+ * behavior when the executor throws a {@link java.util.concurrent.RejectedExecutionException}.
+ */
+@ProductionComponent(
+  dependencies = ComponentDependency.class,
+  modules = {ExecutorModule.class, SimpleProducerModule.class}
+)
+interface SimpleComponent {
+  /** An entry point exposing a producer method with no args. */
+  ListenableFuture<String> noArgStr();
+
+  /** An entry point exposing a producer method that depends on another producer method. */
+  ListenableFuture<Integer> singleArgInt();
+
+  /** An entry point exposing a producer method that depends on a component dependency method. */
+  ListenableFuture<Boolean> singleArgBool();
+
+  /** An entry point exposing a component dependency method. */
+  ListenableFuture<Double> doubleDep();
+}
diff --git a/javatests/dagger/functional/producers/badexecutor/SimpleProducerModule.java b/javatests/dagger/functional/producers/badexecutor/SimpleProducerModule.java
new file mode 100644
index 000000000..f907fdaba
--- /dev/null
+++ b/javatests/dagger/functional/producers/badexecutor/SimpleProducerModule.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.badexecutor;
+
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+
+@ProducerModule
+final class SimpleProducerModule {
+  @Produces
+  static String noArgStr() {
+    return "no arg string";
+  }
+
+  @Produces
+  static int singleArgInt(String arg) {
+    return arg.length();
+  }
+
+  @Produces
+  static boolean singleArgBool(double arg) {
+    return arg > 0.0;
+  }
+}
diff --git a/javatests/dagger/functional/producers/binds/BindsProducersTest.java b/javatests/dagger/functional/producers/binds/BindsProducersTest.java
new file mode 100644
index 000000000..ef2c6e06c
--- /dev/null
+++ b/javatests/dagger/functional/producers/binds/BindsProducersTest.java
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.binds;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.collect.ImmutableMap;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import java.util.Map;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class BindsProducersTest {
+
+  private SimpleBindsProductionComponent component;
+
+  @Before
+  public void setUp() {
+    component = DaggerSimpleBindsProductionComponent.create();
+  }
+
+  @Test
+  public void bindDelegates() throws Exception {
+    assertThat(component.object().get()).isInstanceOf(FooOfStrings.class);
+    assertThat(component.fooOfStrings().get()).isInstanceOf(FooOfStrings.class);
+    assertThat(component.fooOfIntegers().get()).isNotNull();
+  }
+
+  @Test
+  public void bindWithScope() throws Exception {
+    assertThat(component.qualifiedFooOfStrings().get())
+        .isSameAs(component.qualifiedFooOfStrings().get());
+  }
+
+  @Test
+  public void multibindings() throws Exception {
+    assertThat(component.foosOfNumbers().get()).hasSize(2);
+    assertThat(component.objects().get()).hasSize(3);
+    assertThat(component.charSequences().get()).hasSize(5);
+
+    assertThat(component.integerObjectMap().get())
+        .containsExactlyEntriesIn(
+            ImmutableMap.of(
+                123, "123-string", 456, "456-string", 789, "789-string", -1, "provision-string"));
+
+    Map<Integer, Producer<Object>> integerProducerOfObjectMap =
+        component.integerProducerOfObjectMap().get();
+    assertThat(integerProducerOfObjectMap).hasSize(4);
+    assertThat(integerProducerOfObjectMap.get(123).get().get()).isEqualTo("123-string");
+    assertThat(integerProducerOfObjectMap.get(456).get().get()).isEqualTo("456-string");
+    assertThat(integerProducerOfObjectMap.get(789).get().get()).isEqualTo("789-string");
+    assertThat(integerProducerOfObjectMap.get(-1).get().get()).isEqualTo("provision-string");
+
+    assertThat(component.integerProducedOfObjectMap().get())
+        .containsExactlyEntriesIn(
+            ImmutableMap.of(
+                123, Produced.successful("123-string"),
+                456, Produced.successful("456-string"),
+                789, Produced.successful("789-string"),
+                -1, Produced.successful("provision-string")));
+
+    assertThat(component.qualifiedIntegerObjectMap().get()).hasSize(1);
+  }
+}
diff --git a/javatests/dagger/functional/producers/binds/Foo.java b/javatests/dagger/functional/producers/binds/Foo.java
new file mode 100644
index 000000000..4eb71fd36
--- /dev/null
+++ b/javatests/dagger/functional/producers/binds/Foo.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.binds;
+
+/**
+ * This is the type that will be bound.  We throw in generics just to complicate the test.
+ */
+interface Foo<T> {}
diff --git a/javatests/dagger/functional/producers/binds/FooOfStrings.java b/javatests/dagger/functional/producers/binds/FooOfStrings.java
new file mode 100644
index 000000000..b94d907fe
--- /dev/null
+++ b/javatests/dagger/functional/producers/binds/FooOfStrings.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.binds;
+
+/**
+ * This is not marked with {@link javax.inject.Inject @Inject} in order to test that {@link
+ * dagger.Binds @Binds} properly translate to {@code dagger.internal.codegen.ProductionBinding}s
+ * when the right-hand-side of the method is also a production binding. We force this by adding a
+ * {@link dagger.producers.Produces @Produces} method to add it to the graph instead of relying on
+ * the {@code dagger.internal.codegen.ProvisionBinding} that would be created by default with an
+ * {@code @Inject} constructor.
+ */
+final class FooOfStrings implements Foo<String> {}
diff --git a/javatests/dagger/functional/producers/binds/SimpleBindingModule.java b/javatests/dagger/functional/producers/binds/SimpleBindingModule.java
new file mode 100644
index 000000000..f2af277bb
--- /dev/null
+++ b/javatests/dagger/functional/producers/binds/SimpleBindingModule.java
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.binds;
+
+import com.google.common.util.concurrent.MoreExecutors;
+import dagger.Binds;
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntKey;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.Production;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.TreeSet;
+import java.util.concurrent.Executor;
+import javax.inject.Named;
+import javax.inject.Qualifier;
+import javax.inject.Singleton;
+
+@ProducerModule(includes = {
+    SimpleBindingModule.ExecutorModule.class,
+    SimpleBindingModule.ProvisionModuleForMap.class
+})
+abstract class SimpleBindingModule {
+  @Binds
+  abstract Object bindObject(FooOfStrings impl);
+
+  @Binds
+  abstract Foo<String> bindFooOfStrings(FooOfStrings impl);
+
+  @Binds
+  abstract Foo<? extends Number> bindFooOfNumbers(Foo<Integer> fooOfIntegers);
+
+  @Binds
+  @Singleton
+  @SomeQualifier
+  abstract Foo<String> bindQualifiedFooOfStrings(FooOfStrings impl);
+
+  @Produces
+  static FooOfStrings produceFooOfStrings() {
+    return new FooOfStrings();
+  }
+
+  @Produces
+  static Foo<Integer> produceFooOfIntegers() {
+    return new Foo<Integer>() {};
+  }
+
+  @Produces
+  static Foo<Double> produceFooOfDoubles() {
+    return new Foo<Double>() {};
+  }
+
+  @Binds
+  @IntoSet
+  abstract Foo<? extends Number> bindFooOfIntegersIntoSet(Foo<Integer> fooOfIntegers);
+
+  @Binds
+  @IntoSet
+  abstract Foo<? extends Number> bindFooExtendsNumberIntoSet(Foo<Double> fooOfDoubles);
+
+  @Binds
+  @ElementsIntoSet
+  abstract Set<Object> bindSetOfFooNumbersToObjects(Set<Foo<? extends Number>> setOfFooNumbers);
+
+  @Binds
+  @IntoSet
+  abstract Object bindFooOfStringsIntoSetOfObjects(FooOfStrings impl);
+
+  @Produces
+  static HashSet<String> produceStringHashSet() {
+    return new HashSet<>(Arrays.asList("hash-string1", "hash-string2"));
+  }
+
+  @Produces
+  static TreeSet<CharSequence> produceCharSequenceTreeSet() {
+    return new TreeSet<CharSequence>(Arrays.asList("tree-charSequence1", "tree-charSequence2"));
+  }
+
+  @Produces
+  static Collection<CharSequence> produceCharSequenceCollection() {
+    return Arrays.<CharSequence>asList("list-charSequence");
+  }
+
+  @Binds
+  @ElementsIntoSet
+  abstract Set<CharSequence> bindHashSetOfStrings(HashSet<String> set);
+
+  @Binds
+  @ElementsIntoSet
+  abstract Set<CharSequence> bindTreeSetOfCharSequences(TreeSet<CharSequence> set);
+
+  @Binds
+  @ElementsIntoSet
+  abstract Set<CharSequence> bindCollectionOfCharSequences(Collection<CharSequence> collection);
+
+  @Qualifier
+  @Retention(RetentionPolicy.RUNTIME)
+  @interface SomeQualifier {}
+
+  @Module
+  static final class ExecutorModule {
+    @Provides @Production
+    static Executor provideExecutor() {
+      return MoreExecutors.directExecutor();
+    }
+  }
+
+  @Binds
+  @IntoMap
+  @IntKey(123)
+  abstract Object bind123ForMap(@Named("For-123") String string);
+
+  @Binds
+  @IntoMap
+  @IntKey(456)
+  abstract Object bind456ForMap(@Named("For-456") String string);
+
+  @Produces
+  @IntoMap
+  @IntKey(789)
+  static Object produce789ForMap() {
+    return "789-string";
+  }
+
+  @Module
+  abstract static class ProvisionModuleForMap {
+    @Provides @Named("Provision string") static String provideProvisionString() {
+      return "provision-string";
+    }
+
+    @Binds
+    @IntoMap
+    @IntKey(-1)
+    abstract Object bindNegative1ForMap(@Named("Provision string") String string);
+  }
+
+  @Binds
+  @IntoMap
+  @IntKey(123)
+  @SomeQualifier
+  abstract Object bindFooOfStringsIntoQualifiedMap(FooOfStrings fooOfStrings);
+
+  @Produces
+  @Named("For-123")
+  static String produce123String() {
+    return "123-string";
+  }
+
+  @Produces
+  @Named("For-456")
+  static String produce456String() {
+    return "456-string";
+  }
+}
diff --git a/javatests/dagger/functional/producers/binds/SimpleBindsProductionComponent.java b/javatests/dagger/functional/producers/binds/SimpleBindsProductionComponent.java
new file mode 100644
index 000000000..21cf66122
--- /dev/null
+++ b/javatests/dagger/functional/producers/binds/SimpleBindsProductionComponent.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.binds;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.functional.producers.binds.SimpleBindingModule.SomeQualifier;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.ProductionComponent;
+import java.util.Map;
+import java.util.Set;
+import javax.inject.Singleton;
+
+@Singleton
+@ProductionComponent(modules = SimpleBindingModule.class)
+public interface SimpleBindsProductionComponent {
+  ListenableFuture<Object> object();
+
+  ListenableFuture<Foo<String>> fooOfStrings();
+
+  @SomeQualifier
+  ListenableFuture<Foo<String>> qualifiedFooOfStrings();
+
+  ListenableFuture<Foo<Integer>> fooOfIntegers();
+
+  ListenableFuture<Set<Foo<? extends Number>>> foosOfNumbers();
+
+  ListenableFuture<Set<Object>> objects();
+
+  ListenableFuture<Set<CharSequence>> charSequences();
+
+  ListenableFuture<Map<Integer, Object>> integerObjectMap();
+
+  ListenableFuture<Map<Integer, Producer<Object>>> integerProducerOfObjectMap();
+
+  ListenableFuture<Map<Integer, Produced<Object>>> integerProducedOfObjectMap();
+
+  @SomeQualifier ListenableFuture<Map<Integer, Object>> qualifiedIntegerObjectMap();
+}
diff --git a/javatests/dagger/functional/producers/builder/DepComponent.java b/javatests/dagger/functional/producers/builder/DepComponent.java
new file mode 100644
index 000000000..c2811f12f
--- /dev/null
+++ b/javatests/dagger/functional/producers/builder/DepComponent.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.builder;
+
+import com.google.common.util.concurrent.ListenableFuture;
+
+interface DepComponent {
+  ListenableFuture<Double> d();
+}
diff --git a/javatests/dagger/functional/producers/builder/IntModule.java b/javatests/dagger/functional/producers/builder/IntModule.java
new file mode 100644
index 000000000..ed2bb9522
--- /dev/null
+++ b/javatests/dagger/functional/producers/builder/IntModule.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.builder;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class IntModule {
+  @Provides
+  static int i() {
+    return 42;
+  }
+}
diff --git a/javatests/dagger/functional/producers/builder/ProductionComponentBuilderTest.java b/javatests/dagger/functional/producers/builder/ProductionComponentBuilderTest.java
new file mode 100644
index 000000000..7b33053b8
--- /dev/null
+++ b/javatests/dagger/functional/producers/builder/ProductionComponentBuilderTest.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.builder;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for {@link dagger.producers.ProductionComponent.Builder}. */
+@RunWith(JUnit4.class)
+public final class ProductionComponentBuilderTest {
+
+  @Test
+  public void successfulBuild() throws Exception {
+    TestComponentWithBuilder component =
+        DaggerTestComponentWithBuilder.builder()
+            .depComponent(depComponent(15.3))
+            .strModule(new StringModule())
+            .build();
+    assertThat(component.s().get()).isEqualTo("arg: 42");
+    assertThat(component.d().get()).isWithin(0).of(15.3);
+  }
+
+  @Test
+  public void successfulBuild_withMissingZeroArgModule() throws Exception {
+    TestComponentWithBuilder component =
+        DaggerTestComponentWithBuilder.builder()
+            .depComponent(depComponent(15.3))
+            .build();
+    assertThat(component.s().get()).isEqualTo("arg: 42");
+    assertThat(component.d().get()).isWithin(0).of(15.3);
+  }
+
+  @Test(expected = IllegalStateException.class)
+  public void missingDepComponent() {
+    DaggerTestComponentWithBuilder.builder()
+        .strModule(new StringModule())
+        .build();
+  }
+
+  private static DepComponent depComponent(final double value) {
+    return new DepComponent() {
+      @Override
+      public ListenableFuture<Double> d() {
+        return Futures.immediateFuture(value);
+      }
+    };
+  }
+}
diff --git a/javatests/dagger/functional/producers/builder/StringModule.java b/javatests/dagger/functional/producers/builder/StringModule.java
new file mode 100644
index 000000000..6ad748f2d
--- /dev/null
+++ b/javatests/dagger/functional/producers/builder/StringModule.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.builder;
+
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+
+@ProducerModule
+final class StringModule {
+  @Produces
+  static String str(int i) {
+    return "arg: " + i;
+  }
+}
diff --git a/javatests/dagger/functional/producers/builder/TestComponentWithBuilder.java b/javatests/dagger/functional/producers/builder/TestComponentWithBuilder.java
new file mode 100644
index 000000000..91fb326a9
--- /dev/null
+++ b/javatests/dagger/functional/producers/builder/TestComponentWithBuilder.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.builder;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.functional.producers.ExecutorModule;
+import dagger.producers.ProductionComponent;
+
+@ProductionComponent(
+  modules = {ExecutorModule.class, StringModule.class, IntModule.class},
+  dependencies = DepComponent.class
+)
+interface TestComponentWithBuilder {
+  ListenableFuture<String> s();
+  ListenableFuture<Double> d();
+
+  @ProductionComponent.Builder
+  interface Builder {
+    Builder depComponent(DepComponent depComponent);
+    Builder strModule(StringModule strModule);
+    TestComponentWithBuilder build();
+  }
+}
diff --git a/javatests/dagger/functional/producers/gwt/GwtIncompatibles.java b/javatests/dagger/functional/producers/gwt/GwtIncompatibles.java
new file mode 100644
index 000000000..75efd9660
--- /dev/null
+++ b/javatests/dagger/functional/producers/gwt/GwtIncompatibles.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.gwt;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import java.lang.annotation.Retention;
+
+interface GwtIncompatibles {
+  @Retention(RUNTIME)
+  @interface GwtIncompatible {}
+
+  @GwtIncompatible
+  @ProducerModule
+  class OnModule {
+    @Produces
+    static String onModule() {
+      return "on module";
+    }
+  }
+
+  @ProducerModule
+  class OnMethod {
+    @GwtIncompatible
+    @Produces
+    static String onMethod() {
+      return "on method";
+    }
+  }
+}
diff --git a/javatests/dagger/functional/producers/gwt/GwtIncompatiblesTest.java b/javatests/dagger/functional/producers/gwt/GwtIncompatiblesTest.java
new file mode 100644
index 000000000..0ca3dc417
--- /dev/null
+++ b/javatests/dagger/functional/producers/gwt/GwtIncompatiblesTest.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.gwt;
+
+import dagger.functional.producers.gwt.GwtIncompatibles.GwtIncompatible;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for {@code @GwtIncompatible} bindings. */
+@RunWith(JUnit4.class)
+public class GwtIncompatiblesTest {
+  @Test
+  public void testIncompatible() {
+    assertGwtIncompatible(GwtIncompatibles_OnModule_OnModuleFactory.class);
+    assertGwtIncompatible(GwtIncompatibles_OnMethod_OnMethodFactory.class);
+  }
+
+  private void assertGwtIncompatible(Class<?> clazz) {
+    boolean gwtIncompatible = clazz.getAnnotation(GwtIncompatible.class) != null;
+    if (!gwtIncompatible) {
+      throw new AssertionError(clazz.getCanonicalName() + " is not @GwtIncompatible");
+    }
+  }
+}
diff --git a/javatests/dagger/functional/producers/monitoring/MonitoredComponent.java b/javatests/dagger/functional/producers/monitoring/MonitoredComponent.java
new file mode 100644
index 000000000..2df564554
--- /dev/null
+++ b/javatests/dagger/functional/producers/monitoring/MonitoredComponent.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.monitoring;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.functional.producers.ExecutorModule;
+import dagger.producers.ProductionComponent;
+
+@ProductionComponent(
+  modules = {ExecutorModule.class, MonitoringModule.class, StubModule.class, ServingModule.class}
+)
+interface MonitoredComponent {
+  ListenableFuture<String> output();
+}
diff --git a/javatests/dagger/functional/producers/monitoring/MonitoringModule.java b/javatests/dagger/functional/producers/monitoring/MonitoringModule.java
new file mode 100644
index 000000000..3c08255e6
--- /dev/null
+++ b/javatests/dagger/functional/producers/monitoring/MonitoringModule.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.monitoring;
+
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.IntoSet;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+
+@Module
+final class MonitoringModule {
+  private final ProductionComponentMonitor.Factory monitorFactory;
+
+  MonitoringModule(ProductionComponentMonitor.Factory monitorFactory) {
+    this.monitorFactory = monitorFactory;
+  }
+
+  @Provides
+  @IntoSet
+  ProductionComponentMonitor.Factory monitorFactory() {
+    return monitorFactory;
+  }
+}
diff --git a/javatests/dagger/functional/producers/monitoring/MonitoringTest.java b/javatests/dagger/functional/producers/monitoring/MonitoringTest.java
new file mode 100644
index 000000000..3c01198e5
--- /dev/null
+++ b/javatests/dagger/functional/producers/monitoring/MonitoringTest.java
@@ -0,0 +1,254 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.monitoring;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+import com.google.common.base.Throwables;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.SettableFuture;
+import dagger.functional.producers.ExecutorModule;
+import dagger.producers.monitoring.ProducerMonitor;
+import dagger.producers.monitoring.ProducerToken;
+import dagger.producers.monitoring.ProductionComponentMonitor;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Executors;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+/** Tests for production components using monitoring. */
+@RunWith(JUnit4.class)
+public final class MonitoringTest {
+  @Mock private ProductionComponentMonitor.Factory componentMonitorFactory;
+  @Mock private StringStub server1;
+  @Mock private StringStub server2;
+  private SettableFuture<String> server1Future;
+  private SettableFuture<String> server2Future;
+  private FakeProductionComponentMonitor componentMonitor;
+
+  @Before
+  public void setUp() {
+    MockitoAnnotations.initMocks(this);
+    componentMonitor = new FakeProductionComponentMonitor();
+    when(componentMonitorFactory.create(any())).thenReturn(componentMonitor);
+    server1Future = SettableFuture.create();
+    server2Future = SettableFuture.create();
+    when(server1.run(any(String.class))).thenReturn(server1Future);
+    when(server2.run(any(String.class))).thenReturn(server2Future);
+  }
+
+  @Test
+  public void basicMonitoring() throws Exception {
+    MonitoredComponent component =
+        DaggerMonitoredComponent.builder()
+            .monitoringModule(new MonitoringModule(componentMonitorFactory))
+            .stubModule(new StubModule(server1, server2))
+            .build();
+    ListenableFuture<String> output = component.output();
+    assertThat(componentMonitor.monitors).hasSize(3);
+    ImmutableList<Map.Entry<ProducerToken, ProducerMonitor>> entries =
+        ImmutableList.copyOf(componentMonitor.monitors.entrySet());
+    assertThat(entries.get(0).getKey().toString()).contains("CallServer2");
+    assertThat(entries.get(1).getKey().toString()).contains("CallServer1");
+    assertThat(entries.get(2).getKey().toString()).contains("RequestData");
+
+    ProducerMonitor callServer2Monitor = entries.get(0).getValue();
+    ProducerMonitor callServer1Monitor = entries.get(1).getValue();
+    ProducerMonitor requestDataMonitor = entries.get(2).getValue();
+
+    InOrder inOrder = inOrder(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+    inOrder.verify(callServer2Monitor).requested();
+    inOrder.verify(callServer1Monitor).requested();
+    inOrder.verify(requestDataMonitor).requested();
+    inOrder.verify(requestDataMonitor).ready();
+    inOrder.verify(requestDataMonitor).methodStarting();
+    inOrder.verify(requestDataMonitor).methodFinished();
+    inOrder.verify(requestDataMonitor).succeeded("Hello, World!");
+    inOrder.verify(callServer1Monitor).ready();
+    inOrder.verify(callServer1Monitor).methodStarting();
+    inOrder.verify(callServer1Monitor).methodFinished();
+    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+
+    server1Future.set("server 1 response");
+    inOrder.verify(callServer1Monitor).succeeded("server 1 response");
+    inOrder.verify(callServer2Monitor).ready();
+    inOrder.verify(callServer2Monitor).methodStarting();
+    inOrder.verify(callServer2Monitor).methodFinished();
+    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+
+    server2Future.set("server 2 response");
+    inOrder.verify(callServer2Monitor).succeeded("server 2 response");
+    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+    assertThat(output.get()).isEqualTo("server 2 response");
+  }
+
+  @Test
+  public void basicMonitoringWithFailure() throws Exception {
+    MonitoredComponent component =
+        DaggerMonitoredComponent.builder()
+            .monitoringModule(new MonitoringModule(componentMonitorFactory))
+            .stubModule(new StubModule(server1, server2))
+            .build();
+    ListenableFuture<String> output = component.output();
+    assertThat(componentMonitor.monitors).hasSize(3);
+    ImmutableList<Map.Entry<ProducerToken, ProducerMonitor>> entries =
+        ImmutableList.copyOf(componentMonitor.monitors.entrySet());
+    assertThat(entries.get(0).getKey().toString()).contains("CallServer2");
+    assertThat(entries.get(1).getKey().toString()).contains("CallServer1");
+    assertThat(entries.get(2).getKey().toString()).contains("RequestData");
+
+    ProducerMonitor callServer2Monitor = entries.get(0).getValue();
+    ProducerMonitor callServer1Monitor = entries.get(1).getValue();
+    ProducerMonitor requestDataMonitor = entries.get(2).getValue();
+
+    InOrder inOrder = inOrder(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+    inOrder.verify(callServer2Monitor).requested();
+    inOrder.verify(callServer1Monitor).requested();
+    inOrder.verify(requestDataMonitor).requested();
+    inOrder.verify(requestDataMonitor).ready();
+    inOrder.verify(requestDataMonitor).methodStarting();
+    inOrder.verify(requestDataMonitor).methodFinished();
+    inOrder.verify(requestDataMonitor).succeeded("Hello, World!");
+    inOrder.verify(callServer1Monitor).ready();
+    inOrder.verify(callServer1Monitor).methodStarting();
+    inOrder.verify(callServer1Monitor).methodFinished();
+    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+
+    RuntimeException cause = new RuntimeException("monkey");
+    server1Future.setException(cause);
+    inOrder.verify(callServer1Monitor).failed(cause);
+    inOrder.verify(callServer2Monitor).ready();
+    inOrder.verify(callServer2Monitor).failed(any(Throwable.class));
+    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);
+    try {
+      output.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(Throwables.getRootCause(e)).isSameAs(cause);
+    }
+  }
+
+  private static final class FakeProductionComponentMonitor extends ProductionComponentMonitor {
+    final Map<ProducerToken, ProducerMonitor> monitors = new LinkedHashMap<>();
+
+    @Override
+    public ProducerMonitor producerMonitorFor(ProducerToken token) {
+      ProducerMonitor monitor = mock(ProducerMonitor.class);
+      monitors.put(token, monitor);
+      return monitor;
+    }
+  }
+
+  @Test
+  public void monitoringWithThreads() throws Exception {
+    ThreadRecordingProductionComponentMonitor componentMonitor =
+        new ThreadRecordingProductionComponentMonitor();
+    when(componentMonitorFactory.create(any())).thenReturn(componentMonitor);
+
+    ThreadMonitoredComponent component =
+        DaggerThreadMonitoredComponent.builder()
+            .monitoringModule(new MonitoringModule(componentMonitorFactory))
+            .executorModule(new ExecutorModule(Executors.newFixedThreadPool(10)))
+            .build();
+    ThreadAccumulator threadAccumulator = component.threadAccumulator().get();
+
+    assertThat(componentMonitor.monitors).hasSize(3);
+    ImmutableList<Map.Entry<ProducerToken, ThreadRecordingProducerMonitor>> entries =
+        ImmutableList.copyOf(componentMonitor.monitors.entrySet());
+
+    assertThat(entries.get(0).getKey().toString()).contains("EntryPoint");
+    ThreadRecordingProducerMonitor entryPointMonitor = entries.get(0).getValue();
+    assertThat(entries.get(1).getKey().toString()).contains("Required");
+    ThreadRecordingProducerMonitor requiredMonitor = entries.get(1).getValue();
+    assertThat(entries.get(2).getKey().toString()).contains("Deferred");
+    ThreadRecordingProducerMonitor deferredMonitor = entries.get(2).getValue();
+
+    // The entry point producer was requested from the main thread, then ran in its own thread.
+    assertThat(entryPointMonitor.requestedThreadId).isEqualTo(Thread.currentThread().getId());
+    assertThat(entryPointMonitor.startingThreadId)
+        .isEqualTo(threadAccumulator.threadId("entryPoint"));
+    assertThat(entryPointMonitor.finishedThreadId)
+        .isEqualTo(threadAccumulator.threadId("entryPoint"));
+
+    // The deferred producer was requested by the required producer, then ran in its own thread.
+    assertThat(deferredMonitor.requestedThreadId).isEqualTo(threadAccumulator.threadId("required"));
+    assertThat(deferredMonitor.startingThreadId).isEqualTo(threadAccumulator.threadId("deferred"));
+    assertThat(deferredMonitor.finishedThreadId).isEqualTo(threadAccumulator.threadId("deferred"));
+
+    // The required producer was requested by the entry point producer, then ran in its own thread.
+    assertThat(requiredMonitor.requestedThreadId).isEqualTo(entryPointMonitor.requestedThreadId);
+    assertThat(requiredMonitor.startingThreadId).isEqualTo(threadAccumulator.threadId("required"));
+    assertThat(requiredMonitor.finishedThreadId).isEqualTo(threadAccumulator.threadId("required"));
+
+    // Each producer ran in a distinct thread.
+    ImmutableSet<Long> threadIds =
+        ImmutableSet.of(
+            Thread.currentThread().getId(),
+            threadAccumulator.threadId("required"),
+            threadAccumulator.threadId("deferred"),
+            threadAccumulator.threadId("entryPoint"));
+    assertThat(threadIds).hasSize(4);
+  }
+
+  private static final class ThreadRecordingProductionComponentMonitor
+      extends ProductionComponentMonitor {
+    final Map<ProducerToken, ThreadRecordingProducerMonitor> monitors = new LinkedHashMap<>();
+
+    @Override
+    public ProducerMonitor producerMonitorFor(ProducerToken token) {
+      ThreadRecordingProducerMonitor monitor = new ThreadRecordingProducerMonitor();
+      monitors.put(token, monitor);
+      return monitor;
+    }
+  }
+
+  private static final class ThreadRecordingProducerMonitor extends ProducerMonitor {
+    private long requestedThreadId;
+    private long startingThreadId;
+    private long finishedThreadId;
+
+    @Override
+    public void requested() {
+      requestedThreadId = Thread.currentThread().getId();
+    }
+
+    @Override
+    public void methodStarting() {
+      startingThreadId = Thread.currentThread().getId();
+    }
+
+    @Override
+    public void methodFinished() {
+      finishedThreadId = Thread.currentThread().getId();
+    }
+  }
+}
diff --git a/javatests/dagger/functional/producers/monitoring/ServingModule.java b/javatests/dagger/functional/producers/monitoring/ServingModule.java
new file mode 100644
index 000000000..09c9cd19d
--- /dev/null
+++ b/javatests/dagger/functional/producers/monitoring/ServingModule.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.monitoring;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.functional.producers.monitoring.StubModule.ForServer1;
+import dagger.functional.producers.monitoring.StubModule.ForServer2;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import javax.inject.Qualifier;
+
+@ProducerModule
+final class ServingModule {
+  @Qualifier
+  @interface RequestData {}
+
+  @Qualifier
+  @interface IntermediateData {}
+
+  @Produces
+  @RequestData
+  static String requestData() {
+    return "Hello, World!";
+  }
+
+  @Produces
+  @IntermediateData
+  static ListenableFuture<String> callServer1(
+      @RequestData String data, @ForServer1 StringStub stub) {
+    return stub.run(data);
+  }
+
+  @Produces
+  static ListenableFuture<String> callServer2(
+      @IntermediateData String data, @ForServer2 StringStub stub) {
+    return stub.run(data);
+  }
+}
diff --git a/javatests/dagger/functional/producers/monitoring/StringStub.java b/javatests/dagger/functional/producers/monitoring/StringStub.java
new file mode 100644
index 000000000..2553e88c9
--- /dev/null
+++ b/javatests/dagger/functional/producers/monitoring/StringStub.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.monitoring;
+
+import com.google.common.util.concurrent.ListenableFuture;
+
+interface StringStub {
+  ListenableFuture<String> run(String input);
+}
diff --git a/javatests/dagger/functional/producers/monitoring/StubModule.java b/javatests/dagger/functional/producers/monitoring/StubModule.java
new file mode 100644
index 000000000..3c5893cbf
--- /dev/null
+++ b/javatests/dagger/functional/producers/monitoring/StubModule.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.monitoring;
+
+import dagger.Module;
+import dagger.Provides;
+import javax.inject.Qualifier;
+
+@Module
+final class StubModule {
+  @Qualifier
+  @interface ForServer1 {}
+
+  @Qualifier
+  @interface ForServer2 {}
+
+  private final StringStub server1;
+  private final StringStub server2;
+
+  StubModule(StringStub server1, StringStub server2) {
+    this.server1 = server1;
+    this.server2 = server2;
+  }
+
+  @Provides
+  @ForServer1
+  StringStub server1() {
+    return server1;
+  }
+
+  @Provides
+  @ForServer2
+  StringStub server2() {
+    return server2;
+  }
+}
diff --git a/javatests/dagger/functional/producers/monitoring/ThreadAccumulator.java b/javatests/dagger/functional/producers/monitoring/ThreadAccumulator.java
new file mode 100644
index 000000000..3d95fb6f4
--- /dev/null
+++ b/javatests/dagger/functional/producers/monitoring/ThreadAccumulator.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.monitoring;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+@Singleton
+final class ThreadAccumulator {
+  private final Map<String, Long> threadIds = new ConcurrentHashMap<>();
+
+  @Inject
+  ThreadAccumulator() {}
+
+  void markThread(String name) {
+    threadIds.put(name, Thread.currentThread().getId());
+  }
+
+  long threadId(String name) {
+    return threadIds.get(name);
+  }
+}
diff --git a/javatests/dagger/functional/producers/monitoring/ThreadModule.java b/javatests/dagger/functional/producers/monitoring/ThreadModule.java
new file mode 100644
index 000000000..f55c3e067
--- /dev/null
+++ b/javatests/dagger/functional/producers/monitoring/ThreadModule.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.monitoring;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.functional.producers.monitoring.ThreadQualifiers.Deferred;
+import dagger.functional.producers.monitoring.ThreadQualifiers.EntryPoint;
+import dagger.functional.producers.monitoring.ThreadQualifiers.Required;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+
+@ProducerModule
+final class ThreadModule {
+  @Produces
+  @Deferred
+  Object deferred(ThreadAccumulator acc) {
+    acc.markThread("deferred");
+    return new Object();
+  }
+
+  @Produces
+  @Required
+  ListenableFuture<Object> required(@Deferred Producer<Object> o, ThreadAccumulator acc) {
+    acc.markThread("required");
+    return o.get();
+  }
+
+  @Produces
+  @EntryPoint
+  ThreadAccumulator entryPoint(@Required Object o, ThreadAccumulator acc) {
+    acc.markThread("entryPoint");
+    return acc;
+  }
+}
diff --git a/javatests/dagger/functional/producers/monitoring/ThreadMonitoredComponent.java b/javatests/dagger/functional/producers/monitoring/ThreadMonitoredComponent.java
new file mode 100644
index 000000000..576cd7ff8
--- /dev/null
+++ b/javatests/dagger/functional/producers/monitoring/ThreadMonitoredComponent.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.monitoring;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.functional.producers.ExecutorModule;
+import dagger.functional.producers.monitoring.ThreadQualifiers.EntryPoint;
+import dagger.producers.ProductionComponent;
+import javax.inject.Singleton;
+
+@Singleton
+@ProductionComponent(modules = {ExecutorModule.class, MonitoringModule.class, ThreadModule.class})
+interface ThreadMonitoredComponent {
+  @EntryPoint
+  ListenableFuture<ThreadAccumulator> threadAccumulator();
+}
diff --git a/javatests/dagger/functional/producers/monitoring/ThreadQualifiers.java b/javatests/dagger/functional/producers/monitoring/ThreadQualifiers.java
new file mode 100644
index 000000000..59ccbe468
--- /dev/null
+++ b/javatests/dagger/functional/producers/monitoring/ThreadQualifiers.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.monitoring;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
+
+final class ThreadQualifiers {
+  private ThreadQualifiers() {}
+
+  @Qualifier
+  @Retention(RUNTIME)
+  @Documented
+  @interface EntryPoint {}
+
+  @Qualifier
+  @Retention(RUNTIME)
+  @Documented
+  @interface Required {}
+
+  @Qualifier
+  @Retention(RUNTIME)
+  @Documented
+  @interface Deferred {}
+}
diff --git a/javatests/dagger/functional/producers/multibindings/MultibindingComponent.java b/javatests/dagger/functional/producers/multibindings/MultibindingComponent.java
new file mode 100644
index 000000000..fa5c6ee76
--- /dev/null
+++ b/javatests/dagger/functional/producers/multibindings/MultibindingComponent.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.multibindings;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.functional.producers.ExecutorModule;
+import dagger.functional.producers.multibindings.Qualifiers.EmptyButDeclaredInModule;
+import dagger.functional.producers.multibindings.Qualifiers.EmptyButDeclaredInModuleAndProducerModule;
+import dagger.functional.producers.multibindings.Qualifiers.ObjCount;
+import dagger.functional.producers.multibindings.Qualifiers.OnlyProvisionMultibindings;
+import dagger.functional.producers.multibindings.Qualifiers.PossiblyThrowingMap;
+import dagger.functional.producers.multibindings.Qualifiers.PossiblyThrowingSet;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.ProductionComponent;
+import java.util.Map;
+import java.util.Set;
+
+@ProductionComponent(
+  modules = {ExecutorModule.class, MultibindingProducerModule.class, MultibindingModule.class}
+)
+interface MultibindingComponent {
+  ListenableFuture<Set<String>> strs();
+  ListenableFuture<Integer> strCount();
+
+  ListenableFuture<Set<Produced<String>>> successfulSet();
+
+  @PossiblyThrowingSet
+  ListenableFuture<Set<Produced<String>>> possiblyThrowingSet();
+
+  ListenableFuture<Map<Integer, String>> map();
+
+  ListenableFuture<Map<Integer, Producer<String>>> mapOfProducer();
+
+  ListenableFuture<Map<Integer, Produced<String>>> mapOfProduced();
+
+  @PossiblyThrowingMap
+  ListenableFuture<Map<Integer, String>> possiblyThrowingMap();
+
+  @PossiblyThrowingMap
+  ListenableFuture<Map<Integer, Producer<String>>> possiblyThrowingMapOfProducer();
+
+  @PossiblyThrowingMap
+  ListenableFuture<Map<Integer, Produced<String>>> possiblyThrowingMapOfProduced();
+
+  ListenableFuture<Set<Object>> objs();
+
+  ListenableFuture<Set<Produced<Object>>> producedObjs();
+
+  ListenableFuture<Map<Object, Object>> objMap();
+
+  ListenableFuture<Map<Object, Produced<Object>>> objMapOfProduced();
+
+  ListenableFuture<Map<Object, Producer<Object>>> objMapOfProducer();
+
+  @ObjCount
+  ListenableFuture<Integer> objCount();
+
+  @EmptyButDeclaredInModuleAndProducerModule
+  ListenableFuture<Map<String, Object>> emptyButDeclaredInModuleAndProducerModule();
+
+  @EmptyButDeclaredInModule
+  ListenableFuture<Map<String, Object>> emptyButDeclaredInModule();
+
+  @OnlyProvisionMultibindings
+  ListenableFuture<Map<String, Object>> onlyProvisionMultibindings();
+}
diff --git a/javatests/dagger/functional/producers/multibindings/MultibindingModule.java b/javatests/dagger/functional/producers/multibindings/MultibindingModule.java
new file mode 100644
index 000000000..08ed6d7c3
--- /dev/null
+++ b/javatests/dagger/functional/producers/multibindings/MultibindingModule.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.multibindings;
+
+import com.google.common.collect.ImmutableSet;
+import dagger.Module;
+import dagger.Provides;
+import dagger.functional.producers.multibindings.Qualifiers.EmptyButDeclaredInModule;
+import dagger.functional.producers.multibindings.Qualifiers.EmptyButDeclaredInModuleAndProducerModule;
+import dagger.functional.producers.multibindings.Qualifiers.OnlyProvisionMultibindings;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntKey;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+import dagger.multibindings.Multibinds;
+import dagger.multibindings.StringKey;
+import java.util.Map;
+import java.util.Set;
+
+@Module
+abstract class MultibindingModule {
+  @Provides
+  @IntoSet
+  static String providedStr() {
+    return "providedStr";
+  }
+
+  @Provides
+  @ElementsIntoSet
+  static Set<String> providedStrs() {
+    return ImmutableSet.of("providedStr1", "providedStr2");
+  }
+
+  @Provides
+  @IntoMap
+  @IntKey(3)
+  static String providedValueFor3() {
+    return "provided three";
+  }
+  
+  @Multibinds
+  @EmptyButDeclaredInModuleAndProducerModule
+  abstract Map<String, Object> emptyButDeclaredInModuleAndProducerModule();
+
+  @Multibinds
+  @EmptyButDeclaredInModule
+  abstract Map<String, Object> emptyButDeclaredInModule();
+
+  @Provides
+  @IntoMap
+  @StringKey("a")
+  @OnlyProvisionMultibindings
+  static Object onlyProvisionMultibindings() {
+    return "only multibinding";
+  }
+}
diff --git a/javatests/dagger/functional/producers/multibindings/MultibindingProducerModule.java b/javatests/dagger/functional/producers/multibindings/MultibindingProducerModule.java
new file mode 100644
index 000000000..350733b2a
--- /dev/null
+++ b/javatests/dagger/functional/producers/multibindings/MultibindingProducerModule.java
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.multibindings;
+
+import com.google.common.collect.ImmutableSet;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.functional.producers.multibindings.Qualifiers.EmptyButDeclaredInModuleAndProducerModule;
+import dagger.functional.producers.multibindings.Qualifiers.ObjCount;
+import dagger.functional.producers.multibindings.Qualifiers.PossiblyThrowingMap;
+import dagger.functional.producers.multibindings.Qualifiers.PossiblyThrowingSet;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntKey;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+import dagger.multibindings.Multibinds;
+import dagger.producers.Produced;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import java.util.Map;
+import java.util.Set;
+
+@ProducerModule
+abstract class MultibindingProducerModule {
+  @Produces
+  @IntoSet
+  static ListenableFuture<String> futureStr() {
+    return Futures.immediateFuture("foo");
+  }
+
+  @Produces
+  @IntoSet
+  static String str() {
+    return "bar";
+  }
+
+  @Produces
+  @ElementsIntoSet
+  static ListenableFuture<Set<String>> futureStrs() {
+    return Futures.<Set<String>>immediateFuture(ImmutableSet.of("foo1", "foo2"));
+  }
+
+  @Produces
+  @ElementsIntoSet
+  static Set<ListenableFuture<String>> strFutures() {
+    return ImmutableSet.of(Futures.immediateFuture("baz1"), Futures.immediateFuture("baz2"));
+  }
+
+  @Produces
+  @ElementsIntoSet
+  static Set<String> strs() {
+    return ImmutableSet.of("bar1", "bar2");
+  }
+
+  @Produces
+  static int strCount(Set<String> strs) {
+    return strs.size();
+  }
+
+  @Produces
+  @IntoSet
+  @PossiblyThrowingSet
+  static String successfulStringForSet() {
+    return "singleton";
+  }
+
+  @Produces
+  @ElementsIntoSet
+  @PossiblyThrowingSet
+  static Set<String> successfulStringsForSet() {
+    return ImmutableSet.of("double", "ton");
+  }
+
+  @Produces
+  @IntoSet
+  @PossiblyThrowingSet
+  static String throwingStringForSet() {
+    throw new RuntimeException("monkey");
+  }
+
+  @Produces
+  @IntoMap
+  @IntKey(42)
+  static ListenableFuture<String> futureFor42() {
+    return Futures.immediateFuture("forty two");
+  }
+
+  @Produces
+  @IntoMap
+  @IntKey(15)
+  static String valueFor15() {
+    return "fifteen";
+  }
+
+  @Produces
+  @IntoMap
+  @PossiblyThrowingMap
+  @IntKey(42)
+  static ListenableFuture<String> successfulFutureFor42() {
+    return Futures.immediateFuture("forty two");
+  }
+
+  @Produces
+  @IntoMap
+  @PossiblyThrowingMap
+  @IntKey(15)
+  static String throwingValueFor15() {
+    throw new RuntimeException("monkey");
+  }
+
+  @Multibinds
+  abstract Set<Object> objs();
+
+  @Multibinds
+  abstract Map<Object, Object> objMap();
+
+  @Produces
+  @ObjCount
+  static int objCount(Set<Produced<Object>> objs, Map<Object, Produced<Object>> objMap) {
+    return objs.size() + objMap.size();
+  }
+  
+  @Multibinds
+  @EmptyButDeclaredInModuleAndProducerModule
+  abstract Map<String, Object> emptyButDeclaredInModuleAndProducerModule();
+}
diff --git a/javatests/dagger/functional/producers/multibindings/MultibindingTest.java b/javatests/dagger/functional/producers/multibindings/MultibindingTest.java
new file mode 100644
index 000000000..9e5568baa
--- /dev/null
+++ b/javatests/dagger/functional/producers/multibindings/MultibindingTest.java
@@ -0,0 +1,189 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.multibindings;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import com.google.common.collect.Iterables;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ExecutionException;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class MultibindingTest {
+  @Test
+  public void setBinding() throws Exception {
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
+    assertThat(multibindingComponent.strs().get())
+        .containsExactly(
+            "foo",
+            "foo1",
+            "foo2",
+            "baz1",
+            "baz2",
+            "bar",
+            "bar1",
+            "bar2",
+            "providedStr",
+            "providedStr1",
+            "providedStr2");
+    assertThat(multibindingComponent.strCount().get()).isEqualTo(11);
+  }
+
+  @Test
+  public void setBindingOfProduced() throws Exception {
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
+    assertThat(multibindingComponent.successfulSet().get())
+        .containsExactly(
+            Produced.successful("foo"),
+            Produced.successful("foo1"),
+            Produced.successful("foo2"),
+            Produced.successful("baz1"),
+            Produced.successful("baz2"),
+            Produced.successful("bar"),
+            Produced.successful("bar1"),
+            Produced.successful("bar2"),
+            Produced.successful("providedStr"),
+            Produced.successful("providedStr1"),
+            Produced.successful("providedStr2"));
+  }
+
+  @Test
+  public void setBindingOfProducedWithFailures() throws Exception {
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
+    Set<Produced<String>> possiblyThrowingSet = multibindingComponent.possiblyThrowingSet().get();
+    Set<String> successes = new HashSet<>();
+    Set<ExecutionException> failures = new HashSet<>();
+    for (Produced<String> str : possiblyThrowingSet) {
+      try {
+        successes.add(str.get());
+      } catch (ExecutionException e) {
+        failures.add(e);
+      }
+    }
+    assertThat(successes).containsExactly("singleton", "double", "ton");
+    assertThat(failures).hasSize(1);
+    assertThat(Iterables.getOnlyElement(failures).getCause()).hasMessage("monkey");
+  }
+
+  @Test
+  public void mapBinding() throws Exception {
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
+    Map<Integer, String> map = multibindingComponent.map().get();
+    assertThat(map).hasSize(3);
+    assertThat(map).containsEntry(15, "fifteen");
+    assertThat(map).containsEntry(42, "forty two");
+    assertThat(map).containsEntry(3, "provided three");
+  }
+
+  @Test
+  public void mapOfProducerBinding() throws Exception {
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
+    Map<Integer, Producer<String>> map = multibindingComponent.mapOfProducer().get();
+    assertThat(map).hasSize(3);
+    assertThat(map).containsKey(15);
+    assertThat(map.get(15).get().get()).isEqualTo("fifteen");
+    assertThat(map).containsKey(42);
+    assertThat(map.get(42).get().get()).isEqualTo("forty two");
+    assertThat(map).containsKey(3);
+    assertThat(map.get(3).get().get()).isEqualTo("provided three");
+  }
+
+  @Test
+  public void mapOfProducedBinding() throws Exception {
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
+    Map<Integer, Produced<String>> map = multibindingComponent.mapOfProduced().get();
+    assertThat(map).hasSize(3);
+    assertThat(map).containsKey(15);
+    assertThat(map.get(15).get()).isEqualTo("fifteen");
+    assertThat(map).containsKey(42);
+    assertThat(map.get(42).get()).isEqualTo("forty two");
+    assertThat(map).containsKey(3);
+    assertThat(map.get(3).get()).isEqualTo("provided three");
+  }
+
+  @Test
+  public void mapBindingWithFailures() throws Exception {
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
+    try {
+      multibindingComponent.possiblyThrowingMap().get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).hasMessage("monkey");
+    }
+  }
+
+  @Test
+  public void mapOfProducerBindingWithFailures() throws Exception {
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
+    Map<Integer, Producer<String>> map =
+        multibindingComponent.possiblyThrowingMapOfProducer().get();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsKey(42);
+    assertThat(map.get(42).get().get()).isEqualTo("forty two");
+    assertThat(map).containsKey(15);
+    ListenableFuture<String> future = map.get(15).get();
+    try {
+      future.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).hasMessage("monkey");
+    }
+  }
+
+  @Test
+  public void mapOfProducedBindingWithFailures() throws Exception {
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
+    Map<Integer, Produced<String>> map =
+        multibindingComponent.possiblyThrowingMapOfProduced().get();
+    assertThat(map).hasSize(2);
+    assertThat(map).containsKey(42);
+    assertThat(map.get(42).get()).isEqualTo("forty two");
+    assertThat(map).containsKey(15);
+    Produced<String> produced = map.get(15);
+    try {
+      produced.get();
+      fail();
+    } catch (ExecutionException e) {
+      assertThat(e.getCause()).hasMessage("monkey");
+    }
+  }
+
+  @Test
+  public void emptySet() throws Exception {
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
+    assertThat(multibindingComponent.objs().get()).isEmpty();
+    assertThat(multibindingComponent.producedObjs().get()).isEmpty();
+    assertThat(multibindingComponent.objCount().get()).isEqualTo(0);
+  }
+
+  @Test
+  public void emptyMap() throws Exception {
+    MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
+    assertThat(multibindingComponent.objMap().get()).isEmpty();
+    assertThat(multibindingComponent.objMapOfProduced().get()).isEmpty();
+    assertThat(multibindingComponent.objMapOfProducer().get()).isEmpty();
+  }
+}
diff --git a/javatests/dagger/functional/producers/multibindings/Qualifiers.java b/javatests/dagger/functional/producers/multibindings/Qualifiers.java
new file mode 100644
index 000000000..640430c5b
--- /dev/null
+++ b/javatests/dagger/functional/producers/multibindings/Qualifiers.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.multibindings;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
+
+final class Qualifiers {
+  @Documented
+  @Retention(RUNTIME)
+  @Qualifier
+  @interface PossiblyThrowingSet {}
+
+  @Documented
+  @Retention(RUNTIME)
+  @Qualifier
+  @interface PossiblyThrowingMap {}
+
+  @Documented
+  @Retention(RUNTIME)
+  @Qualifier
+  @interface ObjCount {}
+
+  @Documented
+  @Retention(RUNTIME)
+  @Qualifier
+  @interface EmptyButDeclaredInModule {}
+
+  @Documented
+  @Retention(RUNTIME)
+  @Qualifier
+  @interface EmptyButDeclaredInModuleAndProducerModule {}
+
+  @Documented
+  @Retention(RUNTIME)
+  @Qualifier
+  @interface OnlyProvisionMultibindings {}
+
+  private Qualifiers() {}
+}
diff --git a/javatests/dagger/functional/producers/optional/OptionalBindingComponents.java b/javatests/dagger/functional/producers/optional/OptionalBindingComponents.java
new file mode 100644
index 000000000..6a36127b0
--- /dev/null
+++ b/javatests/dagger/functional/producers/optional/OptionalBindingComponents.java
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.optional;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import com.google.auto.value.AutoValue;
+import com.google.common.base.Optional;
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.BindsOptionalOf;
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.Produced;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.Production;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import java.lang.annotation.Retention;
+import java.util.concurrent.Executor;
+import java.util.concurrent.Executors;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+
+/** Classes to support testing {@code BindsOptionalOf} functionality. */
+final class OptionalBindingComponents {
+
+  /** A qualifier. */
+  @Qualifier
+  @Retention(RUNTIME)
+  @interface SomeQualifier {}
+
+  /** A value object that contains various optionally-bound objects. */
+  @AutoValue
+  abstract static class Values {
+    abstract Optional<Value> optionalInstance();
+
+    abstract Optional<Producer<Value>> optionalProducer();
+
+    abstract Optional<Produced<Value>> optionalProduced();
+  }
+
+  enum Value {
+    VALUE,
+    QUALIFIED_VALUE
+  }
+
+  @Module
+  static final class ExecutorModule {
+    @Provides
+    @Production
+    static Executor executor() {
+      return Executors.newSingleThreadExecutor();
+    }
+  }
+
+  /** Binds optionals and {@link Values}. */
+  @ProducerModule
+  abstract static class OptionalBindingModule {
+    @BindsOptionalOf
+    abstract Value value();
+
+    @BindsOptionalOf
+    @SomeQualifier
+    abstract Value qualifiedValue();
+
+    @Produces
+    static Values values(
+        Optional<Value> optionalInstance,
+        Optional<Producer<Value>> optionalProducer,
+        Optional<Produced<Value>> optionalProduced) {
+      return new AutoValue_OptionalBindingComponents_Values(
+          optionalInstance, optionalProducer, optionalProduced);
+    }
+
+    @Produces
+    @SomeQualifier
+    static Values qualifiedValues(
+        Optional<Value> optionalInstance,
+        Optional<Producer<Value>> optionalProducer,
+        Optional<Produced<Value>> optionalProduced) {
+      return new AutoValue_OptionalBindingComponents_Values(
+          optionalInstance, optionalProducer, optionalProduced);
+    }
+  }
+
+  /** Binds {@link Value} using {@link Producer}s. */
+  @ProducerModule
+  abstract static class ConcreteBindingProducerModule {
+    @Produces
+    static Value value() {
+      return Value.VALUE;
+    }
+
+    @Produces
+    @SomeQualifier
+    static Value qualifiedValue() {
+      return Value.QUALIFIED_VALUE;
+    }
+  }
+
+  /** Binds {@link Value} using {@link Provider}s. */
+  @Module
+  abstract static class ConcreteBindingModule {
+    @Provides
+    static Value value() {
+      return Value.VALUE;
+    }
+
+    @Provides
+    @SomeQualifier
+    static Value qualifiedValue() {
+      return Value.QUALIFIED_VALUE;
+    }
+  }
+
+  interface OptionalBindingComponent {
+    ListenableFuture<Values> values();
+
+    ListenableFuture<Optional<Value>> optionalInstance();
+
+    ListenableFuture<Optional<Producer<Value>>> optionalProducer();
+
+    ListenableFuture<Optional<Produced<Value>>> optionalProduced();
+
+    @SomeQualifier
+    ListenableFuture<Values> qualifiedValues();
+
+    @SomeQualifier
+    ListenableFuture<Optional<Value>> qualifiedOptionalInstance();
+
+    @SomeQualifier
+    ListenableFuture<Optional<Producer<Value>>> qualifiedOptionalProducer();
+
+    @SomeQualifier
+    ListenableFuture<Optional<Produced<Value>>> qualifiedOptionalProduced();
+  }
+
+  @ProductionComponent(modules = {ExecutorModule.class, OptionalBindingModule.class})
+  interface AbsentOptionalBindingComponent extends OptionalBindingComponent {
+    PresentOptionalBindingSubcomponent presentChild();
+  }
+
+  @ProductionComponent(
+    modules = {
+      ExecutorModule.class,
+      OptionalBindingModule.class,
+      ConcreteBindingProducerModule.class
+    }
+  )
+  interface PresentOptionalBindingComponent extends OptionalBindingComponent {}
+
+  @ProductionSubcomponent(modules = ConcreteBindingProducerModule.class)
+  interface PresentOptionalBindingSubcomponent extends OptionalBindingComponent {}
+
+  @ProductionComponent(
+    modules = {ExecutorModule.class, OptionalBindingModule.class, ConcreteBindingModule.class}
+  )
+  interface PresentOptionalProvisionBindingComponent extends OptionalBindingComponent {}
+}
diff --git a/javatests/dagger/functional/producers/optional/OptionalBindingComponentsAbsentTest.java b/javatests/dagger/functional/producers/optional/OptionalBindingComponentsAbsentTest.java
new file mode 100644
index 000000000..4bb723462
--- /dev/null
+++ b/javatests/dagger/functional/producers/optional/OptionalBindingComponentsAbsentTest.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.optional;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.functional.producers.optional.OptionalBindingComponents.AbsentOptionalBindingComponent;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for absent optional bindings. */
+@RunWith(JUnit4.class)
+public final class OptionalBindingComponentsAbsentTest {
+  private AbsentOptionalBindingComponent absent;
+
+  @Before
+  public void setUp() {
+    absent = DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create();
+  }
+
+  @Test
+  public void optional() throws Exception {
+    assertThat(absent.optionalInstance().get()).isAbsent();
+  }
+
+  @Test
+  public void optionalProducer() throws Exception {
+    assertThat(absent.optionalProducer().get()).isAbsent();
+  }
+
+  @Test
+  public void optionalProduced() throws Exception {
+    assertThat(absent.optionalProduced().get()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptional() throws Exception {
+    assertThat(absent.qualifiedOptionalInstance().get()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptionalProducer() throws Exception {
+    assertThat(absent.qualifiedOptionalProducer().get()).isAbsent();
+  }
+
+  @Test
+  public void qualifiedOptionalProduced() throws Exception {
+    assertThat(absent.qualifiedOptionalProduced().get()).isAbsent();
+  }
+}
diff --git a/javatests/dagger/functional/producers/optional/OptionalBindingComponentsPresentTest.java b/javatests/dagger/functional/producers/optional/OptionalBindingComponentsPresentTest.java
new file mode 100644
index 000000000..030ccc669
--- /dev/null
+++ b/javatests/dagger/functional/producers/optional/OptionalBindingComponentsPresentTest.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.optional;
+
+import static com.google.common.truth.Truth.assertThat;
+import static dagger.functional.producers.optional.OptionalBindingComponents.Value.QUALIFIED_VALUE;
+import static dagger.functional.producers.optional.OptionalBindingComponents.Value.VALUE;
+
+import com.google.common.collect.ImmutableList;
+import dagger.functional.producers.optional.OptionalBindingComponents.OptionalBindingComponent;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+/** Tests for present optional bindings. */
+@RunWith(Parameterized.class)
+public final class OptionalBindingComponentsPresentTest {
+
+  @Parameters(name = "{0}")
+  public static Iterable<Object[]> parameters() {
+    return ImmutableList.copyOf(
+        new Object[][] {
+          {DaggerOptionalBindingComponents_PresentOptionalBindingComponent.create()},
+          {DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create().presentChild()},
+          {DaggerOptionalBindingComponents_PresentOptionalProvisionBindingComponent.create()}
+        });
+  }
+  
+  private final OptionalBindingComponent component;
+
+  public OptionalBindingComponentsPresentTest(OptionalBindingComponent component) {
+    this.component = component;
+  }
+
+  @Test
+  public void optional() throws Exception {
+    assertThat(component.optionalInstance().get()).hasValue(VALUE);
+  }
+
+  @Test
+  public void optionalProducer() throws Exception {
+    assertThat(component.optionalProducer().get().get().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void optionalProduced() throws Exception {
+    assertThat(component.optionalProduced().get().get().get()).isEqualTo(VALUE);
+  }
+
+  @Test
+  public void qualifiedOptional() throws Exception {
+    assertThat(component.qualifiedOptionalInstance().get()).hasValue(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void qualifiedOptionalProducer() throws Exception {
+    assertThat(component.qualifiedOptionalProducer().get().get().get().get())
+        .isEqualTo(QUALIFIED_VALUE);
+  }
+
+  @Test
+  public void qualifiedOptionalProduced() throws Exception {
+    assertThat(component.qualifiedOptionalProduced().get().get().get()).isEqualTo(QUALIFIED_VALUE);
+  }
+}
diff --git a/javatests/dagger/functional/producers/provisions/Provisions.java b/javatests/dagger/functional/producers/provisions/Provisions.java
new file mode 100644
index 000000000..e9f32f5ec
--- /dev/null
+++ b/javatests/dagger/functional/producers/provisions/Provisions.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.provisions;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.functional.producers.ExecutorModule;
+import dagger.producers.Producer;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.ProductionComponent;
+import javax.inject.Inject;
+import javax.inject.Qualifier;
+
+/** Tests for requesting provisions from producers. */
+final class Provisions {
+  static final class InjectedClass {
+    @Inject InjectedClass() {}
+  }
+
+  static final class WrappedProducer<T> {
+    final Producer<T> producer;
+
+    WrappedProducer(Producer<T> producer) {
+      this.producer = producer;
+    }
+  }
+
+  static final class Output {
+    final Producer<InjectedClass> injectedClass1;
+    final Producer<InjectedClass> injectedClass2;
+
+    Output(Producer<InjectedClass> injectedClass1, Producer<InjectedClass> injectedClass2) {
+      this.injectedClass1 = injectedClass1;
+      this.injectedClass2 = injectedClass2;
+    }
+  }
+
+  @Qualifier @interface First {}
+  @Qualifier @interface Second {}
+
+  @ProducerModule
+  static final class TestModule {
+    @Produces @First static WrappedProducer<InjectedClass> firstProducer(
+        Producer<InjectedClass> injectedClass) {
+      return new WrappedProducer<InjectedClass>(injectedClass);
+    }
+
+    @Produces @Second static WrappedProducer<InjectedClass> secondProducer(
+        Producer<InjectedClass> injectedClass) {
+      return new WrappedProducer<InjectedClass>(injectedClass);
+    }
+
+    @Produces static Output output(
+        @First WrappedProducer<InjectedClass> producer1,
+        @Second WrappedProducer<InjectedClass> producer2) {
+      return new Output(producer1.producer, producer2.producer);
+    }
+  }
+
+  @ProductionComponent(modules = {ExecutorModule.class, TestModule.class})
+  interface TestComponent {
+    ListenableFuture<Output> output();
+  }
+
+  private Provisions() {}
+}
diff --git a/javatests/dagger/functional/producers/provisions/ProvisionsTest.java b/javatests/dagger/functional/producers/provisions/ProvisionsTest.java
new file mode 100644
index 000000000..06f307432
--- /dev/null
+++ b/javatests/dagger/functional/producers/provisions/ProvisionsTest.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.provisions;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.functional.producers.provisions.Provisions.Output;
+import dagger.functional.producers.provisions.Provisions.TestComponent;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class ProvisionsTest {
+
+  @Test
+  public void provisionsOnlyAreHeldInOneProducer() throws Exception {
+    TestComponent component = DaggerProvisions_TestComponent.create();
+    Output output = component.output().get();
+    assertThat(output.injectedClass1).isSameAs(output.injectedClass2);
+  }
+}
diff --git a/javatests/dagger/functional/producers/scope/ScopeTest.java b/javatests/dagger/functional/producers/scope/ScopeTest.java
new file mode 100644
index 000000000..aaa4219b5
--- /dev/null
+++ b/javatests/dagger/functional/producers/scope/ScopeTest.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.scope;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class ScopeTest {
+
+  @Test
+  public void scope() throws Exception {
+    SetComponent component = DaggerSetComponent.create();
+    assertThat(component.set().get()).hasSize(1);
+    assertThat(component.scopedObject()).isSameAs(component.scopedObject());
+  }
+}
diff --git a/javatests/dagger/functional/producers/scope/ScopedModule.java b/javatests/dagger/functional/producers/scope/ScopedModule.java
new file mode 100644
index 000000000..eec300bfb
--- /dev/null
+++ b/javatests/dagger/functional/producers/scope/ScopedModule.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.scope;
+
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.ProductionScope;
+
+@Module
+final class ScopedModule {
+  @Provides
+  @ProductionScope
+  static Object newScopedObject() {
+    return new Object();
+  }
+}
diff --git a/javatests/dagger/functional/producers/scope/ScopedObject.java b/javatests/dagger/functional/producers/scope/ScopedObject.java
new file mode 100644
index 000000000..07eebd92b
--- /dev/null
+++ b/javatests/dagger/functional/producers/scope/ScopedObject.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.scope;
+
+import dagger.producers.ProductionScope;
+import javax.inject.Inject;
+
+@ProductionScope
+final class ScopedObject {
+  @Inject
+  ScopedObject() {}
+}
diff --git a/javatests/dagger/functional/producers/scope/SetComponent.java b/javatests/dagger/functional/producers/scope/SetComponent.java
new file mode 100644
index 000000000..8400b70a6
--- /dev/null
+++ b/javatests/dagger/functional/producers/scope/SetComponent.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.scope;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.functional.producers.ExecutorModule;
+import dagger.producers.ProductionComponent;
+import java.util.Set;
+
+@ProductionComponent(modules = {ExecutorModule.class, ScopedModule.class, SetProducerModule.class})
+interface SetComponent {
+  ScopedObject scopedObject();
+
+  ListenableFuture<Set<Object>> set();
+}
diff --git a/javatests/dagger/functional/producers/scope/SetProducerModule.java b/javatests/dagger/functional/producers/scope/SetProducerModule.java
new file mode 100644
index 000000000..f88c91b03
--- /dev/null
+++ b/javatests/dagger/functional/producers/scope/SetProducerModule.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.scope;
+
+import dagger.multibindings.IntoSet;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+
+/**
+ * A module that provides two entries into a set; but since the inputs are scoped, the set should
+ * only have one value.
+ */
+@ProducerModule
+final class SetProducerModule {
+  @Produces
+  @IntoSet
+  static Object setValue1(Object value) {
+    return value;
+  }
+
+  @Produces
+  @IntoSet
+  static Object setValue2(Object value) {
+    return value;
+  }
+}
diff --git a/javatests/dagger/functional/producers/subcomponent/ModuleSubcomponentsInterop.java b/javatests/dagger/functional/producers/subcomponent/ModuleSubcomponentsInterop.java
new file mode 100644
index 000000000..673be2b29
--- /dev/null
+++ b/javatests/dagger/functional/producers/subcomponent/ModuleSubcomponentsInterop.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.subcomponent;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Subcomponent;
+import dagger.producers.ProducerModule;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+
+final class ModuleSubcomponentsInterop {
+  @Component(modules = ProvisionTestModule.class)
+  interface ProvisionParent {
+    ProductionChild.Builder productionChild();
+  }
+
+  @Module(subcomponents = ProductionChild.class)
+  static class ProvisionTestModule {}
+
+  @ProductionSubcomponent
+  interface ProductionChild {
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      ProductionChild build();
+    }
+  }
+
+  @ProductionComponent(modules = ProductionTestModule.class)
+  interface ProductionParent {
+    ProvisionChild.Builder provisionBuilder();
+  }
+
+  @ProducerModule(subcomponents = ProvisionChild.class)
+  static class ProductionTestModule {}
+
+  @Subcomponent
+  interface ProvisionChild {
+    @Subcomponent.Builder
+    interface Builder {
+      ProvisionChild build();
+    }
+  }
+}
diff --git a/javatests/dagger/functional/producers/subcomponent/MultiPackageSubcomponentTest.java b/javatests/dagger/functional/producers/subcomponent/MultiPackageSubcomponentTest.java
new file mode 100644
index 000000000..482991d68
--- /dev/null
+++ b/javatests/dagger/functional/producers/subcomponent/MultiPackageSubcomponentTest.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.subcomponent;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.functional.producers.subcomponent.MultiPackageSubcomponents.ParentComponent;
+import dagger.functional.producers.subcomponent.sub.ChildComponent;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class MultiPackageSubcomponentTest {
+
+  @Test
+  public void childComponent() throws Exception {
+    ParentComponent parent = DaggerMultiPackageSubcomponents_ParentComponent.create();
+    ChildComponent child = parent.childComponentBuilder().build();
+    assertThat(child.str().get()).isEqualTo("Hello, World 42");
+  }
+}
diff --git a/javatests/dagger/functional/producers/subcomponent/MultiPackageSubcomponents.java b/javatests/dagger/functional/producers/subcomponent/MultiPackageSubcomponents.java
new file mode 100644
index 000000000..953bfff50
--- /dev/null
+++ b/javatests/dagger/functional/producers/subcomponent/MultiPackageSubcomponents.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.subcomponent;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.functional.producers.subcomponent.sub.ChildComponent;
+
+final class MultiPackageSubcomponents {
+  @Component(modules = IntModule.class)
+  interface ParentComponent {
+    ChildComponent.Builder childComponentBuilder();
+  }
+
+  @Module
+  static final class IntModule {
+    @Provides
+    static int i() {
+      return 42;
+    }
+  }
+
+  private MultiPackageSubcomponents() {}
+}
diff --git a/javatests/dagger/functional/producers/subcomponent/ProducerModuleWithSubcomponentsTest.java b/javatests/dagger/functional/producers/subcomponent/ProducerModuleWithSubcomponentsTest.java
new file mode 100644
index 000000000..756807139
--- /dev/null
+++ b/javatests/dagger/functional/producers/subcomponent/ProducerModuleWithSubcomponentsTest.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.subcomponent;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.functional.producers.subcomponent.UsesProducerModuleSubcomponents.ParentIncludesProductionSubcomponentTransitively;
+import dagger.producers.ProducerModule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for {@link ProducerModule#subcomponents()}. */
+@RunWith(JUnit4.class)
+public class ProducerModuleWithSubcomponentsTest {
+
+  @Test
+  public void subcomponentFromModules() throws Exception {
+    UsesProducerModuleSubcomponents parent = DaggerUsesProducerModuleSubcomponents.create();
+    assertThat(parent.strings().get()).containsExactly("from parent");
+    assertThat(parent.stringsFromChild().get()).containsExactly("from parent", "from child");
+  }
+
+  @Test
+  public void subcomponentFromModules_transitively() throws Exception {
+    ParentIncludesProductionSubcomponentTransitively parent =
+        DaggerUsesProducerModuleSubcomponents_ParentIncludesProductionSubcomponentTransitively
+            .create();
+    assertThat(parent.strings().get()).containsExactly("from parent");
+    assertThat(parent.stringsFromChild().get()).containsExactly("from parent", "from child");
+  }
+}
diff --git a/javatests/dagger/functional/producers/subcomponent/ProductionSubcomponentFromModuleAndFactoryMethod.java b/javatests/dagger/functional/producers/subcomponent/ProductionSubcomponentFromModuleAndFactoryMethod.java
new file mode 100644
index 000000000..128624726
--- /dev/null
+++ b/javatests/dagger/functional/producers/subcomponent/ProductionSubcomponentFromModuleAndFactoryMethod.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.subcomponent;
+
+import dagger.Module;
+import dagger.Subcomponent;
+import dagger.functional.producers.ExecutorModule;
+import dagger.producers.ProducerModule;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+
+/**
+ * Tests for {@link Subcomponent}s which are defined with {@link Module#subcomponents()} and are
+ * also requested as component factory methods.
+ */
+public class ProductionSubcomponentFromModuleAndFactoryMethod {
+  @ProductionSubcomponent
+  interface Sub {
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      Sub sub();
+    }
+  }
+
+  @ProducerModule(subcomponents = Sub.class)
+  static class ModuleWithSubcomponent {}
+
+  @ProductionComponent(modules = {ModuleWithSubcomponent.class, ExecutorModule.class})
+  interface ExposesBuilder {
+    Sub.Builder subcomponentBuilder();
+  }
+}
diff --git a/javatests/dagger/functional/producers/subcomponent/SubcomponentWithBoundExecutorTest.java b/javatests/dagger/functional/producers/subcomponent/SubcomponentWithBoundExecutorTest.java
new file mode 100644
index 000000000..6d176d7f5
--- /dev/null
+++ b/javatests/dagger/functional/producers/subcomponent/SubcomponentWithBoundExecutorTest.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.subcomponent;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.functional.producers.subcomponent.SubcomponentsWithBoundExecutor.ChildComponent;
+import dagger.functional.producers.subcomponent.SubcomponentsWithBoundExecutor.ExecutorModule;
+import dagger.functional.producers.subcomponent.SubcomponentsWithBoundExecutor.GrandchildComponent;
+import dagger.functional.producers.subcomponent.SubcomponentsWithBoundExecutor.GrandchildComponentWithoutBuilder;
+import dagger.functional.producers.subcomponent.SubcomponentsWithBoundExecutor.ParentComponent;
+import dagger.functional.producers.subcomponent.SubcomponentsWithBoundExecutor.ParentProductionComponent;
+import java.util.concurrent.atomic.AtomicInteger;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class SubcomponentWithBoundExecutorTest {
+  private ParentComponent parentComponent;
+  private ParentProductionComponent parentProductionComponent;
+  private final AtomicInteger executorConstructionCount = new AtomicInteger();
+  private final AtomicInteger executionCount = new AtomicInteger();
+
+  @Before
+  public void setUp() {
+    parentComponent =
+        DaggerSubcomponentsWithBoundExecutor_ParentComponent.builder()
+            .executorModule(new ExecutorModule(executorConstructionCount, executionCount))
+            .build();
+    parentProductionComponent =
+        DaggerSubcomponentsWithBoundExecutor_ParentProductionComponent.builder()
+            .executorModule(new ExecutorModule(executorConstructionCount, executionCount))
+            .build();
+  }
+
+  @Test
+  public void topLevelComponent_child() throws Exception {
+    ChildComponent child = parentComponent.newChildComponentBuilder().build();
+    assertThat(child.fromChild().get()).isEqualTo("child:parent");
+    assertThat(executorConstructionCount.get()).isEqualTo(1);
+    assertThat(executionCount.get()).isEqualTo(1);
+  }
+
+  @Test
+  public void topLevelComponent_injectsChildBuilder() throws Exception {
+    ChildComponent child = parentComponent.injectsChildBuilder().childBuilder().build();
+    assertThat(child.fromChild().get()).isEqualTo("child:parent");
+    assertThat(executorConstructionCount.get()).isEqualTo(1);
+    assertThat(executionCount.get()).isEqualTo(1);
+  }
+
+  @Test
+  public void topLevelComponent_grandchild() throws Exception {
+    ChildComponent child = parentComponent.newChildComponentBuilder().build();
+    GrandchildComponent grandchild = child.newGrandchildComponentBuilder().build();
+    assertThat(grandchild.fromGrandchild().get()).isEqualTo("grandchild:child:parent");
+    assertThat(executorConstructionCount.get()).isEqualTo(1);
+    assertThat(executionCount.get()).isEqualTo(2);
+  }
+
+  @Test
+  public void topLevelComponent_grandchildWithoutBuilder() throws Exception {
+    ChildComponent child = parentComponent.newChildComponentBuilder().build();
+    GrandchildComponentWithoutBuilder grandchild = child.newGrandchildComponent();
+    assertThat(grandchild.fromGrandchild().get()).isEqualTo("grandchild:child:parent");
+    assertThat(executorConstructionCount.get()).isEqualTo(1);
+    assertThat(executionCount.get()).isEqualTo(2);
+  }
+
+  @Test
+  public void topLevelProductionComponent_child() throws Exception {
+    ChildComponent child = parentProductionComponent.newChildComponentBuilder().build();
+    assertThat(child.fromChild().get()).isEqualTo("child:parentproduction");
+    assertThat(executorConstructionCount.get()).isEqualTo(1);
+    assertThat(executionCount.get()).isEqualTo(2);
+  }
+
+  @Test
+  public void topLevelProductionComponent_grandchild() throws Exception {
+    ChildComponent child = parentProductionComponent.newChildComponentBuilder().build();
+    GrandchildComponent grandchild = child.newGrandchildComponentBuilder().build();
+    assertThat(grandchild.fromGrandchild().get()).isEqualTo("grandchild:child:parentproduction");
+    assertThat(executorConstructionCount.get()).isEqualTo(1);
+    assertThat(executionCount.get()).isEqualTo(3);
+  }
+
+  @Test
+  public void topLevelProductionComponent_grandchildWithoutBuilder() throws Exception {
+    ChildComponent child = parentProductionComponent.newChildComponentBuilder().build();
+    GrandchildComponentWithoutBuilder grandchild = child.newGrandchildComponent();
+    assertThat(grandchild.fromGrandchild().get()).isEqualTo("grandchild:child:parentproduction");
+    assertThat(executorConstructionCount.get()).isEqualTo(1);
+    assertThat(executionCount.get()).isEqualTo(3);
+  }
+}
diff --git a/javatests/dagger/functional/producers/subcomponent/SubcomponentsWithBoundExecutor.java b/javatests/dagger/functional/producers/subcomponent/SubcomponentsWithBoundExecutor.java
new file mode 100644
index 000000000..f7059c751
--- /dev/null
+++ b/javatests/dagger/functional/producers/subcomponent/SubcomponentsWithBoundExecutor.java
@@ -0,0 +1,176 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.subcomponent;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.Production;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import java.util.concurrent.Executor;
+import java.util.concurrent.atomic.AtomicInteger;
+import javax.inject.Inject;
+import javax.inject.Provider;
+import javax.inject.Qualifier;
+
+final class SubcomponentsWithBoundExecutor {
+  @Qualifier
+  @interface FromParent {}
+
+  @Qualifier
+  @interface FromChild {}
+
+  @Qualifier
+  @interface FromGrandchild {}
+
+  static final class CountingExecutor implements Executor {
+    private final AtomicInteger executionCount;
+
+    CountingExecutor(AtomicInteger executionCount) {
+      this.executionCount = executionCount;
+    }
+
+    @Override
+    public void execute(Runnable runnable) {
+      executionCount.incrementAndGet();
+      runnable.run();
+    }
+  }
+
+  @Module
+  static final class ExecutorModule {
+    private final AtomicInteger constructionCount;
+    private final AtomicInteger executionCount;
+
+    ExecutorModule(AtomicInteger constructionCount, AtomicInteger executionCount) {
+      this.constructionCount = constructionCount;
+      this.executionCount = executionCount;
+    }
+
+    @Provides
+    @Production
+    Executor executor() {
+      constructionCount.incrementAndGet();
+      return new CountingExecutor(executionCount);
+    }
+  }
+
+  @Module
+  static final class ParentModule {
+    @Provides
+    @FromParent
+    static String fromParent() {
+      return "parent";
+    }
+  }
+
+  @Component(modules = {ParentModule.class, ExecutorModule.class})
+  interface ParentComponent {
+    InjectsChildBuilder injectsChildBuilder();
+
+    ChildComponent.Builder newChildComponentBuilder();
+  }
+
+  @ProducerModule
+  static final class ParentProducerModule {
+    @Produces
+    @FromParent
+    static String fromParent() {
+      return "parentproduction";
+    }
+  }
+
+  @ProductionComponent(modules = {ParentProducerModule.class, ExecutorModule.class})
+  interface ParentProductionComponent {
+    ChildComponent.Builder newChildComponentBuilder();
+
+    @ProductionComponent.Builder
+    interface Builder {
+      Builder executorModule(ExecutorModule executorModule);
+
+      ParentProductionComponent build();
+    }
+  }
+
+  @ProducerModule
+  static final class ChildProducerModule {
+    @Produces
+    @FromChild
+    static String fromChild(@FromParent String fromParent) {
+      return "child:" + fromParent;
+    }
+  }
+
+  @ProductionSubcomponent(modules = ChildProducerModule.class)
+  interface ChildComponent {
+    @FromChild
+    ListenableFuture<String> fromChild();
+
+    GrandchildComponent.Builder newGrandchildComponentBuilder();
+    GrandchildComponentWithoutBuilder newGrandchildComponent();
+
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      ChildComponent build();
+    }
+  }
+
+  static final class InjectsChildBuilder {
+    private final Provider<ChildComponent.Builder> childBuilder;
+
+    @Inject
+    InjectsChildBuilder(Provider<ChildComponent.Builder> childBuilder) {
+      this.childBuilder = childBuilder;
+    }
+
+    ChildComponent.Builder childBuilder() {
+      return childBuilder.get();
+    }
+  }
+
+  @ProducerModule
+  static final class GrandchildProducerModule {
+    @Produces
+    @FromGrandchild
+    static String fromGranchild(@FromChild String fromChild) {
+      return "grandchild:" + fromChild;
+    }
+  }
+
+  @ProductionSubcomponent(modules = GrandchildProducerModule.class)
+  interface GrandchildComponent {
+    @FromGrandchild
+    ListenableFuture<String> fromGrandchild();
+
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      GrandchildComponent build();
+    }
+  }
+
+  @ProductionSubcomponent(modules = GrandchildProducerModule.class)
+  interface GrandchildComponentWithoutBuilder {
+    @FromGrandchild
+    ListenableFuture<String> fromGrandchild();
+  }
+
+  private SubcomponentsWithBoundExecutor() {}
+}
diff --git a/javatests/dagger/functional/producers/subcomponent/UsesProducerModuleSubcomponents.java b/javatests/dagger/functional/producers/subcomponent/UsesProducerModuleSubcomponents.java
new file mode 100644
index 000000000..31253cc70
--- /dev/null
+++ b/javatests/dagger/functional/producers/subcomponent/UsesProducerModuleSubcomponents.java
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.subcomponent;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.functional.producers.ExecutorModule;
+import dagger.multibindings.IntoSet;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import java.util.Set;
+import javax.inject.Qualifier;
+
+/** Supporting types for {@code ProducerModuleWithSubcomponentsTest}. */
+@ProductionComponent(
+  modules = UsesProducerModuleSubcomponents.ProducerModuleWithSubcomponents.class
+)
+public interface UsesProducerModuleSubcomponents {
+
+  ListenableFuture<Set<String>> strings();
+
+  @FromChild
+  ListenableFuture<Set<String>> stringsFromChild();
+
+  @ProducerModule(
+    subcomponents = Child.class,
+    includes = {AlsoIncludesSubcomponents.class, ExecutorModule.class}
+  )
+  class ProducerModuleWithSubcomponents {
+    @Produces
+    @IntoSet
+    static String produceStringInParent() {
+      return "from parent";
+    }
+
+    @Produces
+    @FromChild
+    static Set<String> stringsFromChild(Child.Builder childBuilder) throws Exception {
+      return childBuilder.build().strings().get();
+    }
+  }
+
+  @ProducerModule(subcomponents = Child.class)
+  class AlsoIncludesSubcomponents {}
+
+  @ProductionSubcomponent(modules = ChildModule.class)
+  interface Child {
+    ListenableFuture<Set<String>> strings();
+
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      Child build();
+    }
+  }
+
+  @ProducerModule
+  class ChildModule {
+    @Produces
+    @IntoSet
+    static String produceStringInChild() {
+      return "from child";
+    }
+  }
+
+  @Qualifier
+  @interface FromChild {}
+
+  @ProducerModule(includes = ProducerModuleWithSubcomponents.class)
+  class OnlyIncludesProducerModuleWithSubcomponents {}
+
+  @ProductionComponent(modules = OnlyIncludesProducerModuleWithSubcomponents.class)
+  interface ParentIncludesProductionSubcomponentTransitively
+      extends UsesProducerModuleSubcomponents {}
+}
diff --git a/javatests/dagger/functional/producers/subcomponent/pruning/ParentDoesntUseProductionSubcomponent.java b/javatests/dagger/functional/producers/subcomponent/pruning/ParentDoesntUseProductionSubcomponent.java
new file mode 100644
index 000000000..bf931c19c
--- /dev/null
+++ b/javatests/dagger/functional/producers/subcomponent/pruning/ParentDoesntUseProductionSubcomponent.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.subcomponent.pruning;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.multibindings.IntoSet;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.ProductionComponent;
+import dagger.producers.ProductionSubcomponent;
+import java.util.Set;
+import javax.inject.Qualifier;
+
+/**
+ * Supporting types for {@code ProductionSubcomponentOnlyRequestedBySiblingTest}. {@link ChildA} is
+ * a direct child of the top level component, but is only requested within its sibling, not directly
+ * from its parent.
+ */
+@ProductionComponent(
+  modules = {
+    ParentDoesntUseProductionSubcomponent.ParentModule.class,
+    dagger.functional.producers.ExecutorModule.class
+  }
+)
+interface ParentDoesntUseProductionSubcomponent {
+
+  ChildB.Builder childBBuilder();
+
+  @ProductionSubcomponent(modules = ChildAModule.class)
+  interface ChildA {
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      ChildA build();
+    }
+
+    ListenableFuture<Set<Class<?>>> componentHierarchy();
+  }
+
+  @ProductionSubcomponent(modules = ChildBModule.class)
+  interface ChildB {
+    @ProductionSubcomponent.Builder
+    interface Builder {
+      ChildB build();
+    }
+
+    ListenableFuture<Set<Class<?>>> componentHierarchy();
+
+    @FromChildA
+    ListenableFuture<Set<Class<?>>> componentHierarchyFromChildA();
+  }
+
+  @ProducerModule(subcomponents = {ChildA.class, ChildB.class})
+  class ParentModule {
+    @Produces
+    @IntoSet
+    static Class<?> produceComponentType() {
+      return ParentDoesntUseProductionSubcomponent.class;
+    }
+  }
+
+  @ProducerModule
+  class ChildAModule {
+    @Produces
+    @IntoSet
+    static Class<?> produceComponentType() {
+      return ChildA.class;
+    }
+  }
+
+  @ProducerModule
+  class ChildBModule {
+    @Produces
+    @IntoSet
+    static Class<?> produceComponentType() {
+      return ChildB.class;
+    }
+
+    @Produces
+    @FromChildA
+    Set<Class<?>> fromChildA(ChildA.Builder childABuilder) throws Exception {
+      return childABuilder.build().componentHierarchy().get();
+    }
+  }
+
+  @Qualifier
+  @interface FromChildA {}
+}
diff --git a/javatests/dagger/functional/producers/subcomponent/pruning/ProductionSubcomponentOnlyRequestedBySiblingTest.java b/javatests/dagger/functional/producers/subcomponent/pruning/ProductionSubcomponentOnlyRequestedBySiblingTest.java
new file mode 100644
index 000000000..d17806100
--- /dev/null
+++ b/javatests/dagger/functional/producers/subcomponent/pruning/ProductionSubcomponentOnlyRequestedBySiblingTest.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.subcomponent.pruning;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.functional.producers.subcomponent.pruning.ParentDoesntUseProductionSubcomponent.ChildA;
+import dagger.functional.producers.subcomponent.pruning.ParentDoesntUseProductionSubcomponent.ChildB;
+import dagger.producers.ProducerModule;
+import dagger.producers.ProductionSubcomponent;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests for {@link ProductionSubcomponent}s which are included with {@link
+ * ProducerModule#subcomponents()} but not used directly within the component which adds them.
+ *
+ * <p>This tests to make sure that while resolving one subcomponent (A), another subcomponent (B)
+ * can be requested if they have a shared ancestor component. If that shared ancestor did not
+ * resolve B directly via any of its entry points, B will still be generated since it is requested
+ * by a descendant.
+ */
+@RunWith(JUnit4.class)
+public class ProductionSubcomponentOnlyRequestedBySiblingTest {
+  @Test
+  public void subcomponentAddedInParent_onlyUsedInSibling() throws Exception {
+    ParentDoesntUseProductionSubcomponent parent =
+        DaggerParentDoesntUseProductionSubcomponent.create();
+    ChildB childB = parent.childBBuilder().build();
+    assertThat(childB.componentHierarchy().get())
+        .containsExactly(ParentDoesntUseProductionSubcomponent.class, ChildB.class);
+    assertThat(childB.componentHierarchyFromChildA().get())
+        .containsExactly(ParentDoesntUseProductionSubcomponent.class, ChildA.class);
+  }
+}
diff --git a/javatests/dagger/functional/producers/subcomponent/sub/ChildComponent.java b/javatests/dagger/functional/producers/subcomponent/sub/ChildComponent.java
new file mode 100644
index 000000000..4dfb112d5
--- /dev/null
+++ b/javatests/dagger/functional/producers/subcomponent/sub/ChildComponent.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.subcomponent.sub;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.functional.producers.ExecutorModule;
+import dagger.producers.ProductionSubcomponent;
+
+@ProductionSubcomponent(modules = {ExecutorModule.class, ChildModule.class})
+public interface ChildComponent {
+  ListenableFuture<String> str();
+
+  @ProductionSubcomponent.Builder
+  interface Builder {
+    ChildComponent build();
+  }
+}
diff --git a/javatests/dagger/functional/producers/subcomponent/sub/ChildModule.java b/javatests/dagger/functional/producers/subcomponent/sub/ChildModule.java
new file mode 100644
index 000000000..8994a8ad0
--- /dev/null
+++ b/javatests/dagger/functional/producers/subcomponent/sub/ChildModule.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.producers.subcomponent.sub;
+
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+
+@ProducerModule
+final class ChildModule {
+  @Produces
+  static String str(int n) {
+    return "Hello, World " + n;
+  }
+}
diff --git a/javatests/dagger/functional/scope/BlueModule.java b/javatests/dagger/functional/scope/BlueModule.java
new file mode 100644
index 000000000..e04bc7a32
--- /dev/null
+++ b/javatests/dagger/functional/scope/BlueModule.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.scope;
+
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.IntoSet;
+
+@Module
+final class BlueModule {
+  @Provides
+  @IntoSet
+  @BlueScope
+  static Object blue() {
+    return new Object();
+  }
+}
diff --git a/javatests/dagger/functional/scope/BlueScope.java b/javatests/dagger/functional/scope/BlueScope.java
new file mode 100644
index 000000000..ecd0da51b
--- /dev/null
+++ b/javatests/dagger/functional/scope/BlueScope.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.scope;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Scope;
+
+@Documented
+@Retention(RUNTIME)
+@Scope
+@interface BlueScope {}
diff --git a/javatests/dagger/functional/scope/GreenModule.java b/javatests/dagger/functional/scope/GreenModule.java
new file mode 100644
index 000000000..3f9248f21
--- /dev/null
+++ b/javatests/dagger/functional/scope/GreenModule.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.scope;
+
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.IntoSet;
+
+@Module
+final class GreenModule  {
+  @Provides
+  @IntoSet
+  @GreenScope
+  static Object green() {
+    return new Object();
+  }
+}
diff --git a/javatests/dagger/functional/scope/GreenScope.java b/javatests/dagger/functional/scope/GreenScope.java
new file mode 100644
index 000000000..92bcc620f
--- /dev/null
+++ b/javatests/dagger/functional/scope/GreenScope.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.scope;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Scope;
+
+@Documented
+@Retention(RUNTIME)
+@Scope
+@interface GreenScope {}
diff --git a/javatests/dagger/functional/scope/ScopeTest.java b/javatests/dagger/functional/scope/ScopeTest.java
new file mode 100644
index 000000000..40c1fa91e
--- /dev/null
+++ b/javatests/dagger/functional/scope/ScopeTest.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.scope;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class ScopeTest {
+
+  @Test
+  public void testScope() {
+    ScopedComponent component = DaggerScopedComponent.create();
+    assertThat(component.set()).hasSize(4);
+    assertThat(component.set()).isEqualTo(component.set());
+  }
+}
diff --git a/javatests/dagger/functional/scope/ScopedComponent.java b/javatests/dagger/functional/scope/ScopedComponent.java
new file mode 100644
index 000000000..fa9b0da4a
--- /dev/null
+++ b/javatests/dagger/functional/scope/ScopedComponent.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.scope;
+
+import dagger.Component;
+import java.util.Set;
+
+@BlueScope
+@GreenScope
+@Component(modules = {BlueModule.class, GreenModule.class, TurquoiseModule.class})
+interface ScopedComponent {
+  Set<Object> set();
+}
diff --git a/javatests/dagger/functional/scope/TurquoiseModule.java b/javatests/dagger/functional/scope/TurquoiseModule.java
new file mode 100644
index 000000000..780ecb26a
--- /dev/null
+++ b/javatests/dagger/functional/scope/TurquoiseModule.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.scope;
+
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.IntoSet;
+
+@Module
+final class TurquoiseModule {
+  @Provides
+  @IntoSet
+  @BlueScope
+  static Object blue() {
+    return new Object();
+  }
+
+  @Provides
+  @IntoSet
+  @GreenScope
+  static Object green() {
+    return new Object();
+  }
+}
diff --git a/javatests/dagger/functional/staticprovides/AllStaticModule.java b/javatests/dagger/functional/staticprovides/AllStaticModule.java
new file mode 100644
index 000000000..fff63eec3
--- /dev/null
+++ b/javatests/dagger/functional/staticprovides/AllStaticModule.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.staticprovides;
+
+import static java.util.Collections.emptySet;
+
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoSet;
+import java.util.Set;
+
+@Module
+final class AllStaticModule {
+  @Provides
+  @IntoSet
+  static String contributeString() {
+    return AllStaticModule.class + ".contributeString";
+  }
+
+  @Provides
+  @ElementsIntoSet
+  static Set<Integer> contibuteEmptyIntegerSet() {
+    return emptySet();
+  }
+}
diff --git a/javatests/dagger/functional/staticprovides/SomeStaticModule.java b/javatests/dagger/functional/staticprovides/SomeStaticModule.java
new file mode 100644
index 000000000..ab65b58d6
--- /dev/null
+++ b/javatests/dagger/functional/staticprovides/SomeStaticModule.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.staticprovides;
+
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.IntoSet;
+
+@Module
+final class SomeStaticModule {
+  @Provides
+  @IntoSet
+  static String contributeStringFromAStaticMethod() {
+    return SomeStaticModule.class + ".contributeStringFromAStaticMethod";
+  }
+
+  @Provides
+  @IntoSet
+  static String contributeStringFromAnInstanceMethod() {
+    return SomeStaticModule.class + ".contributeStringFromAnInstanceMethod";
+  }
+}
diff --git a/javatests/dagger/functional/staticprovides/StaticProvidesTest.java b/javatests/dagger/functional/staticprovides/StaticProvidesTest.java
new file mode 100644
index 000000000..9d9952af1
--- /dev/null
+++ b/javatests/dagger/functional/staticprovides/StaticProvidesTest.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.staticprovides;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.truth.Truth.assertWithMessage;
+
+import com.google.common.collect.ImmutableSet;
+import java.lang.reflect.Field;
+import java.lang.reflect.Method;
+import java.util.Arrays;
+import java.util.Collection;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameter;
+import org.junit.runners.Parameterized.Parameters;
+
+@RunWith(Parameterized.class)
+public class StaticProvidesTest {
+  @Parameters
+  public static Collection<Object[]> components() {
+    return Arrays.asList(new Object[][] {
+        {DaggerStaticTestComponent.create()},
+        {DaggerStaticTestComponentWithBuilder.builder().build()},
+        {DaggerStaticTestComponentWithBuilder.builder()
+          .allStaticModule(new AllStaticModule())
+          .someStaticModule(new SomeStaticModule())
+          .build()}});
+  }
+
+  @Parameter
+  public StaticTestComponent component;
+
+  @Test public void setMultibinding() {
+    assertThat(component.getMultiboundStrings()).isEqualTo(ImmutableSet.of(
+        AllStaticModule.class + ".contributeString",
+        SomeStaticModule.class + ".contributeStringFromAStaticMethod",
+        SomeStaticModule.class + ".contributeStringFromAnInstanceMethod"));
+  }
+
+  @Test public void allStaticProvidesModules_noFieldInComponentBuilder() {
+    for (Field field : DaggerStaticTestComponent.Builder.class.getDeclaredFields()) {
+      assertWithMessage(field.getName())
+          .that(field.getType()).isNotEqualTo(AllStaticModule.class);
+    }
+  }
+
+  @Test public void allStaticProvidesModules_deprecatedMethodInComponentBuilder() {
+    for (Method method : DaggerStaticTestComponent.Builder.class.getDeclaredMethods()) {
+      if (Arrays.asList(method.getParameterTypes()).contains(AllStaticModule.class)) {
+        assertWithMessage(method.getName())
+            .that(method.isAnnotationPresent(Deprecated.class))
+            .isTrue();
+      }
+    }
+  }
+}
diff --git a/javatests/dagger/functional/staticprovides/StaticTestComponent.java b/javatests/dagger/functional/staticprovides/StaticTestComponent.java
new file mode 100644
index 000000000..4dced9102
--- /dev/null
+++ b/javatests/dagger/functional/staticprovides/StaticTestComponent.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.staticprovides;
+
+import dagger.Component;
+import java.util.Set;
+
+/**
+ * A simple component that demonstrates both static and non-static provides methods.
+ */
+@Component(modules = {AllStaticModule.class, SomeStaticModule.class})
+interface StaticTestComponent {
+  Set<String> getMultiboundStrings();
+  Set<Integer> getMultiboundIntegers();
+}
diff --git a/javatests/dagger/functional/staticprovides/StaticTestComponentWithBuilder.java b/javatests/dagger/functional/staticprovides/StaticTestComponentWithBuilder.java
new file mode 100644
index 000000000..c6e8f2ac8
--- /dev/null
+++ b/javatests/dagger/functional/staticprovides/StaticTestComponentWithBuilder.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.staticprovides;
+
+import dagger.Component;
+
+/**
+ * A simple component that demonstrates both static and non-static provides methods with a builder.
+ */
+@Component(modules = {AllStaticModule.class, SomeStaticModule.class})
+interface StaticTestComponentWithBuilder extends StaticTestComponent {
+  @Component.Builder
+  interface Builder {
+    Builder allStaticModule(AllStaticModule allStaticModule);
+    Builder someStaticModule(SomeStaticModule someStaticModule);
+    StaticTestComponentWithBuilder build();
+  }
+}
diff --git a/javatests/dagger/functional/sub/ContributionsModule.java b/javatests/dagger/functional/sub/ContributionsModule.java
new file mode 100644
index 000000000..654e8f7db
--- /dev/null
+++ b/javatests/dagger/functional/sub/ContributionsModule.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.sub;
+
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoSet;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+@Module
+public final class ContributionsModule {
+  @Provides
+  @IntoSet
+  static int contributeAnInt(@SuppressWarnings("unused") double doubleDependency) {
+    return 1742;
+  }
+
+  @Provides
+  @IntoSet
+  static int contributeAnotherInt() {
+    return 832;
+  }
+
+  @Provides
+  @ElementsIntoSet
+  static Set<Integer> contributeSomeInts() {
+    return Collections.unmodifiableSet(new LinkedHashSet<Integer>(Arrays.asList(-1, -90, -17)));
+  }
+}
diff --git a/javatests/dagger/functional/sub/Exposed.java b/javatests/dagger/functional/sub/Exposed.java
new file mode 100644
index 000000000..2c85db019
--- /dev/null
+++ b/javatests/dagger/functional/sub/Exposed.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.sub;
+
+import dagger.functional.Generic;
+import dagger.functional.Generic2;
+import javax.inject.Inject;
+
+public class Exposed {
+  
+  @Inject public Generic2<PackagePrivate> gpp2;
+  @Inject public Generic2<PackagePrivateContainer.PublicEnclosed> gppc2;
+
+  public Generic<PackagePrivate> gpp;
+  public Generic<PackagePrivateContainer.PublicEnclosed> gppc;
+  
+  @Inject Exposed(Generic<PackagePrivate> gpp, Generic<PackagePrivateContainer.PublicEnclosed> gppc) {
+    this.gpp = gpp;
+    this.gppc = gppc;
+  }
+}
diff --git a/javatests/dagger/functional/sub/OtherThing.java b/javatests/dagger/functional/sub/OtherThing.java
new file mode 100644
index 000000000..9150aaba2
--- /dev/null
+++ b/javatests/dagger/functional/sub/OtherThing.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.sub;
+
+import javax.inject.Inject;
+
+public final class OtherThing {
+  @Inject
+  public OtherThing(@SuppressWarnings("unused") int i) {}
+}
diff --git a/javatests/dagger/functional/sub/PackagePrivate.java b/javatests/dagger/functional/sub/PackagePrivate.java
new file mode 100644
index 000000000..8220877d9
--- /dev/null
+++ b/javatests/dagger/functional/sub/PackagePrivate.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.sub;
+
+import javax.inject.Inject;
+
+class PackagePrivate {  
+  @Inject PackagePrivate() {}
+}
diff --git a/javatests/dagger/functional/sub/PackagePrivateContainer.java b/javatests/dagger/functional/sub/PackagePrivateContainer.java
new file mode 100644
index 000000000..f1b1033f9
--- /dev/null
+++ b/javatests/dagger/functional/sub/PackagePrivateContainer.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.sub;
+
+import javax.inject.Inject;
+
+class PackagePrivateContainer {  
+  public static class PublicEnclosed {
+    @Inject PublicEnclosed() {}
+  }
+}
diff --git a/javatests/dagger/functional/sub/PublicSubclass.java b/javatests/dagger/functional/sub/PublicSubclass.java
new file mode 100644
index 000000000..2ccd42ab3
--- /dev/null
+++ b/javatests/dagger/functional/sub/PublicSubclass.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.sub;
+
+import dagger.functional.Generic;
+import javax.inject.Inject;
+
+public class PublicSubclass extends Generic<PackagePrivate> {
+  @Inject public PublicSubclass(PackagePrivate pp) {
+    super(pp);
+  }
+}
diff --git a/javatests/dagger/functional/sub/PublicSubclass2.java b/javatests/dagger/functional/sub/PublicSubclass2.java
new file mode 100644
index 000000000..3d5f42970
--- /dev/null
+++ b/javatests/dagger/functional/sub/PublicSubclass2.java
@@ -0,0 +1,26 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.sub;
+
+import dagger.functional.Generic;
+import javax.inject.Inject;
+
+public class PublicSubclass2 extends Generic<PackagePrivateContainer.PublicEnclosed> {
+  @Inject public PublicSubclass2(PackagePrivateContainer.PublicEnclosed pp) {
+    super(pp);
+  }
+}
diff --git a/javatests/dagger/functional/subcomponent/AnInterface.java b/javatests/dagger/functional/subcomponent/AnInterface.java
new file mode 100644
index 000000000..f0d9b4c48
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/AnInterface.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+interface AnInterface {
+}
diff --git a/javatests/dagger/functional/subcomponent/BoundAsSingleton.java b/javatests/dagger/functional/subcomponent/BoundAsSingleton.java
new file mode 100644
index 000000000..9d14465dc
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/BoundAsSingleton.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
+
+@Documented
+@Retention(RUNTIME)
+@Qualifier
+@interface BoundAsSingleton {}
diff --git a/javatests/dagger/functional/subcomponent/ChildAbstractClassComponent.java b/javatests/dagger/functional/subcomponent/ChildAbstractClassComponent.java
new file mode 100644
index 000000000..b9bcce22d
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/ChildAbstractClassComponent.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = {ChildModule.class, StaticChildModule.class})
+abstract class ChildAbstractClassComponent implements ChildComponent {
+}
diff --git a/javatests/dagger/functional/subcomponent/ChildComponent.java b/javatests/dagger/functional/subcomponent/ChildComponent.java
new file mode 100644
index 000000000..6d6fd8bd9
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/ChildComponent.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import dagger.Subcomponent;
+import java.util.Set;
+import javax.inject.Provider;
+
+@Subcomponent(modules = {ChildModule.class, StaticChildModule.class})
+interface ChildComponent {
+  Provider<UnscopedType> getUnscopedTypeProvider();
+
+  RequiresSingletons requiresSingleton();
+
+  Set<Object> objectSet();
+
+  GrandchildComponent newGrandchildComponent();
+  
+  Object object();
+}
diff --git a/javatests/dagger/functional/subcomponent/ChildComponentRequiringModules.java b/javatests/dagger/functional/subcomponent/ChildComponentRequiringModules.java
new file mode 100644
index 000000000..29b60e2c7
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/ChildComponentRequiringModules.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = {
+    ChildModule.class,
+    ChildModuleWithParameters.class,
+    ChildModuleWithState.class})
+interface ChildComponentRequiringModules {
+  int getInt();
+}
diff --git a/javatests/dagger/functional/subcomponent/ChildModule.java b/javatests/dagger/functional/subcomponent/ChildModule.java
new file mode 100644
index 000000000..f11cefc56
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/ChildModule.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.IntoSet;
+
+@Module
+final class ChildModule {
+  @Provides
+  @IntoSet
+  static Object provideUnscopedObject() {
+    return new Object() {
+      @Override public String toString() {
+        return "unscoped in child";
+      }
+    };
+  }
+}
diff --git a/javatests/dagger/functional/subcomponent/ChildModuleWithParameters.java b/javatests/dagger/functional/subcomponent/ChildModuleWithParameters.java
new file mode 100644
index 000000000..17f8471f0
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/ChildModuleWithParameters.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import dagger.Module;
+
+/**
+ * This is a module that can't be constructed with a default constructor.
+ */
+@Module
+final class ChildModuleWithParameters {
+  public ChildModuleWithParameters(@SuppressWarnings("unused") Object whatever) {}
+}
diff --git a/javatests/dagger/functional/subcomponent/ChildModuleWithState.java b/javatests/dagger/functional/subcomponent/ChildModuleWithState.java
new file mode 100644
index 000000000..49b266c9a
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/ChildModuleWithState.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import dagger.Module;
+import dagger.Provides;
+
+/**
+ * This is a module that can be constructed with a default constructor, but has state, so callers
+ * might want to pass a reference anyway.
+ */
+@Module
+final class ChildModuleWithState {
+  private int i = 0;
+
+  @Provides int provideInt() {
+    return i++;
+  }
+}
diff --git a/javatests/dagger/functional/subcomponent/GenericParentComponent.java b/javatests/dagger/functional/subcomponent/GenericParentComponent.java
new file mode 100644
index 000000000..f49083b76
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/GenericParentComponent.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+interface GenericParentComponent<B> {  
+  B subcomponent();
+}
diff --git a/javatests/dagger/functional/subcomponent/GrandchildComponent.java b/javatests/dagger/functional/subcomponent/GrandchildComponent.java
new file mode 100644
index 000000000..5a1b7720c
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/GrandchildComponent.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import dagger.Subcomponent;
+import java.util.Set;
+import javax.inject.Provider;
+
+@Subcomponent(modules = GrandchildModule.class)
+interface GrandchildComponent {
+  Provider<UnscopedType> getUnscopedTypeProvider();
+
+  RequiresSingletons requiresSingleton();
+
+  Set<Object> objectSet();
+
+  NeedsAnInterface needsAnInterface();
+}
diff --git a/javatests/dagger/functional/subcomponent/GrandchildModule.java b/javatests/dagger/functional/subcomponent/GrandchildModule.java
new file mode 100644
index 000000000..c61accf81
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/GrandchildModule.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import dagger.Binds;
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.IntoSet;
+
+@Module
+abstract class GrandchildModule {
+  @Provides
+  @IntoSet
+  static Object provideUnscopedObject() {
+    return new Object() {
+      @Override public String toString() {
+        return "unscoped in grandchild";
+      }
+    };
+  }
+
+  @Binds
+  abstract AnInterface provideAnInterface(ImplementsAnInterface implementsAnInterface);
+
+  @Provides
+  static NeedsAnInterface provideNeedsAnInterface(AnInterface anInterface) {
+    return new NeedsAnInterface(anInterface);
+  }
+}
diff --git a/javatests/dagger/functional/subcomponent/ImplementsAnInterface.java b/javatests/dagger/functional/subcomponent/ImplementsAnInterface.java
new file mode 100644
index 000000000..a07025cd1
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/ImplementsAnInterface.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import javax.inject.Inject;
+
+class ImplementsAnInterface implements AnInterface {
+  @Inject ImplementsAnInterface() {}
+}
+
diff --git a/javatests/dagger/functional/subcomponent/ModuleWithSubcomponentsTest.java b/javatests/dagger/functional/subcomponent/ModuleWithSubcomponentsTest.java
new file mode 100644
index 000000000..06beae14d
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/ModuleWithSubcomponentsTest.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.Module;
+import dagger.functional.subcomponent.UsesModuleSubcomponents.ParentIncludesSubcomponentTransitively;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for {@link Module#subcomponents()}. */
+@RunWith(JUnit4.class)
+public class ModuleWithSubcomponentsTest {
+
+  @Test
+  public void subcomponentFromModules() {
+    UsesModuleSubcomponents parent = DaggerUsesModuleSubcomponents.create();
+    assertThat(parent.strings()).containsExactly("from parent");
+    assertThat(parent.usesChild().strings).containsExactly("from parent", "from child");
+  }
+
+  @Test
+  public void subcomponentFromModules_transitively() {
+    ParentIncludesSubcomponentTransitively parent =
+        DaggerUsesModuleSubcomponents_ParentIncludesSubcomponentTransitively.create();
+    assertThat(parent.strings()).containsExactly("from parent");
+    assertThat(parent.usesChild().strings).containsExactly("from parent", "from child");
+  }
+}
diff --git a/javatests/dagger/functional/subcomponent/MultibindingSubcomponents.java b/javatests/dagger/functional/subcomponent/MultibindingSubcomponents.java
new file mode 100644
index 000000000..99597711f
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/MultibindingSubcomponents.java
@@ -0,0 +1,254 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import dagger.Binds;
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+import dagger.multibindings.StringKey;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+import javax.inject.Inject;
+
+final class MultibindingSubcomponents {
+
+  /** Multibindings for this type are bound only in the parent component. */
+  enum BoundInParent {
+    INSTANCE;
+  }
+
+  /** Multibindings for this type are bound only in the child component. */
+  enum BoundInChild {
+    INSTANCE;
+  }
+
+  /** Multibindings for this type are bound in the parent component and the child component. */
+  enum BoundInParentAndChild {
+    IN_PARENT,
+    IN_CHILD;
+  }
+
+  static final class RequiresMultibindings<T> {
+    private final Set<T> set;
+    private final Map<String, T> map;
+
+    @Inject
+    RequiresMultibindings(Set<T> set, Map<String, T> map) {
+      this.set = set;
+      this.map = map;
+    }
+
+    Set<T> set() {
+      return set;
+    }
+
+    Map<String, T> map() {
+      return map;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+      return obj instanceof RequiresMultibindings<?>
+          && set.equals(((RequiresMultibindings<?>) obj).set)
+          && map.equals(((RequiresMultibindings<?>) obj).map);
+    }
+
+    @Override
+    public int hashCode() {
+      return Objects.hash(set, map);
+    }
+
+    @Override
+    public String toString() {
+      return String.format(
+          "%s{set=%s, map=%s}", RequiresMultibindings.class.getSimpleName(), set, map);
+    }
+  }
+
+  @Module
+  abstract static class ParentMultibindingModule {
+
+    @Provides
+    @IntoSet
+    static BoundInParent onlyInParentElement() {
+      return BoundInParent.INSTANCE;
+    }
+
+    @Provides
+    @IntoMap
+    @StringKey("parent key")
+    static BoundInParent onlyInParentEntry() {
+      return BoundInParent.INSTANCE;
+    }
+
+    @Provides
+    @IntoSet
+    static BoundInParentAndChild inParentAndChildElement() {
+      return BoundInParentAndChild.IN_PARENT;
+    }
+
+    @Provides
+    @IntoMap
+    @StringKey("parent key")
+    static BoundInParentAndChild inParentAndChildEntry() {
+      return BoundInParentAndChild.IN_PARENT;
+    }
+
+    /* This is not static because otherwise we have no tests that cover the case where a
+     * subcomponent uses a module instance installed onto a parent component. */
+    @Binds
+    @IntoSet
+    abstract RequiresMultibindings<BoundInParentAndChild>
+        requiresMultibindingsInParentAndChildElement(
+            RequiresMultibindings<BoundInParentAndChild> requiresMultibindingsInParentAndChild);
+  }
+
+  @Module
+  static final class ChildMultibindingModule {
+
+    @Provides
+    @IntoSet
+    static BoundInParentAndChild inParentAndChildElement() {
+      return BoundInParentAndChild.IN_CHILD;
+    }
+
+    @Provides
+    @IntoMap
+    @StringKey("child key")
+    static BoundInParentAndChild inParentAndChildEntry() {
+      return BoundInParentAndChild.IN_CHILD;
+    }
+
+    @Provides
+    @IntoSet
+    static BoundInChild onlyInChildElement() {
+      return BoundInChild.INSTANCE;
+    }
+
+    @Provides
+    @IntoMap
+    @StringKey("child key")
+    static BoundInChild onlyInChildEntry() {
+      return BoundInChild.INSTANCE;
+    }
+  }
+
+  @Module
+  abstract static class ChildMultibindingModuleWithOnlyBindsMultibindings {
+    @Provides
+    static BoundInParentAndChild provideBoundInParentAndChildForBinds() {
+      return BoundInParentAndChild.IN_CHILD;
+    }
+
+    @Binds
+    @IntoSet
+    abstract BoundInParentAndChild bindsLocalContribution(BoundInParentAndChild instance);
+
+    @Binds
+    @IntoMap
+    @StringKey("child key")
+    abstract BoundInParentAndChild inParentAndChildEntry(BoundInParentAndChild instance);
+
+    @Provides
+    static BoundInChild provideBoundInChildForBinds() {
+      return BoundInChild.INSTANCE;
+    }
+
+    @Binds
+    @IntoSet
+    abstract BoundInChild inChild(BoundInChild instance);
+
+    @Binds
+    @IntoMap
+    @StringKey("child key")
+    abstract BoundInChild inChildEntry(BoundInChild instance);
+  }
+
+  interface ProvidesBoundInParent {
+    RequiresMultibindings<BoundInParent> requiresMultibindingsBoundInParent();
+  }
+
+  interface ProvidesBoundInChild {
+    RequiresMultibindings<BoundInChild> requiresMultibindingsBoundInChild();
+  }
+
+  interface ProvidesBoundInParentAndChild {
+    RequiresMultibindings<BoundInParentAndChild> requiresMultibindingsBoundInParentAndChild();
+  }
+
+  interface ProvidesSetOfRequiresMultibindings {
+    Set<RequiresMultibindings<BoundInParentAndChild>> setOfRequiresMultibindingsInParentAndChild();
+  }
+
+  interface ParentWithProvision
+      extends ProvidesBoundInParent, ProvidesBoundInParentAndChild,
+          ProvidesSetOfRequiresMultibindings {}
+
+  interface HasChildWithProvision {
+    ChildWithProvision childWithProvision();
+  }
+
+  interface HasChildWithoutProvision {
+    ChildWithoutProvision childWithoutProvision();
+  }
+
+  @Component(modules = ParentMultibindingModule.class)
+  interface ParentWithoutProvisionHasChildWithoutProvision extends HasChildWithoutProvision {}
+
+  @Component(modules = ParentMultibindingModule.class)
+  interface ParentWithoutProvisionHasChildWithProvision extends HasChildWithProvision {}
+
+  @Component(modules = ParentMultibindingModule.class)
+  interface ParentWithProvisionHasChildWithoutProvision
+      extends ParentWithProvision, HasChildWithoutProvision {}
+
+  @Component(modules = ParentMultibindingModule.class)
+  interface ParentWithProvisionHasChildWithProvision
+      extends ParentWithProvision, HasChildWithProvision {}
+
+  @Subcomponent(modules = ChildMultibindingModule.class)
+  interface ChildWithoutProvision {
+    Grandchild grandchild();
+  }
+
+  @Subcomponent(modules = ChildMultibindingModule.class)
+  interface ChildWithProvision
+      extends ProvidesBoundInParent, ProvidesBoundInParentAndChild, ProvidesBoundInChild,
+          ProvidesSetOfRequiresMultibindings {
+
+    Grandchild grandchild();
+  }
+
+  @Subcomponent
+  interface Grandchild
+      extends ProvidesBoundInParent, ProvidesBoundInParentAndChild, ProvidesBoundInChild,
+          ProvidesSetOfRequiresMultibindings {}
+
+  @Component(modules = ParentMultibindingModule.class)
+  interface ParentWithProvisionHasChildWithBinds extends ParentWithProvision {
+    ChildWithBinds childWithBinds();
+  }
+
+  @Subcomponent(modules = ChildMultibindingModuleWithOnlyBindsMultibindings.class)
+  interface ChildWithBinds extends ChildWithProvision {}
+
+}
diff --git a/javatests/dagger/functional/subcomponent/NeedsAnInterface.java b/javatests/dagger/functional/subcomponent/NeedsAnInterface.java
new file mode 100644
index 000000000..3efbad7af
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/NeedsAnInterface.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+class NeedsAnInterface {
+  NeedsAnInterface(@SuppressWarnings("unused") AnInterface anInterface) {}
+}
diff --git a/javatests/dagger/functional/subcomponent/ParentComponent.java b/javatests/dagger/functional/subcomponent/ParentComponent.java
new file mode 100644
index 000000000..4c0b60806
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/ParentComponent.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import dagger.Component;
+import dagger.functional.SomeQualifier;
+import javax.inject.Singleton;
+
+@Component(modules = {ParentModule.class, UnresolvableChildComponentModule.class})
+@Singleton
+interface ParentComponent extends ParentGetters {
+  ChildComponent newChildComponent();
+
+  ChildAbstractClassComponent newChildAbstractClassComponent();
+
+  ChildComponentRequiringModules newChildComponentRequiringModules(
+      ChildModuleWithParameters cmwp,
+      ChildModuleWithState childModuleWithState);
+
+  /**
+   * Requests a qualified version of this subcomponent builder, which does not install it as a
+   * subcomponent, but instead, uses the explicit binding of this qualified builder.
+   */
+  @SomeQualifier UnresolvableChildComponent.Builder unresolvableChildComponentBuilder();
+}
diff --git a/javatests/dagger/functional/subcomponent/ParentGetters.java b/javatests/dagger/functional/subcomponent/ParentGetters.java
new file mode 100644
index 000000000..928bff29a
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/ParentGetters.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import java.util.Set;
+import javax.inject.Provider;
+
+interface ParentGetters {
+  Provider<UnscopedType> getUnscopedTypeProvider();
+
+  Set<Object> objectSet();
+
+}
diff --git a/javatests/dagger/functional/subcomponent/ParentModule.java b/javatests/dagger/functional/subcomponent/ParentModule.java
new file mode 100644
index 000000000..8ce4b87e2
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/ParentModule.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import dagger.Binds;
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.IntoSet;
+import javax.inject.Singleton;
+
+@Module
+abstract class ParentModule {
+  @Provides
+  @IntoSet
+  static Object provideUnscopedObject() {
+    return new Object() {
+      @Override public String toString() {
+        return "unscoped in parent";
+      }
+    };
+  }
+
+  @Provides
+  @IntoSet
+  @Singleton
+  static Object provideSingletonObject() {
+    return new Object() {
+      @Override public String toString() {
+        return "singleton";
+      }
+    };
+  }
+
+  @Binds
+  @Singleton
+  @BoundAsSingleton
+  abstract UnscopedType provideUnscopedTypeBoundAsSingleton(UnscopedType unscopedType);
+}
diff --git a/javatests/dagger/functional/subcomponent/ParentOfGenericComponent.java b/javatests/dagger/functional/subcomponent/ParentOfGenericComponent.java
new file mode 100644
index 000000000..cc701f45e
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/ParentOfGenericComponent.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import dagger.Component;
+import javax.inject.Singleton;
+
+@Component(modules = ParentModule.class)
+@Singleton
+interface ParentOfGenericComponent extends GenericParentComponent<ChildComponent>, ParentGetters {
+}
diff --git a/javatests/dagger/functional/subcomponent/RequiresSingletons.java b/javatests/dagger/functional/subcomponent/RequiresSingletons.java
new file mode 100644
index 000000000..8dc9b3d26
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/RequiresSingletons.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import javax.inject.Inject;
+
+final class RequiresSingletons {
+  private final SingletonType singletonType;
+  private final UnscopedType unscopedTypeBoundAsSingleton;
+
+  @Inject RequiresSingletons(SingletonType singletonType,
+      @BoundAsSingleton UnscopedType unscopedTypeBoundAsSingleton) {
+    this.singletonType = singletonType;
+    this.unscopedTypeBoundAsSingleton = unscopedTypeBoundAsSingleton;
+  }
+
+  SingletonType singletonType() {
+    return singletonType;
+  }
+
+  UnscopedType unscopedTypeBoundAsSingleton() {
+    return unscopedTypeBoundAsSingleton;
+  }
+}
diff --git a/javatests/dagger/functional/subcomponent/SingletonType.java b/javatests/dagger/functional/subcomponent/SingletonType.java
new file mode 100644
index 000000000..9a6da6c5c
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/SingletonType.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+@Singleton
+final class SingletonType {
+  @Inject SingletonType() {}
+}
diff --git a/javatests/dagger/functional/subcomponent/StaticChildModule.java b/javatests/dagger/functional/subcomponent/StaticChildModule.java
new file mode 100644
index 000000000..fcd0cd55c
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/StaticChildModule.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+final class StaticChildModule {
+  private StaticChildModule() {}
+  
+  @Provides static Object provideStaticObject() {
+    return "static";
+  }
+}
diff --git a/javatests/dagger/functional/subcomponent/SubcomponentFromModuleAndFactoryMethod.java b/javatests/dagger/functional/subcomponent/SubcomponentFromModuleAndFactoryMethod.java
new file mode 100644
index 000000000..b8b880698
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/SubcomponentFromModuleAndFactoryMethod.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Subcomponent;
+
+/**
+ * Tests for {@link Subcomponent}s which are defined with {@link Module#subcomponents()} and are
+ * also requested as component factory methods.
+ */
+public class SubcomponentFromModuleAndFactoryMethod {
+  @Subcomponent
+  interface Sub {
+    @Subcomponent.Builder
+    interface Builder {
+      Sub sub();
+    }
+  }
+
+  @Module(subcomponents = Sub.class)
+  class ModuleWithSubcomponent {}
+
+  @Component(modules = ModuleWithSubcomponent.class)
+  interface ExposesBuilder {
+    Sub.Builder subcomponentBuilder();
+  }
+}
diff --git a/javatests/dagger/functional/subcomponent/SubcomponentMultibindingsTest.java b/javatests/dagger/functional/subcomponent/SubcomponentMultibindingsTest.java
new file mode 100644
index 000000000..eeadbeb4d
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/SubcomponentMultibindingsTest.java
@@ -0,0 +1,282 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSet;
+import dagger.functional.subcomponent.MultibindingSubcomponents.BoundInChild;
+import dagger.functional.subcomponent.MultibindingSubcomponents.BoundInParent;
+import dagger.functional.subcomponent.MultibindingSubcomponents.BoundInParentAndChild;
+import dagger.functional.subcomponent.MultibindingSubcomponents.ParentWithProvisionHasChildWithProvision;
+import dagger.functional.subcomponent.MultibindingSubcomponents.ParentWithProvisionHasChildWithoutProvision;
+import dagger.functional.subcomponent.MultibindingSubcomponents.ParentWithoutProvisionHasChildWithProvision;
+import dagger.functional.subcomponent.MultibindingSubcomponents.ParentWithoutProvisionHasChildWithoutProvision;
+import dagger.functional.subcomponent.MultibindingSubcomponents.RequiresMultibindings;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class SubcomponentMultibindingsTest {
+
+  private static final RequiresMultibindings<BoundInParent> BOUND_IN_PARENT =
+      new RequiresMultibindings<>(
+          ImmutableSet.of(BoundInParent.INSTANCE),
+          ImmutableMap.of("parent key", BoundInParent.INSTANCE));
+
+  private static final RequiresMultibindings<BoundInChild> BOUND_IN_CHILD =
+      new RequiresMultibindings<>(
+          ImmutableSet.of(BoundInChild.INSTANCE),
+          ImmutableMap.of("child key", BoundInChild.INSTANCE));
+
+  private static final RequiresMultibindings<BoundInParentAndChild> BOUND_IN_PARENT_AND_CHILD =
+      new RequiresMultibindings<>(
+          ImmutableSet.of(BoundInParentAndChild.IN_PARENT, BoundInParentAndChild.IN_CHILD),
+          ImmutableMap.of(
+              "parent key", BoundInParentAndChild.IN_PARENT,
+              "child key", BoundInParentAndChild.IN_CHILD));
+
+  private static final RequiresMultibindings<BoundInParentAndChild>
+      BOUND_IN_PARENT_AND_CHILD_PROVIDED_BY_PARENT =
+          new RequiresMultibindings<>(
+              ImmutableSet.of(BoundInParentAndChild.IN_PARENT),
+              ImmutableMap.of("parent key", BoundInParentAndChild.IN_PARENT));
+
+  private ParentWithoutProvisionHasChildWithoutProvision
+      parentWithoutProvisionHasChildWithoutProvision;
+  private ParentWithoutProvisionHasChildWithProvision parentWithoutProvisionHasChildWithProvision;
+  private ParentWithProvisionHasChildWithoutProvision parentWithProvisionHasChildWithoutProvision;
+  private ParentWithProvisionHasChildWithProvision parentWithProvisionHasChildWithProvision;
+
+  @Before
+  public void setUp() {
+    parentWithoutProvisionHasChildWithoutProvision =
+        DaggerMultibindingSubcomponents_ParentWithoutProvisionHasChildWithoutProvision.create();
+    parentWithoutProvisionHasChildWithProvision =
+        DaggerMultibindingSubcomponents_ParentWithoutProvisionHasChildWithProvision.create();
+    parentWithProvisionHasChildWithoutProvision =
+        DaggerMultibindingSubcomponents_ParentWithProvisionHasChildWithoutProvision.create();
+    parentWithProvisionHasChildWithProvision =
+        DaggerMultibindingSubcomponents_ParentWithProvisionHasChildWithProvision.create();
+  }
+
+  @Test
+  public void testParentWithoutProvisionHasChildWithoutProvision() {
+    // Child
+    assertThat(
+            parentWithoutProvisionHasChildWithoutProvision
+                .childWithoutProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInParent())
+        .isEqualTo(BOUND_IN_PARENT);
+
+    // Grandchild
+    assertThat(
+            parentWithoutProvisionHasChildWithoutProvision
+                .childWithoutProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInParentAndChild())
+        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
+    assertThat(
+            parentWithoutProvisionHasChildWithoutProvision
+                .childWithoutProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInChild())
+        .isEqualTo(BOUND_IN_CHILD);
+
+    /*
+     * Even though the multibinding for Set<RequiresMultiboundObjects> does not itself have a
+     * contribution from the child, it must be pushed down to (not duplicated in) the child because
+     * its contribution depends on multibindings that have one contribution from the parent and one
+     * from the child.
+     *
+     */
+    assertThat(
+            parentWithoutProvisionHasChildWithoutProvision
+                .childWithoutProvision()
+                .grandchild()
+                .setOfRequiresMultibindingsInParentAndChild())
+        .containsExactly(BOUND_IN_PARENT_AND_CHILD);
+  }
+
+  @Test
+  public void testParentWithoutProvisionHasChildWithProvision() {
+    // Child
+    assertThat(
+            parentWithoutProvisionHasChildWithProvision
+                .childWithProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInParent())
+        .isEqualTo(BOUND_IN_PARENT);
+
+    // Grandchild
+    assertThat(
+            parentWithoutProvisionHasChildWithProvision
+                .childWithProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInParentAndChild())
+        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
+    assertThat(
+            parentWithoutProvisionHasChildWithProvision
+                .childWithProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInChild())
+        .isEqualTo(BOUND_IN_CHILD);
+
+    /*
+     * Even though the multibinding for Set<RequiresMultiboundObjects> does not itself have a
+     * contribution from the child, it must be pushed down to (not duplicated in) the child because
+     * its contribution depends on multibindings that have one contribution from the parent and one
+     * from the child.
+     *
+     */
+    assertThat(
+            parentWithoutProvisionHasChildWithProvision
+                .childWithProvision()
+                .grandchild()
+                .setOfRequiresMultibindingsInParentAndChild())
+        .containsExactly(BOUND_IN_PARENT_AND_CHILD);
+  }
+
+  @Test
+  public void testParentWithProvisionHasChildWithoutProvision() {
+    // Parent
+    assertThat(parentWithProvisionHasChildWithoutProvision.requiresMultibindingsBoundInParent())
+        .isEqualTo(BOUND_IN_PARENT);
+
+    assertThat(
+            parentWithProvisionHasChildWithoutProvision
+                .requiresMultibindingsBoundInParentAndChild())
+        .isEqualTo(BOUND_IN_PARENT_AND_CHILD_PROVIDED_BY_PARENT);
+
+    // Grandchild
+    assertThat(
+            parentWithProvisionHasChildWithoutProvision
+                .childWithoutProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInParent())
+        .isEqualTo(BOUND_IN_PARENT);
+    assertThat(
+            parentWithProvisionHasChildWithoutProvision
+                .childWithoutProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInChild())
+        .isEqualTo(BOUND_IN_CHILD);
+
+    assertThat(
+            parentWithProvisionHasChildWithoutProvision
+                .childWithoutProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInParentAndChild())
+        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
+
+    /*
+     * Even though the multibinding for Set<RequiresMultiboundObjects> does not itself have a
+     * contribution from the child, it must be pushed down to (not duplicated in) the child because
+     * its contribution depends on multibindings that have one contribution from the parent and one
+     * from the child.
+     *
+     */
+    assertThat(
+            parentWithProvisionHasChildWithoutProvision
+                .childWithoutProvision()
+                .grandchild()
+                .setOfRequiresMultibindingsInParentAndChild())
+        .containsExactly(BOUND_IN_PARENT_AND_CHILD);
+  }
+
+  @Test
+  public void testParentWithProvisionHasChildWithProvision() {
+    // Parent
+    assertThat(parentWithProvisionHasChildWithProvision.requiresMultibindingsBoundInParent())
+        .isEqualTo(BOUND_IN_PARENT);
+
+    // Child
+    assertThat(
+            parentWithProvisionHasChildWithProvision
+                .childWithProvision()
+                .requiresMultibindingsBoundInParent())
+        .isEqualTo(BOUND_IN_PARENT);
+    assertThat(
+            parentWithProvisionHasChildWithProvision
+                .childWithProvision()
+                .requiresMultibindingsBoundInChild())
+        .isEqualTo(BOUND_IN_CHILD);
+    assertThat(
+            parentWithProvisionHasChildWithProvision
+                .childWithProvision()
+                .requiresMultibindingsBoundInParentAndChild())
+        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
+
+    // https://github.com/google/dagger/issues/401
+    assertThat(
+        DaggerMultibindingSubcomponents_ParentWithProvisionHasChildWithBinds.create()
+            .childWithBinds()
+            .requiresMultibindingsBoundInParentAndChild())
+        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
+
+    /*
+     * Even though the multibinding for Set<RequiresMultiboundObjects> does not itself have a
+     * contribution from the child, it must be pushed down to (not duplicated in) the child because
+     * its contribution depends on multibindings that have one contribution from the parent and one
+     * from the child.
+     *
+     */
+    assertThat(
+            parentWithProvisionHasChildWithProvision
+                .childWithProvision()
+                .setOfRequiresMultibindingsInParentAndChild())
+        .containsExactly(BOUND_IN_PARENT_AND_CHILD);
+
+    // Grandchild
+    assertThat(
+            parentWithProvisionHasChildWithProvision
+                .childWithProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInParent())
+        .isEqualTo(BOUND_IN_PARENT);
+    assertThat(
+            parentWithProvisionHasChildWithProvision
+                .childWithProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInChild())
+        .isEqualTo(BOUND_IN_CHILD);
+    assertThat(
+            parentWithProvisionHasChildWithProvision
+                .childWithProvision()
+                .grandchild()
+                .requiresMultibindingsBoundInParentAndChild())
+        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);
+
+    /*
+     * Even though the multibinding for Set<RequiresMultiboundObjects> does not itself have a
+     * contribution from the child, it must be pushed down to (not duplicated in) the child because
+     * its contribution depends on multibindings that have one contribution from the parent and one
+     * from the child.
+     *
+     */
+    assertThat(
+            parentWithProvisionHasChildWithProvision
+                .childWithProvision()
+                .grandchild()
+                .setOfRequiresMultibindingsInParentAndChild())
+        .containsExactly(BOUND_IN_PARENT_AND_CHILD);
+  }
+}
diff --git a/javatests/dagger/functional/subcomponent/SubcomponentTest.java b/javatests/dagger/functional/subcomponent/SubcomponentTest.java
new file mode 100644
index 000000000..68d19d3a7
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/SubcomponentTest.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import static com.google.common.collect.Sets.intersection;
+import static com.google.common.truth.Truth.assertThat;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Set;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+@RunWith(Parameterized.class)
+public class SubcomponentTest {
+  private static final ParentComponent parentComponent = DaggerParentComponent.create();
+  private static final ParentOfGenericComponent parentOfGenericComponent =
+      DaggerParentOfGenericComponent.create();
+  
+  @Parameters
+  public static Collection<Object[]> parameters() {
+    return Arrays.asList(new Object[][] {
+        { parentComponent, parentComponent.newChildComponent() },
+        { parentComponent, parentComponent.newChildAbstractClassComponent() },
+        { parentOfGenericComponent, parentOfGenericComponent.subcomponent() }});
+  }        
+  
+  private final ParentGetters parentGetters;
+  private final ChildComponent childComponent;
+  
+  public SubcomponentTest(ParentGetters parentGetters, ChildComponent childComponent) {
+    this.parentGetters = parentGetters;
+    this.childComponent = childComponent;
+  }
+  
+
+  @Test
+  public void scopePropagatesUpward_class() {
+    assertThat(childComponent.requiresSingleton().singletonType())
+        .isSameAs(childComponent.requiresSingleton().singletonType());
+    assertThat(childComponent.requiresSingleton().singletonType())
+        .isSameAs(childComponent.newGrandchildComponent().requiresSingleton().singletonType());
+  }
+
+  @Test
+  public void scopePropagatesUpward_provides() {
+    assertThat(childComponent
+        .requiresSingleton().unscopedTypeBoundAsSingleton())
+            .isSameAs(childComponent
+                .requiresSingleton().unscopedTypeBoundAsSingleton());
+    assertThat(childComponent
+        .requiresSingleton().unscopedTypeBoundAsSingleton())
+            .isSameAs(childComponent.newGrandchildComponent()
+                .requiresSingleton().unscopedTypeBoundAsSingleton());
+  }
+
+  @Test
+  public void multibindingContributions() {
+    Set<Object> parentObjectSet = parentGetters.objectSet();
+    assertThat(parentObjectSet).hasSize(2);
+    Set<Object> childObjectSet = childComponent.objectSet();
+    assertThat(childObjectSet).hasSize(3);
+    Set<Object> grandchildObjectSet =
+        childComponent.newGrandchildComponent().objectSet();
+    assertThat(grandchildObjectSet).hasSize(4);
+    assertThat(intersection(parentObjectSet, childObjectSet)).hasSize(1);
+    assertThat(intersection(parentObjectSet, grandchildObjectSet)).hasSize(1);
+    assertThat(intersection(childObjectSet, grandchildObjectSet)).hasSize(1);
+  }
+
+  @Test
+  public void unscopedProviders() {
+    assertThat(parentGetters.getUnscopedTypeProvider())
+        .isSameAs(childComponent.getUnscopedTypeProvider());
+    assertThat(parentGetters.getUnscopedTypeProvider())
+        .isSameAs(childComponent
+            .newGrandchildComponent()
+            .getUnscopedTypeProvider());
+  }
+
+  @Test
+  public void passedModules() {
+    ChildModuleWithState childModuleWithState = new ChildModuleWithState();
+    ChildComponentRequiringModules childComponent1 =
+        parentComponent.newChildComponentRequiringModules(
+            new ChildModuleWithParameters(new Object()),
+            childModuleWithState);
+    ChildComponentRequiringModules childComponent2 =
+        parentComponent.newChildComponentRequiringModules(
+            new ChildModuleWithParameters(new Object()),
+            childModuleWithState);
+    assertThat(childComponent1.getInt()).isEqualTo(0);
+    assertThat(childComponent2.getInt()).isEqualTo(1);
+  }
+
+  @Test
+  public void dependenceisInASubcomponent() {
+    assertThat(childComponent.newGrandchildComponent().needsAnInterface()).isNotNull();
+  }
+
+  @Test
+  public void qualifiedSubcomponentIsBound() {
+    assertThat(parentComponent.unresolvableChildComponentBuilder().build().unboundString())
+        .isEqualTo("unbound");
+  }
+}
diff --git a/javatests/dagger/functional/subcomponent/Unbound.java b/javatests/dagger/functional/subcomponent/Unbound.java
new file mode 100644
index 000000000..ae8062180
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/Unbound.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.Retention;
+import javax.inject.Qualifier;
+
+/**
+ * A qualifier representing an unbound type, to verify that the compiler does not attempt to
+ * generate code depending on it.
+ */
+@Documented
+@Retention(RUNTIME)
+@Qualifier
+@interface Unbound {}
diff --git a/javatests/dagger/functional/subcomponent/UnresolvableChildComponent.java b/javatests/dagger/functional/subcomponent/UnresolvableChildComponent.java
new file mode 100644
index 000000000..57d9d0dbf
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/UnresolvableChildComponent.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import dagger.Subcomponent;
+
+/**
+ * A subcomponent that's not resolvable in any parent component, for testing that qualified methods
+ * on components that return subcomponents do not trigger actual subcomponents.
+ */
+@Subcomponent
+interface UnresolvableChildComponent {
+  /**
+   * Requests a type that is never bound in any component that this subcomponent might be installed
+   * in. If this subcomponent is ever attempted to be installed in a component, then it will produce
+   * a compiler error.
+   */
+  @Unbound
+  String unboundString();
+
+  @Subcomponent.Builder
+  interface Builder {
+    UnresolvableChildComponent build();
+  }
+}
diff --git a/javatests/dagger/functional/subcomponent/UnresolvableChildComponentModule.java b/javatests/dagger/functional/subcomponent/UnresolvableChildComponentModule.java
new file mode 100644
index 000000000..613e7e355
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/UnresolvableChildComponentModule.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import dagger.Module;
+import dagger.Provides;
+import dagger.functional.SomeQualifier;
+
+@Module
+final class UnresolvableChildComponentModule {
+  /**
+   * Provides a qualified version of the {@link UnresolvableChildComponent}'s builder. If the
+   * subcomponent were actually installed in a component, this would be a duplicate binding; but
+   * since that doesn't happen, this binding is OK.
+   */
+  @Provides
+  @SomeQualifier
+  static UnresolvableChildComponent.Builder unresolvableChildComponentBuilder() {
+    return new UnresolvableChildComponent.Builder() {
+      @Override
+      public UnresolvableChildComponent build() {
+        return new UnresolvableChildComponent() {
+          @Override
+          public String unboundString() {
+            return "unbound";
+          }
+        };
+      }
+    };
+  }
+}
diff --git a/javatests/dagger/functional/subcomponent/UnscopedType.java b/javatests/dagger/functional/subcomponent/UnscopedType.java
new file mode 100644
index 000000000..c16745778
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/UnscopedType.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import javax.inject.Inject;
+
+final class UnscopedType {
+  @Inject UnscopedType(@SuppressWarnings("unused") SingletonType singletonType) {}
+}
diff --git a/javatests/dagger/functional/subcomponent/UsesModuleSubcomponents.java b/javatests/dagger/functional/subcomponent/UsesModuleSubcomponents.java
new file mode 100644
index 000000000..bd240af66
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/UsesModuleSubcomponents.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.multibindings.IntoSet;
+import java.util.Set;
+import javax.inject.Inject;
+
+/** Supporting types for {@link ModuleWithSubcomponentsTest}. */
+@Component(modules = UsesModuleSubcomponents.ModuleWithSubcomponents.class)
+public interface UsesModuleSubcomponents {
+  UsesChild usesChild();
+
+  Set<String> strings();
+
+  @Module(subcomponents = Child.class, includes = AlsoIncludesSubcomponents.class)
+  class ModuleWithSubcomponents {
+    @Provides
+    @IntoSet
+    static String provideStringInParent() {
+      return "from parent";
+    }
+  }
+
+  @Module(subcomponents = Child.class)
+  class AlsoIncludesSubcomponents {}
+
+  @Subcomponent(modules = ChildModule.class)
+  interface Child {
+    Set<String> strings();
+
+    @Subcomponent.Builder
+    interface Builder {
+      Child build();
+    }
+  }
+
+  @Module
+  class ChildModule {
+    @Provides
+    @IntoSet
+    static String provideStringInChild() {
+      return "from child";
+    }
+  }
+
+  class UsesChild {
+    Set<String> strings;
+
+    @Inject
+    UsesChild(Child.Builder childBuilder) {
+      this.strings = childBuilder.build().strings();
+    }
+  }
+
+  @Module(includes = ModuleWithSubcomponents.class)
+  class OnlyIncludesModuleWithSubcomponents {}
+
+  @Component(modules = OnlyIncludesModuleWithSubcomponents.class)
+  interface ParentIncludesSubcomponentTransitively extends UsesModuleSubcomponents {}
+
+}
diff --git a/javatests/dagger/functional/subcomponent/hiding/ChildComponent.java b/javatests/dagger/functional/subcomponent/hiding/ChildComponent.java
new file mode 100644
index 000000000..7cb4fcec5
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/hiding/ChildComponent.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent.hiding;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = dagger.functional.subcomponent.hiding.b.CommonModuleName.class)
+interface ChildComponent {
+  //ensure that t.s.h.a.CommonName gets bound in this component
+  dagger.functional.subcomponent.hiding.a.CommonName aCommonName();
+  //ensure that t.s.h.b.CommonName gets bound in this component
+  dagger.functional.subcomponent.hiding.b.CommonName bCommonName();
+}
diff --git a/javatests/dagger/functional/subcomponent/hiding/ParentComponent.java b/javatests/dagger/functional/subcomponent/hiding/ParentComponent.java
new file mode 100644
index 000000000..7458d82f9
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/hiding/ParentComponent.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent.hiding;
+
+import dagger.Component;
+import javax.inject.Singleton;
+
+@Component(modules = dagger.functional.subcomponent.hiding.a.CommonModuleName.class)
+@Singleton
+interface ParentComponent {
+  // ensure that t.s.h.a.CommonName gets bound in this component
+  dagger.functional.subcomponent.hiding.a.CommonName aCommonName();
+
+  ChildComponent newChildComponent();
+}
diff --git a/javatests/dagger/functional/subcomponent/hiding/SubcomponentHidingTest.java b/javatests/dagger/functional/subcomponent/hiding/SubcomponentHidingTest.java
new file mode 100644
index 000000000..398b8a701
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/hiding/SubcomponentHidingTest.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent.hiding;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class SubcomponentHidingTest {
+  @Test public void moduleNameHiding() {
+    ParentComponent parent = DaggerParentComponent.create();
+    assertThat(parent.aCommonName().toString()).isEqualTo("a");
+    assertThat(parent.newChildComponent().aCommonName().toString()).isEqualTo("a");
+    assertThat(parent.newChildComponent().bCommonName().toString()).isEqualTo("1");
+  }
+}
diff --git a/javatests/dagger/functional/subcomponent/hiding/a/CommonModuleName.java b/javatests/dagger/functional/subcomponent/hiding/a/CommonModuleName.java
new file mode 100644
index 000000000..d13446c25
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/hiding/a/CommonModuleName.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent.hiding.a;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+public class CommonModuleName {
+  @Provides String provideString() {
+    return "a";
+  }
+}
diff --git a/javatests/dagger/functional/subcomponent/hiding/a/CommonName.java b/javatests/dagger/functional/subcomponent/hiding/a/CommonName.java
new file mode 100644
index 000000000..567fc3941
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/hiding/a/CommonName.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent.hiding.a;
+
+import javax.inject.Inject;
+
+public final class CommonName {
+  private final String s;
+
+  @Inject CommonName(String s) {
+    this.s = s;
+  }
+
+  @Override
+  public String toString() {
+    return s;
+  }
+}
diff --git a/javatests/dagger/functional/subcomponent/hiding/b/CommonModuleName.java b/javatests/dagger/functional/subcomponent/hiding/b/CommonModuleName.java
new file mode 100644
index 000000000..b05356f86
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/hiding/b/CommonModuleName.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent.hiding.b;
+
+import dagger.Module;
+import dagger.Provides;
+
+@Module
+public class CommonModuleName {
+  @Provides int provideString() {
+    return 1;
+  }
+}
diff --git a/javatests/dagger/functional/subcomponent/hiding/b/CommonName.java b/javatests/dagger/functional/subcomponent/hiding/b/CommonName.java
new file mode 100644
index 000000000..1136f64e0
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/hiding/b/CommonName.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent.hiding.b;
+
+import javax.inject.Inject;
+
+public final class CommonName {
+  private final int i;
+
+  @Inject CommonName(int i) {
+    this.i = i;
+  }
+
+  @Override
+  public String toString() {
+    return Integer.toString(i);
+  }
+}
diff --git a/javatests/dagger/functional/subcomponent/pruning/ParentDoesntUseSubcomponent.java b/javatests/dagger/functional/subcomponent/pruning/ParentDoesntUseSubcomponent.java
new file mode 100644
index 000000000..516a52c10
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/pruning/ParentDoesntUseSubcomponent.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent.pruning;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.multibindings.IntoSet;
+import java.util.Set;
+import javax.inject.Qualifier;
+
+/**
+ * Supporting types for {@link SubcomponentOnlyRequestedBySiblingTest}. {@link ChildA} is a direct
+ * child of the top level component, but is only requested within its sibling, not directly from its
+ * parent.
+ */
+@Component(modules = ParentDoesntUseSubcomponent.ParentModule.class)
+interface ParentDoesntUseSubcomponent {
+
+  ChildB.Builder childBBuilder();
+
+  @Subcomponent(modules = ChildAModule.class)
+  interface ChildA {
+    @Subcomponent.Builder
+    interface Builder {
+      ChildA build();
+    }
+
+    Set<Class<?>> componentHierarchy();
+  }
+
+  @Subcomponent(modules = ChildBModule.class)
+  interface ChildB {
+    @Subcomponent.Builder
+    interface Builder {
+      ChildB build();
+    }
+
+    Set<Class<?>> componentHierarchy();
+
+    @FromChildA
+    Set<Class<?>> componentHierarchyFromChildA();
+  }
+
+  @Module(subcomponents = {ChildA.class, ChildB.class})
+  class ParentModule {
+    @Provides
+    @IntoSet
+    static Class<?> provideComponentType() {
+      return ParentDoesntUseSubcomponent.class;
+    }
+  }
+
+  @Module
+  class ChildAModule {
+    @Provides
+    @IntoSet
+    static Class<?> provideComponentType() {
+      return ChildA.class;
+    }
+  }
+
+  @Module
+  class ChildBModule {
+    @Provides
+    @IntoSet
+    static Class<?> provideComponentType() {
+      return ChildB.class;
+    }
+
+    @Provides
+    @FromChildA
+    Set<Class<?>> fromChildA(ChildA.Builder childABuilder) {
+      return childABuilder.build().componentHierarchy();
+    }
+  }
+
+  @Qualifier
+  @interface FromChildA {}
+}
diff --git a/javatests/dagger/functional/subcomponent/pruning/SubcomponentOnlyRequestedBySiblingTest.java b/javatests/dagger/functional/subcomponent/pruning/SubcomponentOnlyRequestedBySiblingTest.java
new file mode 100644
index 000000000..40a784aaf
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/pruning/SubcomponentOnlyRequestedBySiblingTest.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent.pruning;
+
+import static com.google.common.truth.Truth.assertThat;
+
+import dagger.Module;
+import dagger.Subcomponent;
+import dagger.functional.subcomponent.pruning.ParentDoesntUseSubcomponent.ChildA;
+import dagger.functional.subcomponent.pruning.ParentDoesntUseSubcomponent.ChildB;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/**
+ * Tests for {@link Subcomponent}s which are included with {@link Module#subcomponents()} but not
+ * used directly within the component which adds them.
+ *
+ * <p>This tests to make sure that while resolving one subcomponent (A), another subcomponent (B)
+ * can be requested if they have a shared ancestor component. If that shared ancestor did not
+ * resolve B directly via any of its entry points, B will still be generated since it is requested
+ * by a descendant.
+ */
+@RunWith(JUnit4.class)
+public class SubcomponentOnlyRequestedBySiblingTest {
+  @Test
+  public void subcomponentAddedInParent_onlyUsedInSibling() {
+    ParentDoesntUseSubcomponent parent = DaggerParentDoesntUseSubcomponent.create();
+    ChildB childB = parent.childBBuilder().build();
+    assertThat(childB.componentHierarchy())
+        .containsExactly(ParentDoesntUseSubcomponent.class, ChildB.class);
+    assertThat(childB.componentHierarchyFromChildA())
+        .containsExactly(ParentDoesntUseSubcomponent.class, ChildA.class);
+  }
+}
diff --git a/javatests/dagger/functional/subcomponent/repeat/OnlyUsedInChild.java b/javatests/dagger/functional/subcomponent/repeat/OnlyUsedInChild.java
new file mode 100644
index 000000000..b3318cf88
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/repeat/OnlyUsedInChild.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent.repeat;
+
+abstract class OnlyUsedInChild {
+
+}
diff --git a/javatests/dagger/functional/subcomponent/repeat/OnlyUsedInParent.java b/javatests/dagger/functional/subcomponent/repeat/OnlyUsedInParent.java
new file mode 100644
index 000000000..1e8d4cd93
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/repeat/OnlyUsedInParent.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent.repeat;
+
+abstract class OnlyUsedInParent {
+
+}
diff --git a/javatests/dagger/functional/subcomponent/repeat/OtherSubcomponentWithRepeatedModule.java b/javatests/dagger/functional/subcomponent/repeat/OtherSubcomponentWithRepeatedModule.java
new file mode 100644
index 000000000..82cd021fd
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/repeat/OtherSubcomponentWithRepeatedModule.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent.repeat;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = RepeatedModule.class)
+interface OtherSubcomponentWithRepeatedModule extends SubcomponentWithRepeatedModule {
+
+  @Subcomponent.Builder
+  interface Builder {
+    Builder repeatedModule(RepeatedModule repeatedModule);
+
+    OtherSubcomponentWithRepeatedModule build();
+  }
+}
diff --git a/javatests/dagger/functional/subcomponent/repeat/ParentComponent.java b/javatests/dagger/functional/subcomponent/repeat/ParentComponent.java
new file mode 100644
index 000000000..1578596c5
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/repeat/ParentComponent.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent.repeat;
+
+import dagger.Component;
+import java.util.Set;
+
+@Component(modules = RepeatedModule.class)
+interface ParentComponent {
+  Object state();
+
+  String getString();
+  Set<String> getMultiboundStrings();
+  OnlyUsedInParent getOnlyUsedInParent();
+
+  SubcomponentWithRepeatedModule.Builder newChildComponentBuilder();
+
+  SubcomponentWithoutRepeatedModule newChildComponentWithoutRepeatedModule();
+
+  @Component.Builder
+  interface Builder {
+    Builder repeatedModule(RepeatedModule repeatedModule);
+
+    ParentComponent build();
+  }
+}
diff --git a/javatests/dagger/functional/subcomponent/repeat/RepeatedModule.java b/javatests/dagger/functional/subcomponent/repeat/RepeatedModule.java
new file mode 100644
index 000000000..55d7de9d4
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/repeat/RepeatedModule.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent.repeat;
+
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.IntoSet;
+
+@Module
+final class RepeatedModule {
+  private final Object state = new Object();
+
+  @Provides
+  Object state() {
+    return state;
+  }
+
+  @Provides
+  static String provideString() {
+    return "a string";
+  }
+
+  @Provides
+  @IntoSet
+  static String contributeString() {
+    return "a string in a set";
+  }
+
+  @Provides
+  static OnlyUsedInParent provideOnlyUsedInParent() {
+    return new OnlyUsedInParent() {};
+  }
+
+  @Provides
+  static OnlyUsedInChild provideOnlyUsedInChild() {
+    return new OnlyUsedInChild() {};
+  }
+}
diff --git a/javatests/dagger/functional/subcomponent/repeat/RepeatedModuleTest.java b/javatests/dagger/functional/subcomponent/repeat/RepeatedModuleTest.java
new file mode 100644
index 000000000..1d7740b8a
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/repeat/RepeatedModuleTest.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent.repeat;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.junit.Assert.fail;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class RepeatedModuleTest {
+  private ParentComponent parentComponent;
+
+  @Before
+  public void initializeParentComponent() {
+    this.parentComponent = DaggerParentComponent.builder().build();
+  }
+
+  @Test
+  public void repeatedModuleHasSameStateInSubcomponent() {
+    SubcomponentWithRepeatedModule childComponent =
+        parentComponent.newChildComponentBuilder().build();
+    assertThat(parentComponent.state()).isSameAs(childComponent.state());
+  }
+
+  @Test
+  public void repeatedModuleHasSameStateInGrandchildSubcomponent() {
+    SubcomponentWithoutRepeatedModule childComponent =
+        parentComponent.newChildComponentWithoutRepeatedModule();
+    SubcomponentWithRepeatedModule grandchildComponent =
+        childComponent.newGrandchildBuilder().build();
+    assertThat(parentComponent.state()).isSameAs(grandchildComponent.state());
+  }
+
+  @Test
+  public void repeatedModuleBuilderThrowsInSubcomponent() {
+    SubcomponentWithRepeatedModule.Builder childComponentBuilder =
+        parentComponent.newChildComponentBuilder();
+    try {
+      childComponentBuilder.repeatedModule(new RepeatedModule());
+      fail();
+    } catch (UnsupportedOperationException expected) {
+      assertThat(expected)
+          .hasMessage(
+              "dagger.functional.subcomponent.repeat.RepeatedModule cannot be set "
+                  + "because it is inherited from the enclosing component");
+    }
+  }
+
+  @Test
+  public void repeatedModuleBuilderThrowsInGrandchildSubcomponent() {
+    SubcomponentWithoutRepeatedModule childComponent =
+        parentComponent.newChildComponentWithoutRepeatedModule();
+    OtherSubcomponentWithRepeatedModule.Builder grandchildComponentBuilder =
+        childComponent.newGrandchildBuilder();
+    try {
+      grandchildComponentBuilder.repeatedModule(new RepeatedModule());
+      fail();
+    } catch (UnsupportedOperationException expected) {
+      assertThat(expected)
+          .hasMessage(
+              "dagger.functional.subcomponent.repeat.RepeatedModule cannot be set "
+                  + "because it is inherited from the enclosing component");
+    }
+  }
+}
diff --git a/javatests/dagger/functional/subcomponent/repeat/SubcomponentWithRepeatedModule.java b/javatests/dagger/functional/subcomponent/repeat/SubcomponentWithRepeatedModule.java
new file mode 100644
index 000000000..0762374bd
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/repeat/SubcomponentWithRepeatedModule.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent.repeat;
+
+import dagger.Subcomponent;
+import java.util.Set;
+
+@Subcomponent(modules = RepeatedModule.class)
+interface SubcomponentWithRepeatedModule {
+  Object state();
+
+  String getString();
+
+  Set<String> getMultiboundStrings();
+
+  OnlyUsedInChild getOnlyUsedInChild();
+
+  @Subcomponent.Builder
+  interface Builder {
+    Builder repeatedModule(RepeatedModule repeatedModule);
+
+    SubcomponentWithRepeatedModule build();
+  }
+}
diff --git a/javatests/dagger/functional/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java b/javatests/dagger/functional/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java
new file mode 100644
index 000000000..5930f5182
--- /dev/null
+++ b/javatests/dagger/functional/subcomponent/repeat/SubcomponentWithoutRepeatedModule.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.subcomponent.repeat;
+
+import dagger.Subcomponent;
+
+@Subcomponent
+interface SubcomponentWithoutRepeatedModule {
+  OtherSubcomponentWithRepeatedModule.Builder newGrandchildBuilder();
+}
diff --git a/javatests/dagger/functional/tck/BUILD b/javatests/dagger/functional/tck/BUILD
new file mode 100644
index 000000000..e20228275
--- /dev/null
+++ b/javatests/dagger/functional/tck/BUILD
@@ -0,0 +1,41 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#  TCK tests for Dagger
+
+package(default_visibility = ["//:src"])
+
+load(
+    "//:build_defs.bzl",
+    "DOCLINT_HTML_AND_SYNTAX",
+    "DOCLINT_REFERENCES",
+)
+load("//:test_defs.bzl", "GenJavaTests")
+
+GenJavaTests(
+    name = "tck_tests",
+    srcs = glob(["*.java"]),
+    javacopts = DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES + [
+        "-Adagger.privateMemberValidation=warning",
+        "-Adagger.staticMemberValidation=warning",
+        "-Adagger.ignorePrivateAndStaticInjectionForComponent=enabled",
+    ],
+    deps = [
+        "//:dagger_with_compiler",
+        "//third_party:jsr330_inject",
+        "//third_party:jsr330_inject_tck",
+        "//third_party:junit",
+    ],
+)
diff --git a/javatests/dagger/functional/tck/CarModule.java b/javatests/dagger/functional/tck/CarModule.java
new file mode 100644
index 000000000..3c44d60f9
--- /dev/null
+++ b/javatests/dagger/functional/tck/CarModule.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.tck;
+
+import dagger.Binds;
+import dagger.Module;
+import org.atinject.tck.auto.Car;
+import org.atinject.tck.auto.Convertible;
+
+@Module
+abstract class CarModule {
+  @Binds
+  abstract Car provideConvertible(Convertible convertible);
+}
diff --git a/javatests/dagger/functional/tck/CarShop.java b/javatests/dagger/functional/tck/CarShop.java
new file mode 100644
index 000000000..7e1cdcd37
--- /dev/null
+++ b/javatests/dagger/functional/tck/CarShop.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.tck;
+
+import dagger.Component;
+import javax.inject.Singleton;
+import org.atinject.tck.auto.Car;
+
+@Singleton
+@Component(
+  modules = {
+    CarModule.class,
+    TireModule.class,
+    SeatModule.class,
+    EngineModule.class,
+    FuelTankModule.class
+  }
+)
+public interface CarShop {
+  @SuppressWarnings("dependency-cycle")
+  Car make();
+  @Component.Builder
+  interface Builder {
+    CarShop build();
+  }
+}
diff --git a/javatests/dagger/functional/tck/EngineModule.java b/javatests/dagger/functional/tck/EngineModule.java
new file mode 100644
index 000000000..331b064ef
--- /dev/null
+++ b/javatests/dagger/functional/tck/EngineModule.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.tck;
+
+import dagger.MembersInjector;
+import dagger.Module;
+import dagger.Provides;
+import org.atinject.tck.auto.Engine;
+import org.atinject.tck.auto.V8Engine;
+
+@Module
+public class EngineModule {
+  @Provides
+  static Engine provideEngine(MembersInjector<V8Engine> injector) {
+    // This is provided because V8Engine has no @Inject constructor and Dagger requires an @Inject
+    // constructor, however this is a TCK supplied class that we prefer to leave unmodified.
+    V8Engine engine = new V8Engine();
+    injector.injectMembers(engine);
+    return engine;
+  }
+}
diff --git a/javatests/dagger/functional/tck/FuelTankModule.java b/javatests/dagger/functional/tck/FuelTankModule.java
new file mode 100644
index 000000000..b5f2800b6
--- /dev/null
+++ b/javatests/dagger/functional/tck/FuelTankModule.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.tck;
+
+import dagger.Module;
+import dagger.Provides;
+import org.atinject.tck.auto.FuelTank;
+
+@Module
+class FuelTankModule {
+  @Provides
+  static FuelTank provideFuelTank() {
+    return new FuelTank();
+  }
+}
diff --git a/javatests/dagger/functional/tck/SeatModule.java b/javatests/dagger/functional/tck/SeatModule.java
new file mode 100644
index 000000000..c3574eaa8
--- /dev/null
+++ b/javatests/dagger/functional/tck/SeatModule.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.tck;
+
+import dagger.Binds;
+import dagger.Module;
+import org.atinject.tck.auto.Drivers;
+import org.atinject.tck.auto.DriversSeat;
+import org.atinject.tck.auto.Seat;
+
+@Module
+abstract class SeatModule {
+  @Binds
+  @Drivers
+  abstract Seat provideSeat(DriversSeat seat);
+}
diff --git a/javatests/dagger/functional/tck/TckTest.java b/javatests/dagger/functional/tck/TckTest.java
new file mode 100644
index 000000000..a49972d5e
--- /dev/null
+++ b/javatests/dagger/functional/tck/TckTest.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.tck;
+
+import junit.framework.Test;
+import org.atinject.tck.Tck;
+import org.atinject.tck.auto.Car;
+import org.atinject.tck.auto.Convertible;
+
+/** 
+ * Test suite to execute the JSR-330 TCK in JUnit.
+ */
+public class TckTest {
+  public static Test suite() {
+    CarShop carShopComponent = DaggerCarShop.create();
+    Car car = carShopComponent.make();
+    Convertible.localConvertible.set((Convertible) car);
+    return Tck.testsFor(car, false, false);
+  }
+}
diff --git a/javatests/dagger/functional/tck/TireModule.java b/javatests/dagger/functional/tck/TireModule.java
new file mode 100644
index 000000000..e6b6d58a1
--- /dev/null
+++ b/javatests/dagger/functional/tck/TireModule.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.functional.tck;
+
+import dagger.Binds;
+import dagger.Module;
+import javax.inject.Named;
+import org.atinject.tck.auto.Tire;
+import org.atinject.tck.auto.accessories.SpareTire;
+
+@Module
+abstract class TireModule {
+  @Binds
+  @Named("spare")
+  abstract Tire provideTire(SpareTire sparetire);
+}
diff --git a/javatests/dagger/grpc/functional/server/BUILD b/javatests/dagger/grpc/functional/server/BUILD
new file mode 100644
index 000000000..1e8c2e6e8
--- /dev/null
+++ b/javatests/dagger/grpc/functional/server/BUILD
@@ -0,0 +1,19 @@
+# Functional tests for Dagger-gRPC
+
+package(default_visibility = ["//:src"])
+
+load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX", "DOCLINT_REFERENCES")
+load("//:test_defs.bzl", "GenJavaTests")
+
+# TODO(dpb): enable tests once java_grpc_library is ready in bazel:
+# https://github.com/grpc/grpc-java/issues/2756
+
+java_proto_library(
+    name = "coffee_service_java_proto",
+    deps = [":protos"],
+)
+
+proto_library(
+    name = "protos",
+    srcs = glob(["*.proto"]),
+)
diff --git a/javatests/dagger/grpc/functional/server/BaristaTest.java b/javatests/dagger/grpc/functional/server/BaristaTest.java
new file mode 100644
index 000000000..d6c5b429c
--- /dev/null
+++ b/javatests/dagger/grpc/functional/server/BaristaTest.java
@@ -0,0 +1,154 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.functional.server;
+
+import static com.google.common.truth.Truth.assertThat;
+import static com.google.common.util.concurrent.Futures.getUnchecked;
+import static com.google.protos.test.CoffeeService.CoffeeType.AMERICANO;
+import static com.google.protos.test.CoffeeService.CoffeeType.DRIP;
+import static com.google.protos.test.CoffeeService.CoffeeType.ESPRESSO;
+import static com.google.protos.test.CoffeeService.CoffeeType.LATTE;
+import static com.google.protos.test.CoffeeService.CoffeeType.POUR_OVER;
+import static java.util.Arrays.asList;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.util.concurrent.SettableFuture;
+import com.google.protos.test.BaristaGrpc;
+import com.google.protos.test.BaristaGrpc.BaristaStub;
+import com.google.protos.test.CoffeeService.CoffeeRequest;
+import com.google.protos.test.CoffeeService.CoffeeResponse;
+import com.google.protos.test.CoffeeService.CoffeeType;
+import io.grpc.inprocess.InProcessChannelBuilder;
+import io.grpc.stub.StreamObserver;
+import java.util.ArrayList;
+import java.util.List;
+import org.junit.Before;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+@RunWith(Parameterized.class)
+public class BaristaTest {
+
+  private static final class CoffeeResponseObserver implements StreamObserver<CoffeeResponse> {
+    private final SettableFuture<Void> completion = SettableFuture.create();
+    private final List<CoffeeResponse> responses = new ArrayList<>();
+
+    List<CoffeeResponse> responses() {
+      getUnchecked(completion);
+      return responses;
+    }
+
+    @Override
+    public void onNext(CoffeeResponse value) {
+      responses.add(value);
+    }
+
+    @Override
+    public void onError(Throwable t) {
+      completion.setException(t);
+    }
+
+    @Override
+    public void onCompleted() {
+      completion.set(null);
+    }
+  }
+
+  @ClassRule
+  public static CoffeeServerResource coffeeServerWithCallScope =
+      new CoffeeServerResource("CallScope", DaggerCoffeeServerWithCallScopeService.builder());
+
+  @ClassRule
+  public static CoffeeServerResource coffeeServerWithSingletonScope =
+      new CoffeeServerResource("Unscoped", DaggerCoffeeServerWithUnscopedService.builder());
+
+  @Parameters(name = "{0}")
+  public static Iterable<Object[]> coffeeServers() {
+    return ImmutableList.copyOf(
+        new Object[][] {{coffeeServerWithCallScope}, {coffeeServerWithSingletonScope}});
+  }
+
+  @Rule public final VerifyInterceptor verifyCount;
+  private final CoffeeServerResource coffeeServer;
+  private final CoffeeResponseObserver responseObserver = new CoffeeResponseObserver();
+
+  private BaristaStub barista;
+
+  public BaristaTest(CoffeeServerResource coffeeServer) {
+    this.coffeeServer = coffeeServer;
+    this.verifyCount = new VerifyInterceptor(coffeeServer);
+  }
+
+  @Before
+  public void setUp() {
+    barista = BaristaGrpc.newStub(InProcessChannelBuilder.forName(coffeeServer.name()).build());
+  }
+
+  @Test
+  public void testUnaryGetCoffee() {
+    barista.unaryGetCoffee(request(POUR_OVER, LATTE), responseObserver);
+    assertThat(responseObserver.responses())
+        .containsExactly(response("Here you go!", POUR_OVER, LATTE));
+  }
+
+  @Test
+  public void testClientStreamingGetCoffee() {
+    StreamObserver<CoffeeRequest> requestObserver =
+        barista.clientStreamingGetCoffee(responseObserver);
+    requestObserver.onNext(request(POUR_OVER, LATTE));
+    requestObserver.onNext(request(AMERICANO));
+    requestObserver.onNext(request(DRIP, ESPRESSO));
+    requestObserver.onCompleted();
+    assertThat(responseObserver.responses())
+        .containsExactly(response("All yours!", POUR_OVER, LATTE, AMERICANO, DRIP, ESPRESSO));
+  }
+
+  @Test
+  public void testServerStreamingGetCoffee() {
+    barista.serverStreamingGetCoffee(request(DRIP, AMERICANO), responseObserver);
+    assertThat(responseObserver.responses())
+        .containsExactly(
+            response("Here's a DRIP", DRIP), response("Here's a AMERICANO", AMERICANO));
+  }
+
+  @Test
+  public void testBidiStreamingGetCoffee() {
+    StreamObserver<CoffeeRequest> requestObserver =
+        barista.bidiStreamingGetCoffee(responseObserver);
+    requestObserver.onNext(request(POUR_OVER, LATTE));
+    requestObserver.onNext(request(AMERICANO));
+    requestObserver.onNext(request(DRIP, ESPRESSO));
+    requestObserver.onCompleted();
+    assertThat(responseObserver.responses())
+        .containsExactly(
+            response("Enjoy!", POUR_OVER, LATTE),
+            response("Enjoy!", AMERICANO),
+            response("Enjoy!", DRIP, ESPRESSO));
+  }
+
+  private CoffeeRequest request(CoffeeType... types) {
+    return CoffeeRequest.newBuilder().addAllType(asList(types)).build();
+  }
+
+  private CoffeeResponse response(String message, CoffeeType... types) {
+    return CoffeeResponse.newBuilder().setMessage(message).addAllCup(asList(types)).build();
+  }
+}
diff --git a/javatests/dagger/grpc/functional/server/CoffeeServer.java b/javatests/dagger/grpc/functional/server/CoffeeServer.java
new file mode 100644
index 000000000..10a0fd225
--- /dev/null
+++ b/javatests/dagger/grpc/functional/server/CoffeeServer.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.functional.server;
+
+import dagger.grpc.server.InProcessServerModule;
+import io.grpc.Server;
+import java.io.IOException;
+
+abstract class CoffeeServer<T extends CoffeeServer<T>> {
+  protected abstract Server server();
+
+  public void start() throws IOException {
+    server().start();
+  }
+
+  public void shutdown() {
+    server().shutdownNow();
+  }
+
+  abstract CountingInterceptor countingInterceptor();
+
+  interface Builder<T extends CoffeeServer<T>> {
+    Builder<T> inProcessServerModule(InProcessServerModule serverModule);
+
+    T build();
+  }
+}
diff --git a/javatests/dagger/grpc/functional/server/CoffeeServerResource.java b/javatests/dagger/grpc/functional/server/CoffeeServerResource.java
new file mode 100644
index 000000000..dc449fb16
--- /dev/null
+++ b/javatests/dagger/grpc/functional/server/CoffeeServerResource.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.functional.server;
+
+import dagger.grpc.server.InProcessServerModule;
+import java.io.IOException;
+import org.junit.rules.ExternalResource;
+
+final class CoffeeServerResource extends ExternalResource {
+  private final String name;
+  private final CoffeeServer<?> coffeeServer;
+
+  CoffeeServerResource(String name, CoffeeServer.Builder<?> coffeeServerBuilder) {
+    this.name = name;
+    this.coffeeServer =
+        coffeeServerBuilder.inProcessServerModule(InProcessServerModule.serverNamed(name)).build();
+  }
+
+  public String name() {
+    return name;
+  }
+
+  public int methodCount(String methodName) {
+    return coffeeServer.countingInterceptor().countCalls(methodName);
+  }
+
+  @Override
+  protected void before() throws IOException, InterruptedException {
+    coffeeServer.start();
+  }
+
+  @Override
+  protected void after() {
+    coffeeServer.shutdown();
+  }
+
+  @Override
+  public String toString() {
+    return name;
+  }
+}
diff --git a/javatests/dagger/grpc/functional/server/CoffeeServerWithCallScopeService.java b/javatests/dagger/grpc/functional/server/CoffeeServerWithCallScopeService.java
new file mode 100644
index 000000000..5fb06b64d
--- /dev/null
+++ b/javatests/dagger/grpc/functional/server/CoffeeServerWithCallScopeService.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.functional.server;
+
+import dagger.Component;
+import dagger.Module;
+import dagger.Provides;
+import dagger.Subcomponent;
+import dagger.grpc.functional.server.CoffeeServerWithCallScopeService.CallScopeServiceModule;
+import dagger.grpc.functional.server.CountingInterceptor.CountingInterceptorModule;
+import dagger.grpc.server.CallScoped;
+import dagger.grpc.server.GrpcCallMetadataModule;
+import dagger.grpc.server.InProcessServerModule;
+import javax.inject.Singleton;
+
+@Singleton
+@Component(modules = {InProcessServerModule.class, CallScopeServiceModule.class})
+abstract class CoffeeServerWithCallScopeService
+    extends CoffeeServer<CoffeeServerWithCallScopeService> {
+
+  @Component.Builder
+  interface Builder extends CoffeeServer.Builder<CoffeeServerWithCallScopeService> {}
+
+  abstract BaristaCallScope baristaCallScope(GrpcCallMetadataModule callMetadataModule);
+
+  @CallScoped
+  @Subcomponent(
+    modules = {
+      GrpcCallMetadataModule.class,
+      FriendlyBaristaGrpcServiceModule.class,
+      CountingInterceptorModule.class
+    }
+  )
+  interface BaristaCallScope extends FriendlyBaristaServiceDefinition {}
+
+  @Module(includes = FriendlyBaristaGrpcProxyModule.class)
+  static class CallScopeServiceModule {
+    @Provides
+    static FriendlyBaristaServiceDefinition.Factory friendlyBaristaServiceDefinitionFactory(
+        final CoffeeServerWithCallScopeService testServer) {
+      return new FriendlyBaristaServiceDefinition.Factory() {
+        @Override
+        public FriendlyBaristaServiceDefinition grpcService(
+            GrpcCallMetadataModule grpcCallMetadataModule) {
+          return testServer.baristaCallScope(grpcCallMetadataModule);
+        }
+      };
+    }
+  }
+}
diff --git a/javatests/dagger/grpc/functional/server/CoffeeServerWithUnscopedService.java b/javatests/dagger/grpc/functional/server/CoffeeServerWithUnscopedService.java
new file mode 100644
index 000000000..3346f8486
--- /dev/null
+++ b/javatests/dagger/grpc/functional/server/CoffeeServerWithUnscopedService.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.functional.server;
+
+import dagger.Binds;
+import dagger.Component;
+import dagger.Module;
+import dagger.grpc.functional.server.CoffeeServerWithUnscopedService.UnscopedServiceModule;
+import dagger.grpc.functional.server.CountingInterceptor.CountingInterceptorModule;
+import dagger.grpc.server.InProcessServerModule;
+import javax.inject.Singleton;
+
+@Singleton
+@Component(
+  modules = {
+    InProcessServerModule.class,
+    UnscopedServiceModule.class,
+    CountingInterceptorModule.class
+  }
+)
+abstract class CoffeeServerWithUnscopedService extends CoffeeServer<CoffeeServerWithUnscopedService>
+    implements FriendlyBaristaServiceDefinition {
+
+  @Component.Builder
+  interface Builder extends CoffeeServer.Builder<CoffeeServerWithUnscopedService> {}
+
+  @Module(includes = FriendlyBaristaUnscopedGrpcServiceModule.class)
+  abstract static class UnscopedServiceModule {
+    @Binds
+    abstract FriendlyBaristaServiceDefinition friendlyBaristaServiceDefinition(
+        CoffeeServerWithUnscopedService testServer);
+  }
+}
diff --git a/javatests/dagger/grpc/functional/server/CountingInterceptor.java b/javatests/dagger/grpc/functional/server/CountingInterceptor.java
new file mode 100644
index 000000000..4d537826d
--- /dev/null
+++ b/javatests/dagger/grpc/functional/server/CountingInterceptor.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.functional.server;
+
+import static java.util.Arrays.asList;
+
+import com.google.common.collect.ConcurrentHashMultiset;
+import com.google.common.collect.Multiset;
+import com.google.protos.test.BaristaGrpc;
+import dagger.Module;
+import dagger.Provides;
+import dagger.grpc.server.ForGrpcService;
+import io.grpc.Metadata;
+import io.grpc.ServerCall;
+import io.grpc.ServerCall.Listener;
+import io.grpc.ServerCallHandler;
+import io.grpc.ServerInterceptor;
+import java.util.List;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+@Singleton
+class CountingInterceptor implements ServerInterceptor {
+  private final Multiset<String> calls = ConcurrentHashMultiset.create();
+
+  @Inject
+  CountingInterceptor() {}
+
+  @Override
+  public <RequestT, ResponseT> Listener<RequestT> interceptCall(
+      ServerCall<RequestT, ResponseT> call,
+      Metadata headers,
+      ServerCallHandler<RequestT, ResponseT> next) {
+    calls.add(call.getMethodDescriptor().getFullMethodName());
+    return next.startCall(call, headers);
+  }
+
+  public int countCalls(String methodName) {
+    return calls.count(methodName);
+  }
+
+  @Module
+  static class CountingInterceptorModule {
+    @Provides
+    @ForGrpcService(BaristaGrpc.class)
+    static List<? extends ServerInterceptor> testServiceInterceptors(
+        CountingInterceptor countingInterceptor) {
+      return asList(countingInterceptor);
+    }
+  }
+}
diff --git a/javatests/dagger/grpc/functional/server/FriendlyBarista.java b/javatests/dagger/grpc/functional/server/FriendlyBarista.java
new file mode 100644
index 000000000..2c0246f8e
--- /dev/null
+++ b/javatests/dagger/grpc/functional/server/FriendlyBarista.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.functional.server;
+
+import static java.util.Collections.singletonList;
+
+import com.google.protos.test.BaristaGrpc;
+import com.google.protos.test.BaristaGrpc.BaristaImplBase;
+import com.google.protos.test.CoffeeService.CoffeeRequest;
+import com.google.protos.test.CoffeeService.CoffeeResponse;
+import com.google.protos.test.CoffeeService.CoffeeType;
+import dagger.grpc.server.GrpcService;
+import io.grpc.stub.StreamObserver;
+import java.util.List;
+import javax.inject.Inject;
+
+@GrpcService(grpcClass = BaristaGrpc.class)
+class FriendlyBarista extends BaristaImplBase {
+
+  @Inject
+  FriendlyBarista() {}
+
+  @Override
+  public void unaryGetCoffee(
+      CoffeeRequest request, StreamObserver<CoffeeResponse> responseObserver) {
+    responseObserver.onNext(response("Here you go!", request.getTypeList()));
+    responseObserver.onCompleted();
+  }
+
+  @Override
+  public StreamObserver<CoffeeRequest> clientStreamingGetCoffee(
+      final StreamObserver<CoffeeResponse> responseObserver) {
+    return new StreamObserver<CoffeeRequest>() {
+
+      private final CoffeeResponse.Builder response = CoffeeResponse.newBuilder();
+
+      @Override
+      public void onNext(CoffeeRequest value) {
+        response.addAllCup(value.getTypeList());
+      }
+
+      @Override
+      public void onError(Throwable t) {}
+
+      @Override
+      public void onCompleted() {
+        response.setMessage("All yours!");
+        responseObserver.onNext(response.build());
+        responseObserver.onCompleted();
+      }
+    };
+  }
+
+  @Override
+  public void serverStreamingGetCoffee(
+      CoffeeRequest request, StreamObserver<CoffeeResponse> responseObserver) {
+    for (CoffeeType type : request.getTypeList()) {
+      responseObserver.onNext(response("Here's a " + type, singletonList(type)));
+    }
+    responseObserver.onCompleted();
+  }
+
+  @Override
+  public StreamObserver<CoffeeRequest> bidiStreamingGetCoffee(
+      final StreamObserver<CoffeeResponse> responseObserver) {
+    return new StreamObserver<CoffeeRequest>() {
+
+      private int responses;
+
+      @Override
+      public void onNext(CoffeeRequest value) {
+        responseObserver.onNext(response("Enjoy!", value.getTypeList()));
+        if (responses++ > 10) {
+          responseObserver.onNext(CoffeeResponse.newBuilder().setMessage("We're done.").build());
+          responseObserver.onCompleted();
+        }
+      }
+
+      @Override
+      public void onError(Throwable t) {}
+
+      @Override
+      public void onCompleted() {
+        responseObserver.onCompleted();
+      }
+    };
+  }
+
+  private CoffeeResponse response(String message, List<CoffeeType> types) {
+    return CoffeeResponse.newBuilder().addAllCup(types).setMessage(message).build();
+  }
+}
diff --git a/javatests/dagger/grpc/functional/server/VerifyInterceptor.java b/javatests/dagger/grpc/functional/server/VerifyInterceptor.java
new file mode 100644
index 000000000..99ecedb4e
--- /dev/null
+++ b/javatests/dagger/grpc/functional/server/VerifyInterceptor.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.grpc.functional.server;
+
+import static com.google.common.truth.Truth.assertWithMessage;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import com.google.protos.test.BaristaGrpc;
+import io.grpc.MethodDescriptor;
+import java.lang.annotation.Retention;
+import org.junit.rules.TestRule;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+final class VerifyInterceptor implements TestRule {
+
+  @Retention(RUNTIME)
+  @interface MethodName {
+    String value();
+  }
+
+  private final CoffeeServerResource coffeeServer;
+
+  VerifyInterceptor(CoffeeServerResource coffeeServer) {
+    this.coffeeServer = coffeeServer;
+  }
+
+  @Override
+  public Statement apply(final Statement base, Description description) {
+    MethodName annotation = description.getAnnotation(MethodName.class);
+    if (annotation == null) {
+      return base;
+    }
+    final String fullMethodName =
+        MethodDescriptor.generateFullMethodName(BaristaGrpc.SERVICE_NAME, annotation.value());
+    return new Statement() {
+      @Override
+      public void evaluate() throws Throwable {
+        int calls = coffeeServer.methodCount(fullMethodName);
+        base.evaluate();
+        assertWithMessage("Calls to %s", fullMethodName)
+            .that(coffeeServer.methodCount(fullMethodName))
+            .isEqualTo(calls + 1);
+      }
+    };
+  }
+}
diff --git a/javatests/dagger/grpc/functional/server/coffee_service.proto b/javatests/dagger/grpc/functional/server/coffee_service.proto
new file mode 100644
index 000000000..a14c79482
--- /dev/null
+++ b/javatests/dagger/grpc/functional/server/coffee_service.proto
@@ -0,0 +1,50 @@
+// Copyright (C) 2016 The Dagger Authors.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+syntax = "proto3";
+
+package test;
+
+enum CoffeeType {
+  UNKNOWN = 0;
+  DRIP = 1;
+  POUR_OVER = 2;
+  ESPRESSO = 3;
+  AMERICANO = 4;
+  LATTE = 5;
+}
+
+message CoffeeRequest {
+  repeated CoffeeType type = 1;
+}
+
+message CoffeeResponse {
+  repeated CoffeeType cup = 1;
+  string message = 2;
+}
+
+service Barista {
+  rpc UnaryGetCoffee(CoffeeRequest) returns (CoffeeResponse) {
+  }
+
+  rpc ClientStreamingGetCoffee(stream CoffeeRequest) returns (CoffeeResponse) {
+  }
+
+  rpc ServerStreamingGetCoffee(CoffeeRequest) returns (stream CoffeeResponse) {
+  }
+
+  rpc BidiStreamingGetCoffee(stream CoffeeRequest)
+      returns (stream CoffeeResponse) {
+  }
+}
diff --git a/core/src/test/java/dagger/internal/DoubleCheckTest.java b/javatests/dagger/internal/DoubleCheckTest.java
similarity index 100%
rename from core/src/test/java/dagger/internal/DoubleCheckTest.java
rename to javatests/dagger/internal/DoubleCheckTest.java
diff --git a/core/src/test/java/dagger/internal/InstanceFactoryTest.java b/javatests/dagger/internal/InstanceFactoryTest.java
similarity index 100%
rename from core/src/test/java/dagger/internal/InstanceFactoryTest.java
rename to javatests/dagger/internal/InstanceFactoryTest.java
diff --git a/core/src/test/java/dagger/internal/MapProviderFactoryTest.java b/javatests/dagger/internal/MapProviderFactoryTest.java
similarity index 100%
rename from core/src/test/java/dagger/internal/MapProviderFactoryTest.java
rename to javatests/dagger/internal/MapProviderFactoryTest.java
diff --git a/core/src/test/java/dagger/internal/SetFactoryTest.java b/javatests/dagger/internal/SetFactoryTest.java
similarity index 100%
rename from core/src/test/java/dagger/internal/SetFactoryTest.java
rename to javatests/dagger/internal/SetFactoryTest.java
diff --git a/core/src/test/java/dagger/internal/SingleCheckTest.java b/javatests/dagger/internal/SingleCheckTest.java
similarity index 100%
rename from core/src/test/java/dagger/internal/SingleCheckTest.java
rename to javatests/dagger/internal/SingleCheckTest.java
diff --git a/compiler/src/test/java/dagger/internal/codegen/AccessibilityTest.java b/javatests/dagger/internal/codegen/AccessibilityTest.java
similarity index 100%
rename from compiler/src/test/java/dagger/internal/codegen/AccessibilityTest.java
rename to javatests/dagger/internal/codegen/AccessibilityTest.java
diff --git a/javatests/dagger/internal/codegen/BUILD b/javatests/dagger/internal/codegen/BUILD
new file mode 100644
index 000000000..49e155225
--- /dev/null
+++ b/javatests/dagger/internal/codegen/BUILD
@@ -0,0 +1,41 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   Tests for the Dagger compiler/codegen
+
+package(default_visibility = ["//:src"])
+
+load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX")
+load("//:test_defs.bzl", "GenJavaTests")
+
+GenJavaTests(
+    name = "compiler_tests",
+    srcs = glob(["*.java"]),
+    javacopts = DOCLINT_HTML_AND_SYNTAX,
+    deps = [
+        "//java/dagger:core",
+        "//java/dagger/internal/codegen",
+        "//java/dagger/producers",
+        "//third_party:auto_common",
+        "//third_party:auto_value",
+        "//third_party:compile_testing",
+        "//third_party:guava",
+        "//third_party:javapoet",
+        "//third_party:jsr330_inject",
+        "//third_party:junit",
+        "//third_party:mockito",
+        "//third_party:truth",
+    ],
+)
diff --git a/compiler/src/test/java/dagger/internal/codegen/BindingTypeMapperTest.java b/javatests/dagger/internal/codegen/BindingTypeMapperTest.java
similarity index 100%
rename from compiler/src/test/java/dagger/internal/codegen/BindingTypeMapperTest.java
rename to javatests/dagger/internal/codegen/BindingTypeMapperTest.java
diff --git a/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java b/javatests/dagger/internal/codegen/BindsMethodValidatorTest.java
similarity index 100%
rename from compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java
rename to javatests/dagger/internal/codegen/BindsMethodValidatorTest.java
diff --git a/compiler/src/test/java/dagger/internal/codegen/BindsOptionalOfMethodValidatorTest.java b/javatests/dagger/internal/codegen/BindsOptionalOfMethodValidatorTest.java
similarity index 100%
rename from compiler/src/test/java/dagger/internal/codegen/BindsOptionalOfMethodValidatorTest.java
rename to javatests/dagger/internal/codegen/BindsOptionalOfMethodValidatorTest.java
diff --git a/compiler/src/test/java/dagger/internal/codegen/CanReleaseReferencesValidatorTest.java b/javatests/dagger/internal/codegen/CanReleaseReferencesValidatorTest.java
similarity index 100%
rename from compiler/src/test/java/dagger/internal/codegen/CanReleaseReferencesValidatorTest.java
rename to javatests/dagger/internal/codegen/CanReleaseReferencesValidatorTest.java
diff --git a/compiler/src/test/java/dagger/internal/codegen/CodeBlocksTest.java b/javatests/dagger/internal/codegen/CodeBlocksTest.java
similarity index 100%
rename from compiler/src/test/java/dagger/internal/codegen/CodeBlocksTest.java
rename to javatests/dagger/internal/codegen/CodeBlocksTest.java
diff --git a/compiler/src/test/java/dagger/internal/codegen/Compilers.java b/javatests/dagger/internal/codegen/Compilers.java
similarity index 100%
rename from compiler/src/test/java/dagger/internal/codegen/Compilers.java
rename to javatests/dagger/internal/codegen/Compilers.java
diff --git a/javatests/dagger/internal/codegen/ComponentBuilderTest.java b/javatests/dagger/internal/codegen/ComponentBuilderTest.java
new file mode 100644
index 000000000..d3ae193b5
--- /dev/null
+++ b/javatests/dagger/internal/codegen/ComponentBuilderTest.java
@@ -0,0 +1,1313 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for {@link dagger.Component.Builder} */
+@RunWith(JUnit4.class)
+public class ComponentBuilderTest {
+
+  private static final ErrorMessages.ComponentBuilderMessages MSGS =
+      ErrorMessages.ComponentBuilderMessages.INSTANCE;
+
+  @Test
+  public void testEmptyBuilder() {
+    JavaFileObject injectableTypeFile =
+        JavaFileObjects.forSourceLines(
+            "test.SomeInjectableType",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class SomeInjectableType {",
+            "  @Inject SomeInjectableType() {}",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface SimpleComponent {",
+            "  SomeInjectableType someInjectableType();",
+            "",
+            "  @Component.Builder",
+            "  static interface Builder {",
+            "     SimpleComponent build();",
+            "  }",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerSimpleComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerSimpleComponent implements SimpleComponent {",
+            "  private DaggerSimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static SimpleComponent.Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static SimpleComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public SomeInjectableType someInjectableType() {",
+            "    return new SomeInjectableType();",
+            "  }",
+            "",
+            "  private static final class Builder implements SimpleComponent.Builder {",
+            "    @Override",
+            "    public SimpleComponent build() {",
+            "      return new DaggerSimpleComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(injectableTypeFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void testUsesBuildAndSetterNames() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides String string() { return null; }",
+            "}");
+
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  String string();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    Builder setTestModule(TestModule testModule);",
+            "    TestComponent create();",
+            "  }",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<String> stringProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static TestComponent.Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().create();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.stringProvider = TestModule_StringFactory.create(builder.testModule);",
+            "  }",
+            "",
+            "  @Override",
+            "  public String string() {",
+            "    return stringProvider.get();",
+            "  }",
+            "",
+            "  private static final class Builder implements TestComponent.Builder {",
+            "    private TestModule testModule;",
+            "",
+            "    @Override",
+            "    public TestComponent create() {",
+            "      if (testModule == null) {",
+            "        this.testModule = new TestModule();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    @Override",
+            "    public Builder setTestModule(TestModule testModule) {",
+            "      this.testModule = Preconditions.checkNotNull(testModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void testIgnoresModulesNotInApi() {
+    JavaFileObject module1 =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule1",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule1 {",
+            "  @Provides String string() { return null; }",
+            "}");
+    JavaFileObject module2 =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule2",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule2 {",
+            "  @Provides Integer integer() { return null; }",
+            "}");
+
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = {TestModule1.class, TestModule2.class})",
+            "interface TestComponent {",
+            "  String string();",
+            "  Integer integer();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    Builder testModule1(TestModule1 testModule1);",
+            "    TestComponent build();",
+            "  }",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<String> stringProvider;",
+            "  private Provider<Integer> integerProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static TestComponent.Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.stringProvider = TestModule1_StringFactory.create(builder.testModule1);",
+            "    this.integerProvider = TestModule2_IntegerFactory.create(builder.testModule2);",
+            "  }",
+            "",
+            "  @Override",
+            "  public String string() {",
+            "    return stringProvider.get();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Integer integer() {",
+            "    return integerProvider.get();",
+            "  }",
+            "",
+            "  private static final class Builder implements TestComponent.Builder {",
+            "    private TestModule1 testModule1;",
+            "    private TestModule2 testModule2;",
+            "",
+            "    @Override",
+            "    public TestComponent build() {",
+            "      if (testModule1 == null) {",
+            "        this.testModule1 = new TestModule1();",
+            "      }",
+            "      if (testModule2 == null) {",
+            "        this.testModule2 = new TestModule2();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    @Override",
+            "    public Builder testModule1(TestModule1 testModule1) {",
+            "      this.testModule1 = Preconditions.checkNotNull(testModule1);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(module1, module2, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void testMoreThanOneBuilderFails() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface SimpleComponent {",
+            "  @Component.Builder",
+            "  static interface Builder {",
+            "     SimpleComponent build();",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder2 {",
+            "     SimpleComponent build();",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(
+                MSGS.moreThanOne(),
+                "[test.SimpleComponent.Builder, test.SimpleComponent.Builder2]"))
+        .in(componentFile);
+  }
+
+  @Test
+  public void testBuilderGenericsFails() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder<T> {",
+            "     SimpleComponent build();",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.generics())
+        .in(componentFile);
+  }
+
+  @Test
+  public void testBuilderNotInComponentFails() {
+    JavaFileObject builder =
+        JavaFileObjects.forSourceLines(
+            "test.Builder",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component.Builder",
+            "interface Builder {}");
+    assertAbout(javaSource())
+        .that(builder)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeInComponent())
+        .in(builder);
+  }
+
+  @Test
+  public void testBuilderMissingBuildMethodFails() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.missingBuildMethod())
+        .in(componentFile);
+  }
+
+  @Test
+  public void testBuilderBindsInstanceNoCreateGenerated() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface SimpleComponent {",
+            "  Object object();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    @BindsInstance Builder object(Object object);",
+            "    SimpleComponent build();",
+            "  }",
+            "}");
+
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerSimpleComponent",
+            "package test;",
+            "",
+            "import dagger.internal.InstanceFactory;",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerSimpleComponent implements SimpleComponent {",
+            "  private Provider<Object> objectProvider;",
+            "",
+            "  private DaggerSimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static SimpleComponent.Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.objectProvider = InstanceFactory.create(builder.object);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Object object() {",
+            "    return objectProvider.get();",
+            "  }",
+            "",
+            "  private static final class Builder implements SimpleComponent.Builder {",
+            "    private Object object;",
+            "",
+            "    @Override",
+            "    public SimpleComponent build() {",
+            "      if (object == null) {",
+            "        throw new IllegalStateException(",
+            "            Object.class.getCanonicalName() + \" must be set\")",
+            "      }",
+            "      return new DaggerSimpleComponent(this);",
+            "    }",
+            "",
+            "    @Override",
+            "    public Builder object(Object object) {",
+            "      this.object = Preconditions.checkNotNull(object);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(componentFile);
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void testPrivateBuilderFails() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  private interface Builder {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.isPrivate())
+        .in(componentFile);
+  }
+
+  @Test
+  public void testNonStaticBuilderFails() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  abstract class Builder {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeStatic())
+        .in(componentFile);
+  }
+
+  @Test
+  public void testNonAbstractBuilderFails() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  static class Builder {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeAbstract());
+  }
+
+  @Test
+  public void testBuilderOneCxtorWithArgsFails() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  static abstract class Builder {",
+            "    Builder(String unused) {}",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
+        .in(componentFile);
+  }
+
+  @Test
+  public void testBuilderMoreThanOneCxtorFails() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  static abstract class Builder {",
+            "    Builder() {}",
+            "    Builder(String unused) {}",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
+        .in(componentFile);
+  }
+
+  @Test
+  public void testBuilderEnumFails() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  enum Builder {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeClassOrInterface())
+        .in(componentFile);
+  }
+
+  @Test
+  public void testBuilderBuildReturnsWrongTypeFails() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    String build();",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.buildMustReturnComponentType())
+        .in(componentFile)
+        .onLine(10);
+  }
+
+  @Test
+  public void testInheritedBuilderBuildReturnsWrongTypeFails() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  interface Parent {",
+            "    String build();",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends Parent {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
+        .in(componentFile)
+        .onLine(13);
+  }
+
+  @Test
+  public void testTwoBuildMethodsFails() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "    SimpleComponent create();",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(MSGS.twoBuildMethods(), "build()"))
+        .in(componentFile)
+        .onLine(11);
+  }
+
+  @Test
+  public void testInheritedTwoBuildMethodsFails() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  interface Parent {",
+            "    SimpleComponent build();",
+            "    SimpleComponent create();",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends Parent {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(MSGS.inheritedTwoBuildMethods(), "build()", "create()"))
+        .in(componentFile)
+        .onLine(14);
+  }
+
+  @Test
+  public void testMoreThanOneArgFails() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "    Builder set(String s, Integer i);",
+            "    Builder set(Number n, Double d);",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.methodsMustTakeOneArg())
+        .in(componentFile)
+        .onLine(11)
+        .and()
+        .withErrorContaining(MSGS.methodsMustTakeOneArg())
+        .in(componentFile)
+        .onLine(12);
+  }
+
+  @Test
+  public void testInheritedMoreThanOneArgFails() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  interface Parent {",
+            "    SimpleComponent build();",
+            "    Builder set1(String s, Integer i);",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends Parent {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(
+                MSGS.inheritedMethodsMustTakeOneArg(), "set1(java.lang.String,java.lang.Integer)"))
+        .in(componentFile)
+        .onLine(14);
+  }
+
+  @Test
+  public void testSetterReturningNonVoidOrBuilderFails() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "    String set(Integer i);",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())
+        .in(componentFile)
+        .onLine(11);
+  }
+
+  @Test
+  public void testInheritedSetterReturningNonVoidOrBuilderFails() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  interface Parent {",
+            "    SimpleComponent build();",
+            "    String set(Integer i);",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends Parent {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(), "set(java.lang.Integer)"))
+        .in(componentFile)
+        .onLine(14);
+  }
+
+  @Test
+  public void testGenericsOnSetterMethodFails() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "    <T> Builder set(T t);",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.methodsMayNotHaveTypeParameters())
+        .in(componentFile)
+        .onLine(11);
+  }
+
+  @Test
+  public void testGenericsOnInheritedSetterMethodFails() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "abstract class SimpleComponent {",
+            "  interface Parent {",
+            "    SimpleComponent build();",
+            "    <T> Builder set(T t);",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends Parent {}",
+            "}");
+    assertAbout(javaSource())
+        .that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedMethodsMayNotHaveTypeParameters(), "<T>set(T)"))
+        .in(componentFile)
+        .onLine(14);
+  }
+
+  @Test
+  public void testMultipleSettersPerTypeFails() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides String s() { return \"\"; }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "abstract class SimpleComponent {",
+            "  abstract String s();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "    void set1(TestModule s);",
+            "    void set2(TestModule s);",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(
+                MSGS.manyMethodsForType(),
+                "test.TestModule",
+                "[set1(test.TestModule), set2(test.TestModule)]"))
+        .in(componentFile)
+        .onLine(11);
+  }
+
+  @Test
+  public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides String s() { return \"\"; }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "abstract class SimpleComponent {",
+            "  abstract String s();",
+            "",
+            "  interface Parent<T> {",
+            "    void set1(T t);",
+            "  }",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends Parent<TestModule> {",
+            "    SimpleComponent build();",
+            "    void set2(TestModule s);",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(
+                MSGS.manyMethodsForType(), "test.TestModule", "[set1(T), set2(test.TestModule)]"))
+        .in(componentFile)
+        .onLine(15);
+  }
+
+  @Test
+  public void testExtraSettersFails() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = AbstractModule.class)",
+            "abstract class SimpleComponent {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "    void abstractModule(AbstractModule abstractModule);",
+            "    void other(String s);",
+            "  }",
+            "}");
+    JavaFileObject abstractModule =
+        JavaFileObjects.forSourceLines(
+            "test.AbstractModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class AbstractModule {}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(componentFile, abstractModule))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(
+                MSGS.extraSetters(),
+                "[void test.SimpleComponent.Builder.abstractModule(test.AbstractModule), "
+                    + "void test.SimpleComponent.Builder.other(String)]"))
+        .in(componentFile)
+        .onLine(10);
+  }
+
+  @Test
+  public void testMissingSettersFail() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  TestModule(String unused) {}",
+            "  @Provides String s() { return null; }",
+            "}");
+    JavaFileObject module2File =
+        JavaFileObjects.forSourceLines(
+            "test.Test2Module",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class Test2Module {",
+            "  @Provides Integer i() { return null; }",
+            "}");
+    JavaFileObject module3File =
+        JavaFileObjects.forSourceLines(
+            "test.Test3Module",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class Test3Module {",
+            "  Test3Module(String unused) {}",
+            "  @Provides Double d() { return null; }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = {TestModule.class, Test2Module.class, Test3Module.class},",
+            "           dependencies = OtherComponent.class)",
+            "interface TestComponent {",
+            "  String string();",
+            "  Integer integer();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    TestComponent create();",
+            "  }",
+            "}");
+    JavaFileObject otherComponent =
+        JavaFileObjects.forSourceLines(
+            "test.OtherComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface OtherComponent {}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, module2File, module3File, componentFile, otherComponent))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            // Ignores Test2Module because we can construct it ourselves.
+            // TODO(sameb): Ignore Test3Module because it's not used within transitive dependencies.
+            String.format(
+                MSGS.missingSetters(), "[test.TestModule, test.Test3Module, test.OtherComponent]"))
+        .in(componentFile)
+        .onLine(12);
+  }
+
+  @Test
+  public void covariantBuildMethodReturnType() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface HasSupertype extends Supertype {",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    Supertype build();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(foo, supertype, component);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void covariantBuildMethodReturnType_hasNewMethod() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject bar =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Bar {",
+            "  @Inject Bar() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface HasSupertype extends Supertype {",
+            "  Bar bar();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder {",
+            "    Supertype build();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(foo, bar, supertype, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining(
+            "test.HasSupertype.Builder.build() returns test.Supertype, but test.HasSupertype "
+                + "declares additional component method(s): bar(). In order to provide type-safe "
+                + "access to these methods, override build() to return test.HasSupertype")
+        .inFile(component)
+        .onLine(11);
+  }
+
+  @Test
+  public void covariantBuildMethodReturnType_hasNewMethod_buildMethodInherited() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject bar =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Bar {",
+            "  @Inject Bar() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject builderSupertype =
+        JavaFileObjects.forSourceLines(
+            "test.BuilderSupertype",
+            "package test;",
+            "",
+            "interface BuilderSupertype {",
+            "  Supertype build();",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface HasSupertype extends Supertype {",
+            "  Bar bar();",
+            "",
+            "  @Component.Builder",
+            "  interface Builder extends BuilderSupertype {}",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(foo, bar, supertype, builderSupertype, component);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining(
+            "[test.BuilderSupertype.build()] test.HasSupertype.Builder.build() returns "
+                + "test.Supertype, but test.HasSupertype declares additional component method(s): "
+                + "bar(). In order to provide type-safe access to these methods, override build() "
+                + "to return test.HasSupertype");
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentHierarchyValidatorTest.java b/javatests/dagger/internal/codegen/ComponentHierarchyValidatorTest.java
similarity index 100%
rename from compiler/src/test/java/dagger/internal/codegen/ComponentHierarchyValidatorTest.java
rename to javatests/dagger/internal/codegen/ComponentHierarchyValidatorTest.java
diff --git a/javatests/dagger/internal/codegen/ComponentProcessorTest.java b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
new file mode 100644
index 000000000..18e02de4b
--- /dev/null
+++ b/javatests/dagger/internal/codegen/ComponentProcessorTest.java
@@ -0,0 +1,2945 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
+import com.google.auto.common.MoreElements;
+import com.google.common.base.Joiner;
+import com.google.common.base.Predicate;
+import com.google.common.base.Predicates;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.Compiler;
+import com.google.testing.compile.JavaFileObjects;
+import com.squareup.javapoet.CodeBlock;
+import dagger.MembersInjector;
+import java.io.IOException;
+import java.io.Writer;
+import java.lang.annotation.Annotation;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.ProcessingEnvironment;
+import javax.annotation.processing.Processor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.inject.Inject;
+import javax.lang.model.SourceVersion;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.TypeElement;
+import javax.tools.JavaFileObject;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ComponentProcessorTest {
+  private static final CodeBlock NPE_LITERAL =
+      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);
+
+  @Test public void componentOnConcreteClass() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "final class NotAComponent {}");
+    Compilation compilation = daggerCompiler().compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("interface");
+  }
+
+  @Test public void componentOnEnum() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "enum NotAComponent {",
+        "  INSTANCE",
+        "}");
+    Compilation compilation = daggerCompiler().compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("interface");
+  }
+
+  @Test public void componentOnAnnotation() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "@interface NotAComponent {}");
+    Compilation compilation = daggerCompiler().compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("interface");
+  }
+
+  @Test public void nonModuleModule() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = Object.class)",
+        "interface NotAComponent {}");
+    Compilation compilation = daggerCompiler().compile(componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("is not annotated with @Module");
+  }
+
+  @Test
+  public void componentWithInvalidModule() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.BadModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class BadModule {",
+            "  @Binds abstract Object noParameters();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.BadComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = BadModule.class)",
+            "interface BadComponent {",
+            "  Object object();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(module, component);
+    assertThat(compilation)
+        .hadErrorContaining("test.BadModule has errors")
+        .inFile(component)
+        .onLine(5);
+  }
+
+  @Test public void doubleBindingFromResolvedModules() {
+    JavaFileObject parent = JavaFileObjects.forSourceLines("test.ParentModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import java.util.List;",
+        "",
+        "@Module",
+        "abstract class ParentModule<A> {",
+        "  @Provides List<A> provideListB(A a) { return null; }",
+        "}");
+    JavaFileObject child = JavaFileObjects.forSourceLines("test.ChildModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "class ChildNumberModule extends ParentModule<Integer> {",
+        "  @Provides Integer provideInteger() { return null; }",
+        "}");
+    JavaFileObject another = JavaFileObjects.forSourceLines("test.AnotherModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import java.util.List;",
+        "",
+        "@Module",
+        "class AnotherModule {",
+        "  @Provides List<Integer> provideListOfInteger() { return null; }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.BadComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.List;",
+        "",
+        "@Component(modules = {ChildNumberModule.class, AnotherModule.class})",
+        "interface BadComponent {",
+        "  List<Integer> listOfInteger();",
+        "}");
+
+    Compilation compilation = daggerCompiler().compile(parent, child, another, componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("java.util.List<java.lang.Integer> is bound multiple times");
+    assertThat(compilation)
+        .hadErrorContaining("@Provides List<Integer> test.ChildNumberModule.provideListB(Integer)");
+    assertThat(compilation)
+        .hadErrorContaining("@Provides List<Integer> test.AnotherModule.provideListOfInteger()");
+  }
+
+  @Test public void privateNestedClassWithWarningThatIsAnErrorInComponent() {
+    JavaFileObject outerClass = JavaFileObjects.forSourceLines("test.OuterClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterClass {",
+        "  @Inject OuterClass(InnerClass innerClass) {}",
+        "",
+        "  private static final class InnerClass {",
+        "    @Inject InnerClass() {}",
+        "  }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.BadComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface BadComponent {",
+        "  OuterClass outerClass();",
+        "}");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions("-Adagger.privateMemberValidation=WARNING")
+            .compile(outerClass, componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Dagger does not support injection into private classes");
+  }
+
+  @Test public void simpleComponent() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  SomeInjectableType someInjectableType();",
+        "  Lazy<SomeInjectableType> lazySomeInjectableType();",
+        "  Provider<SomeInjectableType> someInjectableTypeProvider();",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerSimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Lazy;",
+            "import dagger.internal.DoubleCheck;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerSimpleComponent implements SimpleComponent {",
+            "  private DaggerSimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static SimpleComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public SomeInjectableType someInjectableType() {",
+            "    return new SomeInjectableType();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
+            "    return DoubleCheck.lazy(SomeInjectableType_Factory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
+            "    return SomeInjectableType_Factory.create();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public SimpleComponent build() {",
+            "      return new DaggerSimpleComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(injectableTypeFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test public void componentWithScope() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Singleton",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "import javax.inject.Provider;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Singleton",
+        "@Component",
+        "interface SimpleComponent {",
+        "  SomeInjectableType someInjectableType();",
+        "  Lazy<SomeInjectableType> lazySomeInjectableType();",
+        "  Provider<SomeInjectableType> someInjectableTypeProvider();",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerSimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Lazy;",
+            "import dagger.internal.DoubleCheck;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerSimpleComponent implements SimpleComponent {",
+            "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
+            "",
+            "  private DaggerSimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static SimpleComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.someInjectableTypeProvider =",
+            "        DoubleCheck.provider(SomeInjectableType_Factory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public SomeInjectableType someInjectableType() {",
+            "    return someInjectableTypeProvider.get();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Lazy<SomeInjectableType> lazySomeInjectableType() {",
+            "    return DoubleCheck.lazy(someInjectableTypeProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Provider<SomeInjectableType> someInjectableTypeProvider() {",
+            "    return someInjectableTypeProvider;",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public SimpleComponent build() {",
+            "      return new DaggerSimpleComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(injectableTypeFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test public void simpleComponentWithNesting() {
+    JavaFileObject nestedTypesFile = JavaFileObjects.forSourceLines("test.OuterType",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterType {",
+        "  static class A {",
+        "    @Inject A() {}",
+        "  }",
+        "  static class B {",
+        "    @Inject A a;",
+        "  }",
+        "  @Component interface SimpleComponent {",
+        "    A a();",
+        "    void inject(B b);",
+        "  }",
+        "}");
+
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerOuterType_SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerOuterType_SimpleComponent",
+            "    implements OuterType.SimpleComponent {",
+            "  private MembersInjector<OuterType.B> bMembersInjector;",
+            "",
+            "  private DaggerOuterType_SimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static OuterType.SimpleComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.bMembersInjector =",
+            "        OuterType_B_MembersInjector.create(OuterType_A_Factory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public OuterType.A a() {",
+            "    return new OuterType.A();",
+            "  }",
+            "",
+            "  @Override",
+            "  public void inject(OuterType.B b) {",
+            "    bMembersInjector.injectMembers(b);",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public OuterType.SimpleComponent build() {",
+            "      return new DaggerOuterType_SimpleComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(nestedTypesFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerOuterType_SimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test public void componentWithModule() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A(B b) {}",
+        "}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "interface B {}");
+    JavaFileObject cFile = JavaFileObjects.forSourceLines("test.C",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class C {",
+        "  @Inject C() {}",
+        "}");
+
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides B b(C c) { return null; }",
+        "}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  A a();",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<B> bProvider;",
+            "  private Provider<A> aProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.bProvider = TestModule_BFactory.create(builder.testModule,",
+            "        C_Factory.create());",
+            "    this.aProvider = A_Factory.create(bProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public A a() {",
+            "    return new A(bProvider.get());",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private TestModule testModule;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      if (testModule == null) {",
+            "        this.testModule = new TestModule();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    public Builder testModule(TestModule testModule) {",
+            "      this.testModule = Preconditions.checkNotNull(testModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().compile(aFile, bFile, cFile, moduleFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void componentWithAbstractModule() {
+    JavaFileObject aFile =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class A {",
+            "  @Inject A(B b) {}",
+            "}");
+    JavaFileObject bFile =
+        JavaFileObjects.forSourceLines("test.B",
+            "package test;",
+            "",
+            "interface B {}");
+    JavaFileObject cFile =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class C {",
+            "  @Inject C() {}",
+            "}");
+
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Provides static B b(C c) { return null; }",
+            "}");
+
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  A a();",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<B> bProvider;",
+            "  private Provider<A> aProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.bProvider = TestModule_BFactory.create(C_Factory.create());",
+            "    this.aProvider = A_Factory.create(bProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public A a() {",
+            "    return new A(TestModule.b(new C()));",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().compile(aFile, bFile, cFile, moduleFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test public void transitiveModuleDeps() {
+    JavaFileObject always = JavaFileObjects.forSourceLines("test.AlwaysIncluded",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "final class AlwaysIncluded {}");
+    JavaFileObject testModule = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = {DepModule.class, AlwaysIncluded.class})",
+        "final class TestModule extends ParentTestModule {}");
+    JavaFileObject parentTest = JavaFileObjects.forSourceLines("test.ParentTestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = {ParentTestIncluded.class, AlwaysIncluded.class})",
+        "class ParentTestModule {}");
+    JavaFileObject parentTestIncluded = JavaFileObjects.forSourceLines("test.ParentTestIncluded",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = AlwaysIncluded.class)",
+        "final class ParentTestIncluded {}");
+    JavaFileObject depModule = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = {RefByDep.class, AlwaysIncluded.class})",
+        "final class DepModule extends ParentDepModule {}");
+    JavaFileObject refByDep = JavaFileObjects.forSourceLines("test.RefByDep",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = AlwaysIncluded.class)",
+        "final class RefByDep extends ParentDepModule {}");
+    JavaFileObject parentDep = JavaFileObjects.forSourceLines("test.ParentDepModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = {ParentDepIncluded.class, AlwaysIncluded.class})",
+        "class ParentDepModule {}");
+    JavaFileObject parentDepIncluded = JavaFileObjects.forSourceLines("test.ParentDepIncluded",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = AlwaysIncluded.class)",
+        "final class ParentDepIncluded {}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "}");
+    // Generated code includes all includes, but excludes the parent modules.
+    // The "always" module should only be listed once.
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.Preconditions;",
+        "import javax.annotation.Generated;",
+        "",
+        GENERATED_ANNOTATION,
+        "public final class DaggerTestComponent implements TestComponent {",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return new Builder().build();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "",
+        "    @Deprecated",
+        "    public Builder testModule(TestModule testModule) {",
+        "      Preconditions.checkNotNull(testModule)",
+        "      return this;",
+        "    }",
+        "",
+        "    @Deprecated",
+        "    public Builder parentTestIncluded(ParentTestIncluded parentTestIncluded) {",
+        "      Preconditions.checkNotNull(parentTestIncluded)",
+        "      return this;",
+        "    }",
+        "",
+        "    @Deprecated",
+        "    public Builder alwaysIncluded(AlwaysIncluded alwaysIncluded) {",
+        "      Preconditions.checkNotNull(alwaysIncluded)",
+        "      return this;",
+        "    }",
+        "",
+        "    @Deprecated",
+        "    public Builder depModule(DepModule depModule) {",
+        "      Preconditions.checkNotNull(depModule)",
+        "      return this;",
+        "    }",
+        "",
+        "    @Deprecated",
+        "    public Builder parentDepIncluded(ParentDepIncluded parentDepIncluded) {",
+        "      Preconditions.checkNotNull(parentDepIncluded)",
+        "      return this;",
+        "    }",
+        "",
+        "    @Deprecated",
+        "    public Builder refByDep(RefByDep refByDep) {",
+        "      Preconditions.checkNotNull(refByDep)",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    Compilation compilation =
+        daggerCompiler()
+            .compile(
+                always,
+                testModule,
+                parentTest,
+                parentTestIncluded,
+                depModule,
+                refByDep,
+                parentDep,
+                parentDepIncluded,
+                componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test
+  public void generatedTransitiveModule() {
+    JavaFileObject rootModule = JavaFileObjects.forSourceLines("test.RootModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module(includes = GeneratedModule.class)",
+        "final class RootModule {}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = RootModule.class)",
+        "interface TestComponent {}");
+    assertThat(daggerCompiler().compile(rootModule, component)).failed();
+    assertThat(
+            daggerCompiler(
+                    new GeneratingProcessor(
+                        "test.GeneratedModule",
+                        "package test;",
+                        "",
+                        "import dagger.Module;",
+                        "",
+                        "@Module",
+                        "final class GeneratedModule {}"))
+                .compile(rootModule, component))
+        .succeeded();
+  }
+
+  @Test
+  public void generatedModuleInSubcomponent() {
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.ChildComponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GeneratedModule.class)",
+            "interface ChildComponent {}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  ChildComponent childComponent();",
+            "}");
+    assertThat(daggerCompiler().compile(subcomponent, component)).failed();
+    assertThat(
+            daggerCompiler(
+                    new GeneratingProcessor(
+                        "test.GeneratedModule",
+                        "package test;",
+                        "",
+                        "import dagger.Module;",
+                        "",
+                        "@Module",
+                        "final class GeneratedModule {}"))
+                .compile(subcomponent, component))
+        .succeeded();
+  }
+
+  @Test
+  public void subcomponentOmitsInheritedBindings() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.StringKey;",
+            "",
+            "@Module",
+            "class ParentModule {",
+            "  @Provides @IntoSet static Object parentObject() {",
+            "    return \"parent object\";",
+            "  }",
+            "",
+            "  @Provides @IntoMap @StringKey(\"parent key\") Object parentKeyObject() {",
+            "    return \"parent value\";",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "@Subcomponent",
+            "interface Child {",
+            "  Set<Object> objectSet();",
+            "  Map<String, Object> objectMap();",
+            "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParent",
+            "package test;",
+            "",
+            "import dagger.internal.MapFactory;",
+            "import dagger.internal.MapProviderFactory;",
+            "import dagger.internal.Preconditions;",
+            "import dagger.internal.SetFactory;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParent implements Parent {",
+            "  private Provider<Object> parentKeyObjectProvider;",
+            "",
+            "  private DaggerParent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Parent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.parentKeyObjectProvider =",
+            "        ParentModule_ParentKeyObjectFactory.create(builder.parentModule);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Child child() {",
+            "    return new ChildImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private ParentModule parentModule;",
+            "",
+            "    private Builder() {}",
+            "",
+            "    public Parent build() {",
+            "      if (parentModule == null) {",
+            "        this.parentModule = new ParentModule();",
+            "      }",
+            "      return new DaggerParent(this);",
+            "    }",
+            "",
+            "    public Builder parentModule(ParentModule parentModule) {",
+            "      this.parentModule = Preconditions.checkNotNull(parentModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "",
+            "  private final class ChildImpl implements Child {",
+            "    private Provider<Set<Object>> setOfObjectProvider;",
+            "    private Provider<Map<String, Provider<Object>>>",
+            "        mapOfStringAndProviderOfObjectProvider;",
+            "    private Provider<Map<String, Object>> mapOfStringAndObjectProvider;",
+            "",
+            "    private ChildImpl() {",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() {",
+            "      this.setOfObjectProvider = SetFactory.<Object>builder(1, 0)",
+            "          .addProvider(ParentModule_ParentObjectFactory.create()).build();",
+            "      this.mapOfStringAndProviderOfObjectProvider =",
+            "          MapProviderFactory.<String, Object>builder(1)",
+            "              .put(\"parent key\", DaggerParent.this.parentKeyObjectProvider)",
+            "              .build();",
+            "      this.mapOfStringAndObjectProvider = MapFactory.create(",
+            "          mapOfStringAndProviderOfObjectProvider);",
+            "    }",
+            "",
+            "    @Override",
+            "    public Set<Object> objectSet() {",
+            "      return setOfObjectProvider.get();",
+            "    }",
+            "",
+            "    @Override",
+            "    public Map<String, Object> objectMap() {",
+            "      return mapOfStringAndObjectProvider.get();",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(parent, parentModule, child);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerParent")
+        .hasSourceEquivalentTo(expected);
+  }
+
+  @Test
+  public void subcomponentNotGeneratedIfNotUsedInGraph() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  String notSubcomponent();",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module(subcomponents = Child.class)",
+            "class ParentModule {",
+            "  @Provides static String notSubcomponent() { return new String(); }",
+            "}");
+
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Child {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Child build();",
+            "  }",
+            "}");
+
+    JavaFileObject generatedComponentWithoutSubcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParent",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParent implements Parent {",
+            "",
+            "  private DaggerParent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Parent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public String notSubcomponent() {",
+            "    return ParentModule.notSubcomponent();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public Parent build() {",
+            "      return new DaggerParent(this);",
+            "    }",
+            "",
+            "    @Deprecated",
+            "    public Builder parentModule(ParentModule parentModule) {",
+            "      Preconditions.checkNotNull(parentModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(component, module, subcomponent);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerParent")
+        .hasSourceEquivalentTo(generatedComponentWithoutSubcomponent);
+  }
+
+  @Test
+  public void testDefaultPackage() {
+    JavaFileObject aClass = JavaFileObjects.forSourceLines("AClass", "class AClass {}");
+    JavaFileObject bClass = JavaFileObjects.forSourceLines("BClass",
+        "import javax.inject.Inject;",
+        "",
+        "class BClass {",
+        "  @Inject BClass(AClass a) {}",
+        "}");
+    JavaFileObject aModule = JavaFileObjects.forSourceLines("AModule",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module class AModule {",
+        "  @Provides AClass aClass() {",
+        "    return new AClass();",
+        "  }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("SomeComponent",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = AModule.class)",
+        "interface SomeComponent {",
+        "  BClass bClass();",
+        "}");
+    assertThat(daggerCompiler().compile(aModule, aClass, bClass, component)).succeeded();
+  }
+
+  @Test public void setBindings() {
+    JavaFileObject emptySetModuleFile = JavaFileObjects.forSourceLines("test.EmptySetModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.multibindings.ElementsIntoSet;",
+        "import java.util.Collections;",
+        "import java.util.Set;",
+        "",
+        "@Module",
+        "final class EmptySetModule {",
+        "  @Provides @ElementsIntoSet Set<String> emptySet() { return Collections.emptySet(); }",
+        "}");
+    JavaFileObject setModuleFile = JavaFileObjects.forSourceLines("test.SetModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.multibindings.IntoSet;",
+        "",
+        "@Module",
+        "final class SetModule {",
+        "  @Provides @IntoSet String string() { return \"\"; }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Set;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {EmptySetModule.class, SetModule.class})",
+        "interface TestComponent {",
+        "  Set<String> strings();",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            "import dagger.internal.SetFactory;",
+            "import java.util.Set;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<Set<String>> emptySetProvider;",
+            "  private Provider<String> stringProvider;",
+            "  private Provider<Set<String>> setOfStringProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.emptySetProvider =",
+            "        EmptySetModule_EmptySetFactory.create(builder.emptySetModule);",
+            "    this.stringProvider =",
+            "        SetModule_StringFactory.create(builder.setModule);",
+            "    this.setOfStringProvider = ",
+            "        SetFactory.<String>builder(1, 1)",
+            "            .addCollectionProvider(emptySetProvider)",
+            "            .addProvider(stringProvider)",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Set<String> strings() {",
+            "    return setOfStringProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private EmptySetModule emptySetModule;",
+            "    private SetModule setModule;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      if (emptySetModule == null) {",
+            "        this.emptySetModule = new EmptySetModule();",
+            "      }",
+            "      if (setModule == null) {",
+            "        this.setModule = new SetModule();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    public Builder emptySetModule(EmptySetModule emptySetModule) {",
+            "      this.emptySetModule = Preconditions.checkNotNull(emptySetModule);",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder setModule(SetModule setModule) {",
+            "      this.setModule = Preconditions.checkNotNull(setModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().compile(emptySetModuleFile, setModuleFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test public void membersInjection() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject injectedTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectedType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectedType {",
+        "  @Inject SomeInjectableType injectedField;",
+        "  SomeInjectedType() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  void inject(SomeInjectedType instance);",
+        "  SomeInjectedType injectAndReturn(SomeInjectedType instance);",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerSimpleComponent",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "",
+        GENERATED_ANNOTATION,
+        "public final class DaggerSimpleComponent implements SimpleComponent {",
+        "  private MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
+        "",
+        "  private DaggerSimpleComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return new Builder().build();",
+        "  }",
+        "",
+        "  @SuppressWarnings(\"unchecked\")",
+        "  private void initialize(final Builder builder) {",
+        "    this.someInjectedTypeMembersInjector =",
+        "        SomeInjectedType_MembersInjector.create(SomeInjectableType_Factory.create());",
+        "  }",
+        "",
+        "  @Override",
+        "  public void inject(SomeInjectedType instance) {",
+        "    someInjectedTypeMembersInjector.injectMembers(instance);",
+        "  }",
+        "",
+        "  @Override",
+        "  public SomeInjectedType injectAndReturn(SomeInjectedType instance) {",
+        "    someInjectedTypeMembersInjector.injectMembers(instance);",
+        "    return instance;",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new DaggerSimpleComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    Compilation compilation =
+        daggerCompiler().compile(injectableTypeFile, injectedTypeFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test public void componentInjection() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType(SimpleComponent component) {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  SomeInjectableType someInjectableType();",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerSimpleComponent",
+            "package test;",
+            "",
+            "import dagger.internal.InstanceFactory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerSimpleComponent implements SimpleComponent {",
+            "  private Provider<SimpleComponent> simpleComponentProvider;",
+            "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
+            "",
+            "  private DaggerSimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static SimpleComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.simpleComponentProvider = InstanceFactory.<SimpleComponent>create(this);",
+            "    this.someInjectableTypeProvider =",
+            "        SomeInjectableType_Factory.create(simpleComponentProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public SomeInjectableType someInjectableType() {",
+            "    return new SomeInjectableType(simpleComponentProvider.get())",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public SimpleComponent build() {",
+            "      return new DaggerSimpleComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(injectableTypeFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test public void membersInjectionInsideProvision() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject injectedTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectedType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectedType {",
+        "  @Inject SomeInjectableType injectedField;",
+        "  @Inject SomeInjectedType() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  SomeInjectedType createAndInject();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerSimpleComponent",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        GENERATED_ANNOTATION,
+        "public final class DaggerSimpleComponent implements SimpleComponent {",
+        "  private MembersInjector<SomeInjectedType> someInjectedTypeMembersInjector;",
+        "  private Provider<SomeInjectedType> someInjectedTypeProvider;",
+        "",
+        "  private DaggerSimpleComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return new Builder().build();",
+        "  }",
+        "",
+        "  @SuppressWarnings(\"unchecked\")",
+        "  private void initialize(final Builder builder) {",
+        "    this.someInjectedTypeMembersInjector =",
+        "        SomeInjectedType_MembersInjector.create(SomeInjectableType_Factory.create());",
+        "    this.someInjectedTypeProvider =",
+        "        SomeInjectedType_Factory.create(someInjectedTypeMembersInjector);",
+        "  }",
+        "",
+        "  @Override",
+        "  public SomeInjectedType createAndInject() {",
+        "    return someInjectedTypeProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new DaggerSimpleComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    Compilation compilation =
+        daggerCompiler().compile(injectableTypeFile, injectedTypeFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test public void injectionWithGenericBaseClass() {
+    JavaFileObject genericType = JavaFileObjects.forSourceLines("test.AbstractGenericType",
+        "package test;",
+        "",
+        "abstract class AbstractGenericType<T> {",
+        "}");
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType extends AbstractGenericType<String> {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  SomeInjectableType someInjectableType();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerSimpleComponent",
+        "package test;",
+        "",
+        "import dagger.internal.MembersInjectors;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        GENERATED_ANNOTATION,
+        "public final class DaggerSimpleComponent implements SimpleComponent {",
+        "  private Provider<SomeInjectableType> someInjectableTypeProvider;",
+        "",
+        "  private DaggerSimpleComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static SimpleComponent create() {",
+        "    return new Builder().build();",
+        "  }",
+        "",
+        "  @SuppressWarnings(\"unchecked\")",
+        "  private void initialize(final Builder builder) {",
+        "    this.someInjectableTypeProvider =",
+        "        SomeInjectableType_Factory.create(MembersInjectors.<SomeInjectableType>noOp());",
+        "  }",
+        "",
+        "  @Override",
+        "  public SomeInjectableType someInjectableType() {",
+        "    return someInjectableTypeProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public SimpleComponent build() {",
+        "      return new DaggerSimpleComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    Compilation compilation =
+        daggerCompiler().compile(genericType, injectableTypeFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test public void componentDependency() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A() {}",
+        "}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class B {",
+        "  @Inject B(A a) {}",
+        "}");
+    JavaFileObject aComponentFile = JavaFileObjects.forSourceLines("test.AComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface AComponent {",
+        "  A a();",
+        "}");
+    JavaFileObject bComponentFile = JavaFileObjects.forSourceLines("test.AComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(dependencies = AComponent.class)",
+        "interface BComponent {",
+        "  B b();",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerBComponent",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerBComponent implements BComponent {",
+            "  private Provider<A> aProvider;",
+            "  private Provider<B> bProvider;",
+            "",
+            "  private DaggerBComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.aProvider = new test_AComponent_a(builder.aComponent);",
+            "    this.bProvider = B_Factory.create(aProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public B b() {",
+            "    return new B(aProvider.get());",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private AComponent aComponent;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public BComponent build() {",
+            "      if (aComponent == null) {",
+            "        throw new IllegalStateException(AComponent.class.getCanonicalName()",
+            "            + \" must be set\");",
+            "      }",
+            "      return new DaggerBComponent(this);",
+            "    }",
+            "",
+            "    public Builder aComponent(AComponent aComponent) {",
+            "      this.aComponent = Preconditions.checkNotNull(aComponent);",
+            "      return this;",
+            "    }",
+            "  }",
+            "",
+            "  private static class test_AComponent_a implements Provider<A> {",
+            "    private final AComponent aComponent;",
+            "    ",
+            "    test_AComponent_a(AComponent aComponent) {",
+            "        this.aComponent = aComponent;",
+            "    }",
+            "    ",
+            "    @Override()",
+            "    public A get() {",
+            "      return Preconditions.checkNotNull(aComponent.a(), " + NPE_LITERAL + ");",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler().compile(aFile, bFile, aComponentFile, bComponentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerBComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test public void moduleNameCollision() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "public final class A {}");
+    JavaFileObject otherAFile = JavaFileObjects.forSourceLines("other.test.A",
+        "package other.test;",
+        "",
+        "public final class A {}");
+
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "public final class TestModule {",
+        "  @Provides A a() { return null; }",
+        "}");
+    JavaFileObject otherModuleFile = JavaFileObjects.forSourceLines("other.test.TestModule",
+        "package other.test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "public final class TestModule {",
+        "  @Provides A a() { return null; }",
+        "}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {TestModule.class, other.test.TestModule.class})",
+        "interface TestComponent {",
+        "  A a();",
+        "  other.test.A otherA();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.Preconditions;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        GENERATED_ANNOTATION,
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private Provider<A> aProvider;",
+        "  private Provider<other.test.A> aProvider2;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return new Builder().build();",
+        "  }",
+        "",
+        "  @SuppressWarnings(\"unchecked\")",
+        "  private void initialize(final Builder builder) {",
+        "    this.aProvider = TestModule_AFactory.create(builder.testModule);",
+        "    this.aProvider2 = other.test.TestModule_AFactory.create(builder.testModule2);",
+        "  }",
+        "",
+        "  @Override",
+        "  public A a() {",
+        "    return aProvider.get();",
+        "  }",
+        "",
+        "  @Override",
+        "  public other.test.A otherA() {",
+        "    return aProvider2.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private TestModule testModule;",
+        "    private other.test.TestModule testModule2;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (testModule == null) {",
+        "        this.testModule = new TestModule();",
+        "      }",
+        "      if (testModule2 == null) {",
+        "        this.testModule2 = new other.test.TestModule();",
+        "      }",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "",
+        "    public Builder testModule(TestModule testModule) {",
+        "      this.testModule = Preconditions.checkNotNull(testModule);",
+        "      return this;",
+        "    }",
+        "",
+        "    public Builder testModule(other.test.TestModule testModule) {",
+        "      this.testModule2 = Preconditions.checkNotNull(testModule);",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    Compilation compilation =
+        daggerCompiler().compile(aFile, otherAFile, moduleFile, otherModuleFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test public void resolutionOrder() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A(B b) {}",
+        "}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class B {",
+        "  @Inject B(C c) {}",
+        "}");
+    JavaFileObject cFile = JavaFileObjects.forSourceLines("test.C",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class C {",
+        "  @Inject C() {}",
+        "}");
+    JavaFileObject xFile = JavaFileObjects.forSourceLines("test.X",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class X {",
+        "  @Inject X(C c) {}",
+        "}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  A a();",
+        "  C c();",
+        "  X x();",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<B> bProvider;",
+            "  private Provider<A> aProvider;",
+            "  private Provider<X> xProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.bProvider = B_Factory.create(C_Factory.create());",
+            "    this.aProvider = A_Factory.create(bProvider);",
+            "    this.xProvider = X_Factory.create(C_Factory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public A a() {",
+            "    return new A(new B(new C()));",
+            "  }",
+            "",
+            "  @Override",
+            "  public C c() {",
+            "    return new C();",
+            "  }",
+            "",
+            "  @Override",
+            "  public X x() {",
+            "    return new X(new C());",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(aFile, bFile, cFile, xFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerTestComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test public void simpleComponent_redundantComponentMethod() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject componentSupertypeAFile = JavaFileObjects.forSourceLines("test.SupertypeA",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SupertypeA {",
+        "  SomeInjectableType someInjectableType();",
+        "}");
+    JavaFileObject componentSupertypeBFile = JavaFileObjects.forSourceLines("test.SupertypeB",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SupertypeB {",
+        "  SomeInjectableType someInjectableType();",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent extends SupertypeA, SupertypeB {",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerSimpleComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerSimpleComponent implements SimpleComponent {",
+            "  private DaggerSimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static SimpleComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public SomeInjectableType someInjectableType() {",
+            "    return new SomeInjectableType();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public SimpleComponent build() {",
+            "      return new DaggerSimpleComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .compile(
+                injectableTypeFile,
+                componentSupertypeAFile,
+                componentSupertypeBFile,
+                componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test public void simpleComponent_inheritedComponentMethodDep() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType() {}",
+        "}");
+    JavaFileObject componentSupertype = JavaFileObjects.forSourceLines("test.Supertype",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface Supertype {",
+        "  SomeInjectableType someInjectableType();",
+        "}");
+    JavaFileObject depComponentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent extends Supertype {",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ComponentWithDep",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(dependencies = SimpleComponent.class)",
+        "interface ComponentWithDep {",
+        "  SomeInjectableType someInjectableType();",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerSimpleComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerSimpleComponent implements SimpleComponent {",
+            "  private DaggerSimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static SimpleComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public SomeInjectableType someInjectableType() {",
+            "    return new SomeInjectableType();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public SimpleComponent build() {",
+            "      return new DaggerSimpleComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .compile(injectableTypeFile, componentSupertype, depComponentFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+  }
+
+  @Test public void wildcardGenericsRequiresAtProvides() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A() {}",
+        "}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "final class B<T> {",
+        "  @Inject B(T t) {}",
+        "}");
+    JavaFileObject cFile = JavaFileObjects.forSourceLines("test.C",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "final class C {",
+        "  @Inject C(B<? extends A> bA) {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Lazy;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  C c();",
+        "}");
+    Compilation compilation = daggerCompiler().compile(aFile, bFile, cFile, componentFile);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.B<? extends test.A> cannot be provided without an @Provides-annotated method");
+  }
+
+  // https://github.com/google/dagger/issues/630
+  @Test
+  public void arrayKeyRequiresAtProvides() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  String[] array();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("String[] cannot be provided without an @Provides-annotated method");
+  }
+
+  @Test
+  public void componentImplicitlyDependsOnGeneratedType() {
+    JavaFileObject injectableTypeFile = JavaFileObjects.forSourceLines("test.SomeInjectableType",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class SomeInjectableType {",
+        "  @Inject SomeInjectableType(GeneratedType generatedType) {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface SimpleComponent {",
+        "  SomeInjectableType someInjectableType();",
+        "}");
+    Compilation compilation =
+        daggerCompiler(
+                new GeneratingProcessor(
+                    "test.GeneratedType",
+                    "package test;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "final class GeneratedType {",
+                    "  @Inject GeneratedType() {}",
+                    "}"))
+            .compile(injectableTypeFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation).generatedSourceFile("test.DaggerSimpleComponent");
+  }
+
+  @Test
+  public void componentSupertypeDependsOnGeneratedType() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface SimpleComponent extends SimpleComponentInterface {}");
+    JavaFileObject interfaceFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponentInterface",
+            "package test;",
+            "",
+            "interface SimpleComponentInterface {",
+            "  GeneratedType generatedType();",
+            "}");
+    Compilation compilation =
+        daggerCompiler(
+                new GeneratingProcessor(
+                    "test.GeneratedType",
+                    "package test;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "final class GeneratedType {",
+                    "  @Inject GeneratedType() {}",
+                    "}"))
+            .compile(componentFile, interfaceFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation).generatedSourceFile("test.DaggerSimpleComponent");
+  }
+
+  @Test
+  @Ignore // modify this test as necessary while debugging for your situation.
+  @SuppressWarnings("unused")
+  public void genericTestToLetMeDebugInEclipse() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+         "import javax.inject.Inject;",
+         "",
+         "public final class A {",
+         "  @Inject A() {}",
+         "}");
+     JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+         "package test;",
+         "",
+         "import javax.inject.Inject;",
+         "import javax.inject.Provider;",
+         "",
+         "public class B<T> {",
+         "  @Inject B() {}",
+         "}");
+     JavaFileObject dFile = JavaFileObjects.forSourceLines("test.sub.D",
+         "package test.sub;",
+         "",
+         "import javax.inject.Inject;",
+         "import javax.inject.Provider;",
+         "import test.B;",
+         "",
+         "public class D {",
+         "  @Inject D(B<A.InA> ba) {}",
+         "}");
+     JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.SimpleComponent",
+         "package test;",
+         "",
+         "import dagger.Component;",
+         "import dagger.Lazy;",
+         "",
+         "import javax.inject.Provider;",
+         "",
+         "@Component",
+         "interface SimpleComponent {",
+         "  B<A> d();",
+         "  Provider<B<A>> d2();",
+         "}");
+     JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+         "test.DaggerSimpleComponent",
+         "package test;",
+         "",
+         "import javax.annotation.Generated;",
+         "import javax.inject.Provider;",
+         "",
+         GENERATED_ANNOTATION,
+         "public final class DaggerSimpleComponent implements SimpleComponent {",
+         "  private Provider<D> dProvider;",
+         "",
+         "  private DaggerSimpleComponent(Builder builder) {",
+         "    assert builder != null;",
+         "    initialize(builder);",
+         "  }",
+         "",
+         "  public static Builder builder() {",
+         "    return new Builder();",
+         "  }",
+         "",
+         "  public static SimpleComponent create() {",
+         "    return new Builder().build();",
+         "  }",
+         "",
+         "  @SuppressWarnings(\"unchecked\")",
+         "  private void initialize(final Builder builder) {",
+         "    this.dProvider = new D_Factory(B_Factory.INSTANCE);",
+         "  }",
+         "",
+         "  @Override",
+         "  public D d() {",
+         "    return dProvider.get();",
+         "  }",
+         "",
+         "  public static final class Builder {",
+         "    private Builder() {",
+         "    }",
+         "",
+         "    public SimpleComponent build() {",
+         "      return new DaggerSimpleComponent(this);",
+         "    }",
+         "  }",
+         "}");
+    Compilation compilation = daggerCompiler().compile(aFile, bFile, componentFile);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerSimpleComponent")
+        .hasSourceEquivalentTo(generatedComponent);
+   }
+
+  /**
+   * We warn when generating a {@link MembersInjector} for a type post-hoc (i.e., if Dagger wasn't
+   * invoked when compiling the type). But Dagger only generates {@link MembersInjector}s for types
+   * with {@link Inject @Inject} constructors if they have any injection sites, and it only
+   * generates them for types without {@link Inject @Inject} constructors if they have local
+   * (non-inherited) injection sites. So make sure we warn in only those cases where running the
+   * Dagger processor actually generates a {@link MembersInjector}.
+   */
+  @Test
+  public void unprocessedMembersInjectorNotes() {
+    Compilation compilation =
+        javac()
+            .withOptions(
+                "-Xlint:-processing",
+                 "-Adagger.warnIfInjectionFactoryNotGeneratedUpstream=enabled")
+            .withProcessors(
+                new ElementFilteringComponentProcessor(
+                    Predicates.not(
+                        element ->
+                            MoreElements.getPackage(element)
+                                .getQualifiedName()
+                                .contentEquals("test.inject"))))
+            .compile(
+                JavaFileObjects.forSourceLines(
+                    "test.TestComponent",
+                    "package test;",
+                    "",
+                    "import dagger.Component;",
+                    "",
+                    "@Component(modules = TestModule.class)",
+                    "interface TestComponent {",
+                    "  void inject(test.inject.NoInjectMemberNoConstructor object);",
+                    "  void inject(test.inject.NoInjectMemberWithConstructor object);",
+                    "  void inject(test.inject.LocalInjectMemberNoConstructor object);",
+                    "  void inject(test.inject.LocalInjectMemberWithConstructor object);",
+                    "  void inject(test.inject.ParentInjectMemberNoConstructor object);",
+                    "  void inject(test.inject.ParentInjectMemberWithConstructor object);",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.TestModule",
+                    "package test;",
+                    "",
+                    "import dagger.Module;",
+                    "import dagger.Provides;",
+                    "",
+                    "@Module",
+                    "class TestModule {",
+                    "  @Provides static Object object() {",
+                    "    return \"object\";",
+                    "  }",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.inject.NoInjectMemberNoConstructor",
+                    "package test.inject;",
+                    "",
+                    "public class NoInjectMemberNoConstructor {",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.inject.NoInjectMemberWithConstructor",
+                    "package test.inject;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "public class NoInjectMemberWithConstructor {",
+                    "  @Inject NoInjectMemberWithConstructor() {}",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.inject.LocalInjectMemberNoConstructor",
+                    "package test.inject;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "public class LocalInjectMemberNoConstructor {",
+                    "  @Inject Object object;",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.inject.LocalInjectMemberWithConstructor",
+                    "package test.inject;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "public class LocalInjectMemberWithConstructor {",
+                    "  @Inject LocalInjectMemberWithConstructor() {}",
+                    "  @Inject Object object;",
+                    "}"),
+                JavaFileObjects.forSourceLines(
+                    "test.inject.ParentInjectMemberNoConstructor",
+                    "package test.inject;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "public class ParentInjectMemberNoConstructor",
+                    "    extends LocalInjectMemberNoConstructor {}"),
+                JavaFileObjects.forSourceLines(
+                    "test.inject.ParentInjectMemberWithConstructor",
+                    "package test.inject;",
+                    "",
+                    "import javax.inject.Inject;",
+                    "",
+                    "public class ParentInjectMemberWithConstructor",
+                    "    extends LocalInjectMemberNoConstructor {",
+                    "  @Inject ParentInjectMemberWithConstructor() {}",
+                    "}"));
+
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .hadNoteContaining(
+            "Generating a MembersInjector for "
+                + "test.inject.LocalInjectMemberNoConstructor. "
+                + "Prefer to run the dagger processor over that class instead.");
+    assertThat(compilation)
+        .hadNoteContaining(
+            "Generating a MembersInjector for "
+                + "test.inject.LocalInjectMemberWithConstructor. "
+                + "Prefer to run the dagger processor over that class instead.");
+    assertThat(compilation)
+        .hadNoteContaining(
+            "Generating a MembersInjector for "
+                + "test.inject.ParentInjectMemberWithConstructor. "
+                + "Prefer to run the dagger processor over that class instead.");
+    assertThat(compilation).hadNoteCount(3);
+  }
+
+  @Test
+  public void scopeAnnotationOnInjectConstructorNotValid() {
+    JavaFileObject aScope =
+        JavaFileObjects.forSourceLines(
+            "test.AScope",
+            "package test;",
+            "",
+            "import javax.inject.Scope;",
+            "",
+            "@Scope",
+            "@interface AScope {}");
+    JavaFileObject aClass =
+        JavaFileObjects.forSourceLines(
+            "test.AClass",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class AClass {",
+            "  @Inject @AScope AClass() {}",
+            "}");
+    Compilation compilation = daggerCompiler().compile(aScope, aClass);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@Scope annotations are not allowed on @Inject constructors.")
+        .inFile(aClass)
+        .onLine(6);
+  }
+
+  @Test
+  public void attemptToInjectWildcardGenerics() {
+    JavaFileObject testComponent =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Lazy;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  Lazy<? extends Number> wildcardNumberLazy();",
+            "  Provider<? super Number> wildcardNumberProvider();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(testComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("wildcard type").inFile(testComponent).onLine(9);
+    assertThat(compilation).hadErrorContaining("wildcard type").inFile(testComponent).onLine(10);
+  }
+
+  @Test
+  public void unusedSubcomponents_dontResolveExtraBindingsInParentComponents() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "",
+            "@Module(subcomponents = Pruned.class)",
+            "class TestModule {}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component(modules = TestModule.class)",
+            "interface Parent {}");
+
+    JavaFileObject prunedSubcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Pruned",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Pruned {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Pruned build();",
+            "  }",
+            "",
+            "  Foo foo();",
+            "}");
+    JavaFileObject generated =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParent",
+            "package test;",
+            "",
+            "import dagger.internal.Preconditions;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParent implements Parent {",
+            "  private DaggerParent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static Parent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public Parent build() {",
+            "      return new DaggerParent(this);",
+            "    }",
+            "",
+            "    @Deprecated",
+            "    public Builder testModule(TestModule testModule) {",
+            "      Preconditions.checkNotNull(testModule);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(foo, module, component, prunedSubcomponent);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerParent")
+        .hasSourceEquivalentTo(generated);
+  }
+
+  // TODO(b/34107586): Fix and enable test.
+  @Test
+  @Ignore
+  public void invalidComponentDependencies() {
+    JavaFileObject testComponent =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(dependencies = int.class)",
+            "interface TestComponent {}");
+    Compilation compilation = daggerCompiler().compile(testComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("int is not a valid component dependency type");
+  }
+
+  @Test
+  public void invalidComponentModules() {
+    JavaFileObject testComponent =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = int.class)",
+            "interface TestComponent {}");
+    Compilation compilation = daggerCompiler().compile(testComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("int is not a valid module type");
+  }
+
+  @Test
+  public void moduleInDependencies() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides String s() { return null; }",
+            "}");
+    JavaFileObject testComponent =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(dependencies = TestModule.class)",
+            "interface TestComponent {}");
+    Compilation compilation = daggerCompiler().compile(testModule, testComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("test.TestModule is a module, which cannot be a component dependency");
+  }
+
+  @Test
+  public void bindsInstanceInModule() {
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @BindsInstance abstract void str(String string);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(testModule);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@BindsInstance methods should not be included in @Modules. Did you mean @Binds");
+  }
+
+  @Test
+  public void bindsInstanceInComponent() {
+    JavaFileObject testComponent =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  @BindsInstance String s(String s);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(testComponent);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@BindsInstance methods should not be included in @Components. "
+                + "Did you mean to put it in a @Component.Builder?");
+  }
+
+  @Test
+  public void bindsInstanceNotAbstract() {
+    JavaFileObject notAbstract =
+        JavaFileObjects.forSourceLines(
+            "test.BindsInstanceNotAbstract",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Component;",
+            "",
+            "class BindsInstanceNotAbstract {",
+            "  @BindsInstance BindsInstanceNotAbstract bind(int unused) { return this; }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(notAbstract);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@BindsInstance methods must be abstract")
+        .inFile(notAbstract)
+        .onLine(7);
+  }
+
+  @Test
+  public void bindsInstanceNoParameters() {
+    JavaFileObject notAbstract =
+        JavaFileObjects.forSourceLines(
+            "test.BindsInstanceNoParameters",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "",
+            "interface BindsInstanceNoParameters {",
+            "  @BindsInstance void noParams();",
+            "}");
+    Compilation compilation = daggerCompiler().compile(notAbstract);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@BindsInstance methods should have exactly one parameter for the bound type")
+        .inFile(notAbstract)
+        .onLine(6);
+  }
+
+  @Test
+  public void bindsInstanceManyParameters() {
+    JavaFileObject notAbstract =
+        JavaFileObjects.forSourceLines(
+            "test.BindsInstanceNoParameter",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "",
+            "interface BindsInstanceManyParameters {",
+            "  @BindsInstance void manyParams(int i, long l);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(notAbstract);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@BindsInstance methods should have exactly one parameter for the bound type")
+        .inFile(notAbstract)
+        .onLine(6);
+  }
+
+  @Test
+  public void bindsInstanceFrameworkType() {
+    JavaFileObject bindsFrameworkType =
+        JavaFileObjects.forSourceLines(
+            "test.BindsInstanceFrameworkType",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.producers.Producer;",
+            "import javax.inject.Provider;",
+            "",
+            "interface BindsInstanceFrameworkType {",
+            "  @BindsInstance void bindsProvider(Provider<Object> objectProvider);",
+            "  @BindsInstance void bindsProducer(Producer<Object> objectProducer);",
+            "}");
+    Compilation compilation = daggerCompiler().compile(bindsFrameworkType);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@BindsInstance parameters may not be framework types")
+        .inFile(bindsFrameworkType)
+        .onLine(8);
+
+    assertThat(compilation)
+        .hadErrorContaining("@BindsInstance parameters may not be framework types")
+        .inFile(bindsFrameworkType)
+        .onLine(9);
+  }
+
+  private static Compiler daggerCompiler(Processor... extraProcessors) {
+    return javac().withProcessors(Lists.asList(new ComponentProcessor(), extraProcessors));
+  }
+
+  /**
+   * A {@link ComponentProcessor} that excludes elements using a {@link Predicate}.
+   */
+  private static final class ElementFilteringComponentProcessor extends AbstractProcessor {
+    private final ComponentProcessor componentProcessor = new ComponentProcessor();
+    private final Predicate<? super Element> filter;
+
+    /**
+     * Creates a {@link ComponentProcessor} that only processes elements that match {@code filter}.
+     */
+    public ElementFilteringComponentProcessor(Predicate<? super Element> filter) {
+      this.filter = filter;
+    }
+
+    @Override
+    public synchronized void init(ProcessingEnvironment processingEnv) {
+      super.init(processingEnv);
+      componentProcessor.init(processingEnv);
+    }
+
+    @Override
+    public Set<String> getSupportedAnnotationTypes() {
+      return componentProcessor.getSupportedAnnotationTypes();
+    }
+
+    @Override
+    public SourceVersion getSupportedSourceVersion() {
+      return componentProcessor.getSupportedSourceVersion();
+    }
+
+    @Override
+    public Set<String> getSupportedOptions() {
+      return componentProcessor.getSupportedOptions();
+    }
+
+    @Override
+    public boolean process(
+        Set<? extends TypeElement> annotations, final RoundEnvironment roundEnv) {
+      return componentProcessor.process(
+          annotations,
+          new RoundEnvironment() {
+            @Override
+            public boolean processingOver() {
+              return roundEnv.processingOver();
+            }
+
+            @Override
+            public Set<? extends Element> getRootElements() {
+              return Sets.filter(roundEnv.getRootElements(), filter);
+            }
+
+            @Override
+            public Set<? extends Element> getElementsAnnotatedWith(Class<? extends Annotation> a) {
+              return Sets.filter(roundEnv.getElementsAnnotatedWith(a), filter);
+            }
+
+            @Override
+            public Set<? extends Element> getElementsAnnotatedWith(TypeElement a) {
+              return Sets.filter(roundEnv.getElementsAnnotatedWith(a), filter);
+            }
+
+            @Override
+            public boolean errorRaised() {
+              return roundEnv.errorRaised();
+            }
+          });
+    }
+  }
+
+  /**
+   * A simple {@link Processor} that generates one source file.
+   */
+  private static final class GeneratingProcessor extends AbstractProcessor {
+    private final String generatedClassName;
+    private final String generatedSource;
+    private boolean processed;
+
+    GeneratingProcessor(String generatedClassName, String... source) {
+      this.generatedClassName = generatedClassName;
+      this.generatedSource = Joiner.on("\n").join(source);
+    }
+
+    @Override
+    public Set<String> getSupportedAnnotationTypes() {
+      return ImmutableSet.of("*");
+    }
+
+    @Override
+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+      if (!processed) {
+        processed = true;
+        try (Writer writer =
+                processingEnv.getFiler().createSourceFile(generatedClassName).openWriter()) {
+          writer.append(generatedSource);
+        } catch (IOException e) {
+          throw new RuntimeException(e);
+        }
+      }
+      return false;
+    }
+  }
+}
diff --git a/javatests/dagger/internal/codegen/DaggerModuleMethodSubject.java b/javatests/dagger/internal/codegen/DaggerModuleMethodSubject.java
new file mode 100644
index 000000000..a5b91de49
--- /dev/null
+++ b/javatests/dagger/internal/codegen/DaggerModuleMethodSubject.java
@@ -0,0 +1,179 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+import com.google.common.collect.FluentIterable;
+import com.google.common.collect.ImmutableList;
+import com.google.common.truth.FailureStrategy;
+import com.google.common.truth.Subject;
+import com.google.common.truth.SubjectFactory;
+import com.google.common.truth.Truth;
+import com.google.testing.compile.JavaFileObjects;
+import dagger.Module;
+import dagger.producers.ProducerModule;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.util.Arrays;
+import java.util.List;
+import javax.tools.JavaFileObject;
+
+/** A {@link Truth} subject for testing Dagger module methods. */
+final class DaggerModuleMethodSubject extends Subject<DaggerModuleMethodSubject, String> {
+
+  /** A {@link Truth} subject factory for testing Dagger module methods. */
+  static final class Factory extends SubjectFactory<DaggerModuleMethodSubject, String> {
+
+    /** Starts a clause testing a Dagger {@link Module @Module} method. */
+    static DaggerModuleMethodSubject assertThatModuleMethod(String method) {
+      return assertAbout(daggerModuleMethod())
+          .that(method)
+          .withDeclaration("@Module abstract class %s { %s }");
+    }
+
+    /** Starts a clause testing a Dagger {@link ProducerModule @ProducerModule} method. */
+    static DaggerModuleMethodSubject assertThatProductionModuleMethod(String method) {
+      return assertAbout(daggerModuleMethod())
+          .that(method)
+          .withDeclaration("@ProducerModule abstract class %s { %s }");
+    }
+
+    /** Starts a clause testing a method in an unannotated class. */
+    static DaggerModuleMethodSubject assertThatMethodInUnannotatedClass(String method) {
+      return assertAbout(daggerModuleMethod())
+          .that(method)
+          .withDeclaration("abstract class %s { %s }");
+    }
+
+    static Factory daggerModuleMethod() {
+      return new Factory();
+    }
+
+    private Factory() {}
+
+    @Override
+    public DaggerModuleMethodSubject getSubject(FailureStrategy fs, String that) {
+      return new DaggerModuleMethodSubject(fs, that);
+    }
+  }
+
+  private ImmutableList.Builder<String> imports =
+      new ImmutableList.Builder<String>()
+          .add(
+              "import dagger.*;",
+              "import dagger.multibindings.*;",
+              "import dagger.producers.*;",
+              "import java.util.*;",
+              "import javax.inject.*;");
+  private String declaration;
+  private ImmutableList<JavaFileObject> additionalSources = ImmutableList.of();
+
+  private DaggerModuleMethodSubject(FailureStrategy failureStrategy, String subject) {
+    super(failureStrategy, subject);
+  }
+
+  /**
+   * Imports classes and interfaces. Note that all types in the following packages are already
+   * imported:<ul>
+   * <li>{@code dagger.*}
+   * <li>{@code dagger.multibindings.*}
+   * <li>(@code dagger.producers.*}
+   * <li>{@code java.util.*}
+   * <li>{@code javax.inject.*}
+   * </ul>
+   */
+  DaggerModuleMethodSubject importing(Class<?>... imports) {
+    return importing(Arrays.asList(imports));
+  }
+
+  /**
+   * Imports classes and interfaces. Note that all types in the following packages are already
+   * imported:<ul>
+   * <li>{@code dagger.*}
+   * <li>{@code dagger.multibindings.*}
+   * <li>(@code dagger.producers.*}
+   * <li>{@code java.util.*}
+   * <li>{@code javax.inject.*}
+   * </ul>
+   */
+  DaggerModuleMethodSubject importing(List<? extends Class<?>> imports) {
+    imports.stream()
+        .map(clazz -> String.format("import %s;", clazz.getCanonicalName()))
+        .forEachOrdered(this.imports::add);
+    return this;
+  }
+
+  /**
+   * Sets the declaration of the module. Must be a string with two {@code %s} parameters. The first
+   * will be replaced with the name of the type, and the second with the method declaration, which
+   * must be within paired braces.
+   */
+  DaggerModuleMethodSubject withDeclaration(String declaration) {
+    this.declaration = declaration;
+    return this;
+  }
+
+  /** Additional source files that must be compiled with the module. */
+  DaggerModuleMethodSubject withAdditionalSources(JavaFileObject... sources) {
+    this.additionalSources = ImmutableList.copyOf(sources);
+    return this;
+  }
+
+  /**
+   * Fails if compiling the module with the method doesn't report an error at the method
+   * declaration whose message contains {@code errorSubstring}.
+   */
+  void hasError(String errorSubstring) {
+    String source = moduleSource();
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule", source);
+    assertAbout(javaSources())
+        .that(FluentIterable.from(additionalSources).append(module))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorSubstring)
+        .in(module)
+        .onLine(methodLine(source));
+  }
+
+  private int methodLine(String source) {
+    String beforeMethod = source.substring(0, source.indexOf(actual()));
+    int methodLine = 1;
+    for (int nextNewlineIndex = beforeMethod.indexOf('\n');
+        nextNewlineIndex >= 0;
+        nextNewlineIndex = beforeMethod.indexOf('\n', nextNewlineIndex + 1)) {
+      methodLine++;
+    }
+    return methodLine;
+  }
+
+  private String moduleSource() {
+    StringWriter stringWriter = new StringWriter();
+    PrintWriter writer = new PrintWriter(stringWriter);
+    writer.println("package test;");
+    writer.println();
+    for (String importLine : imports.build()) {
+      writer.println(importLine);
+    }
+    writer.println();
+    writer.printf(declaration, "TestModule", "\n" + actual() + "\n");
+    writer.println();
+    return stringWriter.toString();
+  }
+
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ErrorMessagesTest.java b/javatests/dagger/internal/codegen/ErrorMessagesTest.java
similarity index 100%
rename from compiler/src/test/java/dagger/internal/codegen/ErrorMessagesTest.java
rename to javatests/dagger/internal/codegen/ErrorMessagesTest.java
diff --git a/compiler/src/test/java/dagger/internal/codegen/ForReleasableReferencesValidatorTest.java b/javatests/dagger/internal/codegen/ForReleasableReferencesValidatorTest.java
similarity index 100%
rename from compiler/src/test/java/dagger/internal/codegen/ForReleasableReferencesValidatorTest.java
rename to javatests/dagger/internal/codegen/ForReleasableReferencesValidatorTest.java
diff --git a/compiler/src/test/java/dagger/internal/codegen/FrameworkFieldTest.java b/javatests/dagger/internal/codegen/FrameworkFieldTest.java
similarity index 100%
rename from compiler/src/test/java/dagger/internal/codegen/FrameworkFieldTest.java
rename to javatests/dagger/internal/codegen/FrameworkFieldTest.java
diff --git a/compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java b/javatests/dagger/internal/codegen/GeneratedLines.java
similarity index 100%
rename from compiler/src/test/java/dagger/internal/codegen/GeneratedLines.java
rename to javatests/dagger/internal/codegen/GeneratedLines.java
diff --git a/compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java b/javatests/dagger/internal/codegen/GraphValidationScopingTest.java
similarity index 100%
rename from compiler/src/test/java/dagger/internal/codegen/GraphValidationScopingTest.java
rename to javatests/dagger/internal/codegen/GraphValidationScopingTest.java
diff --git a/javatests/dagger/internal/codegen/GraphValidationTest.java b/javatests/dagger/internal/codegen/GraphValidationTest.java
new file mode 100644
index 000000000..949c0c1c5
--- /dev/null
+++ b/javatests/dagger/internal/codegen/GraphValidationTest.java
@@ -0,0 +1,2533 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubject.assertThat;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.ErrorMessages.nullableToNonNullable;
+
+import com.google.common.base.Joiner;
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import java.util.Arrays;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class GraphValidationTest {
+  private static final JavaFileObject NULLABLE =
+      JavaFileObjects.forSourceLines(
+          "test.Nullable", // force one-string-per-line format
+          "package test;",
+          "",
+          "public @interface Nullable {}");
+
+  @Test public void componentOnConcreteClass() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.MyComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface MyComponent {",
+        "  Foo getFoo();",
+        "}");
+    JavaFileObject injectable = JavaFileObjects.forSourceLines("test.Foo",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class Foo {",
+        "  @Inject Foo(Bar bar) {}",
+        "}");
+    JavaFileObject nonInjectable = JavaFileObjects.forSourceLines("test.Bar",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "interface Bar {}");
+    assertAbout(javaSources()).that(Arrays.asList(component, injectable, nonInjectable))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("test.Bar cannot be provided without an @Provides-annotated method.")
+            .in(component).onLine(7);
+  }
+
+  @Test public void componentProvisionWithNoDependencyChain() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestClass",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Qualifier;",
+            "",
+            "final class TestClass {",
+            "  @Qualifier @interface Q {}",
+            "  interface A {}",
+            "",
+            "  @Component()",
+            "  interface AComponent {",
+            "    A getA();",
+            "    @Q A qualifiedA();",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "test.TestClass.A cannot be provided without an @Provides-annotated method.")
+        .in(component)
+        .onLine(12)
+        .and()
+        .withErrorContaining(
+            "@test.TestClass.Q test.TestClass.A "
+                + "cannot be provided without an @Provides-annotated method.")
+        .in(component)
+        .onLine(13);
+  }
+
+  @Test public void constructorInjectionWithoutAnnotation() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class TestClass {",
+        "  static class A {",
+        "    A() {}",
+        "  }",
+        "",
+        "  @Component()",
+        "  interface AComponent {",
+        "    A getA();",
+        "  }",
+        "}");
+    String expectedError = "test.TestClass.A cannot be provided without an "
+        + "@Inject constructor or from an @Provides-annotated method.";
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(15);
+  }
+
+  @Test public void membersInjectWithoutProvision() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class TestClass {",
+        "  static class A {",
+        "    @Inject A() {}",
+        "  }",
+        "",
+        "  static class B {",
+        "    @Inject A a;",
+        "  }",
+        "",
+        "  @Component()",
+        "  interface AComponent {",
+        "    B getB();",
+        "  }",
+        "}");
+    String expectedError = "test.TestClass.B cannot be provided without an "
+        + "@Inject constructor or from an @Provides-annotated method. "
+        + "This type supports members injection but cannot be implicitly provided.";
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(19);
+  }
+
+  @Test
+  public void membersInjectDependsOnUnboundedType() {
+    JavaFileObject injectsUnboundedType =
+        JavaFileObjects.forSourceLines(
+            "test.InjectsUnboundedType",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import java.util.ArrayList;",
+            "import javax.inject.Inject;",
+            "",
+            "class InjectsUnboundedType {",
+            "  @Inject MembersInjector<ArrayList<?>> listInjector;",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  void injectsUnboundedType(InjectsUnboundedType injects);",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(injectsUnboundedType, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            Joiner.on('\n')
+                .join(
+                    "Type parameters must be bounded for members injection."
+                        + " ? required by java.util.ArrayList<?>, via:",
+                    "      dagger.MembersInjector<java.util.ArrayList<?>> is injected at",
+                    "          test.InjectsUnboundedType.listInjector",
+                    "      test.InjectsUnboundedType is injected at",
+                    "          test.TestComponent.injectsUnboundedType(injects)"))
+        .in(component)
+        .onLine(7);
+  }
+
+  @Test
+  public void invalidMembersInjection() {
+    JavaFileObject injected =
+        JavaFileObjects.forSourceLines(
+            "test.Injected",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class Injected {",
+            "  @Inject static Object object;",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  void inject(Injected injected);",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(injected, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("static fields")
+        .in(injected)
+        .onLine(6);
+  }
+
+  @Test public void cyclicDependency() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class Outer {",
+        "  static class A {",
+        "    @Inject A(C cParam) {}",
+        "  }",
+        "",
+        "  static class B {",
+        "    @Inject B(A aParam) {}",
+        "  }",
+        "",
+        "  static class C {",
+        "    @Inject C(B bParam) {}",
+        "  }",
+        "",
+        "  @Component()",
+        "  interface CComponent {",
+        "    C getC();",
+        "  }",
+        "}");
+
+    String expectedError =
+        Joiner.on('\n')
+            .join(
+                "Found a dependency cycle:",
+                "      test.Outer.C is injected at",
+                "          test.Outer.A.<init>(cParam)",
+                "      test.Outer.A is injected at",
+                "          test.Outer.B.<init>(aParam)",
+                "      test.Outer.B is injected at",
+                "          test.Outer.C.<init>(bParam)",
+                "      test.Outer.C is provided at",
+                "          test.Outer.CComponent.getC()");
+
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(23);
+  }
+
+  @Test public void cyclicDependencyNotIncludingEntryPoint() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(C cParam) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(A aParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(B bParam) {}",
+            "  }",
+            "",
+            "  static class D {",
+            "    @Inject D(C cParam) {}",
+            "  }",
+            "",
+            "  @Component()",
+            "  interface DComponent {",
+            "    D getD();",
+            "  }",
+            "}");
+
+    String expectedError =
+        Joiner.on('\n')
+            .join(
+                "Found a dependency cycle:",
+                "      test.Outer.C is injected at",
+                "          test.Outer.A.<init>(cParam)",
+                "      test.Outer.A is injected at",
+                "          test.Outer.B.<init>(aParam)",
+                "      test.Outer.B is injected at",
+                "          test.Outer.C.<init>(bParam)",
+                "      test.Outer.C is injected at",
+                "          test.Outer.D.<init>(cParam)",
+                "      test.Outer.D is provided at",
+                "          test.Outer.DComponent.getD()");
+
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError)
+        .in(component)
+        .onLine(27);
+  }
+
+  @Test
+  public void cyclicDependencyNotBrokenByMapBinding() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.MapKey;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "import java.util.Map;",
+            "import javax.inject.Inject;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(Map<String, C> cMap) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(A aParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(B bParam) {}",
+            "  }",
+            "",
+            "  @Component(modules = CModule.class)",
+            "  interface CComponent {",
+            "    C getC();",
+            "  }",
+            "",
+            "  @Module",
+            "  static class CModule {",
+            "    @Provides @IntoMap",
+            "    @StringKey(\"C\")",
+            "    static C c(C c) {",
+            "      return c;",
+            "    }",
+            "  }",
+            "",
+            "  @MapKey",
+            "  @interface StringKey {",
+            "    String value();",
+            "  }",
+            "}");
+
+    String expectedError =
+        Joiner.on('\n')
+            .join(
+                "Found a dependency cycle:",
+                "      test.Outer.C is injected at",
+                "          test.Outer.CModule.c(c)",
+                "      java.util.Map<java.lang.String,test.Outer.C> is injected at",
+                "          test.Outer.A.<init>(cMap)",
+                "      test.Outer.A is injected at",
+                "          test.Outer.B.<init>(aParam)",
+                "      test.Outer.B is injected at",
+                "          test.Outer.C.<init>(bParam)",
+                "      test.Outer.C is provided at",
+                "          test.Outer.CComponent.getC()");
+
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError)
+        .in(component)
+        .onLine(26);
+  }
+
+  @Test
+  public void cyclicDependencyWithSetBinding() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import java.util.Set;",
+            "import javax.inject.Inject;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(Set<C> cSet) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(A aParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(B bParam) {}",
+            "  }",
+            "",
+            "  @Component(modules = CModule.class)",
+            "  interface CComponent {",
+            "    C getC();",
+            "  }",
+            "",
+            "  @Module",
+            "  static class CModule {",
+            "    @Provides @IntoSet",
+            "    static C c(C c) {",
+            "      return c;",
+            "    }",
+            "  }",
+            "}");
+
+    String expectedError =
+        Joiner.on('\n')
+            .join(
+                "Found a dependency cycle:",
+                "      test.Outer.C is injected at",
+                "          test.Outer.CModule.c(c)",
+                "      java.util.Set<test.Outer.C> is injected at",
+                "          test.Outer.A.<init>(cSet)",
+                "      test.Outer.A is injected at",
+                "          test.Outer.B.<init>(aParam)",
+                "      test.Outer.B is injected at",
+                "          test.Outer.C.<init>(bParam)",
+                "      test.Outer.C is provided at",
+                "          test.Outer.CComponent.getC()");
+
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError)
+        .in(component)
+        .onLine(25);
+  }
+
+  @Test
+  public void falsePositiveCyclicDependencyIndirectionDetected() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class Outer {",
+            "  static class A {",
+            "    @Inject A(C cParam) {}",
+            "  }",
+            "",
+            "  static class B {",
+            "    @Inject B(A aParam) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject C(B bParam) {}",
+            "  }",
+            "",
+            "  static class D {",
+            "    @Inject D(Provider<C> cParam) {}",
+            "  }",
+            "",
+            "  @Component()",
+            "  interface DComponent {",
+            "    D getD();",
+            "  }",
+            "}");
+
+    String expectedError =
+        Joiner.on('\n')
+            .join(
+                "Found a dependency cycle:",
+                "      test.Outer.C is injected at",
+                "          test.Outer.A.<init>(cParam)",
+                "      test.Outer.A is injected at",
+                "          test.Outer.B.<init>(aParam)",
+                "      test.Outer.B is injected at",
+                "          test.Outer.C.<init>(bParam)",
+                "      javax.inject.Provider<test.Outer.C> is injected at",
+                "          test.Outer.D.<init>(cParam)",
+                "      test.Outer.D is provided at",
+                "          test.Outer.DComponent.getD()");
+
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError)
+        .in(component)
+        .onLine(28);
+  }
+
+  @Test
+  public void cyclicDependencyInSubcomponents() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface Child {",
+            "  Grandchild grandchild();",
+            "}");
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GrandchildModule.class)",
+            "interface Grandchild {",
+            "  String entry();",
+            "}");
+    JavaFileObject childModule =
+        JavaFileObjects.forSourceLines(
+            "test.ChildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class ChildModule {",
+            "  @Provides static Object object(String string) {",
+            "    return string;",
+            "  }",
+            "}");
+    JavaFileObject grandchildModule =
+        JavaFileObjects.forSourceLines(
+            "test.GrandchildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class GrandchildModule {",
+            "  @Provides static String string(Object object) {",
+            "    return object.toString();",
+            "  }",
+            "}");
+
+    String expectedError =
+        Joiner.on('\n')
+            .join(
+                "[test.Grandchild.entry()] Found a dependency cycle:",
+                "      java.lang.String is injected at",
+                "          test.ChildModule.object(string)",
+                "      java.lang.Object is injected at",
+                "          test.GrandchildModule.string(object)",
+                "      java.lang.String is provided at",
+                "          test.Grandchild.entry()");
+
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, child, grandchild, childModule, grandchildModule))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError)
+        .in(child)
+        .onLine(6);
+  }
+
+  @Test
+  public void circularBindsMethods() {
+    JavaFileObject qualifier =
+        JavaFileObjects.forSourceLines(
+            "test.SomeQualifier",
+            "package test;",
+            "",
+            "import javax.inject.Qualifier;",
+            "",
+            "@Qualifier @interface SomeQualifier {}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Binds abstract Object bindUnqualified(@SomeQualifier Object qualified);",
+            "  @Binds @SomeQualifier abstract Object bindQualified(Object unqualified);",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  Object unqualified();",
+            "  @SomeQualifier Object qualified();",
+            "}");
+
+    assertThat(qualifier, module, component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "Found a dependency cycle:\n"
+                + "      java.lang.Object is injected at\n"
+                + "          test.TestModule.bindQualified(unqualified)\n"
+                + "      @test.SomeQualifier java.lang.Object is injected at\n"
+                + "          test.TestModule.bindUnqualified(qualified)\n"
+                + "      java.lang.Object is provided at\n"
+                + "          test.TestComponent.unqualified()")
+        .in(component)
+        .onLine(7)
+        .and()
+        .withErrorContaining(
+            "Found a dependency cycle:\n"
+                + "      @test.SomeQualifier java.lang.Object is injected at\n"
+                + "          test.TestModule.bindUnqualified(qualified)\n"
+                + "      java.lang.Object is injected at\n"
+                + "          test.TestModule.bindQualified(unqualified)\n"
+                + "      @test.SomeQualifier java.lang.Object is provided at\n"
+                + "          test.TestComponent.qualified()")
+        .in(component)
+        .onLine(8);
+  }
+
+  @Test
+  public void selfReferentialBinds() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Binds abstract Object bindToSelf(Object sameKey);",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  Object selfReferential();",
+            "}");
+
+    assertThat(module, component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            // TODO(gak): cl/126230644 produces a better error message in this case. Here it isn't
+            // unclear what is going wrong.
+            "Found a dependency cycle:\n"
+                + "      java.lang.Object is injected at\n"
+                + "          test.TestModule.bindToSelf(sameKey)\n"
+                + "      java.lang.Object is provided at\n"
+                + "          test.TestComponent.selfReferential()")
+        .in(component)
+        .onLine(7);
+  }
+
+  @Test public void duplicateExplicitBindings_ProvidesAndComponentProvision() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "final class Outer {",
+        "  interface A {}",
+        "",
+        "  interface B {}",
+        "",
+        "  @Module",
+        "  static class AModule {",
+        "    @Provides String provideString() { return \"\"; }",
+        "    @Provides A provideA(String s) { return new A() {}; }",
+        "  }",
+        "",
+        "  @Component(modules = AModule.class)",
+        "  interface Parent {",
+        "    A getA();",
+        "  }",
+        "",
+        "  @Module",
+        "  static class BModule {",
+        "    @Provides B provideB(A a) { return new B() {}; }",
+        "  }",
+        "",
+        "  @Component(dependencies = Parent.class, modules = { BModule.class, AModule.class})",
+        "  interface Child {",
+        "    B getB();",
+        "  }",
+        "}");
+
+    String expectedError = "test.Outer.A is bound multiple times:\n"
+        + "      test.Outer.A test.Outer.Parent.getA()\n"
+        + "      @Provides test.Outer.A test.Outer.AModule.provideA(String)";
+
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(30);
+  }
+
+  @Test public void duplicateExplicitBindings_TwoProvidesMethods() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class Outer {",
+        "  interface A {}",
+        "",
+        "  @Module",
+        "  static class Module1 {",
+        "    @Provides A provideA1() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module2 {",
+        "    @Provides String provideString() { return \"\"; }",
+        "    @Provides A provideA2(String s) { return new A() {}; }",
+        "  }",
+        "",
+        "  @Component(modules = { Module1.class, Module2.class})",
+        "  interface TestComponent {",
+        "    A getA();",
+        "  }",
+        "}");
+
+    String expectedError = "test.Outer.A is bound multiple times:\n"
+        + "      @Provides test.Outer.A test.Outer.Module1.provideA1()\n"
+        + "      @Provides test.Outer.A test.Outer.Module2.provideA2(String)";
+
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(24);
+  }
+
+  @Test
+  public void duplicateExplicitBindings_ProvidesVsBinds() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "final class Outer {",
+            "  interface A {}",
+            "",
+            "  static final class B implements A {",
+            "    @Inject B() {}",
+            "  }",
+            "",
+            "  @Module",
+            "  static class Module1 {",
+            "    @Provides A provideA1() { return new A() {}; }",
+            "  }",
+            "",
+            "  @Module",
+            "  static abstract class Module2 {",
+            "    @Binds abstract A bindA2(B b);",
+            "  }",
+            "",
+            "  @Component(modules = { Module1.class, Module2.class})",
+            "  interface TestComponent {",
+            "    A getA();",
+            "  }",
+            "}");
+
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            Joiner.on("\n      ")
+                .join(
+                    "test.Outer.A is bound multiple times:",
+                    "@Provides test.Outer.A test.Outer.Module1.provideA1()",
+                    "@Binds test.Outer.A test.Outer.Module2.bindA2(test.Outer.B)"))
+        .in(component)
+        .onLine(28);
+  }
+
+  @Test public void duplicateExplicitBindings_MultipleProvisionTypes() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Binds;",
+        "import dagger.Component;",
+        "import dagger.MapKey;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.MapKey;",
+        "import dagger.multibindings.IntoMap;",
+        "import dagger.multibindings.IntoSet;",
+        "import java.util.HashMap;",
+        "import java.util.HashSet;",
+        "import java.util.Map;",
+        "import java.util.Set;",
+        "import javax.inject.Qualifier;",
+        "",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "final class Outer {",
+        "  @MapKey(unwrapValue = true)",
+        "  @interface StringKey {",
+        "    String value();",
+        "  }",
+        "",
+        "  @Qualifier @interface SomeQualifier {}",
+        "",
+        "  @Module",
+        "  abstract static class TestModule1 {",
+        "    @Provides @IntoMap",
+        "    @StringKey(\"foo\")",
+        "    static String stringMapEntry() { return \"\"; }",
+        "",
+        "    @Binds @IntoMap @StringKey(\"bar\")",
+        "    abstract String bindStringMapEntry(@SomeQualifier String value);",
+        "",
+        "    @Provides @IntoSet static String stringSetElement() { return \"\"; }",
+        "    @Binds @IntoSet abstract String bindStringSetElement(@SomeQualifier String value);",
+        "",
+        "    @Provides @SomeQualifier static String provideSomeQualifiedString() { return \"\"; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class TestModule2 {",
+        "    @Provides Set<String> stringSet() { return new HashSet<String>(); }",
+        "",
+        "    @Provides Map<String, String> stringMap() {",
+        "      return new HashMap<String, String>();",
+        "    }",
+        "  }",
+        "",
+        "  @Component(modules = { TestModule1.class, TestModule2.class })",
+        "  interface TestComponent {",
+        "    Set<String> getStringSet();",
+        "    Map<String, String> getStringMap();",
+        "  }",
+        "}");
+
+    String expectedSetError =
+        "java.util.Set<java.lang.String> has incompatible bindings or declarations:\n"
+            + "      Set bindings and declarations:\n"
+            + "          @Provides @dagger.multibindings.IntoSet String "
+            + "test.Outer.TestModule1.stringSetElement()\n"
+            + "          @Binds @dagger.multibindings.IntoSet String "
+            + "test.Outer.TestModule1.bindStringSetElement(@test.Outer.SomeQualifier String)\n"
+            + "      Unique bindings and declarations:\n"
+            + "          @Provides Set<String> test.Outer.TestModule2.stringSet()";
+
+    String expectedMapError =
+        "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
+            + "or declarations:\n"
+            + "      Map bindings and declarations:\n"
+            + "          @Provides @dagger.multibindings.IntoMap "
+            + "@test.Outer.StringKey(\"foo\") String"
+            + " test.Outer.TestModule1.stringMapEntry()\n"
+            + "          @Binds @dagger.multibindings.IntoMap "
+            + "@test.Outer.StringKey(\"bar\") String"
+            + " test.Outer.TestModule1.bindStringMapEntry(@test.Outer.SomeQualifier String)\n"
+            + "      Unique bindings and declarations:\n"
+            + "          @Provides Map<String,String> test.Outer.TestModule2.stringMap()";
+
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedSetError)
+        .in(component)
+        .onLine(52)
+        .and()
+        .withErrorContaining(expectedMapError)
+        .in(component)
+        .onLine(53);
+  }
+
+  @Test
+  public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Outer",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.Multibinds;",
+            "import java.util.HashMap;",
+            "import java.util.HashSet;",
+            "import java.util.Map;",
+            "import java.util.Set;",
+            "",
+            "final class Outer {",
+            "  @Module",
+            "  abstract static class TestModule1 {",
+            "    @Multibinds abstract Map<String, String> stringMap();",
+            "    @Multibinds abstract Set<String> stringSet();",
+            "  }",
+            "",
+            "  @Module",
+            "  static class TestModule2 {",
+            "    @Provides Set<String> stringSet() { return new HashSet<String>(); }",
+            "",
+            "    @Provides Map<String, String> stringMap() {",
+            "      return new HashMap<String, String>();",
+            "    }",
+            "  }",
+            "",
+            "  @Component(modules = { TestModule1.class, TestModule2.class })",
+            "  interface TestComponent {",
+            "    Set<String> getStringSet();",
+            "    Map<String, String> getStringMap();",
+            "  }",
+            "}");
+
+    String expectedSetError =
+        "java.util.Set<java.lang.String> has incompatible bindings or declarations:\n"
+            + "      Set bindings and declarations:\n"
+            + "          @dagger.multibindings.Multibinds Set<String> "
+            + "test.Outer.TestModule1.stringSet()\n"
+            + "      Unique bindings and declarations:\n"
+            + "          @Provides Set<String> test.Outer.TestModule2.stringSet()";
+
+    String expectedMapError =
+        "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
+            + "or declarations:\n"
+            + "      Map bindings and declarations:\n"
+            + "          @dagger.multibindings.Multibinds Map<String,String> "
+            + "test.Outer.TestModule1.stringMap()\n"
+            + "      Unique bindings and declarations:\n"
+            + "          @Provides Map<String,String> test.Outer.TestModule2.stringMap()";
+
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedSetError)
+        .in(component)
+        .onLine(32)
+        .and()
+        .withErrorContaining(expectedMapError)
+        .in(component)
+        .onLine(33);
+  }
+
+  @Test public void duplicateBindings_TruncateAfterLimit() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "final class Outer {",
+        "  interface A {}",
+        "",
+        "  @Module",
+        "  static class Module1 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module2 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module3 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module4 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module5 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module6 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module7 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module8 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module9 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module10 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module11 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Module",
+        "  static class Module12 {",
+        "    @Provides A provideA() { return new A() {}; }",
+        "  }",
+        "",
+        "  @Component(modules = {",
+        "    Module1.class,",
+        "    Module2.class,",
+        "    Module3.class,",
+        "    Module4.class,",
+        "    Module5.class,",
+        "    Module6.class,",
+        "    Module7.class,",
+        "    Module8.class,",
+        "    Module9.class,",
+        "    Module10.class,",
+        "    Module11.class,",
+        "    Module12.class",
+        "  })",
+        "  interface TestComponent {",
+        "    A getA();",
+        "  }",
+        "}");
+
+    String expectedError = "test.Outer.A is bound multiple times:\n"
+        + "      @Provides test.Outer.A test.Outer.Module1.provideA()\n"
+        + "      @Provides test.Outer.A test.Outer.Module2.provideA()\n"
+        + "      @Provides test.Outer.A test.Outer.Module3.provideA()\n"
+        + "      @Provides test.Outer.A test.Outer.Module4.provideA()\n"
+        + "      @Provides test.Outer.A test.Outer.Module5.provideA()\n"
+        + "      @Provides test.Outer.A test.Outer.Module6.provideA()\n"
+        + "      @Provides test.Outer.A test.Outer.Module7.provideA()\n"
+        + "      @Provides test.Outer.A test.Outer.Module8.provideA()\n"
+        + "      @Provides test.Outer.A test.Outer.Module9.provideA()\n"
+        + "      @Provides test.Outer.A test.Outer.Module10.provideA()\n"
+        + "      and 2 others";
+
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedError).in(component).onLine(86);
+  }
+
+  @Test public void longChainOfDependencies() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestClass",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Lazy;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Named;",
+            "import javax.inject.Provider;",
+            "",
+            "final class TestClass {",
+            "  interface A {}",
+            "",
+            "  static class B {",
+            "    @Inject B(A a) {}",
+            "  }",
+            "",
+            "  static class C {",
+            "    @Inject B b;",
+            "    @Inject C(X x, B b) {}",
+            "  }",
+            "",
+            "  interface D { }",
+            "",
+            "  static class DImpl implements D {",
+            "    @Inject DImpl(C c, B b) {}",
+            "  }",
+            "",
+            "  static class X {",
+            "    @Inject X() {}",
+            "  }",
+            "",
+            "  @Module",
+            "  static class DModule {",
+            "    @Provides @Named(\"slim shady\") D d(X x1, DImpl impl, X x2) { return impl; }",
+            "  }",
+            "",
+            "  @Component(modules = { DModule.class })",
+            "  interface AComponent {",
+            "    @Named(\"slim shady\") D getFoo();",
+            "    C injectC(C c);",
+            "    Provider<C> cProvider();",
+            "    Lazy<C> lazyC();",
+            "    Provider<Lazy<C>> lazyCProvider();",
+            "  }",
+            "}");
+    String errorText = "test.TestClass.A cannot be provided without an @Provides-annotated method.";
+    String firstError =
+        Joiner.on("\n      ")
+            .join(
+                errorText,
+                "test.TestClass.A is injected at",
+                "    test.TestClass.B.<init>(a)",
+                "test.TestClass.B is injected at",
+                "    test.TestClass.C.b",
+                "test.TestClass.C is injected at",
+                "    test.TestClass.DImpl.<init>(c, )",
+                "test.TestClass.DImpl is injected at",
+                "    test.TestClass.DModule.d(, impl, )",
+                "@javax.inject.Named(\"slim shady\") test.TestClass.D is provided at",
+                "    test.TestClass.AComponent.getFoo()");
+    String otherErrorFormat =
+        Joiner.on("\n      ")
+            .join(
+                errorText,
+                "test.TestClass.A is injected at",
+                "    test.TestClass.B.<init>(a)",
+                "test.TestClass.B is injected at",
+                "    test.TestClass.C.b",
+                "test.TestClass.C is %s at",
+                "    test.TestClass.AComponent.%s");
+    assertAbout(javaSource())
+        .that(component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(firstError)
+        .in(component)
+        .onLine(40)
+        .and()
+        .withErrorContaining(String.format(otherErrorFormat, "injected", "injectC(c)"))
+        .in(component)
+        .onLine(41)
+        .and()
+        .withErrorContaining(String.format(otherErrorFormat, "provided", "cProvider()"))
+        .in(component)
+        .onLine(42)
+        .and()
+        .withErrorContaining(String.format(otherErrorFormat, "provided", "lazyC()"))
+        .in(component)
+        .onLine(43)
+        .and()
+        .withErrorContaining(String.format(otherErrorFormat, "provided", "lazyCProvider()"))
+        .in(component)
+        .onLine(44);
+  }
+
+  @Test
+  public void bindsMethodAppearsInTrace() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "TestComponent",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  TestInterface testInterface();",
+            "}");
+    JavaFileObject interfaceFile =
+        JavaFileObjects.forSourceLines("TestInterface", "interface TestInterface {}");
+    JavaFileObject implementationFile =
+        JavaFileObjects.forSourceLines(
+            "TestImplementation",
+            "import javax.inject.Inject;",
+            "",
+            "final class TestImplementation implements TestInterface {",
+            "  @Inject TestImplementation(String missingBinding) {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "TestModule",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @Binds abstract TestInterface bindTestInterface(TestImplementation implementation);",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(component, module, interfaceFile, implementationFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            Joiner.on("\n      ")
+                .join(
+                    "java.lang.String cannot be provided without an @Inject constructor or from "
+                        + "an @Provides-annotated method.",
+                    "java.lang.String is injected at",
+                    "    TestImplementation.<init>(missingBinding)",
+                    "TestImplementation is injected at",
+                    "    TestModule.bindTestInterface(implementation)",
+                    "TestInterface is provided at",
+                    "    TestComponent.testInterface()"))
+        .in(component)
+        .onLine(5);
+  }
+
+  @Test
+  public void bindsMissingRightHandSide() {
+    JavaFileObject duplicates =
+        JavaFileObjects.forSourceLines(
+            "test.Duplicates",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.multibindings.IntKey;",
+            "import dagger.multibindings.IntoSet;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.multibindings.LongKey;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "interface Duplicates {",
+            "",
+            "  interface BoundTwice {}",
+            "",
+            "  class BoundImpl implements BoundTwice {",
+            "    @Inject BoundImpl() {}",
+            "  }",
+            "",
+            "  class NotBound implements BoundTwice {}",
+            "",
+            "  @Module",
+            "  abstract class DuplicatesModule {",
+            "    @Binds abstract BoundTwice bindWithResolvedKey(BoundImpl impl);",
+            "    @Binds abstract BoundTwice bindWithUnresolvedKey(NotBound notBound);",
+            "",
+            "    @Binds abstract Object bindObject(NotBound notBound);",
+            "",
+            "    @Binds @IntoSet abstract BoundTwice bindWithUnresolvedKey_set(NotBound notBound);",
+            "",
+            "    @Binds @IntoMap @IntKey(1)",
+            "    abstract BoundTwice bindWithUnresolvedKey_intMap(NotBound notBound);",
+            "",
+            "    @Provides @IntoMap @LongKey(2L)",
+            "    static BoundTwice provideWithUnresolvedKey_longMap(BoundImpl impl) {",
+            "      return impl;",
+            "    }",
+            "    @Binds @IntoMap @LongKey(2L)",
+            "    abstract BoundTwice bindWithUnresolvedKey_longMap(NotBound notBound);",
+            "  }",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Set;",
+            "import java.util.Map;",
+            "import test.Duplicates.BoundTwice;",
+            "",
+            "@Component(modules = Duplicates.DuplicatesModule.class)",
+            "interface C {",
+            "  BoundTwice boundTwice();",
+            "  Object object();",
+            "  Set<BoundTwice> set();",
+            "  Map<Integer, BoundTwice> intMap();",
+            "  Map<Long, BoundTwice> longMap();",
+            "}");
+
+    assertThat(duplicates, component)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("test.Duplicates.BoundTwice is bound multiple times:")
+            .in(component).onLine(10)
+        .and().withErrorContaining("test.Duplicates.DuplicatesModule.bindWithUnresolvedKey")
+            .in(component).onLine(10)
+        .and().withErrorContaining("test.Duplicates.NotBound cannot be provided")
+            .in(component).onLine(11)
+        .and().withErrorContaining("test.Duplicates.NotBound cannot be provided")
+            .in(component).onLine(12)
+        .and().withErrorContaining("test.Duplicates.NotBound cannot be provided")
+            .in(component).onLine(13)
+        .and().withErrorContaining("same map key is bound more than once")
+            .in(component).onLine(14);
+  }
+
+  @Test public void resolvedParametersInDependencyTrace() {
+    JavaFileObject generic = JavaFileObjects.forSourceLines("test.Generic",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "final class Generic<T> {",
+        "  @Inject Generic(T t) {}",
+        "}");
+    JavaFileObject testClass = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import java.util.List;",
+        "",
+        "final class TestClass {",
+        "  @Inject TestClass(List list) {}",
+        "}");
+    JavaFileObject usesTest = JavaFileObjects.forSourceLines("test.UsesTest",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class UsesTest {",
+        "  @Inject UsesTest(Generic<TestClass> genericTestClass) {}",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  UsesTest usesTest();",
+        "}");
+    String expectedMsg =
+        Joiner.on("\n")
+            .join(
+                "java.util.List cannot be provided without an @Provides-annotated method.",
+                "      java.util.List is injected at",
+                "          test.TestClass.<init>(list)",
+                "      test.TestClass is injected at",
+                "          test.Generic.<init>(t)",
+                "      test.Generic<test.TestClass> is injected at",
+                "          test.UsesTest.<init>(genericTestClass)",
+                "      test.UsesTest is provided at",
+                "          test.TestComponent.usesTest()");
+    assertAbout(javaSources()).that(ImmutableList.of(generic, testClass, usesTest, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedMsg);
+  }
+
+  @Test public void resolvedVariablesInDependencyTrace() {
+    JavaFileObject generic = JavaFileObjects.forSourceLines("test.Generic",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "final class Generic<T> {",
+        "  @Inject T t;",
+        "  @Inject Generic() {}",
+        "}");
+    JavaFileObject testClass = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "import java.util.List;",
+        "",
+        "final class TestClass {",
+        "  @Inject TestClass(List list) {}",
+        "}");
+    JavaFileObject usesTest = JavaFileObjects.forSourceLines("test.UsesTest",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class UsesTest {",
+        "  @Inject UsesTest(Generic<TestClass> genericTestClass) {}",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  UsesTest usesTest();",
+        "}");
+    String expectedMsg =
+        Joiner.on("\n")
+            .join(
+                "java.util.List cannot be provided without an @Provides-annotated method.",
+                "      java.util.List is injected at",
+                "          test.TestClass.<init>(list)",
+                "      test.TestClass is injected at",
+                "          test.Generic.t",
+                "      test.Generic<test.TestClass> is injected at",
+                "          test.UsesTest.<init>(genericTestClass)",
+                "      test.UsesTest is provided at",
+                "          test.TestComponent.usesTest()");
+    assertAbout(javaSources()).that(ImmutableList.of(generic, testClass, usesTest, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(expectedMsg);
+  }
+
+  @Test public void nullCheckForConstructorParameters() {
+    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A(String string) {}",
+        "}");
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "@dagger.Module",
+        "final class TestModule {",
+        "  @Nullable @Provides String provideString() { return null; }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  A a();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
+
+    // but if we disable the validation, then it compiles fine.
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
+        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
+  @Test public void nullCheckForMembersInjectParam() {
+    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A() {}",
+        "  @Inject void register(String string) {}",
+        "}");
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "@dagger.Module",
+        "final class TestModule {",
+        "  @Nullable @Provides String provideString() { return null; }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  A a();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
+
+    // but if we disable the validation, then it compiles fine.
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
+        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
+  @Test public void nullCheckForVariable() {
+    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject String string;",
+        "  @Inject A() {}",
+        "}");
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "@dagger.Module",
+        "final class TestModule {",
+        "  @Nullable @Provides String provideString() { return null; }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  A a();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
+
+    // but if we disable the validation, then it compiles fine.
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))
+        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
+  @Test public void nullCheckForComponentReturn() {
+    JavaFileObject module = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Provides;",
+        "import javax.inject.Inject;",
+        "",
+        "@dagger.Module",
+        "final class TestModule {",
+        "  @Nullable @Provides String provideString() { return null; }",
+        "}");
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(modules = TestModule.class)",
+        "interface TestComponent {",
+        "  String string();",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, module, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
+
+    // but if we disable the validation, then it compiles fine.
+    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, module, component))
+        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
+  @Test
+  public void nullCheckForOptionalInstance() {
+    JavaFileObject a =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import javax.inject.Inject;",
+            "",
+            "final class A {",
+            "  @Inject A(Optional<String> optional) {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "@dagger.Module",
+            "abstract class TestModule {",
+            "  @Nullable @Provides static String provideString() { return null; }",
+            "  @BindsOptionalOf abstract String optionalString();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  A a();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(NULLABLE, a, module, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            nullableToNonNullable(
+                "java.lang.String",
+                "@test.Nullable @Provides String test.TestModule.provideString()"));
+  }
+
+  @Test
+  public void nullCheckForOptionalProvider() {
+    JavaFileObject a =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class A {",
+            "  @Inject A(Optional<Provider<String>> optional) {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "@dagger.Module",
+            "abstract class TestModule {",
+            "  @Nullable @Provides static String provideString() { return null; }",
+            "  @BindsOptionalOf abstract String optionalString();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  A a();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(NULLABLE, a, module, component))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
+  @Test
+  public void nullCheckForOptionalLazy() {
+    JavaFileObject a =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import dagger.Lazy;",
+            "import javax.inject.Inject;",
+            "",
+            "final class A {",
+            "  @Inject A(Optional<Lazy<String>> optional) {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "@dagger.Module",
+            "abstract class TestModule {",
+            "  @Nullable @Provides static String provideString() { return null; }",
+            "  @BindsOptionalOf abstract String optionalString();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  A a();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(NULLABLE, a, module, component))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
+  @Test
+  public void nullCheckForOptionalProviderOfLazy() {
+    JavaFileObject a =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import com.google.common.base.Optional;",
+            "import dagger.Lazy;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "final class A {",
+            "  @Inject A(Optional<Provider<Lazy<String>>> optional) {}",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.BindsOptionalOf;",
+            "import dagger.Provides;",
+            "import javax.inject.Inject;",
+            "",
+            "@dagger.Module",
+            "abstract class TestModule {",
+            "  @Nullable @Provides static String provideString() { return null; }",
+            "  @BindsOptionalOf abstract String optionalString();",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  A a();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(NULLABLE, a, module, component))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
+  @Test public void componentDependencyMustNotCycle_Direct() {
+    JavaFileObject shortLifetime = JavaFileObjects.forSourceLines("test.ComponentShort",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(dependencies = ComponentShort.class)",
+        "interface ComponentShort {",
+        "}");
+    String errorMessage =
+        "test.ComponentShort contains a cycle in its component dependencies:\n"
+            + "      test.ComponentShort";
+    assertAbout(javaSource())
+        .that(shortLifetime)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorMessage);
+  }
+
+  @Test public void componentDependencyMustNotCycle_Indirect() {
+    JavaFileObject longLifetime = JavaFileObjects.forSourceLines("test.ComponentLong",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(dependencies = ComponentMedium.class)",
+        "interface ComponentLong {",
+        "}");
+    JavaFileObject mediumLifetime = JavaFileObjects.forSourceLines("test.ComponentMedium",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(dependencies = ComponentLong.class)",
+        "interface ComponentMedium {",
+        "}");
+    JavaFileObject shortLifetime = JavaFileObjects.forSourceLines("test.ComponentShort",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component(dependencies = ComponentMedium.class)",
+        "interface ComponentShort {",
+        "}");
+    String longErrorMessage =
+        "test.ComponentLong contains a cycle in its component dependencies:\n"
+            + "      test.ComponentLong\n"
+            + "      test.ComponentMedium\n"
+            + "      test.ComponentLong";
+    String mediumErrorMessage =
+        "test.ComponentMedium contains a cycle in its component dependencies:\n"
+            + "      test.ComponentMedium\n"
+            + "      test.ComponentLong\n"
+            + "      test.ComponentMedium";
+    String shortErrorMessage =
+        "test.ComponentShort contains a cycle in its component dependencies:\n"
+            + "      test.ComponentMedium\n"
+            + "      test.ComponentLong\n"
+            + "      test.ComponentMedium\n"
+            + "      test.ComponentShort";
+    assertAbout(javaSources())
+        .that(ImmutableList.of(longLifetime, mediumLifetime, shortLifetime))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(longErrorMessage).in(longLifetime)
+        .and()
+        .withErrorContaining(mediumErrorMessage).in(mediumLifetime)
+        .and()
+        .withErrorContaining(shortErrorMessage).in(shortLifetime);
+  }
+
+  @Test
+  public void subcomponentBindingConflictsWithParent() {
+    JavaFileObject parentChildConflict =
+        JavaFileObjects.forSourceLines(
+            "test.ParentChildConflict",
+            "package test;",
+            "",
+            "import javax.inject.Qualifier;",
+            "",
+            "@Qualifier @interface ParentChildConflict {}");
+    JavaFileObject parentGrandchildConflict =
+        JavaFileObjects.forSourceLines(
+            "test.ParentGrandchildConflict",
+            "package test;",
+            "",
+            "import javax.inject.Qualifier;",
+            "",
+            "@Qualifier @interface ParentGrandchildConflict {}");
+    JavaFileObject childGrandchildConflict =
+        JavaFileObjects.forSourceLines(
+            "test.ChildGrandchildConflict",
+            "package test;",
+            "",
+            "import javax.inject.Qualifier;",
+            "",
+            "@Qualifier @interface ChildGrandchildConflict {}");
+
+    /* Some annotation processor implementations do not report more than one error per element. So
+     * separate parents for testing parent-conflicts-with-child and
+     * parent-conflicts-with-grandchild.
+     */
+    JavaFileObject parentConflictsWithChild =
+        JavaFileObjects.forSourceLines(
+            "test.ParentConflictsWithChild",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Component(modules = ParentConflictsWithChild.ParentModule.class)",
+            "interface ParentConflictsWithChild {",
+            "  @ParentChildConflict Object parentChildConflict();",
+            "",
+            "  Child child();",
+            "",
+            "  @Module",
+            "  static class ParentModule {",
+            "    @Provides @ParentChildConflict static Object parentChildConflict() {",
+            "      return \"parent\";",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject parentConflictsWithGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.ParentConflictsWithGrandchild",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Component(modules = ParentConflictsWithGrandchild.ParentModule.class)",
+            "interface ParentConflictsWithGrandchild {",
+            "  @ParentGrandchildConflict Object parentGrandchildConflict();",
+            "",
+            "  Child child();",
+            "",
+            "  @Module",
+            "  static class ParentModule {",
+            "    @Provides @ParentGrandchildConflict static Object parentGrandchildConflict() {",
+            "      return \"parent\";",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = Child.ChildModule.class)",
+            "interface Child {",
+            "  @ParentChildConflict Object parentChildConflict();",
+            "  @ChildGrandchildConflict Object childGrandchildConflict();",
+            "",
+            "  Grandchild grandchild();",
+            "",
+            "  @Module",
+            "  static class ChildModule {",
+            "    @Provides @ParentChildConflict static Object parentChildConflict() {",
+            "      return \"child\";",
+            "    }",
+            "",
+            "    @Provides @ChildGrandchildConflict static Object childGrandchildConflict() {",
+            "      return \"child\";",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = Grandchild.GrandchildModule.class)",
+            "interface Grandchild {",
+            "  @ParentChildConflict Object parentChildConflict();",
+            "  @ParentGrandchildConflict Object parentGrandchildConflict();",
+            "  @ChildGrandchildConflict Object childGrandchildConflict();",
+            "",
+            "  @Module",
+            "  static class GrandchildModule {",
+            "    @Provides @ParentGrandchildConflict static Object parentGrandchildConflict() {",
+            "      return \"grandchild\";",
+            "    }",
+            "",
+            "    @Provides @ChildGrandchildConflict static Object childGrandchildConflict() {",
+            "      return \"grandchild\";",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                parentChildConflict,
+                parentGrandchildConflict,
+                childGrandchildConflict,
+                parentConflictsWithChild,
+                parentConflictsWithGrandchild,
+                child,
+                grandchild))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "[test.Child.parentChildConflict()] "
+                + "@test.ParentChildConflict java.lang.Object is bound multiple times:\n"
+                + "      @Provides @test.ParentChildConflict Object"
+                + " test.ParentConflictsWithChild.ParentModule.parentChildConflict()\n"
+                + "      @Provides @test.ParentChildConflict Object"
+                + " test.Child.ChildModule.parentChildConflict()")
+        .in(parentConflictsWithChild)
+        .onLine(8)
+        .and()
+        .withErrorContaining(
+            "[test.Grandchild.parentGrandchildConflict()] "
+                + "@test.ParentGrandchildConflict java.lang.Object is bound multiple times:\n"
+                + "      @Provides @test.ParentGrandchildConflict Object"
+                + " test.ParentConflictsWithGrandchild.ParentModule.parentGrandchildConflict()\n"
+                + "      @Provides @test.ParentGrandchildConflict Object"
+                + " test.Grandchild.GrandchildModule.parentGrandchildConflict()")
+        .in(parentConflictsWithGrandchild)
+        .onLine(8)
+        .and()
+        .withErrorContaining(
+            "[test.Grandchild.childGrandchildConflict()] "
+                + "@test.ChildGrandchildConflict java.lang.Object is bound multiple times:\n"
+                + "      @Provides @test.ChildGrandchildConflict Object"
+                + " test.Child.ChildModule.childGrandchildConflict()\n"
+                + "      @Provides @test.ChildGrandchildConflict Object"
+                + " test.Grandchild.GrandchildModule.childGrandchildConflict()")
+        .in(child)
+        .onLine(8);
+  }
+
+  @Test
+  public void subcomponentBindingConflictsWithParentWithNullableViolationAsWarning() {
+    JavaFileObject parentConflictsWithChild =
+        JavaFileObjects.forSourceLines(
+            "test.ParentConflictsWithChild",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.annotation.Nullable;",
+            "",
+            "@Component(modules = ParentConflictsWithChild.ParentModule.class)",
+            "interface ParentConflictsWithChild {",
+            "  Child child();",
+            "",
+            "  @Module",
+            "  static class ParentModule {",
+            "    @Provides @Nullable static Object nullableParentChildConflict() {",
+            "      return \"parent\";",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = Child.ChildModule.class)",
+            "interface Child {",
+            "  Object parentChildConflictThatViolatesNullability();",
+            "",
+            "  @Module",
+            "  static class ChildModule {",
+            "    @Provides static Object nonNullableParentChildConflict() {",
+            "      return \"child\";",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parentConflictsWithChild, child))
+        .withCompilerOptions("-Adagger.nullableValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "[test.Child.parentChildConflictThatViolatesNullability()] "
+                + "java.lang.Object is bound multiple times:\n"
+                + "      @Provides @javax.annotation.Nullable Object"
+                + " test.ParentConflictsWithChild.ParentModule.nullableParentChildConflict()\n"
+                + "      @Provides Object"
+                + " test.Child.ChildModule.nonNullableParentChildConflict()")
+        .in(parentConflictsWithChild)
+        .onLine(9);
+  }
+
+  @Test
+  public void bindingUsedOnlyInSubcomponentDependsOnBindingOnlyInSubcomponent() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "Parent",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "ParentModule",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class ParentModule {",
+            "  @Provides static Object needsString(String string) {",
+            "    return \"needs string: \" + string;",
+            "  }",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "Child",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface Child {",
+            "  String string();",
+            "  Object needsString();",
+            "}");
+    JavaFileObject childModule =
+        JavaFileObjects.forSourceLines(
+            "ChildModule",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class ChildModule {",
+            "  @Provides static String string() {",
+            "    return \"child string\";",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, parentModule, child, childModule))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("[Child.needsString()] java.lang.String cannot be provided")
+        .in(parent)
+        .onLine(4);
+  }
+
+  @Test
+  public void multibindingContributionBetweenAncestorComponentAndEntrypointComponent() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "Parent",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "Child",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface Child {",
+            "  Grandchild grandchild();",
+            "}");
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "Grandchild",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Grandchild {",
+            "  Object object();",
+            "}");
+
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "ParentModule",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "class ParentModule {",
+            "  @Provides static Object dependsOnSet(Set<String> strings) {",
+            "    return \"needs strings: \" + strings;",
+            "  }",
+            "",
+            "  @Provides @IntoSet static String contributesToSet() {",
+            "    return \"parent string\";",
+            "  }",
+            "",
+            "  @Provides int missingDependency(double dub) {",
+            "    return 4;",
+            "  }",
+            "}");
+    JavaFileObject childModule =
+        JavaFileObjects.forSourceLines(
+            "ChildModule",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoSet;",
+            "",
+            "@Module",
+            "class ChildModule {",
+            "  @Provides @IntoSet static String contributesToSet(int i) {",
+            "    return \"\" + i;",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, parentModule, child, childModule, grandchild))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("[Grandchild.object()] java.lang.Double cannot be provided")
+        .in(parent)
+        .onLine(4);
+  }
+
+  @Test
+  public void missingReleasableReferenceManager() {
+    JavaFileObject testScope =
+        JavaFileObjects.forSourceLines(
+            "test.TestScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@CanReleaseReferences",
+            "@BadMetadata",
+            "@Scope",
+            "@Retention(RUNTIME)",
+            "@interface TestScope {}");
+    JavaFileObject otherScope =
+        JavaFileObjects.forSourceLines(
+            "test.OtherScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@CanReleaseReferences",
+            "@Scope",
+            "@Retention(RUNTIME)",
+            "@interface OtherScope {}");
+    JavaFileObject yetAnotherScope =
+        JavaFileObjects.forSourceLines(
+            "test.YetAnotherScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@CanReleaseReferences",
+            "@Scope",
+            "@Retention(RUNTIME)",
+            "@interface YetAnotherScope {}");
+    JavaFileObject testMetadata =
+        JavaFileObjects.forSourceLines(
+            "test.TestMetadata",
+            "package test;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "",
+            "@CanReleaseReferences",
+            "@interface TestMetadata {}");
+    JavaFileObject badMetadata =
+        JavaFileObjects.forSourceLines(
+            "test.BadMetadata", // force one-string-per-line format
+            "package test;",
+            "",
+            "@interface BadMetadata {}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.ReleasableReferenceManager;",
+            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
+            "",
+            "@TestScope",
+            "@YetAnotherScope",
+            "@Component",
+            "interface TestComponent {",
+            "  @ForReleasableReferences(OtherScope.class)",
+            "  ReleasableReferenceManager otherManager();",
+            "",
+            "  @ForReleasableReferences(TestScope.class)",
+            "  TypedReleasableReferenceManager<TestMetadata> typedManager();",
+            "",
+            "  @ForReleasableReferences(TestScope.class)",
+            "  TypedReleasableReferenceManager<BadMetadata> badManager();",
+            "}");
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                testScope, otherScope, yetAnotherScope, testMetadata, badMetadata, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "There is no binding for "
+                + "@dagger.releasablereferences.ForReleasableReferences(test.OtherScope.class) "
+                + "dagger.releasablereferences.ReleasableReferenceManager "
+                + "because no component in test.TestComponent's component hierarchy is annotated "
+                + "with @test.OtherScope. "
+                + "The available reference-releasing scopes are "
+                + "[@test.TestScope, @test.YetAnotherScope].")
+        .in(component)
+        .onLine(13)
+        .and()
+        .withErrorContaining(
+            "There is no binding for "
+                + "@dagger.releasablereferences.ForReleasableReferences(test.TestScope.class) "
+                + "dagger.releasablereferences.TypedReleasableReferenceManager<test.TestMetadata> "
+                + "because test.TestScope is not annotated with @test.TestMetadata")
+        .in(component)
+        .onLine(16)
+        .and()
+        .withErrorContaining(
+            "There is no binding for "
+                + "@dagger.releasablereferences.ForReleasableReferences(test.TestScope.class) "
+                + "dagger.releasablereferences.TypedReleasableReferenceManager<test.BadMetadata> "
+                + "because test.BadMetadata is not annotated with "
+                + "@dagger.releasablereferences.CanReleaseReferences")
+        .in(component)
+        .onLine(19);
+  }
+
+  @Test
+  public void releasableReferenceManagerConflict() {
+    JavaFileObject testScope =
+        JavaFileObjects.forSourceLines(
+            "test.TestScope",
+            "package test;",
+            "",
+            "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "import java.lang.annotation.Retention;",
+            "import javax.inject.Scope;",
+            "",
+            "@TestMetadata",
+            "@CanReleaseReferences",
+            "@Scope",
+            "@Retention(RUNTIME)",
+            "@interface TestScope {}");
+    JavaFileObject testMetadata =
+        JavaFileObjects.forSourceLines(
+            "test.TestMetadata",
+            "package test;",
+            "",
+            "import dagger.releasablereferences.CanReleaseReferences;",
+            "",
+            "@CanReleaseReferences",
+            "@interface TestMetadata {}");
+
+    JavaFileObject testModule =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.ReleasableReferenceManager;",
+            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
+            "import java.util.Set;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Provides @ForReleasableReferences(TestScope.class)",
+            "  static ReleasableReferenceManager rrm() {",
+            "    return null;",
+            "  }",
+            "",
+            "  @Provides @ForReleasableReferences(TestScope.class)",
+            "  static TypedReleasableReferenceManager<TestMetadata> typedRrm() {",
+            "    return null;",
+            "  }",
+            "",
+            "  @Provides",
+            "  static Set<ReleasableReferenceManager> rrmSet() {",
+            "    return null;",
+            "  }",
+            "",
+            "  @Provides",
+            "  static Set<TypedReleasableReferenceManager<TestMetadata>> typedRrmSet() {",
+            "    return null;",
+            "  }",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.releasablereferences.ForReleasableReferences;",
+            "import dagger.releasablereferences.ReleasableReferenceManager;",
+            "import dagger.releasablereferences.TypedReleasableReferenceManager;",
+            "import java.util.Set;",
+            "",
+            "@TestScope",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  @ForReleasableReferences(TestScope.class)",
+            "  ReleasableReferenceManager testManager();",
+            "",
+            "  @ForReleasableReferences(TestScope.class)",
+            "  TypedReleasableReferenceManager<TestMetadata> typedManager();",
+            "",
+            "  Set<ReleasableReferenceManager> managers();",
+            "  Set<TypedReleasableReferenceManager<TestMetadata>> typedManagers();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(testScope, testMetadata, testModule, component))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(
+                error(
+                    "@%1$s.ForReleasableReferences(test.TestScope.class) "
+                        + "%1$s.ReleasableReferenceManager is bound multiple times:",
+                    "@Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
+                        + "%1$s.ReleasableReferenceManager test.TestModule.rrm()",
+                    "binding for "
+                        + "@%1$s.ForReleasableReferences(value = test.TestScope.class) "
+                        + "%1$s.ReleasableReferenceManager from the scope declaration"),
+                "dagger.releasablereferences"))
+        .in(component)
+        .onLine(13)
+        .and()
+        .withErrorContaining(
+            String.format(
+                error(
+                    "@%1$s.ForReleasableReferences(test.TestScope.class) "
+                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
+                        + "is bound multiple times:",
+                    "@Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
+                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
+                        + "test.TestModule.typedRrm()",
+                    "binding for "
+                        + "@%1$s.ForReleasableReferences(value = test.TestScope.class) "
+                        + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
+                        + "from the scope declaration"),
+                "dagger.releasablereferences"))
+        .in(component)
+        .onLine(16)
+        .and()
+        .withErrorContaining(
+            error(
+                "java.util.Set<dagger.releasablereferences.ReleasableReferenceManager> "
+                    + "is bound multiple times:",
+                "@Provides "
+                    + "Set<dagger.releasablereferences.ReleasableReferenceManager> "
+                    + "test.TestModule.rrmSet()",
+                "Dagger-generated binding for "
+                    + "Set<dagger.releasablereferences.ReleasableReferenceManager>"))
+        .in(component)
+        .onLine(18)
+        .and()
+        .withErrorContaining(
+            String.format(
+                error(
+                    "java.util.Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>> "
+                        + "is bound multiple times:",
+                    "@Provides "
+                        + "Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>> "
+                        + "test.TestModule.typedRrmSet()",
+                    "Dagger-generated binding for "
+                        + "Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>>"),
+                "dagger.releasablereferences"))
+        .in(component)
+        .onLine(19);
+  }
+
+  private String error(String... lines) {
+    return Joiner.on("\n      ").join(lines);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/InaccessibleTypeTest.java b/javatests/dagger/internal/codegen/InaccessibleTypeTest.java
new file mode 100644
index 000000000..4f2932e41
--- /dev/null
+++ b/javatests/dagger/internal/codegen/InaccessibleTypeTest.java
@@ -0,0 +1,275 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class InaccessibleTypeTest {
+  @Test public void basicInjectedType() {
+    JavaFileObject noDepClassFile = JavaFileObjects.forSourceLines("foreign.NoDepClass",
+        "package foreign;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "public final class NoDepClass {",
+        "  @Inject NoDepClass() {}",
+        "}");
+    JavaFileObject publicClassFile = JavaFileObjects.forSourceLines("foreign.PublicClass",
+        "package foreign;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "public final class PublicClass {",
+        "  @Inject PublicClass(NonPublicClass1 dep1, NonPublicClass2 dep2, NoDepClass dep3) {}",
+        "}");
+    JavaFileObject nonPublicClass1File = JavaFileObjects.forSourceLines("foreign.NonPublicClass1",
+        "package foreign;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class NonPublicClass1 {",
+        "  @Inject NonPublicClass1(NoDepClass dep) {}",
+        "}");
+    JavaFileObject nonPublicClass2File = JavaFileObjects.forSourceLines("foreign.NonPublicClass2",
+        "package foreign;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class NonPublicClass2 {",
+        "  @Inject NonPublicClass2(NoDepClass dep) {}",
+        "}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import foreign.PublicClass;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  PublicClass publicClass();",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import foreign.NoDepClass_Factory;",
+            "import foreign.NonPublicClass1_Factory;",
+            "import foreign.NonPublicClass2_Factory;",
+            "import foreign.PublicClass;",
+            "import foreign.PublicClass_Factory;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  @SuppressWarnings(\"rawtypes\")",
+            "  private Provider nonPublicClass1Provider;",
+            "  @SuppressWarnings(\"rawtypes\")",
+            "  private Provider nonPublicClass2Provider;",
+            "  private Provider<PublicClass> publicClassProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.nonPublicClass1Provider =",
+            "        NonPublicClass1_Factory.create(NoDepClass_Factory.create());",
+            "    this.nonPublicClass2Provider =",
+            "        NonPublicClass2_Factory.create(NoDepClass_Factory.create());",
+            "    this.publicClassProvider = PublicClass_Factory.create(",
+            "        nonPublicClass1Provider,",
+            "        nonPublicClass2Provider,",
+            "        NoDepClass_Factory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public PublicClass publicClass() {",
+            "    return PublicClass_Factory.newPublicClass(",
+            "        NonPublicClass1_Factory.newNonPublicClass1(",
+            "            NoDepClass_Factory.newNoDepClass()),",
+            "        NonPublicClass2_Factory.newNonPublicClass2(",
+            "            NoDepClass_Factory.newNoDepClass()),",
+            "        NoDepClass_Factory.newNoDepClass());",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                noDepClassFile,
+                publicClassFile,
+                nonPublicClass1File,
+                nonPublicClass2File,
+                componentFile))
+        .withCompilerOptions(
+            "-Xlint:-processing",
+            "-Xlint:rawtypes",
+            "-Xlint:unchecked",
+            "-Werror")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+
+  @Test public void memberInjectedType() {
+    JavaFileObject noDepClassFile = JavaFileObjects.forSourceLines("test.NoDepClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "public final class NoDepClass {",
+        "  @Inject NoDepClass() {}",
+        "}");
+    JavaFileObject aClassFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import foreign.B;",
+        "import javax.inject.Inject;",
+        "",
+        "final class A extends B {",
+        "  @Inject NoDepClass dep;",
+        "}");
+    JavaFileObject bClassFile = JavaFileObjects.forSourceLines("foreign.B",
+        "package foreign;",
+        "",
+        "import test.NoDepClass;",
+        "import javax.inject.Inject;",
+        "",
+        "public class B extends C {",
+        "  @Inject NoDepClass dep;",
+        "}");
+    JavaFileObject cClassFile = JavaFileObjects.forSourceLines("foreign.C",
+        "package foreign;",
+        "",
+        "import test.D;",
+        "import test.NoDepClass;",
+        "import javax.inject.Inject;",
+        "",
+        "class C extends D {",
+        "  @Inject NoDepClass dep;",
+        "}");
+    JavaFileObject dClassFile = JavaFileObjects.forSourceLines("test.D",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "public class D {",
+        "  @Inject NoDepClass dep;",
+        "}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  void injectA(A a);",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private MembersInjector<A> aMembersInjector;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "     this.aMembersInjector = A_MembersInjector.create(NoDepClass_Factory.create());",
+            "  }",
+            "",
+            "  @Override",
+            "  public void injectA(A a) {",
+            "    aMembersInjector.injectMembers(a);",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                noDepClassFile, aClassFile, bClassFile, cClassFile, dClassFile, componentFile))
+        .withCompilerOptions(
+            "-Xlint:-processing",
+            "-Xlint:rawtypes",
+            "-Xlint:unchecked",
+            "-Werror")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
similarity index 100%
rename from compiler/src/test/java/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
rename to javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
diff --git a/compiler/src/test/java/dagger/internal/codegen/KeyTest.java b/javatests/dagger/internal/codegen/KeyTest.java
similarity index 100%
rename from compiler/src/test/java/dagger/internal/codegen/KeyTest.java
rename to javatests/dagger/internal/codegen/KeyTest.java
diff --git a/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
new file mode 100644
index 000000000..5c4f98214
--- /dev/null
+++ b/javatests/dagger/internal/codegen/MapBindingComponentProcessorTest.java
@@ -0,0 +1,880 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
+import com.google.auto.value.processor.AutoAnnotationProcessor;
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class MapBindingComponentProcessorTest {
+
+  @Test
+  public void mapBindingsWithEnumKey() {
+    JavaFileObject mapModuleOneFile =
+        JavaFileObjects
+            .forSourceLines("test.MapModuleOne",
+                "package test;",
+                "",
+                "import dagger.Module;",
+                "import dagger.Provides;",
+                "import dagger.multibindings.IntoMap;",
+                "",
+                "@Module",
+                "final class MapModuleOne {",
+                "  @Provides @IntoMap @PathKey(PathEnum.ADMIN) Handler provideAdminHandler() {",
+                "    return new AdminHandler();",
+                "  }",
+                "}");
+    JavaFileObject mapModuleTwoFile =
+        JavaFileObjects
+            .forSourceLines("test.MapModuleTwo",
+                "package test;",
+                "",
+                "import dagger.Module;",
+                "import dagger.Provides;",
+                "import dagger.multibindings.IntoMap;",
+                "",
+                "@Module",
+                "final class MapModuleTwo {",
+                "  @Provides @IntoMap @PathKey(PathEnum.LOGIN) Handler provideLoginHandler() {",
+                "    return new LoginHandler();",
+                "  }",
+                "}");
+    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey(unwrapValue = true)",
+        "@Retention(RUNTIME)",
+        "public @interface PathKey {",
+        "  PathEnum value();",
+        "}");
+    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
+        "package test;",
+        "",
+        "public enum PathEnum {",
+        "    ADMIN,",
+        "    LOGIN;",
+        "}");
+
+    JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler",
+        "package test;",
+        "",
+        "interface Handler {}");
+    JavaFileObject LoginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
+        "package test;",
+        "",
+        "class LoginHandler implements Handler {",
+        "  public LoginHandler() {}",
+        "}");
+    JavaFileObject AdminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
+        "package test;",
+        "",
+        "class AdminHandler implements Handler {",
+        "  public AdminHandler() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
+        "interface TestComponent {",
+        "  Map<PathEnum, Provider<Handler>> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.MapProviderFactory;",
+            "import dagger.internal.Preconditions;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<Handler> provideAdminHandlerProvider;",
+            "  private Provider<Handler> provideLoginHandlerProvider;",
+            "  private Provider<Map<PathEnum, Provider<Handler>>>",
+            "      mapOfPathEnumAndProviderOfHandlerProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.provideAdminHandlerProvider =",
+            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+            "    this.provideLoginHandlerProvider =",
+            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+            "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
+            "        MapProviderFactory.<PathEnum, Handler>builder(2)",
+            "            .put(PathEnum.ADMIN, provideAdminHandlerProvider)",
+            "            .put(PathEnum.LOGIN, provideLoginHandlerProvider)",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<PathEnum, Provider<Handler>> dispatcher() {",
+            "    return mapOfPathEnumAndProviderOfHandlerProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private MapModuleOne mapModuleOne;",
+            "    private MapModuleTwo mapModuleTwo;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      if (mapModuleOne == null) {",
+            "        this.mapModuleOne = new MapModuleOne();",
+            "      }",
+            "      if (mapModuleTwo == null) {",
+            "        this.mapModuleTwo = new MapModuleTwo();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+            "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+            "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(mapModuleOneFile,
+            mapModuleTwoFile,
+            enumKeyFile,
+            pathEnumFile,
+            HandlerFile,
+            LoginHandlerFile,
+            AdminHandlerFile,
+            componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void mapBindingsWithStringKey() {
+    JavaFileObject mapModuleOneFile =
+        JavaFileObjects
+            .forSourceLines("test.MapModuleOne",
+                "package test;",
+                "",
+                "import dagger.Module;",
+                "import dagger.Provides;",
+                "import dagger.multibindings.StringKey;",
+                "import dagger.multibindings.IntoMap;",
+                "",
+                "@Module",
+                "final class MapModuleOne {",
+                "  @Provides @IntoMap @StringKey(\"Admin\") Handler provideAdminHandler() {",
+                "    return new AdminHandler();",
+                "  }",
+                "}");
+    JavaFileObject mapModuleTwoFile =
+        JavaFileObjects
+            .forSourceLines("test.MapModuleTwo",
+                "package test;",
+                "",
+                "import dagger.Module;",
+                "import dagger.Provides;",
+                "import dagger.multibindings.IntoMap;",
+                "import dagger.multibindings.StringKey;",
+                "",
+                "@Module",
+                "final class MapModuleTwo {",
+                "  @Provides @IntoMap @StringKey(\"Login\") Handler provideLoginHandler() {",
+                "    return new LoginHandler();",
+                "  }",
+                "}");
+    JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler",
+        "package test;",
+        "",
+        "interface Handler {}");
+    JavaFileObject LoginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
+        "package test;",
+        "",
+        "class LoginHandler implements Handler {",
+        "  public LoginHandler() {}",
+        "}");
+    JavaFileObject AdminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
+        "package test;",
+        "",
+        "class AdminHandler implements Handler {",
+        "  public AdminHandler() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
+        "interface TestComponent {",
+        "  Map<String, Provider<Handler>> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.MapProviderFactory;",
+            "import dagger.internal.Preconditions;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<Handler> provideAdminHandlerProvider;",
+            "  private Provider<Handler> provideLoginHandlerProvider;",
+            "  private Provider<Map<String, Provider<Handler>>>",
+            "      mapOfStringAndProviderOfHandlerProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.provideAdminHandlerProvider =",
+            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+            "    this.provideLoginHandlerProvider =",
+            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+            "    this.mapOfStringAndProviderOfHandlerProvider =",
+            "        MapProviderFactory.<String, Handler>builder(2)",
+            "            .put(\"Admin\", provideAdminHandlerProvider)",
+            "            .put(\"Login\", provideLoginHandlerProvider)",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<String, Provider<Handler>> dispatcher() {",
+            "    return mapOfStringAndProviderOfHandlerProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private MapModuleOne mapModuleOne;",
+            "    private MapModuleTwo mapModuleTwo;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      if (mapModuleOne == null) {",
+            "        this.mapModuleOne = new MapModuleOne();",
+            "      }",
+            "      if (mapModuleTwo == null) {",
+            "        this.mapModuleTwo = new MapModuleTwo();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+            "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+            "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(mapModuleOneFile,
+            mapModuleTwoFile,
+            HandlerFile,
+            LoginHandlerFile,
+            AdminHandlerFile,
+            componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void mapBindingsWithWrappedKey() {
+    JavaFileObject mapModuleOneFile =
+        JavaFileObjects
+            .forSourceLines("test.MapModuleOne",
+                "package test;",
+                "",
+                "import dagger.Module;",
+                "import dagger.Provides;",
+                "import dagger.multibindings.IntoMap;",
+                "",
+                "@Module",
+                "final class MapModuleOne {",
+                "  @Provides @IntoMap",
+                "  @WrappedClassKey(Integer.class) Handler provideAdminHandler() {",
+                "    return new AdminHandler();",
+                "  }",
+                "}");
+    JavaFileObject mapModuleTwoFile =
+        JavaFileObjects
+            .forSourceLines("test.MapModuleTwo",
+                "package test;",
+                "",
+                "import dagger.Module;",
+                "import dagger.Provides;",
+                "import dagger.multibindings.IntoMap;",
+                "",
+                "@Module",
+                "final class MapModuleTwo {",
+                "  @Provides @IntoMap",
+                "  @WrappedClassKey(Long.class) Handler provideLoginHandler() {",
+                "    return new LoginHandler();",
+                "  }",
+                "}");
+    JavaFileObject wrappedClassKeyFile = JavaFileObjects.forSourceLines("test.WrappedClassKey",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey(unwrapValue = false)",
+        "@Retention(RUNTIME)",
+        "public @interface WrappedClassKey {",
+        "  Class<?> value();",
+        "}");
+    JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler",
+        "package test;",
+        "",
+        "interface Handler {}");
+    JavaFileObject LoginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
+        "package test;",
+        "",
+        "class LoginHandler implements Handler {",
+        "  public LoginHandler() {}",
+        "}");
+    JavaFileObject AdminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
+        "package test;",
+        "",
+        "class AdminHandler implements Handler {",
+        "  public AdminHandler() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
+        "interface TestComponent {",
+        "  Map<WrappedClassKey, Provider<Handler>> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.MapProviderFactory;",
+            "import dagger.internal.Preconditions;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<Handler> provideAdminHandlerProvider;",
+            "  private Provider<Handler> provideLoginHandlerProvider;",
+            "  private Provider<Map<WrappedClassKey, Provider<Handler>>>",
+            "      mapOfWrappedClassKeyAndProviderOfHandlerProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.provideAdminHandlerProvider =",
+            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+            "    this.provideLoginHandlerProvider =",
+            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+            "    this.mapOfWrappedClassKeyAndProviderOfHandlerProvider =",
+            "        MapProviderFactory.<WrappedClassKey, Handler>builder(2)",
+            "            .put(WrappedClassKeyCreator.createWrappedClassKey(Integer.class),",
+            "                provideAdminHandlerProvider)",
+            "            .put(WrappedClassKeyCreator.createWrappedClassKey(Long.class),",
+            "                provideLoginHandlerProvider)",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<WrappedClassKey, Provider<Handler>> dispatcher() {",
+            "    return mapOfWrappedClassKeyAndProviderOfHandlerProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private MapModuleOne mapModuleOne;",
+            "    private MapModuleTwo mapModuleTwo;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      if (mapModuleOne == null) {",
+            "        this.mapModuleOne = new MapModuleOne();",
+            "      }",
+            "      if (mapModuleTwo == null) {",
+            "        this.mapModuleTwo = new MapModuleTwo();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+            "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+            "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(mapModuleOneFile,
+            mapModuleTwoFile,
+            wrappedClassKeyFile,
+            HandlerFile,
+            LoginHandlerFile,
+            AdminHandlerFile,
+            componentFile))
+        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void mapBindingsWithNonProviderValue() {
+    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.multibindings.IntoMap;",
+        "",
+        "@Module",
+        "final class MapModuleOne {",
+        "  @Provides @IntoMap @PathKey(PathEnum.ADMIN) Handler provideAdminHandler() {",
+        "    return new AdminHandler();",
+        "  }",
+        "}");
+    JavaFileObject mapModuleTwoFile = JavaFileObjects.forSourceLines("test.MapModuleTwo",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.multibindings.IntoMap;",
+        "",
+        "@Module",
+        "final class MapModuleTwo {",
+        "  @Provides @IntoMap @PathKey(PathEnum.LOGIN) Handler provideLoginHandler() {",
+        "    return new LoginHandler();",
+        "  }",
+        "}");
+    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey(unwrapValue = true)",
+        "@Retention(RUNTIME)",
+        "public @interface PathKey {",
+        "  PathEnum value();",
+        "}");
+    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
+        "package test;",
+        "",
+        "public enum PathEnum {",
+        "    ADMIN,",
+        "    LOGIN;",
+        "}");
+    JavaFileObject HandlerFile = JavaFileObjects.forSourceLines("test.Handler",
+        "package test;",
+        "",
+        "interface Handler {}");
+    JavaFileObject LoginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
+        "package test;",
+        "",
+        "class LoginHandler implements Handler {",
+        "  public LoginHandler() {}",
+        "}");
+    JavaFileObject AdminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
+        "package test;",
+        "",
+        "class AdminHandler implements Handler {",
+        "  public AdminHandler() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
+        "interface TestComponent {",
+        "  Map<PathEnum, Handler> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.MapFactory;",
+            "import dagger.internal.MapProviderFactory;",
+            "import dagger.internal.Preconditions;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<Handler> provideAdminHandlerProvider;",
+            "  private Provider<Handler> provideLoginHandlerProvider;",
+            "  private Provider<Map<PathEnum, Provider<Handler>>>",
+            "      mapOfPathEnumAndProviderOfHandlerProvider;",
+            "  private Provider<Map<PathEnum, Handler>> mapOfPathEnumAndHandlerProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.provideAdminHandlerProvider =",
+            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+            "    this.provideLoginHandlerProvider =",
+            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+            "    this.mapOfPathEnumAndProviderOfHandlerProvider =",
+            "        MapProviderFactory.<PathEnum, Handler>builder(2)",
+            "            .put(PathEnum.ADMIN, provideAdminHandlerProvider)",
+            "            .put(PathEnum.LOGIN, provideLoginHandlerProvider)",
+            "            .build();",
+            "    this.mapOfPathEnumAndHandlerProvider =",
+            "        MapFactory.create(mapOfPathEnumAndProviderOfHandlerProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<PathEnum, Handler> dispatcher() {",
+            "    return mapOfPathEnumAndHandlerProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private MapModuleOne mapModuleOne;",
+            "    private MapModuleTwo mapModuleTwo;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      if (mapModuleOne == null) {",
+            "        this.mapModuleOne = new MapModuleOne();",
+            "      }",
+            "      if (mapModuleTwo == null) {",
+            "        this.mapModuleTwo = new MapModuleTwo();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+            "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+            "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(mapModuleOneFile,
+            mapModuleTwoFile,
+            enumKeyFile,
+            pathEnumFile,
+            HandlerFile,
+            LoginHandlerFile,
+            AdminHandlerFile,
+            componentFile)).
+        processedWith(new ComponentProcessor())
+            .compilesWithoutError()
+            .and().generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void injectMapWithoutMapBinding() {
+    JavaFileObject mapModuleFile = JavaFileObjects.forSourceLines("test.MapModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import java.util.HashMap;",
+        "import java.util.Map;",
+        "",
+        "@Module",
+        "final class MapModule {",
+        "  @Provides Map<String, String> provideAMap() {",
+        "    Map<String, String> map = new HashMap<String, String>();",
+        "    map.put(\"Hello\", \"World\");",
+        "    return map;",
+        "  }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "",
+        "@Component(modules = {MapModule.class})",
+        "interface TestComponent {",
+        "  Map<String, String> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines("test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.Preconditions;",
+        "import java.util.Map;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        GENERATED_ANNOTATION,
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private Provider<Map<String, String>> provideAMapProvider;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return new Builder().build();",
+        "  }",
+        "",
+        "  @SuppressWarnings(\"unchecked\")",
+        "  private void initialize(final Builder builder) {",
+        "    this.provideAMapProvider = MapModule_ProvideAMapFactory.create(builder.mapModule);",
+        "  }",
+        "",
+        "  @Override",
+        "  public Map<String, String> dispatcher() {",
+        "    return provideAMapProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private MapModule mapModule;",
+        "",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      if (mapModule == null) {",
+        "        this.mapModule = new MapModule();",
+        "      }",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "",
+        "    public Builder mapModule(MapModule mapModule) {",
+        "      this.mapModule = Preconditions.checkNotNull(mapModule);",
+        "      return this;",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(mapModuleFile,componentFile))
+        .processedWith(new ComponentProcessor()).compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void mapBindingsWithDuplicateKeys() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.MapModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.StringKey;",
+            "import dagger.multibindings.IntoMap;",
+            "",
+            "@Module",
+            "final class MapModule {",
+            "  @Provides @IntoMap @StringKey(\"AKey\") Object provideObjectForAKey() {",
+            "    return \"one\";",
+            "  }",
+            "",
+            "  @Provides @IntoMap @StringKey(\"AKey\") Object provideObjectForAKeyAgain() {",
+            "    return \"one again\";",
+            "  }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Map;",
+            "import javax.inject.Provider;",
+            "",
+            "@Component(modules = {MapModule.class})",
+            "interface TestComponent {",
+            "  Map<String, Object> objects();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(module, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("The same map key is bound more than once")
+        .and()
+        .withErrorContaining("provideObjectForAKey()")
+        .and()
+        .withErrorContaining("provideObjectForAKeyAgain()")
+        .and()
+        .withErrorCount(1);
+  }
+
+  @Test
+  public void mapBindingsWithInconsistentKeyAnnotations() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.MapModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.StringKey;",
+            "import dagger.multibindings.IntoMap;",
+            "",
+            "@Module",
+            "final class MapModule {",
+            "  @Provides @IntoMap @StringKey(\"AKey\") Object provideObjectForAKey() {",
+            "    return \"one\";",
+            "  }",
+            "",
+            "  @Provides @IntoMap @StringKeyTwo(\"BKey\") Object provideObjectForBKey() {",
+            "    return \"two\";",
+            "  }",
+            "}");
+    JavaFileObject stringKeyTwoFile =
+        JavaFileObjects.forSourceLines(
+            "test.StringKeyTwo",
+            "package test;",
+            "",
+            "import dagger.MapKey;",
+            "",
+            "@MapKey(unwrapValue = true)",
+            "public @interface StringKeyTwo {",
+            "  String value();",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import java.util.Map;",
+            "",
+            "@Component(modules = {MapModule.class})",
+            "interface TestComponent {",
+            "  Map<String, Object> objects();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(module, stringKeyTwoFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("uses more than one @MapKey annotation type")
+        .and()
+        .withErrorContaining("provideObjectForAKey()")
+        .and()
+        .withErrorContaining("provideObjectForBKey()")
+        .and()
+        .withErrorCount(1);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/MapKeyProcessorTest.java b/javatests/dagger/internal/codegen/MapKeyProcessorTest.java
new file mode 100644
index 000000000..62fe2fdb6
--- /dev/null
+++ b/javatests/dagger/internal/codegen/MapKeyProcessorTest.java
@@ -0,0 +1,521 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubject.assertThat;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
+import com.google.auto.value.processor.AutoAnnotationProcessor;
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class MapKeyProcessorTest {
+  @Test
+  public void mapKeyCreatorFile() {
+    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey(unwrapValue = false)",
+        "@Retention(RUNTIME)",
+        "public @interface PathKey {",
+        "  PathEnum value();",
+        "  String relativePath() default \"Defaultpath\";",
+        "}");
+    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
+        "package test;",
+        "",
+        "public enum PathEnum {",
+        "    ADMIN,",
+        "    LOGIN;",
+        "}");
+    JavaFileObject generatedKeyCreator =
+        JavaFileObjects.forSourceLines(
+            "test.PathKeyCreator",
+            "package test;",
+            "",
+            "import com.google.auto.value.AutoAnnotation;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class PathKeyCreator {",
+            "  private PathKeyCreator() {}",
+            "",
+            "  @AutoAnnotation",
+            "  public static PathKey createPathKey(PathEnum value, String relativePath) {",
+            "    return new AutoAnnotation_PathKeyCreator_createPathKey(value, relativePath);",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(enumKeyFile, pathEnumFile))
+        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedKeyCreator);
+  }
+
+  @Test
+  public void nestedMapKeyCreatorFile() {
+    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.Container",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "public interface Container {",
+        "@MapKey(unwrapValue = false)",
+        "@Retention(RUNTIME)",
+        "public @interface PathKey {",
+        "  PathEnum value();",
+        "  String relativePath() default \"Defaultpath\";",
+        "}",
+        "}");
+    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
+        "package test;",
+        "",
+        "public enum PathEnum {",
+        "    ADMIN,",
+        "    LOGIN;",
+        "}");
+    JavaFileObject generatedKeyCreator =
+        JavaFileObjects.forSourceLines(
+            "test.Container_PathKeyCreator",
+            "package test;",
+            "",
+            "import com.google.auto.value.AutoAnnotation;",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class Container_PathKeyCreator {",
+            "  private Container_PathKeyCreator() {}",
+            "",
+            "  @AutoAnnotation",
+            "  public static Container.PathKey createPathKey("
+                + "PathEnum value, String relativePath) {",
+            "    return new AutoAnnotation_Container_PathKeyCreator_createPathKey(",
+            "        value, relativePath);",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(enumKeyFile, pathEnumFile))
+        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedKeyCreator);
+  }
+
+  @Test
+  public void mapKeyComponentFileWithDisorderedKeyField() {
+    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.multibindings.IntoMap;",
+        "",
+        "@Module",
+        "final class MapModuleOne {",
+        "  @Provides",
+        "  @IntoMap",
+        "  @PathKey(relativePath = \"AdminPath\", value = PathEnum.ADMIN)",
+        "  Handler provideAdminHandler() {",
+        "    return new AdminHandler();",
+        "  }",
+        "}");
+    JavaFileObject mapModuleTwoFile =JavaFileObjects.forSourceLines("test.MapModuleTwo",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.multibindings.IntoMap;",
+        "",
+        "@Module",
+        "final class MapModuleTwo {",
+        "  @Provides",
+        "  @IntoMap",
+        "  @PathKey(value = PathEnum.LOGIN, relativePath = \"LoginPath\")",
+        "  Handler provideLoginHandler() {",
+        "    return new LoginHandler();",
+        "  }",
+        "}");
+    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey(unwrapValue = false)",
+        "@Retention(RUNTIME)",
+        "public @interface PathKey {",
+        "  PathEnum value();",
+        "  String relativePath() default \"DefaultPath\";",
+        "}");
+    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
+        "package test;",
+        "",
+        "public enum PathEnum {",
+        "    ADMIN,",
+        "    LOGIN;",
+        "}");
+    JavaFileObject handlerFile = JavaFileObjects.forSourceLines("test.Handler",
+        "package test;",
+        "",
+        "interface Handler {}");
+    JavaFileObject loginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
+        "package test;",
+        "",
+        "class LoginHandler implements Handler {",
+        "  public LoginHandler() {}",
+        "}");
+    JavaFileObject adminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
+        "package test;",
+        "",
+        "class AdminHandler implements Handler {",
+        "  public AdminHandler() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
+        "interface TestComponent {",
+        "  Map<PathKey, Provider<Handler>> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.MapProviderFactory;",
+            "import dagger.internal.Preconditions;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<Handler> provideAdminHandlerProvider;",
+            "  private Provider<Handler> provideLoginHandlerProvider;",
+            "  private Provider<Map<PathKey, Provider<Handler>>>",
+            "      mapOfPathKeyAndProviderOfHandlerProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.provideAdminHandlerProvider =",
+            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+            "    this.provideLoginHandlerProvider =",
+            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+            "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
+            "        MapProviderFactory.<PathKey, Handler>builder(2)",
+            "            .put(PathKeyCreator.createPathKey(PathEnum.ADMIN, \"AdminPath\"),",
+            "                provideAdminHandlerProvider)",
+            "            .put(PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
+            "                provideLoginHandlerProvider)",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<PathKey, Provider<Handler>> dispatcher() {",
+            "    return mapOfPathKeyAndProviderOfHandlerProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private MapModuleOne mapModuleOne;",
+            "    private MapModuleTwo mapModuleTwo;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      if (mapModuleOne == null) {",
+            "        this.mapModuleOne = new MapModuleOne();",
+            "      }",
+            "      if (mapModuleTwo == null) {",
+            "        this.mapModuleTwo = new MapModuleTwo();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+            "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+            "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                mapModuleOneFile,
+                mapModuleTwoFile,
+                enumKeyFile,
+                pathEnumFile,
+                handlerFile,
+                loginHandlerFile,
+                adminHandlerFile,
+                componentFile))
+        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void mapKeyComponentFileWithDefaultField() {
+    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.multibindings.IntoMap;",
+        "",
+        "@Module",
+        "final class MapModuleOne {",
+        "  @Provides",
+        "  @IntoMap",
+        "  @PathKey(value = PathEnum.ADMIN) Handler provideAdminHandler() {",
+        "    return new AdminHandler();",
+        "  }",
+        "}");
+    JavaFileObject mapModuleTwoFile =JavaFileObjects.forSourceLines("test.MapModuleTwo",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.multibindings.IntoMap;",
+        "",
+        "@Module",
+        "final class MapModuleTwo {",
+        "  @Provides",
+        "  @IntoMap",
+        "  @PathKey(value = PathEnum.LOGIN, relativePath = \"LoginPath\")",
+        "  Handler provideLoginHandler() {",
+        "    return new LoginHandler();",
+        "  }",
+        "}");
+    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.PathKey",
+        "package test;",
+        "import dagger.MapKey;",
+        "import java.lang.annotation.Retention;",
+        "import static java.lang.annotation.RetentionPolicy.RUNTIME;",
+        "",
+        "@MapKey(unwrapValue = false)",
+        "@Retention(RUNTIME)",
+        "public @interface PathKey {",
+        "  PathEnum value();",
+        "  String relativePath() default \"DefaultPath\";",
+        "}");
+    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.PathEnum",
+        "package test;",
+        "",
+        "public enum PathEnum {",
+        "    ADMIN,",
+        "    LOGIN;",
+        "}");
+    JavaFileObject handlerFile = JavaFileObjects.forSourceLines("test.Handler",
+        "package test;",
+        "",
+        "interface Handler {}");
+    JavaFileObject loginHandlerFile = JavaFileObjects.forSourceLines("test.LoginHandler",
+        "package test;",
+        "",
+        "class LoginHandler implements Handler {",
+        "  public LoginHandler() {}",
+        "}");
+    JavaFileObject adminHandlerFile = JavaFileObjects.forSourceLines("test.AdminHandler",
+        "package test;",
+        "",
+        "class AdminHandler implements Handler {",
+        "  public AdminHandler() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import java.util.Map;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
+        "interface TestComponent {",
+        "  Map<PathKey, Provider<Handler>> dispatcher();",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.internal.MapProviderFactory;",
+            "import dagger.internal.Preconditions;",
+            "import java.util.Map;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private Provider<Handler> provideAdminHandlerProvider;",
+            "  private Provider<Handler> provideLoginHandlerProvider;",
+            "  private Provider<Map<PathKey, Provider<Handler>>>",
+            "      mapOfPathKeyAndProviderOfHandlerProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.provideAdminHandlerProvider =",
+            "        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);",
+            "    this.provideLoginHandlerProvider =",
+            "        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);",
+            "    this.mapOfPathKeyAndProviderOfHandlerProvider =",
+            "        MapProviderFactory.<PathKey, Handler>builder(2)",
+            "            .put(PathKeyCreator.createPathKey(PathEnum.ADMIN, \"DefaultPath\"),",
+            "                provideAdminHandlerProvider)",
+            "            .put(PathKeyCreator.createPathKey(PathEnum.LOGIN, \"LoginPath\"),",
+            "                provideLoginHandlerProvider)",
+            "            .build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Map<PathKey, Provider<Handler>> dispatcher() {",
+            "    return mapOfPathKeyAndProviderOfHandlerProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private MapModuleOne mapModuleOne;",
+            "    private MapModuleTwo mapModuleTwo;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestComponent build() {",
+            "      if (mapModuleOne == null) {",
+            "        this.mapModuleOne = new MapModuleOne();",
+            "      }",
+            "      if (mapModuleTwo == null) {",
+            "        this.mapModuleTwo = new MapModuleTwo();",
+            "      }",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "",
+            "    public Builder mapModuleOne(MapModuleOne mapModuleOne) {",
+            "      this.mapModuleOne = Preconditions.checkNotNull(mapModuleOne);",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {",
+            "      this.mapModuleTwo = Preconditions.checkNotNull(mapModuleTwo);",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                mapModuleOneFile,
+                mapModuleTwoFile,
+                enumKeyFile,
+                pathEnumFile,
+                handlerFile,
+                loginHandlerFile,
+                adminHandlerFile,
+                componentFile))
+        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void mapKeyWithDefaultValue() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.MapModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.multibindings.IntoMap;",
+            "",
+            "@Module",
+            "final class MapModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @BoolKey int provideFalseValue() {",
+            "    return -1;",
+            "  }",
+            "",
+            "  @Provides",
+            "  @IntoMap",
+            "  @BoolKey(true) int provideTrueValue() {",
+            "    return 1;",
+            "  }",
+            "}");
+    JavaFileObject mapKey =
+        JavaFileObjects.forSourceLines(
+            "test.BoolKey",
+            "package test;",
+            "",
+            "import dagger.MapKey;",
+            "",
+            "@MapKey",
+            "@interface BoolKey {",
+            "  boolean value() default false;",
+            "}");
+    assertThat(module, mapKey)
+        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())
+        .compilesWithoutError();
+  }
+}
diff --git a/javatests/dagger/internal/codegen/MembersInjectionTest.java b/javatests/dagger/internal/codegen/MembersInjectionTest.java
new file mode 100644
index 000000000..35337fce5
--- /dev/null
+++ b/javatests/dagger/internal/codegen/MembersInjectionTest.java
@@ -0,0 +1,1117 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubject.assertThat;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static javax.tools.StandardLocation.CLASS_OUTPUT;
+
+import com.google.common.base.Joiner;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.testing.compile.JavaFileObjects;
+import java.io.IOException;
+import java.io.Writer;
+import java.util.Set;
+import javax.annotation.processing.AbstractProcessor;
+import javax.annotation.processing.RoundEnvironment;
+import javax.lang.model.element.TypeElement;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class MembersInjectionTest {
+  @Test
+  public void parentClass_noInjectedMembers() {
+    JavaFileObject childFile = JavaFileObjects.forSourceLines("test.Child",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "public final class Child extends Parent {",
+        "  @Inject Child() {}",
+        "}");
+    JavaFileObject parentFile = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "public abstract class Parent {}");
+
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  Child child();",
+        "}");
+    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
+        "test.DaggerTestComponent",
+        "package test;",
+        "",
+        "import dagger.internal.MembersInjectors;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        GENERATED_ANNOTATION,
+        "public final class DaggerTestComponent implements TestComponent {",
+        "  private Provider<Child> childProvider;",
+        "",
+        "  private DaggerTestComponent(Builder builder) {",
+        "    assert builder != null;",
+        "    initialize(builder);",
+        "  }",
+        "",
+        "  public static Builder builder() {",
+        "    return new Builder();",
+        "  }",
+        "",
+        "  public static TestComponent create() {",
+        "    return new Builder().build();",
+        "  }",
+        "",
+        "  @SuppressWarnings(\"unchecked\")",
+        "  private void initialize(final Builder builder) {",
+        "    this.childProvider =",
+        "        Child_Factory.create(MembersInjectors.<Child>noOp());",
+        "  }",
+        "",
+        "  @Override",
+        "  public Child child() {",
+        "    return childProvider.get();",
+        "  }",
+        "",
+        "  public static final class Builder {",
+        "    private Builder() {",
+        "    }",
+        "",
+        "    public TestComponent build() {",
+        "      return new DaggerTestComponent(this);",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(childFile, parentFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test
+  public void parentClass_injectedMembersInSupertype() {
+    JavaFileObject childFile = JavaFileObjects.forSourceLines("test.Child",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "public final class Child extends Parent {",
+        "  @Inject Child() {}",
+        "}");
+    JavaFileObject parentFile = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "public abstract class Parent {",
+        "  @Inject Dep dep;",
+        "}");
+    JavaFileObject depFile = JavaFileObjects.forSourceLines("test.Dep",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class Dep {",
+        "  @Inject Dep() {}",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  Child child();",
+        "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestComponent",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestComponent implements TestComponent {",
+            "  private MembersInjector<Child> childMembersInjector;",
+            "  private Provider<Child> childProvider;",
+            "",
+            "  private DaggerTestComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.childMembersInjector = Child_MembersInjector.create(Dep_Factory.create());",
+            "    this.childProvider = Child_Factory.create(childMembersInjector);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Child child() {",
+            "    return childProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public TestComponent build() {",
+            "      return new DaggerTestComponent(this);",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(childFile, parentFile, depFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(generatedComponent);
+  }
+
+  @Test public void fieldAndMethodGenerics() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.GenericClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class GenericClass<A, B> {",
+        "  @Inject A a;",
+        "",
+        "  @Inject GenericClass() {}",
+        "",
+        " @Inject void register(B b) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.GenericClass_MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        GENERATED_ANNOTATION,
+        "public final class GenericClass_MembersInjector<A, B>",
+        "    implements MembersInjector<GenericClass<A, B>> {",
+        "  private final Provider<A> aProvider;",
+        "  private final Provider<B> bProvider;",
+        "",
+        "  public GenericClass_MembersInjector(Provider<A> aProvider, Provider<B> bProvider) {",
+        "    assert aProvider != null;",
+        "    this.aProvider = aProvider;",
+        "    assert bProvider != null;",
+        "    this.bProvider = bProvider;",
+        "  }",
+        "",
+        "  public static <A, B> MembersInjector<GenericClass<A, B>> create(",
+        "      Provider<A> aProvider, Provider<B> bProvider) {",
+        "    return new GenericClass_MembersInjector<A, B>(aProvider, bProvider);",
+        "  }",
+        "",
+        "  @Override",
+        "  public void injectMembers(GenericClass<A, B> instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.a = aProvider.get();",
+        "    instance.register(bProvider.get());",
+        "  }",
+        "",
+        "  public static <A, B> void injectA(GenericClass<A, B> instance, Provider<A> aProvider) {",
+        "    instance.a = aProvider.get();",
+        "  }",
+        "",
+        "  public static <A, B> void injectRegister(",
+        "      GenericClass<A, B> instance, Provider<B> bProvider) {",
+        "    instance.register(bProvider.get());",
+        "  }",
+        "",
+        "}");
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expected);
+  }
+
+  @Test public void subclassedGenericMembersInjectors() {
+    JavaFileObject a = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A {",
+        "  @Inject A() {}",
+        "}");
+    JavaFileObject a2 = JavaFileObjects.forSourceLines("test.A2",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class A2 {",
+        "  @Inject A2() {}",
+        "}");
+    JavaFileObject parent = JavaFileObjects.forSourceLines("test.Parent",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class Parent<X, Y> {",
+        "  @Inject X x;",
+        "  @Inject Y y;",
+        "  @Inject A2 a2;",
+        "",
+        "  @Inject Parent() {}",
+        "}");
+    JavaFileObject child = JavaFileObjects.forSourceLines("test.Child",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class Child<T> extends Parent<T, A> {",
+        "  @Inject A a;",
+        "  @Inject T t;",
+        "",
+        "  @Inject Child() {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.Child_MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        GENERATED_ANNOTATION,
+        "public final class Child_MembersInjector<T>",
+        "    implements MembersInjector<Child<T>> {",
+        "  private final Provider<T> tAndXProvider;",
+        "  private final Provider<A> aAndYProvider;",
+        "  private final Provider<A2> a2Provider;",
+        "",
+        "  public Child_MembersInjector(",
+        "      Provider<T> tAndXProvider, Provider<A> aAndYProvider, Provider<A2> a2Provider) {",
+        "    assert tAndXProvider != null;",
+        "    this.tAndXProvider = tAndXProvider;",
+        "    assert aAndYProvider != null;",
+        "    this.aAndYProvider = aAndYProvider;",
+        "    assert a2Provider != null;",
+        "    this.a2Provider = a2Provider;",
+        "  }",
+        "",
+        "  public static <T> MembersInjector<Child<T>> create(",
+        "      Provider<T> tAndXProvider, Provider<A> aAndYProvider, Provider<A2> a2Provider) {",
+        "    return new Child_MembersInjector<T>(tAndXProvider, aAndYProvider, a2Provider);",
+        "  }",
+        "",
+        "  @Override",
+        "  public void injectMembers(Child<T> instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    ((Parent) instance).x = tAndXProvider.get();",
+        "    ((Parent) instance).y = aAndYProvider.get();",
+        "    ((Parent) instance).a2 = a2Provider.get();",
+        "    instance.a = aAndYProvider.get();",
+        "    instance.t = tAndXProvider.get();",
+        "  }",
+        "",
+        "  public static <T> void injectA(Child<T> instance, Provider<A> aProvider) {",
+        "    instance.a = aProvider.get();",
+        "  }",
+        "",
+        "  public static <T> void injectT(Child<T> instance, Provider<T> tProvider) {",
+        "    instance.t = tProvider.get();",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(a, a2, parent, child))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expected);
+  }
+
+  @Test public void fieldInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.FieldInjection",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "class FieldInjection {",
+        "  @Inject String string;",
+        "  @Inject Lazy<String> lazyString;",
+        "  @Inject Provider<String> stringProvider;",
+        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.FieldInjection_MembersInjector",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import dagger.internal.DoubleCheck;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class FieldInjection_MembersInjector",
+            "    implements MembersInjector<FieldInjection> {",
+            "  private final Provider<String> stringProvider;",
+            "",
+            "  public FieldInjection_MembersInjector(Provider<String> stringProvider) {",
+            "    assert stringProvider != null;",
+            "    this.stringProvider = stringProvider;",
+            "  }",
+            "",
+            "  public static MembersInjector<FieldInjection> create(Provider<String> stringProvider) {",
+            "    return new FieldInjection_MembersInjector(stringProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public void injectMembers(FieldInjection instance) {",
+            "    if (instance == null) {",
+            "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+            "    }",
+            "    instance.string = stringProvider.get();",
+            "    instance.lazyString = DoubleCheck.lazy(stringProvider);",
+            "    instance.stringProvider = stringProvider;",
+            "  }",
+            "",
+            "  public static void injectString(",
+            "      FieldInjection instance, Provider<String> stringProvider) {",
+            "    instance.string = stringProvider.get();",
+            "  }",
+            "",
+            "  public static void injectLazyString(",
+            "      FieldInjection instance, Provider<String> lazyStringProvider) {",
+            "    instance.lazyString = DoubleCheck.lazy(lazyStringProvider);",
+            "  }",
+            "",
+            "  public static void injectStringProvider(",
+            "      FieldInjection instance, Provider<String> stringProvider) {",
+            "    instance.stringProvider = stringProvider;",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expected);
+  }
+
+  @Test public void methodInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.MethodInjection",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "class MethodInjection {",
+        "  @Inject void noArgs() {}",
+        "  @Inject void oneArg(String string) {}",
+        "  @Inject void manyArgs(",
+        "      String string, Lazy<String> lazyString, Provider<String> stringProvider) {}",
+        "}");
+    JavaFileObject expected =
+        JavaFileObjects.forSourceLines(
+            "test.MethodInjection_MembersInjector",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import dagger.internal.DoubleCheck;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class MethodInjection_MembersInjector",
+            "     implements MembersInjector<MethodInjection> {",
+            "",
+            "  private final Provider<String> stringProvider;",
+            "",
+            "  public MethodInjection_MembersInjector(Provider<String> stringProvider) {",
+            "    assert stringProvider != null;",
+            "    this.stringProvider = stringProvider;",
+            "  }",
+            "",
+            "  public static MembersInjector<MethodInjection> create(",
+            "      Provider<String> stringProvider) {",
+            "    return new MethodInjection_MembersInjector(stringProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public void injectMembers(MethodInjection instance) {",
+            "    if (instance == null) {",
+            "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+            "    }",
+            "    instance.noArgs();",
+            "    instance.oneArg(stringProvider.get());",
+            "    instance.manyArgs(",
+            "        stringProvider.get(),",
+            "        DoubleCheck.lazy(stringProvider),",
+            "        stringProvider);",
+            "  }",
+            "",
+            "  public static void injectNoArgs(MethodInjection instance) {",
+            "    instance.noArgs();",
+            "  }",
+            "",
+            "  public static void injectOneArg(",
+            "      MethodInjection instance, Provider<String> stringProvider) {",
+            "    instance.oneArg(stringProvider.get());",
+            "  }",
+            "",
+            "  public static void injectManyArgs(",
+            "      MethodInjection instance,",
+            "      Provider<String> stringProvider,",
+            "      Provider<String> lazyStringProvider,",
+            "      Provider<String> stringProvider2) {",
+            "    instance.manyArgs(",
+            "        stringProvider.get(),",
+            "        DoubleCheck.lazy(lazyStringProvider),",
+            "        stringProvider2);",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expected);
+  }
+
+  @Test
+  public void mixedMemberInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines(
+        "test.MixedMemberInjection",
+        "package test;",
+        "",
+        "import dagger.Lazy;",
+        "import javax.inject.Inject;",
+        "import javax.inject.Provider;",
+        "",
+        "class MixedMemberInjection {",
+        "  @Inject String string;",
+        "  @Inject void setString(String s) {}",
+        "  @Inject Object object;",
+        "  @Inject void setObject(Object o) {}",
+        "}");
+    JavaFileObject expected = JavaFileObjects.forSourceLines(
+        "test.MixedMemberInjection_MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        GENERATED_ANNOTATION,
+        "public final class MixedMemberInjection_MembersInjector",
+        "    implements MembersInjector<MixedMemberInjection> {",
+        "",
+        "  private final Provider<String> stringAndSProvider;",
+        "  private final Provider<Object> objectAndOProvider;",
+        "",
+        "  public MixedMemberInjection_MembersInjector(",
+        "      Provider<String> stringAndSProvider,",
+        "      Provider<Object> objectAndOProvider) {",
+        "    assert stringAndSProvider != null;",
+        "    this.stringAndSProvider = stringAndSProvider;",
+        "    assert objectAndOProvider != null;",
+        "    this.objectAndOProvider = objectAndOProvider;",
+        "  }",
+        "",
+        "  public static MembersInjector<MixedMemberInjection> create(",
+        "      Provider<String> stringAndSProvider,",
+        "      Provider<Object> objectAndOProvider) {",
+        "    return new MixedMemberInjection_MembersInjector(",
+        "        stringAndSProvider, objectAndOProvider);",
+        "  }",
+        "",
+        "  @Override",
+        "  public void injectMembers(MixedMemberInjection instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.string = stringAndSProvider.get();",
+        "    instance.object = objectAndOProvider.get();",
+        "    instance.setString(stringAndSProvider.get());",
+        "    instance.setObject(objectAndOProvider.get());",
+        "  }",
+        "",
+        "  public static void injectString(",
+        "      MixedMemberInjection instance, Provider<String> stringProvider) {",
+        "    instance.string = stringProvider.get();",
+        "  }",
+        "",
+        "  public static void injectObject(",
+        "      MixedMemberInjection instance, Provider<Object> objectProvider) {",
+        "    instance.object = objectProvider.get();",
+        "  }",
+        "",
+        "  public static void injectSetString(",
+        "      MixedMemberInjection instance, Provider<String> sProvider) {",
+        "    instance.setString(sProvider.get());",
+        "  }",
+        "",
+        "  public static void injectSetObject(",
+        "      MixedMemberInjection instance, Provider<Object> oProvider) {",
+        "    instance.setObject(oProvider.get());",
+        "  }",
+        "}");
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expected);
+  }
+
+  @Test public void injectConstructorAndMembersInjection() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.AllInjections",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class AllInjections {",
+        "  @Inject String s;",
+        "  @Inject AllInjections(String s) {}",
+        "  @Inject void s(String s) {}",
+        "}");
+    JavaFileObject expectedMembersInjector = JavaFileObjects.forSourceLines(
+        "test.AllInjections_MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        GENERATED_ANNOTATION,
+        "public final class AllInjections_MembersInjector ",
+        "    implements MembersInjector<AllInjections> {",
+        "",
+        "  private final Provider<String> sProvider;",
+        "",
+        "  public AllInjections_MembersInjector(Provider<String> sProvider) {",
+        "    assert sProvider != null;",
+        "    this.sProvider = sProvider;",
+        "  }",
+        "",
+        "  public static MembersInjector<AllInjections> create(Provider<String> sProvider) {",
+        "      return new AllInjections_MembersInjector(sProvider);",
+        "  }",
+        "",
+        "  @Override",
+        "  public void injectMembers(AllInjections instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.s = sProvider.get();",
+        "    instance.s(sProvider.get());",
+        "  }",
+        "",
+        "  public static void injectS(AllInjections instance, Provider<String> sProvider) {",
+        "    instance.s = sProvider.get();",
+        "  }",
+        "}");
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expectedMembersInjector);
+  }
+
+  @Test public void supertypeMembersInjection() {
+    JavaFileObject aFile = JavaFileObjects.forSourceLines("test.A",
+        "package test;",
+        "",
+        "class A {}");
+    JavaFileObject bFile = JavaFileObjects.forSourceLines("test.B",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "class B extends A {",
+        "  @Inject String s;",
+        "}");
+    JavaFileObject expectedMembersInjector = JavaFileObjects.forSourceLines(
+        "test.AllInjections_MembersInjector",
+        "package test;",
+        "",
+        "import dagger.MembersInjector;",
+        "import javax.annotation.Generated;",
+        "import javax.inject.Provider;",
+        "",
+        GENERATED_ANNOTATION,
+        "public final class B_MembersInjector implements MembersInjector<B> {",
+        "  private final Provider<String> sProvider;",
+        "",
+        "  public B_MembersInjector(Provider<String> sProvider) {",
+        "    assert sProvider != null;",
+        "    this.sProvider = sProvider;",
+        "  }",
+        "",
+        "  public static MembersInjector<B> create(Provider<String> sProvider) {",
+        "      return new B_MembersInjector(sProvider);",
+        "  }",
+        "",
+        "  @Override",
+        "  public void injectMembers(B instance) {",
+        "    if (instance == null) {",
+        "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+        "    }",
+        "    instance.s = sProvider.get();",
+        "  }",
+        "",
+        "  public static void injectS(B instance, Provider<String> sProvider) {",
+        "    instance.s = sProvider.get();",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(aFile, bFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(expectedMembersInjector);
+  }
+
+  @Test
+  public void simpleComponentWithNesting() {
+    JavaFileObject nestedTypesFile = JavaFileObjects.forSourceLines(
+          "test.OuterType",
+          "package test;",
+          "",
+          "import dagger.Component;",
+          "import javax.inject.Inject;",
+          "",
+          "final class OuterType {",
+          "  static class A {",
+          "    @Inject A() {}",
+          "  }",
+          "  static class B {",
+          "    @Inject A a;",
+          "  }",
+          "  @Component interface SimpleComponent {",
+          "    A a();",
+          "    void inject(B b);",
+          "  }",
+          "}");
+    JavaFileObject bMembersInjector = JavaFileObjects.forSourceLines(
+          "test.OuterType_B_MembersInjector",
+          "package test;",
+          "",
+          "import dagger.MembersInjector;",
+          "import javax.annotation.Generated;",
+          "import javax.inject.Provider;",
+          "",
+          GENERATED_ANNOTATION,
+          "public final class OuterType_B_MembersInjector",
+          "    implements MembersInjector<OuterType.B> {",
+          "  private final Provider<OuterType.A> aProvider;",
+          "",
+          "  public OuterType_B_MembersInjector(Provider<OuterType.A> aProvider) {",
+          "    assert aProvider != null;",
+          "    this.aProvider = aProvider;",
+          "  }",
+          "",
+          "  public static MembersInjector<OuterType.B> create(Provider<OuterType.A> aProvider) {",
+          "    return new OuterType_B_MembersInjector(aProvider);",
+          "  }",
+          "",
+          "  @Override",
+          "  public void injectMembers(OuterType.B instance) {",
+          "    if (instance == null) {",
+          "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+          "    }",
+          "    instance.a = aProvider.get();",
+          "  }",
+          "",
+          "  public static void injectA(OuterType.B instance, Provider<OuterType.A> aProvider) {",
+          "    instance.a = aProvider.get();",
+          "  }",
+          "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(nestedTypesFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(bMembersInjector);
+  }
+
+  @Test
+  public void componentWithNestingAndGeneratedType() {
+    JavaFileObject nestedTypesFile =
+        JavaFileObjects.forSourceLines(
+            "test.OuterType",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Inject;",
+            "",
+            "final class OuterType {",
+            "  @Inject GeneratedType generated;",
+            "  static class A {",
+            "    @Inject A() {}",
+            "  }",
+            "  static class B {",
+            "    @Inject A a;",
+            "  }",
+            "  @Component interface SimpleComponent {",
+            "    A a();",
+            "    void inject(B b);",
+            "  }",
+            "}");
+    JavaFileObject bMembersInjector =
+        JavaFileObjects.forSourceLines(
+            "test.OuterType_B_MembersInjector",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class OuterType_B_MembersInjector",
+            "    implements MembersInjector<OuterType.B> {",
+            "  private final Provider<OuterType.A> aProvider;",
+            "",
+            "  public OuterType_B_MembersInjector(Provider<OuterType.A> aProvider) {",
+            "    assert aProvider != null;",
+            "    this.aProvider = aProvider;",
+            "  }",
+            "",
+            "  public static MembersInjector<OuterType.B> create(Provider<OuterType.A> aProvider) {",
+            "    return new OuterType_B_MembersInjector(aProvider);",
+            "  }",
+            "",
+            "  @Override",
+            "  public void injectMembers(OuterType.B instance) {",
+            "    if (instance == null) {",
+            "      throw new NullPointerException(\"Cannot inject members into a null reference\");",
+            "    }",
+            "    instance.a = aProvider.get();",
+            "  }",
+            "",
+            "  public static void injectA(OuterType.B instance, Provider<OuterType.A> aProvider) {",
+            "    instance.a = aProvider.get();",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(nestedTypesFile)
+        .processedWith(
+            new ComponentProcessor(),
+            new AbstractProcessor() {
+              private boolean done;
+
+              @Override
+              public Set<String> getSupportedAnnotationTypes() {
+                return ImmutableSet.of("*");
+              }
+
+              @Override
+              public boolean process(
+                  Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
+                if (!done) {
+                  done = true;
+                  try (Writer writer =
+                          processingEnv
+                              .getFiler()
+                              .createSourceFile("test.GeneratedType")
+                              .openWriter()) {
+                    writer.write(
+                        Joiner.on('\n')
+                            .join(
+                                "package test;",
+                                "",
+                                "import javax.inject.Inject;",
+                                "",
+                                "class GeneratedType {",
+                                "  @Inject GeneratedType() {}",
+                                "}"));
+                  } catch (IOException e) {
+                    throw new RuntimeException(e);
+                  }
+                }
+                return false;
+              }
+            })
+        .compilesWithoutError()
+        .and()
+        .generatesSources(bMembersInjector);
+  }
+
+  @Test
+  public void lowerCaseNamedMembersInjector_forLowerCaseType() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class foo {",
+            "  @Inject String string;",
+            "}");
+    JavaFileObject fooModule =
+        JavaFileObjects.forSourceLines(
+            "test.fooModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class fooModule {",
+            "  @Provides String string() { return \"foo\"; }",
+            "}");
+    JavaFileObject fooComponent =
+        JavaFileObjects.forSourceLines(
+            "test.fooComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = fooModule.class)",
+            "interface fooComponent {",
+            "  void inject(foo target);",
+            "}");
+
+    assertAbout(javaSources())
+        .that(ImmutableList.of(foo, fooModule, fooComponent))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesFileNamed(CLASS_OUTPUT, "test", "foo_MembersInjector.class");
+  }
+
+  @Test
+  public void fieldInjectionForShadowedMember() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject bar =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Bar {",
+            "  @Inject Bar() {}",
+            "}");
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Parent { ",
+            "  @Inject Foo object;",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Child extends Parent { ",
+            "  @Inject Bar object;",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface C { ",
+            "  void inject(Child child);",
+            "}");
+
+    JavaFileObject expectedMembersInjector =
+        JavaFileObjects.forSourceLines(
+            "test.Child_MembersInjector",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class Child_MembersInjector implements MembersInjector<Child> {",
+            "  private final Provider<Foo> objectProvider;",
+            "  private final Provider<Bar> objectProvider2;",
+            "",
+            "  public Child_MembersInjector(",
+            "        Provider<Foo> objectProvider, Provider<Bar> objectProvider2) {",
+            "    assert objectProvider != null;",
+            "    this.objectProvider = objectProvider;",
+            "    assert objectProvider2 != null;",
+            "    this.objectProvider2 = objectProvider2;",
+            "  }",
+            "",
+            "  public static MembersInjector<Child> create(",
+            "      Provider<Foo> objectProvider, Provider<Bar> objectProvider2) {",
+            "    return new Child_MembersInjector(objectProvider, objectProvider2);",
+            "  }",
+            "",
+            "  @Override",
+            "  public void injectMembers(Child instance) {",
+            "    if (instance == null) {",
+            "      throw new NullPointerException(",
+            "          \"Cannot inject members into a null reference\");",
+            "    }",
+            "    ((Parent) instance).object = objectProvider.get();",
+            "    instance.object = objectProvider2.get();",
+            "  }",
+            "",
+            "  public static void injectObject(Child instance, Provider<Bar> objectProvider) {",
+            "    instance.object = objectProvider.get();",
+            "  }",
+            "}");
+
+    assertAbout(javaSources())
+        .that(ImmutableList.of(foo, bar, parent, child, component))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(expectedMembersInjector);
+  }
+
+  @Test public void privateNestedClassError() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.OuterClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterClass {",
+        "  private static final class InnerClass {",
+        "    @Inject int field;",
+        "  }",
+        "}");
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor()).failsToCompile()
+        .withErrorContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(6);
+  }
+
+  @Test public void privateNestedClassWarning() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.OuterClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterClass {",
+        "  private static final class InnerClass {",
+        "    @Inject int field;",
+        "  }",
+        "}");
+    assertAbout(javaSource())
+        .that(file)
+        .withCompilerOptions("-Adagger.privateMemberValidation=WARNING")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .withWarningContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(6);
+  }
+
+  @Test public void privateSuperclassIsOkIfNotInjectedInto() {
+    JavaFileObject file = JavaFileObjects.forSourceLines("test.OuterClass",
+        "package test;",
+        "",
+        "import javax.inject.Inject;",
+        "",
+        "final class OuterClass {",
+        "  private static class BaseClass {}",
+        "",
+        "  static final class DerivedClass extends BaseClass {",
+        "    @Inject int field;",
+        "  }",
+        "}");
+    assertAbout(javaSource())
+        .that(file)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
+  @Test public void rawFrameworkTypes() {
+    JavaFileObject file =
+        JavaFileObjects.forSourceLines(
+            "test.RawFrameworkTypes",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Inject;",
+            "import javax.inject.Provider;",
+            "",
+            "class RawProviderField {",
+            "  @Inject Provider fieldWithRawProvider;",
+            "}",
+            "",
+            "class RawProviderParameter {",
+            "  @Inject void methodInjection(Provider rawProviderParameter) {}",
+            "}",
+            "",
+            "@Component",
+            "interface C {",
+            "  void inject(RawProviderField rawProviderField);",
+            "  void inject(RawProviderParameter rawProviderParameter);",
+            "}");
+    assertThat(file)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("javax.inject.Provider cannot be provided").in(file).onLine(17)
+        .and()
+        .withErrorContaining("javax.inject.Provider cannot be provided").in(file).onLine(18);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java b/javatests/dagger/internal/codegen/MethodSignatureFormatterTest.java
similarity index 100%
rename from compiler/src/test/java/dagger/internal/codegen/MethodSignatureFormatterTest.java
rename to javatests/dagger/internal/codegen/MethodSignatureFormatterTest.java
diff --git a/compiler/src/test/java/dagger/internal/codegen/MissingBindingSuggestionsTest.java b/javatests/dagger/internal/codegen/MissingBindingSuggestionsTest.java
similarity index 100%
rename from compiler/src/test/java/dagger/internal/codegen/MissingBindingSuggestionsTest.java
rename to javatests/dagger/internal/codegen/MissingBindingSuggestionsTest.java
diff --git a/compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
similarity index 100%
rename from compiler/src/test/java/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
rename to javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
diff --git a/javatests/dagger/internal/codegen/ModuleValidatorTest.java b/javatests/dagger/internal/codegen/ModuleValidatorTest.java
new file mode 100644
index 000000000..a25c53ad0
--- /dev/null
+++ b/javatests/dagger/internal/codegen/ModuleValidatorTest.java
@@ -0,0 +1,282 @@
+/*
+ * Copyright (C) 2016 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.JavaSourcesSubject.assertThat;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;
+
+import com.google.testing.compile.JavaFileObjects;
+import dagger.Module;
+import dagger.producers.ProducerModule;
+import java.lang.annotation.Annotation;
+import java.util.Arrays;
+import java.util.Collection;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+@RunWith(Parameterized.class)
+public final class ModuleValidatorTest {
+
+  @Parameterized.Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return Arrays.asList(new Object[][] {{ModuleType.MODULE}, {ModuleType.PRODUCER_MODULE}});
+  }
+
+  private enum ModuleType {
+    MODULE(Module.class),
+    PRODUCER_MODULE(ProducerModule.class),
+    ;
+
+    private final Class<? extends Annotation> annotation;
+
+    ModuleType(Class<? extends Annotation> annotation) {
+      this.annotation = annotation;
+    }
+
+    String annotationWithSubcomponent(String subcomponent) {
+      return String.format("@%s(subcomponents = %s)", annotation.getSimpleName(), subcomponent);
+    }
+
+    String importStatement() {
+      return String.format("import %s;", annotation.getName());
+    }
+
+    String simpleName() {
+      return annotation.getSimpleName();
+    }
+  }
+
+  private final ModuleType moduleType;
+
+  public ModuleValidatorTest(ModuleType moduleType) {
+    this.moduleType = moduleType;
+  }
+
+  @Test
+  public void moduleSubcomponents_notASubcomponent() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            moduleType.importStatement(),
+            "",
+            moduleType.annotationWithSubcomponent("NotASubcomponent.class"),
+            "class TestModule {}");
+    JavaFileObject notASubcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.NotASubcomponent", "package test;", "", "class NotASubcomponent {}");
+    assertThat(module, notASubcomponent)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "test.NotASubcomponent is not a @Subcomponent or @ProductionSubcomponent")
+        .in(module)
+        .onLine(5);
+  }
+
+  @Test
+  public void moduleSubcomponents_listsSubcomponentBuilder() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            moduleType.importStatement(),
+            "",
+            moduleType.annotationWithSubcomponent("Sub.Builder.class"),
+            "class TestModule {}");
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Sub {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Sub build();",
+            "  }",
+            "}");
+    assertThat(module, subcomponent)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "test.Sub.Builder is a @Subcomponent.Builder. Did you mean to use test.Sub?")
+        .in(module)
+        .onLine(5);
+  }
+
+  @Test
+  public void moduleSubcomponents_listsProductionSubcomponentBuilder() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            moduleType.importStatement(),
+            "",
+            moduleType.annotationWithSubcomponent("Sub.Builder.class"),
+            "class TestModule {}");
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.producers.ProductionSubcomponent;",
+            "",
+            "@ProductionSubcomponent",
+            "interface Sub {",
+            "  @ProductionSubcomponent.Builder",
+            "  interface Builder {",
+            "    Sub build();",
+            "  }",
+            "}");
+    assertThat(module, subcomponent)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "test.Sub.Builder is a @ProductionSubcomponent.Builder. Did you mean to use test.Sub?")
+        .in(module)
+        .onLine(5);
+  }
+
+  @Test
+  public void moduleSubcomponents_noSubcomponentBuilder() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            moduleType.importStatement(),
+            "",
+            moduleType.annotationWithSubcomponent("NoBuilder.class"),
+            "class TestModule {}");
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.NoBuilder",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface NoBuilder {}");
+    assertThat(module, subcomponent)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "test.NoBuilder doesn't have a @Subcomponent.Builder, which is required when used "
+                + "with @"
+                + moduleType.simpleName()
+                + ".subcomponents")
+        .in(module)
+        .onLine(5);
+  }
+
+  @Test
+  public void moduleSubcomponents_noProductionSubcomponentBuilder() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            moduleType.importStatement(),
+            "",
+            moduleType.annotationWithSubcomponent("NoBuilder.class"),
+            "class TestModule {}");
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.NoBuilder",
+            "package test;",
+            "",
+            "import dagger.producers.ProductionSubcomponent;",
+            "",
+            "@ProductionSubcomponent",
+            "interface NoBuilder {}");
+    assertThat(module, subcomponent)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "test.NoBuilder doesn't have a @ProductionSubcomponent.Builder, which is required "
+                + "when used with @"
+                + moduleType.simpleName()
+                + ".subcomponents")
+        .in(module)
+        .onLine(5);
+  }
+
+  @Test
+  public void moduleSubcomponentsAreTypes() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "",
+            "@Module(subcomponents = int.class)",
+            "class TestModule {}");
+    assertThat(module)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("int is not a valid subcomponent type")
+        .in(module)
+        .onLine(5);
+  }
+  
+  @Test
+  public void tooManyAnnotations() {
+    assertThatModuleMethod(
+            "@BindsOptionalOf @Multibinds abstract Set<Object> tooManyAnnotations();")
+        .hasError("is annotated with more than one of");
+  }
+
+  @Test
+  public void invalidIncludedModule() {
+    JavaFileObject badModule =
+        JavaFileObjects.forSourceLines(
+            "test.BadModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "abstract class BadModule {",
+            "  @Binds abstract Object noParameters();",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.IncludesBadModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "",
+            "@Module(includes = BadModule.class)",
+            "abstract class IncludesBadModule {}");
+    assertThat(daggerCompiler().compile(badModule, module))
+        .hadErrorContaining("test.BadModule has errors")
+        .inFile(module)
+        .onLine(5);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultibindingTest.java b/javatests/dagger/internal/codegen/MultibindingTest.java
similarity index 100%
rename from compiler/src/test/java/dagger/internal/codegen/MultibindingTest.java
rename to javatests/dagger/internal/codegen/MultibindingTest.java
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultibindsValidatorTest.java b/javatests/dagger/internal/codegen/MultibindsValidatorTest.java
similarity index 100%
rename from compiler/src/test/java/dagger/internal/codegen/MultibindsValidatorTest.java
rename to javatests/dagger/internal/codegen/MultibindsValidatorTest.java
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultipleRequestTest.java b/javatests/dagger/internal/codegen/MultipleRequestTest.java
similarity index 100%
rename from compiler/src/test/java/dagger/internal/codegen/MultipleRequestTest.java
rename to javatests/dagger/internal/codegen/MultipleRequestTest.java
diff --git a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
new file mode 100644
index 000000000..066ed9792
--- /dev/null
+++ b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -0,0 +1,530 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// TODO(beder): Merge the error-handling tests with the ModuleFactoryGeneratorTest.
+package dagger.internal.codegen;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;
+import static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatProductionModuleMethod;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SCOPE;
+import static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.testing.compile.JavaFileObjects;
+import javax.inject.Qualifier;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ProducerModuleFactoryGeneratorTest {
+
+  private String formatErrorMessage(String msg) {
+    return String.format(msg, "Produces");
+  }
+
+  private String formatModuleErrorMessage(String msg) {
+    return String.format(msg, "Produces", "ProducerModule");
+  }
+
+  @Test public void producesMethodNotInModule() {
+    assertThatMethodInUnannotatedClass("@Produces String produceString() { return null; }")
+        .hasError(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE));
+  }
+
+  @Test public void producesMethodAbstract() {
+    assertThatProductionModuleMethod("@Produces abstract String produceString();")
+        .hasError(formatErrorMessage(BINDING_METHOD_ABSTRACT));
+  }
+
+  @Test public void producesMethodPrivate() {
+    assertThatProductionModuleMethod("@Produces private String produceString() { return null; }")
+        .hasError(formatErrorMessage(BINDING_METHOD_PRIVATE));
+  }
+
+  @Test public void producesMethodReturnVoid() {
+    assertThatProductionModuleMethod("@Produces void produceNothing() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));
+  }
+
+  @Test
+  public void producesProvider() {
+    assertThatProductionModuleMethod("@Produces Provider<String> produceProvider() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+  }
+
+  @Test
+  public void producesLazy() {
+    assertThatProductionModuleMethod("@Produces Lazy<String> produceLazy() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+  }
+
+  @Test
+  public void producesMembersInjector() {
+    assertThatProductionModuleMethod(
+            "@Produces MembersInjector<String> produceMembersInjector() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+  }
+
+  @Test
+  public void producesProducer() {
+    assertThatProductionModuleMethod("@Produces Producer<String> produceProducer() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+  }
+
+  @Test
+  public void producesProduced() {
+    assertThatProductionModuleMethod("@Produces Produced<String> produceProduced() {}")
+        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));
+  }
+
+  @Test public void producesMethodReturnRawFuture() {
+    assertThatProductionModuleMethod("@Produces ListenableFuture produceRaw() {}")
+        .importing(ListenableFuture.class)
+        .hasError(PRODUCES_METHOD_RAW_FUTURE);
+  }
+
+  @Test public void producesMethodReturnWildcardFuture() {
+    assertThatProductionModuleMethod("@Produces ListenableFuture<?> produceRaw() {}")
+        .importing(ListenableFuture.class)
+        .hasError(PRODUCES_METHOD_RETURN_TYPE);
+  }
+
+  @Test public void producesMethodWithTypeParameter() {
+    assertThatProductionModuleMethod("@Produces <T> String produceString() { return null; }")
+        .hasError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));
+  }
+
+  @Test public void producesMethodSetValuesWildcard() {
+    assertThatProductionModuleMethod(
+            "@Produces @ElementsIntoSet Set<?> produceWildcard() { return null; }")
+        .hasError(PRODUCES_METHOD_RETURN_TYPE);
+  }
+
+  @Test public void producesMethodSetValuesRawSet() {
+    assertThatProductionModuleMethod(
+            "@Produces @ElementsIntoSet Set produceSomething() { return null; }")
+        .hasError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
+  }
+
+  @Test public void producesMethodSetValuesNotASet() {
+    assertThatProductionModuleMethod(
+            "@Produces @ElementsIntoSet List<String> produceStrings() { return null; }")
+        .hasError(PRODUCES_METHOD_SET_VALUES_RETURN_SET);
+  }
+
+  @Test public void producesMethodSetValuesWildcardInFuture() {
+    assertThatProductionModuleMethod(
+            "@Produces @ElementsIntoSet "
+                + "ListenableFuture<Set<?>> produceWildcard() { return null; }")
+        .importing(ListenableFuture.class)
+        .hasError(PRODUCES_METHOD_RETURN_TYPE);
+  }
+
+  @Test public void producesMethodSetValuesFutureRawSet() {
+    assertThatProductionModuleMethod(
+            "@Produces @ElementsIntoSet ListenableFuture<Set> produceSomething() { return null; }")
+        .importing(ListenableFuture.class)
+        .hasError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));
+  }
+
+  @Test public void producesMethodSetValuesFutureNotASet() {
+    assertThatProductionModuleMethod(
+            "@Produces @ElementsIntoSet "
+                + "ListenableFuture<List<String>> produceStrings() { return null; }")
+        .importing(ListenableFuture.class)
+        .hasError(PRODUCES_METHOD_SET_VALUES_RETURN_SET);
+  }
+
+  @Test public void multipleProducesMethodsWithSameName() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces Object produce(int i) {",
+        "    return i;",
+        "  }",
+        "",
+        "  @Produces String produce() {",
+        "    return \"\";",
+        "  }",
+        "}");
+    String errorMessage = String.format(BINDING_METHOD_WITH_SAME_NAME, "Produces");
+    assertAbout(javaSource()).that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(errorMessage).in(moduleFile).onLine(8)
+        .and().withErrorContaining(errorMessage).in(moduleFile).onLine(12);
+  }
+
+  @Test
+  public void producesMethodThrowsThrowable() {
+    assertThatProductionModuleMethod("@Produces int produceInt() throws Throwable { return 0; }")
+        .hasError(
+            "@Produces methods may only throw unchecked exceptions or exceptions subclassing "
+                + "Exception");
+  }
+
+  @Test public void producesMethodWithScope() {
+    assertThatProductionModuleMethod("@Produces @Singleton String str() { return \"\"; }")
+        .hasError(PRODUCES_METHOD_SCOPE);
+  }
+
+  @Test
+  public void privateModule() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.Enclosing",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "",
+        "final class Enclosing {",
+        "  @ProducerModule private static final class PrivateModule {",
+        "  }",
+        "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Modules cannot be private.")
+        .in(moduleFile).onLine(6);
+  }
+
+  @Test
+  public void enclosedInPrivateModule() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.Enclosing",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "",
+        "final class Enclosing {",
+        "  private static final class PrivateEnclosing {",
+        "    @ProducerModule static final class TestModule {",
+        "    }",
+        "  }",
+        "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("Modules cannot be enclosed in private types.")
+        .in(moduleFile).onLine(7);
+  }
+
+  @Test
+  public void includesNonModule() {
+    JavaFileObject xFile =
+        JavaFileObjects.forSourceLines("test.X", "package test;", "", "public final class X {}");
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.FooModule",
+            "package test;",
+            "",
+            "import dagger.producers.ProducerModule;",
+            "",
+            "@ProducerModule(includes = X.class)",
+            "public final class FooModule {",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(xFile, moduleFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(
+                ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED,
+                "X",
+                "one of @Module, @ProducerModule"));
+  }
+
+  @Test
+  public void publicModuleNonPublicIncludes() {
+    JavaFileObject publicModuleFile = JavaFileObjects.forSourceLines("test.PublicModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "",
+        "@ProducerModule(includes = {",
+        "    NonPublicModule1.class, OtherPublicModule.class, NonPublicModule2.class",
+        "})",
+        "public final class PublicModule {",
+        "}");
+    JavaFileObject nonPublicModule1File = JavaFileObjects.forSourceLines("test.NonPublicModule1",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "",
+        "@ProducerModule",
+        "final class NonPublicModule1 {",
+        "}");
+    JavaFileObject nonPublicModule2File = JavaFileObjects.forSourceLines("test.NonPublicModule2",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "",
+        "@ProducerModule",
+        "final class NonPublicModule2 {",
+        "}");
+    JavaFileObject otherPublicModuleFile = JavaFileObjects.forSourceLines("test.OtherPublicModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "",
+        "@ProducerModule",
+        "public final class OtherPublicModule {",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(
+            publicModuleFile, nonPublicModule1File, nonPublicModule2File, otherPublicModuleFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("This module is public, but it includes non-public "
+            + "(or effectively non-public) modules. "
+            + "Either reduce the visibility of this module or make "
+            + "test.NonPublicModule1 and test.NonPublicModule2 public.")
+        .in(publicModuleFile).onLine(8);
+  }
+
+  @Test public void argumentNamedModuleCompiles() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces String produceString(int module) {",
+        "    return null;",
+        "  }",
+        "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+
+  @Test public void singleProducesMethodNoArgsFuture() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "",
+        "@ProducerModule",
+        "final class TestModule {",
+        "  @Produces ListenableFuture<String> produceString() {",
+        "    return null;",
+        "  }",
+        "}");
+    JavaFileObject factoryFile =
+        JavaFileObjects.forSourceLines(
+            "TestModule_ProduceStringFactory",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.AsyncFunction;",
+            "import com.google.common.util.concurrent.Futures;",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.internal.AbstractProducer;",
+            "import dagger.producers.monitoring.ProducerToken;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor;",
+            "import java.util.concurrent.Executor;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class TestModule_ProduceStringFactory",
+            "    extends AbstractProducer<String>",
+            "    implements AsyncFunction<Void, String>, Executor {",
+            "  private final TestModule module;",
+            "  private final Provider<Executor> executorProvider;",
+            "  private final Provider<ProductionComponentMonitor> monitorProvider;",
+            "",
+            "  public TestModule_ProduceStringFactory(",
+            "      TestModule module,",
+            "      Provider<Executor> executorProvider,",
+            "      Provider<ProductionComponentMonitor> monitorProvider) {",
+            "    super(",
+            "        monitorProvider,",
+            "        ProducerToken.create(TestModule_ProduceStringFactory.class));",
+            "    assert module != null;",
+            "    this.module = module;",
+            "    assert executorProvider != null;",
+            "    this.executorProvider = executorProvider;",
+            "    assert monitorProvider != null;",
+            "    this.monitorProvider = monitorProvider;",
+            "  }",
+            "",
+            "  @Override protected ListenableFuture<String> compute() {",
+            "    return Futures.transformAsync(",
+            "        Futures.<Void>immediateFuture(null), this, this);",
+            "  }",
+            "",
+            "  @Deprecated",
+            "  @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
+            "    assert monitor != null :",
+            "        \"apply() may only be called internally from compute(); \"",
+            "        + \"if it's called explicitly, the monitor might be null\";",
+            "    monitor.methodStarting();",
+            "    try {",
+            "      return TestModule_ProduceStringFactory.this.module.produceString();",
+            "    } finally {",
+            "      monitor.methodFinished();",
+            "    }",
+            "  }",
+            "",
+            "  @Deprecated",
+            "  @Override public void execute(Runnable runnable) {",
+            "    assert monitor != null :",
+            "        \"execute() may only be called internally from compute(); \"",
+            "        + \"if it's called explicitly, the monitor might be null\";",
+            "    monitor.ready();",
+            "    executorProvider.get().execute(runnable);",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(factoryFile);
+  }
+
+  @Test
+  public void singleProducesMethodNoArgsFutureWithProducerName() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.Futures;",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "",
+            "@ProducerModule",
+            "final class TestModule {",
+            "  @Produces ListenableFuture<String> produceString() {",
+            "    return Futures.immediateFuture(\"\");",
+            "  }",
+            "}");
+    JavaFileObject factoryFile =
+        JavaFileObjects.forSourceLines(
+            "TestModule_ProduceStringFactory",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.AsyncFunction;",
+            "import com.google.common.util.concurrent.Futures;",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.internal.AbstractProducer;",
+            "import dagger.producers.monitoring.ProducerToken;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor;",
+            "import java.util.concurrent.Executor;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class TestModule_ProduceStringFactory",
+            "    extends AbstractProducer<String>",
+            "    implements AsyncFunction<Void, String>, Executor {",
+            "  private final TestModule module;",
+            "  private final Provider<Executor> executorProvider;",
+            "  private final Provider<ProductionComponentMonitor> monitorProvider;",
+            "",
+            "  public TestModule_ProduceStringFactory(",
+            "      TestModule module,",
+            "      Provider<Executor> executorProvider,",
+            "      Provider<ProductionComponentMonitor> monitorProvider) {",
+            "    super(",
+            "        monitorProvider,",
+            "        ProducerToken.create(\"test.TestModule#produceString\"));",
+            "    assert module != null;",
+            "    this.module = module;",
+            "    assert executorProvider != null;",
+            "    this.executorProvider = executorProvider;",
+            "    assert monitorProvider != null;",
+            "    this.monitorProvider = monitorProvider;",
+            "  }",
+            "",
+            "  @Override protected ListenableFuture<String> compute() {",
+            "    return Futures.transformAsync(",
+            "      Futures.<Void>immediateFuture(null), this, this);",
+            "  }",
+            "",
+            "  @Deprecated",
+            "  @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
+            "    assert monitor != null :",
+            "        \"apply() may only be called internally from compute(); \"",
+            "        + \"if it's called explicitly, the monitor might be null\";",
+            "    monitor.methodStarting();",
+            "    try {",
+            "      return TestModule_ProduceStringFactory.this.module.produceString();",
+            "    } finally {",
+            "      monitor.methodFinished();",
+            "    }",
+            "  }",
+            "",
+            "  @Deprecated",
+            "  @Override public void execute(Runnable runnable) {",
+            "    assert monitor != null :",
+            "        \"execute() may only be called internally from compute(); \"",
+            "        + \"if it's called explicitly, the monitor might be null\";",
+            "    monitor.ready();",
+            "    executorProvider.get().execute(runnable);",
+            "  }",
+            "}");
+    assertAbout(javaSource())
+        .that(moduleFile)
+        .withCompilerOptions("-Adagger.writeProducerNameInToken=ENABLED")
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(factoryFile);
+  }
+
+  @Test public void producesMethodMultipleQualifiers() {
+    assertThatProductionModuleMethod(
+            "@Produces @QualifierA @QualifierB abstract String produceString() { return null; }")
+        .importing(ListenableFuture.class, QualifierA.class, QualifierB.class)
+        .hasError(BINDING_METHOD_MULTIPLE_QUALIFIERS);
+  }
+  
+  @Qualifier
+  public @interface QualifierA {}
+
+  @Qualifier
+  public @interface QualifierB {}
+}
diff --git a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
new file mode 100644
index 000000000..561795632
--- /dev/null
+++ b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -0,0 +1,372 @@
+/*
+ * Copyright (C) 2014 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class ProductionComponentProcessorTest {
+  @Test public void componentOnConcreteClass() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.producers.ProductionComponent;",
+        "",
+        "@ProductionComponent",
+        "final class NotAComponent {}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("interface");
+  }
+
+  @Test public void componentOnEnum() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.producers.ProductionComponent;",
+        "",
+        "@ProductionComponent",
+        "enum NotAComponent {",
+        "  INSTANCE",
+        "}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("interface");
+  }
+
+  @Test public void componentOnAnnotation() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.producers.ProductionComponent;",
+        "",
+        "@ProductionComponent",
+        "@interface NotAComponent {}");
+    assertAbout(javaSource()).that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("interface");
+  }
+
+  @Test public void nonModuleModule() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.NotAComponent",
+        "package test;",
+        "",
+        "import dagger.producers.ProductionComponent;",
+        "",
+        "@ProductionComponent(modules = Object.class)",
+        "interface NotAComponent {}");
+    assertAbout(javaSource())
+        .that(componentFile)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("is not annotated with one of @Module, @ProducerModule");
+  }
+
+  @Test
+  public void dependsOnProductionExecutor() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.ExecutorModule",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.MoreExecutors;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.producers.Production;",
+            "import java.util.concurrent.Executor;",
+            "",
+            "@Module",
+            "final class ExecutorModule {",
+            "  @Provides @Production Executor executor() {",
+            "    return MoreExecutors.directExecutor();",
+            "  }",
+            "}");
+    JavaFileObject producerModuleFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleModule",
+            "package test;",
+            "",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "import dagger.producers.Production;",
+            "import java.util.concurrent.Executor;",
+            "",
+            "@ProducerModule",
+            "final class SimpleModule {",
+            "  @Produces String str(@Production Executor executor) {",
+            "    return \"\";",
+            "  }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.SimpleComponent",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.producers.ProductionComponent;",
+            "import java.util.concurrent.Executor;",
+            "",
+            "@ProductionComponent(modules = {ExecutorModule.class, SimpleModule.class})",
+            "interface SimpleComponent {",
+            "  ListenableFuture<String> str();",
+            "",
+            "  @ProductionComponent.Builder",
+            "  interface Builder {",
+            "    SimpleComponent build();",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, producerModuleFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("may not depend on the production executor");
+  }
+
+  @Test
+  public void simpleComponent() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestClass",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import com.google.common.util.concurrent.MoreExecutors;",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import dagger.producers.ProducerModule;",
+            "import dagger.producers.Produces;",
+            "import dagger.producers.Production;",
+            "import dagger.producers.ProductionComponent;",
+            "import java.util.concurrent.Executor;",
+            "import javax.inject.Inject;",
+            "",
+            "final class TestClass {",
+            "  static final class C {",
+            "    @Inject C() {}",
+            "  }",
+            "",
+            "  interface A {}",
+            "  interface B {}",
+            "",
+            "  @Module",
+            "  static final class BModule {",
+            "    @Provides B b(C c) {",
+            "      return null;",
+            "    }",
+            "",
+            "    @Provides @Production Executor executor() {",
+            "      return MoreExecutors.directExecutor();",
+            "    }",
+            "  }",
+            "",
+            "  @ProducerModule",
+            "  static final class AModule {",
+            "    @Produces ListenableFuture<A> a(B b) {",
+            "      return null;",
+            "    }",
+            "  }",
+            "",
+            "  @ProductionComponent(modules = {AModule.class, BModule.class})",
+            "  interface SimpleComponent {",
+            "    ListenableFuture<A> a();",
+            "  }",
+            "}");
+    JavaFileObject generatedComponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerTestClass_SimpleComponent",
+            "package test;",
+            "",
+            "import com.google.common.util.concurrent.ListenableFuture;",
+            "import dagger.internal.DoubleCheck;",
+            "import dagger.internal.InstanceFactory;",
+            "import dagger.internal.Preconditions;",
+            "import dagger.internal.SetFactory;",
+            "import dagger.producers.Producer;",
+            "import dagger.producers.internal.Producers;",
+            "import dagger.producers.monitoring.ProductionComponentMonitor;",
+            "import java.util.concurrent.Executor;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerTestClass_SimpleComponent",
+            "    implements TestClass.SimpleComponent {",
+            "  private Provider<Executor> executorProvider;",
+            "  private Provider<Executor> executorProvider2;",
+            "  private Provider<TestClass.SimpleComponent> simpleComponentProvider;",
+            "  private Provider<ProductionComponentMonitor> monitorProvider;",
+            "  private Provider<TestClass.B> bProvider;",
+            "  private Producer<TestClass.A> aProducer;",
+            "  private Producer<TestClass.B> bProducer;",
+            "",
+            "  private DaggerTestClass_SimpleComponent(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static TestClass.SimpleComponent create() {",
+            "    return new Builder().build()",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.executorProvider =",
+            "        TestClass_BModule_ExecutorFactory.create(builder.bModule);",
+            "     this.executorProvider2 =",
+            "         DoubleCheck.provider(",
+            "             TestClass_SimpleComponent_ProductionExecutorModule_ExecutorFactory",
+            "                 .create(executorProvider));",
+            "    this.simpleComponentProvider =",
+            "        InstanceFactory.<TestClass.SimpleComponent>create(this);",
+            "    this.monitorProvider =",
+            "        DoubleCheck.provider(",
+            "            TestClass_SimpleComponent_MonitoringModule_MonitorFactory.create(",
+            "                simpleComponentProvider,",
+            "                SetFactory.<ProductionComponentMonitor.Factory>empty());",
+            "    this.bProvider = TestClass_BModule_BFactory.create(",
+            "        builder.bModule, TestClass_C_Factory.create());",
+            "    this.bProducer = Producers.producerFromProvider(bProvider);",
+            "    this.aProducer = new TestClass_AModule_AFactory(",
+            "        builder.aModule,",
+            "        executorProvider2,",
+            "        monitorProvider,",
+            "        bProducer);",
+            "  }",
+            "",
+            "  @Override",
+            "  public ListenableFuture<TestClass.A> a() {",
+            "    return aProducer.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private TestClass.BModule bModule;",
+            "    private TestClass.AModule aModule;",
+            "",
+            "    private Builder() {",
+            "    }",
+            "",
+            "    public TestClass.SimpleComponent build() {",
+            "      if (bModule == null) {",
+            "        this.bModule = new TestClass.BModule();",
+            "      }",
+            "      if (aModule == null) {",
+            "        this.aModule = new TestClass.AModule();",
+            "      }",
+            "      return new DaggerTestClass_SimpleComponent(this);",
+            "    }",
+            "",
+            "    public Builder aModule(TestClass.AModule aModule) {",
+            "      this.aModule = Preconditions.checkNotNull(aModule);",
+            "      return this;",
+            "    }",
+            "",
+            "    public Builder bModule(TestClass.BModule bModule) {",
+            "      this.bModule = Preconditions.checkNotNull(bModule);",
+            "      return this;",
+            "    }",
+            "",
+            "    @Deprecated",
+            "    public Builder testClass_SimpleComponent_ProductionExecutorModule(",
+            "        TestClass_SimpleComponent_ProductionExecutorModule",
+            "        testClass_SimpleComponent_ProductionExecutorModule) {",
+            "      Preconditions.checkNotNull(testClass_SimpleComponent_ProductionExecutorModule);",
+            "      return this;",
+            "    }",
+            "}");
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and().generatesSources(generatedComponent);
+  }
+
+  @Test public void nullableProducersAreNotErrors() {
+    JavaFileObject component = JavaFileObjects.forSourceLines("test.TestClass",
+        "package test;",
+        "",
+        "import com.google.common.util.concurrent.ListenableFuture;",
+        "import com.google.common.util.concurrent.MoreExecutors;",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import dagger.producers.ProducerModule;",
+        "import dagger.producers.Produces;",
+        "import dagger.producers.Production;",
+        "import dagger.producers.ProductionComponent;",
+        "import java.util.concurrent.Executor;",
+        "import javax.annotation.Nullable;",
+        "import javax.inject.Inject;",
+        "",
+        "final class TestClass {",
+        "  interface A {}",
+        "  interface B {}",
+        "  interface C {}",
+        "",
+        "  @Module",
+        "  static final class CModule {",
+        "    @Provides @Nullable C c() {",
+        "      return null;",
+        "    }",
+        "",
+        "    @Provides @Production Executor executor() {",
+        "      return MoreExecutors.directExecutor();",
+        "    }",
+        "  }",
+        "",
+        "  @ProducerModule",
+        "  static final class ABModule {",
+        "    @Produces @Nullable B b(@Nullable C c) {",
+        "      return null;",
+        "    }",
+
+        "    @Produces @Nullable ListenableFuture<A> a(B b) {",  // NOTE: B not injected as nullable
+        "      return null;",
+        "    }",
+        "  }",
+        "",
+        "  @ProductionComponent(modules = {ABModule.class, CModule.class})",
+        "  interface SimpleComponent {",
+        "    ListenableFuture<A> a();",
+        "  }",
+        "}");
+    assertAbout(javaSource()).that(component)
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .withWarningContaining("@Nullable on @Produces methods does not do anything")
+        .in(component)
+        .onLine(33)
+        .and()
+        .withWarningContaining("@Nullable on @Produces methods does not do anything")
+        .in(component)
+        .onLine(36);
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java b/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
similarity index 100%
rename from compiler/src/test/java/dagger/internal/codegen/ProductionGraphValidationTest.java
rename to javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
diff --git a/javatests/dagger/internal/codegen/RepeatedModuleValidationTest.java b/javatests/dagger/internal/codegen/RepeatedModuleValidationTest.java
new file mode 100644
index 000000000..4fc74d811
--- /dev/null
+++ b/javatests/dagger/internal/codegen/RepeatedModuleValidationTest.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class RepeatedModuleValidationTest {
+  private static final JavaFileObject MODULE_FILE =
+      JavaFileObjects.forSourceLines(
+          "test.TestModule",
+          "package test;",
+          "",
+          "import dagger.Module;",
+          "",
+          "@Module",
+          "final class TestModule {}");
+
+  @Test
+  public void moduleRepeatedInSubcomponentFactoryMethod() {
+    JavaFileObject subcomponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestSubcomponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = TestModule.class)",
+            "interface TestSubcomponent {",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  TestSubcomponent newTestSubcomponent(TestModule module);",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("TestModule is present in test.TestComponent.")
+        .in(componentFile)
+        .onLine(7)
+        .atColumn(51);
+  }
+
+  @Test
+  public void moduleRepeatedInSubcomponentBuilderMethod() {
+    JavaFileObject subcomponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestSubcomponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = TestModule.class)",
+            "interface TestSubcomponent {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Builder testModule(TestModule testModule);",
+            "    TestSubcomponent build();",
+            "  }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  TestSubcomponent.Builder newTestSubcomponentBuilder();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+    // TODO(gak): assert about the warning when we have that ability
+  }
+
+  @Test
+  public void moduleRepeatedButNotPassed() {
+    JavaFileObject subcomponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestSubcomponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = TestModule.class)",
+            "interface TestSubcomponent {",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  TestSubcomponent newTestSubcomponent();",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError();
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/SourceFilesTest.java b/javatests/dagger/internal/codegen/SourceFilesTest.java
similarity index 100%
rename from compiler/src/test/java/dagger/internal/codegen/SourceFilesTest.java
rename to javatests/dagger/internal/codegen/SourceFilesTest.java
diff --git a/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
new file mode 100644
index 000000000..f4cb9ed51
--- /dev/null
+++ b/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
@@ -0,0 +1,1010 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+
+import com.google.common.base.Joiner;
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+/** Tests for {@link dagger.Subcomponent.Builder} validation. */
+@RunWith(JUnit4.class)
+public class SubcomponentBuilderValidationTest {
+
+  private static final ErrorMessages.SubcomponentBuilderMessages MSGS =
+      new ErrorMessages.SubcomponentBuilderMessages();
+
+  @Test
+  public void testRefSubcomponentAndSubBuilderFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent child();",
+        "  ChildComponent.Builder builder();",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static interface Builder {",
+        "    ChildComponent build();",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(MSGS.moreThanOneRefToSubcomponent(),
+            "test.ChildComponent", "[child(), builder()]"))
+        .in(componentFile);
+  }
+
+  @Test
+  public void testRefSubBuilderTwiceFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder builder1();",
+        "  ChildComponent.Builder builder2();",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static interface Builder {",
+        "    ChildComponent build();",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(MSGS.moreThanOneRefToSubcomponent(),
+            "test.ChildComponent", "[builder1(), builder2()]"))
+        .in(componentFile);
+  }
+
+  @Test
+  public void testMoreThanOneBuilderFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder1 build();",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static interface Builder1 {",
+        "    ChildComponent build();",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  static interface Builder2 {",
+        "    ChildComponent build();",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(MSGS.moreThanOne(),
+            "[test.ChildComponent.Builder1, test.ChildComponent.Builder2]"))
+        .in(childComponentFile);
+  }
+
+  @Test
+  public void testBuilderGenericsFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder1 build();",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder<T> {",
+        "     ChildComponent build();",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.generics())
+        .in(childComponentFile);
+  }
+
+  @Test
+  public void testBuilderNotInComponentFails() {
+    JavaFileObject builder = JavaFileObjects.forSourceLines("test.Builder",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent.Builder",
+        "interface Builder {}");
+    assertAbout(javaSource()).that(builder)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeInComponent())
+        .in(builder);
+  }
+
+  @Test
+  public void testBuilderMissingBuildMethodFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder1 build();",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.missingBuildMethod())
+        .in(childComponentFile);
+  }
+
+  @Test
+  public void testPrivateBuilderFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  private interface Builder {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.isPrivate())
+        .in(childComponentFile);
+  }
+
+  @Test
+  public void testNonStaticBuilderFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  abstract class Builder {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeStatic())
+        .in(childComponentFile);
+  }
+
+  @Test
+  public void testNonAbstractBuilderFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static class Builder {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeAbstract())
+        .in(childComponentFile);
+  }
+
+  @Test
+  public void testBuilderOneCxtorWithArgsFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static abstract class Builder {",
+        "    Builder(String unused) {}",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
+        .in(childComponentFile);
+  }
+
+  @Test
+  public void testBuilderMoreThanOneCxtorFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  static abstract class Builder {",
+        "    Builder() {}",
+        "    Builder(String unused) {}",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())
+        .in(childComponentFile);
+  }
+
+  @Test
+  public void testBuilderEnumFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  enum Builder {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.mustBeClassOrInterface())
+        .in(childComponentFile);
+  }
+
+  @Test
+  public void testBuilderBuildReturnsWrongTypeFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    String build();",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.buildMustReturnComponentType())
+            .in(childComponentFile).onLine(9);
+  }
+
+  @Test
+  public void testInheritedBuilderBuildReturnsWrongTypeFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  interface Parent {",
+        "    String build();",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedBuildMustReturnComponentType(), "build"))
+            .in(childComponentFile).onLine(12);
+  }
+
+  @Test
+  public void testTwoBuildMethodsFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent build();",
+        "    ChildComponent create();",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(String.format(MSGS.twoBuildMethods(), "build()"))
+            .in(childComponentFile).onLine(10);
+  }
+
+  @Test
+  public void testInheritedTwoBuildMethodsFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  interface Parent {",
+        "    ChildComponent build();",
+        "    ChildComponent create();",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedTwoBuildMethods(), "build()", "create()"))
+            .in(childComponentFile).onLine(13);
+  }
+
+  @Test
+  public void testMoreThanOneArgFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent build();",
+        "    Builder set(String s, Integer i);",
+        "    Builder set(Number n, Double d);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.methodsMustTakeOneArg())
+            .in(childComponentFile).onLine(10)
+        .and().withErrorContaining(MSGS.methodsMustTakeOneArg())
+            .in(childComponentFile).onLine(11);
+  }
+
+  @Test
+  public void testInheritedMoreThanOneArgFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  interface Parent {",
+        "    ChildComponent build();",
+        "    Builder set1(String s, Integer i);",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedMethodsMustTakeOneArg(),
+                "set1(java.lang.String,java.lang.Integer)"))
+            .in(childComponentFile).onLine(13);
+  }
+
+  @Test
+  public void testSetterReturningNonVoidOrBuilderFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent build();",
+        "    String set(Integer i);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())
+            .in(childComponentFile).onLine(10);
+  }
+
+  @Test
+  public void testInheritedSetterReturningNonVoidOrBuilderFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  interface Parent {",
+        "    ChildComponent build();",
+        "    String set(Integer i);",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(),
+                "set(java.lang.Integer)"))
+            .in(childComponentFile).onLine(13);
+  }
+
+  @Test
+  public void testGenericsOnSetterMethodFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent build();",
+        "    <T> Builder set(T t);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(MSGS.methodsMayNotHaveTypeParameters())
+            .in(childComponentFile).onLine(10);
+  }
+
+  @Test
+  public void testGenericsOnInheritedSetterMethodFails() {
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "abstract class ChildComponent {",
+        "  interface Parent {",
+        "    ChildComponent build();",
+        "    <T> Builder set(T t);",
+        "  }",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder extends Parent {}",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.inheritedMethodsMayNotHaveTypeParameters(), "<T>set(T)"))
+            .in(childComponentFile).onLine(13);
+  }
+
+  @Test
+  public void testMultipleSettersPerTypeFails() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides String s() { return \"\"; }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ParentComponent {",
+            "  ChildComponent.Builder childComponentBuilder();",
+            "}");
+    JavaFileObject childComponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.ChildComponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = TestModule.class)",
+            "abstract class ChildComponent {",
+            "  abstract String s();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    ChildComponent build();",
+            "    void set1(TestModule s);",
+            "    void set2(TestModule s);",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(
+                MSGS.manyMethodsForType(),
+                "test.TestModule",
+                "[set1(test.TestModule), set2(test.TestModule)]"))
+        .in(childComponentFile)
+        .onLine(10);
+  }
+
+  @Test
+  public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides String s() { return \"\"; }",
+            "}");
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ParentComponent {",
+            "  ChildComponent.Builder childComponentBuilder();",
+            "}");
+    JavaFileObject childComponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.ChildComponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = TestModule.class)",
+            "abstract class ChildComponent {",
+            "  abstract String s();",
+            "",
+            "  interface Parent<T> {",
+            "    void set1(T t);",
+            "  }",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder extends Parent<TestModule> {",
+            "    ChildComponent build();",
+            "    void set2(TestModule s);",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(
+                MSGS.manyMethodsForType(), "test.TestModule", "[set1(T), set2(test.TestModule)]"))
+        .in(childComponentFile)
+        .onLine(14);
+  }
+
+  @Test
+  public void testMultipleSettersPerBoundInstanceTypeFails() {
+    JavaFileObject componentFile =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ParentComponent {",
+            "  ChildComponent.Builder childComponentBuilder();",
+            "}");
+    JavaFileObject childComponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.ChildComponent",
+            "package test;",
+            "",
+            "import dagger.BindsInstance;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface ChildComponent {",
+            "  String s();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    ChildComponent build();",
+            "    @BindsInstance void set1(String s);",
+            "    @BindsInstance void set2(String s);",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            Joiner.on("\n      ")
+                .join(
+                    "java.lang.String is bound multiple times:",
+                    "@BindsInstance void test.ChildComponent.Builder.set1(String)",
+                    "@BindsInstance void test.ChildComponent.Builder.set2(String)"))
+        .in(childComponentFile)
+        .onLine(8);
+  }
+
+  @Test
+  public void testExtraSettersFails() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder build();",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent build();",
+        "    void set1(String s);",
+        "    void set2(Integer s);",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            String.format(MSGS.extraSetters(),
+                  "[void test.ChildComponent.Builder.set1(String),"
+                  + " void test.ChildComponent.Builder.set2(Integer)]"))
+            .in(childComponentFile).onLine(8);
+  }
+
+  @Test
+  public void testMissingSettersFail() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  TestModule(String unused) {}",
+        "  @Provides String s() { return null; }",
+        "}");
+    JavaFileObject module2File = JavaFileObjects.forSourceLines("test.Test2Module",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class Test2Module {",
+        "  @Provides Integer i() { return null; }",
+        "}");
+    JavaFileObject module3File = JavaFileObjects.forSourceLines("test.Test3Module",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class Test3Module {",
+        "  Test3Module(String unused) {}",
+        "  @Provides Double d() { return null; }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Provider;",
+        "",
+        "@Component",
+        "interface ParentComponent {",
+        "  ChildComponent.Builder build();",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent(modules = {TestModule.class, Test2Module.class, Test3Module.class})",
+        "interface ChildComponent {",
+        "  String string();",
+        "  Integer integer();",
+        "",
+        "  @Subcomponent.Builder",
+        "  interface Builder {",
+        "    ChildComponent create();",
+        "  }",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile,
+            module2File,
+            module3File,
+            componentFile,
+            childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            // Ignores Test2Module because we can construct it ourselves.
+            // TODO(sameb): Ignore Test3Module because it's not used within transitive dependencies.
+            String.format(MSGS.missingSetters(), "[test.TestModule, test.Test3Module]"))
+            .in(childComponentFile).onLine(11);
+  }
+
+  @Test
+  public void covariantBuildMethodReturnType() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface HasSupertype extends Supertype {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Supertype build();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(foo, supertype, subcomponent);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void covariantBuildMethodReturnType_hasNewMethod() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject bar =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Bar {",
+            "  @Inject Bar() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface HasSupertype extends Supertype {",
+            "  Bar bar();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Supertype build();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(foo, bar, supertype, subcomponent);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining(
+            "test.HasSupertype.Builder.build() returns test.Supertype, but test.HasSupertype "
+                + "declares additional component method(s): bar(). In order to provide type-safe "
+                + "access to these methods, override build() to return test.HasSupertype")
+        .inFile(subcomponent)
+        .onLine(11);
+  }
+
+  @Test
+  public void covariantBuildMethodReturnType_hasNewMethod_buildMethodInherited() {
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Foo {",
+            "  @Inject Foo() {}",
+            "}");
+    JavaFileObject bar =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class Bar {",
+            "  @Inject Bar() {}",
+            "}");
+    JavaFileObject supertype =
+        JavaFileObjects.forSourceLines(
+            "test.Supertype",
+            "package test;",
+            "",
+            "interface Supertype {",
+            "  Foo foo();",
+            "}");
+
+    JavaFileObject builderSupertype =
+        JavaFileObjects.forSourceLines(
+            "test.BuilderSupertype",
+            "package test;",
+            "",
+            "interface BuilderSupertype {",
+            "  Supertype build();",
+            "}");
+
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.HasSupertype",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface HasSupertype extends Supertype {",
+            "  Bar bar();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder extends BuilderSupertype {}",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(foo, bar, supertype, builderSupertype, subcomponent);
+    assertThat(compilation).succeeded();
+    assertThat(compilation)
+        .hadWarningContaining(
+            "[test.BuilderSupertype.build()] test.HasSupertype.Builder.build() returns "
+                + "test.Supertype, but test.HasSupertype declares additional component method(s): "
+                + "bar(). In order to provide type-safe access to these methods, override build() "
+                + "to return test.HasSupertype");
+  }
+}
diff --git a/javatests/dagger/internal/codegen/SubcomponentValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
new file mode 100644
index 000000000..225918e9a
--- /dev/null
+++ b/javatests/dagger/internal/codegen/SubcomponentValidationTest.java
@@ -0,0 +1,1117 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.truth.Truth.assertAbout;
+import static com.google.testing.compile.JavaSourcesSubject.assertThat;
+import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+
+import com.google.common.collect.ImmutableList;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class SubcomponentValidationTest {
+  @Test public void factoryMethod_missingModulesWithParameters() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  ChildComponent newChildComponent();",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent(modules = ModuleWithParameters.class)",
+        "interface ChildComponent {",
+        "  Object object();",
+        "}");
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ModuleWithParameters",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class ModuleWithParameters {",
+        "  private final Object object;",
+        "",
+        "  ModuleWithParameters(Object object) {",
+        "    this.object = object;",
+        "  }",
+        "",
+        "  @Provides Object object() {",
+        "    return object;",
+        "  }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile, moduleFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "test.ChildComponent requires modules which have no visible default constructors. "
+                + "Add the following modules as parameters to this method: "
+                + "test.ModuleWithParameters")
+        .in(componentFile).onLine(7);
+  }
+
+  @Test public void factoryMethod_nonModuleParameter() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  ChildComponent newChildComponent(String someRandomString);",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "Subcomponent factory methods may only accept modules, but java.lang.String is not.")
+        .in(componentFile).onLine(7).atColumn(43);
+  }
+
+  @Test public void factoryMethod_duplicateParameter() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "final class TestModule {}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  ChildComponent newChildComponent(TestModule testModule1, TestModule testModule2);",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent(modules = TestModule.class)",
+        "interface ChildComponent {}");
+    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "A module may only occur once an an argument in a Subcomponent factory method, "
+                + "but test.TestModule was already passed.")
+        .in(componentFile).onLine(7).atColumn(71);
+  }
+
+  @Test public void factoryMethod_superflouousModule() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "",
+        "@Module",
+        "final class TestModule {}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  ChildComponent newChildComponent(TestModule testModule);",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "interface ChildComponent {}");
+    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
+    .processedWith(new ComponentProcessor())
+    .failsToCompile()
+    .withErrorContaining(
+        "test.TestModule is present as an argument to the test.ChildComponent factory method, but "
+            + "is not one of the modules used to implement the subcomponent.")
+                .in(componentFile).onLine(7);
+  }
+
+  @Test public void missingBinding() {
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "",
+        "@Module",
+        "final class TestModule {",
+        "  @Provides String provideString(int i) {",
+        "    return Integer.toString(i);",
+        "  }",
+        "}");
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "",
+        "@Component",
+        "interface TestComponent {",
+        "  ChildComponent newChildComponent();",
+        "}");
+    JavaFileObject childComponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent(modules = TestModule.class)",
+        "interface ChildComponent {",
+        "  String getString();",
+        "}");
+    assertAbout(javaSources())
+        .that(ImmutableList.of(moduleFile, componentFile, childComponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining(
+            "[test.ChildComponent.getString()] "
+                + "java.lang.Integer cannot be provided without an @Inject constructor or from an "
+                + "@Provides-annotated method")
+        .in(componentFile)
+        .onLine(6);
+  }
+
+  @Test public void subcomponentOnConcreteType() {
+    JavaFileObject subcomponentFile = JavaFileObjects.forSourceLines("test.NotASubcomponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent",
+        "final class NotASubcomponent {}");
+    assertAbout(javaSources()).that(ImmutableList.of(subcomponentFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("interface");
+  }
+
+  @Test public void scopeMismatch() {
+    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.ParentComponent",
+        "package test;",
+        "",
+        "import dagger.Component;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Component",
+        "@Singleton",
+        "interface ParentComponent {",
+        "  ChildComponent childComponent();",
+        "}");
+    JavaFileObject subcomponentFile = JavaFileObjects.forSourceLines("test.ChildComponent",
+        "package test;",
+        "",
+        "import dagger.Subcomponent;",
+        "",
+        "@Subcomponent(modules = ChildModule.class)",
+        "interface ChildComponent {",
+        "  Object getObject();",
+        "}");
+    JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.ChildModule",
+        "package test;",
+        "",
+        "import dagger.Module;",
+        "import dagger.Provides;",
+        "import javax.inject.Singleton;",
+        "",
+        "@Module",
+        "final class ChildModule {",
+        "  @Provides @Singleton Object provideObject() { return null; }",
+        "}");
+    assertAbout(javaSources()).that(ImmutableList.of(componentFile, subcomponentFile, moduleFile))
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("@Singleton");
+  }
+
+  @Test
+  public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent() {
+    JavaFileObject parentComponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ParentComponent {",
+            "  ChildComponent childComponent();",
+            "  Dep1 getDep1();",
+            "  Dep2 getDep2();",
+            "}");
+    JavaFileObject childComponentFile =
+        JavaFileObjects.forSourceLines(
+            "test.ChildComponent",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = ChildModule.class)",
+            "interface ChildComponent {",
+            "  Object getObject();",
+            "}");
+    JavaFileObject childModuleFile =
+        JavaFileObjects.forSourceLines(
+            "test.ChildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class ChildModule {",
+            "  @Provides Object provideObject(A a) { return null; }",
+            "}");
+    JavaFileObject aFile =
+        JavaFileObjects.forSourceLines(
+            "test.A",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class A {",
+            "  @Inject public A(NeedsDep1 a, Dep1 b, Dep2 c) { }",
+            "  @Inject public void methodA() { }",
+            "}");
+    JavaFileObject needsDep1File =
+        JavaFileObjects.forSourceLines(
+            "test.NeedsDep1",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class NeedsDep1 {",
+            "  @Inject public NeedsDep1(Dep1 d) { }",
+            "}");
+    JavaFileObject dep1File =
+        JavaFileObjects.forSourceLines(
+            "test.Dep1",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class Dep1 {",
+            "  @Inject public Dep1() { }",
+            "  @Inject public void dep1Method() { }",
+            "}");
+    JavaFileObject dep2File =
+        JavaFileObjects.forSourceLines(
+            "test.Dep2",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class Dep2 {",
+            "  @Inject public Dep2() { }",
+            "  @Inject public void dep2Method() { }",
+            "}");
+
+    JavaFileObject componentGeneratedFile =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParentComponent",
+            "package test;",
+            "",
+            "import dagger.MembersInjector;",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParentComponent implements ParentComponent {",
+            "  private MembersInjector<Dep1> dep1MembersInjector;",
+            "  private Provider<Dep1> dep1Provider;",
+            "  private MembersInjector<Dep2> dep2MembersInjector;",
+            "  private Provider<Dep2> dep2Provider;",
+            "",
+            "  private DaggerParentComponent(Builder builder) {  ",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {  ",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static ParentComponent create() {  ",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {  ",
+            "    this.dep1MembersInjector = Dep1_MembersInjector.create();",
+            "    this.dep1Provider = Dep1_Factory.create(dep1MembersInjector);",
+            "    this.dep2MembersInjector = Dep2_MembersInjector.create();",
+            "    this.dep2Provider = Dep2_Factory.create(dep2MembersInjector);",
+            "  }",
+            "",
+            "  @Override",
+            "  public Dep1 getDep1() {  ",
+            "    return dep1Provider.get();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Dep2 getDep2() {  ",
+            "    return dep2Provider.get();",
+            "  }",
+            "",
+            "  @Override",
+            "  public ChildComponent childComponent() {  ",
+            "    return new ChildComponentImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {  ",
+            "    }",
+            "  ",
+            "    public ParentComponent build() {  ",
+            "      return new DaggerParentComponent(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class ChildComponentImpl implements ChildComponent {",
+            "    private final ChildModule childModule;",
+            "    private MembersInjector<A> aMembersInjector;",
+            "    private Provider<NeedsDep1> needsDep1Provider;",
+            "    private Provider<A> aProvider;",
+            "    private Provider<Object> provideObjectProvider;",
+            "  ",
+            "    private ChildComponentImpl() {  ",
+            "      this.childModule = new ChildModule();",
+            "      initialize();",
+            "    }",
+            "",
+            "    @SuppressWarnings(\"unchecked\")",
+            "    private void initialize() {  ",
+            "      this.aMembersInjector = A_MembersInjector.create();",
+            "      this.needsDep1Provider = NeedsDep1_Factory.create(",
+            "          DaggerParentComponent.this.dep1Provider);",
+            "      this.aProvider = A_Factory.create(",
+            "          aMembersInjector,",
+            "          needsDep1Provider,",
+            "          DaggerParentComponent.this.dep1Provider,",
+            "          DaggerParentComponent.this.dep2Provider);",
+            "      this.provideObjectProvider = ChildModule_ProvideObjectFactory.create(",
+            "          childModule, aProvider);",
+            "    }",
+            "  ",
+            "    @Override",
+            "    public Object getObject() {  ",
+            "      return provideObjectProvider.get();",
+            "    }",
+            "  }",
+            "}");
+    assertAbout(javaSources())
+        .that(
+            ImmutableList.of(
+                parentComponentFile,
+                childComponentFile,
+                childModuleFile,
+                aFile,
+                needsDep1File,
+                dep1File,
+                dep2File))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(componentGeneratedFile);
+  }
+
+  @Test
+  public void multipleSubcomponentsWithSameSimpleNamesCanExistInSameComponent() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ParentComponent {",
+            "  Foo.Sub newFooSubcomponent();",
+            "  NoConflict newNoConflictSubcomponent();",
+            "}");
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "interface Foo {",
+            "  @Subcomponent interface Sub {",
+            "    Bar.Sub newBarSubcomponent();",
+            "  }",
+            "}");
+    JavaFileObject bar =
+        JavaFileObjects.forSourceLines(
+            "test.Bar",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "interface Bar {",
+            "  @Subcomponent interface Sub {",
+            "    test.subpackage.Sub newSubcomponentInSubpackage();",
+            "  }",
+            "}");
+    JavaFileObject baz =
+        JavaFileObjects.forSourceLines(
+            "test.subpackage.Sub",
+            "package test.subpackage;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent public interface Sub {}");
+    JavaFileObject noConflict =
+        JavaFileObjects.forSourceLines(
+            "test.NoConflict",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent interface NoConflict {}");
+
+    JavaFileObject componentGeneratedFile =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParentComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "import test.subpackage.Sub;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParentComponent implements ParentComponent {",
+            "  private DaggerParentComponent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static ParentComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Foo.Sub newFooSubcomponent() {",
+            "    return new F_SubImpl();",
+            "  }",
+            "",
+            "  @Override",
+            "  public NoConflict newNoConflictSubcomponent() {",
+            "    return new NoConflictImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public ParentComponent build() {",
+            "      return new DaggerParentComponent(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class F_SubImpl implements Foo.Sub {",
+            "",
+            "    private F_SubImpl() {}",
+            "",
+            "    @Override",
+            "    public Bar.Sub newBarSubcomponent() {",
+            "      return new B_SubImpl();",
+            "    }",
+            "",
+            "    private final class B_SubImpl implements Bar.Sub {",
+            "",
+            "      private B_SubImpl() {}",
+            "",
+            "      @Override",
+            "      public Sub newSubcomponentInSubpackage() {",
+            "        return new ts_SubImpl();",
+            "      }",
+            "",
+            "      private final class ts_SubImpl implements Sub {",
+            "        private ts_SubImpl() {}",
+            "      }",
+            "    }",
+            "  }",
+            "  private final class NoConflictImpl implements NoConflict {",
+            "    private NoConflictImpl() {}",
+            "  }",
+            "}");
+
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, foo, bar, baz, noConflict))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(componentGeneratedFile);
+  }
+
+  @Test
+  public void subcomponentSimpleNamesDisambiguated() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ParentComponent {",
+            "  Sub newSubcomponent();",
+            "}");
+    JavaFileObject sub =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent interface Sub {",
+            "  test.deep.many.levels.that.match.test.Sub newDeepSubcomponent();",
+            "}");
+    JavaFileObject deepSub =
+        JavaFileObjects.forSourceLines(
+            "test.deep.many.levels.that.match.test.Sub",
+            "package test.deep.many.levels.that.match.test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent public interface Sub {}");
+
+    JavaFileObject componentGeneratedFile =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParentComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParentComponent implements ParentComponent {",
+            "  private DaggerParentComponent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static ParentComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Sub newSubcomponent() {",
+            "    return new t_SubImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public ParentComponent build() {",
+            "      return new DaggerParentComponent(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class t_SubImpl implements Sub {",
+            "",
+            "    private t_SubImpl() {}",
+            "",
+            "    @Override",
+            "    public test.deep.many.levels.that.match.test.Sub newDeepSubcomponent() {",
+            "      return new tdmltmt_SubImpl();",
+            "    }",
+            "",
+            "    private final class tdmltmt_SubImpl implements ",
+            "        test.deep.many.levels.that.match.test.Sub {",
+            "      private tdmltmt_SubImpl() {}",
+            "    }",
+            "  }",
+            "}");
+
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, sub, deepSub))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(componentGeneratedFile);
+  }
+
+  @Test
+  public void subcomponentSimpleNamesDisambiguatedInRoot() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "ParentComponent",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ParentComponent {",
+            "  Sub newSubcomponent();",
+            "}");
+    JavaFileObject sub =
+        JavaFileObjects.forSourceLines(
+            "Sub",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent interface Sub {",
+            "  test.deep.many.levels.that.match.test.Sub newDeepSubcomponent();",
+            "}");
+    JavaFileObject deepSub =
+        JavaFileObjects.forSourceLines(
+            "test.deep.many.levels.that.match.test.Sub",
+            "package test.deep.many.levels.that.match.test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent public interface Sub {}");
+
+    JavaFileObject componentGeneratedFile =
+        JavaFileObjects.forSourceLines(
+            "DaggerParentComponent",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParentComponent implements ParentComponent {",
+            "  private DaggerParentComponent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static ParentComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Sub newSubcomponent() {",
+            "    return new $_SubImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public ParentComponent build() {",
+            "      return new DaggerParentComponent(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class $_SubImpl implements Sub {",
+            "    private $_SubImpl() {}",
+            "",
+            "    @Override",
+            "    public test.deep.many.levels.that.match.test.Sub newDeepSubcomponent() {",
+            "      return new tdmltmt_SubImpl();",
+            "    }",
+            "",
+            "    private final class tdmltmt_SubImpl implements ",
+            "        test.deep.many.levels.that.match.test.Sub {",
+            "      private tdmltmt_SubImpl() {}",
+            "    }",
+            "  }",
+            "}",
+            "");
+
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, sub, deepSub))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(componentGeneratedFile);
+  }
+
+  @Test
+  public void subcomponentImplNameUsesFullyQualifiedClassNameIfNecessary() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface ParentComponent {",
+            "  top1.a.b.c.d.E.F.Sub top1();",
+            "  top2.a.b.c.d.E.F.Sub top2();",
+            "}");
+    JavaFileObject top1 =
+        JavaFileObjects.forSourceLines(
+            "top1.a.b.c.d.E",
+            "package top1.a.b.c.d;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "public interface E {",
+            "  interface F {",
+            "    @Subcomponent interface Sub {}",
+            "  }",
+            "}");
+    JavaFileObject top2 =
+        JavaFileObjects.forSourceLines(
+            "top2.a.b.c.d.E",
+            "package top2.a.b.c.d;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "public interface E {",
+            "  interface F {",
+            "    @Subcomponent interface Sub {}",
+            "  }",
+            "}");
+
+    JavaFileObject componentGeneratedFile =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerParentComponent",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "import top1.a.b.c.d.E;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerParentComponent implements ParentComponent {",
+            "  private DaggerParentComponent(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static ParentComponent create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public E.F.Sub top1() {",
+            "    return new F_SubImpl();",
+            "  }",
+            "",
+            "  @Override",
+            "  public top2.a.b.c.d.E.F.Sub top2() {",
+            "    return new F2_SubImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public ParentComponent build() {",
+            "      return new DaggerParentComponent(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class F_SubImpl implements E.F.Sub {",
+            "    private F_SubImpl() {}",
+            "  }",
+            "  private final class F2_SubImpl implements top2.a.b.c.d.E.F.Sub {",
+            "    private F2_SubImpl() {}",
+            "  }",
+            "}");
+
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, top1, top2))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(componentGeneratedFile);
+  }
+
+  @Test
+  public void parentComponentNameShouldNotBeDisambiguatedWhenItConflictsWithASubcomponent() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface C {",
+            "  test.Foo.C newFooC();",
+            "}");
+    JavaFileObject subcomponentWithSameSimpleNameAsParent =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "interface Foo {",
+            "  @Subcomponent interface C {}",
+            "}");
+
+    JavaFileObject componentGeneratedFile =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerC",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerC implements C {",
+            "  private DaggerC(Builder builder) {",
+            "    assert builder != null;",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static C create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @Override",
+            "  public Foo.C newFooC() {",
+            "    return new F_CImpl();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public C build() {",
+            "      return new DaggerC(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class F_CImpl implements Foo.C {",
+            "    private F_CImpl() {}",
+            "  }",
+            "}");
+
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent, subcomponentWithSameSimpleNameAsParent))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(componentGeneratedFile);
+  }
+
+  @Test
+  public void subcomponentBuilderNamesShouldNotConflict() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.C",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import dagger.Subcomponent;",
+            "",
+            "@Component",
+            "interface C {",
+            "  Foo.Sub.Builder fooBuilder();",
+            "  Bar.Sub.Builder barBuilder();",
+            "",
+            "  interface Foo {",
+            "    @Subcomponent",
+            "    interface Sub {",
+            "      @Subcomponent.Builder",
+            "      interface Builder {",
+            "        Sub build();",
+            "      }",
+            "    }",
+            "  }",
+            "",
+            "  interface Bar {",
+            "    @Subcomponent",
+            "    interface Sub {",
+            "      @Subcomponent.Builder",
+            "      interface Builder {",
+            "        Sub build();",
+            "      }",
+            "    }",
+            "  }",
+            "}");
+    JavaFileObject componentGeneratedFile =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerC",
+            "package test;",
+            "",
+            "import javax.annotation.Generated;",
+            "import javax.inject.Provider;",
+            "",
+            GENERATED_ANNOTATION,
+            "public final class DaggerC implements C {",
+            "",
+            "  private Provider<C.Foo.Sub.Builder> fooBuilderProvider;",
+            "  private Provider<C.Bar.Sub.Builder> barBuilderProvider;",
+            "",
+            "  private DaggerC(Builder builder) {",
+            "    assert builder != null;",
+            "    initialize(builder);",
+            "  }",
+            "",
+            "  public static Builder builder() {",
+            "    return new Builder();",
+            "  }",
+            "",
+            "  public static C create() {",
+            "    return new Builder().build();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize(final Builder builder) {",
+            "    this.fooBuilderProvider = ",
+            "        new dagger.internal.Factory<C.Foo.Sub.Builder>() {",
+            "          @Override",
+            "          public C.Foo.Sub.Builder get() {",
+            "            return new F_SubBuilder();",
+            "          }",
+            "        };",
+            "",
+            "    this.barBuilderProvider = ",
+            "        new dagger.internal.Factory<C.Bar.Sub.Builder>() {",
+            "          @Override",
+            "          public C.Bar.Sub.Builder get() {",
+            "            return new B_SubBuilder();",
+            "          }",
+            "        };",
+            "  }",
+            "",
+            "  @Override",
+            "  public C.Foo.Sub.Builder fooBuilder() {",
+            "    return fooBuilderProvider.get();",
+            "  }",
+            "",
+            "  @Override",
+            "  public C.Bar.Sub.Builder barBuilder() {",
+            "    return barBuilderProvider.get();",
+            "  }",
+            "",
+            "  public static final class Builder {",
+            "    private Builder() {}",
+            "",
+            "    public C build() {",
+            "      return new DaggerC(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class F_SubBuilder implements C.Foo.Sub.Builder {",
+            "    @Override",
+            "    public C.Foo.Sub build() {",
+            "      return new F_SubImpl(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class F_SubImpl implements C.Foo.Sub {",
+            "    private F_SubImpl(F_SubBuilder builder) {",
+            "      assert builder != null;",
+            "    }",
+            "  }",
+            "",
+            "  private final class B_SubBuilder implements C.Bar.Sub.Builder {",
+            "    @Override",
+            "    public C.Bar.Sub build() {",
+            "      return new B_SubImpl(this);",
+            "    }",
+            "  }",
+            "",
+            "  private final class B_SubImpl implements C.Bar.Sub {",
+            "    private B_SubImpl(B_SubBuilder builder) {",
+            "      assert builder != null;",
+            "    }",
+            "  }",
+            "}");
+
+    assertAbout(javaSources())
+        .that(ImmutableList.of(parent))
+        .processedWith(new ComponentProcessor())
+        .compilesWithoutError()
+        .and()
+        .generatesSources(componentGeneratedFile);
+  }
+
+  @Test
+  public void duplicateBindingWithSubcomponentDeclaration() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module(subcomponents = Sub.class)",
+            "class TestModule {",
+            "  @Provides Sub.Builder providesConflictsWithModuleSubcomponents() { return null; }",
+            "  @Provides Object usesSubcomponentBuilder(Sub.Builder builder) {",
+            "    return new Builder().toString();",
+            "  }",
+            "}");
+
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Sub {",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Sub build();",
+            "  }",
+            "}");
+
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.Sub",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface C {",
+            "  Object dependsOnBuilder();",
+            "}");
+
+    assertThat(module, component, subcomponent)
+        .processedWith(new ComponentProcessor())
+        .failsToCompile()
+        .withErrorContaining("test.Sub.Builder is bound multiple times:")
+        .and()
+        .withErrorContaining(
+            "@Provides test.Sub.Builder test.TestModule.providesConflictsWithModuleSubcomponents()")
+        .and()
+        .withErrorContaining("@Module(subcomponents = test.Sub.class) for test.TestModule");
+  }
+}
diff --git a/compiler/src/test/java/dagger/internal/codegen/ValidationReportTest.java b/javatests/dagger/internal/codegen/ValidationReportTest.java
similarity index 100%
rename from compiler/src/test/java/dagger/internal/codegen/ValidationReportTest.java
rename to javatests/dagger/internal/codegen/ValidationReportTest.java
diff --git a/javatests/dagger/producers/BUILD b/javatests/dagger/producers/BUILD
new file mode 100644
index 000000000..1d353ee13
--- /dev/null
+++ b/javatests/dagger/producers/BUILD
@@ -0,0 +1,40 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   Tests for dagger.producers
+
+package(default_visibility = ["//:src"])
+
+load(
+    "//:build_defs.bzl",
+    "DOCLINT_HTML_AND_SYNTAX",
+    "DOCLINT_REFERENCES",
+    "SOURCE_7_TARGET_7",
+)
+load("//:test_defs.bzl", "GenJavaTests")
+
+GenJavaTests(
+    name = "producers_tests",
+    srcs = glob(["**/*.java"]),
+    javacopts = SOURCE_7_TARGET_7 + DOCLINT_REFERENCES + DOCLINT_HTML_AND_SYNTAX,
+    deps = [
+        "//java/dagger/producers",
+        "//third_party:guava",
+        "//third_party:guava_testlib",
+        "//third_party:junit",
+        "//third_party:mockito",
+        "//third_party:truth",
+    ],
+)
diff --git a/producers/src/test/java/dagger/producers/ProducedTest.java b/javatests/dagger/producers/ProducedTest.java
similarity index 100%
rename from producers/src/test/java/dagger/producers/ProducedTest.java
rename to javatests/dagger/producers/ProducedTest.java
diff --git a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java b/javatests/dagger/producers/internal/AbstractProducerTest.java
similarity index 100%
rename from producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
rename to javatests/dagger/producers/internal/AbstractProducerTest.java
diff --git a/producers/src/test/java/dagger/producers/internal/MapOfProducerProducerTest.java b/javatests/dagger/producers/internal/MapOfProducerProducerTest.java
similarity index 100%
rename from producers/src/test/java/dagger/producers/internal/MapOfProducerProducerTest.java
rename to javatests/dagger/producers/internal/MapOfProducerProducerTest.java
diff --git a/producers/src/test/java/dagger/producers/internal/MapProducerTest.java b/javatests/dagger/producers/internal/MapProducerTest.java
similarity index 100%
rename from producers/src/test/java/dagger/producers/internal/MapProducerTest.java
rename to javatests/dagger/producers/internal/MapProducerTest.java
diff --git a/producers/src/test/java/dagger/producers/internal/ProducersTest.java b/javatests/dagger/producers/internal/ProducersTest.java
similarity index 100%
rename from producers/src/test/java/dagger/producers/internal/ProducersTest.java
rename to javatests/dagger/producers/internal/ProducersTest.java
diff --git a/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java b/javatests/dagger/producers/internal/SetOfProducedProducerTest.java
similarity index 100%
rename from producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java
rename to javatests/dagger/producers/internal/SetOfProducedProducerTest.java
diff --git a/producers/src/test/java/dagger/producers/internal/SetProducerTest.java b/javatests/dagger/producers/internal/SetProducerTest.java
similarity index 100%
rename from producers/src/test/java/dagger/producers/internal/SetProducerTest.java
rename to javatests/dagger/producers/internal/SetProducerTest.java
diff --git a/producers/src/test/java/dagger/producers/monitoring/TimingProductionComponentMonitorTest.java b/javatests/dagger/producers/monitoring/TimingProductionComponentMonitorTest.java
similarity index 100%
rename from producers/src/test/java/dagger/producers/monitoring/TimingProductionComponentMonitorTest.java
rename to javatests/dagger/producers/monitoring/TimingProductionComponentMonitorTest.java
diff --git a/javatests/dagger/producers/monitoring/TimingRecordersTest.java b/javatests/dagger/producers/monitoring/TimingRecordersTest.java
new file mode 100644
index 000000000..ef0f21872
--- /dev/null
+++ b/javatests/dagger/producers/monitoring/TimingRecordersTest.java
@@ -0,0 +1,360 @@
+/*
+ * Copyright (C) 2015 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.producers.monitoring;
+
+import static com.google.common.truth.Truth.assertThat;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.anyLong;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.inOrder;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+import com.google.common.collect.ImmutableList;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+import org.mockito.InOrder;
+import org.mockito.Mock;
+import org.mockito.MockitoAnnotations;
+
+@RunWith(JUnit4.class)
+public final class TimingRecordersTest {
+  @Mock
+  private ProductionComponentTimingRecorder.Factory mockProductionComponentTimingRecorderFactory;
+
+  @Mock private ProductionComponentTimingRecorder mockProductionComponentTimingRecorder;
+  @Mock private ProducerTimingRecorder mockProducerTimingRecorder;
+
+  @Mock
+  private ProductionComponentTimingRecorder.Factory mockProductionComponentTimingRecorderFactoryA;
+
+  @Mock
+  private ProductionComponentTimingRecorder.Factory mockProductionComponentTimingRecorderFactoryB;
+
+  @Mock
+  private ProductionComponentTimingRecorder.Factory mockProductionComponentTimingRecorderFactoryC;
+
+  @Mock private ProductionComponentTimingRecorder mockProductionComponentTimingRecorderA;
+  @Mock private ProductionComponentTimingRecorder mockProductionComponentTimingRecorderB;
+  @Mock private ProductionComponentTimingRecorder mockProductionComponentTimingRecorderC;
+  @Mock private ProducerTimingRecorder mockProducerTimingRecorderA;
+  @Mock private ProducerTimingRecorder mockProducerTimingRecorderB;
+  @Mock private ProducerTimingRecorder mockProducerTimingRecorderC;
+
+  @Before
+  public void initMocks() {
+    MockitoAnnotations.initMocks(this);
+  }
+
+  @Test
+  public void zeroRecordersReturnsNoOp() {
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.<ProductionComponentTimingRecorder.Factory>of());
+    assertThat(factory).isSameAs(TimingRecorders.noOpProductionComponentTimingRecorderFactory());
+  }
+
+  @Test
+  public void singleRecorder_nullProductionComponentTimingRecorder() {
+    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class))).thenReturn(null);
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    assertThat(factory.create(new Object()))
+        .isSameAs(TimingRecorders.noOpProductionComponentTimingRecorder());
+  }
+
+  @Test
+  public void singleRecorder_throwingProductionComponentTimingRecorderFactory() {
+    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    assertThat(factory.create(new Object()))
+        .isSameAs(TimingRecorders.noOpProductionComponentTimingRecorder());
+  }
+
+  @Test
+  public void singleRecorder_nullProducerTimingRecorder() {
+    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorder);
+    when(mockProductionComponentTimingRecorder.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(null);
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    assertThat(recorder.producerTimingRecorderFor(ProducerToken.create(Object.class)))
+        .isSameAs(ProducerTimingRecorder.noOp());
+  }
+
+  @Test
+  public void singleRecorder_throwingProductionComponentTimingRecorder() {
+    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorder);
+    when(mockProductionComponentTimingRecorder.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    assertThat(recorder.producerTimingRecorderFor(ProducerToken.create(Object.class)))
+        .isSameAs(ProducerTimingRecorder.noOp());
+  }
+
+  @Test
+  public void singleRecorder_normalProducerTimingRecorderSuccess() {
+    setUpNormalSingleRecorder();
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordSuccess(100);
+
+    InOrder order = inOrder(mockProducerTimingRecorder);
+    order.verify(mockProducerTimingRecorder).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorder).recordSuccess(100);
+    verifyNoMoreInteractions(mockProducerTimingRecorder);
+  }
+
+  @Test
+  public void singleRecorder_normalProducerTimingRecorderFailure() {
+    setUpNormalSingleRecorder();
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+    Throwable t = new RuntimeException("monkey");
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordFailure(t, 100);
+
+    InOrder order = inOrder(mockProducerTimingRecorder);
+    order.verify(mockProducerTimingRecorder).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorder).recordFailure(t, 100);
+    verifyNoMoreInteractions(mockProducerTimingRecorder);
+  }
+
+  @Test
+  public void singleRecorder_throwingProducerTimingRecorderSuccess() {
+    setUpNormalSingleRecorder();
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProducerTimingRecorder)
+        .recordMethod(anyLong(), anyLong());
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProducerTimingRecorder)
+        .recordSuccess(anyLong());
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordSuccess(100);
+
+    InOrder order = inOrder(mockProducerTimingRecorder);
+    order.verify(mockProducerTimingRecorder).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorder).recordSuccess(100);
+    verifyNoMoreInteractions(mockProducerTimingRecorder);
+  }
+
+  @Test
+  public void multipleRecorders_nullProductionComponentTimingRecorders() {
+    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class))).thenReturn(null);
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(
+                mockProductionComponentTimingRecorderFactoryA,
+                mockProductionComponentTimingRecorderFactoryB,
+                mockProductionComponentTimingRecorderFactoryC));
+    assertThat(factory.create(new Object()))
+        .isSameAs(TimingRecorders.noOpProductionComponentTimingRecorder());
+  }
+
+  @Test
+  public void multipleRecorders_throwingProductionComponentTimingRecorderFactories() {
+    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(
+                mockProductionComponentTimingRecorderFactoryA,
+                mockProductionComponentTimingRecorderFactoryB,
+                mockProductionComponentTimingRecorderFactoryC));
+    assertThat(factory.create(new Object()))
+        .isSameAs(TimingRecorders.noOpProductionComponentTimingRecorder());
+  }
+
+  @Test
+  public void multipleRecorders_someNullProductionComponentTimingRecorders() {
+    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorderA);
+    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class))).thenReturn(null);
+    when(mockProductionComponentTimingRecorderA.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerTimingRecorderA);
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(
+                mockProductionComponentTimingRecorderFactoryA,
+                mockProductionComponentTimingRecorderFactoryB,
+                mockProductionComponentTimingRecorderFactoryC));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordSuccess(100);
+
+    InOrder order = inOrder(mockProducerTimingRecorderA);
+    order.verify(mockProducerTimingRecorderA).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderA).recordSuccess(100);
+    verifyNoMoreInteractions(mockProducerTimingRecorderA);
+  }
+
+  @Test
+  public void multipleRecorders_someThrowingProductionComponentTimingRecorderFactories() {
+    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorderA);
+    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class)))
+        .thenThrow(new RuntimeException("monkey"));
+    when(mockProductionComponentTimingRecorderA.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerTimingRecorderA);
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(
+                mockProductionComponentTimingRecorderFactoryA,
+                mockProductionComponentTimingRecorderFactoryB,
+                mockProductionComponentTimingRecorderFactoryC));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordSuccess(100);
+
+    InOrder order = inOrder(mockProducerTimingRecorderA);
+    order.verify(mockProducerTimingRecorderA).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderA).recordSuccess(100);
+    verifyNoMoreInteractions(mockProducerTimingRecorderA);
+  }
+
+  @Test
+  public void multipleRecorders_normalProductionComponentTimingRecorderSuccess() {
+    setUpNormalMultipleRecorders();
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(
+                mockProductionComponentTimingRecorderFactoryA,
+                mockProductionComponentTimingRecorderFactoryB,
+                mockProductionComponentTimingRecorderFactoryC));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordSuccess(100);
+
+    InOrder order =
+        inOrder(
+            mockProducerTimingRecorderA, mockProducerTimingRecorderB, mockProducerTimingRecorderC);
+    order.verify(mockProducerTimingRecorderA).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderB).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderC).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderA).recordSuccess(100);
+    order.verify(mockProducerTimingRecorderB).recordSuccess(100);
+    order.verify(mockProducerTimingRecorderC).recordSuccess(100);
+    verifyNoMoreInteractions(
+        mockProducerTimingRecorderA, mockProducerTimingRecorderB, mockProducerTimingRecorderC);
+  }
+
+  @Test
+  public void multipleRecorders_someThrowingProducerTimingRecordersSuccess() {
+    setUpNormalMultipleRecorders();
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProducerTimingRecorderA)
+        .recordMethod(anyLong(), anyLong());
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProducerTimingRecorderB)
+        .recordSuccess(anyLong());
+    doThrow(new RuntimeException("monkey"))
+        .when(mockProducerTimingRecorderC)
+        .recordMethod(anyLong(), anyLong());
+    ProductionComponentTimingRecorder.Factory factory =
+        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
+            ImmutableList.of(
+                mockProductionComponentTimingRecorderFactoryA,
+                mockProductionComponentTimingRecorderFactoryB,
+                mockProductionComponentTimingRecorderFactoryC));
+    ProductionComponentTimingRecorder recorder = factory.create(new Object());
+    ProducerTimingRecorder producerTimingRecorder =
+        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
+
+    producerTimingRecorder.recordMethod(15, 42);
+    producerTimingRecorder.recordSuccess(100);
+
+    InOrder order =
+        inOrder(
+            mockProducerTimingRecorderA, mockProducerTimingRecorderB, mockProducerTimingRecorderC);
+    order.verify(mockProducerTimingRecorderA).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderB).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderC).recordMethod(15, 42);
+    order.verify(mockProducerTimingRecorderA).recordSuccess(100);
+    order.verify(mockProducerTimingRecorderB).recordSuccess(100);
+    order.verify(mockProducerTimingRecorderC).recordSuccess(100);
+    verifyNoMoreInteractions(
+        mockProducerTimingRecorderA, mockProducerTimingRecorderB, mockProducerTimingRecorderC);
+  }
+
+  private void setUpNormalSingleRecorder() {
+    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorder);
+    when(mockProductionComponentTimingRecorder.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerTimingRecorder);
+  }
+
+  private void setUpNormalMultipleRecorders() {
+    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorderA);
+    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorderB);
+    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class)))
+        .thenReturn(mockProductionComponentTimingRecorderC);
+    when(mockProductionComponentTimingRecorderA.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerTimingRecorderA);
+    when(mockProductionComponentTimingRecorderB.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerTimingRecorderB);
+    when(mockProductionComponentTimingRecorderC.producerTimingRecorderFor(any(ProducerToken.class)))
+        .thenReturn(mockProducerTimingRecorderC);
+  }
+}
diff --git a/producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java b/javatests/dagger/producers/monitoring/internal/MonitorsTest.java
similarity index 100%
rename from producers/src/test/java/dagger/producers/monitoring/internal/MonitorsTest.java
rename to javatests/dagger/producers/monitoring/internal/MonitorsTest.java
diff --git a/tools/maven_sha1_test.py b/maven_sha1_test.py
similarity index 100%
rename from tools/maven_sha1_test.py
rename to maven_sha1_test.py
diff --git a/pom.xml b/pom.xml
index d3e7557b8..840b69644 100644
--- a/pom.xml
+++ b/pom.xml
@@ -38,6 +38,8 @@
     <module>gwt</module>
     <!-- examples are handled in a default profile (see below) -->
     <module>producers</module>
+    <module>android-support</module>
+    <module>android-compiler</module>
   </modules>
 
   <properties>
@@ -92,6 +94,7 @@
         <groupId>com.google.code.findbugs</groupId>
         <artifactId>jsr305</artifactId>
         <version>3.0.1</version>
+        <optional>true</optional>
       </dependency>
       <dependency>
         <groupId>com.google.guava</groupId>
diff --git a/producers/BUILD b/producers/BUILD
deleted file mode 100644
index df23036ab..000000000
--- a/producers/BUILD
+++ /dev/null
@@ -1,63 +0,0 @@
-# Copyright (C) 2017 The Dagger Authors.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-# Description:
-#   An asynchronous dependency injection system that extends JSR-330.
-
-package(default_visibility = ["//:src"])
-
-load(
-    "//:build_defs.bzl",
-    "DOCLINT_HTML_AND_SYNTAX",
-    "DOCLINT_REFERENCES",
-    "JAVA_6_SOURCE_LEVEL",
-    "JAVA_7_SOURCE_LEVEL",
-    "PRE_JAVA_8_INFERENCE_OPTS",
-)
-
-java_library(
-    name = "producers",
-    srcs = glob(["src/main/java/**/*.java"]),
-    javacopts = PRE_JAVA_8_INFERENCE_OPTS + JAVA_6_SOURCE_LEVEL + DOCLINT_HTML_AND_SYNTAX + DOCLINT_REFERENCES,
-    plugins = [
-        # TODO(cgruber): Enable Beta checker.
-    ],
-    exports = [
-        # TODO(dpb): Don't export any of Guava.
-        "//third_party:guava",
-        "//third_party:jsr330_inject",
-    ],
-    deps = [
-        "//core",
-        "//third_party:guava",
-        "//third_party:jsr305_annotations",
-        "//third_party:jsr330_inject",
-    ],
-)
-
-load("//:test_defs.bzl", "GenJavaTests")
-
-GenJavaTests(
-    name = "produces_tests",
-    srcs = glob(["src/test/java/**/*.java"]),
-    javacopts = PRE_JAVA_8_INFERENCE_OPTS + JAVA_7_SOURCE_LEVEL,
-    deps = [
-        ":producers",
-        "//third_party:guava",
-        "//third_party:guava_testlib",
-        "//third_party:junit",
-        "//third_party:mockito",
-        "//third_party:truth",
-    ],
-)
diff --git a/producers/src/main/java/dagger/producers/ProductionComponent.java b/producers/src/main/java/dagger/producers/ProductionComponent.java
index 6e7376b4b..074d01cf7 100644
--- a/producers/src/main/java/dagger/producers/ProductionComponent.java
+++ b/producers/src/main/java/dagger/producers/ProductionComponent.java
@@ -67,10 +67,10 @@
  *
  * <h2>Executor</h2>
  *
- * <p>The component must include a binding for <code>{@literal @}Production Executor</code>;
- * this binding will be called exactly once, and the provided executor will be used by the framework
- * to schedule all producer methods (for this component, and any {@link ProductionSubcomponent} it
- * may have.
+ * <p>The component must include a binding for <code>{@literal @}{@link Production}
+ * {@link java.util.concurrent.Executor}</code>; this binding will be called exactly once, and the
+ * provided executor will be used by the framework to schedule all producer methods (for this
+ * component, and any {@link ProductionSubcomponent} it may have.
  *
  * @author Jesse Beder
  */
diff --git a/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java b/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
index f86408393..7fe2ce488 100644
--- a/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
@@ -26,7 +26,6 @@
 import com.google.common.util.concurrent.AsyncFunction;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
-import dagger.internal.Beta;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
 import java.util.List;
@@ -39,7 +38,6 @@
  *
  * @author Jesse Beder
  */
-@Beta
 public final class MapOfProducedProducer<K, V> extends AbstractProducer<Map<K, Produced<V>>> {
   private final Producer<Map<K, Producer<V>>> mapProducerProducer;
 
@@ -84,7 +82,8 @@ private MapOfProducedProducer(Producer<Map<K, Producer<V>>> mapProducerProducer)
                 },
                 directExecutor());
           }
-        });
+        },
+        directExecutor());
   }
 
   private static final Function<
diff --git a/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java b/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java
index 216966e75..5eef863c3 100644
--- a/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java
@@ -23,7 +23,6 @@
 import com.google.common.collect.ImmutableMap;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
-import dagger.internal.Beta;
 import dagger.producers.Producer;
 import java.util.Map;
 import javax.inject.Provider;
@@ -34,7 +33,6 @@
  *
  * @author Jesse Beder
  */
-@Beta
 public final class MapOfProducerProducer<K, V> extends AbstractProducer<Map<K, Producer<V>>> {
   private static final MapOfProducerProducer<Object, Object> EMPTY =
       new MapOfProducerProducer<Object, Object>(ImmutableMap.<Object, Producer<Object>>of());
diff --git a/producers/src/main/java/dagger/producers/internal/MapProducer.java b/producers/src/main/java/dagger/producers/internal/MapProducer.java
index d02c9ca90..1a13b9d53 100644
--- a/producers/src/main/java/dagger/producers/internal/MapProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/MapProducer.java
@@ -26,7 +26,6 @@
 import com.google.common.util.concurrent.AsyncFunction;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
-import dagger.internal.Beta;
 import dagger.producers.Producer;
 import java.util.List;
 import java.util.Map;
@@ -37,7 +36,6 @@
  *
  * @author Jesse Beder
  */
-@Beta
 public final class MapProducer<K, V> extends AbstractProducer<Map<K, V>> {
   private final Producer<Map<K, Producer<V>>> mapProducerProducer;
 
@@ -79,7 +77,8 @@ private MapProducer(Producer<Map<K, Producer<V>>> mapProducerProducer) {
                 },
                 directExecutor());
           }
-        });
+        },
+        directExecutor());
   }
 
   private static final Function<
diff --git a/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
index a7e060d95..0156887d5 100644
--- a/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
@@ -17,6 +17,7 @@
 package dagger.producers.internal;
 
 import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.util.concurrent.MoreExecutors.directExecutor;
 import static dagger.internal.DaggerCollections.hasDuplicates;
 import static dagger.internal.DaggerCollections.presizedList;
 
@@ -169,6 +170,7 @@ private SetOfProducedProducer(
             }
             return builder.build();
           }
-        });
+        },
+        directExecutor());
   }
 }
diff --git a/producers/src/main/java/dagger/producers/package-info.java b/producers/src/main/java/dagger/producers/package-info.java
index 01d261a87..4e4f61747 100644
--- a/producers/src/main/java/dagger/producers/package-info.java
+++ b/producers/src/main/java/dagger/producers/package-info.java
@@ -17,13 +17,10 @@
 /**
  * This package contains the public API for Dagger 2's producer functionality.
  *
- * <p>Dagger Producers is an extension to Dagger that implements asynchronous
- * dependency injection in Java.
- *
- * <p>Extended documentation on Dagger Producers can be found at
- * <a href="http://google.github.io/dagger/producers">
- * google.github.io/dagger/producers</a>.
+ * <p>Dagger Producers is an extension to Dagger that implements asynchronous dependency injection
+ * in Java.
  *
+ * <p>Extended documentation on Dagger Producers can be found at <a
+ * href="https://google.github.io/dagger/producers">google.github.io/dagger/producers</a>.
  */
-
 package dagger.producers;
diff --git a/producers/src/test/java/dagger/producers/monitoring/TimingRecordersTest.java b/producers/src/test/java/dagger/producers/monitoring/TimingRecordersTest.java
deleted file mode 100644
index c0c7eb6c5..000000000
--- a/producers/src/test/java/dagger/producers/monitoring/TimingRecordersTest.java
+++ /dev/null
@@ -1,359 +0,0 @@
-/*
- * Copyright (C) 2015 The Dagger Authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package dagger.producers.monitoring;
-
-import static com.google.common.truth.Truth.assertThat;
-import static org.mockito.Mockito.any;
-import static org.mockito.Mockito.doThrow;
-import static org.mockito.Mockito.inOrder;
-import static org.mockito.Mockito.verifyNoMoreInteractions;
-import static org.mockito.Mockito.when;
-
-import com.google.common.collect.ImmutableList;
-import org.junit.Before;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.junit.runners.JUnit4;
-import org.mockito.InOrder;
-import org.mockito.Mock;
-import org.mockito.MockitoAnnotations;
-
-@RunWith(JUnit4.class)
-public final class TimingRecordersTest {
-  @Mock
-  private ProductionComponentTimingRecorder.Factory mockProductionComponentTimingRecorderFactory;
-
-  @Mock private ProductionComponentTimingRecorder mockProductionComponentTimingRecorder;
-  @Mock private ProducerTimingRecorder mockProducerTimingRecorder;
-
-  @Mock
-  private ProductionComponentTimingRecorder.Factory mockProductionComponentTimingRecorderFactoryA;
-
-  @Mock
-  private ProductionComponentTimingRecorder.Factory mockProductionComponentTimingRecorderFactoryB;
-
-  @Mock
-  private ProductionComponentTimingRecorder.Factory mockProductionComponentTimingRecorderFactoryC;
-
-  @Mock private ProductionComponentTimingRecorder mockProductionComponentTimingRecorderA;
-  @Mock private ProductionComponentTimingRecorder mockProductionComponentTimingRecorderB;
-  @Mock private ProductionComponentTimingRecorder mockProductionComponentTimingRecorderC;
-  @Mock private ProducerTimingRecorder mockProducerTimingRecorderA;
-  @Mock private ProducerTimingRecorder mockProducerTimingRecorderB;
-  @Mock private ProducerTimingRecorder mockProducerTimingRecorderC;
-
-  @Before
-  public void initMocks() {
-    MockitoAnnotations.initMocks(this);
-  }
-
-  @Test
-  public void zeroRecordersReturnsNoOp() {
-    ProductionComponentTimingRecorder.Factory factory =
-        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
-            ImmutableList.<ProductionComponentTimingRecorder.Factory>of());
-    assertThat(factory).isSameAs(TimingRecorders.noOpProductionComponentTimingRecorderFactory());
-  }
-
-  @Test
-  public void singleRecorder_nullProductionComponentTimingRecorder() {
-    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class))).thenReturn(null);
-    ProductionComponentTimingRecorder.Factory factory =
-        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
-            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
-    assertThat(factory.create(new Object()))
-        .isSameAs(TimingRecorders.noOpProductionComponentTimingRecorder());
-  }
-
-  @Test
-  public void singleRecorder_throwingProductionComponentTimingRecorderFactory() {
-    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class)))
-        .thenThrow(new RuntimeException("monkey"));
-    ProductionComponentTimingRecorder.Factory factory =
-        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
-            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
-    assertThat(factory.create(new Object()))
-        .isSameAs(TimingRecorders.noOpProductionComponentTimingRecorder());
-  }
-
-  @Test
-  public void singleRecorder_nullProducerTimingRecorder() {
-    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class)))
-        .thenReturn(mockProductionComponentTimingRecorder);
-    when(mockProductionComponentTimingRecorder.producerTimingRecorderFor(any(ProducerToken.class)))
-        .thenReturn(null);
-    ProductionComponentTimingRecorder.Factory factory =
-        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
-            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
-    ProductionComponentTimingRecorder recorder = factory.create(new Object());
-    assertThat(recorder.producerTimingRecorderFor(ProducerToken.create(Object.class)))
-        .isSameAs(ProducerTimingRecorder.noOp());
-  }
-
-  @Test
-  public void singleRecorder_throwingProductionComponentTimingRecorder() {
-    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class)))
-        .thenReturn(mockProductionComponentTimingRecorder);
-    when(mockProductionComponentTimingRecorder.producerTimingRecorderFor(any(ProducerToken.class)))
-        .thenThrow(new RuntimeException("monkey"));
-    ProductionComponentTimingRecorder.Factory factory =
-        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
-            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
-    ProductionComponentTimingRecorder recorder = factory.create(new Object());
-    assertThat(recorder.producerTimingRecorderFor(ProducerToken.create(Object.class)))
-        .isSameAs(ProducerTimingRecorder.noOp());
-  }
-
-  @Test
-  public void singleRecorder_normalProducerTimingRecorderSuccess() {
-    setUpNormalSingleRecorder();
-    ProductionComponentTimingRecorder.Factory factory =
-        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
-            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
-    ProductionComponentTimingRecorder recorder = factory.create(new Object());
-    ProducerTimingRecorder producerTimingRecorder =
-        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
-    producerTimingRecorder.recordMethod(15, 42);
-    producerTimingRecorder.recordSuccess(100);
-
-    InOrder order = inOrder(mockProducerTimingRecorder);
-    order.verify(mockProducerTimingRecorder).recordMethod(15, 42);
-    order.verify(mockProducerTimingRecorder).recordSuccess(100);
-    verifyNoMoreInteractions(mockProducerTimingRecorder);
-  }
-
-  @Test
-  public void singleRecorder_normalProducerTimingRecorderFailure() {
-    setUpNormalSingleRecorder();
-    ProductionComponentTimingRecorder.Factory factory =
-        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
-            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
-    ProductionComponentTimingRecorder recorder = factory.create(new Object());
-    ProducerTimingRecorder producerTimingRecorder =
-        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
-    Throwable t = new RuntimeException("monkey");
-    producerTimingRecorder.recordMethod(15, 42);
-    producerTimingRecorder.recordFailure(t, 100);
-
-    InOrder order = inOrder(mockProducerTimingRecorder);
-    order.verify(mockProducerTimingRecorder).recordMethod(15, 42);
-    order.verify(mockProducerTimingRecorder).recordFailure(t, 100);
-    verifyNoMoreInteractions(mockProducerTimingRecorder);
-  }
-
-  @Test
-  public void singleRecorder_throwingProducerTimingRecorderSuccess() {
-    setUpNormalSingleRecorder();
-    doThrow(new RuntimeException("monkey"))
-        .when(mockProducerTimingRecorder)
-        .recordMethod(any(Long.class), any(Long.class));
-    doThrow(new RuntimeException("monkey"))
-        .when(mockProducerTimingRecorder)
-        .recordSuccess(any(Long.class));
-    ProductionComponentTimingRecorder.Factory factory =
-        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
-            ImmutableList.of(mockProductionComponentTimingRecorderFactory));
-    ProductionComponentTimingRecorder recorder = factory.create(new Object());
-    ProducerTimingRecorder producerTimingRecorder =
-        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
-    producerTimingRecorder.recordMethod(15, 42);
-    producerTimingRecorder.recordSuccess(100);
-
-    InOrder order = inOrder(mockProducerTimingRecorder);
-    order.verify(mockProducerTimingRecorder).recordMethod(15, 42);
-    order.verify(mockProducerTimingRecorder).recordSuccess(100);
-    verifyNoMoreInteractions(mockProducerTimingRecorder);
-  }
-
-  @Test
-  public void multipleRecorders_nullProductionComponentTimingRecorders() {
-    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class))).thenReturn(null);
-    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class))).thenReturn(null);
-    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class))).thenReturn(null);
-    ProductionComponentTimingRecorder.Factory factory =
-        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
-            ImmutableList.of(
-                mockProductionComponentTimingRecorderFactoryA,
-                mockProductionComponentTimingRecorderFactoryB,
-                mockProductionComponentTimingRecorderFactoryC));
-    assertThat(factory.create(new Object()))
-        .isSameAs(TimingRecorders.noOpProductionComponentTimingRecorder());
-  }
-
-  @Test
-  public void multipleRecorders_throwingProductionComponentTimingRecorderFactories() {
-    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class)))
-        .thenThrow(new RuntimeException("monkey"));
-    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class)))
-        .thenThrow(new RuntimeException("monkey"));
-    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class)))
-        .thenThrow(new RuntimeException("monkey"));
-    ProductionComponentTimingRecorder.Factory factory =
-        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
-            ImmutableList.of(
-                mockProductionComponentTimingRecorderFactoryA,
-                mockProductionComponentTimingRecorderFactoryB,
-                mockProductionComponentTimingRecorderFactoryC));
-    assertThat(factory.create(new Object()))
-        .isSameAs(TimingRecorders.noOpProductionComponentTimingRecorder());
-  }
-
-  @Test
-  public void multipleRecorders_someNullProductionComponentTimingRecorders() {
-    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class)))
-        .thenReturn(mockProductionComponentTimingRecorderA);
-    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class))).thenReturn(null);
-    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class))).thenReturn(null);
-    when(mockProductionComponentTimingRecorderA.producerTimingRecorderFor(any(ProducerToken.class)))
-        .thenReturn(mockProducerTimingRecorderA);
-    ProductionComponentTimingRecorder.Factory factory =
-        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
-            ImmutableList.of(
-                mockProductionComponentTimingRecorderFactoryA,
-                mockProductionComponentTimingRecorderFactoryB,
-                mockProductionComponentTimingRecorderFactoryC));
-    ProductionComponentTimingRecorder recorder = factory.create(new Object());
-    ProducerTimingRecorder producerTimingRecorder =
-        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
-
-    producerTimingRecorder.recordMethod(15, 42);
-    producerTimingRecorder.recordSuccess(100);
-
-    InOrder order = inOrder(mockProducerTimingRecorderA);
-    order.verify(mockProducerTimingRecorderA).recordMethod(15, 42);
-    order.verify(mockProducerTimingRecorderA).recordSuccess(100);
-    verifyNoMoreInteractions(mockProducerTimingRecorderA);
-  }
-
-  @Test
-  public void multipleRecorders_someThrowingProductionComponentTimingRecorderFactories() {
-    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class)))
-        .thenReturn(mockProductionComponentTimingRecorderA);
-    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class)))
-        .thenThrow(new RuntimeException("monkey"));
-    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class)))
-        .thenThrow(new RuntimeException("monkey"));
-    when(mockProductionComponentTimingRecorderA.producerTimingRecorderFor(any(ProducerToken.class)))
-        .thenReturn(mockProducerTimingRecorderA);
-    ProductionComponentTimingRecorder.Factory factory =
-        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
-            ImmutableList.of(
-                mockProductionComponentTimingRecorderFactoryA,
-                mockProductionComponentTimingRecorderFactoryB,
-                mockProductionComponentTimingRecorderFactoryC));
-    ProductionComponentTimingRecorder recorder = factory.create(new Object());
-    ProducerTimingRecorder producerTimingRecorder =
-        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
-
-    producerTimingRecorder.recordMethod(15, 42);
-    producerTimingRecorder.recordSuccess(100);
-
-    InOrder order = inOrder(mockProducerTimingRecorderA);
-    order.verify(mockProducerTimingRecorderA).recordMethod(15, 42);
-    order.verify(mockProducerTimingRecorderA).recordSuccess(100);
-    verifyNoMoreInteractions(mockProducerTimingRecorderA);
-  }
-
-  @Test
-  public void multipleRecorders_normalProductionComponentTimingRecorderSuccess() {
-    setUpNormalMultipleRecorders();
-    ProductionComponentTimingRecorder.Factory factory =
-        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
-            ImmutableList.of(
-                mockProductionComponentTimingRecorderFactoryA,
-                mockProductionComponentTimingRecorderFactoryB,
-                mockProductionComponentTimingRecorderFactoryC));
-    ProductionComponentTimingRecorder recorder = factory.create(new Object());
-    ProducerTimingRecorder producerTimingRecorder =
-        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
-
-    producerTimingRecorder.recordMethod(15, 42);
-    producerTimingRecorder.recordSuccess(100);
-
-    InOrder order =
-        inOrder(
-            mockProducerTimingRecorderA, mockProducerTimingRecorderB, mockProducerTimingRecorderC);
-    order.verify(mockProducerTimingRecorderA).recordMethod(15, 42);
-    order.verify(mockProducerTimingRecorderB).recordMethod(15, 42);
-    order.verify(mockProducerTimingRecorderC).recordMethod(15, 42);
-    order.verify(mockProducerTimingRecorderA).recordSuccess(100);
-    order.verify(mockProducerTimingRecorderB).recordSuccess(100);
-    order.verify(mockProducerTimingRecorderC).recordSuccess(100);
-    verifyNoMoreInteractions(
-        mockProducerTimingRecorderA, mockProducerTimingRecorderB, mockProducerTimingRecorderC);
-  }
-
-  @Test
-  public void multipleRecorders_someThrowingProducerTimingRecordersSuccess() {
-    setUpNormalMultipleRecorders();
-    doThrow(new RuntimeException("monkey"))
-        .when(mockProducerTimingRecorderA)
-        .recordMethod(any(Long.class), any(Long.class));
-    doThrow(new RuntimeException("monkey"))
-        .when(mockProducerTimingRecorderB)
-        .recordSuccess(any(Long.class));
-    doThrow(new RuntimeException("monkey"))
-        .when(mockProducerTimingRecorderC)
-        .recordMethod(any(Long.class), any(Long.class));
-    ProductionComponentTimingRecorder.Factory factory =
-        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(
-            ImmutableList.of(
-                mockProductionComponentTimingRecorderFactoryA,
-                mockProductionComponentTimingRecorderFactoryB,
-                mockProductionComponentTimingRecorderFactoryC));
-    ProductionComponentTimingRecorder recorder = factory.create(new Object());
-    ProducerTimingRecorder producerTimingRecorder =
-        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));
-
-    producerTimingRecorder.recordMethod(15, 42);
-    producerTimingRecorder.recordSuccess(100);
-
-    InOrder order =
-        inOrder(
-            mockProducerTimingRecorderA, mockProducerTimingRecorderB, mockProducerTimingRecorderC);
-    order.verify(mockProducerTimingRecorderA).recordMethod(15, 42);
-    order.verify(mockProducerTimingRecorderB).recordMethod(15, 42);
-    order.verify(mockProducerTimingRecorderC).recordMethod(15, 42);
-    order.verify(mockProducerTimingRecorderA).recordSuccess(100);
-    order.verify(mockProducerTimingRecorderB).recordSuccess(100);
-    order.verify(mockProducerTimingRecorderC).recordSuccess(100);
-    verifyNoMoreInteractions(
-        mockProducerTimingRecorderA, mockProducerTimingRecorderB, mockProducerTimingRecorderC);
-  }
-
-  private void setUpNormalSingleRecorder() {
-    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class)))
-        .thenReturn(mockProductionComponentTimingRecorder);
-    when(mockProductionComponentTimingRecorder.producerTimingRecorderFor(any(ProducerToken.class)))
-        .thenReturn(mockProducerTimingRecorder);
-  }
-
-  private void setUpNormalMultipleRecorders() {
-    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class)))
-        .thenReturn(mockProductionComponentTimingRecorderA);
-    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class)))
-        .thenReturn(mockProductionComponentTimingRecorderB);
-    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class)))
-        .thenReturn(mockProductionComponentTimingRecorderC);
-    when(mockProductionComponentTimingRecorderA.producerTimingRecorderFor(any(ProducerToken.class)))
-        .thenReturn(mockProducerTimingRecorderA);
-    when(mockProductionComponentTimingRecorderB.producerTimingRecorderFor(any(ProducerToken.class)))
-        .thenReturn(mockProducerTimingRecorderB);
-    when(mockProductionComponentTimingRecorderC.producerTimingRecorderFor(any(ProducerToken.class)))
-        .thenReturn(mockProducerTimingRecorderC);
-  }
-}
diff --git a/settings.gradle b/settings.gradle
new file mode 100644
index 000000000..cf0d917a3
--- /dev/null
+++ b/settings.gradle
@@ -0,0 +1 @@
+include ':dagger-android-support'
diff --git a/shade_rules.txt b/shade_rules.txt
new file mode 100644
index 000000000..968e53209
--- /dev/null
+++ b/shade_rules.txt
@@ -0,0 +1 @@
+rule com.google.auto.common.** dagger.shaded.auto.common.@1
diff --git a/test_defs.bzl b/test_defs.bzl
index 20ae62146..4c86d3543 100644
--- a/test_defs.bzl
+++ b/test_defs.bzl
@@ -12,15 +12,19 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-def GenJavaTests(name, srcs, deps, plugins = None, javacopts = None):
-  _GenTests(native.java_library, native.java_test, name, srcs, deps, plugins, javacopts)
+def GenJavaTests(name, srcs, deps, test_only_deps=None, plugins=None, javacopts=None,
+                 lib_javacopts=None, test_javacopts=None):
+  _GenTests(native.java_library, native.java_test, name, srcs, deps, test_only_deps=test_only_deps,
+            plugins=plugins, javacopts=javacopts, lib_javacopts=lib_javacopts,
+            test_javacopts=test_javacopts)
 
-def GenRobolectricTests(name, srcs, deps, plugins = None, javacopts = None):
+def GenRobolectricTests(name, srcs, deps, test_only_deps=None, plugins=None, javacopts=None,
+                        lib_javacopts=None, test_javacopts=None):
   # TODO(ronshapiro): enable these when Bazel supports robolectric tests
   pass
 
-def _GenTests(
-    library_rule_type, test_rule_type, name, srcs, deps, plugins = None, javacopts = None):
+def _GenTests(library_rule_type, test_rule_type, name, srcs, deps, test_only_deps=None,
+              plugins=None, javacopts=None, lib_javacopts=None, test_javacopts=None):
   test_files = []
   supporting_files = []
   for src in srcs:
@@ -29,7 +33,10 @@ def _GenTests(
     else:
       supporting_files.append(src)
 
-  test_deps = [] + deps
+  if not test_only_deps:
+    test_only_deps = []
+
+  test_deps = test_only_deps + deps
   if len(supporting_files) > 0:
     supporting_files_name = name + "_lib"
     test_deps.append(":" + supporting_files_name)
@@ -38,18 +45,21 @@ def _GenTests(
         deps = deps,
         srcs = supporting_files,
         plugins = plugins,
-        javacopts = javacopts,
+        javacopts = (javacopts or []) + (lib_javacopts or []),
         testonly = 1,
     )
 
   for test_file in test_files:
     test_name = test_file.replace(".java", "")
-    test_class = (PACKAGE_NAME + "/" + test_name).rpartition("src/test/java/")[2].replace("/",".")
+    prefix_path = "src/test/java/"
+    if PACKAGE_NAME.find("javatests/") != -1:
+      prefix_path = "javatests/"
+    test_class = (PACKAGE_NAME + "/" + test_name).rpartition(prefix_path)[2].replace("/",".")
     test_rule_type(
         name = test_name,
         deps = test_deps,
         srcs = [test_file],
         plugins = plugins,
-        javacopts = javacopts,
+        javacopts = (javacopts or []) + (test_javacopts or []),
         test_class = test_class,
     )
diff --git a/third_party/BUILD b/third_party/BUILD
index 7aa46968c..d2e6d52c4 100644
--- a/third_party/BUILD
+++ b/third_party/BUILD
@@ -16,7 +16,7 @@ package(default_visibility = ["//visibility:public"])
 
 java_library(
     name = "jsr_250",
-    exports = ["@javax_annotations_jsr250_api//jar"],
+    exports = ["@javax_annotation_jsr250_api//jar"],
 )
 
 java_library(
@@ -36,20 +36,34 @@ java_library(
 
 java_library(
     name = "error_prone_annotations",
-    tags = ["compile_time_dep"],
+    tags = ["maven:compile_only"],
     exports = ["@com_google_errorprone_error_prone_annotations//jar"],
 )
 
 java_library(
     name = "junit",
-    exports = ["@junit_junit//jar"],
+    testonly = 1,
+    exports = [
+        "@junit_junit//jar",
+        "@org_hamcrest_hamcrest_core//jar",
+    ],
 )
 
 java_library(
     name = "truth",
+    testonly = 1,
     exports = ["@com_google_truth_truth//jar"],
 )
 
+java_library(
+    name = "truth8",
+    testonly = 1,
+    exports = [
+        ":truth",
+        "@com_google_truth_extensions_truth_java8_extension//jar",
+    ],
+)
+
 java_library(
     name = "guava",
     exports = ["@com_google_guava_guava//jar"],
@@ -57,11 +71,13 @@ java_library(
 
 java_library(
     name = "guava_testlib",
+    testonly = 1,
     exports = ["@com_google_guava_guava_testlib//jar"],
 )
 
 java_library(
     name = "auto_common",
+    tags = ["maven:shaded"],
     exports = ["@com_google_auto_auto_common//jar"],
 )
 
@@ -95,7 +111,7 @@ java_library(
         ":auto_value_processor",
         ":auto_annotation_processor",
     ],
-    tags = ["compile_time_dep"],
+    tags = ["maven:compile_only"],
     exports = [
         ":jsr_250",
         "@com_google_auto_value_auto_value//jar",
@@ -136,7 +152,7 @@ java_plugin(
 java_library(
     name = "auto_service",
     exported_plugins = [":auto_service_processor"],
-    tags = ["compile_time_dep"],
+    tags = ["maven:compile_only"],
     exports = ["@com_google_auto_service_auto_service//jar"],
 )
 
@@ -166,6 +182,41 @@ java_library(
     ],
 )
 
+java_library(
+    name = "grpc",
+    exports = ["@io_grpc_grpc_all//jar"],
+)
+
+java_library(
+    name = "grpc_core",
+    exports = ["@io_grpc_grpc_core//jar"],
+)
+
+java_library(
+    name = "grpc_netty",
+    exports = ["@io_grpc_grpc_netty//jar"],
+)
+
+java_library(
+    name = "grpc_context",
+    exports = ["@io_grpc_grpc_context//jar"],
+)
+
+java_library(
+    name = "grpc_protobuf",
+    exports = ["@io_grpc_grpc_protobuf//jar"],
+)
+
+java_library(
+    name = "grpc_stub",
+    exports = ["@io_grpc_grpc_stub//jar"],
+)
+
+java_library(
+    name = "protobuf",
+    exports = ["@com_google_protobuf_protobuf_java//jar"],
+)
+
 java_library(
     name = "compile_testing",
     testonly = 1,
diff --git a/tools/BUILD b/tools/BUILD
new file mode 100644
index 000000000..c3bf2c78d
--- /dev/null
+++ b/tools/BUILD
@@ -0,0 +1,64 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   Tools for Dagger
+
+package(default_visibility = ["//:src"])
+
+sh_binary(
+    name = "jarjar_library_impl",
+    srcs = ["jarjar_library_impl.sh"],
+)
+
+sh_test(
+    name = "jarjar_library_impl_test",
+    srcs = ["jarjar_library_impl_test.sh"],
+    args = ["$(JAVABASE)"],
+    data = [
+        ":jarjar_deploy.jar",
+        ":jarjar_library_impl",
+        "//tools/testdata:bar",
+        "//tools/testdata:bar_with_dupe_file",
+        "//tools/testdata:foo",
+        "//tools/testdata:foo_with_dupe_file",
+        "@local_jdk//:bin/jar",
+        "@local_jdk//:bin/java",
+        "@local_jdk//:jre",
+    ],
+)
+
+java_binary(
+    name = "jarjar",
+    main_class = "org.pantsbuild.jarjar.Main",
+    runtime_deps = [
+        "@javax_annotation_jsr250_api//jar",
+        "@javax_enterprise_cdi_api//jar",
+        "@javax_inject_javax_inject//jar",
+        "@org_apache_ant_ant//jar",
+        "@org_apache_ant_ant_launcher//jar",
+        "@org_apache_maven_maven_artifact//jar",
+        "@org_apache_maven_maven_model//jar",
+        "@org_apache_maven_maven_plugin_api//jar",
+        "@org_codehaus_plexus_plexus_classworlds//jar",
+        "@org_codehaus_plexus_plexus_component_annotations//jar",
+        "@org_codehaus_plexus_plexus_utils//jar",
+        "@org_eclipse_sisu_org_eclipse_sisu_inject//jar",
+        "@org_eclipse_sisu_org_eclipse_sisu_plexus//jar",
+        "@org_ow2_asm_asm//jar",
+        "@org_ow2_asm_asm_commons//jar",
+        "@org_ow2_asm_asm_tree//jar",
+        "@org_pantsbuild_jarjar//jar",
+    ],
+)
diff --git a/tools/bazel.rc b/tools/bazel.rc
new file mode 100644
index 000000000..bec9778ac
--- /dev/null
+++ b/tools/bazel.rc
@@ -0,0 +1,2 @@
+# Include debug info in the compiled jars
+build --javacopt=-g --strategy=Javac=standalone
\ No newline at end of file
diff --git a/tools/jarjar.bzl b/tools/jarjar.bzl
new file mode 100644
index 000000000..17e1aed31
--- /dev/null
+++ b/tools/jarjar.bzl
@@ -0,0 +1,140 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+def jarjar_deps():
+  """
+  Deps that are necessary to build jarjar_binary() but aren't used in the regular build process for
+  Dagger, so they are organized separately from the workspace file.
+  """
+  native.maven_jar(
+      name = "org_codehaus_plexus_plexus_utils",
+      artifact = "org.codehaus.plexus:plexus-utils:3.0.20",
+      sha1 = "e121ed37af8ee3928952f6d8a303de24e019aab0",
+  )
+
+  native.maven_jar(
+      name = "org_eclipse_sisu_org_eclipse_sisu_plexus",
+      artifact = "org.eclipse.sisu:org.eclipse.sisu.plexus:0.3.0",
+      sha1 = "3f53953a998d03b9b0f7d5098f63119e434af0ef",
+  )
+
+  native.maven_jar(
+      name = "org_apache_ant_ant_launcher",
+      artifact = "org.apache.ant:ant-launcher:1.9.6",
+      sha1 = "d75dd4c39ba06401f20e7afffb861d268baec6bc",
+  )
+
+  native.maven_jar(
+      name = "org_apache_maven_maven_plugin_api",
+      artifact = "org.apache.maven:maven-plugin-api:3.3.3",
+      sha1 = "3b78a7e40707be313c4d5449ba514c9747e1c731",
+  )
+
+  native.maven_jar(
+      name = "org_eclipse_sisu_org_eclipse_sisu_inject",
+      artifact = "org.eclipse.sisu:org.eclipse.sisu.inject:0.3.0",
+      sha1 = "6c25adce9ca9af097728ed57834e8807e3b6e2b5",
+  )
+
+  native.maven_jar(
+      name = "org_ow2_asm_asm",
+      artifact = "org.ow2.asm:asm:5.0.4",
+      sha1 = "0da08b8cce7bbf903602a25a3a163ae252435795",
+  )
+
+  native.maven_jar(
+      name = "org_ow2_asm_asm_tree",
+      artifact = "org.ow2.asm:asm-tree:5.0.4",
+      sha1 = "396ce0c07ba2b481f25a70195c7c94922f0d1b0b",
+  )
+
+  native.maven_jar(
+      name = "javax_enterprise_cdi_api",
+      artifact = "javax.enterprise:cdi-api:1.0",
+      sha1 = "44c453f60909dfc223552ace63e05c694215156b",
+  )
+
+  native.maven_jar(
+      name = "org_ow2_asm_asm_commons",
+      artifact = "org.ow2.asm:asm-commons:5.0.4",
+      sha1 = "5a556786086c23cd689a0328f8519db93821c04c",
+  )
+
+  native.maven_jar(
+      name = "org_apache_maven_maven_model",
+      artifact = "org.apache.maven:maven-model:3.3.3",
+      sha1 = "73ba535c2e3a1381aeab131598010b3a723d4b47",
+  )
+
+  native.maven_jar(
+      name = "org_apache_maven_maven_artifact",
+      artifact = "org.apache.maven:maven-artifact:3.3.3",
+      sha1 = "d9f439dfef726e54eebb390ff38dd27356901528",
+  )
+
+  native.maven_jar(
+      name = "org_pantsbuild_jarjar",
+      artifact = "org.pantsbuild:jarjar:1.6.3",
+      sha1 = "cf54d4b142f5409c394095181c8d308a81869622",
+  )
+
+  native.maven_jar(
+      name = "org_codehaus_plexus_plexus_classworlds",
+      artifact = "org.codehaus.plexus:plexus-classworlds:2.5.2",
+      sha1 = "4abb111bfdace5b8167db4c0ef74644f3f88f142",
+  )
+
+  native.maven_jar(
+      name = "org_apache_ant_ant",
+      artifact = "org.apache.ant:ant:1.9.6",
+      sha1 = "80e2063b01bab3c79c2d84e4ed5e73868394c85a",
+  )
+
+  native.maven_jar(
+      name = "org_codehaus_plexus_plexus_component_annotations",
+      artifact = "org.codehaus.plexus:plexus-component-annotations:1.5.5",
+      sha1 = "c72f2660d0cbed24246ddb55d7fdc4f7374d2078",
+  )
+
+def jarjar_library(name, deps, rules_file):
+  """
+  Combines `deps` into one jar file named <name>.jar and jarjar with the rules specified in
+  `rules_file`.
+
+  See: https://github.com/pantsbuild/jarjar
+  """
+  native.genrule(
+      name = name,
+      srcs = deps + [
+          rules_file,
+          "//tools:jarjar_deploy.jar",
+      ],
+      tools = [
+          "//tools:jarjar_library_impl",
+          "@local_jdk//:bin/jar",
+          "@local_jdk//:bin/java",
+          "@local_jdk//:jre",
+      ],
+      outs = [name + ".jar"],
+      cmd = """
+      export JAVA_HOME=$(JAVABASE)
+      $(location //tools:jarjar_library_impl) $@ "{deps}" {rules} \
+        $(location //tools:jarjar_deploy.jar) \
+        $$(readlink $(location @local_jdk//:bin/jar)) \
+        $$(readlink $(location @local_jdk//:bin/java)) \
+        $(@D)
+      """.format(
+          deps=" ".join(["$(location %s)" % dep for dep in deps]),
+          rules="$(location %s)" % rules_file),
+  )
diff --git a/tools/jarjar_library_impl.sh b/tools/jarjar_library_impl.sh
new file mode 100755
index 000000000..357628d14
--- /dev/null
+++ b/tools/jarjar_library_impl.sh
@@ -0,0 +1,56 @@
+#!/usr/bin/env bash
+
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+if [[ ! $JAVA_HOME =~ ^/ ]]; then
+  JAVA_HOME=$(readlink -f $JAVA_HOME)
+fi
+
+OUT=$1
+DEPS=$2
+RULES_FILE=$3
+JARJAR=$4
+JAR_BINARY=$5
+JAVA_BINARY=$6
+TMPDIR=$7/combined
+
+mkdir -p $TMPDIR
+for dep in $DEPS; do
+  unzip -B $dep -d $TMPDIR
+done
+pushd $TMPDIR
+
+# Concatenate similar files in META-INF/services
+for file in META-INF/services/*; do
+  original=$(echo $file | sed s/"~[0-9]*$"//)
+  if [[ "$file" != "$original" ]]; then
+    cat $file >> $original
+    rm $file
+  fi
+done
+
+rm META-INF/MANIFEST.MF*
+rm -rf META-INF/maven/
+duplicate_files=$(find * -type f -regex ".*~[0-9]*$")
+if [[ -n "$duplicate_files" ]]; then
+  echo "Error: duplicate files in merged jar: $duplicate_files"
+  exit 1
+fi
+$JAR_BINARY cvf combined.jar *
+
+popd
+
+$JAVA_BINARY -jar $JARJAR process $RULES_FILE $TMPDIR/combined.jar $OUT
+rm -rf $TMPDIR
diff --git a/tools/jarjar_library_impl_test.sh b/tools/jarjar_library_impl_test.sh
new file mode 100755
index 000000000..edc65d44c
--- /dev/null
+++ b/tools/jarjar_library_impl_test.sh
@@ -0,0 +1,60 @@
+#!/usr/bin/env bash
+
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+export JAVA_HOME=$(readlink -f $1)
+
+set -eu
+
+JAR_BINARY="$(readlink external/local_jdk/bin/jar)"
+JAVA_BINARY="$(readlink external/local_jdk/bin/java)"
+
+report_bad_output() {
+  $JAR_BINARY tf output.jar
+  echo $1
+  exit 1
+}
+
+ROOT=$TEST_SRCDIR/$TEST_WORKSPACE
+
+cd $TEST_TMPDIR
+
+echo "rule foo.** baz.@1" > rules_file
+
+$ROOT/tools/jarjar_library_impl.sh \
+  "output.jar" \
+  "$ROOT/tools/testdata/libfoo.jar $ROOT/tools/testdata/libbar.jar" \
+  "rules_file" \
+  "$ROOT/tools/jarjar_deploy.jar" \
+  "$JAR_BINARY" \
+  "$JAVA_BINARY" \
+  "."
+if $JAR_BINARY  tf output.jar | grep -F -q foo/Foo.class; then
+  report_bad_output "Expected foo/Foo.class to be renamed to baz/Foo.class"
+elif ! $JAR_BINARY tf output.jar | grep -F -q baz/Foo.class; then
+  report_bad_output "Expected baz/Foo.class to be in the output jar"
+fi
+
+if $ROOT/tools/jarjar_library_impl.sh \
+  "output.jar" \
+  "$ROOT/tools/testdata/libfoo_with_dupe_file.jar $ROOT/tools/testdata/libbar_with_dupe_file.jar" \
+  "rules_file" \
+  "$ROOT/tools/jarjar_deploy.jar" \
+  "$JAR_BINARY" \
+  "$JAVA_BINARY" \
+  "."; then
+  report_bad_output 'Expected duplicate file "dupe"'
+fi
diff --git a/tools/javadoc.bzl b/tools/javadoc.bzl
new file mode 100644
index 000000000..8b31a4e0f
--- /dev/null
+++ b/tools/javadoc.bzl
@@ -0,0 +1,120 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+_EXTERNAL_JAVADOC_LINKS = [
+    "https://docs.oracle.com/javase/8/docs/api/",
+    "https://developer.android.com/reference/",
+    "https://google.github.io/guava/releases/21.0/api/docs/",
+    "https://docs.oracle.com/javaee/7/api/",
+]
+
+def _check_non_empty(value, name):
+  if not value:
+    fail("%s must be non-empty" % name)
+
+def _android_jar(android_api_level):
+  if android_api_level == -1:
+    return None
+  return Label("@androidsdk//:platforms/android-%s/android.jar" % android_api_level)
+
+def _javadoc_libary(ctx):
+  _check_non_empty(ctx.attr.root_packages, "root_packages")
+
+  inputs = []
+  for src_attr in ctx.attr.srcs:
+    inputs.extend(src_attr.files.to_list())
+
+  classpath = depset()
+  for dep in ctx.attr.deps:
+    for transitive_dep in dep.java.transitive_deps:
+      classpath += [transitive_dep]
+  if ctx.attr._android_jar:
+    classpath += ctx.attr._android_jar.files
+
+  inputs += classpath.to_list()
+
+  include_packages = ":".join(ctx.attr.root_packages)
+  javadoc_command = [
+      #ctx.file._javadoc_binary.path,
+      'javadoc -sourcepath $(find * -type d -name "*java" -print0 | tr "\\0" :)',
+      include_packages,
+      "-use",
+      "-subpackages", include_packages,
+      "-encoding UTF8",
+      "-classpath", ":".join([jar.path for jar in classpath.to_list()]),
+      "-notimestamp",
+      '-bottom "Copyright &copy; 2012&ndash;2017 The Dagger Authors. All rights reserved."',
+      "-d tmp",
+      "-Xdoclint:-missing",
+      "-quiet",
+  ]
+
+  if ctx.attr.doctitle:
+    javadoc_command.append('-doctitle "%s"' % ctx.attr.doctitle)
+
+  if ctx.attr.exclude_packages:
+    javadoc_command.append("-exclude %s" % ":".join(ctx.attr.exclude_packages))
+
+  for link in _EXTERNAL_JAVADOC_LINKS:
+    javadoc_command.append("-linkoffline {0} {0}".format(link))
+
+  jar_command = "%s cf %s -C tmp ." % (ctx.file._jar_binary.path, ctx.outputs.jar.path)
+
+  ctx.action(
+      inputs = inputs + ctx.files._jdk,
+      command = "%s && %s" % (" ".join(javadoc_command), jar_command),
+      outputs = [ctx.outputs.jar])
+
+javadoc_library = rule(
+    attrs = {
+        "srcs": attr.label_list(allow_files = True),
+        "deps": attr.label_list(),
+        "doctitle": attr.string(default = ""),
+        "root_packages": attr.string_list(),
+        "exclude_packages": attr.string_list(),
+        "android_api_level": attr.int(default = -1),
+        "_android_jar": attr.label(
+            default = _android_jar,
+            allow_single_file = True,
+        ),
+        #"_javadoc_binary": attr.label(
+        #    default = Label("@local_jdk//:bin/javadoc"),
+        #    allow_single_file = True,
+        #),
+        "_jar_binary": attr.label(
+            default = Label("@local_jdk//:bin/jar"),
+            allow_single_file = True,
+        ),
+        "_jdk": attr.label(
+            default = Label("@local_jdk//:jdk-default"),
+            allow_files = True,
+        ),
+    },
+    outputs = {"jar": "%{name}.jar"},
+    implementation = _javadoc_libary,
+)
+"""
+Generates a Javadoc jar path/to/target/<name>.jar.
+
+Arguments:
+  srcs: source files to process
+  deps: targets that contain references to other types referenced in Javadoc. This can be the
+      java_library/android_library target(s) for the same sources
+  root_packages: Java packages to include in generated Javadoc. Any subpackages not listed in
+      exclude_packages will be included as well
+  exclude_packages: Java packages to exclude from generated Javadoc
+  android_api_level: If Android APIs are used, the API level to compile against to generate
+      Javadoc
+  doctitle: title for Javadoc's index.html. See javadoc -doctitle
+"""
diff --git a/tools/testdata/BUILD b/tools/testdata/BUILD
new file mode 100644
index 000000000..b994ff545
--- /dev/null
+++ b/tools/testdata/BUILD
@@ -0,0 +1,44 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# Description:
+#   Tools for Dagger
+
+package(default_visibility = ["//:src"])
+
+java_library(
+    name = "foo",
+    srcs = ["Foo.java"],
+    deps = ["//third_party:auto_service"],
+)
+
+java_library(
+    name = "foo_with_dupe_file",
+    srcs = ["Foo.java"],
+    resources = ["dupe"],
+    deps = ["//third_party:auto_service"],
+)
+
+java_library(
+    name = "bar",
+    srcs = ["Bar.java"],
+    deps = ["//third_party:auto_service"],
+)
+
+java_library(
+    name = "bar_with_dupe_file",
+    srcs = ["Bar.java"],
+    resources = ["dupe"],
+    deps = ["//third_party:auto_service"],
+)
diff --git a/tools/testdata/Bar.java b/tools/testdata/Bar.java
new file mode 100644
index 000000000..e040e39fd
--- /dev/null
+++ b/tools/testdata/Bar.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package bar;
+
+import com.google.auto.service.AutoService;
+
+@AutoService(Object.class)
+class Bar {}
diff --git a/tools/testdata/Foo.java b/tools/testdata/Foo.java
new file mode 100644
index 000000000..f2305c83a
--- /dev/null
+++ b/tools/testdata/Foo.java
@@ -0,0 +1,22 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package foo;
+
+import com.google.auto.service.AutoService;
+
+@AutoService(Object.class)
+class Foo {}
diff --git a/tools/testdata/dupe b/tools/testdata/dupe
new file mode 100644
index 000000000..b68619fc0
--- /dev/null
+++ b/tools/testdata/dupe
@@ -0,0 +1 @@
+duped data file
diff --git a/util/deploy-to-maven-central.sh b/util/deploy-to-maven-central.sh
new file mode 100755
index 000000000..e2e7d2898
--- /dev/null
+++ b/util/deploy-to-maven-central.sh
@@ -0,0 +1,53 @@
+#!/bin/bash
+
+set -eu
+
+if [ $# -lt 2 ]; then
+  echo "usage $0 <ssl-key> <version-name> [<param> ...]"
+  exit 1;
+fi
+key=$1
+version_name=$2
+shift 2
+
+if [[ ! "$version_name" =~ ^2\. ]]; then
+  echo 'Version name must begin with "2."'
+  exit 2
+fi
+
+if [[ "$version_name" =~ " " ]]; then
+  echo "Version name must not have any spaces"
+  exit 3
+fi
+
+#validate key
+keystatus=$(gpg --list-keys | grep ${key} | awk '{print $1}')
+if [ "${keystatus}" != "pub" ]; then
+  echo "Could not find public key with label ${key}"
+  echo -n "Available keys from: "
+  gpg --list-keys | grep --invert-match '^sub'
+
+  exit 64
+fi
+
+bazel test //...
+
+bash $(dirname $0)/execute-deploy.sh \
+  "gpg:sign-and-deploy-file" \
+  "$version_name" \
+  "-DrepositoryId=sonatype-nexus-staging" \
+  "-Durl=https://oss.sonatype.org/service/local/staging/deploy/maven2/" \
+  "-Dgpg.keyname=${key}"
+
+# Publish javadocs to gh-pages
+bazel build //:user-docs.jar
+git clone --quiet --branch gh-pages \
+    https://github.com/google/dagger gh-pages > /dev/null
+cd gh-pages
+unzip ../bazel-genfiles/user-docs.jar -d api/$version_name
+rm -rf api/$version_name/META-INF/
+git add api/$version_name
+git commit -m "$version_name docs"
+git push origin gh-pages
+cd ..
+rm -rf gh-pages
diff --git a/util/execute-deploy.sh b/util/execute-deploy.sh
new file mode 100755
index 000000000..364fa537c
--- /dev/null
+++ b/util/execute-deploy.sh
@@ -0,0 +1,124 @@
+#!/bin/sh
+
+set -eu
+
+readonly MVN_GOAL="$1"
+readonly VERSION_NAME="$2"
+shift 2
+readonly EXTRA_MAVEN_ARGS=("$@")
+
+python $(dirname $0)/maven/generate_poms.py $VERSION_NAME \
+  //java/dagger:core \
+  //gwt:gwt \
+  //java/dagger/internal/codegen:codegen \
+  //java/dagger/producers:producers \
+  //java/dagger/android:android \
+  //java/dagger/android:libandroid.jar \
+  //java/dagger/android/support:libsupport.jar \
+  //java/dagger/android/support:support \
+  //java/dagger/android/processor:processor \
+  //java/dagger/grpc/server:server \
+  //java/dagger/grpc/server:annotations \
+  //java/dagger/grpc/server/processor:processor
+
+library_output_file() {
+  library=$1
+  library_output=bazel-bin/$library
+  if [[ ! -e $library_output ]]; then
+     library_output=bazel-genfiles/$library
+  fi
+  if [[ ! -e $library_output ]]; then
+    echo "Could not find bazel output file for $library"
+    exit 1
+  fi
+  echo -n $library_output
+}
+
+deploy_library() {
+  library=$1
+  srcjar=$2
+  javadoc=$3
+  pomfile=$4
+  bazel build $library $srcjar $javadoc
+
+  mvn $MVN_GOAL \
+    -Dfile=$(library_output_file $library) \
+    -Djavadoc=bazel-bin/$javadoc \
+    -DpomFile=$pomfile \
+    -Dsources=bazel-bin/$srcjar \
+    "${EXTRA_MAVEN_ARGS[@]:+${EXTRA_MAVEN_ARGS[@]}}"
+}
+
+deploy_library \
+  java/dagger/libcore.jar \
+  java/dagger/libcore-src.jar \
+  java/dagger/core-javadoc.jar \
+  dagger.pom.xml
+
+deploy_library \
+  gwt/libgwt.jar \
+  gwt/libgwt.jar \
+  gwt/libgwt.jar \
+  dagger-gwt.pom.xml
+
+deploy_library \
+  shaded_compiler.jar \
+  java/dagger/internal/codegen/libcodegen-src.jar \
+  java/dagger/internal/codegen/codegen-javadoc.jar \
+  dagger-compiler.pom.xml
+
+deploy_library \
+  java/dagger/producers/libproducers.jar \
+  java/dagger/producers/libproducers-src.jar \
+  java/dagger/producers/producers-javadoc.jar \
+  dagger-producers.pom.xml
+
+deploy_library \
+  java/dagger/android/android.aar \
+  java/dagger/android/libandroid-src.jar \
+  java/dagger/android/android-javadoc.jar \
+  dagger-android.pom.xml
+
+# b/37741866 and https://github.com/google/dagger/issues/715
+deploy_library \
+  java/dagger/android/libandroid.jar \
+  java/dagger/android/libandroid-src.jar \
+  java/dagger/android/android-javadoc.jar \
+  dagger-android-jarimpl.pom.xml
+
+deploy_library \
+  java/dagger/android/support/support.aar \
+  java/dagger/android/support/libsupport-src.jar \
+  java/dagger/android/support/support-javadoc.jar \
+  dagger-android-support.pom.xml
+
+# b/37741866 and https://github.com/google/dagger/issues/715
+deploy_library \
+  java/dagger/android/support/libsupport.jar \
+  java/dagger/android/support/libsupport-src.jar \
+  java/dagger/android/support/support-javadoc.jar \
+  dagger-android-support-jarimpl.pom.xml
+
+deploy_library \
+  shaded_android_processor.jar \
+  java/dagger/android/processor/libprocessor-src.jar \
+  java/dagger/android/processor/processor-javadoc.jar \
+  dagger-android-processor.pom.xml
+
+deploy_library \
+  java/dagger/grpc/server/libserver.jar \
+  java/dagger/grpc/server/libserver-src.jar \
+  java/dagger/grpc/server/javadoc.jar \
+  dagger-grpc-server.pom.xml
+
+deploy_library \
+  java/dagger/grpc/server/libannotations.jar \
+  java/dagger/grpc/server/libannotations-src.jar \
+  java/dagger/grpc/server/javadoc.jar \
+  dagger-grpc-server-annotations.pom.xml
+
+deploy_library \
+  shaded_grpc_server_processor.jar \
+  java/dagger/grpc/server/processor/libprocessor-src.jar \
+  java/dagger/grpc/server/processor/javadoc.jar \
+  dagger-grpc-server-processor.pom.xml
diff --git a/util/generate-latest-docs.sh b/util/generate-latest-docs.sh
index 8846d9b54..672fba9ea 100755
--- a/util/generate-latest-docs.sh
+++ b/util/generate-latest-docs.sh
@@ -1,12 +1,14 @@
 # see http://benlimmer.com/2013/12/26/automatically-publish-javadoc-to-gh-pages-with-travis-ci/ for details
 
+set -eu
+
 if [ "$TRAVIS_REPO_SLUG" == "google/dagger" ] && \
    [ "$TRAVIS_JDK_VERSION" == "$JDK_FOR_PUBLISHING" ] && \
    [ "$TRAVIS_PULL_REQUEST" == "false" ] && \
    [ "$TRAVIS_BRANCH" == "master" ]; then
   echo -e "Publishing javadoc...\n"
-  mvn javadoc:aggregate -P!examples -DexcludePackageNames=*.internal
-  TARGET="$(pwd)/target"
+  bazel build //:user-docs.jar
+  JAVADOC_JAR="$(pwd)/bazel-bin/user-docs.jar"
 
   cd $HOME
   git clone --quiet --branch=gh-pages https://${GH_TOKEN}@github.com/google/dagger gh-pages > /dev/null
@@ -16,7 +18,8 @@ if [ "$TRAVIS_REPO_SLUG" == "google/dagger" ] && \
   git config --global user.name "travis-ci"
   git rm -rf api/latest
   mkdir -p api
-  mv ${TARGET}/site/apidocs api/latest
+  unzip "$JAVADOC_JAR" -d api/latest
+  rm -rf api/latest/META-INF/
   git add -f api/latest
   git commit -m "Lastest javadoc on successful travis build $TRAVIS_BUILD_NUMBER auto-pushed to gh-pages"
   git push -fq origin gh-pages > /dev/null
diff --git a/util/maven/generate_poms.py b/util/maven/generate_poms.py
index c9dcc42ee..af19c9820 100644
--- a/util/maven/generate_poms.py
+++ b/util/maven/generate_poms.py
@@ -13,11 +13,13 @@
 # limitations under the License.
 
 import os
+import re
 from subprocess import check_output
 import sys
 from workspace_parser import maven_artifacts
 from xml_formatting import generate_pom
 
+
 def _shell(command):
   output = check_output(command,
                         shell=True,
@@ -26,8 +28,9 @@ def _shell(command):
 
 def deps_of(label):
   return _shell(
-      """bazel query 'let deps = labels(deps, {0}) in
-      $deps except attr(tags, compile_time_dep, $deps)'""".format(label))
+      """bazel query 'let deps = labels(deps, {0})in $deps
+      except attr(tags, "maven:(compile_only|shaded)", $deps)
+      '""".format(label))
 
 def exports_for(label):
   return _shell('bazel query "labels(exports, %s)"' % label)
@@ -49,61 +52,115 @@ def pom_deps(label):
 GROUP = 'com.google.dagger'
 
 METADATA = {
-    '//core/src/main/java/dagger:core': {
+    '//java/dagger:core': {
         'name': 'Dagger',
         'artifact': 'dagger',
-        'alias': '//core:core',
     },
-    '//compiler:compiler': {
+    '//gwt:gwt': {
+        'name': 'Dagger GWT',
+        'artifact': 'dagger-gwt',
+        'manual_dependencies': [
+            'com.google.dagger:dagger:${project.version}',
+            'com.google.dagger:dagger:${project.version}:jar:sources',
+            'javax.inject:javax.inject:1:jar:sources',
+        ],
+    },
+    '//java/dagger/internal/codegen:codegen': {
         'name': 'Dagger Compiler',
         'artifact': 'dagger-compiler',
     },
-    '//producers:producers': {
+    '//java/dagger/producers:producers': {
         'name': 'Dagger Producers',
         'artifact': 'dagger-producers',
     },
-    '//android/src/main/java/dagger/android:android': {
+    '//java/dagger/android:android': {
         'name': 'Dagger Android',
         'artifact': 'dagger-android',
-        'alias': '//android:android',
         'packaging': 'aar',
     },
+    '//java/dagger/android/support:support': {
+        'name': 'Dagger Android Support',
+        'artifact': 'dagger-android-support',
+        'packaging': 'aar',
+    },
+    '//java/dagger/android/processor:processor': {
+        'name': 'Dagger Android Processor',
+        'artifact': 'dagger-android-processor',
+    },
+    '//java/dagger/grpc/server:server': {
+        'name': 'Dagger gRPC Server',
+        'artifact': 'dagger-grpc-server',
+    },
+    '//java/dagger/grpc/server:annotations': {
+        'name': 'Dagger gRPC Server annotations',
+        'artifact': 'dagger-grpc-server-annotations',
+    },
+    '//java/dagger/grpc/server/processor:processor': {
+        'name': 'Dagger gRPC Server processor',
+        'artifact': 'dagger-grpc-server-processor',
+    },
+    # b/37741866 and https://github.com/google/dagger/issues/715
+    '//java/dagger/android:libandroid.jar': {
+        'name': 'Dagger Android (Jar Impl)',
+        'artifact': 'dagger-android-jarimpl',
+    },
+    '//java/dagger/android/support:libsupport.jar': {
+        'name': 'Dagger Android Support (Jar Impl)',
+        'artifact': 'dagger-android-support-jarimpl',
+    },
 }
 
+def dependencies_comparator(first, second):
+  if first == second:
+    return 0
+
+  first = first.split(':')
+  second = second.split(':')
+
+  if first[0] == GROUP and second[0] != GROUP:
+    return -1
+  if second[0] == GROUP and first[0] != GROUP:
+    return 1
+
+  # Compare each item in the list: first sort by group, then artifact
+  if first < second:
+    return -1
+  else:
+    return 1
+
 class UnknownDependencyException(Exception): pass
 
+
 def main():
-  if len(sys.argv) <= 3:
+  if len(sys.argv) < 3:
     print 'Usage: %s <version> <target_for_pom>...' % sys.argv[0]
     sys.exit(1)
 
   version = sys.argv[1]
   artifacts = maven_artifacts()
-  artifacts['@androidsdk//com.android.support:support-annotations-24.2.0'] = (
-      'com.android.support:support-annotations:24.2.0'
-  )
+
+  android_sdk_pattern = re.compile(
+      r'@androidsdk//([a-z.-]*):([a-z0-9-]*)-([0-9.]*)')
 
   for label, metadata in METADATA.iteritems():
     artifacts[label] = (
         'com.google.dagger:%s:%s' % (metadata['artifact'], version)
     )
-    if 'alias' in metadata:
-      artifacts[metadata['alias']] = artifacts[label]
 
   def artifact_for_dep(label):
     if label in artifacts:
       return artifacts[label]
+    match = android_sdk_pattern.match(label)
+    if match:
+      return ':'.join(match.groups())
     raise UnknownDependencyException('No artifact found for %s' % label)
 
   for arg in sys.argv[2:]:
     metadata = METADATA[arg]
     with open('%s.pom.xml' % metadata['artifact'], 'w') as pom_file:
-      pom_file.write(
-          generate_pom(
-              artifacts[arg],
-              metadata,
-              map(artifact_for_dep, pom_deps(arg)),
-              version))
+      deps = map(artifact_for_dep, pom_deps(arg))
+      deps.sort(cmp=dependencies_comparator)
+      pom_file.write(generate_pom(artifacts[arg], metadata, deps, version))
 
 if __name__ == '__main__':
   main()
diff --git a/util/maven/xml_formatting.py b/util/maven/xml_formatting.py
index 71db83b8b..4e8cbb717 100644
--- a/util/maven/xml_formatting.py
+++ b/util/maven/xml_formatting.py
@@ -12,6 +12,8 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
+import textwrap
+
 DEP_BLOCK = """
 <dependency>
   <groupId>%s</groupId>
@@ -20,9 +22,23 @@
 </dependency>
 """.strip()
 
+CLASSIFIER_DEP_BLOCK = """
+<dependency>
+  <groupId>%s</groupId>
+  <artifactId>%s</artifactId>
+  <version>%s</version>
+  <type>%s</type>
+  <classifier>%s</classifier>
+</dependency>
+""".strip()
+
+
 def maven_dependency_xml(artifact_string):
-  group, artifact, version = artifact_string.split(':')
-  formatted = DEP_BLOCK % (group, artifact, version)
+  if artifact_string.count(':') is 2:
+    format_string = DEP_BLOCK
+  else:
+    format_string = CLASSIFIER_DEP_BLOCK
+  formatted = format_string % tuple(artifact_string.split(':'))
   return '\n'.join(['    %s' %x for x in formatted.split('\n')])
 
 POM_OUTLINE = """<?xml version="1.0" encoding="UTF-8"?>
@@ -91,6 +107,8 @@ def maven_dependency_xml(artifact_string):
 def generate_pom(artifact_string, metadata, deps, version):
   group, artifact, version = artifact_string.split(':')
 
+  deps = deps + metadata.get('manual_dependencies', [])
+
   return POM_OUTLINE.format(
       group=group,
       artifact=artifact,
diff --git a/util/mvn-deploy.sh b/util/mvn-deploy.sh
deleted file mode 100755
index c95988094..000000000
--- a/util/mvn-deploy.sh
+++ /dev/null
@@ -1,49 +0,0 @@
-#!/bin/bash
-
-set -eu
-
-if [ $# -lt 2 ]; then
-  echo "usage $0 <ssl-key> <version-name> [<param> ...]"
-  exit 1;
-fi
-key=$1
-version_name=$2
-shift 2
-
-if [[ ! $version_name =~ ^2\. ]]; then
-  echo 'Version name must begin with "2."'
-  exit 2
-fi
-
-# Rename snapshot version and sanity check that it doesn't exist in any poms
-sed -i s/HEAD-SNAPSHOT/$version_name/g `find . -name pom.xml`
-if [[ $(git grep HEAD-SNAPSHOT -- '*pom.xml') ]]; then
-  echo "Snapshots found in poms!"
-  exit 3
-fi
-
-#validate key
-keystatus=$(gpg --list-keys | grep ${key} | awk '{print $1}')
-if [ "${keystatus}" != "pub" ]; then
-  echo "Could not find public key with label ${key}"
-  echo -n "Available keys from: "
-  gpg --list-keys | grep --invert-match '^sub'
-
-  exit 64
-fi
-
-mvn "$@" -P '!examples' -P sonatype-oss-release \
-    -Dgpg.skip=false -Dgpg.keyname=${key} \
-    clean clean site:jar deploy
-
-# Publish javadocs to gh-pages
-mvn javadoc:aggregate -P!examples -DexcludePackageNames=*.internal
-git clone --quiet --branch gh-pages \
-    https://github.com/google/dagger gh-pages > /dev/null
-cd gh-pages
-cp -r ../target/site/apidocs api/$version_name
-git add api/$version_name
-git commit -m "$version_name docs"
-git push origin gh-pages
-cd ..
-rm -rf gh-pages
diff --git a/util/publish-local-snapshot.sh b/util/publish-local-snapshot.sh
new file mode 100755
index 000000000..577ea462b
--- /dev/null
+++ b/util/publish-local-snapshot.sh
@@ -0,0 +1,11 @@
+#!/bin/bash
+
+set -eu
+
+echo -e "Publishing maven snapshot locally...\n"
+
+bash $(dirname $0)/execute-deploy.sh \
+  "install:install-file" \
+  "LOCAL-SNAPSHOT"
+
+echo -e "Published local snapshot"
diff --git a/util/publish-snapshot-on-commit.sh b/util/publish-snapshot-on-commit.sh
index 8173fbb52..944a2c3f7 100755
--- a/util/publish-snapshot-on-commit.sh
+++ b/util/publish-snapshot-on-commit.sh
@@ -1,12 +1,19 @@
 # see https://coderwall.com/p/9b_lfq
 
+set -eu
+
 if [ "$TRAVIS_REPO_SLUG" == "google/dagger" ] && \
    [ "$TRAVIS_JDK_VERSION" == "$JDK_FOR_PUBLISHING" ] && \
    [ "$TRAVIS_PULL_REQUEST" == "false" ] && \
    [ "$TRAVIS_BRANCH" == "master" ]; then
   echo -e "Publishing maven snapshot...\n"
 
-  mvn clean source:jar deploy --settings="util/settings.xml" -DskipTests=true -Dinvoker.skip=true -Dmaven.javadoc.skip=true
+  bash $(dirname $0)/execute-deploy.sh \
+    "deploy:deploy-file" \
+    "HEAD-SNAPSHOT" \
+    "-DrepositoryId=sonatype-nexus-snapshots" \
+    "-Durl=https://oss.sonatype.org/content/repositories/snapshots" \
+    "--settings=$(dirname $0)/settings.xml"
 
   echo -e "Published maven snapshot"
 else
