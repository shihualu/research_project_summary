diff --git a/README.md b/README.md
index 16a47ba8f..3dc38616d 100644
--- a/README.md
+++ b/README.md
@@ -14,7 +14,7 @@ removing the traditional ObjectGraph/Injector in favor of user-specified
 
 This github project represents the Dagger 2 development stream.  The earlier
 [project page][square] (Square, Inc's repository) represents the earlier 1.0
-development stream. Both versions have benefitted from strong involvement from
+development stream. Both versions have benefited from strong involvement from
 Square, Google, and other contributors.
 
 Dagger is currently in active development, primarily internally at Google,
@@ -46,7 +46,7 @@ Given the following `WORKSPACE` definition, you can reference dagger via
 
 ```python
 http_archive(
-    name = "com_google_dagger"
+    name = "com_google_dagger",
     urls = ["https://github.com/google/dagger/archive/dagger-<version>.zip"],
 )
 ```
diff --git a/java/dagger/android/AndroidInjectionKey.java b/java/dagger/android/AndroidInjectionKey.java
new file mode 100644
index 000000000..d4a5d72c2
--- /dev/null
+++ b/java/dagger/android/AndroidInjectionKey.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android;
+
+import static java.lang.annotation.ElementType.METHOD;
+
+import dagger.MapKey;
+import dagger.internal.Beta;
+import java.lang.annotation.Documented;
+import java.lang.annotation.Target;
+
+/**
+ * {@link MapKey} annotation to key {@link AndroidInjector.Factory} bindings. The {@linkplain
+ * #value() value} of the annotation is the canonical name of the class that will be passed to
+ * {@link AndroidInjector#inject(Object)}.
+ *
+ * <p>All key strings will be obfuscated by ProGuard/R8/AppReduce if the named class is obfuscated.
+ *
+ * <p>
+ * You should only use this annotation if you are using a version of ProGuard/R8/AppReduce that
+ * supports the {@code -identifiernamestring} flag.
+ */
+@Beta
+@MapKey
+@Target(METHOD)
+@Documented
+public @interface AndroidInjectionKey {
+  /** The fully qualified class name of the type to be injected. */
+  String value();
+}
diff --git a/java/dagger/android/AndroidInjectionModule.java b/java/dagger/android/AndroidInjectionModule.java
index 224e07f71..05f1adae3 100644
--- a/java/dagger/android/AndroidInjectionModule.java
+++ b/java/dagger/android/AndroidInjectionModule.java
@@ -38,23 +38,42 @@
   abstract Map<Class<? extends Activity>, AndroidInjector.Factory<? extends Activity>>
       activityInjectorFactories();
 
+  @Multibinds
+  abstract Map<String, AndroidInjector.Factory<? extends Activity>>
+      activityInjectorFactoriesWithStringKeys();
+
   @Multibinds
   abstract Map<Class<? extends Fragment>, AndroidInjector.Factory<? extends Fragment>>
       fragmentInjectorFactories();
 
+  @Multibinds
+  abstract Map<String, AndroidInjector.Factory<? extends Fragment>>
+      fragmentInjectorFactoriesWithStringKeys();
+
   @Multibinds
   abstract Map<Class<? extends Service>, AndroidInjector.Factory<? extends Service>>
       serviceInjectorFactories();
 
+  @Multibinds
+  abstract Map<String, AndroidInjector.Factory<? extends Service>>
+      serviceInjectorFactoriesWithStringKeys();
+
   @Multibinds
   abstract Map<
           Class<? extends BroadcastReceiver>, AndroidInjector.Factory<? extends BroadcastReceiver>>
       broadcastReceiverInjectorFactories();
 
   @Multibinds
-  abstract Map<
-          Class<? extends ContentProvider>, AndroidInjector.Factory<? extends ContentProvider>>
+  abstract Map<String, AndroidInjector.Factory<? extends BroadcastReceiver>>
+      broadcastReceiverInjectorFactoriesWithStringKeys();
+
+  @Multibinds
+  abstract Map<Class<? extends ContentProvider>, AndroidInjector.Factory<? extends ContentProvider>>
       contentProviderInjectorFactories();
 
+  @Multibinds
+  abstract Map<String, AndroidInjector.Factory<? extends ContentProvider>>
+      contentProviderInjectorFactoriesWithStringKeys();
+
   private AndroidInjectionModule() {}
 }
diff --git a/java/dagger/android/BUILD b/java/dagger/android/BUILD
index cb2aa8c17..6dfa1c5e3 100644
--- a/java/dagger/android/BUILD
+++ b/java/dagger/android/BUILD
@@ -27,7 +27,10 @@ load("//tools:maven.bzl", "pom_file", "POM_VERSION")
 
 # Work around b/70476182 which prevents Kythe from connecting :producers to the .java files it
 # contains.
-SRCS = glob(["*.java"])
+SRCS = glob([
+    "*.java",
+    "internal/*.java",
+])
 
 filegroup(
     name = "android-srcs",
@@ -82,6 +85,7 @@ javadoc_library(
     name = "android-javadoc",
     srcs = [":android-srcs"],
     android_api_level = 26,
+    exclude_packages = ["dagger.android.internal"],
     root_packages = ["dagger.android"],
     deps = [":android"],
 )
diff --git a/java/dagger/android/DispatchingAndroidInjector.java b/java/dagger/android/DispatchingAndroidInjector.java
index 3c9b7775b..9b011dd13 100644
--- a/java/dagger/android/DispatchingAndroidInjector.java
+++ b/java/dagger/android/DispatchingAndroidInjector.java
@@ -16,6 +16,7 @@
 
 package dagger.android;
 
+import static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;
 import static dagger.internal.Preconditions.checkNotNull;
 
 import android.app.Activity;
@@ -26,6 +27,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import javax.inject.Inject;
 import javax.inject.Provider;
 
@@ -47,13 +49,39 @@
       "No injector factory bound for Class<%1$s>. Injector factories were bound for supertypes "
           + "of %1$s: %2$s. Did you mean to bind an injector factory for the subtype?";
 
-  private final Map<Class<? extends T>, Provider<AndroidInjector.Factory<? extends T>>>
-      injectorFactories;
+  private final Map<String, Provider<AndroidInjector.Factory<? extends T>>> injectorFactories;
 
   @Inject
   DispatchingAndroidInjector(
-      Map<Class<? extends T>, Provider<AndroidInjector.Factory<? extends T>>> injectorFactories) {
-    this.injectorFactories = injectorFactories;
+      Map<Class<? extends T>, Provider<Factory<? extends T>>> injectorFactoriesWithClassKeys,
+      Map<String, Provider<Factory<? extends T>>> injectorFactoriesWithStringKeys) {
+    this.injectorFactories = merge(injectorFactoriesWithClassKeys, injectorFactoriesWithStringKeys);
+  }
+
+  /**
+   * Merges the two maps into one by transforming the values of the {@code classKeyedMap} with
+   * {@link Class#getName()}.
+   *
+   * <p>An SPI plugin verifies the logical uniqueness of the keysets of these two maps so we're
+   * assured there's no overlap.
+   *
+   * <p>Ideally we could achieve this with a generic {@code @Provides} method, but we'd need to have
+   * <i>N</i> modules that each extend one base module.
+   */
+  private static <C, V> Map<String, V> merge(
+      Map<Class<? extends C>, V> classKeyedMap, Map<String, V> stringKeyedMap) {
+    if (classKeyedMap.isEmpty()) {
+      return stringKeyedMap;
+    }
+
+    Map<String, V> merged =
+        newLinkedHashMapWithExpectedSize(classKeyedMap.size() + stringKeyedMap.size());
+    merged.putAll(stringKeyedMap);
+    for (Entry<Class<? extends C>, V> entry : classKeyedMap.entrySet()) {
+      merged.put(entry.getKey().getName(), entry.getValue());
+    }
+
+    return Collections.unmodifiableMap(merged);
   }
 
   /**
@@ -66,7 +94,7 @@
   @CanIgnoreReturnValue
   public boolean maybeInject(T instance) {
     Provider<AndroidInjector.Factory<? extends T>> factoryProvider =
-        injectorFactories.get(instance.getClass());
+        injectorFactories.get(instance.getClass().getName());
     if (factoryProvider == null) {
       return false;
     }
@@ -119,13 +147,12 @@ public void inject(T instance) {
 
   /** Returns an error message with the class names that are supertypes of {@code instance}. */
   private String errorMessageSuggestions(T instance) {
-    List<String> suggestions = new ArrayList<String>();
-    for (Class<? extends T> activityClass : injectorFactories.keySet()) {
-      if (activityClass.isInstance(instance)) {
-        suggestions.add(activityClass.getCanonicalName());
+    List<String> suggestions = new ArrayList<>();
+    for (Class<?> clazz = instance.getClass(); clazz != null; clazz = clazz.getSuperclass()) {
+      if (injectorFactories.containsKey(clazz.getCanonicalName())) {
+        suggestions.add(clazz.getCanonicalName());
       }
     }
-    Collections.sort(suggestions);
 
     return suggestions.isEmpty()
         ? String.format(NO_SUPERTYPES_BOUND_FORMAT, instance.getClass().getCanonicalName())
diff --git a/java/dagger/android/internal/AndroidInjectionKeys.java b/java/dagger/android/internal/AndroidInjectionKeys.java
new file mode 100644
index 000000000..f30b92cdd
--- /dev/null
+++ b/java/dagger/android/internal/AndroidInjectionKeys.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.internal;
+
+/**
+ * An internal implementation detail of Dagger's generated code. This is not guaranteed to remain
+ * consistent from version to version.
+ */
+public final class AndroidInjectionKeys {
+  /**
+   * Accepts the fully qualified name of a class that is injected with {@code dagger.android}.
+   *
+   * <p>From a runtime perspective, this method does nothing except return its single argument. It
+   * is used as a signal to bytecode shrinking tools that its argument should be rewritten if it
+   * corresponds to a class that has been obfuscated/relocated. Once it is done so, it is expected
+   * that the argument will be inlined and this method will go away.
+   */
+  public static String of(String mapKey) {
+    return mapKey;
+  }
+
+  private AndroidInjectionKeys() {}
+}
diff --git a/java/dagger/android/processor/AndroidMapKeyValidator.java b/java/dagger/android/processor/AndroidMapKeyValidator.java
index a6c8a80f0..4084ff4e2 100644
--- a/java/dagger/android/processor/AndroidMapKeyValidator.java
+++ b/java/dagger/android/processor/AndroidMapKeyValidator.java
@@ -17,11 +17,11 @@
 package dagger.android.processor;
 
 import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
-import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.android.processor.AndroidMapKeys.annotationsAndFrameworkTypes;
+import static dagger.android.processor.AndroidMapKeys.injectedTypeFromMapKey;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
 import com.google.auto.common.MoreElements;
@@ -29,6 +29,7 @@
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
 import dagger.Binds;
+import dagger.android.AndroidInjectionKey;
 import dagger.android.AndroidInjector;
 import java.lang.annotation.Annotation;
 import java.util.Set;
@@ -62,7 +63,10 @@
 
   @Override
   public Set<? extends Class<? extends Annotation>> annotations() {
-    return annotationsAndFrameworkTypes(elements).keySet();
+    return ImmutableSet.<Class<? extends Annotation>>builder()
+        .addAll(annotationsAndFrameworkTypes(elements).keySet())
+        .add(AndroidInjectionKey.class)
+        .build();
   }
 
   @Override
@@ -84,7 +88,7 @@ private void validateMethod(Class<? extends Annotation> annotation, ExecutableEl
       return;
     }
 
-    TypeMirror frameworkType = annotationsAndFrameworkTypes(elements).get(annotation);
+    TypeMirror frameworkType = frameworkTypeForMapKey(method, annotation);
 
     if (!getAnnotatedAnnotations(method, Scope.class).isEmpty()) {
       SuppressWarnings suppressedWarnings = method.getAnnotation(SuppressWarnings.class);
@@ -102,11 +106,16 @@ private void validateMethod(Class<? extends Annotation> annotation, ExecutableEl
 
     DeclaredType intendedReturnType = injectorFactoryOf(types.getWildcardType(frameworkType, null));
     if (!MoreTypes.equivalence().equivalent(returnType, intendedReturnType)) {
+      String subject =
+          annotation.equals(AndroidInjectionKey.class)
+              ? method.toString()
+              : String.format("@%s methods", annotation.getCanonicalName());
+
       messager.printMessage(
           Kind.ERROR,
           String.format(
-              "@%s methods should bind %s, not %s. See https://google.github.io/dagger/android",
-              annotation.getCanonicalName(), intendedReturnType, returnType),
+              "%s should bind %s, not %s. See https://google.github.io/dagger/android",
+              subject, intendedReturnType, returnType),
           method);
     }
 
@@ -135,16 +144,30 @@ private void validateMapKeyMatchesBindsParameter(
       Class<? extends Annotation> annotation, ExecutableElement method) {
     TypeMirror parameterType = getOnlyElement(method.getParameters()).asType();
     AnnotationMirror annotationMirror = getAnnotationMirror(method, annotation).get();
-    TypeMirror mapKeyValue = (TypeMirror) getAnnotationValue(annotationMirror, "value").getValue();
-    if (!types.isAssignable(parameterType, injectorFactoryOf(mapKeyValue))) {
+    TypeMirror mapKeyType =
+        elements.getTypeElement(injectedTypeFromMapKey(annotationMirror).get()).asType();
+    if (!types.isAssignable(parameterType, injectorFactoryOf(mapKeyType))) {
       messager.printMessage(
           Kind.ERROR,
-          String.format("%s does not implement AndroidInjector<%s>", parameterType, mapKeyValue),
+          String.format("%s does not implement AndroidInjector<%s>", parameterType, mapKeyType),
           method,
           annotationMirror);
     }
   }
 
+  private TypeMirror frameworkTypeForMapKey(
+      ExecutableElement method, Class<? extends Annotation> annotation) {
+    AnnotationMirror annotationMirror = getAnnotationMirror(method, annotation).get();
+    TypeMirror mapKeyType =
+        elements.getTypeElement(injectedTypeFromMapKey(annotationMirror).get()).asType();
+    return annotationsAndFrameworkTypes(elements)
+        .values()
+        .stream()
+        .filter(frameworkType -> types.isAssignable(mapKeyType, frameworkType))
+        .findFirst()
+        .get();
+  }
+
   /** Returns a {@link DeclaredType} for {@code AndroidInjector.Factory<implementationType>}. */
   private DeclaredType injectorFactoryOf(TypeMirror implementationType) {
     return types.getDeclaredType(factoryElement(), implementationType);
diff --git a/java/dagger/android/processor/AndroidMapKeys.java b/java/dagger/android/processor/AndroidMapKeys.java
index 61eee8e75..64682070a 100644
--- a/java/dagger/android/processor/AndroidMapKeys.java
+++ b/java/dagger/android/processor/AndroidMapKeys.java
@@ -16,6 +16,7 @@
 
 package dagger.android.processor;
 
+import static com.google.auto.common.AnnotationMirrors.getAnnotationValue;
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static java.util.stream.Collectors.toMap;
@@ -25,9 +26,12 @@
 import com.google.auto.common.MoreTypes;
 import com.google.common.collect.ImmutableMap;
 import dagger.MapKey;
+import dagger.android.AndroidInjectionKey;
 import java.lang.annotation.Annotation;
 import java.util.List;
+import java.util.Optional;
 import java.util.stream.Stream;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
@@ -50,12 +54,17 @@
                 elements.getPackageElement("dagger.android.support"))
             .filter(packageElement -> packageElement != null)
             .flatMap(packageElement -> typesIn(packageElement.getEnclosedElements()).stream())
+            .filter(AndroidMapKeys::isNotAndroidInjectionKey)
             .filter(type -> isAnnotationPresent(type, MapKey.class))
             .filter(mapKey -> mapKey.getAnnotation(MapKey.class).unwrapValue())
             .flatMap(AndroidMapKeys::classForAnnotationElement)
             .collect(toMap(key -> key, key -> mapKeyValue(key, elements))));
   }
 
+  private static boolean isNotAndroidInjectionKey(TypeElement type) {
+    return !type.getQualifiedName().contentEquals(AndroidInjectionKey.class.getCanonicalName());
+  }
+
   private static Stream<Class<? extends Annotation>> classForAnnotationElement(TypeElement type) {
     try {
       @SuppressWarnings("unchecked")
@@ -75,4 +84,21 @@ private static TypeMirror mapKeyValue(Class<? extends Annotation> annotation, El
     return ((WildcardType) getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments()))
         .getExtendsBound();
   }
+
+  /**
+   * If {@code mapKey} is {@link AndroidInjectionKey}, returns the string value for the map key. If
+   * it's {@link dagger.android.ActivityKey} or one of the other class-based keys, returns the
+   * fully-qualified class name of the annotation value. Otherwise returns {@link Optional#empty()}.
+   */
+  static Optional<String> injectedTypeFromMapKey(AnnotationMirror mapKey) {
+    Object mapKeyClass = getAnnotationValue(mapKey, "value").getValue();
+    if (mapKeyClass instanceof String) {
+      return Optional.of((String) mapKeyClass);
+    } else if (mapKeyClass instanceof TypeMirror) {
+      TypeElement type = MoreTypes.asTypeElement((TypeMirror) mapKeyClass);
+      return Optional.of(type.getQualifiedName().toString());
+    } else {
+      return Optional.empty();
+    }
+  }
 }
diff --git a/java/dagger/android/processor/AndroidProcessor.java b/java/dagger/android/processor/AndroidProcessor.java
index 5db7fabeb..c46817018 100644
--- a/java/dagger/android/processor/AndroidProcessor.java
+++ b/java/dagger/android/processor/AndroidProcessor.java
@@ -16,13 +16,23 @@
 
 package dagger.android.processor;
 
+import static javax.tools.Diagnostic.Kind.ERROR;
+import static javax.tools.StandardLocation.CLASS_OUTPUT;
+
 import com.google.auto.common.BasicAnnotationProcessor;
 import com.google.auto.service.AutoService;
+import com.google.common.base.Ascii;
+import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.googlejavaformat.java.filer.FormattingFiler;
+import java.io.IOException;
+import java.io.Writer;
+import java.util.Set;
 import javax.annotation.processing.Filer;
 import javax.annotation.processing.Messager;
 import javax.annotation.processing.Processor;
+import javax.annotation.processing.RoundEnvironment;
 import javax.lang.model.SourceVersion;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
@@ -30,9 +40,22 @@
 /**
  * An {@linkplain javax.annotation.processing.Processor annotation processor} to verify usage of
  * {@code dagger.android} code.
+ *
+ * <p>Additionally, if {@code -Adagger.android.experimentalUseStringKeys} is passed to the
+ * compilation, a file will be generated to support obfuscated injected Android types used with
+ * {@code @AndroidInjectionKey}. The fact that this is generated is deliberate: not all versions of
+ * ProGuard/R8 support {@code -identifiernamestring}, so we can't include a ProGuard file in the
+ * dagger-android artifact Instead, we generate the file in {@code META-INF/proguard} only when
+ * users enable the flag. They should only be enabling it if their shrinker supports those files,
+ * and any version that does so will also support {@code -identifiernamestring}. This was added to
+ * R8 in <a href="https://r8.googlesource.com/r8/+/389123dfcc11e6dda0eec31ab62e1b7eb0da80d2">May
+ * 2018</a>.
  */
 @AutoService(Processor.class)
 public final class AndroidProcessor extends BasicAnnotationProcessor {
+  private static final String FLAG_EXPERIMENTAL_USE_STRING_KEYS =
+      "dagger.android.experimentalUseStringKeys";
+
   @Override
   protected Iterable<? extends ProcessingStep> initSteps() {
     Filer filer = new FormattingFiler(processingEnv.getFiler());
@@ -44,11 +67,61 @@
         new AndroidMapKeyValidator(elements, types, messager),
         new ContributesAndroidInjectorGenerator(
             new AndroidInjectorDescriptor.Validator(types, elements, messager),
+            useStringKeys(),
             filer,
             elements,
             processingEnv.getSourceVersion()));
   }
 
+  private boolean useStringKeys() {
+    if (!processingEnv.getOptions().containsKey(FLAG_EXPERIMENTAL_USE_STRING_KEYS)) {
+      return false;
+    }
+    String flagValue = processingEnv.getOptions().get(FLAG_EXPERIMENTAL_USE_STRING_KEYS);
+    if (flagValue == null || Ascii.equalsIgnoreCase(flagValue, "true")) {
+      return true;
+    } else if (Ascii.equalsIgnoreCase(flagValue, "false")) {
+      return false;
+    } else {
+      processingEnv
+          .getMessager()
+          .printMessage(
+              ERROR,
+              String.format(
+                  "Unknown flag value: %s. %s must be set to either 'true' or 'false'.",
+                  flagValue, FLAG_EXPERIMENTAL_USE_STRING_KEYS));
+      return false;
+    }
+  }
+
+  @Override
+  protected void postRound(RoundEnvironment roundEnv) {
+    if (roundEnv.processingOver() && useStringKeys()) {
+      try (Writer writer = createProguardFile()){
+        writer.write(
+            Joiner.on("\n")
+                .join(
+                    "-identifiernamestring class dagger.android.internal.AndroidInjectionKeys {",
+                    "  java.lang.String of(java.lang.String);",
+                    "}"));
+      } catch (IOException e) {
+        e.printStackTrace();
+      }
+    }
+  }
+
+  private Writer createProguardFile() throws IOException {
+    return processingEnv
+        .getFiler()
+        .createResource(CLASS_OUTPUT, "", "META-INF/proguard/dagger.android.AndroidInjectionKeys")
+        .openWriter();
+  }
+
+  @Override
+  public Set<String> getSupportedOptions() {
+    return ImmutableSet.of(FLAG_EXPERIMENTAL_USE_STRING_KEYS);
+  }
+
   @Override
   public SourceVersion getSupportedSourceVersion() {
     return SourceVersion.latestSupported();
diff --git a/java/dagger/android/processor/BUILD b/java/dagger/android/processor/BUILD
index 565b1b8a3..94caad6a1 100644
--- a/java/dagger/android/processor/BUILD
+++ b/java/dagger/android/processor/BUILD
@@ -42,6 +42,8 @@ java_library(
         "@google_bazel_common//third_party/java/javapoet",
         "@google_bazel_common//third_party/java/google_java_format",
         "//java/dagger:core",
+        "//java/dagger/model",
+        "//java/dagger/spi",
         # https://github.com/bazelbuild/bazel/issues/2517
         ":dagger-android-jars",
     ],
diff --git a/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java b/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
index 2d1023abc..57404764c 100644
--- a/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
+++ b/java/dagger/android/processor/ContributesAndroidInjectorGenerator.java
@@ -46,6 +46,7 @@
 import dagger.Module;
 import dagger.Subcomponent;
 import dagger.Subcomponent.Builder;
+import dagger.android.AndroidInjectionKey;
 import dagger.android.AndroidInjector;
 import dagger.android.ContributesAndroidInjector;
 import dagger.android.processor.AndroidInjectorDescriptor.Validator;
@@ -65,12 +66,18 @@
   private final AndroidInjectorDescriptor.Validator validator;
   private final Filer filer;
   private final Elements elements;
+  private final boolean useStringKeys;
   private final SourceVersion sourceVersion;
 
   ContributesAndroidInjectorGenerator(
-      Validator validator, Filer filer, Elements elements, SourceVersion sourceVersion) {
-    this.filer = filer;
+      Validator validator,
+      boolean useStringKeys,
+      Filer filer,
+      Elements elements,
+      SourceVersion sourceVersion) {
     this.validator = validator;
+    this.useStringKeys = useStringKeys;
+    this.filer = filer;
     this.elements = elements;
     this.sourceVersion = sourceVersion;
   }
@@ -131,10 +138,7 @@ private MethodSpec bindAndroidInjectorFactory(
     return methodBuilder("bindAndroidInjectorFactory")
         .addAnnotation(Binds.class)
         .addAnnotation(IntoMap.class)
-        .addAnnotation(
-            AnnotationSpec.builder(descriptor.mapKeyType())
-                .addMember("value", "$T.class", descriptor.injectedType())
-                .build())
+        .addAnnotation(androidInjectorMapKey(descriptor))
         .addModifiers(ABSTRACT)
         .returns(
             parameterizedTypeName(
@@ -144,6 +148,17 @@ private MethodSpec bindAndroidInjectorFactory(
         .build();
   }
 
+  private AnnotationSpec androidInjectorMapKey(AndroidInjectorDescriptor descriptor) {
+    if (useStringKeys) {
+      return AnnotationSpec.builder(AndroidInjectionKey.class)
+          .addMember("value", "$S", descriptor.injectedType().toString())
+          .build();
+    }
+    return AnnotationSpec.builder(descriptor.mapKeyType())
+        .addMember("value", "$T.class", descriptor.injectedType())
+        .build();
+  }
+
   private TypeSpec subcomponent(
       AndroidInjectorDescriptor descriptor,
       ClassName subcomponentName,
diff --git a/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java b/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java
new file mode 100644
index 000000000..0e08debb3
--- /dev/null
+++ b/java/dagger/android/processor/DuplicateAndroidInjectorsChecker.java
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;
+import static com.google.common.collect.Iterables.getOnlyElement;
+import static dagger.android.processor.AndroidMapKeys.injectedTypeFromMapKey;
+import static java.util.stream.Collectors.collectingAndThen;
+import static java.util.stream.Collectors.toList;
+import static javax.tools.Diagnostic.Kind.ERROR;
+
+import com.google.auto.common.MoreTypes;
+import com.google.auto.service.AutoService;
+import com.google.common.collect.ImmutableListMultimap;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Multimaps;
+import dagger.MapKey;
+import dagger.android.AndroidInjector;
+import dagger.android.DispatchingAndroidInjector;
+import dagger.model.BindingGraph;
+import dagger.model.BindingGraph.BindingNode;
+import dagger.model.BindingKind;
+import dagger.model.Key;
+import dagger.spi.BindingGraphPlugin;
+import dagger.spi.DiagnosticReporter;
+import java.util.Formatter;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.stream.Stream;
+import javax.inject.Provider;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.type.TypeKind;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.util.Elements;
+import javax.lang.model.util.Types;
+
+/**
+ * Validates that the two maps that {@link DispatchingAndroidInjector} injects have logically
+ * different keys. If a contribution exists for the same {@code FooActivity} with
+ * {@code @ActivityKey(FooActivity.class)} and
+ * {@code @AndroidInjectionKey("com.example.FooActivity")}, report an error.
+ */
+@AutoService(BindingGraphPlugin.class)
+public final class DuplicateAndroidInjectorsChecker implements BindingGraphPlugin {
+  private Types types;
+  private Elements elements;
+
+  @Override
+  public void visitGraph(BindingGraph graph, DiagnosticReporter diagnosticReporter) {
+    for (BindingNode node : graph.bindingNodes()) {
+      if (isDispatchingAndroidInjector(node)) {
+        validateMapKeyUniqueness(node, graph, diagnosticReporter);
+      }
+    }
+  }
+
+  private boolean isDispatchingAndroidInjector(BindingNode node) {
+    Key key = node.binding().key();
+    return MoreTypes.isTypeOf(DispatchingAndroidInjector.class, key.type())
+        && !key.qualifier().isPresent();
+  }
+
+  private void validateMapKeyUniqueness(
+      BindingNode dispatchingAndroidInjectorNode,
+      BindingGraph graph,
+      DiagnosticReporter diagnosticReporter) {
+    ImmutableSet<BindingNode> injectorFactories =
+        injectorMapDependencies(dispatchingAndroidInjectorNode, graph)
+            .flatMap(injectorFactoryMap -> dependencies(injectorFactoryMap, graph))
+            .collect(collectingAndThen(toList(), ImmutableSet::copyOf));
+
+    ImmutableListMultimap.Builder<String, BindingNode> mapKeyIndex =
+        ImmutableListMultimap.builder();
+    for (BindingNode injectorFactory : injectorFactories) {
+      AnnotationMirror mapKey = mapKey(injectorFactory).get();
+      Optional<String> injectedType = injectedTypeFromMapKey(mapKey);
+      if (injectedType.isPresent()) {
+        mapKeyIndex.put(injectedType.get(), injectorFactory);
+      } else {
+        diagnosticReporter.reportBinding(
+            ERROR, injectorFactory, "Unrecognized class: %s", mapKey);
+      }
+    }
+
+    Map<String, List<BindingNode>> duplicates =
+        Maps.filterValues(
+            Multimaps.asMap(mapKeyIndex.build()), bindingNodes -> bindingNodes.size() > 1);
+    if (!duplicates.isEmpty()) {
+      StringBuilder errorMessage =
+          new StringBuilder("Multiple injector factories bound for the same type:\n");
+      Formatter formatter = new Formatter(errorMessage);
+      duplicates.forEach(
+          (injectedType, duplicateFactories) -> {
+            formatter.format("  %s:\n", injectedType);
+            duplicateFactories.forEach(duplicate -> formatter.format("    %s\n", duplicate));
+          });
+      diagnosticReporter.reportBinding(
+          ERROR, dispatchingAndroidInjectorNode, errorMessage.toString());
+    }
+  }
+
+  private Stream<BindingNode> dependencies(BindingNode bindingNode, BindingGraph graph) {
+    return graph
+        .successors(bindingNode)
+        .stream()
+        // TODO(ronshapiro): reuse DaggerStreams.instancesOf()?
+        .filter(BindingNode.class::isInstance)
+        .map(BindingNode.class::cast);
+  }
+
+  /**
+   * Returns a stream of the dependencies of {@code bindingNode} that have a key type of {@code
+   * Map<K, Provider<AndroidInjector.Factory<?>>}.
+   */
+  private Stream<BindingNode> injectorMapDependencies(BindingNode bindingNode, BindingGraph graph) {
+    return dependencies(bindingNode, graph)
+        .filter(node -> node.binding().kind().equals(BindingKind.MULTIBOUND_MAP))
+        .filter(
+            node -> {
+              TypeMirror valueType =
+                  MoreTypes.asDeclared(node.binding().key().type()).getTypeArguments().get(1);
+              if (!MoreTypes.isTypeOf(Provider.class, valueType)
+                  || !valueType.getKind().equals(TypeKind.DECLARED)) {
+                return false;
+              }
+              TypeMirror providedType = MoreTypes.asDeclared(valueType).getTypeArguments().get(0);
+              return MoreTypes.isTypeOf(AndroidInjector.Factory.class, providedType);
+            });
+  }
+
+  private Optional<AnnotationMirror> mapKey(BindingNode bindingNode) {
+    return bindingNode
+        .binding()
+        .bindingElement()
+        .map(bindingElement -> getAnnotatedAnnotations(bindingElement, MapKey.class))
+        .flatMap(
+            annotations ->
+                annotations.isEmpty()
+                    ? Optional.empty()
+                    : Optional.of(getOnlyElement(annotations)));
+  }
+
+  @Override
+  public String pluginName() {
+    return "Dagger/Android/DuplicateAndroidInjectors";
+  }
+
+  @Override
+  public void initTypes(Types types) {
+    this.types = types;
+  }
+
+  @Override
+  public void initElements(Elements elements) {
+    this.elements = elements;
+  }
+}
diff --git a/java/dagger/android/support/AndroidSupportInjectionModule.java b/java/dagger/android/support/AndroidSupportInjectionModule.java
index 6349afb67..85b277a97 100644
--- a/java/dagger/android/support/AndroidSupportInjectionModule.java
+++ b/java/dagger/android/support/AndroidSupportInjectionModule.java
@@ -36,5 +36,9 @@
   abstract Map<Class<? extends Fragment>, AndroidInjector.Factory<? extends Fragment>>
       supportFragmentInjectorFactories();
 
+  @Multibinds
+  abstract Map<String, AndroidInjector.Factory<? extends Fragment>>
+      supportFragmentInjectorFactoriesWithStringKeys();
+
   private AndroidSupportInjectionModule() {}
 }
diff --git a/java/dagger/internal/DaggerCollections.java b/java/dagger/internal/DaggerCollections.java
index 3d47a8497..cebca42d2 100644
--- a/java/dagger/internal/DaggerCollections.java
+++ b/java/dagger/internal/DaggerCollections.java
@@ -70,7 +70,7 @@ public static boolean hasDuplicates(List<?> list) {
    * Creates a {@link LinkedHashMap} instance, with a high enough "initial capacity" that it
    * <em>should</em> hold {@code expectedSize} elements without growth.
    */
-  static <K, V> LinkedHashMap<K, V> newLinkedHashMapWithExpectedSize(int expectedSize) {
+  public static <K, V> LinkedHashMap<K, V> newLinkedHashMapWithExpectedSize(int expectedSize) {
     return new LinkedHashMap<K, V>(calculateInitialCapacity(expectedSize));
   }
 
diff --git a/java/dagger/internal/SetFactory.java b/java/dagger/internal/SetFactory.java
index 3f3ad0d51..349399b3e 100644
--- a/java/dagger/internal/SetFactory.java
+++ b/java/dagger/internal/SetFactory.java
@@ -101,8 +101,7 @@ private SetFactory(
   }
 
   /**
-   * Returns a {@link Set} whose iteration order is that of the elements given by each of the
-   * providers, which are invoked in the order given at creation.
+   * Returns a {@link Set} that contains the elements given by each of the providers.
    *
    * @throws NullPointerException if any of the delegate {@link Set} instances or elements therein
    *     are {@code null}
diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 45597b0f4..4a5a6fcc7 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -176,6 +176,7 @@ java_library(
         "ComponentHierarchyValidator.java",
         "ComponentValidator.java",
         "DependencyRequestFormatter.java",
+        "DependencyRequestValidator.java",
         "ForReleasableReferencesValidator.java",
         "InjectValidator.java",
         "MapKeyValidator.java",
@@ -203,6 +204,7 @@ java_library(
         "DependsOnProductionExecutorValidator.java",
         "DuplicateBindingsValidation.java",
         "IncompatiblyScopedBindingsValidation.java",
+        "IncorrectlyInstalledBindsMethodsValidator.java",
         "InjectBindingValidation.java",
         "MapMultibindingValidation.java",
         "MembersInjectionBindingValidation.java",
@@ -212,6 +214,7 @@ java_library(
         "SubcomponentFactoryMethodValidation.java",
         "Validation.java",
     ],
+    plugins = CODEGEN_PLUGINS,
     tags = ["maven:merged"],
     deps = CODEGEN_DEPS + [
         ":base",
@@ -229,14 +232,12 @@ java_library(
         "BindingMethodImplementation.java",
         "ComponentBindingExpressions.java",
         "ComponentBuilder.java",
-        "ComponentGenerator.java",
         "ComponentInstanceBindingExpression.java",
         "ComponentMethodBindingExpression.java",
         "ComponentProvisionBindingExpression.java",
         "ComponentRequirementBindingExpression.java",
         "ComponentRequirementField.java",
         "ComponentRequirementFields.java",
-        "ComponentWriter.java",
         "DelegateBindingExpression.java",
         "DelegatingFrameworkInstanceCreationExpression.java",
         "DependencyMethodProducerCreationExpression.java",
@@ -248,6 +249,7 @@ java_library(
         "FrameworkInstanceBindingExpression.java",
         "FrameworkInstanceSupplier.java",
         "GeneratedComponentModel.java",
+        "GeneratedInstanceBindingExpression.java",
         "GwtCompatibility.java",
         "ImmediateFutureBindingExpression.java",
         "InaccessibleMapKeyProxyGenerator.java",
@@ -263,6 +265,7 @@ java_library(
         "MembersInjectorGenerator.java",
         "MembersInjectorProviderCreationExpression.java",
         "MethodBindingExpression.java",
+        "MissingBindingExpression.java",
         "MonitoringModuleGenerator.java",
         "MonitoringModuleProcessingStep.java",
         "OptionalBindingExpression.java",
@@ -306,7 +309,9 @@ java_library(
         "BindingGraphPluginsModule.java",
         "BindingMethodValidatorsModule.java",
         "CanReleaseReferencesProcessingStep.java",
+        "ComponentGenerator.java",
         "ComponentHjarProcessingStep.java",
+        "ComponentModelBuilder.java",
         "ComponentProcessingStep.java",
         "ComponentProcessor.java",
         "DiagnosticReporterFactory.java",
@@ -350,6 +355,7 @@ java_library(
     deps = [
         ":base",
         ":binding",
+        ":binding_graph_validation",
         ":kythe_plugin",
         ":processor",
         ":validation",
diff --git a/java/dagger/internal/codegen/BindingCycleValidation.java b/java/dagger/internal/codegen/BindingCycleValidation.java
index 2d6108408..ed61c36b6 100644
--- a/java/dagger/internal/codegen/BindingCycleValidation.java
+++ b/java/dagger/internal/codegen/BindingCycleValidation.java
@@ -27,7 +27,6 @@
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.RequestKinds.extractKeyType;
 import static dagger.internal.codegen.RequestKinds.getRequestKind;
-import static java.util.Comparator.comparingInt;
 import static javax.tools.Diagnostic.Kind.ERROR;
 
 import com.google.auto.value.AutoValue;
@@ -40,6 +39,7 @@
 import com.google.common.graph.NetworkBuilder;
 import dagger.model.BindingGraph;
 import dagger.model.BindingGraph.BindingNode;
+import dagger.model.BindingGraph.ComponentNode;
 import dagger.model.BindingGraph.DependencyEdge;
 import dagger.model.BindingGraph.Node;
 import dagger.model.BindingKind;
@@ -106,6 +106,15 @@ public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticR
 
   /**
    * Reports a dependency cycle at the dependency into the cycle that is closest to an entry point.
+   *
+   * <p>Looks for the shortest path from the component that contains the cycle (all bindings in a
+   * cycle must be in the same component; see below) to some binding in the cycle. Then looks for
+   * the last dependency in that path that is not in the cycle; that is the dependency that will be
+   * reported, so that the dependency trace will end just before the cycle.
+   *
+   * <p>Proof (by counterexample) that all bindings in a cycle must be in the same component: Assume
+   * one binding in the cycle is in a parent component. Bindings cannot depend on bindings in child
+   * components, so that binding cannot depend on the next binding in the cycle.
    */
   private void reportCycle(
       Cycle<Node> cycle, BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
@@ -121,18 +130,11 @@ private void reportCycle(
   private ImmutableList<Node> shortestPathToCycleFromAnEntryPoint(
       Cycle<Node> cycle, BindingGraph bindingGraph) {
     Node someCycleNode = cycle.nodes().asList().get(0);
-    return bindingGraph
-        .componentNodes()
-        .stream()
-        .map(componentNode -> shortestPath(bindingGraph, componentNode, someCycleNode))
-        // Ignore paths that go through subcomponents by requiring all nodes after the first to be
-        // BindingNodes. We can't just use nonCycleBreakingDependencyGraph because that filters out
-        // edges that might break a cycle, but those edges might still be part of the shortest path
-        // TO a cycle.
-        .filter(path -> path.stream().skip(1).allMatch(node -> node instanceof BindingNode))
-        .map(path -> subpathToCycle(path, cycle))
-        .min(comparingInt(ImmutableList::size))
-        .get();
+    ComponentNode componentContainingCycle =
+        bindingGraph.componentNode(someCycleNode.componentPath()).get();
+    ImmutableList<Node> pathToCycle =
+        shortestPath(bindingGraph, componentContainingCycle, someCycleNode);
+    return subpathToCycle(pathToCycle, cycle);
   }
 
   /**
@@ -232,13 +234,8 @@ private DependencyEdge chooseDependencyEdgeConnecting(
   private ImmutableNetwork<Node, DependencyEdge> nonCycleBreakingDependencyGraph(
       BindingGraph bindingGraph) {
     MutableNetwork<Node, DependencyEdge> dependencyNetwork =
-        NetworkBuilder.directed()
-            .allowsParallelEdges(true)
-            .allowsSelfLoops(true)
-            .nodeOrder(bindingGraph.nodeOrder())
-            .edgeOrder(bindingGraph.edgeOrder())
-            .expectedNodeCount(
-                bindingGraph.bindingNodes().size() + bindingGraph.componentNodes().size())
+        NetworkBuilder.from(bindingGraph)
+            .expectedNodeCount(bindingGraph.nodes().size())
             .expectedEdgeCount(bindingGraph.dependencyEdges().size())
             .build();
     bindingGraph
@@ -298,7 +295,7 @@ int size() {
     }
 
     @Override
-    public String toString() {
+    public final String toString() {
       return endpointPairs().toString();
     }
 
diff --git a/java/dagger/internal/codegen/BindingFactory.java b/java/dagger/internal/codegen/BindingFactory.java
index 23e0745c7..9406467c2 100644
--- a/java/dagger/internal/codegen/BindingFactory.java
+++ b/java/dagger/internal/codegen/BindingFactory.java
@@ -27,6 +27,7 @@
 import static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;
 import static dagger.internal.codegen.ConfigurationAnnotations.getNullableType;
 import static dagger.internal.codegen.ContributionBinding.bindingKindForMultibindingKey;
+import static dagger.internal.codegen.DaggerElements.DECLARATION_ORDER;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifier;
 import static dagger.internal.codegen.MapKeys.getMapKey;
@@ -614,7 +615,7 @@ MembersInjectionBinding membersInjectionBinding(
             .thenComparing(injectionSite -> injectionSite.element().getKind())
             // then sort by whichever element comes first in the parent
             // this isn't necessary, but makes the processor nice and predictable
-            .thenComparing(InjectionSite::indexAmongSiblingMembers),
+            .thenComparing(InjectionSite::element, DECLARATION_ORDER),
         injectionSites);
   }
 
diff --git a/java/dagger/internal/codegen/BindingGraph.java b/java/dagger/internal/codegen/BindingGraph.java
index 1eec2ee97..2edd63d1b 100644
--- a/java/dagger/internal/codegen/BindingGraph.java
+++ b/java/dagger/internal/codegen/BindingGraph.java
@@ -18,6 +18,7 @@
 
 import static com.google.common.base.Preconditions.checkState;
 import static dagger.internal.codegen.ComponentRequirement.Kind.BOUND_INSTANCE;
+import static dagger.internal.codegen.DaggerStreams.presentValues;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 
 import com.google.auto.value.AutoValue;
@@ -187,9 +188,8 @@ TypeElement componentType() {
         .flatMap(graph -> graph.contributionBindings().values().stream())
         .flatMap(bindings -> bindings.contributionBindings().stream())
         .filter(ContributionBinding::requiresModuleInstance)
-        .map(bindingDeclaration -> bindingDeclaration.contributingModule())
-        .filter(Optional::isPresent)
-        .map(Optional::get)
+        .map(ContributionBinding::contributingModule)
+        .flatMap(presentValues())
         .filter(module -> ownedModuleTypes().contains(module))
         .map(module -> ComponentRequirement.forModule(module.asType()))
         .forEach(requirements::add);
diff --git a/java/dagger/internal/codegen/BindingGraphConverter.java b/java/dagger/internal/codegen/BindingGraphConverter.java
index cb8f7e15a..533f4344b 100644
--- a/java/dagger/internal/codegen/BindingGraphConverter.java
+++ b/java/dagger/internal/codegen/BindingGraphConverter.java
@@ -16,9 +16,14 @@
 
 package dagger.internal.codegen;
 
+import static com.google.auto.common.MoreTypes.asTypeElement;
 import static dagger.internal.codegen.DaggerStreams.instancesOf;
+import static dagger.internal.codegen.DaggerStreams.presentValues;
+import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.model.BindingGraphProxies.childFactoryMethodEdge;
 import static dagger.model.BindingGraphProxies.dependencyEdge;
+import static dagger.model.BindingGraphProxies.subcomponentBuilderBindingEdge;
+import static dagger.model.BindingKind.SUBCOMPONENT_BUILDER;
 
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
@@ -35,15 +40,20 @@
 import dagger.model.DependencyRequest;
 import javax.inject.Inject;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
+import javax.lang.model.type.TypeMirror;
 
 /** Converts {@link dagger.internal.codegen.BindingGraph}s to {@link dagger.model.BindingGraph}s. */
 final class BindingGraphConverter {
 
   private final BindingDeclarationFormatter bindingDeclarationFormatter;
+  private final CompilerOptions compilerOptions;
 
   @Inject
-  BindingGraphConverter(BindingDeclarationFormatter bindingDeclarationFormatter) {
+  BindingGraphConverter(
+      BindingDeclarationFormatter bindingDeclarationFormatter, CompilerOptions compilerOptions) {
     this.bindingDeclarationFormatter = bindingDeclarationFormatter;
+    this.compilerOptions = compilerOptions;
   }
 
   /**
@@ -65,7 +75,7 @@
     private ComponentNode currentComponent;
 
     Traverser(BindingGraph graph) {
-      super(graph);
+      super(graph, compilerOptions);
     }
 
     @Override
@@ -83,7 +93,16 @@ protected void visitComponent(BindingGraph graph) {
       }
 
       for (ResolvedBindings resolvedBindings : graph.resolvedBindings()) {
-        bindingNodes(resolvedBindings).forEach(node -> addBindingNode(node));
+        for (BindingNode node : bindingNodes(resolvedBindings)) {
+          addBindingNode(node);
+          if (node.binding().kind().equals(SUBCOMPONENT_BUILDER)
+              && node.componentPath().equals(currentComponent.componentPath())) {
+            network.addEdge(
+                node,
+                subcomponentNode(node.binding().key().type(), graph),
+                subcomponentBuilderBindingEdge(subcomponentDeclaringModules(resolvedBindings)));
+          }
+        }
       }
 
       super.visitComponent(graph);
@@ -188,5 +207,24 @@ private MissingBindingNode missingBindingNode(ResolvedBindings dependencies) {
               .toComponentPath(),
           dependencies.key());
     }
+
+    private ComponentNode subcomponentNode(TypeMirror subcomponentBuilderType, BindingGraph graph) {
+      TypeElement subcomponentBuilderElement = asTypeElement(subcomponentBuilderType);
+      ComponentDescriptor subcomponent =
+          graph.componentDescriptor().subcomponentsByBuilderType().get(subcomponentBuilderElement);
+      return ComponentNodeImpl.create(
+          componentTreePath().childPath(subcomponent.componentDefinitionType()).toComponentPath(),
+          subcomponent);
+    }
+
+    private ImmutableSet<TypeElement> subcomponentDeclaringModules(
+        ResolvedBindings resolvedBindings) {
+      return resolvedBindings
+          .subcomponentDeclarations()
+          .stream()
+          .map(SubcomponentDeclaration::contributingModule)
+          .flatMap(presentValues())
+          .collect(toImmutableSet());
+    }
   }
 }
diff --git a/java/dagger/internal/codegen/BindingGraphFactory.java b/java/dagger/internal/codegen/BindingGraphFactory.java
index 6647eb6c2..318f334bc 100644
--- a/java/dagger/internal/codegen/BindingGraphFactory.java
+++ b/java/dagger/internal/codegen/BindingGraphFactory.java
@@ -27,6 +27,7 @@
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.RequestKinds.getRequestKind;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
+import static dagger.model.BindingKind.DELEGATE;
 import static dagger.model.BindingKind.OPTIONAL;
 import static dagger.model.BindingKind.SUBCOMPONENT_BUILDER;
 import static java.util.function.Predicate.isEqual;
@@ -47,6 +48,7 @@
 import dagger.internal.codegen.ComponentDescriptor.BuilderRequirementMethod;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodKind;
+import dagger.model.ComponentPath;
 import dagger.model.DependencyRequest;
 import dagger.model.Key;
 import dagger.model.Scope;
@@ -79,22 +81,29 @@
   private final InjectBindingRegistry injectBindingRegistry;
   private final KeyFactory keyFactory;
   private final BindingFactory bindingFactory;
+  private final IncorrectlyInstalledBindsMethodsValidator incorrectlyInstalledBindsMethodsValidator;
+  private final CompilerOptions compilerOptions;
 
   @Inject
   BindingGraphFactory(
       DaggerElements elements,
       InjectBindingRegistry injectBindingRegistry,
       KeyFactory keyFactory,
-      BindingFactory bindingFactory) {
+      BindingFactory bindingFactory,
+      IncorrectlyInstalledBindsMethodsValidator incorrectlyInstalledBindsMethodsValidator,
+      CompilerOptions compilerOptions) {
     this.elements = elements;
     this.injectBindingRegistry = injectBindingRegistry;
     this.keyFactory = keyFactory;
     this.bindingFactory = bindingFactory;
+    this.incorrectlyInstalledBindsMethodsValidator = incorrectlyInstalledBindsMethodsValidator;
+    this.compilerOptions = compilerOptions;
   }
 
   /** Creates a binding graph for a root component. */
   BindingGraph create(ComponentDescriptor componentDescriptor) {
-    checkArgument(componentDescriptor.kind().isTopLevel());
+    checkArgument(
+        componentDescriptor.kind().isTopLevel() || compilerOptions.aheadOfTimeSubcomponents());
     return create(Optional.empty(), componentDescriptor);
   }
 
@@ -593,7 +602,9 @@ private boolean isResolvedInParent(Key requestKey, ContributionBinding binding)
       if (binding.scope().isPresent() && binding.scope().get().isReusable()) {
         for (Resolver requestResolver : getResolverLineage().reverse()) {
           // If a @Reusable binding was resolved in an ancestor, use that component.
-          if (requestResolver.resolvedContributionBindings.containsKey(binding.key())) {
+          ResolvedBindings resolvedBindings =
+              requestResolver.resolvedContributionBindings.get(binding.key());
+          if (resolvedBindings != null && resolvedBindings.bindings().contains(binding)) {
             return Optional.of(requestResolver);
           }
         }
@@ -603,6 +614,7 @@ private boolean isResolvedInParent(Key requestKey, ContributionBinding binding)
 
       for (Resolver requestResolver : getResolverLineage().reverse()) {
         if (requestResolver.explicitBindingsSet.contains(binding)
+            || resolverContainsDelegateDeclarationForBinding(requestResolver, binding)
             || requestResolver.subcomponentDeclarations.containsKey(binding.key())) {
           return Optional.of(requestResolver);
         }
@@ -621,6 +633,71 @@ private boolean isResolvedInParent(Key requestKey, ContributionBinding binding)
       return Optional.empty();
     }
 
+    /**
+     * Returns true if {@code binding} was installed in a module in this resolver's component. If
+     * {@link CompilerOptions#floatingBindsMethods()} is enabled, calls {@link
+     * #recordFloatingBindsMethod(Resolver, ContributionBinding)} and returns false.
+     */
+    private boolean resolverContainsDelegateDeclarationForBinding(
+        Resolver resolver, ContributionBinding binding) {
+      // TODO(ronshapiro): remove the flag once we feel enough time has passed, and return this
+      // value directly. At that point, this can be remove the resolver parameter and become a
+      // method invoked on a particular resolver
+      boolean resolverContainsDeclaration =
+          binding.kind().equals(DELEGATE)
+              && resolver
+                  .delegateDeclarations
+                  .get(binding.key())
+                  .stream()
+                  .anyMatch(
+                      declaration ->
+                          declaration.contributingModule().equals(binding.contributingModule())
+                              && declaration.bindingElement().equals(binding.bindingElement()));
+      if (resolverContainsDeclaration && compilerOptions.floatingBindsMethods()) {
+        recordFloatingBindsMethod(resolver, binding);
+        return false;
+      }
+      return resolverContainsDeclaration;
+    }
+
+    /**
+     * Records binds methods that are resolved in the wrong component due to b/79859714. These will
+     * be reported later on in {@link IncorrectlyInstalledBindsMethodsValidator}.
+     */
+    private void recordFloatingBindsMethod(Resolver idealResolver, ContributionBinding binding) {
+      Resolver actualResolver = this;
+      if (binding.scope().isPresent()) {
+        for (Resolver requestResolver : getResolverLineage().reverse()) {
+          if (requestResolver.componentDescriptor.scopes().contains(binding.scope().get())) {
+            actualResolver = requestResolver;
+            break;
+          }
+        }
+      }
+      if (actualResolver != idealResolver) {
+        incorrectlyInstalledBindsMethodsValidator.recordBinding(
+            componentPath(idealResolver), binding);
+      }
+    }
+
+    /**
+     * Constructs a {@link ComponentPath} from the root component of this resolver to a {@code
+     * destination}.
+     */
+    private ComponentPath componentPath(Resolver destination) {
+      ImmutableList.Builder<TypeElement> path = ImmutableList.builder();
+      for (Resolver resolver : getResolverLineage()) {
+        path.add(resolver.componentDescriptor.componentDefinitionType());
+        if (resolver == destination) {
+          return ComponentPath.create(path.build());
+        }
+      }
+      throw new AssertionError(
+          String.format(
+              "%s not found in %s",
+              destination.componentDescriptor.componentDefinitionType(), path.build()));
+    }
+
     /** Returns the resolver lineage from parent to child. */
     private ImmutableList<Resolver> getResolverLineage() {
       List<Resolver> resolverList = Lists.newArrayList();
@@ -806,8 +883,8 @@ void resolve(Key key) {
       cycleStack.push(key);
       try {
         ResolvedBindings bindings = lookUpBindings(key);
-        resolveDependencies(bindings);
         resolvedContributionBindings.put(key, bindings);
+        resolveDependencies(bindings);
       } finally {
         cycleStack.pop();
       }
diff --git a/java/dagger/internal/codegen/BindingMethodValidator.java b/java/dagger/internal/codegen/BindingMethodValidator.java
index 8854f13e5..32bc9f0fc 100644
--- a/java/dagger/internal/codegen/BindingMethodValidator.java
+++ b/java/dagger/internal/codegen/BindingMethodValidator.java
@@ -46,6 +46,7 @@
 import javax.inject.Qualifier;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.VariableElement;
 import javax.lang.model.type.TypeKind;
 import javax.lang.model.type.TypeMirror;
 import javax.lang.model.util.Types;
@@ -55,6 +56,7 @@
 
   private final DaggerElements elements;
   private final Types types;
+  private final DependencyRequestValidator dependencyRequestValidator;
   private final Class<? extends Annotation> methodAnnotation;
   private final ImmutableSet<? extends Class<? extends Annotation>> enclosingElementAnnotations;
   private final Abstractness abstractness;
@@ -72,6 +74,7 @@
   protected BindingMethodValidator(
       DaggerElements elements,
       Types types,
+      DependencyRequestValidator dependencyRequestValidator,
       Class<? extends Annotation> methodAnnotation,
       Class<? extends Annotation> enclosingElementAnnotation,
       Abstractness abstractness,
@@ -82,6 +85,7 @@ protected BindingMethodValidator(
         types,
         methodAnnotation,
         ImmutableSet.of(enclosingElementAnnotation),
+        dependencyRequestValidator,
         abstractness,
         exceptionSuperclass,
         allowsMultibindings);
@@ -99,6 +103,7 @@ protected BindingMethodValidator(
       Types types,
       Class<? extends Annotation> methodAnnotation,
       Iterable<? extends Class<? extends Annotation>> enclosingElementAnnotations,
+      DependencyRequestValidator dependencyRequestValidator,
       Abstractness abstractness,
       ExceptionSuperclass exceptionSuperclass,
       AllowsMultibindings allowsMultibindings) {
@@ -106,6 +111,7 @@ protected BindingMethodValidator(
     this.types = types;
     this.methodAnnotation = methodAnnotation;
     this.enclosingElementAnnotations = ImmutableSet.copyOf(enclosingElementAnnotations);
+    this.dependencyRequestValidator = dependencyRequestValidator;
     this.abstractness = abstractness;
     this.exceptionSuperclass = exceptionSuperclass;
     this.allowsMultibindings = allowsMultibindings;
@@ -153,6 +159,7 @@ protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder)
     checkMapKeys(builder);
     checkMultibindings(builder);
     checkScopes(builder);
+    checkParameters(builder);
   }
 
   /**
@@ -300,7 +307,10 @@ protected void checkQualifiers(ValidationReport.Builder<ExecutableElement> build
     ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(builder.getSubject());
     if (qualifiers.size() > 1) {
       for (AnnotationMirror qualifier : qualifiers) {
-        builder.addError("Cannot use more than one @Qualifier", builder.getSubject(), qualifier);
+        builder.addError(
+            bindingMethods("may not use more than one @Qualifier"),
+            builder.getSubject(),
+            qualifier);
       }
     }
   }
@@ -374,6 +384,22 @@ protected void checkScopes(ValidationReport.Builder<ExecutableElement> builder)
     }
   }
 
+  /** Adds errors for the method parameters. */
+  protected void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
+    for (VariableElement parameter : builder.getSubject().getParameters()) {
+      checkParameter(builder, parameter);
+    }
+  }
+
+  /**
+   * Adds errors for a method parameter. This implementation reports an error if the parameter has
+   * more than one qualifier.
+   */
+  protected void checkParameter(
+      ValidationReport.Builder<ExecutableElement> builder, VariableElement parameter) {
+    dependencyRequestValidator.validateDependencyRequest(builder, parameter, parameter.asType());
+  }
+
   /** Adds an error if the method returns a {@linkplain FrameworkTypes framework type}. */
   protected void checkFrameworkType(ValidationReport.Builder<ExecutableElement> builder) {
     if (FrameworkTypes.isFrameworkType(builder.getSubject().getReturnType())) {
diff --git a/java/dagger/internal/codegen/BindsMethodValidator.java b/java/dagger/internal/codegen/BindsMethodValidator.java
index 78909e84e..a9b15d135 100644
--- a/java/dagger/internal/codegen/BindsMethodValidator.java
+++ b/java/dagger/internal/codegen/BindsMethodValidator.java
@@ -16,7 +16,6 @@
 
 package dagger.internal.codegen;
 
-import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
 import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;
@@ -26,7 +25,6 @@
 import dagger.Binds;
 import dagger.Module;
 import dagger.producers.ProducerModule;
-import java.util.List;
 import javax.inject.Inject;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.VariableElement;
@@ -41,12 +39,14 @@
   private final BindsTypeChecker bindsTypeChecker;
 
   @Inject
-  BindsMethodValidator(DaggerElements elements, Types types) {
+  BindsMethodValidator(
+      DaggerElements elements, Types types, DependencyRequestValidator dependencyRequestValidator) {
     super(
         elements,
         types,
         Binds.class,
         ImmutableSet.of(Module.class, ProducerModule.class),
+        dependencyRequestValidator,
         MUST_BE_ABSTRACT,
         RUNTIME_EXCEPTION,
         ALLOWS_MULTIBINDINGS);
@@ -60,29 +60,36 @@ protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder)
     checkParameters(builder);
   }
 
-  private void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
+  @Override
+  protected void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
     ExecutableElement method = builder.getSubject();
-    List<? extends VariableElement> parameters = method.getParameters();
-    if (parameters.size() == 1) {
-      VariableElement parameter = getOnlyElement(parameters);
-      TypeMirror leftHandSide = boxIfNecessary(method.getReturnType());
-      TypeMirror rightHandSide = parameter.asType();
-      ContributionType contributionType = ContributionType.fromBindingMethod(method);
-      if (contributionType.equals(ContributionType.SET_VALUES) && !SetType.isSet(leftHandSide)) {
-        builder.addError(
-            "@Binds @ElementsIntoSet methods must return a Set and take a Set parameter");
-      }
-
-      if (!bindsTypeChecker.isAssignable(rightHandSide, leftHandSide, contributionType)) {
-        // TODO(ronshapiro): clarify this error message for @ElementsIntoSet cases, where the
-        // right-hand-side might not be assignable to the left-hand-side, but still compatible with
-        // Set.addAll(Collection<? extends E>)
-        builder.addError("@Binds methods' parameter type must be assignable to the return type");
-      }
+    if (method.getParameters().size() != 1) {
+      builder.addError(
+          bindingMethods(
+              "must have exactly one parameter, whose type is assignable to the return type"));
     } else {
+      super.checkParameters(builder);
+    }
+  }
+
+  @Override
+  protected void checkParameter(
+      ValidationReport.Builder<ExecutableElement> builder, VariableElement parameter) {
+    super.checkParameter(builder, parameter);
+    ExecutableElement method = builder.getSubject();
+    TypeMirror leftHandSide = boxIfNecessary(method.getReturnType());
+    TypeMirror rightHandSide = parameter.asType();
+    ContributionType contributionType = ContributionType.fromBindingMethod(method);
+    if (contributionType.equals(ContributionType.SET_VALUES) && !SetType.isSet(leftHandSide)) {
       builder.addError(
-          "@Binds methods must have exactly one parameter, "
-              + "whose type is assignable to the return type");
+          "@Binds @ElementsIntoSet methods must return a Set and take a Set parameter");
+    }
+
+    if (!bindsTypeChecker.isAssignable(rightHandSide, leftHandSide, contributionType)) {
+      // TODO(ronshapiro): clarify this error message for @ElementsIntoSet cases, where the
+      // right-hand-side might not be assignable to the left-hand-side, but still compatible with
+      // Set.addAll(Collection<? extends E>)
+      builder.addError("@Binds methods' parameter type must be assignable to the return type");
     }
   }
 
diff --git a/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java b/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
index dfb84ab69..c12dd78d7 100644
--- a/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
+++ b/java/dagger/internal/codegen/BindsOptionalOfMethodValidator.java
@@ -42,12 +42,14 @@
   private final Types types;
 
   @Inject
-  BindsOptionalOfMethodValidator(DaggerElements elements, Types types) {
+  BindsOptionalOfMethodValidator(
+      DaggerElements elements, Types types, DependencyRequestValidator dependencyRequestValidator) {
     super(
         elements,
         types,
         BindsOptionalOf.class,
         ImmutableSet.of(Module.class, ProducerModule.class),
+        dependencyRequestValidator,
         MUST_BE_ABSTRACT,
         NO_EXCEPTIONS,
         NO_MULTIBINDINGS);
@@ -74,7 +76,8 @@ protected void checkKeyType(
     }
   }
 
-  private void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
+  @Override
+  protected void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
     if (!builder.getSubject().getParameters().isEmpty()) {
       builder.addError("@BindsOptionalOf methods cannot have parameters");
     }
diff --git a/java/dagger/internal/codegen/CompilerOptions.java b/java/dagger/internal/codegen/CompilerOptions.java
index 685a26e47..f23234a04 100644
--- a/java/dagger/internal/codegen/CompilerOptions.java
+++ b/java/dagger/internal/codegen/CompilerOptions.java
@@ -79,6 +79,9 @@ boolean doCheckForNulls() {
 
   abstract boolean aheadOfTimeSubcomponents();
 
+  /** See b/79859714 */
+  abstract boolean floatingBindsMethods();
+
   static Builder builder() {
     return new AutoValue_CompilerOptions.Builder().headerCompilation(false);
   }
@@ -111,6 +114,8 @@ static CompilerOptions create(ProcessingEnvironment processingEnv, DaggerElement
                 .equals(FeatureStatus.ENABLED))
         .aheadOfTimeSubcomponents(
             aheadOfTimeSubcomponentsFeatureStatus(processingEnv).equals(FeatureStatus.ENABLED))
+        .floatingBindsMethods(
+            floatingBindsMethodsFeatureStatus(processingEnv).equals(FeatureStatus.ENABLED))
         .build();
   }
 
@@ -142,6 +147,8 @@ Builder warnIfInjectionFactoryNotGeneratedUpstream(
 
     Builder aheadOfTimeSubcomponents(boolean aheadOfTimeSubcomponents);
 
+    Builder floatingBindsMethods(boolean enabled);
+
     CompilerOptions build();
   }
 
@@ -180,6 +187,8 @@ Builder warnIfInjectionFactoryNotGeneratedUpstream(
 
   static final String AHEAD_OF_TIME_COMPONENTS_KEY = "dagger.experimentalAheadOfTimeSubcomponents";
 
+  static final String FLOATING_BINDS_METHODS_KEY = "dagger.floatingBindsMethods";
+
   static final ImmutableSet<String> SUPPORTED_OPTIONS =
       ImmutableSet.of(
           FAST_INIT,
@@ -192,7 +201,8 @@ Builder warnIfInjectionFactoryNotGeneratedUpstream(
           STATIC_MEMBER_VALIDATION_TYPE_KEY,
           WARN_IF_INJECTION_FACTORY_NOT_GENERATED_UPSTREAM_KEY,
           IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT,
-          AHEAD_OF_TIME_COMPONENTS_KEY);
+          AHEAD_OF_TIME_COMPONENTS_KEY,
+          FLOATING_BINDS_METHODS_KEY);
 
   private static boolean fastInitEnabled(ProcessingEnvironment processingEnv) {
     return valueOf(
@@ -286,6 +296,15 @@ private static FeatureStatus aheadOfTimeSubcomponentsFeatureStatus(
         EnumSet.allOf(FeatureStatus.class));
   }
 
+  private static FeatureStatus floatingBindsMethodsFeatureStatus(
+      ProcessingEnvironment processingEnv) {
+    return valueOf(
+        processingEnv,
+        FLOATING_BINDS_METHODS_KEY,
+        FeatureStatus.DISABLED,
+        EnumSet.allOf(FeatureStatus.class));
+  }
+
   private static <T extends Enum<T>> T valueOf(
       ProcessingEnvironment processingEnv, String key, T defaultValue, Set<T> validValues) {
     Map<String, String> options = processingEnv.getOptions();
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index e87e6f558..92c0233ec 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -84,7 +84,7 @@
         generatedComponentModel,
         subcomponentNames,
         componentRequirementFields,
-        new ReferenceReleasingManagerFields(graph, generatedComponentModel),
+        new ReferenceReleasingManagerFields(graph, generatedComponentModel, compilerOptions),
         new StaticSwitchingProviders(generatedComponentModel, types),
         optionalFactories,
         types,
@@ -249,13 +249,20 @@ MethodSpec getComponentMethod(ComponentMethodDescriptor componentMethod) {
   }
 
   private BindingExpression getBindingExpression(Key key, RequestKind requestKind) {
-    ResolvedBindings resolvedBindings = graph.resolvedBindings(requestKind, key);
-    if (resolvedBindings != null && !resolvedBindings.ownedBindings().isEmpty()) {
-      if (!expressions.contains(key, requestKind)) {
-        expressions.put(key, requestKind, createBindingExpression(resolvedBindings, requestKind));
-      }
+    if (expressions.contains(key, requestKind)) {
       return expressions.get(key, requestKind);
     }
+    Optional<BindingExpression> expression = Optional.empty();
+    if (resolvedInThisComponent(key, requestKind)) {
+      ResolvedBindings resolvedBindings = graph.resolvedBindings(requestKind, key);
+      expression = Optional.of(createBindingExpression(resolvedBindings, requestKind));
+    } else if (!resolvableBinding(key, requestKind) && generatedComponentModel.isAbstract()) {
+      expression = Optional.of(new MissingBindingExpression(key));
+    }
+    if (expression.isPresent()) {
+      expressions.put(key, requestKind, expression.get());
+      return expression.get();
+    }
     checkArgument(parent.isPresent(), "no expression found for %s-%s", key, requestKind);
     return parent.get().getBindingExpression(key, requestKind);
   }
@@ -263,6 +270,9 @@ private BindingExpression getBindingExpression(Key key, RequestKind requestKind)
   /** Creates a binding expression. */
   private BindingExpression createBindingExpression(
       ResolvedBindings resolvedBindings, RequestKind requestKind) {
+    if (generatedInstanceForAbstractSubcomponent(resolvedBindings)) {
+      return new GeneratedInstanceBindingExpression(resolvedBindings);
+    }
     switch (resolvedBindings.bindingType()) {
       case MEMBERS_INJECTION:
         checkArgument(requestKind.equals(RequestKind.MEMBERS_INJECTION));
@@ -279,6 +289,37 @@ private BindingExpression createBindingExpression(
     }
   }
 
+  /**
+   * Returns true if the binding exposes an instance of a generated type, but no concrete
+   * implementation of that type is available.
+   */
+  private boolean generatedInstanceForAbstractSubcomponent(ResolvedBindings resolvedBindings) {
+    return !resolvedBindings.contributionBindings().isEmpty()
+        && resolvedBindings.contributionBinding().requiresGeneratedInstance()
+        && generatedComponentModel.isAbstract();
+  }
+
+  /**
+   * Returns true if the binding can be resolved by the graph for this component or any parent
+   * component.
+   */
+  private boolean resolvableBinding(Key key, RequestKind requestKind) {
+    for (ComponentBindingExpressions expressions = this;
+        expressions != null;
+        expressions = expressions.parent.orElse(null)) {
+      if (expressions.resolvedInThisComponent(key, requestKind)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+  /** Returns true if the binding can be resolved by the graph for this component. */
+  private boolean resolvedInThisComponent(Key key, RequestKind requestKind) {
+    ResolvedBindings resolvedBindings = graph.resolvedBindings(requestKind, key);
+    return resolvedBindings != null && !resolvedBindings.ownedBindings().isEmpty();
+  }
+
   /**
    * Returns a binding expression that uses a {@link javax.inject.Provider} for provision bindings
    * or a {@link dagger.producers.Producer} for production bindings.
@@ -373,7 +414,8 @@ private FrameworkInstanceCreationExpression frameworkInstanceCreationExpression(
         return new SetFactoryCreationExpression(binding, generatedComponentModel, this, graph);
 
       case MULTIBOUND_MAP:
-        return new MapFactoryCreationExpression(binding, generatedComponentModel, this, graph);
+        return new MapFactoryCreationExpression(
+            binding, generatedComponentModel, this, graph, elements);
 
       case RELEASABLE_REFERENCE_MANAGER:
         return new ReleasableReferenceManagerProviderCreationExpression(
diff --git a/java/dagger/internal/codegen/ComponentBuilder.java b/java/dagger/internal/codegen/ComponentBuilder.java
index 4b89ebe4c..d4ad5fd5f 100644
--- a/java/dagger/internal/codegen/ComponentBuilder.java
+++ b/java/dagger/internal/codegen/ComponentBuilder.java
@@ -24,6 +24,7 @@
 import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PROTECTED;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 import static javax.lang.model.type.TypeKind.VOID;
@@ -76,14 +77,15 @@ ClassName name() {
   }
 
   static Optional<ComponentBuilder> create(
-      ClassName componentName,
+      GeneratedComponentModel generatedComponentModel,
       BindingGraph graph,
       SubcomponentNames subcomponentNames,
       Elements elements,
       Types types) {
     return hasBuilder(graph.componentDescriptor())
         ? Optional.of(
-            new Creator(componentName, graph, subcomponentNames, elements, types).create())
+            new Creator(generatedComponentModel, graph, subcomponentNames, elements, types)
+                .create())
         : Optional.empty();
   }
 
@@ -97,20 +99,21 @@ private static boolean hasBuilder(ComponentDescriptor component) {
             + "no-op. For more, see https://google.github.io/dagger/unused-modules.\n";
     private final BindingGraph graph;
     private final TypeSpec.Builder builder;
-    private final ClassName componentName;
+    private final GeneratedComponentModel generatedComponentModel;
     private final ClassName builderName;
+    private final SubcomponentNames subcomponentNames;
     private final Elements elements;
     private final Types types;
-    private ImmutableMap<ComponentRequirement, FieldSpec> builderFields;
 
     Creator(
-        ClassName componentName,
+        GeneratedComponentModel generatedComponentModel,
         BindingGraph graph,
         SubcomponentNames subcomponentNames,
         Elements elements,
         Types types) {
-      this.componentName = componentName;
-      if (graph.componentDescriptor().kind().isTopLevel()) {
+      this.generatedComponentModel = generatedComponentModel;
+      ClassName componentName = generatedComponentModel.name();
+      if (!generatedComponentModel.isNested()) {
         builderName = componentName.nestedClass("Builder");
         builder = classBuilder(builderName).addModifiers(STATIC);
       } else {
@@ -119,31 +122,62 @@ private static boolean hasBuilder(ComponentDescriptor component) {
         builder = classBuilder(builderName);
       }
       this.graph = graph;
+      this.subcomponentNames = subcomponentNames;
       this.elements = elements;
       this.types = types;
     }
 
     ComponentBuilder create() {
       if (builderSpec().isPresent()) {
-        builder.addModifiers(PRIVATE);
-        addSupertype(builder, builderSpec().get().builderDefinitionType());
+        if (generatedComponentModel.isAbstract()) {
+          builder.addModifiers(PROTECTED);
+        } else {
+          builder.addModifiers(PRIVATE);
+        }
+        setSupertype();
       } else {
         builder.addModifiers(PUBLIC).addMethod(constructorBuilder().addModifiers(PRIVATE).build());
       }
 
-      builderFields = builderFields(graph);
+      ImmutableMap<ComponentRequirement, FieldSpec> builderFields = builderFields(graph);
+
+      if (generatedComponentModel.isAbstract()) {
+        builder.addModifiers(ABSTRACT);
+      } else {
+        builder.addModifiers(FINAL);
+        builder.addMethod(buildMethod(builderFields)); // Can only instantiate concrete classes.
+      }
 
       builder
-          .addModifiers(FINAL)
           .addFields(builderFields.values())
-          .addMethod(buildMethod())
           // TODO(ronshapiro): this should be switched with buildMethod(), but that currently breaks
           // compile-testing tests that rely on the order of the methods
-          .addMethods(builderMethods());
+          .addMethods(builderMethods(builderFields));
 
       return new ComponentBuilder(builder.build(), builderName, builderFields);
     }
 
+    /** Set the superclass being extended or interface being implemented for this builder. */
+    private void setSupertype() {
+      if (generatedComponentModel.supermodel().isPresent()) {
+        // If there's a superclass, extend the Builder defined there.
+        GeneratedComponentModel subcomponentSupermodel = generatedComponentModel.supermodel().get();
+        if (subcomponentSupermodel.isNested()) {
+          // If the subcomponent superclass is nested we're overriding the builder that was
+          // defined as a peer of the superclass.
+          builder.superclass(
+              subcomponentSupermodel
+                  .name()
+                  .peerClass(subcomponentNames.get(graph.componentDescriptor()) + "Builder"));
+        } else {
+          // Otherwise we're extending the builder defined inside the subcomponent definition.
+          builder.superclass(subcomponentSupermodel.name().nestedClass("Builder"));
+        }
+      } else {
+        addSupertype(builder, builderSpec().get().builderDefinitionType());
+      }
+    }
+
     /**
      * Computes fields for each of the {@linkplain BindingGraph#componentRequirements component
      * requirements}. Regardless of builder spec, there is always one field per requirement.
@@ -160,7 +194,7 @@ ComponentBuilder create() {
       return builderFields.build();
     }
 
-    private MethodSpec buildMethod() {
+    private MethodSpec buildMethod(ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
       MethodSpec.Builder buildMethod;
       if (builderSpec().isPresent()) {
         ExecutableElement specBuildMethod = builderSpec().get().buildMethod();
@@ -195,7 +229,7 @@ private MethodSpec buildMethod() {
                 throw new AssertionError(requirement);
             }
           });
-      buildMethod.addStatement("return new $T(this)", componentName);
+      buildMethod.addStatement("return new $T(this)", generatedComponentModel.name());
       return buildMethod.build();
     }
 
@@ -203,7 +237,8 @@ private MethodSpec buildMethod() {
      * Computes the methods that set each of parameters on the builder. If the {@link BuilderSpec}
      * is present, it will tailor the methods to match the spec.
      */
-    private ImmutableSet<MethodSpec> builderMethods() {
+    private ImmutableSet<MethodSpec> builderMethods(
+        ImmutableMap<ComponentRequirement, FieldSpec> builderFields) {
       ImmutableSet<ComponentRequirement> componentRequirements = graph.componentRequirements();
       ImmutableSet.Builder<MethodSpec> methods = ImmutableSet.builder();
       if (builderSpec().isPresent()) {
diff --git a/java/dagger/internal/codegen/ComponentDescriptor.java b/java/dagger/internal/codegen/ComponentDescriptor.java
index dea137fc8..b2fea631a 100644
--- a/java/dagger/internal/codegen/ComponentDescriptor.java
+++ b/java/dagger/internal/codegen/ComponentDescriptor.java
@@ -442,30 +442,38 @@ Kind componentKind() {
     private final Types types;
     private final DependencyRequestFactory dependencyRequestFactory;
     private final ModuleDescriptor.Factory moduleDescriptorFactory;
+    private final CompilerOptions compilerOptions;
 
     @Inject
     Factory(
         DaggerElements elements,
         Types types,
         DependencyRequestFactory dependencyRequestFactory,
-        ModuleDescriptor.Factory moduleDescriptorFactory) {
+        ModuleDescriptor.Factory moduleDescriptorFactory,
+        CompilerOptions compilerOptions) {
       this.elements = elements;
       this.types = types;
       this.dependencyRequestFactory = dependencyRequestFactory;
       this.moduleDescriptorFactory = moduleDescriptorFactory;
+      this.compilerOptions = compilerOptions;
     }
 
     /**
      * Returns a component descriptor for a type annotated with either {@link Component @Component}
-     * or {@link ProductionComponent @ProductionComponent}.
+     * or {@link ProductionComponent @ProductionComponent}. This is also compatible with {@link
+     * Subcomponent @Subcomponent} or {@link ProductionSubcomponent @ProductionSubcomponent} when
+     * generating ahead-of-time subcomponents.
      */
-    ComponentDescriptor forComponent(TypeElement componentDefinitionType) {
-      Optional<Kind> kind = Kind.forAnnotatedElement(componentDefinitionType);
+    ComponentDescriptor forComponent(TypeElement componentType) {
+      Optional<Kind> kind = Kind.forAnnotatedElement(componentType);
       checkArgument(
-          kind.isPresent() && kind.get().isTopLevel(),
-          "%s must be annotated with @Component or @ProductionComponent",
-          componentDefinitionType);
-      return create(componentDefinitionType, kind.get(), Optional.empty());
+          kind.isPresent(), "%s must have a component or subcomponent annotation", componentType);
+      if (!compilerOptions.aheadOfTimeSubcomponents()) {
+        checkArgument(kind.get().isTopLevel(),
+            "%s must be annotated with @Component or @ProductionComponent.",
+            componentType);
+      }
+      return create(componentType, kind.get(), Optional.empty());
     }
 
     private ComponentDescriptor create(
diff --git a/java/dagger/internal/codegen/ComponentGenerator.java b/java/dagger/internal/codegen/ComponentGenerator.java
index 1b8086dfe..1dc14b933 100644
--- a/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/java/dagger/internal/codegen/ComponentGenerator.java
@@ -36,6 +36,7 @@
   private final DaggerElements elements;
   private final KeyFactory keyFactory;
   private final CompilerOptions compilerOptions;
+  private final BindingGraphFactory bindingGraphFactory;
 
   @Inject
   ComponentGenerator(
@@ -44,12 +45,14 @@
       SourceVersion sourceVersion,
       DaggerTypes types,
       KeyFactory keyFactory,
-      CompilerOptions compilerOptions) {
+      CompilerOptions compilerOptions,
+      BindingGraphFactory bindingGraphFactory) {
     super(filer, elements, sourceVersion);
     this.types = types;
     this.elements = elements;
     this.keyFactory = keyFactory;
     this.compilerOptions = compilerOptions;
+    this.bindingGraphFactory = bindingGraphFactory;
   }
 
   @Override
@@ -70,7 +73,14 @@ static ClassName componentName(TypeElement componentDefinitionType) {
   @Override
   Optional<TypeSpec.Builder> write(ClassName componentName, BindingGraph input) {
     return Optional.of(
-        ComponentWriter.writeComponent(
-            types, elements, keyFactory, compilerOptions, componentName, input));
+        ComponentModelBuilder.buildComponentModel(
+                types,
+                elements,
+                keyFactory,
+                compilerOptions,
+                componentName,
+                input,
+                bindingGraphFactory)
+            .generate());
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
index fbbd0718a..3e08b80a9 100644
--- a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
@@ -72,7 +72,7 @@
  * compilation succeeded.
  *
  * <p>The components emitted by this processing step include all of the API elements exposed by the
- * normal {@link ComponentWriter}. Method bodies are omitted as Turbine ignores them entirely.
+ * normal step. Method bodies are omitted as Turbine ignores them entirely.
  */
 final class ComponentHjarProcessingStep implements ProcessingStep {
   private final Elements elements;
@@ -188,7 +188,7 @@ ClassName nameGeneratedType(ComponentDescriptor input) {
       }
 
       DeclaredType componentType = MoreTypes.asDeclared(componentElement.asType());
-      // TODO(ronshapiro): unify with AbstractComponentWriter
+      // TODO(ronshapiro): unify with ComponentModelBuilder
       Set<MethodSignature> methodSignatures =
           Sets.newHashSetWithExpectedSize(componentDescriptor.componentMethods().size());
       componentDescriptor
diff --git a/java/dagger/internal/codegen/ComponentWriter.java b/java/dagger/internal/codegen/ComponentModelBuilder.java
similarity index 56%
rename from java/dagger/internal/codegen/ComponentWriter.java
rename to java/dagger/internal/codegen/ComponentModelBuilder.java
index dbeea6565..eaeb5b6a3 100644
--- a/java/dagger/internal/codegen/ComponentWriter.java
+++ b/java/dagger/internal/codegen/ComponentModelBuilder.java
@@ -32,6 +32,7 @@
 import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.SUBCOMPONENT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
+import static javax.lang.model.element.Modifier.PROTECTED;
 import static javax.lang.model.element.Modifier.PUBLIC;
 import static javax.lang.model.element.Modifier.STATIC;
 
@@ -51,22 +52,27 @@
 import java.util.Optional;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.type.DeclaredType;
-import javax.lang.model.util.Elements;
 
-/** Creates the implementation class for a component or subcomponent. */
-abstract class ComponentWriter {
-  static TypeSpec.Builder writeComponent(
+/** Builds the model for an implementation of a component or subcomponent. */
+abstract class ComponentModelBuilder {
+  static GeneratedComponentModel buildComponentModel(
       DaggerTypes types,
       DaggerElements elements,
       KeyFactory keyFactory,
       CompilerOptions compilerOptions,
       ClassName name,
-      BindingGraph graph) {
-    GeneratedComponentModel generatedComponentModel = GeneratedComponentModel.forComponent(name);
+      BindingGraph graph,
+      BindingGraphFactory bindingGraphFactory) {
+    GeneratedComponentModel generatedComponentModel;
+    if (graph.componentDescriptor().kind().isTopLevel()) {
+      generatedComponentModel = GeneratedComponentModel.forComponent(name);
+    } else {
+      generatedComponentModel = GeneratedComponentModel.forBaseSubcomponent(name);
+    }
     SubcomponentNames subcomponentNames = new SubcomponentNames(graph, keyFactory);
     OptionalFactories optionalFactories = new OptionalFactories(generatedComponentModel);
     Optional<ComponentBuilder> builder =
-        ComponentBuilder.create(name, graph, subcomponentNames, elements, types);
+        ComponentBuilder.create(generatedComponentModel, graph, subcomponentNames, elements, types);
     ComponentRequirementFields componentRequirementFields =
         new ComponentRequirementFields(graph, generatedComponentModel, builder);
     ComponentBindingExpressions bindingExpressions =
@@ -79,48 +85,134 @@
             types,
             elements,
             compilerOptions);
-    return new RootComponentWriter(
-            types,
-            elements,
-            graph,
-            generatedComponentModel,
-            subcomponentNames,
-            optionalFactories,
-            bindingExpressions,
-            componentRequirementFields,
-            builder)
-        .write();
+    if (generatedComponentModel.isAbstract()) {
+      checkState(
+          compilerOptions.aheadOfTimeSubcomponents(),
+          "Calling 'buildComponentModel()' on %s when not generating ahead-of-time subcomponents.",
+          graph.componentDescriptor().componentDefinitionType());
+      return new AbstractSubcomponentModelBuilder(
+              Optional.empty(), /* parent */
+              types,
+              elements,
+              keyFactory,
+              graph,
+              generatedComponentModel,
+              subcomponentNames,
+              optionalFactories,
+              bindingExpressions,
+              componentRequirementFields,
+              builder,
+              bindingGraphFactory,
+              compilerOptions)
+          .build();
+    } else {
+      return new RootComponentModelBuilder(
+              types,
+              elements,
+              keyFactory,
+              graph,
+              generatedComponentModel,
+              subcomponentNames,
+              optionalFactories,
+              bindingExpressions,
+              componentRequirementFields,
+              builder,
+              bindingGraphFactory,
+              compilerOptions)
+          .build();
+    }
   }
 
-  private static TypeSpec writeSubcomponent(ComponentWriter parent, BindingGraph childGraph) {
-    ClassName parentName = parent.generatedComponentModel.name();
+  private GeneratedComponentModel buildSubcomponentModel(BindingGraph childGraph) {
+    ClassName parentName = generatedComponentModel.name();
     ClassName childName =
-        parentName.nestedClass(
-            parent.subcomponentNames.get(childGraph.componentDescriptor()) + "Impl");
-    GeneratedComponentModel childGeneratedComponentModel =
-        GeneratedComponentModel.forSubcomponent(childName);
+        parentName.nestedClass(subcomponentNames.get(childGraph.componentDescriptor()) + "Impl");
+    GeneratedComponentModel childModel = GeneratedComponentModel.forSubcomponent(childName);
     Optional<ComponentBuilder> childBuilder =
-        ComponentBuilder.create(
-            childName, childGraph, parent.subcomponentNames, parent.elements, parent.types);
+        ComponentBuilder.create(childModel, childGraph, subcomponentNames, elements, types);
     ComponentRequirementFields childComponentRequirementFields =
-        parent.componentRequirementFields.forChildComponent(
-            childGraph, childGeneratedComponentModel, childBuilder);
+        componentRequirementFields.forChildComponent(childGraph, childModel, childBuilder);
     ComponentBindingExpressions childBindingExpressions =
-        parent.bindingExpressions.forChildComponent(
-            childGraph, childGeneratedComponentModel, childComponentRequirementFields);
-    return new SubcomponentWriter(
-            parent,
+        bindingExpressions.forChildComponent(
+            childGraph, childModel, childComponentRequirementFields);
+    return new SubComponentModelBuilder(
+            this,
             childGraph,
-            childGeneratedComponentModel,
+            childModel,
             childBindingExpressions,
             childComponentRequirementFields,
             childBuilder)
-        .write()
         .build();
   }
 
-  private final Elements elements;
+  private GeneratedComponentModel buildAbstractInnerSubcomponentModel(BindingGraph childGraph) {
+    ClassName childName =
+        generatedComponentModel
+            .name()
+            .nestedClass(subcomponentNames.get(childGraph.componentDescriptor()) + "Impl");
+    GeneratedComponentModel supermodel =
+        getSubcomponentSupermodel(childGraph.componentDescriptor());
+    GeneratedComponentModel childModel =
+        GeneratedComponentModel.forAbstractSubcomponent(childName, supermodel);
+    Optional<ComponentBuilder> childBuilder =
+        ComponentBuilder.create(childModel, childGraph, subcomponentNames, elements, types);
+    ComponentRequirementFields childComponentRequirementFields =
+        componentRequirementFields.forChildComponent(childGraph, childModel, childBuilder);
+    ComponentBindingExpressions childBindingExpressions =
+        bindingExpressions.forChildComponent(
+            childGraph, childModel, childComponentRequirementFields);
+    return new AbstractSubcomponentModelBuilder(
+            Optional.of(this),
+            types,
+            elements,
+            keyFactory,
+            childGraph,
+            childModel,
+            subcomponentNames,
+            optionalFactories,
+            childBindingExpressions,
+            childComponentRequirementFields,
+            childBuilder,
+            bindingGraphFactory,
+            compilerOptions)
+        .build();
+  }
+
+  private GeneratedComponentModel getSubcomponentSupermodel(ComponentDescriptor subcomponent) {
+    // If the current model is for a subcomponent that has a defined supermodel, that supermodel
+    // should contain a reference to a model for `subcomponent`
+    if (generatedComponentModel.supermodel().isPresent()) {
+      Optional<GeneratedComponentModel> supermodel =
+          generatedComponentModel.supermodel().get().subcomponentModel(subcomponent);
+      checkState(
+          supermodel.isPresent(),
+          "Attempting to generate an implementation of a subcomponent [%s] whose parent is a "
+              + "subcomponent [%s], but whose supermodel is not present on the parent's "
+              + "supermodel.",
+          subcomponent.componentDefinitionType(),
+          graph.componentType());
+      return supermodel.get();
+    }
+
+    // Otherwise, the enclosing component is top-level, so we must generate the supermodel for the
+    // subcomponent. We do so by building the model for the abstract base class for the
+    // subcomponent. This is done by truncating the binding graph at the subcomponent.
+    BindingGraph truncatedBindingGraph = bindingGraphFactory.create(subcomponent);
+    return buildComponentModel(
+        // TODO(ronshapiro): extract a factory class here so that we don't need to pass around
+        // types, elements, keyFactory, etc...
+        types,
+        elements,
+        keyFactory,
+        compilerOptions,
+        ComponentGenerator.componentName(truncatedBindingGraph.componentType()),
+        truncatedBindingGraph,
+        bindingGraphFactory);
+  }
+
+  private final DaggerElements elements;
   private final DaggerTypes types;
+  private final KeyFactory keyFactory;
   private final BindingGraph graph;
   private final SubcomponentNames subcomponentNames;
   private final ComponentBindingExpressions bindingExpressions;
@@ -128,20 +220,26 @@ private static TypeSpec writeSubcomponent(ComponentWriter parent, BindingGraph c
   private final GeneratedComponentModel generatedComponentModel;
   private final OptionalFactories optionalFactories;
   private final Optional<ComponentBuilder> builder;
+  private final BindingGraphFactory bindingGraphFactory;
+  private final CompilerOptions compilerOptions;
   private boolean done;
 
-  private ComponentWriter(
+  private ComponentModelBuilder(
       DaggerTypes types,
-      Elements elements,
+      DaggerElements elements,
+      KeyFactory keyFactory,
       BindingGraph graph,
       GeneratedComponentModel generatedComponentModel,
       SubcomponentNames subcomponentNames,
       OptionalFactories optionalFactories,
       ComponentBindingExpressions bindingExpressions,
       ComponentRequirementFields componentRequirementFields,
-      Optional<ComponentBuilder> builder) {
+      Optional<ComponentBuilder> builder,
+      BindingGraphFactory bindingGraphFactory,
+      CompilerOptions compilerOptions) {
     this.types = types;
     this.elements = elements;
+    this.keyFactory = keyFactory;
     this.graph = graph;
     this.subcomponentNames = subcomponentNames;
     this.generatedComponentModel = generatedComponentModel;
@@ -149,16 +247,21 @@ private ComponentWriter(
     this.bindingExpressions = bindingExpressions;
     this.componentRequirementFields = componentRequirementFields;
     this.builder = builder;
+    this.bindingGraphFactory = bindingGraphFactory;
+    this.compilerOptions = compilerOptions;
   }
 
   /**
-   * Constructs a {@link TypeSpec.Builder} that models the {@link BindingGraph} for this component.
-   * This is only intended to be called once (and will throw on successive invocations). If the
-   * component must be regenerated, use a new instance.
+   * Returns a {@link GeneratedComponentModel} for this component. This is only intended to be
+   * called once (and will throw on successive invocations). If the component must be regenerated,
+   * use a new instance.
    */
-  protected final TypeSpec.Builder write() {
-    checkState(!done, "ComponentWriter has already been generated.");
-    generatedComponentModel.addSupertype(graph.componentType());
+  protected final GeneratedComponentModel build() {
+    checkState(
+        !done,
+        "ComponentModelBuilder has already built the GeneratedComponentModel for [%s].",
+        generatedComponentModel.name());
+    setSupertype();
     builder.map(ComponentBuilder::typeSpec).ifPresent(this::addBuilderClass);
 
     getLocalAndInheritedMethods(
@@ -171,7 +274,16 @@ private ComponentWriter(
     addConstructor();
 
     done = true;
-    return generatedComponentModel.generate();
+    return generatedComponentModel;
+  }
+
+  /** Set the supertype for this generated class. */
+  private void setSupertype() {
+    if (generatedComponentModel.supermodel().isPresent()) {
+      generatedComponentModel.addSuperclass(generatedComponentModel.supermodel().get().name());
+    } else {
+      generatedComponentModel.addSupertype(graph.componentType());
+    }
   }
 
   /**
@@ -183,7 +295,7 @@ private ComponentWriter(
   /** Adds component factory methods. */
   protected abstract void addFactoryMethods();
 
-  private void addInterfaceMethods() {
+  protected void addInterfaceMethods() {
     /* Each component method may have been declared by several supertypes. We want to implement only
      * one method for each distinct signature.*/
     ImmutableListMultimap<MethodSignature, ComponentMethodDescriptor> componentMethodsBySignature =
@@ -203,7 +315,11 @@ private MethodSignature getMethodSignature(ComponentMethodDescriptor method) {
 
   private void addSubcomponents() {
     for (BindingGraph subgraph : graph.subgraphs()) {
-      generatedComponentModel.addType(SUBCOMPONENT, writeSubcomponent(this, subgraph));
+      generatedComponentModel.addSubcomponent(
+          subgraph.componentDescriptor(),
+          generatedComponentModel.isAbstract()
+              ? buildAbstractInnerSubcomponentModel(subgraph)
+              : buildSubcomponentModel(subgraph));
     }
   }
 
@@ -216,7 +332,19 @@ private void addConstructor() {
 
     ImmutableList<ParameterSpec> constructorParameters = constructorParameters();
     MethodSpec.Builder constructor =
-        constructorBuilder().addModifiers(PRIVATE).addParameters(constructorParameters);
+        constructorBuilder()
+            .addModifiers(generatedComponentModel.isAbstract() ? PROTECTED : PRIVATE)
+            .addParameters(constructorParameters);
+
+    if (generatedComponentModel.supermodel().isPresent()) {
+      constructor.addStatement(
+          CodeBlock.of(
+              "super($L)",
+              constructorParameters
+                  .stream()
+                  .map(param -> CodeBlock.of("$N", param))
+                  .collect(toParametersCodeBlock())));
+    }
 
     ImmutableList<ParameterSpec> initializeParameters = initializeParameters();
     CodeBlock initializeParametersCodeBlock =
@@ -258,36 +386,42 @@ private void addConstructor() {
       return ImmutableList.of(ParameterSpec.builder(builder.get().name(), "builder").build());
     } else if (graph.factoryMethod().isPresent()) {
       return getFactoryMethodParameterSpecs(graph);
+    } else if (generatedComponentModel.isAbstract() && !generatedComponentModel.isNested()) {
+      return ImmutableList.of();
     } else {
       throw new AssertionError(
           "Expected either a component builder or factory method but found neither.");
     }
   }
 
-  /**
-   * Creates the implementation class for the root component.
-   */
-  private static final class RootComponentWriter extends ComponentWriter {
-    RootComponentWriter(
+  /** Builds the model for the root component. */
+  private static final class RootComponentModelBuilder extends ComponentModelBuilder {
+    RootComponentModelBuilder(
         DaggerTypes types,
-        Elements elements,
+        DaggerElements elements,
+        KeyFactory keyFactory,
         BindingGraph graph,
         GeneratedComponentModel generatedComponentModel,
         SubcomponentNames subcomponentNames,
         OptionalFactories optionalFactories,
         ComponentBindingExpressions bindingExpressions,
         ComponentRequirementFields componentRequirementFields,
-        Optional<ComponentBuilder> builder) {
+        Optional<ComponentBuilder> builder,
+        BindingGraphFactory bindingGraphFactory,
+        CompilerOptions compilerOptions) {
       super(
           types,
           elements,
+          keyFactory,
           graph,
           generatedComponentModel,
           subcomponentNames,
           optionalFactories,
           bindingExpressions,
           componentRequirementFields,
-          builder);
+          builder,
+          bindingGraphFactory,
+          compilerOptions);
     }
 
     @Override
@@ -335,13 +469,14 @@ private boolean canInstantiateAllRequirements() {
   }
 
   /**
-   * Creates the nested implementation class for a subcomponent.
+   * Builds the model for a nested subcomponent. This is used when ahead-of-time components are not
+   * enabled (current default mode).
    */
-  private static final class SubcomponentWriter extends ComponentWriter {
-    private final ComponentWriter parent;
+  private static final class SubComponentModelBuilder extends ComponentModelBuilder {
+    private final ComponentModelBuilder parent;
 
-    SubcomponentWriter(
-        ComponentWriter parent,
+    SubComponentModelBuilder(
+        ComponentModelBuilder parent,
         BindingGraph graph,
         GeneratedComponentModel generatedComponentModel,
         ComponentBindingExpressions bindingExpressions,
@@ -350,13 +485,16 @@ private boolean canInstantiateAllRequirements() {
       super(
           parent.types,
           parent.elements,
+          parent.keyFactory,
           graph,
           generatedComponentModel,
           parent.subcomponentNames,
           parent.optionalFactories,
           bindingExpressions,
           componentRequirementFields,
-          builder);
+          builder,
+          parent.bindingGraphFactory,
+          parent.compilerOptions);
       this.parent = parent;
     }
 
@@ -391,6 +529,67 @@ private DeclaredType parentType() {
     }
   }
 
+  /** Builds the model for abstract implementations of a subcomponent. */
+  private static final class AbstractSubcomponentModelBuilder extends ComponentModelBuilder {
+    private final Optional<ComponentModelBuilder> parent;
+    private final GeneratedComponentModel generatedComponentModel;
+
+    AbstractSubcomponentModelBuilder(
+        Optional<ComponentModelBuilder> parent,
+        DaggerTypes types,
+        DaggerElements elements,
+        KeyFactory keyFactory,
+        BindingGraph graph,
+        GeneratedComponentModel generatedComponentModel,
+        SubcomponentNames subcomponentNames,
+        OptionalFactories optionalFactories,
+        ComponentBindingExpressions bindingExpressions,
+        ComponentRequirementFields componentRequirementFields,
+        Optional<ComponentBuilder> builder,
+        BindingGraphFactory bindingGraphFactory,
+        CompilerOptions compilerOptions) {
+      super(
+          types,
+          elements,
+          keyFactory,
+          graph,
+          generatedComponentModel,
+          subcomponentNames,
+          optionalFactories,
+          bindingExpressions,
+          componentRequirementFields,
+          builder,
+          bindingGraphFactory,
+          compilerOptions);
+      this.parent = parent;
+      this.generatedComponentModel = generatedComponentModel;
+    }
+
+    @Override
+    protected void addBuilderClass(TypeSpec builder) {
+      if (parent.isPresent()) {
+        // If an inner implementation of a subcomponent the builder is a peer class.
+        parent.get().generatedComponentModel.addType(SUBCOMPONENT, builder);
+      } else {
+        generatedComponentModel.addType(SUBCOMPONENT, builder);
+      }
+    }
+
+    @Override
+    protected void addFactoryMethods() {
+      // Only construct instances of subcomponents that have concrete implementations.
+    }
+
+    @Override
+    protected void addInterfaceMethods() {
+      if (!generatedComponentModel.supermodel().isPresent()) {
+        super.addInterfaceMethods();
+      }
+      // TODO(b/72748365): Contribute to modifiable portions of subcomponent implementation for
+      // inner abstract subcomponents.
+    }
+  }
+
   /** Returns the list of {@link ParameterSpec}s for the corresponding graph's factory method. */
   private static ImmutableList<ParameterSpec> getFactoryMethodParameterSpecs(BindingGraph graph) {
     return graph
diff --git a/java/dagger/internal/codegen/ComponentProcessingStep.java b/java/dagger/internal/codegen/ComponentProcessingStep.java
index 0b5ba2699..62881c3d3 100644
--- a/java/dagger/internal/codegen/ComponentProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentProcessingStep.java
@@ -53,6 +53,7 @@
   private final BindingGraphConverter bindingGraphConverter;
   private final BindingGraphPlugins validationPlugins;
   private final BindingGraphPlugins spiPlugins;
+  private final CompilerOptions compilerOptions;
 
   @Inject
   ComponentProcessingStep(
@@ -65,7 +66,8 @@
       ComponentGenerator componentGenerator,
       BindingGraphConverter bindingGraphConverter,
       @Validation BindingGraphPlugins validationPlugins,
-      BindingGraphPlugins spiPlugins) {
+      BindingGraphPlugins spiPlugins,
+      CompilerOptions compilerOptions) {
     this.messager = messager;
     this.componentValidator = componentValidator;
     this.builderValidator = builderValidator;
@@ -76,6 +78,7 @@
     this.bindingGraphConverter = bindingGraphConverter;
     this.validationPlugins = validationPlugins;
     this.spiPlugins = spiPlugins;
+    this.compilerOptions = compilerOptions;
   }
 
   @Override
@@ -146,6 +149,25 @@
         rejectedElements.add(componentTypeElement);
       }
     }
+
+    if (compilerOptions.aheadOfTimeSubcomponents()) {
+      for (TypeElement subcomponentTypeElement : typesIn(subcomponentElements)) {
+        if (!subcomponentIsClean(
+            subcomponentTypeElement, reportsBySubcomponent, builderReportsBySubcomponent)) {
+          continue;
+        }
+        try {
+          ComponentDescriptor componentDescriptor =
+              componentDescriptorFactory.forComponent(subcomponentTypeElement);
+          BindingGraph bindingGraph = bindingGraphFactory.create(componentDescriptor);
+          // TODO(b/72748365): Do subgraph validation.
+          generateComponent(bindingGraph);
+        } catch (TypeNotPresentException e) {
+          rejectedElements.add(subcomponentTypeElement);
+        }
+      }
+    }
+
     return rejectedElements.build();
   }
 
@@ -212,15 +234,27 @@ private boolean isClean(
       return false;
     }
     for (Element element : report.referencedSubcomponents()) {
-      ValidationReport<?> subcomponentBuilderReport = builderReportsBySubcomponent.get(element);
-      if (subcomponentBuilderReport != null && !subcomponentBuilderReport.isClean()) {
-        return false;
-      }
-      ValidationReport<?> subcomponentReport = reportsBySubcomponent.get(element);
-      if (subcomponentReport != null && !subcomponentReport.isClean()) {
+      if (!subcomponentIsClean(element, reportsBySubcomponent, builderReportsBySubcomponent)) {
         return false;
       }
     }
     return true;
   }
+
+  /** Returns true if the reports associated with the subcomponent are clean. */
+  private boolean subcomponentIsClean(
+      Element subcomponentElement,
+      Map<Element, ValidationReport<TypeElement>> reportsBySubcomponent,
+      Map<Element, ValidationReport<TypeElement>> builderReportsBySubcomponent) {
+    ValidationReport<?> subcomponentBuilderReport =
+        builderReportsBySubcomponent.get(subcomponentElement);
+    if (subcomponentBuilderReport != null && !subcomponentBuilderReport.isClean()) {
+      return false;
+    }
+    ValidationReport<?> subcomponentReport = reportsBySubcomponent.get(subcomponentElement);
+    if (subcomponentReport != null && !subcomponentReport.isClean()) {
+      return false;
+    }
+    return true;
+  }
 }
diff --git a/java/dagger/internal/codegen/ComponentProcessor.java b/java/dagger/internal/codegen/ComponentProcessor.java
index a77509fc5..bd3a9129b 100644
--- a/java/dagger/internal/codegen/ComponentProcessor.java
+++ b/java/dagger/internal/codegen/ComponentProcessor.java
@@ -116,6 +116,7 @@ public SourceVersion getSupportedSourceVersion() {
         BindingGraphPluginsModule.class,
         BindingGraphValidationModule.class,
         BindingMethodValidatorsModule.class,
+        IncorrectlyInstalledBindsMethodsValidator.Module.class,
         ProcessingStepsModule.class,
       })
   interface ProcessorComponent {
diff --git a/java/dagger/internal/codegen/ComponentRequirementFields.java b/java/dagger/internal/codegen/ComponentRequirementFields.java
index f38fbdaec..62d6aa6fc 100644
--- a/java/dagger/internal/codegen/ComponentRequirementFields.java
+++ b/java/dagger/internal/codegen/ComponentRequirementFields.java
@@ -113,7 +113,8 @@ private ComponentRequirementField create(ComponentRequirement requirement) {
     if (componentBuilder.isPresent()) {
       FieldSpec builderField = componentBuilder.get().builderFields().get(requirement);
       return new BuilderField(requirement, generatedComponentModel, builderField);
-    } else if (graph.factoryMethodParameters().containsKey(requirement)) {
+    } else if (graph.factoryMethod().isPresent()
+        && graph.factoryMethodParameters().containsKey(requirement)) {
       ParameterSpec factoryParameter =
           ParameterSpec.get(graph.factoryMethodParameters().get(requirement));
       return new ComponentParameterField(requirement, generatedComponentModel, factoryParameter);
diff --git a/java/dagger/internal/codegen/ComponentTreeTraverser.java b/java/dagger/internal/codegen/ComponentTreeTraverser.java
index 778c651e9..f79c1d0cb 100644
--- a/java/dagger/internal/codegen/ComponentTreeTraverser.java
+++ b/java/dagger/internal/codegen/ComponentTreeTraverser.java
@@ -74,9 +74,10 @@
   private final Deque<BindingGraph> bindingGraphPath = new ArrayDeque<>();
 
   /** Constructs a traverser for a root (component, not subcomponent) binding graph. */
-  public ComponentTreeTraverser(BindingGraph rootGraph) {
+  public ComponentTreeTraverser(BindingGraph rootGraph, CompilerOptions compilerOptions) {
     checkArgument(
-        rootGraph.componentDescriptor().kind().isTopLevel(),
+        rootGraph.componentDescriptor().kind().isTopLevel()
+            || compilerOptions.aheadOfTimeSubcomponents(),
         "only top-level graphs can be traversed, not %s",
         rootGraph.componentDescriptor().componentDefinitionType().getQualifiedName());
     bindingGraphPath.add(rootGraph);
diff --git a/java/dagger/internal/codegen/ComponentValidator.java b/java/dagger/internal/codegen/ComponentValidator.java
index 671f0857a..3ed0ae801 100644
--- a/java/dagger/internal/codegen/ComponentValidator.java
+++ b/java/dagger/internal/codegen/ComponentValidator.java
@@ -82,6 +82,7 @@
   private final Types types;
   private final ModuleValidator moduleValidator;
   private final BuilderValidator builderValidator;
+  private final DependencyRequestValidator dependencyRequestValidator;
   private final MethodSignatureFormatter methodSignatureFormatter;
   private final DependencyRequestFactory dependencyRequestFactory;
 
@@ -91,12 +92,14 @@
       Types types,
       ModuleValidator moduleValidator,
       BuilderValidator builderValidator,
+      DependencyRequestValidator dependencyRequestValidator,
       MethodSignatureFormatter methodSignatureFormatter,
       DependencyRequestFactory dependencyRequestFactory) {
     this.elements = elements;
     this.types = types;
     this.moduleValidator = moduleValidator;
     this.builderValidator = builderValidator;
+    this.dependencyRequestValidator = dependencyRequestValidator;
     this.methodSignatureFormatter = methodSignatureFormatter;
     this.dependencyRequestFactory = dependencyRequestFactory;
   }
@@ -199,7 +202,8 @@ public ComponentValidationReport validate(
                 switch (parameters.size()) {
                   case 0:
                     // no parameters means that it is a provision method
-                    // basically, there are no restrictions here.  \o/
+                    dependencyRequestValidator.validateDependencyRequest(
+                        report, method, returnType);
                     break;
                   case 1:
                     // one parameter means that it's a members injection method
diff --git a/java/dagger/internal/codegen/ContributionBinding.java b/java/dagger/internal/codegen/ContributionBinding.java
index 9b7685103..c58a980b3 100644
--- a/java/dagger/internal/codegen/ContributionBinding.java
+++ b/java/dagger/internal/codegen/ContributionBinding.java
@@ -164,6 +164,17 @@ final boolean isSyntheticMultibinding() {
     }
   }
 
+  /** Whether the bound type has a generated implementation. */
+  final boolean requiresGeneratedInstance() {
+    switch (kind()) {
+      case COMPONENT:
+      case SUBCOMPONENT_BUILDER:
+        return true;
+      default:
+        return false;
+    }
+  }
+
   /**
    * Returns {@link BindingKind#MULTIBOUND_SET} or {@link
    * BindingKind#MULTIBOUND_MAP} if the key is a set or map.
diff --git a/java/dagger/internal/codegen/DaggerElements.java b/java/dagger/internal/codegen/DaggerElements.java
index 92bf2a3ca..e9e505213 100644
--- a/java/dagger/internal/codegen/DaggerElements.java
+++ b/java/dagger/internal/codegen/DaggerElements.java
@@ -23,6 +23,7 @@
 import static com.google.common.collect.Lists.asList;
 import static dagger.internal.codegen.DaggerStreams.toImmutableSet;
 import static dagger.internal.codegen.Formatter.formatArgumentInList;
+import static java.util.Comparator.comparing;
 import static java.util.stream.Collectors.joining;
 import static java.util.stream.Collectors.toSet;
 import static javax.lang.model.element.Modifier.ABSTRACT;
@@ -38,6 +39,7 @@
 import java.io.Writer;
 import java.lang.annotation.Annotation;
 import java.util.Collection;
+import java.util.Comparator;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
@@ -184,6 +186,13 @@ public TypeElement visitType(TypeElement type, Void p) {
         }
       };
 
+  /**
+   * Compares elements according to their declaration order among siblings. Only valid to compare
+   * elements enclosed by the same parent.
+   */
+  static final Comparator<Element> DECLARATION_ORDER =
+      comparing(element -> element.getEnclosingElement().getEnclosedElements().indexOf(element));
+
   /**
    * Returns {@code true} iff the given element has an {@link AnnotationMirror} whose
    * {@linkplain AnnotationMirror#getAnnotationType() annotation type} has the same canonical name
diff --git a/java/dagger/internal/codegen/DaggerKythePlugin.java b/java/dagger/internal/codegen/DaggerKythePlugin.java
index 98d210cc6..26e0a8ce4 100644
--- a/java/dagger/internal/codegen/DaggerKythePlugin.java
+++ b/java/dagger/internal/codegen/DaggerKythePlugin.java
@@ -155,6 +155,7 @@ public void run(
       DaggerDaggerKythePlugin_PluginComponent.builder()
           .types(JavacTypes.instance(javaContext))
           .elements(JavacElements.instance(javaContext))
+          .compilerOptions(KytheBindingGraphFactory.createCompilerOptions())
           .build()
           .inject(this);
     }
@@ -168,8 +169,15 @@ public void run(
 
     @Component.Builder
     interface Builder {
-      @BindsInstance Builder types(Types types);
-      @BindsInstance Builder elements(Elements elements);
+      @BindsInstance
+      Builder types(Types types);
+
+      @BindsInstance
+      Builder elements(Elements elements);
+
+      @BindsInstance
+      Builder compilerOptions(CompilerOptions compilerOptions);
+
       PluginComponent build();
     }
   }
diff --git a/java/dagger/internal/codegen/DaggerStreams.java b/java/dagger/internal/codegen/DaggerStreams.java
index 83a4e30d1..ff4c44698 100644
--- a/java/dagger/internal/codegen/DaggerStreams.java
+++ b/java/dagger/internal/codegen/DaggerStreams.java
@@ -25,6 +25,7 @@
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.collect.Maps;
 import java.util.Map;
+import java.util.Optional;
 import java.util.function.Function;
 import java.util.stream.Collector;
 import java.util.stream.Collectors;
@@ -98,5 +99,19 @@
     return f -> to.isInstance(f) ? Stream.of(to.cast(f)) : Stream.empty();
   }
 
+  /**
+   * A function that you can use to extract the present values from a stream of {@link Optional}s.
+   *
+   * <pre>{@code
+   * Set<Foo> foos =
+   *     optionalFoos()
+   *         .flatMap(DaggerStreams.presentValues())
+   *         .collect(toSet());
+   * }</pre>
+   */
+  public static <T> Function<Optional<T>, Stream<T>> presentValues() {
+    return optional -> optional.map(Stream::of).orElse(Stream.empty());
+  }
+
   private DaggerStreams() {}
 }
diff --git a/java/dagger/internal/codegen/DependencyRequestValidator.java b/java/dagger/internal/codegen/DependencyRequestValidator.java
new file mode 100644
index 000000000..eb9642215
--- /dev/null
+++ b/java/dagger/internal/codegen/DependencyRequestValidator.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
+import static dagger.internal.codegen.RequestKinds.extractKeyType;
+import static dagger.internal.codegen.RequestKinds.getRequestKind;
+import static javax.lang.model.type.TypeKind.WILDCARD;
+
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableSet;
+import javax.inject.Inject;
+import javax.lang.model.element.AnnotationMirror;
+import javax.lang.model.element.Element;
+import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+
+/** Validation for dependency requests. */
+final class DependencyRequestValidator {
+  @Inject
+  DependencyRequestValidator() {}
+
+  /**
+   * Adds an error if the given dependency request has more than one qualifier annotation or is a
+   * non-instance request with a wildcard type.
+   */
+  void validateDependencyRequest(
+      ValidationReport.Builder<?> report, Element requestElement, TypeMirror requestType) {
+    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(requestElement);
+    if (qualifiers.size() > 1) {
+      for (AnnotationMirror qualifier : qualifiers) {
+        report.addError(
+            "A single dependency request may not use more than one @Qualifier",
+            requestElement,
+            qualifier);
+      }
+    }
+
+    TypeMirror keyType = extractKeyType(getRequestKind(requestType), requestType);
+    if (keyType.getKind().equals(WILDCARD)) {
+      // TODO(ronshapiro): Explore creating this message using RequestKinds.
+      report.addError(
+          "Dagger does not support injecting Provider<T>, Lazy<T>, Producer<T>, "
+              + "or Produced<T> when T is a wildcard type such as "
+              + keyType,
+          requestElement);
+    }
+  }
+
+  /**
+   * Adds an error if the given dependency request is for a {@link dagger.producers.Producer} or
+   * {@link dagger.producers.Produced}.
+   *
+   * <p>Only call this when processing a provision binding.
+   */
+  // TODO(dpb): Should we disallow Producer entry points in non-production components?
+  void checkNotProducer(ValidationReport.Builder<?> report, VariableElement requestElement) {
+    TypeMirror requestType = requestElement.asType();
+    if (FrameworkTypes.isProducerType(requestType)) {
+      report.addError(
+          String.format(
+              "%s may only be injected in @Produces methods",
+              MoreTypes.asTypeElement(requestType).getSimpleName()),
+          requestElement);
+    }
+  }
+}
diff --git a/java/dagger/internal/codegen/DiagnosticReporterFactory.java b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
index 1b295b7e4..0695d81c2 100644
--- a/java/dagger/internal/codegen/DiagnosticReporterFactory.java
+++ b/java/dagger/internal/codegen/DiagnosticReporterFactory.java
@@ -17,6 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Verify.verify;
 import static com.google.common.collect.Lists.asList;
 import static dagger.internal.codegen.DaggerElements.elementEncloses;
 import static dagger.internal.codegen.DaggerElements.elementToString;
@@ -197,16 +198,23 @@ private void reportAtEntryPointsWithDependencyTrace(
     private CharSequence dependencyTrace(DependencyEdge entryPoint, BindingNode bindingNode) {
       checkArgument(entryPoint.isEntryPoint());
       Node entryPointBinding = graph.incidentNodes(entryPoint).target();
-      ImmutableList<Node> shortestPath =
+      ImmutableList<Node> shortestBindingPath =
           shortestPath(
               node -> Sets.filter(graph.successors(node), BindingNode.class::isInstance),
               entryPointBinding,
               bindingNode);
+      verify(
+          !shortestBindingPath.isEmpty(),
+          "no dependency path from %s to %s in %s",
+          entryPoint,
+          bindingNode,
+          graph);
 
-      StringBuilder trace = new StringBuilder(shortestPath.size() * 100 /* a guess heuristic */);
-      for (int i = shortestPath.size() - 1; i > 0; i--) {
+      StringBuilder trace =
+          new StringBuilder(shortestBindingPath.size() * 100 /* a guess heuristic */);
+      for (int i = shortestBindingPath.size() - 1; i > 0; i--) {
         Set<Edge> dependenciesBetween =
-            graph.edgesConnecting(shortestPath.get(i - 1), shortestPath.get(i));
+            graph.edgesConnecting(shortestBindingPath.get(i - 1), shortestBindingPath.get(i));
         DependencyRequest dependencyRequest =
             // If a binding requests a key more than once, any of them should be fine to get to
             // the shortest path
diff --git a/java/dagger/internal/codegen/ErrorMessages.java b/java/dagger/internal/codegen/ErrorMessages.java
index 95d66951b..909b4f5ab 100644
--- a/java/dagger/internal/codegen/ErrorMessages.java
+++ b/java/dagger/internal/codegen/ErrorMessages.java
@@ -16,7 +16,6 @@
 
 package dagger.internal.codegen;
 
-import com.google.auto.common.MoreTypes;
 import com.google.common.base.Joiner;
 import java.util.Set;
 import javax.lang.model.element.ExecutableElement;
@@ -28,12 +27,6 @@
  */
 final class ErrorMessages {
 
-  static String provisionMayNotDependOnProducerType(TypeMirror type) {
-    return String.format(
-        "%s may only be injected in @Produces methods",
-        MoreTypes.asTypeElement(type).getSimpleName());
-  }
-
   static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {
     switch(kind) {
       case COMPONENT:
diff --git a/java/dagger/internal/codegen/GeneratedComponentModel.java b/java/dagger/internal/codegen/GeneratedComponentModel.java
index 636b5a181..33f92aca1 100644
--- a/java/dagger/internal/codegen/GeneratedComponentModel.java
+++ b/java/dagger/internal/codegen/GeneratedComponentModel.java
@@ -16,8 +16,10 @@
 
 package dagger.internal.codegen;
 
+import static com.google.common.base.Preconditions.checkState;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
+import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PUBLIC;
@@ -33,9 +35,14 @@
 import com.squareup.javapoet.TypeSpec;
 import dagger.internal.ReferenceReleasingProviderManager;
 import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
+import java.util.Optional;
 import javax.lang.model.element.Modifier;
 import javax.lang.model.element.Name;
+import javax.lang.model.element.NestingKind;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 
@@ -107,6 +114,10 @@
   }
 
   private final ClassName name;
+  private final NestingKind nestingKind;
+  private final boolean isAbstract;
+  private final Optional<GeneratedComponentModel> supermodel;
+  private final Map<TypeElement, GeneratedComponentModel> subcomponentModels = new HashMap<>();
   private final TypeSpec.Builder component;
   private final UniqueNameSet componentFieldNames = new UniqueNameSet();
   private final UniqueNameSet componentMethodNames = new UniqueNameSet();
@@ -119,17 +130,50 @@
       MultimapBuilder.enumKeys(TypeSpecKind.class).arrayListValues().build();
   private final List<Supplier<TypeSpec>> switchingProviderSupplier = new ArrayList<>();
 
-  private GeneratedComponentModel(ClassName name, Modifier... modifiers) {
+  private GeneratedComponentModel(
+      ClassName name,
+      NestingKind nestingKind,
+      Optional<GeneratedComponentModel> supermodel,
+      Modifier... modifiers) {
     this.name = name;
+    this.nestingKind = nestingKind;
+    this.isAbstract = Arrays.asList(modifiers).contains(ABSTRACT);
+    this.supermodel = supermodel;
     this.component = classBuilder(name).addModifiers(modifiers);
   }
 
+  /** Create a model for a root component. */
   static GeneratedComponentModel forComponent(ClassName name) {
-    return new GeneratedComponentModel(name, PUBLIC, FINAL);
+    return new GeneratedComponentModel(
+        name, NestingKind.TOP_LEVEL, Optional.empty(), /* supermodel */ PUBLIC, FINAL);
   }
 
+  /**
+   * Create a model for a subcomponent. This is for concrete subcomponents implementations when not
+   * generating ahead-of-time subcomponents.
+   */
   static GeneratedComponentModel forSubcomponent(ClassName name) {
-    return new GeneratedComponentModel(name, PRIVATE, FINAL);
+    return new GeneratedComponentModel(
+        name, NestingKind.MEMBER, Optional.empty(), /* supermodel */ PRIVATE, FINAL);
+  }
+
+  /**
+   * Create a model for the top-level abstract subcomponent implementation when generating
+   * ahead-of-time subcomponents.
+   */
+  static GeneratedComponentModel forBaseSubcomponent(ClassName name) {
+    return new GeneratedComponentModel(
+        name, NestingKind.TOP_LEVEL, Optional.empty(), /* supermodel */ PUBLIC, ABSTRACT);
+  }
+
+  /**
+   * Create a model for an inner abstract implementation of a subcomponent. This is applicable when
+   * generating ahead-of-time subcomponents.
+   */
+  static GeneratedComponentModel forAbstractSubcomponent(
+      ClassName name, GeneratedComponentModel supermodel) {
+    return new GeneratedComponentModel(
+        name, NestingKind.MEMBER, Optional.of(supermodel), PUBLIC, ABSTRACT);
   }
 
   /** Returns the name of the component. */
@@ -137,6 +181,26 @@ ClassName name() {
     return name;
   }
 
+  /** Returns whether or not the implementation is nested within another class. */
+  boolean isNested() {
+    return nestingKind.isNested();
+  }
+
+  /** Returns whether or not the implementation is abstract. */
+  boolean isAbstract() {
+    return isAbstract;
+  }
+
+  /** Returns the model of this model's superclass. */
+  Optional<GeneratedComponentModel> supermodel() {
+    return supermodel;
+  }
+
+  /** Returns the model of the child subcomponent. */
+  Optional<GeneratedComponentModel> subcomponentModel(ComponentDescriptor subcomponent) {
+    return Optional.ofNullable(subcomponentModels.get(subcomponent.componentDefinitionType()));
+  }
+
   /** Returns {@code true} if {@code type} is accessible from the generated component. */
   boolean isTypeAccessible(TypeMirror type) {
     return isTypeAccessibleFrom(type, name.packageName());
@@ -147,6 +211,15 @@ void addSupertype(TypeElement supertype) {
     TypeSpecs.addSupertype(component, supertype);
   }
 
+  /** Adds the given super class to the subcomponent. */
+  void addSuperclass(ClassName className) {
+    checkState(
+        supermodel.isPresent(),
+        "Setting the supertype for model [%s] as a class when model has no supermodel.",
+        name);
+    component.superclass(className);
+  }
+
   // TODO(dpb): Consider taking FieldSpec, and returning identical FieldSpec with unique name?
   /** Adds the given field to the component. */
   void addField(FieldSpecKind fieldKind, FieldSpec fieldSpec) {
@@ -179,6 +252,13 @@ void addTypes(TypeSpecKind typeKind, Iterable<TypeSpec> typeSpecs) {
     typeSpecsMap.putAll(typeKind, typeSpecs);
   }
 
+  /** Adds the type generated from the given subcomponent model. */
+  void addSubcomponent(
+      ComponentDescriptor subcomponent, GeneratedComponentModel subcomponentModel) {
+    subcomponentModels.put(subcomponent.componentDefinitionType(), subcomponentModel);
+    addType(TypeSpecKind.SUBCOMPONENT, subcomponentModel.generate().build());
+  }
+
   /** Adds a {@link Supplier} for the SwitchingProvider for the component. */
   void addSwitchingProvider(Supplier<TypeSpec> typeSpecSupplier) {
     switchingProviderSupplier.add(typeSpecSupplier);
diff --git a/java/dagger/internal/codegen/GeneratedInstanceBindingExpression.java b/java/dagger/internal/codegen/GeneratedInstanceBindingExpression.java
new file mode 100644
index 000000000..112154433
--- /dev/null
+++ b/java/dagger/internal/codegen/GeneratedInstanceBindingExpression.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.model.Key;
+
+/**
+ * A {@link BindingExpression} that invokes a method that encapsulates a binding that requires an
+ * instance of a generated type. This expression is used in abstract implementations of a
+ * subcomponent when there are no concrete definitions of generated types available. The
+ * (unimplemented) method is added to the {@code GeneratedComponentModel} when this dependency
+ * expression is requested. The method is overridden when generating the concrete implementation of
+ * an ancestor component.
+ */
+final class GeneratedInstanceBindingExpression extends BindingExpression {
+  private final Key key;
+
+  GeneratedInstanceBindingExpression(ResolvedBindings resolvedBindings) {
+    this.key = resolvedBindings.key();
+  }
+
+  @Override
+  final Expression getDependencyExpression(ClassName requestingClass) {
+    // TODO(b/72748365): Implement method encapsulating binding to invoke in this expression.
+    return Expression.create(key.type(), CodeBlock.of("null"));
+  }
+}
diff --git a/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java b/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java
index 0a042332c..db6844706 100644
--- a/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java
+++ b/java/dagger/internal/codegen/InaccessibleMapKeyProxyGenerator.java
@@ -36,12 +36,14 @@
  */
 final class InaccessibleMapKeyProxyGenerator extends SourceFileGenerator<ContributionBinding> {
   private final DaggerTypes types;
+  private final DaggerElements elements;
 
   @Inject
   InaccessibleMapKeyProxyGenerator(
       Filer filer, DaggerTypes types, DaggerElements elements, SourceVersion sourceVersion) {
     super(filer, elements, sourceVersion);
     this.types = types;
+    this.elements = elements;
   }
 
   @Override
@@ -56,7 +58,7 @@ ClassName nameGeneratedType(ContributionBinding binding) {
 
   @Override
   Optional<TypeSpec.Builder> write(ClassName generatedName, ContributionBinding binding) {
-    return MapKeys.mapKeyFactoryMethod(binding, types)
+    return MapKeys.mapKeyFactoryMethod(binding, types, elements)
         .map(
             method ->
                 classBuilder(generatedName)
diff --git a/java/dagger/internal/codegen/IncorrectlyInstalledBindsMethodsValidator.java b/java/dagger/internal/codegen/IncorrectlyInstalledBindsMethodsValidator.java
new file mode 100644
index 000000000..5df3b9a2f
--- /dev/null
+++ b/java/dagger/internal/codegen/IncorrectlyInstalledBindsMethodsValidator.java
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.common.base.Preconditions.checkState;
+import static java.util.stream.Collectors.toCollection;
+import static javax.tools.Diagnostic.Kind.WARNING;
+
+import com.google.common.collect.Iterables;
+import com.google.common.collect.MultimapBuilder;
+import com.google.common.collect.SetMultimap;
+import com.google.common.graph.EndpointPair;
+import com.google.common.graph.Graphs;
+import com.google.common.graph.ImmutableGraph;
+import com.google.common.graph.ImmutableNetwork;
+import com.google.common.graph.MutableNetwork;
+import com.google.common.graph.NetworkBuilder;
+import dagger.Binds;
+import dagger.model.BindingGraph;
+import dagger.model.BindingGraph.BindingNode;
+import dagger.model.BindingGraph.DependencyEdge;
+import dagger.model.BindingGraph.Edge;
+import dagger.model.BindingGraph.Node;
+import dagger.model.ComponentPath;
+import dagger.multibindings.IntoSet;
+import dagger.spi.BindingGraphPlugin;
+import dagger.spi.DiagnosticReporter;
+import java.util.LinkedHashSet;
+import java.util.Map.Entry;
+import java.util.Set;
+import javax.inject.Inject;
+import javax.inject.Singleton;
+
+/**
+ * Prints warnings to help users debug <a
+ * href="https://github.com/google/dagger/wiki/Dagger-2.17-@Binds-bugs">the floating {@code @Binds}
+ * bug</a>.
+ */
+@Singleton
+final class IncorrectlyInstalledBindsMethodsValidator implements BindingGraphPlugin {
+  private final SetMultimap<ComponentPath, ContributionBinding> incorrectlyInstalledBindingsCache =
+      MultimapBuilder.hashKeys().linkedHashSetValues().build();
+  private final CompilerOptions compilerOptions;
+
+  @Inject
+  IncorrectlyInstalledBindsMethodsValidator(CompilerOptions compilerOptions) {
+    this.compilerOptions = compilerOptions;
+  }
+
+  @Override
+  public void visitGraph(BindingGraph graph, DiagnosticReporter diagnosticReporter) {
+    checkState(
+        compilerOptions.floatingBindsMethods() || incorrectlyInstalledBindingsCache.isEmpty());
+    for (Entry<ComponentPath, ContributionBinding> entry :
+        incorrectlyInstalledBindingsCache.entries()) {
+      ComponentPath idealComponentPath = entry.getKey();
+      ContributionBinding incorrectlyInstalledBinding = entry.getValue();
+      graph
+          .bindingNodes(incorrectlyInstalledBinding.key())
+          .stream()
+          .filter(bindingNode -> bindingNode.binding().equals(incorrectlyInstalledBinding))
+          .forEach(
+              bindingNode -> report(bindingNode, idealComponentPath, graph, diagnosticReporter));
+    }
+  }
+
+  private void report(
+      BindingNode incompatiblyInstalledBinding,
+      ComponentPath idealComponentPath,
+      BindingGraph graph,
+      DiagnosticReporter diagnosticReporter) {
+    // TODO(dpb): consider creating this once per visitGraph()
+    ImmutableGraph<Node> dependencyGraph = dependencyGraph(graph).asGraph();
+    Set<Node> culpableDependencies =
+        Graphs.reachableNodes(dependencyGraph, incompatiblyInstalledBinding)
+            .stream()
+            .filter(node -> isChild(idealComponentPath, node.componentPath()))
+            .filter(node -> !node.equals(incompatiblyInstalledBinding))
+            .collect(toCollection(LinkedHashSet::new));
+    if (culpableDependencies.isEmpty()) {
+      return;
+    }
+    StringBuilder warning =
+        new StringBuilder()
+            .append("Floating @Binds method detected:\n  ")
+            .append(incompatiblyInstalledBinding)
+            .append("\n  It is installed in:       ")
+            .append(idealComponentPath)
+            .append("\n  But is being resolved in: ")
+            .append(incompatiblyInstalledBinding.componentPath())
+            .append("\n  This is because it depends transitively on:");
+
+    while (!culpableDependencies.isEmpty()) {
+      BindingNode culpableDependency = (BindingNode) Iterables.get(culpableDependencies, 0);
+      warning
+          .append("\n      ")
+          .append(culpableDependency)
+          .append(", resolved in: ")
+          .append(culpableDependency.componentPath());
+      culpableDependencies.removeAll(Graphs.reachableNodes(dependencyGraph, culpableDependency));
+    }
+
+    diagnosticReporter.reportComponent(WARNING, graph.rootComponentNode(), warning.toString());
+  }
+
+  private boolean isChild(ComponentPath possibleParent, ComponentPath possibleChild) {
+    return !possibleParent.equals(possibleChild)
+        && possibleChild.components().containsAll(possibleParent.components());
+  }
+
+  private ImmutableNetwork<Node, Edge> dependencyGraph(BindingGraph graph) {
+    MutableNetwork<Node, Edge> dependencyGraph = NetworkBuilder.from(graph).build();
+    for (DependencyEdge dependencyEdge : graph.dependencyEdges()) {
+      EndpointPair<Node> endpoint = graph.incidentNodes(dependencyEdge);
+      dependencyGraph.addEdge(endpoint.source(), endpoint.target(), dependencyEdge);
+    }
+    return ImmutableNetwork.copyOf(dependencyGraph);
+  }
+
+  void recordBinding(ComponentPath componentPath, ContributionBinding binding) {
+    incorrectlyInstalledBindingsCache.put(componentPath, binding);
+  }
+
+  @dagger.Module
+  interface Module {
+    @Binds
+    @IntoSet
+    @Validation
+    BindingGraphPlugin validator(IncorrectlyInstalledBindsMethodsValidator validator);
+  }
+}
diff --git a/java/dagger/internal/codegen/InjectValidator.java b/java/dagger/internal/codegen/InjectValidator.java
index 4d6c89b03..b912fcbcd 100644
--- a/java/dagger/internal/codegen/InjectValidator.java
+++ b/java/dagger/internal/codegen/InjectValidator.java
@@ -17,7 +17,6 @@
 package dagger.internal.codegen;
 
 import static com.google.auto.common.MoreElements.isAnnotationPresent;
-import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 import static dagger.internal.codegen.InjectionAnnotations.getQualifiers;
 import static dagger.internal.codegen.InjectionAnnotations.injectedConstructors;
 import static dagger.internal.codegen.Scopes.scopesOf;
@@ -46,6 +45,7 @@
 import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Types;
 import javax.tools.Diagnostic;
+import javax.tools.Diagnostic.Kind;
 
 /**
  * A {@linkplain ValidationReport validator} for {@link Inject}-annotated elements and the types
@@ -55,21 +55,28 @@
   private final Types types;
   private final DaggerElements elements;
   private final CompilerOptions compilerOptions;
+  private final DependencyRequestValidator dependencyRequestValidator;
   private final Optional<Diagnostic.Kind> privateAndStaticInjectionDiagnosticKind;
 
   @Inject
-  InjectValidator(Types types, DaggerElements elements, CompilerOptions compilerOptions) {
-    this(types, elements, compilerOptions, Optional.empty());
+  InjectValidator(
+      Types types,
+      DaggerElements elements,
+      DependencyRequestValidator dependencyRequestValidator,
+      CompilerOptions compilerOptions) {
+    this(types, elements, compilerOptions, dependencyRequestValidator, Optional.empty());
   }
 
   private InjectValidator(
       Types types,
       DaggerElements elements,
       CompilerOptions compilerOptions,
-      Optional<Diagnostic.Kind> privateAndStaticInjectionDiagnosticKind) {
+      DependencyRequestValidator dependencyRequestValidator,
+      Optional<Kind> privateAndStaticInjectionDiagnosticKind) {
     this.types = types;
     this.elements = elements;
     this.compilerOptions = compilerOptions;
+    this.dependencyRequestValidator = dependencyRequestValidator;
     this.privateAndStaticInjectionDiagnosticKind = privateAndStaticInjectionDiagnosticKind;
   }
 
@@ -79,7 +86,12 @@ private InjectValidator(
    */
   InjectValidator whenGeneratingCode() {
     return compilerOptions.ignorePrivateAndStaticInjectionForComponent()
-        ? new InjectValidator(types, elements, compilerOptions, Optional.of(Diagnostic.Kind.ERROR))
+        ? new InjectValidator(
+            types,
+            elements,
+            compilerOptions,
+            dependencyRequestValidator,
+            Optional.of(Diagnostic.Kind.ERROR))
         : this;
   }
 
@@ -106,10 +118,7 @@ InjectValidator whenGeneratingCode() {
     }
 
     for (VariableElement parameter : constructorElement.getParameters()) {
-      checkMultipleQualifiers(constructorElement, parameter, builder);
-      if (FrameworkTypes.isProducerType(parameter.asType())) {
-        builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);
-      }
+      validateDependencyRequest(builder, parameter);
     }
 
     if (throwsCheckedExceptions(constructorElement)) {
@@ -182,11 +191,7 @@ InjectValidator whenGeneratingCode() {
           fieldElement);
     }
 
-    checkMultipleQualifiers(fieldElement, fieldElement, builder);
-
-    if (FrameworkTypes.isProducerType(fieldElement.asType())) {
-      builder.addError(provisionMayNotDependOnProducerType(fieldElement.asType()), fieldElement);
-    }
+    validateDependencyRequest(builder, fieldElement);
 
     return builder.build();
   }
@@ -219,15 +224,18 @@ InjectValidator whenGeneratingCode() {
     }
 
     for (VariableElement parameter : methodElement.getParameters()) {
-      checkMultipleQualifiers(methodElement, parameter, builder);
-      if (FrameworkTypes.isProducerType(parameter.asType())) {
-        builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);
-      }
+      validateDependencyRequest(builder, parameter);
     }
 
     return builder.build();
   }
 
+  private void validateDependencyRequest(
+      ValidationReport.Builder<?> builder, VariableElement parameter) {
+    dependencyRequestValidator.validateDependencyRequest(builder, parameter, parameter.asType());
+    dependencyRequestValidator.checkNotProducer(builder, parameter);
+  }
+
   ValidationReport<TypeElement> validateMembersInjectionType(TypeElement typeElement) {
     // TODO(beder): This element might not be currently compiled, so this error message could be
     // left in limbo. Find an appropriate way to display the error message in that case.
@@ -304,22 +312,6 @@ private boolean throwsCheckedExceptions(ExecutableElement methodElement) {
     return false;
   }
 
-  // TODO(dpb,ronshapiro): Use this on AnyBindingMethodValidator, or a DependencyRequestValidator.
-  // Currently, @Provides and @Produces methods with multiple qualifiers on a dependency will crash
-  // the compiler.
-  private void checkMultipleQualifiers(
-      Element errorElement, Element qualifiedElement, ValidationReport.Builder<?> builder) {
-    ImmutableSet<? extends AnnotationMirror> qualifiers = getQualifiers(qualifiedElement);
-    if (qualifiers.size() > 1) {
-      for (AnnotationMirror qualifier : qualifiers) {
-        builder.addError(
-            "A single injection site may not use more than one @Qualifier",
-            errorElement,
-            qualifier);
-      }
-    }
-  }
-
   private void checkInjectIntoPrivateClass(Element element, Builder<TypeElement> builder) {
     if (!Accessibility.isElementAccessibleFromOwnPackage(
         DaggerElements.closestEnclosingTypeElement(element))) {
diff --git a/java/dagger/internal/codegen/KytheBindingGraphFactory.java b/java/dagger/internal/codegen/KytheBindingGraphFactory.java
index 0d49637de..28b724fbe 100644
--- a/java/dagger/internal/codegen/KytheBindingGraphFactory.java
+++ b/java/dagger/internal/codegen/KytheBindingGraphFactory.java
@@ -41,11 +41,13 @@
   private final BindingGraphFactory bindingGraphFactory;
 
   @Inject
-  KytheBindingGraphFactory(Types types, Elements elements) {
+  KytheBindingGraphFactory(Types types, Elements elements, CompilerOptions compilerOptions) {
     DaggerElements daggerElements = new DaggerElements(elements, types);
     DaggerTypes daggerTypes = new DaggerTypes(types, daggerElements);
-    this.componentDescriptorFactory = createComponentDescriptorFactory(daggerElements, daggerTypes);
-    this.bindingGraphFactory = createBindingGraphFactory(daggerTypes, daggerElements);
+    this.componentDescriptorFactory =
+        createComponentDescriptorFactory(daggerElements, daggerTypes, compilerOptions);
+    this.bindingGraphFactory =
+        createBindingGraphFactory(daggerTypes, daggerElements, compilerOptions);
   }
 
   /**
@@ -60,8 +62,26 @@
     return Optional.empty();
   }
 
+  /** Creates the {@link CompilerOptions} for use during {@link BindingGraph} construction. */
+  static CompilerOptions createCompilerOptions() {
+    return CompilerOptions.builder()
+        .usesProducers(true)
+        .writeProducerNameInToken(true)
+        .nullableValidationKind(Diagnostic.Kind.NOTE)
+        .privateMemberValidationKind(Diagnostic.Kind.NOTE)
+        .staticMemberValidationKind(Diagnostic.Kind.NOTE)
+        .ignorePrivateAndStaticInjectionForComponent(false)
+        .scopeCycleValidationType(ValidationType.NONE)
+        .warnIfInjectionFactoryNotGeneratedUpstream(false)
+        .fastInit(false)
+        .experimentalAndroidMode2(false)
+        .aheadOfTimeSubcomponents(false)
+        .floatingBindsMethods(false)
+        .build();
+  }
+
   private static ComponentDescriptor.Factory createComponentDescriptorFactory(
-      DaggerElements elements, DaggerTypes types) {
+      DaggerElements elements, DaggerTypes types, CompilerOptions compilerOptions) {
     KeyFactory keyFactory = new KeyFactory(types, elements);
     DependencyRequestFactory dependencyRequestFactory =
         new DependencyRequestFactory(keyFactory, types);
@@ -85,46 +105,33 @@
             subcomponentDeclarationFactory,
             optionalBindingDeclarationFactory);
     return new ComponentDescriptor.Factory(
-        elements, types, dependencyRequestFactory, moduleDescriptorFactory);
+        elements, types, dependencyRequestFactory, moduleDescriptorFactory, compilerOptions);
   }
 
   private static BindingGraphFactory createBindingGraphFactory(
-      DaggerTypes types, DaggerElements elements) {
+      DaggerTypes types, DaggerElements elements, CompilerOptions compilerOptions) {
     KeyFactory keyFactory = new KeyFactory(types, elements);
-    DependencyRequestFactory dependencyRequestFactory =
-        new DependencyRequestFactory(keyFactory, types);
-    Messager messager = new NullMessager();
-    CompilerOptions compilerOptions =
-        CompilerOptions.builder()
-            .usesProducers(true)
-            .writeProducerNameInToken(true)
-            .nullableValidationKind(Diagnostic.Kind.NOTE)
-            .privateMemberValidationKind(Diagnostic.Kind.NOTE)
-            .staticMemberValidationKind(Diagnostic.Kind.NOTE)
-            .ignorePrivateAndStaticInjectionForComponent(false)
-            .scopeCycleValidationType(ValidationType.NONE)
-            .warnIfInjectionFactoryNotGeneratedUpstream(false)
-            .fastInit(false)
-            .experimentalAndroidMode2(false)
-            .aheadOfTimeSubcomponents(false)
-            .build();
 
     BindingFactory bindingFactory =
-        new BindingFactory(types, elements, keyFactory, dependencyRequestFactory);
-
-    InjectValidator injectMethodValidator = new InjectValidator(types, elements, compilerOptions);
+        new BindingFactory(
+            types, elements, keyFactory, new DependencyRequestFactory(keyFactory, types));
 
     InjectBindingRegistry injectBindingRegistry =
         new InjectBindingRegistryImpl(
             elements,
             types,
-            messager,
-            injectMethodValidator,
+            new NullMessager(),
+            new InjectValidator(types, elements, new DependencyRequestValidator(), compilerOptions),
             keyFactory,
             bindingFactory,
             compilerOptions);
-
-    return new BindingGraphFactory(elements, injectBindingRegistry, keyFactory, bindingFactory);
+    return new BindingGraphFactory(
+        elements,
+        injectBindingRegistry,
+        keyFactory,
+        bindingFactory,
+        new IncorrectlyInstalledBindsMethodsValidator(compilerOptions),
+        compilerOptions);
   }
 
   private static class NullMessager implements Messager {
diff --git a/java/dagger/internal/codegen/MapBindingExpression.java b/java/dagger/internal/codegen/MapBindingExpression.java
index 8a1f70360..25e2e001b 100644
--- a/java/dagger/internal/codegen/MapBindingExpression.java
+++ b/java/dagger/internal/codegen/MapBindingExpression.java
@@ -124,7 +124,7 @@ private DeclaredType immutableMapType() {
   private CodeBlock keyAndValueExpression(DependencyRequest dependency, ClassName requestingClass) {
     return CodeBlock.of(
         "$L, $L",
-        getMapKeyExpression(dependencies.get(dependency), requestingClass),
+        getMapKeyExpression(dependencies.get(dependency), requestingClass, elements),
         componentBindingExpressions
             .getDependencyExpression(dependency, requestingClass)
             .codeBlock());
diff --git a/java/dagger/internal/codegen/MapFactoryCreationExpression.java b/java/dagger/internal/codegen/MapFactoryCreationExpression.java
index b5804908b..3e61293b7 100644
--- a/java/dagger/internal/codegen/MapFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/MapFactoryCreationExpression.java
@@ -37,16 +37,19 @@
   private final ComponentBindingExpressions componentBindingExpressions;
   private final BindingGraph graph;
   private final ContributionBinding binding;
+  private final DaggerElements elements;
 
   MapFactoryCreationExpression(
       ContributionBinding binding,
       GeneratedComponentModel generatedComponentModel,
       ComponentBindingExpressions componentBindingExpressions,
-      BindingGraph graph) {
+      BindingGraph graph,
+      DaggerElements elements) {
     this.binding = checkNotNull(binding);
     this.generatedComponentModel = checkNotNull(generatedComponentModel);
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
     this.graph = checkNotNull(graph);
+    this.elements = checkNotNull(elements);
   }
 
   @Override
@@ -84,7 +87,7 @@ public CodeBlock creationExpression() {
               .codeBlock();
       builder.add(
           ".put($L, $L)",
-          getMapKeyExpression(contributionBinding, generatedComponentModel.name()),
+          getMapKeyExpression(contributionBinding, generatedComponentModel.name(), elements),
           useRawType ? CodeBlocks.cast(value, frameworkDependency.frameworkClass()) : value);
     }
     builder.add(".build()");
diff --git a/java/dagger/internal/codegen/MapKeys.java b/java/dagger/internal/codegen/MapKeys.java
index 59dea8660..af0e98ea1 100644
--- a/java/dagger/internal/codegen/MapKeys.java
+++ b/java/dagger/internal/codegen/MapKeys.java
@@ -42,6 +42,7 @@
 import javax.lang.model.element.Element;
 import javax.lang.model.element.ElementKind;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ArrayType;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.PrimitiveType;
@@ -145,11 +146,12 @@ public DeclaredType visitDeclared(DeclaredType t, Void p) {
    * @throws IllegalStateException if {@code binding} is not a {@link dagger.multibindings.IntoMap
    *     map} contribution.
    */
-  static CodeBlock getMapKeyExpression(ContributionBinding binding, ClassName requestingClass) {
+  static CodeBlock getMapKeyExpression(
+      ContributionBinding binding, ClassName requestingClass, DaggerElements elements) {
     AnnotationMirror mapKeyAnnotation = binding.mapKeyAnnotation().get();
     return MapKeyAccessibility.isMapKeyAccessibleFrom(
             mapKeyAnnotation, requestingClass.packageName())
-        ? directMapKeyExpression(mapKeyAnnotation)
+        ? directMapKeyExpression(mapKeyAnnotation, elements)
         : CodeBlock.of("$T.create()", mapKeyProxyClassName(binding));
   }
 
@@ -157,17 +159,30 @@ static CodeBlock getMapKeyExpression(ContributionBinding binding, ClassName requ
    * Returns a code block for the map key annotation {@code mapKey}.
    *
    * <p>This method assumes the map key will be accessible in the context that the returned {@link
-   * CodeBlock} is used. Use {@link #getMapKeyExpression(ContributionBinding, ClassName)} when that
-   * assumption is not guaranteed.
+   * CodeBlock} is used. Use {@link #getMapKeyExpression(ContributionBinding, ClassName,
+   * DaggerElements)} when that assumption is not guaranteed.
    *
    * @throws IllegalArgumentException if the element is annotated with more than one {@code MapKey}
    *     annotation
    * @throws IllegalStateException if {@code bindingElement} is not annotated with a {@code MapKey}
    *     annotation
    */
-  private static CodeBlock directMapKeyExpression(AnnotationMirror mapKey) {
+  private static CodeBlock directMapKeyExpression(
+      AnnotationMirror mapKey, DaggerElements elements) {
     Optional<? extends AnnotationValue> unwrappedValue = unwrapValue(mapKey);
     AnnotationExpression annotationExpression = new AnnotationExpression(mapKey);
+
+    if (MoreTypes.asTypeElement(mapKey.getAnnotationType())
+        .getQualifiedName()
+        .contentEquals("dagger.android.AndroidInjectionKey")) {
+      TypeElement unwrappedType =
+          elements.checkTypePresent((String) unwrappedValue.get().getValue());
+      return CodeBlock.of(
+          "$T.of($S)",
+          ClassName.get("dagger.android.internal", "AndroidInjectionKeys"),
+          ClassName.get(unwrappedType).reflectionName());
+    }
+
     if (unwrappedValue.isPresent()) {
       TypeMirror unwrappedValueType =
           getOnlyElement(getAnnotationValuesWithDefaults(mapKey).keySet()).getReturnType();
@@ -178,8 +193,8 @@ private static CodeBlock directMapKeyExpression(AnnotationMirror mapKey) {
   }
 
   /**
-   * Returns the {@link ClassName} in which {@link #mapKeyFactoryMethod(ContributionBinding, Types)}
-   * is generated.
+   * Returns the {@link ClassName} in which {@link #mapKeyFactoryMethod(ContributionBinding, Types,
+   * DaggerElements)} is generated.
    */
   static ClassName mapKeyProxyClassName(ContributionBinding binding) {
     return elementBasedClassName(
@@ -191,7 +206,8 @@ static ClassName mapKeyProxyClassName(ContributionBinding binding) {
    * #mapKeyProxyClassName(ContributionBinding)} when the {@code @MapKey} annotation is not publicly
    * accessible.
    */
-  static Optional<MethodSpec> mapKeyFactoryMethod(ContributionBinding binding, Types types) {
+  static Optional<MethodSpec> mapKeyFactoryMethod(
+      ContributionBinding binding, Types types, DaggerElements elements) {
     return binding
         .mapKeyAnnotation()
         .filter(mapKey -> !isMapKeyPubliclyAccessible(mapKey))
@@ -200,7 +216,7 @@ static ClassName mapKeyProxyClassName(ContributionBinding binding) {
                 methodBuilder("create")
                     .addModifiers(PUBLIC, STATIC)
                     .returns(TypeName.get(mapKeyType(mapKey, types)))
-                    .addStatement("return $L", directMapKeyExpression(mapKey))
+                    .addStatement("return $L", directMapKeyExpression(mapKey, elements))
                     .build());
   }
 
diff --git a/java/dagger/internal/codegen/MembersInjectionBinding.java b/java/dagger/internal/codegen/MembersInjectionBinding.java
index 81dd05b5f..2b6c94040 100644
--- a/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -98,10 +98,6 @@ public final boolean isProduction() {
 
     abstract ImmutableSet<DependencyRequest> dependencies();
 
-    int indexAmongSiblingMembers() {
-      return element().getEnclosingElement().getEnclosedElements().indexOf(element());
-    }
-
     /**
      * Returns the index of {@link #element()} in its parents {@code @Inject} members that have the
      * same simple name. This method filters out private elements so that the results will be
diff --git a/java/dagger/internal/codegen/MissingBindingExpression.java b/java/dagger/internal/codegen/MissingBindingExpression.java
new file mode 100644
index 000000000..197c388c6
--- /dev/null
+++ b/java/dagger/internal/codegen/MissingBindingExpression.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import com.squareup.javapoet.ClassName;
+import com.squareup.javapoet.CodeBlock;
+import dagger.model.Key;
+
+/**
+ * A {@link BindingExpression} that invokes a method that encapsulates a binding that is missing
+ * when generating the abstract base class implementation of a subcomponent. The (unimplemented)
+ * method is added to the {@link GeneratedComponentModel} when the dependency expression is
+ * requested. The method is overridden when generating the implementation of an ancestor component.
+ */
+final class MissingBindingExpression extends BindingExpression {
+  private final Key key;
+
+  MissingBindingExpression(Key key) {
+    this.key = key;
+  }
+
+  @Override
+  final Expression getDependencyExpression(ClassName requestingClass) {
+    // TODO(b/72748365): Implement method encapsulating binding to invoke in this expression.
+    return Expression.create(key.type(), CodeBlock.of("null"));
+  }
+}
diff --git a/java/dagger/internal/codegen/MissingBindingValidation.java b/java/dagger/internal/codegen/MissingBindingValidation.java
index 5ce5f9bab..b3c597cbd 100644
--- a/java/dagger/internal/codegen/MissingBindingValidation.java
+++ b/java/dagger/internal/codegen/MissingBindingValidation.java
@@ -20,6 +20,7 @@
 import static com.google.auto.common.MoreTypes.asTypeElement;
 import static com.google.auto.common.MoreTypes.isType;
 import static com.google.auto.common.MoreTypes.isTypeOf;
+import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.DaggerElements.isAnnotationPresent;
 import static dagger.internal.codegen.DaggerStreams.instancesOf;
 import static dagger.internal.codegen.Keys.isValidImplicitProvisionKey;
@@ -97,25 +98,19 @@ private void reportMissingBinding(
   private String missingBindingErrorMessage(DependencyEdge edge, BindingGraph graph) {
     Key key = edge.dependencyRequest().key();
     StringBuilder errorMessage = new StringBuilder();
-    // TODO(dpb): Check for wildcard injection somewhere else first?
-    if (key.type().getKind().equals(TypeKind.WILDCARD)) {
-      // TODO(ronshapiro): Explore creating this message using RequestKinds.
-      errorMessage
-          .append("Dagger does not support injecting Provider<T>, Lazy<T>, Producer<T>, ")
-          .append("or Produced<T> when T is a wildcard type such as ")
-          .append(key);
-    } else {
-      // TODO(ronshapiro): replace "provided" with "satisfied"?
-      errorMessage.append(key).append(" cannot be provided without ");
-      if (isValidImplicitProvisionKey(key, types)) {
-        errorMessage.append("an @Inject constructor or ");
-      }
-      errorMessage.append("an @Provides-"); // TODO(dpb): s/an/a
-      if (dependencyCanBeProduction(edge, graph)) {
-        errorMessage.append(" or @Produces-");
-      }
-      errorMessage.append("annotated method.");
+    // Wildcards should have already been checked by DependencyRequestValidator.
+    verify(
+        !key.type().getKind().equals(TypeKind.WILDCARD), "unexpected wildcard request: %s", edge);
+    // TODO(ronshapiro): replace "provided" with "satisfied"?
+    errorMessage.append(key).append(" cannot be provided without ");
+    if (isValidImplicitProvisionKey(key, types)) {
+      errorMessage.append("an @Inject constructor or ");
+    }
+    errorMessage.append("an @Provides-"); // TODO(dpb): s/an/a
+    if (dependencyCanBeProduction(edge, graph)) {
+      errorMessage.append(" or @Produces-");
     }
+    errorMessage.append("annotated method.");
     if (isValidMembersInjectionKey(key) && typeHasInjectionSites(key)) {
       errorMessage.append(
           " This type supports members injection but cannot be implicitly provided.");
@@ -194,7 +189,7 @@ private boolean typeHasInjectionSites(Key key) {
               "There is no binding for %s because no component in %s's component hierarchy is "
                   + "annotated with %s. The available reference-releasing scopes are %s.",
               key,
-              graph.rootComponentNode().toString(),
+              graph.rootComponentNode().componentPath().currentComponent().getQualifiedName(),
               getReadableSource(scope),
               releasableReferencesScopes(graph).map(Scopes::getReadableSource).collect(toList())));
     }
diff --git a/java/dagger/internal/codegen/MultibindsMethodValidator.java b/java/dagger/internal/codegen/MultibindsMethodValidator.java
index bfac2839a..8e8765d08 100644
--- a/java/dagger/internal/codegen/MultibindsMethodValidator.java
+++ b/java/dagger/internal/codegen/MultibindsMethodValidator.java
@@ -36,12 +36,14 @@
 
   /** Creates a validator for {@link Multibinds @Multibinds} methods. */
   @Inject
-  MultibindsMethodValidator(DaggerElements elements, Types types) {
+  MultibindsMethodValidator(
+      DaggerElements elements, Types types, DependencyRequestValidator dependencyRequestValidator) {
     super(
         elements,
         types,
         Multibinds.class,
         ImmutableSet.of(Module.class, ProducerModule.class),
+        dependencyRequestValidator,
         MUST_BE_ABSTRACT,
         NO_EXCEPTIONS,
         NO_MULTIBINDINGS);
@@ -54,7 +56,8 @@ protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder)
     checkParameters(builder);
   }
 
-  private void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
+  @Override
+  protected void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
     if (!builder.getSubject().getParameters().isEmpty()) {
       builder.addError(bindingMethods("cannot have parameters"));
     }
diff --git a/java/dagger/internal/codegen/ProducesMethodValidator.java b/java/dagger/internal/codegen/ProducesMethodValidator.java
index 52ffd672e..5a043da4c 100644
--- a/java/dagger/internal/codegen/ProducesMethodValidator.java
+++ b/java/dagger/internal/codegen/ProducesMethodValidator.java
@@ -41,10 +41,12 @@
 final class ProducesMethodValidator extends BindingMethodValidator {
 
   @Inject
-  ProducesMethodValidator(DaggerElements elements, Types types) {
+  ProducesMethodValidator(
+      DaggerElements elements, Types types, DependencyRequestValidator dependencyRequestValidator) {
     super(
         elements,
         types,
+        dependencyRequestValidator,
         Produces.class,
         ProducerModule.class,
         MUST_BE_CONCRETE,
diff --git a/java/dagger/internal/codegen/ProvidesMethodValidator.java b/java/dagger/internal/codegen/ProvidesMethodValidator.java
index 8f7cf1a17..c4d409f14 100644
--- a/java/dagger/internal/codegen/ProvidesMethodValidator.java
+++ b/java/dagger/internal/codegen/ProvidesMethodValidator.java
@@ -19,7 +19,6 @@
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_CONCRETE;
 import static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;
-import static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;
 
 import com.google.common.collect.ImmutableSet;
 import dagger.Module;
@@ -35,30 +34,33 @@
  */
 final class ProvidesMethodValidator extends BindingMethodValidator {
 
+  private final DependencyRequestValidator dependencyRequestValidator;
+
   @Inject
-  ProvidesMethodValidator(DaggerElements elements, Types types) {
+  ProvidesMethodValidator(
+      DaggerElements elements, Types types, DependencyRequestValidator dependencyRequestValidator) {
     super(
         elements,
         types,
         Provides.class,
         ImmutableSet.of(Module.class, ProducerModule.class),
+        dependencyRequestValidator,
         MUST_BE_CONCRETE,
         RUNTIME_EXCEPTION,
         ALLOWS_MULTIBINDINGS);
+    this.dependencyRequestValidator = dependencyRequestValidator;
   }
 
   @Override
   protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder) {
     super.checkMethod(builder);
-    checkDependsOnProducers(builder);
   }
 
   /** Adds an error if a {@link Provides @Provides} method depends on a producer type. */
-  private void checkDependsOnProducers(ValidationReport.Builder<ExecutableElement> builder) {
-    for (VariableElement parameter : builder.getSubject().getParameters()) {
-      if (FrameworkTypes.isProducerType(parameter.asType())) {
-        builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);
-      }
-    }
+  @Override
+  protected void checkParameter(
+      ValidationReport.Builder<ExecutableElement> builder, VariableElement parameter) {
+    super.checkParameter(builder, parameter);
+    dependencyRequestValidator.checkNotProducer(builder, parameter);
   }
 }
diff --git a/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java b/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java
index fe6962184..0a42fb2ac 100644
--- a/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java
+++ b/java/dagger/internal/codegen/ReferenceReleasingManagerFields.java
@@ -56,10 +56,14 @@
   private final GeneratedComponentModel generatedComponentModel;
 
   ReferenceReleasingManagerFields(
-      BindingGraph graph, GeneratedComponentModel generatedComponentModel) {
+      BindingGraph graph,
+      GeneratedComponentModel generatedComponentModel,
+      CompilerOptions compilerOptions) {
     this.graph = checkNotNull(graph);
     this.generatedComponentModel = checkNotNull(generatedComponentModel);
-    checkArgument(graph.componentDescriptor().kind().isTopLevel());
+    if (!compilerOptions.aheadOfTimeSubcomponents()) {
+      checkArgument(graph.componentDescriptor().kind().isTopLevel());
+    }
   }
 
   /**
diff --git a/java/dagger/model/BindingGraph.java b/java/dagger/model/BindingGraph.java
index 7e49da620..9b1294205 100644
--- a/java/dagger/model/BindingGraph.java
+++ b/java/dagger/model/BindingGraph.java
@@ -30,7 +30,9 @@
 import com.google.common.collect.ImmutableSetMultimap;
 import com.google.common.graph.EndpointPair;
 import com.google.common.graph.ImmutableNetwork;
+import com.google.common.graph.MutableNetwork;
 import com.google.common.graph.Network;
+import com.google.common.graph.NetworkBuilder;
 import dagger.Module;
 import dagger.model.BindingGraph.Edge;
 import dagger.model.BindingGraph.Node;
@@ -173,12 +175,30 @@ public ComponentNode rootComponentNode() {
   /** Returns the edges for entry points that transitively depend on a binding. */
   public ImmutableSet<DependencyEdge> entryPointEdgesDependingOnBindingNode(
       BindingNode bindingNode) {
-    Network<Node, Edge> subgraphDependingOnBindingNode =
-        inducedSubgraph(this, reachableNodes(transpose(this).asGraph(), bindingNode));
+    ImmutableNetwork<Node, DependencyEdge> dependencyGraph = dependencyGraph();
+    Network<Node, DependencyEdge> subgraphDependingOnBindingNode =
+        inducedSubgraph(
+            dependencyGraph, reachableNodes(transpose(dependencyGraph).asGraph(), bindingNode));
     return ImmutableSet.copyOf(
         intersection(entryPointEdges(), subgraphDependingOnBindingNode.edges()));
   }
 
+  // TODO(dpb): Make public. Cache.
+  private ImmutableNetwork<Node, DependencyEdge> dependencyGraph() {
+    MutableNetwork<Node, DependencyEdge> dependencyGraph =
+        NetworkBuilder.from(this)
+            .expectedNodeCount(nodes().size())
+            .expectedEdgeCount((int) dependencyEdgeStream().count())
+            .build();
+    dependencyEdgeStream()
+        .forEach(
+            edge -> {
+              EndpointPair<Node> endpoints = incidentNodes(edge);
+              dependencyGraph.addEdge(endpoints.source(), endpoints.target(), edge);
+            });
+    return ImmutableNetwork.copyOf(dependencyGraph);
+  }
+
   private <N extends Node> ImmutableSet<N> nodes(Class<N> clazz) {
     return nodeStream(clazz).collect(toImmutableSet());
   }
diff --git a/java/dagger/producers/internal/SetOfProducedProducer.java b/java/dagger/producers/internal/SetOfProducedProducer.java
index 60ccc7cc4..40833e5c2 100644
--- a/java/dagger/producers/internal/SetOfProducedProducer.java
+++ b/java/dagger/producers/internal/SetOfProducedProducer.java
@@ -101,15 +101,14 @@ private SetOfProducedProducer(
   }
 
   /**
-   * Returns a future {@link Set} of {@link Produced} values whose iteration order is that of the
-   * elements given by each of the producers, which are invoked in the order given at creation.
+   * Returns a future {@link Set} of {@link Produced} elements given by each of the producers.
    *
    * <p>If any of the delegate collections, or any elements therein, are null, then that
    * corresponding {@code Produced} element will fail with a NullPointerException.
    *
    * <p>Canceling this future will attempt to cancel all of the component futures; but if any of the
-   * delegate futures fail or are canceled, this future succeeds, with the appropriate failed
-   * {@link Produced}.
+   * delegate futures fail or are canceled, this future succeeds, with the appropriate failed {@link
+   * Produced}.
    *
    * @throws NullPointerException if any of the delegate producers return null
    */
diff --git a/java/dagger/producers/internal/SetProducer.java b/java/dagger/producers/internal/SetProducer.java
index 12e196771..4577db991 100644
--- a/java/dagger/producers/internal/SetProducer.java
+++ b/java/dagger/producers/internal/SetProducer.java
@@ -109,8 +109,7 @@ private SetProducer(
   }
 
   /**
-   * Returns a future {@link Set} whose iteration order is that of the elements given by each of the
-   * producers, which are invoked in the order given at creation.
+   * Returns a future {@link Set} that contains the elements given by each of the producers.
    *
    * <p>If any of the delegate collections, or any elements therein, are null, then this future will
    * fail with a NullPointerException.
diff --git a/javatests/dagger/android/DispatchingAndroidInjectorTest.java b/javatests/dagger/android/DispatchingAndroidInjectorTest.java
index 2d1e6132c..338e7039c 100644
--- a/javatests/dagger/android/DispatchingAndroidInjectorTest.java
+++ b/javatests/dagger/android/DispatchingAndroidInjectorTest.java
@@ -20,12 +20,9 @@
 import static org.junit.Assert.fail;
 
 import android.app.Activity;
+import com.google.common.collect.ImmutableMap;
 import org.robolectric.RobolectricTestRunner;
 import dagger.android.DispatchingAndroidInjector.InvalidInjectorBindingException;
-import java.util.HashMap;
-import java.util.Map;
-import javax.inject.Provider;
-import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
@@ -34,36 +31,59 @@
 @Config(manifest = Config.NONE)
 @RunWith(RobolectricTestRunner.class)
 public final class DispatchingAndroidInjectorTest {
-  private DispatchingAndroidInjector<Activity> dispatchingAndroidInjector;
-
-  @Before
-  public void setup() {
-    Map<Class<? extends Activity>, Provider<AndroidInjector.Factory<? extends Activity>>>
-        injectorFactories = new HashMap<>();
-    injectorFactories.put(FooActivity.class, FooInjector.Factory::new);
-    injectorFactories.put(ReturnsNullActivity.class, () -> null);
-    injectorFactories.put(WrongActivity.class, FooInjector.Factory::new);
-    dispatchingAndroidInjector = new DispatchingAndroidInjector<>(injectorFactories);
+  @Test
+  public void withClassKeys() {
+    DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
+        new DispatchingAndroidInjector<>(
+            ImmutableMap.of(FooActivity.class, FooInjector.Factory::new), ImmutableMap.of());
+
+    FooActivity activity = Robolectric.setupActivity(FooActivity.class);
+    assertThat(dispatchingAndroidInjector.maybeInject(activity)).isTrue();
+  }
+
+  @Test
+  public void withStringKeys() {
+    DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
+        new DispatchingAndroidInjector<>(
+            ImmutableMap.of(),
+            ImmutableMap.of(FooActivity.class.getName(), FooInjector.Factory::new));
+
+    FooActivity activity = Robolectric.setupActivity(FooActivity.class);
+    assertThat(dispatchingAndroidInjector.maybeInject(activity)).isTrue();
   }
 
   @Test
-  public void maybeInject_returnsTrue_ifMatchingInjectorExists() {
+  public void withMixedKeys() {
+    DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
+        new DispatchingAndroidInjector<>(
+            ImmutableMap.of(FooActivity.class, FooInjector.Factory::new),
+            ImmutableMap.of(BarActivity.class.getName(), BarInjector.Factory::new));
+
     FooActivity fooActivity = Robolectric.setupActivity(FooActivity.class);
     assertThat(dispatchingAndroidInjector.maybeInject(fooActivity)).isTrue();
+    BarActivity barActivity = Robolectric.setupActivity(BarActivity.class);
+    assertThat(dispatchingAndroidInjector.maybeInject(barActivity)).isTrue();
   }
 
   @Test
   public void maybeInject_returnsFalse_ifNoMatchingInjectorExists() {
-    BarActivity barActivity = Robolectric.setupActivity(BarActivity.class);
-    assertThat(dispatchingAndroidInjector.maybeInject(barActivity)).isFalse();
+    DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
+        new DispatchingAndroidInjector<>(ImmutableMap.of(), ImmutableMap.of());
+    
+    BarActivity activity = Robolectric.setupActivity(BarActivity.class);
+    assertThat(dispatchingAndroidInjector.maybeInject(activity)).isFalse();
   }
 
   @Test
   public void throwsIfFactoryCreateReturnsNull() {
-    ReturnsNullActivity returnsNullActivity = Robolectric.setupActivity(ReturnsNullActivity.class);
+    DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
+        new DispatchingAndroidInjector<>(
+            ImmutableMap.of(FooActivity.class, () -> null),
+            ImmutableMap.of());
+    FooActivity activity = Robolectric.setupActivity(FooActivity.class);
 
     try {
-      dispatchingAndroidInjector.maybeInject(returnsNullActivity);
+      dispatchingAndroidInjector.maybeInject(activity);
       fail("Expected NullPointerException");
     } catch (NullPointerException expected) {
     }
@@ -71,10 +91,13 @@ public void throwsIfFactoryCreateReturnsNull() {
 
   @Test
   public void throwsIfClassMismatched() {
-    WrongActivity wrongActivity = Robolectric.setupActivity(WrongActivity.class);
+    DispatchingAndroidInjector<Activity> dispatchingAndroidInjector =
+        new DispatchingAndroidInjector<>(
+            ImmutableMap.of(FooActivity.class, BarInjector.Factory::new), ImmutableMap.of());
+    FooActivity activity = Robolectric.setupActivity(FooActivity.class);
 
     try {
-      dispatchingAndroidInjector.maybeInject(wrongActivity);
+      dispatchingAndroidInjector.maybeInject(activity);
       fail("Expected InvalidInjectorBindingException");
     } catch (InvalidInjectorBindingException expected) {
     }
@@ -84,10 +107,6 @@ public void throwsIfClassMismatched() {
 
   static class BarActivity extends Activity {}
 
-  static class ReturnsNullActivity extends Activity {}
-
-  static class WrongActivity extends Activity {}
-
   static class FooInjector implements AndroidInjector<FooActivity> {
     @Override
     public void inject(FooActivity instance) {}
@@ -99,4 +118,16 @@ public void inject(FooActivity instance) {}
       }
     }
   }
+
+  static class BarInjector implements AndroidInjector<BarActivity> {
+    @Override
+    public void inject(BarActivity instance) {}
+
+    static class Factory implements AndroidInjector.Factory<BarActivity> {
+      @Override
+      public AndroidInjector<BarActivity> create(BarActivity activity) {
+        return new BarInjector();
+      }
+    }
+  }
 }
diff --git a/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java b/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java
new file mode 100644
index 000000000..d08bf0b78
--- /dev/null
+++ b/javatests/dagger/android/processor/AndroidMapKeyValidatorTest.java
@@ -0,0 +1,451 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.google.common.base.Joiner;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.ComponentProcessor;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public class AndroidMapKeyValidatorTest {
+  private static final JavaFileObject FOO_ACTIVITY =
+      JavaFileObjects.forSourceLines(
+          "test.FooActivity",
+          "package test;",
+          "",
+          "import android.app.Activity;",
+          "import dagger.android.AndroidInjector;",
+          "",
+          "public class FooActivity extends Activity {",
+          "  interface Factory extends AndroidInjector.Factory<FooActivity> {}",
+          "  abstract static class Builder extends AndroidInjector.Builder<FooActivity> {}",
+          "}");
+  private static final JavaFileObject BAR_ACTIVITY =
+      JavaFileObjects.forSourceLines(
+          "test.BarActivity",
+          "package test;",
+          "",
+          "import android.app.Activity;",
+          "",
+          "public class BarActivity extends Activity {}");
+  private static final JavaFileObject BAZ_FRAGMENT =
+      JavaFileObjects.forSourceLines(
+          "test.BazFragment",
+          "package test;",
+          "",
+          "import android.app.Fragment;",
+          "",
+          "public class BazFragment extends Fragment {}");
+
+  private static JavaFileObject moduleWithMethod(String... lines) {
+    return JavaFileObjects.forSourceLines(
+        "test.AndroidModule",
+        "package test;",
+        "",
+        "import android.app.Activity;",
+        "import android.app.Fragment;",
+        "import dagger.Module;",
+        "import dagger.*;",
+        "import dagger.android.*;",
+        "import dagger.multibindings.IntoMap;",
+        "import javax.inject.*;",
+        "",
+        "@Module",
+        "abstract class AndroidModule {",
+        "  " + Joiner.on("\n  ").join(lines),
+        "}");
+  }
+
+  // TODO(dpb): Change these tests to use onLineContaining() instead of onLine().
+  private static final int LINES_BEFORE_METHOD = 12;
+
+  @Test
+  public void rawFactoryType() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Factory bindRawFactory(FooActivity.Factory factory);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.ActivityKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>, not "
+                + "dagger.android.AndroidInjector.Factory");
+  }
+
+  @Test
+  public void rawBuilderType() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Builder bindRawBuilder(FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.ActivityKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>, not "
+                + "dagger.android.AndroidInjector.Builder");
+  }
+
+  @Test
+  public void bindsToBuilderNotFactory() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Builder<? extends Activity> bindBuilder(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.ActivityKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>, not "
+                + "dagger.android.AndroidInjector.Builder<? extends android.app.Activity>");
+  }
+
+  @Test
+  public void providesToBuilderNotFactory() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Provides",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "static AndroidInjector.Builder<? extends Activity> bindBuilder(",
+            "    FooActivity.Builder builder) {",
+            "  return builder;",
+            "}");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.ActivityKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>, not "
+                + "dagger.android.AndroidInjector.Builder<? extends android.app.Activity>");
+  }
+
+  @Test
+  public void mapKeyDoesntMatchCoreType() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@FragmentKey(BazFragment.class)",
+            "abstract AndroidInjector.Factory<? extends Activity> bindWrongFrameworkType(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY, BAZ_FRAGMENT);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.FragmentKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Fragment>, not "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>");
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.FooActivity.Builder does not implement AndroidInjector<test.BazFragment>")
+        .inFile(module)
+        .onLine(LINES_BEFORE_METHOD + 3);
+  }
+
+  @Test
+  public void mapKeyDoesntMatchCoreType_AndroidInjectionKey() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@AndroidInjectionKey(\"test.BazFragment\")",
+            "abstract AndroidInjector.Factory<? extends Activity> bindWrongFrameworkType(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY, BAZ_FRAGMENT);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "bindWrongFrameworkType(test.FooActivity.Builder) should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Fragment>, not "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>");
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.FooActivity.Builder does not implement AndroidInjector<test.BazFragment>")
+        .inFile(module)
+        .onLine(LINES_BEFORE_METHOD + 3);
+  }
+
+  @Test
+  public void mapKeyDoesntMatchCoreType_supportFragments() {
+    JavaFileObject supportFragment =
+        JavaFileObjects.forSourceLines(
+            "test.SupportFragment",
+            "package test;",
+            "",
+            "import android.support.v4.app.Fragment;",
+            "import dagger.android.AndroidInjector;",
+            "",
+            "public class SupportFragment extends Fragment {",
+            "  interface Factory extends AndroidInjector.Factory<SupportFragment> {}",
+            "}");
+
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@dagger.android.FragmentKey(BazFragment.class)",
+            "abstract AndroidInjector.Factory<? extends android.support.v4.app.Fragment> ",
+            "    bindWrongFrameworkType(SupportFragment.Factory factory);");
+    Compilation compilation = compile(module, BAZ_FRAGMENT, supportFragment);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.FragmentKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Fragment>, not "
+                + "dagger.android.AndroidInjector.Factory<? extends "
+                + "android.support.v4.app.Fragment>");
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.SupportFragment.Factory does not implement AndroidInjector<test.BazFragment>")
+        .inFile(module)
+        .onLine(LINES_BEFORE_METHOD + 3);
+  }
+
+  @Test
+  public void bindsToConcreteTypeInsteadOfWildcard() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Builder<FooActivity> bindBuilder(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "@dagger.android.ActivityKey methods should bind "
+                + "dagger.android.AndroidInjector.Factory<? extends android.app.Activity>, not "
+                + "dagger.android.AndroidInjector.Builder<test.FooActivity>");
+  }
+
+  @Test
+  public void bindsToBaseTypeInsteadOfWildcard() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Builder<Activity> bindBuilder(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@Binds methods' parameter type must be assignable to the return type");
+  }
+
+  @Test
+  public void bindsCorrectType() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Factory<? extends Activity> bindCorrectType(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void bindsCorrectType_AndroidInjectionKey() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@AndroidInjectionKey(\"test.FooActivity\")",
+            "abstract AndroidInjector.Factory<? extends Activity> bindCorrectType(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void bindsWithScope() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "@Singleton",
+            "abstract AndroidInjector.Factory<? extends Activity> bindWithScope(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("should not be scoped");
+  }
+
+  @Test
+  public void bindsWithScope_suppressWarnings() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@SuppressWarnings(\"dagger.android.ScopedInjectorFactory\")",
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "@Singleton",
+            "abstract AndroidInjector.Factory<? extends Activity> bindWithScope(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void mismatchedMapKey_bindsFactory() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(BarActivity.class)",
+            "abstract AndroidInjector.Factory<?> mismatchedFactory(",
+            "    FooActivity.Factory factory);");
+    Compilation compilation = compile(module, FOO_ACTIVITY, BAR_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.FooActivity.Factory does not implement AndroidInjector<test.BarActivity>")
+        .inFile(module)
+        .onLine(LINES_BEFORE_METHOD + 3);
+  }
+
+  @Test
+  public void mismatchedMapKey_bindsBuilder() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(BarActivity.class)",
+            "abstract AndroidInjector.Factory<? extends Activity> mismatchedBuilder(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY, BAR_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.FooActivity.Builder does not implement AndroidInjector<test.BarActivity>")
+        .inFile(module)
+        .onLine(LINES_BEFORE_METHOD + 3);
+  }
+
+  @Test
+  public void mismatchedMapKey_bindsBuilder_androidInjectionKey() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@AndroidInjectionKey(\"test.BarActivity\")",
+            "abstract AndroidInjector.Factory<? extends Activity> mismatchedBuilder(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY, BAR_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.FooActivity.Builder does not implement AndroidInjector<test.BarActivity>")
+        .inFile(module)
+        .onLine(LINES_BEFORE_METHOD + 3);
+  }
+
+  @Test
+  public void mismatchedMapKey_providesBuilder() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Provides",
+            "@IntoMap",
+            "@ActivityKey(BarActivity.class)",
+            "static AndroidInjector.Factory<? extends Activity> mismatchedBuilder(",
+            "    FooActivity.Builder builder) {",
+            "  return builder;",
+            "}");
+    Compilation compilation = compile(module, FOO_ACTIVITY, BAR_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void bindsQualifier_ignoresChecks() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "@Named(\"unused\")",
+            // normally this should fail, since it is binding to a Builder not a Factory
+            "abstract AndroidInjector.Builder<?> bindsBuilderWithQualifier(",
+            "    FooActivity.Builder builder);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void bindToPrimitive() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract int bindInt(@Named(\"unused\") int otherInt);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void bindToNonFrameworkClass() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract Number bindInt(Integer integer);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).succeededWithoutWarnings();
+  }
+
+  @Test
+  public void invalidBindsMethod() {
+    JavaFileObject module =
+        moduleWithMethod(
+            "@Binds",
+            "@IntoMap",
+            "@ActivityKey(FooActivity.class)",
+            "abstract AndroidInjector.Factory<?> bindCorrectType(",
+            "    FooActivity.Builder builder, FooActivity.Builder builder2);");
+    Compilation compilation = compile(module, FOO_ACTIVITY);
+    assertThat(compilation).failed();
+  }
+
+  private Compilation compile(JavaFileObject... files) {
+    return javac().withProcessors(new ComponentProcessor(), new AndroidProcessor()).compile(files);
+  }
+}
diff --git a/javatests/dagger/android/processor/AndroidProcessorTest.java b/javatests/dagger/android/processor/AndroidProcessorTest.java
new file mode 100644
index 000000000..1a45bdd05
--- /dev/null
+++ b/javatests/dagger/android/processor/AndroidProcessorTest.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.common.truth.Truth8.assertThat;
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+import static javax.tools.StandardLocation.CLASS_OUTPUT;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class AndroidProcessorTest {
+  @Test
+  public void generatedProguardFile() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.android.AndroidInjectionKey;",
+            "import dagger.Module;",
+            "import dagger.multibindings.IntoMap;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  @Provides",
+            "  @IntoMap",
+            "  @AndroidInjectionKey(\"test.TestActivity\")",
+            "  static int i() { ",
+            "    return 1;",
+            "  }",
+            "}");
+    Compilation enabled =
+        javac()
+            .withProcessors(new AndroidProcessor())
+            .withOptions("-Adagger.android.experimentalUseStringKeys=true")
+            .compile(module);
+    assertThat(enabled).succeeded();
+    assertThat(enabled)
+        .generatedFile(CLASS_OUTPUT, "META-INF/proguard/dagger.android.AndroidInjectionKeys");
+
+    Compilation disabled =
+        javac()
+            .withProcessors(new AndroidProcessor())
+            .withOptions("-Adagger.android.experimentalUseStringKeys=false")
+            .compile(module);
+    assertThat(disabled).succeeded();
+    assertThat(
+            disabled.generatedFile(
+                CLASS_OUTPUT, "META-INF/proguard/dagger.android.AndroidInjectionKeys"))
+        .isEmpty();
+
+    Compilation noFlag = javac().withProcessors(new AndroidProcessor()).compile(module);
+    assertThat(noFlag).succeeded();
+    assertThat(
+            noFlag.generatedFile(
+                CLASS_OUTPUT, "META-INF/proguard/dagger.android.AndroidInjectionKeys"))
+        .isEmpty();
+  }
+}
diff --git a/javatests/dagger/android/processor/BUILD b/javatests/dagger/android/processor/BUILD
new file mode 100644
index 000000000..8a9c16e67
--- /dev/null
+++ b/javatests/dagger/android/processor/BUILD
@@ -0,0 +1,42 @@
+# Copyright (C) 2017 The Dagger Authors.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+# Description:
+#   Tests for Dagger's Android integrations
+
+package(default_visibility = ["//:src"])
+
+load("//:build_defs.bzl", "DOCLINT_HTML_AND_SYNTAX")
+load("//:test_defs.bzl", "GenJavaTests")
+
+GenJavaTests(
+    name = "android_processor_tests",
+    srcs = glob(["*.java"]),
+    functional = False,
+    javacopts = DOCLINT_HTML_AND_SYNTAX,
+    deps = [
+        "@google_bazel_common//third_party/java/guava",
+        "@androidsdk//com.android.support:support-fragment-25.0.0",
+        # TODO(ronshapiro): create a common location to define the current Android version
+        "@androidsdk//:platforms/android-26/android.jar",
+        "@google_bazel_common//third_party/java/compile_testing",
+        "//:dagger_with_compiler",
+        "@google_bazel_common//third_party/java/junit",
+        "@google_bazel_common//third_party/java/truth",
+        "@google_bazel_common//third_party/java/truth:truth8",
+        "//java/dagger/android",
+        "//java/dagger/android/processor",
+        "//java/dagger/internal/codegen:processor",
+    ],
+)
diff --git a/javatests/dagger/android/processor/ContributesAndroidInjectorTest.java b/javatests/dagger/android/processor/ContributesAndroidInjectorTest.java
new file mode 100644
index 000000000..7ac0d53ac
--- /dev/null
+++ b/javatests/dagger/android/processor/ContributesAndroidInjectorTest.java
@@ -0,0 +1,238 @@
+/*
+ * Copyright (C) 2017 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class ContributesAndroidInjectorTest {
+  private static final JavaFileObject TEST_ACTIVITY =
+      JavaFileObjects.forSourceLines(
+          "test.TestActivity",
+          "package test;",
+          "",
+          "import android.app.Activity;",
+          "",
+          "class TestActivity extends Activity {}");
+
+  @Test
+  public void notAbstract() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.android.ContributesAndroidInjector;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @ContributesAndroidInjector",
+            "  static TestActivity test() {",
+            "    return null;",
+            "  }",
+            "}");
+
+    Compilation compilation = compile(module, TEST_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("must be abstract")
+        .inFile(module)
+        .onLineContaining("test()");
+  }
+
+  @Test
+  public void hasParameters() {
+    JavaFileObject otherActivity =
+        JavaFileObjects.forSourceLines(
+            "test.OtherActivity",
+            "package test;",
+            "",
+            "import android.app.Activity;",
+            "",
+            "class OtherActivity extends Activity {}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.android.ContributesAndroidInjector;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @ContributesAndroidInjector",
+            "  abstract TestActivity oneParam(TestActivity one);",
+            "",
+            "  @ContributesAndroidInjector",
+            "  abstract OtherActivity manyParams(OtherActivity two, Object o);",
+            "}");
+
+    Compilation compilation = compile(module, TEST_ACTIVITY, otherActivity);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("cannot have parameters")
+        .inFile(module)
+        .onLineContaining("oneParam(");
+    assertThat(compilation)
+        .hadErrorContaining("cannot have parameters")
+        .inFile(module)
+        .onLineContaining("manyParams(");
+  }
+
+  @Test
+  public void notInAModule() {
+    JavaFileObject randomFile =
+        JavaFileObjects.forSourceLines(
+            "test.RandomFile",
+            "package test;",
+            "",
+            "import dagger.android.ContributesAndroidInjector;",
+            "",
+            "abstract class RandomFile {",
+            "  @ContributesAndroidInjector",
+            "  abstract TestActivity test() {}",
+            "}");
+
+    Compilation compilation = compile(randomFile, TEST_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("must be in a @Module")
+        .inFile(randomFile)
+        .onLineContaining("test()");
+  }
+
+  @Test
+  public void parameterizedReturnType() {
+    JavaFileObject parameterizedActivity =
+        JavaFileObjects.forSourceLines(
+            "test.ParameterizedActivity",
+            "package test;",
+            "",
+            "import android.app.Activity;",
+            "",
+            "class ParameterizedActivity<T> extends Activity {}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.android.ContributesAndroidInjector;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @ContributesAndroidInjector",
+            "  abstract <T> ParameterizedActivity<T> test();",
+            "}");
+
+    Compilation compilation = compile(module, TEST_ACTIVITY, parameterizedActivity);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("cannot return parameterized types")
+        .inFile(module)
+        .onLineContaining("test()");
+  }
+
+  @Test
+  public void notAFrameworkType() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.android.ContributesAndroidInjector;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @ContributesAndroidInjector",
+            "  abstract android.content.Intent intent();",
+            "}");
+
+    Compilation compilation = compile(module);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("is not a framework type")
+        .inFile(module)
+        .onLineContaining("intent()");
+  }
+
+  @Test
+  public void moduleIsntModule() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.android.ContributesAndroidInjector;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @ContributesAndroidInjector(modules = android.content.Intent.class)",
+            "  abstract TestActivity test();",
+            "}");
+
+    Compilation compilation = compile(module, TEST_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Intent is not a @Module")
+        .inFile(module)
+        .onLineContaining("modules = android.content.Intent.class");
+  }
+
+  @Test
+  public void hasQualifier() {
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.android.ContributesAndroidInjector;",
+            "import javax.inject.Qualifier;",
+            "",
+            "@Module",
+            "abstract class TestModule {",
+            "  @Qualifier @interface AndroidQualifier {}",
+            "",
+            "  @AndroidQualifier",
+            "  @ContributesAndroidInjector",
+            "  abstract TestActivity test();",
+            "}");
+
+    Compilation compilation = compile(module, TEST_ACTIVITY);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("@ContributesAndroidInjector methods cannot have qualifiers")
+        .inFile(module)
+        .onLineContaining("@AndroidQualifier");
+  }
+
+  private static Compilation compile(JavaFileObject... javaFileObjects) {
+    return javac().withProcessors(new AndroidProcessor()).compile(javaFileObjects);
+  }
+}
diff --git a/javatests/dagger/android/processor/DuplicateAndroidInjectorsCheckerTest.java b/javatests/dagger/android/processor/DuplicateAndroidInjectorsCheckerTest.java
new file mode 100644
index 000000000..76167511e
--- /dev/null
+++ b/javatests/dagger/android/processor/DuplicateAndroidInjectorsCheckerTest.java
@@ -0,0 +1,106 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.processor;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static com.google.testing.compile.Compiler.javac;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import dagger.internal.codegen.ComponentProcessor;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class DuplicateAndroidInjectorsCheckerTest {
+  @Test
+  public void conflictingMapKeys() {
+    JavaFileObject activity =
+        JavaFileObjects.forSourceLines(
+            "test.TestActivity",
+            "package test;",
+            "",
+            "import android.app.Activity;",
+            "",
+            "public class TestActivity extends Activity {}");
+    JavaFileObject injectorFactory =
+        JavaFileObjects.forSourceLines(
+            "test.TestInjectorFactory",
+            "package test;",
+            "",
+            "import dagger.android.AndroidInjector;",
+            "import javax.inject.Inject;",
+            "",
+            "class TestInjectorFactory implements AndroidInjector.Factory<TestActivity> {",
+            "  @Inject TestInjectorFactory() {}",
+            "",
+            "  @Override",
+            "  public AndroidInjector<TestActivity> create(TestActivity instance) { return null; }",
+            "}");
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import android.app.Activity;",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "import dagger.android.*;",
+            "import dagger.multibindings.*;",
+            "",
+            "@Module",
+            "interface TestModule {",
+            "  @Binds",
+            "  @IntoMap",
+            "  @ActivityKey(TestActivity.class)",
+            "  AndroidInjector.Factory<? extends Activity> classKey(TestInjectorFactory factory);",
+            "",
+            "  @Binds",
+            "  @IntoMap",
+            "  @AndroidInjectionKey(\"test.TestActivity\")",
+            "  AndroidInjector.Factory<? extends Activity> stringKey(TestInjectorFactory factory);",
+            "}");
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import android.app.Activity;",
+            "import dagger.Component;",
+            "import dagger.android.DispatchingAndroidInjector;",
+            "",
+            "@Component(modules = TestModule.class)",
+            "interface TestComponent {",
+            "  DispatchingAndroidInjector<Activity> dispatchingInjector();",
+            "}");
+
+    Compilation compilation =
+        javac()
+            .withProcessors(ComponentProcessor.forTesting(new DuplicateAndroidInjectorsChecker()))
+            .compile(activity, injectorFactory, module, component);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining("Multiple injector factories bound for the same type")
+        .inFile(component)
+        .onLineContaining("dispatchingInjector()");
+    assertThat(compilation).hadErrorContaining("classKey(test.TestInjectorFactory)");
+    assertThat(compilation).hadErrorContaining("stringKey(test.TestInjectorFactory)");
+    assertThat(compilation).hadErrorCount(1);
+  }
+}
diff --git a/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java b/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
index 271bafc94..1382af1ed 100644
--- a/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
+++ b/javatests/dagger/android/support/functional/AllControllersAreDirectChildrenOfApplication.java
@@ -36,6 +36,7 @@
 import dagger.android.support.FragmentKey;
 import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.BroadcastReceiverSubcomponent.BroadcastReceiverModule;
 import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.ContentProviderSubcomponent.ContentProviderModule;
+import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.InnerActivitySubcomponent.InnerActivityModule;
 import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.IntentServiceSubcomponent.IntentServiceModule;
 import dagger.android.support.functional.AllControllersAreDirectChildrenOfApplication.ApplicationComponent.ServiceSubcomponent.ServiceModule;
 import dagger.multibindings.IntoMap;
@@ -56,6 +57,7 @@
     @Module(
       subcomponents = {
         ActivitySubcomponent.class,
+        InnerActivitySubcomponent.class,
         ParentFragmentSubcomponent.class,
         ChildFragmentSubcomponent.class,
         DialogFragmentSubcomponent.class,
@@ -78,6 +80,12 @@
       abstract AndroidInjector.Factory<? extends Activity> bindFactoryForTestActivity(
           ActivitySubcomponent.Builder builder);
 
+      @Binds
+      @IntoMap
+      @ActivityKey(OuterClass.TestInnerClassActivity.class)
+      abstract AndroidInjector.Factory<? extends Activity> bindFactoryForInnerActivity(
+          InnerActivitySubcomponent.Builder builder);
+
       @Binds
       @IntoMap
       @FragmentKey(TestParentFragment.class)
@@ -136,6 +144,21 @@
       abstract class Builder extends AndroidInjector.Builder<TestActivity> {}
     }
 
+    @Subcomponent(modules = InnerActivityModule.class)
+    interface InnerActivitySubcomponent extends AndroidInjector<OuterClass.TestInnerClassActivity> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<OuterClass.TestInnerClassActivity> {}
+
+      @Module
+      abstract class InnerActivityModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return InnerActivitySubcomponent.class;
+        }
+      }
+    }
+
     @Subcomponent(modules = ParentFragmentSubcomponent.ParentFragmentModule.class)
     interface ParentFragmentSubcomponent extends AndroidInjector<TestParentFragment> {
       @Module
diff --git a/javatests/dagger/android/support/functional/AndroidManifest.xml b/javatests/dagger/android/support/functional/AndroidManifest.xml
index 1ace8cb8f..c89d30667 100644
--- a/javatests/dagger/android/support/functional/AndroidManifest.xml
+++ b/javatests/dagger/android/support/functional/AndroidManifest.xml
@@ -16,7 +16,8 @@
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
   package="dagger.android.support.functional">
 
-  <application android:theme="@style/Theme.AppCompat">
+  <application android:theme="@style/Theme.AppCompat"
+      android:name=".UsesGeneratedModulesApplication">
     <activity android:name="dagger.android.support.functional.ParentOfFragmentActivity"/>
     <activity android:name="dagger.android.support.functional.SiblingOfFragmentActivity"/>
     <activity android:name="dagger.android.support.functional.InjectedWithoutSubcomponentActivity"/>
diff --git a/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java b/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
index 9490f48e5..379c795f0 100644
--- a/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
+++ b/javatests/dagger/android/support/functional/ComponentStructureFollowsControllerStructureApplication.java
@@ -36,6 +36,7 @@
 import dagger.android.support.FragmentKey;
 import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.BroadcastReceiverSubcomponent.BroadcastReceiverModule;
 import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.ContentProviderSubcomponent.ContentProviderModule;
+import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.InnerActivitySubcomponent.InnerActivityModule;
 import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.IntentServiceSubcomponent.IntentServiceModule;
 import dagger.android.support.functional.ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.ServiceSubcomponent.ServiceModule;
 import dagger.multibindings.IntoMap;
@@ -58,6 +59,7 @@
     @Module(
       subcomponents = {
         ActivitySubcomponent.class,
+        InnerActivitySubcomponent.class,
         ServiceSubcomponent.class,
         IntentServiceSubcomponent.class,
         BroadcastReceiverSubcomponent.class,
@@ -77,6 +79,12 @@
       abstract AndroidInjector.Factory<? extends Activity> bindFactoryForTestActivity(
           ActivitySubcomponent.Builder builder);
 
+      @Binds
+      @IntoMap
+      @ActivityKey(OuterClass.TestInnerClassActivity.class)
+      abstract AndroidInjector.Factory<? extends Activity> bindFactoryForInnerActivity(
+          InnerActivitySubcomponent.Builder builder);
+
       @Binds
       @IntoMap
       @ServiceKey(TestService.class)
@@ -180,6 +188,21 @@
       }
     }
 
+    @Subcomponent(modules = InnerActivityModule.class)
+    interface InnerActivitySubcomponent extends AndroidInjector<OuterClass.TestInnerClassActivity> {
+      @Subcomponent.Builder
+      abstract class Builder extends AndroidInjector.Builder<OuterClass.TestInnerClassActivity> {}
+
+      @Module
+      abstract class InnerActivityModule {
+        @Provides
+        @IntoSet
+        static Class<?> addToComponentHierarchy() {
+          return InnerActivitySubcomponent.class;
+        }
+      }
+    }
+
     @Subcomponent(modules = ServiceModule.class)
     interface ServiceSubcomponent extends AndroidInjector<TestService> {
       @Subcomponent.Builder
diff --git a/javatests/dagger/android/support/functional/InjectorsTest.java b/javatests/dagger/android/support/functional/InjectorsTest.java
index 7303e2b1c..277b156c1 100644
--- a/javatests/dagger/android/support/functional/InjectorsTest.java
+++ b/javatests/dagger/android/support/functional/InjectorsTest.java
@@ -127,6 +127,14 @@ public void componentStructureFollowsControllerStructure() {
                 .ContentProviderSubcomponent.class);
 
     changeConfiguration();
+
+    OuterClass.TestInnerClassActivity innerClassActivity =
+        Robolectric.setupActivity(OuterClass.TestInnerClassActivity.class);
+    assertThat(innerClassActivity.componentHierarchy)
+        .containsExactly(
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent.class,
+            ComponentStructureFollowsControllerStructureApplication.ApplicationComponent
+                .InnerActivitySubcomponent.class);
   }
 
   @Test
@@ -177,6 +185,14 @@ public void allControllersAreDirectChildrenOfApplication() {
                 .ContentProviderSubcomponent.class);
 
     changeConfiguration();
+
+    OuterClass.TestInnerClassActivity innerClassActivity =
+        Robolectric.setupActivity(OuterClass.TestInnerClassActivity.class);
+    assertThat(innerClassActivity.componentHierarchy)
+        .containsExactly(
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent.class,
+            AllControllersAreDirectChildrenOfApplication.ApplicationComponent
+                .InnerActivitySubcomponent.class);
   }
 
   @Test
@@ -224,6 +240,13 @@ public void usesGeneratedModules() {
         Robolectric.setupActivity(TestActivityWithScope.class);
     assertThat(activityWithScope.scopedStringProvider.get())
         .isSameAs(activityWithScope.scopedStringProvider.get());
+
+    OuterClass.TestInnerClassActivity innerClassActivity =
+        Robolectric.setupActivity(OuterClass.TestInnerClassActivity.class);
+    assertThat(innerClassActivity.componentHierarchy)
+        .containsExactly(
+            UsesGeneratedModulesApplication.ApplicationComponent.class,
+            UsesGeneratedModulesApplication.DummyInnerActivitySubcomponent.class);
   }
 
   // https://github.com/google/dagger/issues/598
diff --git a/javatests/dagger/android/support/functional/OuterClass.java b/javatests/dagger/android/support/functional/OuterClass.java
new file mode 100644
index 000000000..e5d6ed595
--- /dev/null
+++ b/javatests/dagger/android/support/functional/OuterClass.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.android.support.functional;
+
+import dagger.android.support.DaggerAppCompatActivity;
+import java.util.Set;
+import javax.inject.Inject;
+
+final class OuterClass {
+  public static class TestInnerClassActivity extends DaggerAppCompatActivity {
+    @Inject
+    Set<Class<?>> componentHierarchy;
+  }
+}
diff --git a/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java b/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java
index 661426244..cf340e319 100644
--- a/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java
+++ b/javatests/dagger/android/support/functional/UsesGeneratedModulesApplication.java
@@ -55,6 +55,9 @@
     @ContributesAndroidInjector(modules = DummyActivitySubcomponent.AddToHierarchy.class)
     abstract TestActivity contributeTestActivityInjector();
 
+    @ContributesAndroidInjector(modules = DummyInnerActivitySubcomponent.AddToHierarchy.class)
+    abstract OuterClass.TestInnerClassActivity contributeInnerActivityInjector();
+
     @ContributesAndroidInjector(modules = DummyParentFragmentSubcomponent.AddToHierarchy.class)
     abstract TestParentFragment contributeTestParentFragmentInjector();
 
@@ -101,6 +104,17 @@ static String provideScopedString() {
     }
   }
 
+  interface DummyInnerActivitySubcomponent {
+    @Module
+    abstract class AddToHierarchy {
+      @Provides
+      @IntoSet
+      static Class<?> addDummyValueToComponentHierarchy() {
+        return DummyInnerActivitySubcomponent.class;
+      }
+    }
+  }
+
   interface DummyParentFragmentSubcomponent {
     @Module
     abstract class AddToHierarchy {
diff --git a/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
new file mode 100644
index 000000000..79f9fa59d
--- /dev/null
+++ b/javatests/dagger/internal/codegen/AheadOfTimeSubcomponentsTest.java
@@ -0,0 +1,404 @@
+/*
+ * Copyright (C) 2018 The Dagger Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dagger.internal.codegen;
+
+import static com.google.testing.compile.CompilationSubject.assertThat;
+import static dagger.internal.codegen.CompilerMode.AHEAD_OF_TIME_SUBCOMPONENTS_MODE;
+import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;
+import static dagger.internal.codegen.GeneratedLines.IMPORT_GENERATED_ANNOTATION;
+
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.JavaFileObjects;
+import javax.tools.JavaFileObject;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+@RunWith(JUnit4.class)
+public final class AheadOfTimeSubcomponentsTest {
+  @Test
+  public void simpleSubcomponent() {
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = TestModule.class)",
+            "interface Child {",
+            "  String string();",
+            "}");
+
+    JavaFileObject module =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class TestModule {",
+            "  @Provides String provideString() { return \"florp\"; }",
+            "}");
+
+    JavaFileObject generatedSubcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerChild",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerChild implements Child {",
+            "  private TestModule testModule;",
+            "",
+            "  protected DaggerChild() {",
+            "    initialize();",
+            "  }",
+            "",
+            "  @SuppressWarnings(\"unchecked\")",
+            "  private void initialize() {",
+            "    this.testModule = new TestModule();",
+            "  }",
+            "",
+            "  @Override",
+            "  public String string() {",
+            "    return TestModule_ProvideStringFactory.proxyProvideString(testModule);",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
+            .compile(subcomponent, module);
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerChild")
+        .hasSourceEquivalentTo(generatedSubcomponent);
+  }
+
+  @Test
+  public void subcomponent_MissingBinding() {
+    JavaFileObject subcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Child {",
+            "  String string();",
+            "}");
+
+    JavaFileObject generatedSubcomponent =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerChild",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerChild implements Child {",
+            "  protected DaggerChild() {}",
+            "",
+            "  @Override",
+            "  public String string() {",
+            "    return null;",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
+            .compile(subcomponent);
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerChild")
+        .hasSourceEquivalentTo(generatedSubcomponent);
+  }
+
+  @Test
+  public void subcomponent_BuilderAndGeneratedInstanceBinding() {
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GrandchildModule.class)",
+            "interface Grandchild {",
+            "  Integer i();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Builder module(GrandchildModule module);",
+            "",
+            "    Grandchild build();",
+            "  }",
+            "}");
+
+    JavaFileObject grandchildModule =
+        JavaFileObjects.forSourceLines(
+            "test.GrandchildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class GrandchildModule {",
+            "  @Provides static Integer provideInteger() { return 0; }",
+            "}");
+
+    JavaFileObject generatedGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGrandchild",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGrandchild implements Grandchild {",
+            "  protected DaggerGrandchild(Builder builder) {}",
+            "",
+            "  @Override",
+            "  public Integer i() {",
+            "    return GrandchildModule_ProvideIntegerFactory.proxyProvideInteger();",
+            "  }",
+            "",
+            "  protected abstract static class Builder implements Grandchild.Builder {",
+            "",
+            "    @Override",
+            "    public Builder module(GrandchildModule module) {",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Child {",
+            "  Grandchild.Builder grandchild();",
+            "}");
+
+    JavaFileObject generatedChild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerChild",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerChild implements Child {",
+            "  protected DaggerChild() {}",
+            "",
+            "  @Override",
+            "  public Grandchild.Builder grandchild() {",
+            "    return null;",
+            "  }",
+            "",
+            "  protected abstract class GrandchildBuilder extends DaggerGrandchild.Builder {",
+            "    @Override",
+            "    public GrandchildBuilder module(GrandchildModule module) {",
+            "      return this;",
+            "    }",
+            "  }",
+            "",
+            "  public abstract class GrandchildImpl extends DaggerGrandchild {",
+            "    protected GrandchildImpl(GrandchildBuilder builder) {",
+            "      super(builder);",
+            "    }",
+            "  }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
+            .compile(child, grandchild, grandchildModule);
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGrandchild")
+        .hasSourceEquivalentTo(generatedGrandchild);
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerChild")
+        .hasSourceEquivalentTo(generatedChild);
+  }
+
+  @Test
+  public void simpleDeepComponentHierarchy() {
+    JavaFileObject greatGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.GreatGrandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = GreatGrandchildModule.class)",
+            "interface GreatGrandchild {",
+            "  Integer i();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Builder module(GreatGrandchildModule module);",
+            "",
+            "    GreatGrandchild build();",
+            "  }",
+            "}");
+
+    JavaFileObject greatGrandchildModule =
+        JavaFileObjects.forSourceLines(
+            "test.GreatGrandchildModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "class GreatGrandchildModule {",
+            "  @Provides static Integer provideInteger() { return 0; }",
+            "}");
+
+    JavaFileObject generatedGreatGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGreatGrandchild",
+            "package test;",
+            "",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGreatGrandchild implements GreatGrandchild {",
+            "  protected DaggerGreatGrandchild(Builder builder) {}",
+            "",
+            "  @Override",
+            "  public Integer i() {",
+            "    return GreatGrandchildModule_ProvideIntegerFactory.proxyProvideInteger();",
+            "  }",
+            "",
+            "  protected abstract static class Builder implements GreatGrandchild.Builder {",
+            "",
+            "    @Override",
+            "    public Builder module(GreatGrandchildModule module) {",
+            "      return this;",
+            "    }",
+            "  }",
+            "}");
+
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Grandchild {",
+            "  GreatGrandchild.Builder greatGrandchild();",
+            "}");
+
+    JavaFileObject generatedGrandchild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerGrandchild",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerGrandchild implements Grandchild {",
+            "  protected DaggerGrandchild() {}",
+            "",
+            "  @Override",
+            "  public GreatGrandchild.Builder greatGrandchild() {",
+            "    return null;",
+            "  }",
+            "",
+            "  protected abstract class GreatGrandchildBuilder extends",
+            "      DaggerGreatGrandchild.Builder {",
+            "    @Override",
+            "    public GreatGrandchildBuilder module(GreatGrandchildModule module) {",
+            "      return this;",
+            "    }",
+            "  }",
+            "",
+            "  public abstract class GreatGrandchildImpl extends DaggerGreatGrandchild {",
+            "    protected GreatGrandchildImpl(GreatGrandchildBuilder builder) {",
+            "      super(builder);",
+            "    }",
+            "  }",
+            "}");
+
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Child {",
+            "  Grandchild grandchild();",
+            "}");
+
+    JavaFileObject generatedChild =
+        JavaFileObjects.forSourceLines(
+            "test.DaggerChild",
+            "package test;",
+            IMPORT_GENERATED_ANNOTATION,
+            "",
+            GENERATED_ANNOTATION,
+            "public abstract class DaggerChild implements Child {",
+            "  protected DaggerChild() {}",
+            "",
+            "  public abstract class GrandchildImpl extends DaggerGrandchild {",
+            "    protected GrandchildImpl() {",
+            "      super();",
+            "    }",
+            "",
+            "    protected abstract class GreatGrandchildBuilder",
+            "        extends DaggerGrandchild.GreatGrandchildBuilder {",
+            "      @Override",
+            "      public GreatGrandchildBuilder module(GreatGrandchildModule module) {",
+            "        return this;",
+            "      }",
+            "    }",
+            "",
+            "    public abstract class GreatGrandchildImpl extends",
+            "        DaggerGrandchild.GreatGrandchildImpl {",
+            "      protected GreatGrandchildImpl(GreatGrandchildBuilder builder) {",
+            "        super(builder);",
+            "      }",
+            "    }",
+            "}");
+    Compilation compilation =
+        daggerCompiler()
+            .withOptions(AHEAD_OF_TIME_SUBCOMPONENTS_MODE.javacopts())
+            .compile(child, grandchild, greatGrandchild, greatGrandchildModule);
+    assertThat(compilation).succeededWithoutWarnings();
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGreatGrandchild")
+        .hasSourceEquivalentTo(generatedGreatGrandchild);
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerGrandchild")
+        .hasSourceEquivalentTo(generatedGrandchild);
+    assertThat(compilation)
+        .generatedSourceFile("test.DaggerChild")
+        .hasSourceEquivalentTo(generatedChild);
+  }
+}
diff --git a/javatests/dagger/internal/codegen/BindingGraphCapturer.java b/javatests/dagger/internal/codegen/BindingGraphCapturer.java
index b06b504b0..503fd47f4 100644
--- a/javatests/dagger/internal/codegen/BindingGraphCapturer.java
+++ b/javatests/dagger/internal/codegen/BindingGraphCapturer.java
@@ -32,7 +32,14 @@
 
   @Override
   public void visitGraph(BindingGraph bindingGraph, DiagnosticReporter diagnosticReporter) {
-    bindingGraphs.put(bindingGraph.rootComponentNode().toString(), bindingGraph);
+    bindingGraphs.put(
+        bindingGraph
+            .rootComponentNode()
+            .componentPath()
+            .currentComponent()
+            .getQualifiedName()
+            .toString(),
+        bindingGraph);
   }
 
   /** Returns a map of binding graphs, indexed by the canonical name of the root component type. */
diff --git a/javatests/dagger/internal/codegen/BindsMethodValidatorTest.java b/javatests/dagger/internal/codegen/BindsMethodValidatorTest.java
index 07c07859e..479e8031c 100644
--- a/javatests/dagger/internal/codegen/BindsMethodValidatorTest.java
+++ b/javatests/dagger/internal/codegen/BindsMethodValidatorTest.java
@@ -92,13 +92,21 @@ public void returnsVoid() {
   }
 
   @Test
-  public void tooManyQualifiers() {
+  public void tooManyQualifiersOnMethod() {
     assertThatMethod(
             "@Binds @Qualifier1 @Qualifier2 abstract String tooManyQualifiers(String impl);")
         .importing(Qualifier1.class, Qualifier2.class)
         .hasError("more than one @Qualifier");
   }
 
+  @Test
+  public void tooManyQualifiersOnParameter() {
+    assertThatMethod(
+            "@Binds abstract String tooManyQualifiers(@Qualifier1 @Qualifier2 String impl);")
+        .importing(Qualifier1.class, Qualifier2.class)
+        .hasError("more than one @Qualifier");
+  }
+
   @Test
   public void noParameters() {
     assertThatMethod("@Binds abstract Object noParameters();").hasError("one parameter");
diff --git a/javatests/dagger/internal/codegen/CompilerMode.java b/javatests/dagger/internal/codegen/CompilerMode.java
index 2173c2639..4dcc21548 100644
--- a/javatests/dagger/internal/codegen/CompilerMode.java
+++ b/javatests/dagger/internal/codegen/CompilerMode.java
@@ -22,7 +22,8 @@
 /** The configuration options for compiler modes. */
 enum CompilerMode {
   DEFAULT_MODE,
-  FAST_INIT_MODE("-Adagger.fastInit=enabled");
+  FAST_INIT_MODE("-Adagger.fastInit=enabled"),
+  AHEAD_OF_TIME_SUBCOMPONENTS_MODE("-Adagger.experimentalAheadOfTimeSubcomponents=enabled");
 
   /** Returns the compiler modes as a list of parameters for parameterized tests */
   static final ImmutableList<Object[]> TEST_PARAMETERS =
diff --git a/javatests/dagger/internal/codegen/ConflictingEntryPointsTest.java b/javatests/dagger/internal/codegen/ConflictingEntryPointsTest.java
index ea904474b..7ffd922a3 100644
--- a/javatests/dagger/internal/codegen/ConflictingEntryPointsTest.java
+++ b/javatests/dagger/internal/codegen/ConflictingEntryPointsTest.java
@@ -72,8 +72,8 @@ public void covariantType() {
         .hadErrorContaining(
             message(
                 "conflicting entry point declarations:",
-                "Long test.Base1.foo()",
-                "Number test.Base2.foo()"))
+                "    Long test.Base1.foo()",
+                "    Number test.Base2.foo()"))
         .inFile(component)
         .onLineContaining("interface TestComponent ");
   }
@@ -120,8 +120,8 @@ public void covariantTypeFromGenericSupertypes() {
         .hadErrorContaining(
             message(
                 "conflicting entry point declarations:",
-                "Long test.Base1.foo()",
-                "Number test.Base2.foo()"))
+                "    Long test.Base1.foo()",
+                "    Number test.Base2.foo()"))
         .inFile(component)
         .onLineContaining("interface TestComponent ");
   }
@@ -171,8 +171,8 @@ public void differentQualifier() {
         .hadErrorContaining(
             message(
                 "conflicting entry point declarations:",
-                "Object test.Base1.foo()",
-                "@Named(\"foo\") Object test.Base2.foo()"))
+                "    Object test.Base1.foo()",
+                "    @Named(\"foo\") Object test.Base2.foo()"))
         .inFile(component)
         .onLineContaining("interface TestComponent ");
   }
diff --git a/javatests/dagger/internal/codegen/GraphValidationScopingTest.java b/javatests/dagger/internal/codegen/GraphValidationScopingTest.java
index c11d04fbc..2e7aa7d2a 100644
--- a/javatests/dagger/internal/codegen/GraphValidationScopingTest.java
+++ b/javatests/dagger/internal/codegen/GraphValidationScopingTest.java
@@ -18,6 +18,7 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.message;
 
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
@@ -62,13 +63,96 @@
         "  @Provides long integer() { return 0L; }",
         "  @Provides float floatingPoint() { return 0.0f; }",
         "}");
-    String errorMessage =
-        "test.MyComponent (unscoped) may not reference scoped bindings:\n"
-            + "      @Singleton class test.ScopedType\n"
-            + "      @Provides @Singleton String test.ScopedModule.string()";
+
     Compilation compilation = daggerCompiler().compile(componentFile, typeFile, moduleFile);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.MyComponent (unscoped) may not reference scoped bindings:",
+                "    @Singleton class test.ScopedType",
+                "    @Provides @Singleton String test.ScopedModule.string()"));
+  }
+
+  @Test // b/79859714
+  public void bindsWithChildScope_inParentModule_notAllowed() {
+    JavaFileObject childScope =
+        JavaFileObjects.forSourceLines(
+            "test.ChildScope",
+            "package test;",
+            "",
+            "import javax.inject.Scope;",
+            "",
+            "@Scope",
+            "@interface ChildScope {}");
+
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "", //
+            "interface Foo {}");
+
+    JavaFileObject fooImpl =
+        JavaFileObjects.forSourceLines(
+            "test.ChildModule",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "class FooImpl implements Foo {",
+            "  @Inject FooImpl() {}",
+            "}");
+
+    JavaFileObject parentModule =
+        JavaFileObjects.forSourceLines(
+            "test.ParentModule",
+            "package test;",
+            "",
+            "import dagger.Binds;",
+            "import dagger.Module;",
+            "",
+            "@Module",
+            "interface ParentModule {",
+            "  @Binds @ChildScope Foo bind(FooImpl fooImpl);",
+            "}");
+
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.ParentComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "import javax.inject.Singleton;",
+            "",
+            "@Singleton",
+            "@Component(modules = ParentModule.class)",
+            "interface Parent {",
+            "  Child child();",
+            "}");
+
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@ChildScope",
+            "@Subcomponent",
+            "interface Child {",
+            "  Foo foo();",
+            "}");
+
+    Compilation compilation =
+        daggerCompiler().compile(childScope, foo, fooImpl, parentModule, parent, child);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.Parent scoped with @Singleton may not reference bindings with different "
+                    + "scopes:",
+                "    @Binds @test.ChildScope test.Foo test.ParentModule.bind(test.FooImpl)"));
   }
 
   @Test public void componentWithScopeIncludesIncompatiblyScopedBindings_Fail() {
@@ -124,17 +208,20 @@
         "  @Provides @Singleton float floatingPoint() { return 0.0f; }", // same scope - valid
         "  @Provides @Per(MyComponent.class) boolean bool() { return false; }", // incompatible
         "}");
-    String errorMessage =
-        "test.MyComponent scoped with @Singleton "
-            + "may not reference bindings with different scopes:\n"
-            + "      @test.PerTest class test.ScopedType\n"
-            + "      @Provides @test.PerTest String test.ScopedModule.string()\n"
-            + "      @Provides @test.Per(test.MyComponent.class) boolean test.ScopedModule.bool()";
+
     Compilation compilation =
         daggerCompiler()
             .compile(componentFile, scopeFile, scopeWithAttribute, typeFile, moduleFile);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.MyComponent scoped with @Singleton "
+                    + "may not reference bindings with different scopes:",
+                "    @test.PerTest class test.ScopedType",
+                "    @Provides @test.PerTest String test.ScopedModule.string()",
+                "    @Provides @test.Per(test.MyComponent.class) boolean "
+                    + "test.ScopedModule.bool()"));
   }
 
   @Test public void componentWithScopeMayDependOnOnlyOneScopedComponent() {
@@ -197,16 +284,19 @@
         "interface SimpleScopedComponent {",
         "  SimpleType.A type();",
         "}");
-    String errorMessage =
-        "@test.SimpleScope test.SimpleScopedComponent depends on more than one scoped component:\n"
-        + "      @Singleton test.SingletonComponentA\n"
-        + "      @Singleton test.SingletonComponentB";
+
     Compilation compilation =
         daggerCompiler()
             .compile(
                 type, simpleScope, simpleScoped, singletonScopedA, singletonScopedB, scopeless);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "@test.SimpleScope test.SimpleScopedComponent depends on more than one scoped "
+                    + "component:",
+                "    @Singleton test.SingletonComponentA",
+                "    @Singleton test.SingletonComponentB"));
   }
 
   @Test public void componentWithoutScopeCannotDependOnScopedComponent() {
@@ -239,12 +329,14 @@
         "interface UnscopedComponent {",
         "  SimpleType type();",
         "}");
-    String errorMessage =
-        "test.UnscopedComponent (unscoped) cannot depend on scoped components:\n"
-        + "      @Singleton test.ScopedComponent";
+
     Compilation compilation = daggerCompiler().compile(type, scopedComponent, unscopedComponent);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.UnscopedComponent (unscoped) cannot depend on scoped components:",
+                "    @Singleton test.ScopedComponent"));
   }
 
   @Test public void componentWithSingletonScopeMayNotDependOnOtherScope() {
@@ -284,13 +376,15 @@
         "interface SingletonComponent {",
         "  SimpleType type();",
         "}");
-    String errorMessage =
-        "This @Singleton component cannot depend on scoped components:\n"
-        + "      @test.SimpleScope test.SimpleScopedComponent";
+
     Compilation compilation =
         daggerCompiler().compile(type, simpleScope, simpleScoped, singletonScoped);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "This @Singleton component cannot depend on scoped components:",
+                "    @test.SimpleScope test.SimpleScopedComponent"));
   }
 
   @Test public void componentScopeAncestryMustNotCycle() {
@@ -347,15 +441,18 @@
         "interface ComponentShort {",
         "  SimpleType type();",
         "}");
-    String errorMessage =
-        "test.ComponentShort depends on scoped components in a non-hierarchical scope ordering:\n"
-        + "      @test.ScopeA test.ComponentLong\n"
-        + "      @test.ScopeB test.ComponentMedium\n"
-        + "      @test.ScopeA test.ComponentShort";
+
     Compilation compilation =
         daggerCompiler().compile(type, scopeA, scopeB, longLifetime, mediumLifetime, shortLifetime);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.ComponentShort depends on scoped components in a non-hierarchical scope "
+                    + "ordering:",
+                "    @test.ScopeA test.ComponentLong",
+                "    @test.ScopeB test.ComponentMedium",
+                "    @test.ScopeA test.ComponentShort"));
   }
 
   @Test
diff --git a/javatests/dagger/internal/codegen/GraphValidationTest.java b/javatests/dagger/internal/codegen/GraphValidationTest.java
index cd64d7685..f9821b3c6 100644
--- a/javatests/dagger/internal/codegen/GraphValidationTest.java
+++ b/javatests/dagger/internal/codegen/GraphValidationTest.java
@@ -22,7 +22,6 @@
 import static dagger.internal.codegen.NonNullableRequestForNullableBindingValidation.nullableToNonNullable;
 import static dagger.internal.codegen.TestUtils.message;
 
-import com.google.common.base.Joiner;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
@@ -125,12 +124,15 @@
         "    A getA();",
         "  }",
         "}");
-    String expectedError =
-        "test.TestClass.A cannot be provided without an @Inject constructor or an "
-            + "@Provides-annotated method.";
+
     Compilation compilation = daggerCompiler().compile(component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(15);
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.TestClass.A cannot be provided without an @Inject constructor or an "
+                + "@Provides-annotated method.")
+        .inFile(component)
+        .onLine(15);
   }
 
   @Test public void membersInjectWithoutProvision() {
@@ -156,13 +158,16 @@
         "    B getB();",
         "  }",
         "}");
-    String expectedError =
-        "test.TestClass.B cannot be provided without an @Inject constructor or an "
-            + "@Provides-annotated method. This type supports members injection but cannot be "
-            + "implicitly provided.";
+
     Compilation compilation = daggerCompiler().compile(component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(19);
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.TestClass.B cannot be provided without an @Inject constructor or an "
+                + "@Provides-annotated method. This type supports members injection but cannot be "
+                + "implicitly provided.")
+        .inFile(component)
+        .onLine(19);
   }
 
   @Test
@@ -190,18 +195,18 @@ public void membersInjectDependsOnUnboundedType() {
             "interface TestComponent {",
             "  void injectsUnboundedType(InjectsUnboundedType injects);",
             "}");
+
     Compilation compilation = daggerCompiler().compile(injectsUnboundedType, component);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            Joiner.on('\n')
-                .join(
-                    "Cannot inject members into types with unbounded type arguments: "
-                        + "java.util.ArrayList<?>",
-                    "      dagger.MembersInjector<java.util.ArrayList<?>> is injected at",
-                    "          test.InjectsUnboundedType.listInjector",
-                    "      test.InjectsUnboundedType is injected at",
-                    "          test.TestComponent.injectsUnboundedType(test.InjectsUnboundedType)"))
+            message(
+                "Cannot inject members into types with unbounded type arguments: "
+                    + "java.util.ArrayList<?>",
+                "    dagger.MembersInjector<java.util.ArrayList<?>> is injected at",
+                "        test.InjectsUnboundedType.listInjector",
+                "    test.InjectsUnboundedType is injected at",
+                "        test.TestComponent.injectsUnboundedType(test.InjectsUnboundedType)"))
         .inFile(component)
         .onLine(7);
   }
@@ -348,22 +353,22 @@ public void staticFieldInjection() {
         "  }",
         "}");
 
-    String expectedError =
-        Joiner.on('\n')
-            .join(
-                "Found a dependency cycle:",
-                "      test.Outer.C is injected at",
-                "          test.Outer.A.<init>(cParam)",
-                "      test.Outer.A is injected at",
-                "          test.Outer.B.<init>(aParam)",
-                "      test.Outer.B is injected at",
-                "          test.Outer.C.<init>(bParam)",
-                "      test.Outer.C is provided at",
-                "          test.Outer.CComponent.getC()");
-
     Compilation compilation = daggerCompiler().compile(component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(23);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    test.Outer.C is injected at",
+                "        test.Outer.A.<init>(cParam)",
+                "    test.Outer.A is injected at",
+                "        test.Outer.B.<init>(aParam)",
+                "    test.Outer.B is injected at",
+                "        test.Outer.C.<init>(bParam)",
+                "    test.Outer.C is provided at",
+                "        test.Outer.CComponent.getC()"))
+        .inFile(component)
+        .onLine(23);
   }
 
   @Test public void cyclicDependencyNotIncludingEntryPoint() {
@@ -400,24 +405,24 @@ public void staticFieldInjection() {
             "  }",
             "}");
 
-    String expectedError =
-        Joiner.on('\n')
-            .join(
-                "Found a dependency cycle:",
-                "      test.Outer.C is injected at",
-                "          test.Outer.A.<init>(cParam)",
-                "      test.Outer.A is injected at",
-                "          test.Outer.B.<init>(aParam)",
-                "      test.Outer.B is injected at",
-                "          test.Outer.C.<init>(bParam)",
-                "      test.Outer.C is injected at",
-                "          test.Outer.D.<init>(cParam)",
-                "      test.Outer.D is provided at",
-                "          test.Outer.DComponent.getD()");
-
     Compilation compilation = daggerCompiler().compile(component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(27);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    test.Outer.C is injected at",
+                "        test.Outer.A.<init>(cParam)",
+                "    test.Outer.A is injected at",
+                "        test.Outer.B.<init>(aParam)",
+                "    test.Outer.B is injected at",
+                "        test.Outer.C.<init>(bParam)",
+                "    test.Outer.C is injected at",
+                "        test.Outer.D.<init>(cParam)",
+                "    test.Outer.D is provided at",
+                "        test.Outer.DComponent.getD()"))
+        .inFile(component)
+        .onLine(27);
   }
 
   @Test
@@ -474,16 +479,16 @@ public void cyclicDependencyNotBrokenByMapBinding() {
         .hadErrorContaining(
             message(
                 "Found a dependency cycle:",
-                "test.Outer.C is injected at",
-                "    test.Outer.CModule.c(c)",
-                "java.util.Map<java.lang.String,test.Outer.C> is injected at",
-                "    test.Outer.A.<init>(cMap)",
-                "test.Outer.A is injected at",
-                "    test.Outer.B.<init>(aParam)",
-                "test.Outer.B is injected at",
-                "    test.Outer.C.<init>(bParam)",
-                "test.Outer.C is provided at",
-                "    test.Outer.CComponent.getC()"))
+                "    test.Outer.C is injected at",
+                "        test.Outer.CModule.c(c)",
+                "    java.util.Map<java.lang.String,test.Outer.C> is injected at",
+                "        test.Outer.A.<init>(cMap)",
+                "    test.Outer.A is injected at",
+                "        test.Outer.B.<init>(aParam)",
+                "    test.Outer.B is injected at",
+                "        test.Outer.C.<init>(bParam)",
+                "    test.Outer.C is provided at",
+                "        test.Outer.CComponent.getC()"))
         .inFile(component)
         .onLineContaining("C getC();");
   }
@@ -529,24 +534,24 @@ public void cyclicDependencyWithSetBinding() {
             "  }",
             "}");
 
-    String expectedError =
-        Joiner.on('\n')
-            .join(
-                "Found a dependency cycle:",
-                "      test.Outer.C is injected at",
-                "          test.Outer.CModule.c(c)",
-                "      java.util.Set<test.Outer.C> is injected at",
-                "          test.Outer.A.<init>(cSet)",
-                "      test.Outer.A is injected at",
-                "          test.Outer.B.<init>(aParam)",
-                "      test.Outer.B is injected at",
-                "          test.Outer.C.<init>(bParam)",
-                "      test.Outer.C is provided at",
-                "          test.Outer.CComponent.getC()");
-
     Compilation compilation = daggerCompiler().compile(component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(25);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    test.Outer.C is injected at",
+                "        test.Outer.CModule.c(c)",
+                "    java.util.Set<test.Outer.C> is injected at",
+                "        test.Outer.A.<init>(cSet)",
+                "    test.Outer.A is injected at",
+                "        test.Outer.B.<init>(aParam)",
+                "    test.Outer.B is injected at",
+                "        test.Outer.C.<init>(bParam)",
+                "    test.Outer.C is provided at",
+                "        test.Outer.CComponent.getC()"))
+        .inFile(component)
+        .onLine(25);
   }
 
   @Test
@@ -585,24 +590,24 @@ public void falsePositiveCyclicDependencyIndirectionDetected() {
             "  }",
             "}");
 
-    String expectedError =
-        Joiner.on('\n')
-            .join(
-                "Found a dependency cycle:",
-                "      test.Outer.C is injected at",
-                "          test.Outer.A.<init>(cParam)",
-                "      test.Outer.A is injected at",
-                "          test.Outer.B.<init>(aParam)",
-                "      test.Outer.B is injected at",
-                "          test.Outer.C.<init>(bParam)",
-                "      javax.inject.Provider<test.Outer.C> is injected at",
-                "          test.Outer.D.<init>(cParam)",
-                "      test.Outer.D is provided at",
-                "          test.Outer.DComponent.getD()");
-
     Compilation compilation = daggerCompiler().compile(component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(28);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    test.Outer.C is injected at",
+                "        test.Outer.A.<init>(cParam)",
+                "    test.Outer.A is injected at",
+                "        test.Outer.B.<init>(aParam)",
+                "    test.Outer.B is injected at",
+                "        test.Outer.C.<init>(bParam)",
+                "    javax.inject.Provider<test.Outer.C> is injected at",
+                "        test.Outer.D.<init>(cParam)",
+                "    test.Outer.D is provided at",
+                "        test.Outer.DComponent.getD()"))
+        .inFile(component)
+        .onLine(28);
   }
 
   @Test
@@ -616,7 +621,7 @@ public void cyclicDependencyInSubcomponents() {
             "",
             "@Component",
             "interface Parent {",
-            "  Child child();",
+            "  Child.Builder child();",
             "}");
     JavaFileObject child =
         JavaFileObjects.forSourceLines(
@@ -625,9 +630,14 @@ public void cyclicDependencyInSubcomponents() {
             "",
             "import dagger.Subcomponent;",
             "",
-            "@Subcomponent(modules = ChildModule.class)",
+            "@Subcomponent(modules = CycleModule.class)",
             "interface Child {",
-            "  Grandchild grandchild();",
+            "  Grandchild.Builder grandchild();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Child build();",
+            "  }",
             "}");
     JavaFileObject grandchild =
         JavaFileObjects.forSourceLines(
@@ -639,17 +649,104 @@ public void cyclicDependencyInSubcomponents() {
             "@Subcomponent",
             "interface Grandchild {",
             "  String entry();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Grandchild build();",
+            "  }",
             "}");
-    JavaFileObject childModule =
+    JavaFileObject cycleModule =
+        JavaFileObjects.forSourceLines(
+            "test.CycleModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "abstract class CycleModule {",
+            "  @Provides static Object object(String string) {",
+            "    return string;",
+            "  }",
+            "",
+            "  @Provides static String string(Object object) {",
+            "    return object.toString();",
+            "  }",
+            "}");
+
+    Compilation compilation = daggerCompiler().compile(parent, child, grandchild, cycleModule);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "Found a dependency cycle:",
+                "    java.lang.String is injected at",
+                "        test.CycleModule.object(string)",
+                "    java.lang.Object is injected at",
+                "        test.CycleModule.string(object)",
+                "    java.lang.String is provided at",
+                "        test.Grandchild.entry()"))
+        .inFile(parent)
+        .onLineContaining("interface Parent");
+  }
+
+  @Test
+  public void cyclicDependencyInSubcomponentsWithChildren() {
+    JavaFileObject parent =
+        JavaFileObjects.forSourceLines(
+            "test.Parent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface Parent {",
+            "  Child.Builder child();",
+            "}");
+    JavaFileObject child =
+        JavaFileObjects.forSourceLines(
+            "test.Child",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent(modules = CycleModule.class)",
+            "interface Child {",
+            "  String entry();",
+            "",
+            "  Grandchild grandchild();",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Child build();",
+            "  }",
+            "}");
+    // Grandchild has no entry point that depends on the cycle. http://b/111317986
+    JavaFileObject grandchild =
+        JavaFileObjects.forSourceLines(
+            "test.Grandchild",
+            "package test;",
+            "",
+            "import dagger.Subcomponent;",
+            "",
+            "@Subcomponent",
+            "interface Grandchild {",
+            "",
+            "  @Subcomponent.Builder",
+            "  interface Builder {",
+            "    Grandchild build();",
+            "  }",
+            "}");
+    JavaFileObject cycleModule =
         JavaFileObjects.forSourceLines(
-            "test.ChildModule",
+            "test.CycleModule",
             "package test;",
             "",
             "import dagger.Module;",
             "import dagger.Provides;",
             "",
             "@Module",
-            "abstract class ChildModule {",
+            "abstract class CycleModule {",
             "  @Provides static Object object(String string) {",
             "    return string;",
             "  }",
@@ -659,20 +756,20 @@ public void cyclicDependencyInSubcomponents() {
             "  }",
             "}");
 
-    Compilation compilation = daggerCompiler().compile(parent, child, grandchild, childModule);
+    Compilation compilation = daggerCompiler().compile(parent, child, grandchild, cycleModule);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
             message(
-                "[test.Grandchild.entry()] Found a dependency cycle:",
-                "java.lang.String is injected at",
-                "    test.ChildModule.object(string)",
-                "java.lang.Object is injected at",
-                "    test.ChildModule.string(object)",
-                "java.lang.String is provided at",
-                "    test.Grandchild.entry()"))
+                "[test.Child.entry()] Found a dependency cycle:",
+                "    java.lang.String is injected at",
+                "        test.CycleModule.object(string)",
+                "    java.lang.Object is injected at",
+                "        test.CycleModule.string(object)",
+                "    java.lang.String is provided at",
+                "        test.Child.entry()"))
         .inFile(parent)
-        .onLineContaining("interface Parent {");
+        .onLineContaining("interface Parent");
   }
 
   @Test
@@ -716,12 +813,12 @@ public void circularBindsMethods() {
         .hadErrorContaining(
             message(
                 "Found a dependency cycle:",
-                "java.lang.Object is injected at",
-                "    test.TestModule.bindQualified(unqualified)",
-                "@test.SomeQualifier java.lang.Object is injected at",
-                "    test.TestModule.bindUnqualified(qualified)",
-                "java.lang.Object is provided at",
-                "    test.TestComponent.unqualified()"))
+                "    java.lang.Object is injected at",
+                "        test.TestModule.bindQualified(unqualified)",
+                "    @test.SomeQualifier java.lang.Object is injected at",
+                "        test.TestModule.bindUnqualified(qualified)",
+                "    java.lang.Object is provided at",
+                "        test.TestComponent.unqualified()"))
         .inFile(component)
         .onLineContaining("unqualified();");
   }
@@ -756,11 +853,12 @@ public void selfReferentialBinds() {
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            "Found a dependency cycle:\n"
-                + "      java.lang.Object is injected at\n"
-                + "          test.TestModule.bindToSelf(sameKey)\n"
-                + "      java.lang.Object is provided at\n"
-                + "          test.TestComponent.selfReferential()")
+            message(
+                "Found a dependency cycle:",
+                "    java.lang.Object is injected at",
+                "        test.TestModule.bindToSelf(sameKey)",
+                "    java.lang.Object is provided at",
+                "        test.TestComponent.selfReferential()"))
         .inFile(component)
         .onLine(7);
   }
@@ -805,17 +903,16 @@ public void cycleFromMembersInjectionMethod_WithSameKeyAsMembersInjectionMethod(
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            Joiner.on('\n')
-                .join(
-                    "Found a dependency cycle:",
-                    "      test.B is injected at",
-                    "          test.A.b",
-                    "      test.A is injected at",
-                    "          test.B.a",
-                    "      test.B is injected at",
-                    "          test.A.b",
-                    "      test.A is injected at",
-                    "          test.CycleComponent.inject(test.A)"))
+            message(
+                "Found a dependency cycle:",
+                "    test.B is injected at",
+                "        test.A.b",
+                "    test.A is injected at",
+                "        test.B.a",
+                "    test.B is injected at",
+                "        test.A.b",
+                "    test.A is injected at",
+                "        test.CycleComponent.inject(test.A)"))
         .inFile(component)
         .onLineContaining("void inject(A a);");
   }
@@ -886,6 +983,37 @@ public void missingBindingWithSameKeyAsMembersInjectionMethod() {
         .onLineContaining("void inject(Self target);");
   }
 
+  @Test
+  public void genericInjectClassWithWildcardDependencies() {
+    JavaFileObject component =
+        JavaFileObjects.forSourceLines(
+            "test.TestComponent",
+            "package test;",
+            "",
+            "import dagger.Component;",
+            "",
+            "@Component",
+            "interface TestComponent {",
+            "  Foo<? extends Number> foo();",
+            "}");
+    JavaFileObject foo =
+        JavaFileObjects.forSourceLines(
+            "test.Foo",
+            "package test;",
+            "",
+            "import javax.inject.Inject;",
+            "",
+            "final class Foo<T> {",
+            "  @Inject Foo(T t) {}",
+            "}");
+    Compilation compilation = daggerCompiler().compile(component, foo);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.Foo<? extends java.lang.Number> cannot be provided "
+                + "without an @Provides-annotated method");
+  }
+
   @Test public void duplicateExplicitBindings_ProvidesAndComponentProvision() {
     JavaFileObject component = JavaFileObjects.forSourceLines("test.Outer",
         "package test;",
@@ -921,15 +1049,16 @@ public void missingBindingWithSameKeyAsMembersInjectionMethod() {
         "  }",
         "}");
 
-    String expectedError =
-        message(
-            "test.Outer.A is bound multiple times:",
-            "@Provides test.Outer.A test.Outer.AModule.provideA(String)",
-            "test.Outer.A test.Outer.Parent.getA()");
-
     Compilation compilation = daggerCompiler().compile(component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(30);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.Outer.A is bound multiple times:",
+                "    @Provides test.Outer.A test.Outer.AModule.provideA(String)",
+                "    test.Outer.A test.Outer.Parent.getA()"))
+        .inFile(component)
+        .onLine(30);
   }
 
   @Test public void duplicateExplicitBindings_TwoProvidesMethods() {
@@ -961,13 +1090,16 @@ public void missingBindingWithSameKeyAsMembersInjectionMethod() {
         "  }",
         "}");
 
-    String expectedError = "test.Outer.A is bound multiple times:\n"
-        + "      @Provides test.Outer.A test.Outer.Module1.provideA1()\n"
-        + "      @Provides test.Outer.A test.Outer.Module2.provideA2(String)";
-
     Compilation compilation = daggerCompiler().compile(component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(24);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.Outer.A is bound multiple times:",
+                "    @Provides test.Outer.A test.Outer.Module1.provideA1()",
+                "    @Provides test.Outer.A test.Outer.Module2.provideA2(String)"))
+        .inFile(component)
+        .onLine(24);
   }
 
   @Test
@@ -1010,11 +1142,10 @@ public void duplicateExplicitBindings_ProvidesVsBinds() {
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            Joiner.on("\n      ")
-                .join(
-                    "test.Outer.A is bound multiple times:",
-                    "@Provides test.Outer.A test.Outer.Module1.provideA1()",
-                    "@Binds test.Outer.A test.Outer.Module2.bindA2(test.Outer.B)"))
+            message(
+                "test.Outer.A is bound multiple times:",
+                "    @Provides test.Outer.A test.Outer.Module1.provideA1()",
+                "    @Binds test.Outer.A test.Outer.Module2.bindA2(test.Outer.B)"))
         .inFile(component)
         .onLine(28);
   }
@@ -1077,35 +1208,39 @@ public void duplicateExplicitBindings_ProvidesVsBinds() {
         "  }",
         "}");
 
-    String expectedSetError =
-        message(
-            "java.util.Set<java.lang.String> has incompatible bindings or declarations:",
-            "Set bindings and declarations:",
-            "    @Binds @dagger.multibindings.IntoSet String "
-                + "test.Outer.TestModule1.bindStringSetElement(@test.Outer.SomeQualifier String)",
-            "    @Provides @dagger.multibindings.IntoSet String "
-                + "test.Outer.TestModule1.stringSetElement()",
-            "Unique bindings and declarations:",
-            "    @Provides Set<String> test.Outer.TestModule2.stringSet()");
-
-    String expectedMapError =
-        message(
-            "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
-                + "or declarations:",
-            "Map bindings and declarations:",
-            "    @Binds @dagger.multibindings.IntoMap "
-                + "@test.Outer.StringKey(\"bar\") String"
-                + " test.Outer.TestModule1.bindStringMapEntry(@test.Outer.SomeQualifier String)",
-            "    @Provides @dagger.multibindings.IntoMap "
-                + "@test.Outer.StringKey(\"foo\") String"
-                + " test.Outer.TestModule1.stringMapEntry()",
-            "Unique bindings and declarations:",
-            "    @Provides Map<String,String> test.Outer.TestModule2.stringMap()");
-
     Compilation compilation = daggerCompiler().compile(component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedSetError).inFile(component).onLine(52);
-    assertThat(compilation).hadErrorContaining(expectedMapError).inFile(component).onLine(53);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.util.Set<java.lang.String> has incompatible bindings or declarations:",
+                "    Set bindings and declarations:",
+                "        @Binds @dagger.multibindings.IntoSet String "
+                    + "test.Outer.TestModule1.bindStringSetElement(@test.Outer.SomeQualifier "
+                    + "String)",
+                "        @Provides @dagger.multibindings.IntoSet String "
+                    + "test.Outer.TestModule1.stringSetElement()",
+                "    Unique bindings and declarations:",
+                "        @Provides Set<String> test.Outer.TestModule2.stringSet()"))
+        .inFile(component)
+        .onLine(52);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
+                    + "or declarations:",
+                "    Map bindings and declarations:",
+                "        @Binds @dagger.multibindings.IntoMap "
+                    + "@test.Outer.StringKey(\"bar\") String"
+                    + " test.Outer.TestModule1.bindStringMapEntry(@test.Outer.SomeQualifier "
+                    + "String)",
+                "        @Provides @dagger.multibindings.IntoMap "
+                    + "@test.Outer.StringKey(\"foo\") String"
+                    + " test.Outer.TestModule1.stringMapEntry()",
+                "    Unique bindings and declarations:",
+                "        @Provides Map<String,String> test.Outer.TestModule2.stringMap()"))
+        .inFile(component)
+        .onLine(53);
   }
 
   @Test
@@ -1149,27 +1284,31 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
             "  }",
             "}");
 
-    String expectedSetError =
-        "java.util.Set<java.lang.String> has incompatible bindings or declarations:\n"
-            + "      Set bindings and declarations:\n"
-            + "          @dagger.multibindings.Multibinds Set<String> "
-            + "test.Outer.TestModule1.stringSet()\n"
-            + "      Unique bindings and declarations:\n"
-            + "          @Provides Set<String> test.Outer.TestModule2.stringSet()";
-
-    String expectedMapError =
-        "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
-            + "or declarations:\n"
-            + "      Map bindings and declarations:\n"
-            + "          @dagger.multibindings.Multibinds Map<String,String> "
-            + "test.Outer.TestModule1.stringMap()\n"
-            + "      Unique bindings and declarations:\n"
-            + "          @Provides Map<String,String> test.Outer.TestModule2.stringMap()";
-
     Compilation compilation = daggerCompiler().compile(component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedSetError).inFile(component).onLine(32);
-    assertThat(compilation).hadErrorContaining(expectedMapError).inFile(component).onLine(33);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.util.Set<java.lang.String> has incompatible bindings or declarations:",
+                "    Set bindings and declarations:",
+                "        @dagger.multibindings.Multibinds Set<String> "
+                    + "test.Outer.TestModule1.stringSet()",
+                "    Unique bindings and declarations:",
+                "        @Provides Set<String> test.Outer.TestModule2.stringSet()"))
+        .inFile(component)
+        .onLine(32);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.util.Map<java.lang.String,java.lang.String> has incompatible bindings "
+                    + "or declarations:",
+                "    Map bindings and declarations:",
+                "        @dagger.multibindings.Multibinds Map<String,String> "
+                    + "test.Outer.TestModule1.stringMap()",
+                "    Unique bindings and declarations:",
+                "        @Provides Map<String,String> test.Outer.TestModule2.stringMap()"))
+        .inFile(component)
+        .onLine(33);
   }
 
   @Test public void duplicateBindings_TruncateAfterLimit() {
@@ -1271,17 +1410,17 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
         .hadErrorContaining(
             message(
                 "test.Outer.A is bound multiple times:",
-                "@Provides test.Outer.A test.Outer.Module01.provideA()",
-                "@Provides test.Outer.A test.Outer.Module02.provideA()",
-                "@Provides test.Outer.A test.Outer.Module03.provideA()",
-                "@Provides test.Outer.A test.Outer.Module04.provideA()",
-                "@Provides test.Outer.A test.Outer.Module05.provideA()",
-                "@Provides test.Outer.A test.Outer.Module06.provideA()",
-                "@Provides test.Outer.A test.Outer.Module07.provideA()",
-                "@Provides test.Outer.A test.Outer.Module08.provideA()",
-                "@Provides test.Outer.A test.Outer.Module09.provideA()",
-                "@Provides test.Outer.A test.Outer.Module10.provideA()",
-                "and 2 others"))
+                "    @Provides test.Outer.A test.Outer.Module01.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module02.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module03.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module04.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module05.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module06.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module07.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module08.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module09.provideA()",
+                "    @Provides test.Outer.A test.Outer.Module10.provideA()",
+                "    and 2 others"))
         .inFile(component)
         .onLineContaining("getA();");
   }
@@ -1337,30 +1476,30 @@ public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration()
             "  }",
             "}");
     String errorText = "test.TestClass.A cannot be provided without an @Provides-annotated method.";
-    String firstError =
-        message(
-            errorText,
-            "test.TestClass.A is injected at",
-            "    test.TestClass.B.<init>(a)",
-            "test.TestClass.B is injected at",
-            "    test.TestClass.DImpl.<init>(, b)",
-            "test.TestClass.DImpl is injected at",
-            "    test.TestClass.DModule.d(, impl, )",
-            "@javax.inject.Named(\"slim shady\") test.TestClass.D is provided at",
-            "    test.TestClass.AComponent.getFoo()");
     String otherErrorFormat =
         message(
             errorText,
-            "test.TestClass.A is injected at",
-            "    test.TestClass.B.<init>(a)",
-            "test.TestClass.B is injected at",
-            "    test.TestClass.C.b",
-            "test.TestClass.C is %s at",
-            "    test.TestClass.AComponent.%s");
+            "    test.TestClass.A is injected at",
+            "        test.TestClass.B.<init>(a)",
+            "    test.TestClass.B is injected at",
+            "        test.TestClass.C.b",
+            "    test.TestClass.C is %s at",
+            "        test.TestClass.AComponent.%s");
+
     Compilation compilation = daggerCompiler().compile(component);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining(firstError)
+        .hadErrorContaining(
+            message(
+                errorText,
+                "    test.TestClass.A is injected at",
+                "        test.TestClass.B.<init>(a)",
+                "    test.TestClass.B is injected at",
+                "        test.TestClass.DImpl.<init>(, b)",
+                "    test.TestClass.DImpl is injected at",
+                "        test.TestClass.DModule.d(, impl, )",
+                "    @javax.inject.Named(\"slim shady\") test.TestClass.D is provided at",
+                "        test.TestClass.AComponent.getFoo()"))
         .inFile(component)
         .onLineContaining("getFoo();");
     assertThat(compilation)
@@ -1413,21 +1552,21 @@ public void bindsMethodAppearsInTrace() {
             "interface TestModule {",
             "  @Binds abstract TestInterface bindTestInterface(TestImplementation implementation);",
             "}");
+
     Compilation compilation =
         daggerCompiler().compile(component, module, interfaceFile, implementationFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            Joiner.on("\n      ")
-                .join(
-                    "java.lang.String cannot be provided without an @Inject constructor or an "
-                        + "@Provides-annotated method.",
-                    "java.lang.String is injected at",
-                    "    TestImplementation.<init>(missingBinding)",
-                    "TestImplementation is injected at",
-                    "    TestModule.bindTestInterface(implementation)",
-                    "TestInterface is provided at",
-                    "    TestComponent.testInterface()"))
+            message(
+                "java.lang.String cannot be provided without an @Inject constructor or an "
+                    + "@Provides-annotated method.",
+                "    java.lang.String is injected at",
+                "        TestImplementation.<init>(missingBinding)",
+                "    TestImplementation is injected at",
+                "        TestModule.bindTestInterface(implementation)",
+                "    TestInterface is provided at",
+                "        TestComponent.testInterface()"))
         .inFile(component)
         .onLine(5);
   }
@@ -1507,12 +1646,12 @@ public void bindsMissingRightHandSide() {
             "\\Qtest.Duplicates.NotBound cannot be provided\\E|"
                 + message(
                     "\\Qtest.Duplicates.BoundTwice is bound multiple times:",
-                    "@Binds test.Duplicates.BoundTwice "
+                    "    @Binds test.Duplicates.BoundTwice "
                         + "test.Duplicates.DuplicatesModule"
                         + ".bindWithResolvedKey(test.Duplicates.BoundImpl)",
-                    "@Binds test.Duplicates.BoundTwice "
+                    "    @Binds test.Duplicates.BoundTwice "
                         + "test.Duplicates.DuplicatesModule"
-                        + ".bindWithUnresolvedKey(test.Duplicates.NotBound)"))
+                        + ".bindWithUnresolvedKey(test.Duplicates.NotBound"))
         .inFile(component)
         .onLineContaining("boundTwice();");
     assertThat(compilation)
@@ -1572,21 +1711,21 @@ public void bindsMissingRightHandSide() {
         "interface TestComponent {",
         "  UsesTest usesTest();",
         "}");
-    String expectedMsg =
-        Joiner.on("\n")
-            .join(
-                "java.util.List cannot be provided without an @Provides-annotated method.",
-                "      java.util.List is injected at",
-                "          test.TestClass.<init>(list)",
-                "      test.TestClass is injected at",
-                "          test.Generic.<init>(t)",
-                "      test.Generic<test.TestClass> is injected at",
-                "          test.UsesTest.<init>(genericTestClass)",
-                "      test.UsesTest is provided at",
-                "          test.TestComponent.usesTest()");
+
     Compilation compilation = daggerCompiler().compile(generic, testClass, usesTest, component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedMsg);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.util.List cannot be provided without an @Provides-annotated method.",
+                "    java.util.List is injected at",
+                "        test.TestClass.<init>(list)",
+                "    test.TestClass is injected at",
+                "        test.Generic.<init>(t)",
+                "    test.Generic<test.TestClass> is injected at",
+                "        test.UsesTest.<init>(genericTestClass)",
+                "    test.UsesTest is provided at",
+                "        test.TestComponent.usesTest()"));
   }
 
   @Test public void resolvedVariablesInDependencyTrace() {
@@ -1626,21 +1765,21 @@ public void bindsMissingRightHandSide() {
         "interface TestComponent {",
         "  UsesTest usesTest();",
         "}");
-    String expectedMsg =
-        Joiner.on("\n")
-            .join(
-                "java.util.List cannot be provided without an @Provides-annotated method.",
-                "      java.util.List is injected at",
-                "          test.TestClass.<init>(list)",
-                "      test.TestClass is injected at",
-                "          test.Generic.t",
-                "      test.Generic<test.TestClass> is injected at",
-                "          test.UsesTest.<init>(genericTestClass)",
-                "      test.UsesTest is provided at",
-                "          test.TestComponent.usesTest()");
+
     Compilation compilation = daggerCompiler().compile(generic, testClass, usesTest, component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedMsg);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "java.util.List cannot be provided without an @Provides-annotated method.",
+                "    java.util.List is injected at",
+                "        test.TestClass.<init>(list)",
+                "    test.TestClass is injected at",
+                "        test.Generic.t",
+                "    test.Generic<test.TestClass> is injected at",
+                "        test.UsesTest.<init>(genericTestClass)",
+                "    test.UsesTest is provided at",
+                "        test.TestComponent.usesTest()"));
   }
 
   @Test public void nullCheckForConstructorParameters() {
@@ -2003,12 +2142,14 @@ public void nullCheckForOptionalProviderOfLazy() {
         "@Component(dependencies = ComponentShort.class)",
         "interface ComponentShort {",
         "}");
-    String errorMessage =
-        "test.ComponentShort contains a cycle in its component dependencies:\n"
-            + "      test.ComponentShort";
+
     Compilation compilation = daggerCompiler().compile(shortLifetime);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(errorMessage);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.ComponentShort contains a cycle in its component dependencies:",
+                "    test.ComponentShort"));
   }
 
   @Test public void componentDependencyMustNotCycle_Indirect() {
@@ -2036,27 +2177,34 @@ public void nullCheckForOptionalProviderOfLazy() {
         "@Component(dependencies = ComponentMedium.class)",
         "interface ComponentShort {",
         "}");
-    String longErrorMessage =
-        "test.ComponentLong contains a cycle in its component dependencies:\n"
-            + "      test.ComponentLong\n"
-            + "      test.ComponentMedium\n"
-            + "      test.ComponentLong";
-    String mediumErrorMessage =
-        "test.ComponentMedium contains a cycle in its component dependencies:\n"
-            + "      test.ComponentMedium\n"
-            + "      test.ComponentLong\n"
-            + "      test.ComponentMedium";
-    String shortErrorMessage =
-        "test.ComponentShort contains a cycle in its component dependencies:\n"
-            + "      test.ComponentMedium\n"
-            + "      test.ComponentLong\n"
-            + "      test.ComponentMedium\n"
-            + "      test.ComponentShort";
+
     Compilation compilation = daggerCompiler().compile(longLifetime, mediumLifetime, shortLifetime);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(longErrorMessage).inFile(longLifetime);
-    assertThat(compilation).hadErrorContaining(mediumErrorMessage).inFile(mediumLifetime);
-    assertThat(compilation).hadErrorContaining(shortErrorMessage).inFile(shortLifetime);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.ComponentLong contains a cycle in its component dependencies:",
+                "    test.ComponentLong",
+                "    test.ComponentMedium",
+                "    test.ComponentLong"))
+        .inFile(longLifetime);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.ComponentMedium contains a cycle in its component dependencies:",
+                "    test.ComponentMedium",
+                "    test.ComponentLong",
+                "    test.ComponentMedium"))
+        .inFile(mediumLifetime);
+    assertThat(compilation)
+        .hadErrorContaining(
+            message(
+                "test.ComponentShort contains a cycle in its component dependencies:",
+                "    test.ComponentMedium",
+                "    test.ComponentLong",
+                "    test.ComponentMedium",
+                "    test.ComponentShort"))
+        .inFile(shortLifetime);
   }
 
   @Test
@@ -2103,14 +2251,15 @@ public void childBindingConflictsWithParent() {
             "    }",
             "  }",
             "}");
+
     Compilation compilation = daggerCompiler().compile(aComponent, bComponent);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
             message(
-                "[test.B.conflict()] java.lang.Object is bound multiple times:",
-                "@Provides Object test.A.AModule.abConflict()",
-                "@Provides Object test.B.BModule.abConflict()"))
+                "java.lang.Object is bound multiple times:",
+                "    @Provides Object test.A.AModule.abConflict()",
+                "    @Provides Object test.B.BModule.abConflict()"))
         .inFile(aComponent)
         .onLineContaining("interface A {");
   }
@@ -2170,14 +2319,15 @@ public void grandchildBindingConflictsWithGrandparent() {
             "    }",
             "  }",
             "}");
+
     Compilation compilation = daggerCompiler().compile(aComponent, bComponent, cComponent);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
             message(
-                "[test.C.conflict()] java.lang.Object is bound multiple times:",
-                "@Provides Object test.A.AModule.acConflict()",
-                "@Provides Object test.C.CModule.acConflict()"))
+                "java.lang.Object is bound multiple times:",
+                "    @Provides Object test.A.AModule.acConflict()",
+                "    @Provides Object test.C.CModule.acConflict()"))
         .inFile(aComponent)
         .onLineContaining("interface A {");
   }
@@ -2237,14 +2387,15 @@ public void grandchildBindingConflictsWithChild() {
             "    }",
             "  }",
             "}");
+
     Compilation compilation = daggerCompiler().compile(aComponent, bComponent, cComponent);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
             message(
-                "[test.C.conflict()] java.lang.Object is bound multiple times:",
-                "@Provides Object test.B.BModule.bcConflict()",
-                "@Provides Object test.C.CModule.bcConflict()"))
+                "java.lang.Object is bound multiple times:",
+                "    @Provides Object test.B.BModule.bcConflict()",
+                "    @Provides Object test.C.CModule.bcConflict()"))
         .inFile(aComponent)
         .onLineContaining("interface A {");
   }
@@ -2292,6 +2443,7 @@ public void grandchildBindingConflictsWithParentWithNullableViolationAsWarning()
             "    }",
             "  }",
             "}");
+
     Compilation compilation =
         javac()
             .withOptions("-Adagger.nullableValidation=WARNING")
@@ -2301,10 +2453,9 @@ public void grandchildBindingConflictsWithParentWithNullableViolationAsWarning()
     assertThat(compilation)
         .hadErrorContaining(
             message(
-                "[test.Child.parentChildConflictThatViolatesNullability()] "
-                    + "java.lang.Object is bound multiple times:",
-                "@Provides Object test.Child.ChildModule.nonNullableParentChildConflict()",
-                "@Provides @javax.annotation.Nullable Object"
+                "java.lang.Object is bound multiple times:",
+                "    @Provides Object test.Child.ChildModule.nonNullableParentChildConflict()",
+                "    @Provides @javax.annotation.Nullable Object"
                     + " test.ParentConflictsWithChild.ParentModule.nullableParentChildConflict()"))
         .inFile(parentConflictsWithChild)
         .onLine(9);
@@ -2355,6 +2506,7 @@ public void bindingUsedOnlyInSubcomponentDependsOnBindingOnlyInSubcomponent() {
             "    return \"child string\";",
             "  }",
             "}");
+
     Compilation compilation = daggerCompiler().compile(parent, parentModule, child, childModule);
     assertThat(compilation).failed();
     assertThat(compilation)
@@ -2643,6 +2795,7 @@ public void releasableReferenceManagerConflict() {
             "  Set<ReleasableReferenceManager> managers();",
             "  Set<TypedReleasableReferenceManager<TestMetadata>> typedManagers();",
             "}");
+
     Compilation compilation =
         daggerCompiler().compile(testScope, testMetadata, testModule, component);
     assertThat(compilation).failed();
@@ -2652,9 +2805,9 @@ public void releasableReferenceManagerConflict() {
                 message(
                     "@%1$s.ForReleasableReferences(test.TestScope.class) "
                         + "%1$s.ReleasableReferenceManager is bound multiple times:",
-                    "@Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
+                    "    @Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
                         + "%1$s.ReleasableReferenceManager test.TestModule.rrm()",
-                    "binding for "
+                    "    binding for "
                         + "@%1$s.ForReleasableReferences(value = test.TestScope.class) "
                         + "%1$s.ReleasableReferenceManager from the scope declaration"),
                 "dagger.releasablereferences"))
@@ -2667,10 +2820,10 @@ public void releasableReferenceManagerConflict() {
                     "@%1$s.ForReleasableReferences(test.TestScope.class) "
                         + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
                         + "is bound multiple times:",
-                    "@Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
+                    "    @Provides @%1$s.ForReleasableReferences(test.TestScope.class) "
                         + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
                         + "test.TestModule.typedRrm()",
-                    "binding for "
+                    "    binding for "
                         + "@%1$s.ForReleasableReferences(value = test.TestScope.class) "
                         + "%1$s.TypedReleasableReferenceManager<test.TestMetadata> "
                         + "from the scope declaration"),
@@ -2682,10 +2835,10 @@ public void releasableReferenceManagerConflict() {
             message(
                 "java.util.Set<dagger.releasablereferences.ReleasableReferenceManager> "
                     + "is bound multiple times:",
-                "@Provides "
+                "    @Provides "
                     + "Set<dagger.releasablereferences.ReleasableReferenceManager> "
                     + "test.TestModule.rrmSet()",
-                "Dagger-generated binding for "
+                "    Dagger-generated binding for "
                     + "Set<dagger.releasablereferences.ReleasableReferenceManager>"))
         .inFile(component)
         .onLine(18);
@@ -2695,10 +2848,10 @@ public void releasableReferenceManagerConflict() {
                 message(
                     "java.util.Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>> "
                         + "is bound multiple times:",
-                    "@Provides "
+                    "    @Provides "
                         + "Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>> "
                         + "test.TestModule.typedRrmSet()",
-                    "Dagger-generated binding for "
+                    "    Dagger-generated binding for "
                         + "Set<%1$s.TypedReleasableReferenceManager<test.TestMetadata>>"),
                 "dagger.releasablereferences"))
         .inFile(component)
diff --git a/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
index 21de94a06..a852752e2 100644
--- a/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/InjectConstructorFactoryGeneratorTest.java
@@ -564,7 +564,7 @@
     assertThat(compilation).failed();
     // for whatever reason, javac only reports the error once on the constructor
     assertThat(compilation)
-        .hadErrorContaining("A single injection site may not use more than one @Qualifier")
+        .hadErrorContaining("A single dependency request may not use more than one @Qualifier")
         .inFile(file)
         .onLine(6);
   }
@@ -824,12 +824,12 @@
     Compilation compilation = daggerCompiler().compile(file, QUALIFIER_A, QUALIFIER_B);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining("A single injection site may not use more than one @Qualifier")
+        .hadErrorContaining("A single dependency request may not use more than one @Qualifier")
         .inFile(file)
         .onLine(6)
         .atColumn(11);
     assertThat(compilation)
-        .hadErrorContaining("A single injection site may not use more than one @Qualifier")
+        .hadErrorContaining("A single dependency request may not use more than one @Qualifier")
         .inFile(file)
         .onLine(6)
         .atColumn(23);
@@ -943,7 +943,7 @@
     Compilation compilation = daggerCompiler().compile(file, QUALIFIER_A, QUALIFIER_B);
     assertThat(compilation).failed();
     assertThat(compilation)
-        .hadErrorContaining("A single injection site may not use more than one @Qualifier")
+        .hadErrorContaining("A single dependency request may not use more than one @Qualifier")
         .inFile(file)
         .onLine(6);
   }
diff --git a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
index c030266b2..ca9cc9550 100644
--- a/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ModuleFactoryGeneratorTest.java
@@ -213,13 +213,12 @@ public void providesMethodReturnsProduced() {
         "",
         "@Module(includes = Void.class)",
         "class TestModule {}");
+
     Compilation compilation = daggerCompiler().compile(module);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            String.format(
-                "%s is listed as a module, but is not annotated with %s",
-                "java.lang.Void", "@Module"));
+            "java.lang.Void is listed as a module, but is not annotated with @Module");
   }
 
   @Test public void singleProvidesMethodNoArgs() {
@@ -1301,14 +1300,13 @@ public void genericSubclassedModule() {
           "",
           "@Qualifier @interface QualifierB {}");
 
-  @Test public void providesMethodMultipleQualifiers() {
+  @Test
+  public void providesMethodMultipleQualifiersOnMethod() {
     JavaFileObject moduleFile = JavaFileObjects.forSourceLines("test.TestModule",
         "package test;",
         "",
         "import dagger.Module;",
         "import dagger.Provides;",
-        "import javax.annotation.Nullable;",
-        "import javax.inject.Singleton;",
         "",
         "@Module",
         "final class TestModule {",
@@ -1318,7 +1316,53 @@ public void genericSubclassedModule() {
         "}");
     Compilation compilation = daggerCompiler().compile(moduleFile, QUALIFIER_A, QUALIFIER_B);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining("Cannot use more than one @Qualifier");
+    assertThat(compilation).hadErrorContaining("may not use more than one @Qualifier");
+  }
+
+  @Test
+  public void providesMethodMultipleQualifiersOnParameter() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides static String provideString(@QualifierA @QualifierB Object object) {",
+            "    return \"foo\";",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(moduleFile, QUALIFIER_A, QUALIFIER_B);
+    assertThat(compilation).failed();
+    assertThat(compilation).hadErrorContaining("may not use more than one @Qualifier");
+  }
+
+  @Test
+  public void providesMethodWildcardDependency() {
+    JavaFileObject moduleFile =
+        JavaFileObjects.forSourceLines(
+            "test.TestModule",
+            "package test;",
+            "",
+            "import dagger.Module;",
+            "import dagger.Provides;",
+            "import javax.inject.Provider;",
+            "",
+            "@Module",
+            "final class TestModule {",
+            "  @Provides static String provideString(Provider<? extends Number> numberProvider) {",
+            "    return \"foo\";",
+            "  }",
+            "}");
+    Compilation compilation = daggerCompiler().compile(moduleFile, QUALIFIER_A, QUALIFIER_B);
+    assertThat(compilation).failed();
+    assertThat(compilation)
+        .hadErrorContaining(
+            "Dagger does not support injecting Provider<T>, Lazy<T>, Producer<T>, or Produced<T> "
+                + "when T is a wildcard type such as ? extends java.lang.Number");
   }
 
   private static final JavaFileObject SCOPE_A =
diff --git a/javatests/dagger/internal/codegen/MultibindsValidatorTest.java b/javatests/dagger/internal/codegen/MultibindsValidatorTest.java
index 6f642f603..cdd74df0d 100644
--- a/javatests/dagger/internal/codegen/MultibindsValidatorTest.java
+++ b/javatests/dagger/internal/codegen/MultibindsValidatorTest.java
@@ -141,7 +141,7 @@ public void overqualifiedSet() {
                 + "abstract Set<Object> tooManyQualifiersSet();")
         .withDeclaration(moduleDeclaration)
         .importing(SomeQualifier.class, OtherQualifier.class)
-        .hasError("Cannot use more than one @Qualifier");
+        .hasError("may not use more than one @Qualifier");
   }
 
   @Test
@@ -151,7 +151,7 @@ public void overqualifiedMap() {
                 + "abstract Map<String, Object> tooManyQualifiersMap();")
         .withDeclaration(moduleDeclaration)
         .importing(SomeQualifier.class, OtherQualifier.class)
-        .hasError("Cannot use more than one @Qualifier");
+        .hasError("may not use more than one @Qualifier");
   }
 
   @Test
diff --git a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 5169ced35..cd9a97779 100644
--- a/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/javatests/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -466,11 +466,32 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
         .generatesSources(factoryFile);
   }
 
-  @Test public void producesMethodMultipleQualifiers() {
+  @Test
+  public void producesMethodMultipleQualifiersOnMethod() {
+    assertThatProductionModuleMethod(
+            "@Produces @QualifierA @QualifierB static String produceString() { return null; }")
+        .importing(ListenableFuture.class, QualifierA.class, QualifierB.class)
+        .hasError("may not use more than one @Qualifier");
+  }
+
+  @Test
+  public void producesMethodMultipleQualifiersOnParameter() {
     assertThatProductionModuleMethod(
-            "@Produces @QualifierA @QualifierB abstract String produceString() { return null; }")
+            "@Produces static String produceString(@QualifierA @QualifierB Object input) "
+                + "{ return null; }")
         .importing(ListenableFuture.class, QualifierA.class, QualifierB.class)
-        .hasError("Cannot use more than one @Qualifier");
+        .hasError("may not use more than one @Qualifier");
+  }
+
+  @Test
+  public void producesMethodWildcardDependency() {
+    assertThatProductionModuleMethod(
+            "@Produces static String produceString(Provider<? extends Number> numberProvider) "
+                + "{ return null; }")
+        .importing(ListenableFuture.class, QualifierA.class, QualifierB.class)
+        .hasError(
+            "Dagger does not support injecting Provider<T>, Lazy<T>, Producer<T>, or Produced<T> "
+                + "when T is a wildcard type such as ? extends java.lang.Number");
   }
 
   @Qualifier
diff --git a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 8c3299960..4486dd733 100644
--- a/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/javatests/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -351,19 +351,18 @@ public void simpleComponent() {
                 "  }",
                 "",
                 "  public static final class Builder {",
-                "    private TestClass.BModule bModule;",
-                "",
                 "    private TestClass.AModule aModule;",
+                "    private TestClass.BModule bModule;",
                 "",
                 "    private Builder() {}",
                 "",
                 "    public TestClass.SimpleComponent build() {",
-                "      if (bModule == null) {",
-                "        this.bModule = new TestClass.BModule();",
-                "      }",
                 "      if (aModule == null) {",
                 "        this.aModule = new TestClass.AModule();",
                 "      }",
+                "      if (bModule == null) {",
+                "        this.bModule = new TestClass.BModule();",
+                "      }",
                 "      return new DaggerTestClass_SimpleComponent(this);",
                 "    }",
                 "",
@@ -479,18 +478,18 @@ public void simpleComponent() {
                 "  }",
                 "",
                 "  public static final class Builder {",
-                "    private TestClass.BModule bModule;",
                 "    private TestClass.AModule aModule;",
+                "    private TestClass.BModule bModule;",
                 "",
                 "    private Builder() {}",
                 "",
                 "    public TestClass.SimpleComponent build() {",
-                "      if (bModule == null) {",
-                "        this.bModule = new TestClass.BModule();",
-                "      }",
                 "      if (aModule == null) {",
                 "        this.aModule = new TestClass.AModule();",
                 "      }",
+                "      if (bModule == null) {",
+                "        this.bModule = new TestClass.BModule();",
+                "      }",
                 "      return new DaggerTestClass_SimpleComponent(this);",
                 "    }",
                 "",
diff --git a/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java b/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
index 1ea56dbe1..905f94453 100644
--- a/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
+++ b/javatests/dagger/internal/codegen/ProductionGraphValidationTest.java
@@ -98,11 +98,15 @@
         "    ListenableFuture<A> getA();",
         "  }",
         "}");
-    String expectedError =
-        "test.TestClass.A cannot be provided without an @Provides- or @Produces-annotated method.";
+
     Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(11);
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.TestClass.A cannot be provided without an @Provides- or @Produces-annotated "
+                + "method.")
+        .inFile(component)
+        .onLine(11);
   }
 
   @Test public void provisionDependsOnProduction() {
@@ -139,11 +143,13 @@
         "    ListenableFuture<A> getA();",
         "  }",
         "}");
-    String expectedError =
-        "test.TestClass.A is a provision, which cannot depend on a production.";
+
     Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(30);
+    assertThat(compilation)
+        .hadErrorContaining("test.TestClass.A is a provision, which cannot depend on a production.")
+        .inFile(component)
+        .onLine(30);
   }
 
   @Test public void provisionEntryPointDependsOnProduction() {
@@ -172,11 +178,14 @@
             "    A getA();",
             "  }",
             "}");
-    String expectedError =
-        "test.TestClass.A is a provision entry-point, which cannot depend on a production.";
+
     Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(20);
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.TestClass.A is a provision entry-point, which cannot depend on a production.")
+        .inFile(component)
+        .onLine(20);
   }
 
   @Test
@@ -278,11 +287,14 @@ public void monitoringDependsOnUnboundType() {
             "    ListenableFuture<String> getString();",
             "  }",
             "}");
-    String expectedError =
-        "test.TestClass.A cannot be provided without an @Provides-annotated method.";
+
     Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(34);
+    assertThat(compilation)
+        .hadErrorContaining(
+            "test.TestClass.A cannot be provided without an @Provides-annotated method.")
+        .inFile(component)
+        .onLine(34);
   }
 
   @Test
@@ -329,13 +341,16 @@ public void monitoringDependsOnProduction() {
             "    ListenableFuture<String> getString();",
             "  }",
             "}");
-    String expectedError =
-        "java.util.Set<dagger.producers.monitoring.ProductionComponentMonitor.Factory>"
-            + " test.TestClass.MonitoringModule#monitorFactory is a provision,"
-            + " which cannot depend on a production.";
+
     Compilation compilation = daggerCompiler().compile(EXECUTOR_MODULE, component);
     assertThat(compilation).failed();
-    assertThat(compilation).hadErrorContaining(expectedError).inFile(component).onLine(37);
+    assertThat(compilation)
+        .hadErrorContaining(
+            "java.util.Set<dagger.producers.monitoring.ProductionComponentMonitor.Factory>"
+                + " test.TestClass.MonitoringModule#monitorFactory is a provision,"
+                + " which cannot depend on a production.")
+        .inFile(component)
+        .onLine(37);
   }
 
   @Test
diff --git a/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java b/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
index a829ec3d5..ce0c7d43c 100644
--- a/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
+++ b/javatests/dagger/internal/codegen/SubcomponentBuilderValidationTest.java
@@ -18,8 +18,8 @@
 
 import static com.google.testing.compile.CompilationSubject.assertThat;
 import static dagger.internal.codegen.Compilers.daggerCompiler;
+import static dagger.internal.codegen.TestUtils.message;
 
-import com.google.common.base.Joiner;
 import com.google.testing.compile.Compilation;
 import com.google.testing.compile.JavaFileObjects;
 import javax.tools.JavaFileObject;
@@ -719,15 +719,15 @@ public void testMultipleSettersPerBoundInstanceTypeFails() {
             "    @BindsInstance void set2(String s);",
             "  }",
             "}");
+
     Compilation compilation = daggerCompiler().compile(componentFile, childComponentFile);
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            Joiner.on("\n      ")
-                .join(
-                    "[test.ChildComponent.s()] java.lang.String is bound multiple times:",
-                    "@BindsInstance void test.ChildComponent.Builder.set1(String)",
-                    "@BindsInstance void test.ChildComponent.Builder.set2(String)"))
+            message(
+                "[test.ChildComponent.s()] java.lang.String is bound multiple times:",
+                "    @BindsInstance void test.ChildComponent.Builder.set1(String)",
+                "    @BindsInstance void test.ChildComponent.Builder.set2(String)"))
         .inFile(componentFile)
         .onLineContaining("interface ParentComponent {");
   }
diff --git a/javatests/dagger/internal/codegen/TestUtils.java b/javatests/dagger/internal/codegen/TestUtils.java
index c7191d3ea..c02a5f934 100644
--- a/javatests/dagger/internal/codegen/TestUtils.java
+++ b/javatests/dagger/internal/codegen/TestUtils.java
@@ -21,10 +21,10 @@
 /** Utility methods useful for codegen tests. */
 final class TestUtils {
 
-  private static final Joiner MESSAGE_JOINER = Joiner.on("\n      ");
+  private static final Joiner MESSAGE_JOINER = Joiner.on("\n  ");
 
   /**
-   * Returns the lines joined by newline plus the standard indent. Useful for passing to {@link
+   * Returns the lines joined by newline plus two spaces. Useful for passing to {@link
    * com.google.testing.compile.CompilationSubject#hadErrorContaining(String)}, etc.
    */
   static String message(String... lines) {
diff --git a/javatests/dagger/spi/SpiPluginTest.java b/javatests/dagger/spi/SpiPluginTest.java
index d9d479b38..51ddf283e 100644
--- a/javatests/dagger/spi/SpiPluginTest.java
+++ b/javatests/dagger/spi/SpiPluginTest.java
@@ -63,10 +63,10 @@ public void dependencyTraceAtBinding() {
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Binding!",
-                "      test.Foo is provided at",
-                "          test.TestComponent.foo()"))
+                "    test.Foo is provided at",
+                "        test.TestComponent.foo()"))
         .inFile(component)
         .onLineContaining("Foo foo();");
   }
@@ -151,30 +151,30 @@ public void dependencyTraceAtDependencyRequest() {
 
     assertThat(compilationFactory.compilationWithErrorOnDependency("entryPoint"))
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Dependency!",
-                "      test.EntryPoint is provided at",
-                "          test.TestComponent.entryPoint()"))
+                "    test.EntryPoint is provided at",
+                "        test.TestComponent.entryPoint()"))
         .inFile(component)
         .onLineContaining("EntryPoint entryPoint();");
     assertThat(compilationFactory.compilationWithErrorOnDependency("dup1"))
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Dependency!",
-                "      test.Duplicated is injected at",
-                "          test.EntryPoint.<init>(, dup1, )",
-                "      test.EntryPoint is provided at",
-                "          test.TestComponent.entryPoint()"))
+                "    test.Duplicated is injected at",
+                "        test.EntryPoint.<init>(, dup1, )",
+                "    test.EntryPoint is provided at",
+                "        test.TestComponent.entryPoint()"))
         .inFile(component)
         .onLineContaining("EntryPoint entryPoint();");
     assertThat(compilationFactory.compilationWithErrorOnDependency("dup2"))
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Dependency!",
-                "      test.Duplicated is injected at",
-                "          test.EntryPoint.<init>(, dup2)",
-                "      test.EntryPoint is provided at",
-                "          test.TestComponent.entryPoint()"))
+                "    test.Duplicated is injected at",
+                "        test.EntryPoint.<init>(, dup2)",
+                "    test.EntryPoint is provided at",
+                "        test.TestComponent.entryPoint()"))
         .inFile(component)
         .onLineContaining("EntryPoint entryPoint();");
     // Note that this compilation results in one error being reported twice since there are
@@ -183,30 +183,30 @@ public void dependencyTraceAtDependencyRequest() {
         compilationFactory.compilationWithErrorOnDependency("inFooDep");
     assertThat(inFooDepCompilation)
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Dependency!",
-                "      test.Duplicated is injected at",
-                "          test.Foo.<init>(inFooDep)",
-                "      test.Foo is injected at",
-                "          test.EntryPoint.<init>(foo, )",
-                "      test.EntryPoint is provided at",
-                "          test.TestComponent.entryPoint()"))
+                "    test.Duplicated is injected at",
+                "        test.Foo.<init>(inFooDep)",
+                "    test.Foo is injected at",
+                "        test.EntryPoint.<init>(foo, )",
+                "    test.EntryPoint is provided at",
+                "        test.TestComponent.entryPoint()"))
         .inFile(component)
         .onLineContaining("EntryPoint entryPoint();");
     assertThat(inFooDepCompilation)
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Dependency!",
-                "      test.Duplicated is injected at",
-                "          test.Foo.<init>(inFooDep)",
-                "      test.Foo is injected at",
-                "          test.Chain3.<init>(foo)",
-                "      test.Chain3 is injected at",
-                "          test.Chain2.<init>(chain)",
-                "      test.Chain2 is injected at",
-                "          test.Chain1.<init>(chain)",
-                "      test.Chain1 is provided at",
-                "          test.TestComponent.chain()"))
+                "    test.Duplicated is injected at",
+                "        test.Foo.<init>(inFooDep)",
+                "    test.Foo is injected at",
+                "        test.Chain3.<init>(foo)",
+                "    test.Chain3 is injected at",
+                "        test.Chain2.<init>(chain)",
+                "    test.Chain2 is injected at",
+                "        test.Chain1.<init>(chain)",
+                "    test.Chain1 is provided at",
+                "        test.TestComponent.chain()"))
         .inFile(component)
         .onLineContaining("Chain1 chain();");
   }
@@ -260,25 +260,25 @@ public void dependencyTraceAtDependencyRequest_subcomponents() {
         new CompilationFactory(component, subcomponent, foo, entryPoint);
     assertThat(compilationFactory.compilationWithErrorOnDependency("childEntryPoint"))
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] [test.TestSubcomponent.childEntryPoint()] Bad Dependency!",
-                "      test.EntryPoint is provided at",
-                "          test.TestSubcomponent.childEntryPoint()",
-                "  component path: test.TestComponent  test.TestSubcomponent"))
+                "    test.EntryPoint is provided at",
+                "        test.TestSubcomponent.childEntryPoint()",
+                "component path: test.TestComponent  test.TestSubcomponent"))
         .inFile(component)
         .onLineContaining("interface TestComponent");
     assertThat(compilationFactory.compilationWithErrorOnDependency("foo"))
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] [test.TestSubcomponent.childEntryPoint()] Bad Dependency!",
-                "      test.Foo is injected at",
-                "          test.EntryPoint.<init>(foo)",
-                "      test.EntryPoint is provided at",
-                "          test.TestSubcomponent.childEntryPoint()",
+                "    test.Foo is injected at",
+                "        test.EntryPoint.<init>(foo)",
+                "    test.EntryPoint is provided at",
+                "        test.TestSubcomponent.childEntryPoint()",
                 // TODO(ronshapiro): Maybe make the component path resemble a stack trace:
                 //     test.TestSubcomponent is a child of
                 //         test.TestComponent
-                "  component path: test.TestComponent  test.TestSubcomponent"))
+                "component path: test.TestComponent  test.TestSubcomponent"))
         .inFile(component)
         .onLineContaining("interface TestComponent");
   }
@@ -338,9 +338,9 @@ public void errorOnSubcomponent() {
     assertThat(compilation).failed();
     assertThat(compilation)
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Subcomponent!",
-                "  component path: test.TestComponent  test.TestSubcomponent"))
+                "component path: test.TestComponent  test.TestSubcomponent"))
         .inFile(component)
         .onLineContaining("interface TestComponent");
   }
@@ -446,27 +446,27 @@ public void shortestPathToBindingExistsThroughSubcomponentBuilder() {
                 subcomponentModule);
     assertThat(compilation)
         .hadErrorContaining(
-            lines(
+            message(
                 "[FailingPlugin] Bad Binding!",
-                "      test.ExposedOnSubcomponent is injected at",
-                "          test.Chain3.<init>(exposedOnSubcomponent)",
-                "      test.Chain3 is injected at",
-                "          test.Chain2.<init>(chain)",
-                "      test.Chain2 is injected at",
-                "          test.Chain1.<init>(chain)",
-                "      test.Chain1 is provided at",
-                "          test.TestComponent.chain()"))
+                "    test.ExposedOnSubcomponent is injected at",
+                "        test.Chain3.<init>(exposedOnSubcomponent)",
+                "    test.Chain3 is injected at",
+                "        test.Chain2.<init>(chain)",
+                "    test.Chain2 is injected at",
+                "        test.Chain1.<init>(chain)",
+                "    test.Chain1 is provided at",
+                "        test.TestComponent.chain()"))
         .inFile(component)
         .onLineContaining("Chain1 chain();");
     assertThat(compilation)
         .hadErrorContaining(
-            lines(
+            message(
                 // TODO(ronshapiro): should this error be reported if it's already been reported at
                 // an ancestor component?
                 "[FailingPlugin] [test.TestSubcomponent.exposedOnSubcomponent()] Bad Binding!",
-                "      test.ExposedOnSubcomponent is provided at",
-                "          test.TestSubcomponent.exposedOnSubcomponent()",
-                "  component path: test.TestComponent  test.TestSubcomponent"))
+                "    test.ExposedOnSubcomponent is provided at",
+                "        test.TestSubcomponent.exposedOnSubcomponent()",
+                "component path: test.TestComponent  test.TestSubcomponent"))
         .inFile(component)
         .onLineContaining("interface TestComponent");
   }
@@ -490,7 +490,7 @@ private Compilation compilationWithErrorOnDependency(String dependencySimpleName
     }
   }
 
-  private static String lines(String... lines) {
-    return Joiner.on('\n').join(lines);
+  private static String message(String... lines) {
+    return Joiner.on("\n  ").join(lines);
   }
 }
