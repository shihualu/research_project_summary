diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponentWithMultibindings.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponentWithMultibindings.java
new file mode 100644
index 000000000..9ed266aec
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildComponentWithMultibindings.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Subcomponent;
+
+@Subcomponent(modules = ChildMultibindingModule.class)
+interface ChildComponentWithMultibindings {
+  RequiresMultibindingsInChild requiresMultibindingsInChild();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildMultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildMultibindingModule.java
new file mode 100644
index 000000000..8a8bfa7d0
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ChildMultibindingModule.java
@@ -0,0 +1,30 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Module;
+import dagger.Provides;
+
+import static dagger.Provides.Type.SET;
+
+@Module
+class ChildMultibindingModule {
+
+  @Provides(type = SET)
+  Object childObject() {
+    return "object provided by child";
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponentWithMultibindings.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponentWithMultibindings.java
new file mode 100644
index 000000000..46fe8835c
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponentWithMultibindings.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Component;
+
+@Component(modules = ParentMultibindingModule.class)
+interface ParentComponentWithMultibindings extends ParentComponentWithoutMultibindings {
+  RequiresMultibindingsInParent requiresMultibindingsInParent();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponentWithoutMultibindings.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponentWithoutMultibindings.java
new file mode 100644
index 000000000..3d4431ca9
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentComponentWithoutMultibindings.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Component;
+
+@Component(modules = ParentMultibindingModule.class)
+interface ParentComponentWithoutMultibindings {
+  ChildComponentWithMultibindings childComponent();
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentMultibindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentMultibindingModule.java
new file mode 100644
index 000000000..24dc6497e
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/ParentMultibindingModule.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import dagger.Module;
+import dagger.Provides;
+
+import static dagger.Provides.Type.SET;
+
+@Module
+class ParentMultibindingModule {
+
+  @Provides(type = SET)
+  Object provideObject() {
+    return "object provided by parent";
+  }
+
+  @Provides(type = SET)
+  String provideString() {
+    return "string provided by parent";
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultibindingsInChild.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultibindingsInChild.java
new file mode 100644
index 000000000..1f9150c88
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultibindingsInChild.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import javax.inject.Inject;
+
+class RequiresMultibindingsInChild {
+  private final RequiresSetOfObjects requiresSetOfObjects;
+  private final RequiresSetOfStrings requiresSetOfStrings;
+
+  @Inject
+  RequiresMultibindingsInChild(
+      RequiresSetOfObjects requiresSetOfObjects, RequiresSetOfStrings requiresSetOfStrings) {
+    this.requiresSetOfObjects = requiresSetOfObjects;
+    this.requiresSetOfStrings = requiresSetOfStrings;
+  }
+
+  RequiresSetOfObjects requiresSetOfObjects() {
+    return requiresSetOfObjects;
+  }
+
+  RequiresSetOfStrings requiresSetOfStrings() {
+    return requiresSetOfStrings;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultibindingsInParent.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultibindingsInParent.java
new file mode 100644
index 000000000..d87b1c7ee
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresMultibindingsInParent.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import javax.inject.Inject;
+
+class RequiresMultibindingsInParent {
+  private final RequiresSetOfObjects requiresSetOfObjects;
+  private final RequiresSetOfStrings requiresSetOfStrings;
+
+  @Inject
+  RequiresMultibindingsInParent(
+      RequiresSetOfObjects requiresSetOfObjects, RequiresSetOfStrings requiresSetOfStrings) {
+    this.requiresSetOfObjects = requiresSetOfObjects;
+    this.requiresSetOfStrings = requiresSetOfStrings;
+  }
+
+  RequiresSetOfObjects requiresSetOfObjects() {
+    return requiresSetOfObjects;
+  }
+
+  RequiresSetOfStrings requiresSetOfStrings() {
+    return requiresSetOfStrings;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSetOfObjects.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSetOfObjects.java
new file mode 100644
index 000000000..447ac61dc
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSetOfObjects.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import java.util.Set;
+import javax.inject.Inject;
+
+class RequiresSetOfObjects {
+  private Set<Object> setOfObjects;
+
+  @Inject
+  RequiresSetOfObjects(Set<Object> setOfObjects) {
+    this.setOfObjects = setOfObjects;
+  }
+
+  Set<Object> setOfObjects() {
+    return setOfObjects;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSetOfStrings.java b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSetOfStrings.java
new file mode 100644
index 000000000..37eaea95d
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/main/java/test/subcomponent/RequiresSetOfStrings.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import java.util.Set;
+import javax.inject.Inject;
+
+class RequiresSetOfStrings {
+  private Set<String> setOfStrings;
+
+  @Inject
+  RequiresSetOfStrings(Set<String> setOfStrings) {
+    this.setOfStrings = setOfStrings;
+  }
+
+  Set<String> setOfStrings() {
+    return setOfStrings;
+  }
+}
diff --git a/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java
new file mode 100644
index 000000000..566dc3919
--- /dev/null
+++ b/compiler/src/it/functional-tests/src/test/java/test/subcomponent/SubcomponentMultibindingsTest.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2015 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package test.subcomponent;
+
+import com.google.common.collect.ImmutableList;
+import java.util.Collection;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+import org.junit.runners.Parameterized.Parameters;
+
+import static com.google.common.truth.Truth.assertWithMessage;
+
+@RunWith(Parameterized.class)
+public class SubcomponentMultibindingsTest {
+
+  @Parameters(name = "{0}")
+  public static Collection<Object[]> parameters() {
+    return ImmutableList.of(
+        new Object[] {DaggerParentComponentWithMultibindings.create()},
+        new Object[] {DaggerParentComponentWithoutMultibindings.create()});
+  }
+
+  private ParentComponentWithoutMultibindings parent;
+
+  public SubcomponentMultibindingsTest(ParentComponentWithoutMultibindings parentComponent) {
+    this.parent = parentComponent;
+  }
+
+  @Test
+  public void test() {
+    ChildComponentWithMultibindings child = parent.childComponent();
+    RequiresMultibindingsInChild requiresMultibindingsInChild =
+        child.requiresMultibindingsInChild();
+    assertWithMessage("child.requiresMultibindingsInChild.requiresSetOfObjects")
+        .that(requiresMultibindingsInChild.requiresSetOfObjects().setOfObjects())
+        .containsExactly("object provided by parent", "object provided by child");
+    assertWithMessage("child.requiresMultibindingsInChild.requiresSetOfStrings")
+        .that(requiresMultibindingsInChild.requiresSetOfStrings().setOfStrings())
+        .containsExactly("string provided by parent");
+  }
+}
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index ae1cf0b0b..cc3860286 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -20,6 +20,8 @@
 import com.google.common.base.Equivalence;
 import com.google.common.base.Function;
 import com.google.common.base.Optional;
+import com.google.common.cache.Cache;
+import com.google.common.cache.CacheBuilder;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
@@ -32,10 +34,13 @@
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
 import dagger.producers.ProductionComponent;
 import java.util.ArrayDeque;
+import java.util.Collection;
 import java.util.Deque;
 import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Executor;
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
@@ -203,6 +208,8 @@ private BindingGraph create(Optional<RequestResolver> parentResolver,
       final ImmutableSetMultimap<Key, ProductionBinding> explicitProductionBindings;
       final Map<BindingKey, ResolvedBindings> resolvedBindings;
       final Deque<BindingKey> cycleStack = new ArrayDeque<>();
+      final Cache<BindingKey, Boolean> dependsOnLocalMultibindingsCache =
+          CacheBuilder.newBuilder().<BindingKey, Boolean>build();
 
       RequestResolver(Optional<RequestResolver> parentResolver,
           Optional<Equivalence.Wrapper<AnnotationMirror>> targetScope,
@@ -329,18 +336,21 @@ private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
       }
 
       private Optional<RequestResolver> getOwningResolver(ProvisionBinding provisionBinding) {
-        Optional<Equivalence.Wrapper<AnnotationMirror>> bindingScope =
-            provisionBinding.wrappedScope();
         for (RequestResolver requestResolver : getResolverLineage().reverse()) {
           if (requestResolver.explicitProvisionBindingsSet.contains(provisionBinding)) {
             return Optional.of(requestResolver);
           }
         }
+
         // look for scope separately.  we do this for the case where @Singleton can appear twice
         // in the â€  compatibility mode
-        for (RequestResolver requestResolver : getResolverLineage().reverse()) {
-          if (bindingScope.isPresent() && bindingScope.equals(requestResolver.targetScope)) {
-            return Optional.of(requestResolver);
+        Optional<Equivalence.Wrapper<AnnotationMirror>> bindingScope =
+            provisionBinding.wrappedScope();
+        if (bindingScope.isPresent()) {
+          for (RequestResolver requestResolver : getResolverLineage().reverse()) {
+            if (bindingScope.equals(requestResolver.targetScope)) {
+              return Optional.of(requestResolver);
+            }
           }
         }
         return Optional.absent();
@@ -390,19 +400,26 @@ private MembersInjectionBinding rollUpMembersInjectionBindings(Key key) {
       void resolve(DependencyRequest request) {
         BindingKey bindingKey = request.bindingKey();
 
-        Optional<ResolvedBindings> previouslyResolvedBinding =
-            getPreviouslyResolvedBindings(bindingKey);
-        if (previouslyResolvedBinding.isPresent()
-            && !(bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION)
-                && !previouslyResolvedBinding.get().contributionBindings().isEmpty()
-                && ContributionBinding.bindingTypeFor(
-                    previouslyResolvedBinding.get().contributionBindings()).isMultibinding())) {
+        // If we find a cycle, stop resolving. The original request will add it with all of the
+        // other resolved deps.
+        if (cycleStack.contains(bindingKey)) {
           return;
         }
 
-        if (cycleStack.contains(bindingKey)) {
-          // We found a cycle. Don't add a resolved binding, since the original request will add it
-          // with all of the other resolved deps
+        // If the binding was previously resolved in this (sub)component, don't resolve it again.
+        if (resolvedBindings.containsKey(bindingKey)) {
+          return;
+        }
+
+        // If the binding was previously resolved in a supercomponent, then test to see if it
+        // depends on multibindings with contributions from this subcomponent. If it does, then we
+        // have to resolve it in this subcomponent so that it sees the local contributions. If it
+        // does not, then we can stop resolving it in this subcomponent and rely on the
+        // supercomponent resolution.
+        Optional<ResolvedBindings> bindingsPreviouslyResolvedInParent =
+            getPreviouslyResolvedBindings(bindingKey);
+        if (bindingsPreviouslyResolvedInParent.isPresent()
+            && !dependsOnLocalMultibindings(bindingsPreviouslyResolvedInParent.get())) {
           return;
         }
 
@@ -420,24 +437,70 @@ void resolve(DependencyRequest request) {
         }
       }
 
+      /**
+       * Returns {@code true} if {@code previouslyResolvedBindings} is multibindings with
+       * contributions declared within this (sub)component's modules, or if any of its unscoped
+       * provision-dependencies depend on such local multibindings.
+       *
+       * <p>We don't care about scoped dependencies or production bindings because they will never
+       * depend on multibindings with contributions from subcomponents.
+       */
+      private boolean dependsOnLocalMultibindings(
+          final ResolvedBindings previouslyResolvedBindings) {
+        try {
+          return dependsOnLocalMultibindingsCache.get(
+              previouslyResolvedBindings.bindingKey(),
+              new Callable<Boolean>() {
+                @Override
+                public Boolean call() {
+                  if (previouslyResolvedBindings.isMultibindings()
+                      && hasLocalContributions(previouslyResolvedBindings)) {
+                    return true;
+                  }
+
+                  for (Binding binding : previouslyResolvedBindings.bindings()) {
+                    if (!isScoped(binding) && !(binding instanceof ProductionBinding)) {
+                      for (DependencyRequest dependency : binding.implicitDependencies()) {
+                        if (dependsOnLocalMultibindings(
+                            getPreviouslyResolvedBindings(dependency.bindingKey()).get())) {
+                          return true;
+                        }
+                      }
+                    }
+                  }
+                  return false;
+                }
+              });
+        } catch (ExecutionException e) {
+          throw new AssertionError(e);
+        }
+      }
+
+      private boolean hasLocalContributions(ResolvedBindings resolvedBindings) {
+        return !explicitProvisionBindings.get(resolvedBindings.bindingKey().key()).isEmpty()
+            || !explicitProductionBindings.get(resolvedBindings.bindingKey().key()).isEmpty();
+      }
+
+      private boolean isScoped(Binding binding) {
+        if (binding instanceof ProvisionBinding) {
+          ProvisionBinding provisionBinding = (ProvisionBinding) binding;
+          return provisionBinding.scope().isPresent();
+        }
+        return false;
+      }
+
       ImmutableMap<BindingKey, ResolvedBindings> getResolvedBindings() {
         ImmutableMap.Builder<BindingKey, ResolvedBindings> resolvedBindingsBuilder =
             ImmutableMap.builder();
         resolvedBindingsBuilder.putAll(resolvedBindings);
         if (parentResolver.isPresent()) {
-          for (ResolvedBindings resolvedInParent :
-              parentResolver.get().getResolvedBindings().values()) {
-            BindingKey bindingKey = resolvedInParent.bindingKey();
-            if (!resolvedBindings.containsKey(bindingKey)) {
-              if (resolvedInParent.ownedBindings().isEmpty()) {
-                // reuse the instance if we can get away with it
-                resolvedBindingsBuilder.put(bindingKey, resolvedInParent);
-              } else {
-                resolvedBindingsBuilder.put(bindingKey,
-                    ResolvedBindings.create(
-                        bindingKey, ImmutableSet.<Binding>of(), resolvedInParent.bindings()));
-              }
-            }
+          Collection<ResolvedBindings> bindingsResolvedInParent =
+              Maps.difference(parentResolver.get().getResolvedBindings(), resolvedBindings)
+                  .entriesOnlyOnLeft()
+                  .values();
+          for (ResolvedBindings resolvedInParent : bindingsResolvedInParent) {
+            resolvedBindingsBuilder.put(
+                resolvedInParent.bindingKey(), resolvedInParent.asInherited());
           }
         }
         return resolvedBindingsBuilder.build();
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index e44ba4ca7..803ecc44b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -20,6 +20,7 @@
 import java.util.Set;
 
 import static com.google.common.base.Preconditions.checkState;
+import static dagger.internal.codegen.ContributionBinding.bindingTypeFor;
 
 /**
  * The collection of bindings that have been resolved for a binding key.
@@ -70,4 +71,23 @@ static ResolvedBindings create(
     checkState(bindingKey().kind().equals(BindingKey.Kind.MEMBERS_INJECTION));
     return (ImmutableSet<? extends MembersInjectionBinding>) bindings();
   }
+
+  /**
+   * Returns a {@code ResolvedBindings} with the same {@link #bindingKey()} and {@link #bindings()}
+   * as this one, but no {@link #ownedBindings()}.
+   */
+  ResolvedBindings asInherited() {
+    return ownedBindings().isEmpty()
+        ? this
+        : ResolvedBindings.create(bindingKey(), ImmutableSet.<Binding>of(), bindings());
+  }
+
+  /**
+   * {@code true} if this is a multibindings contribution.
+   */
+  boolean isMultibindings() {
+    return bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)
+        && !contributionBindings().isEmpty()
+        && bindingTypeFor(contributionBindings()).isMultibinding();
+  }
 }
