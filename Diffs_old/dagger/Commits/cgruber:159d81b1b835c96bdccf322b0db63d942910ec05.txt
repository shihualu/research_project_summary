diff --git a/java/dagger/internal/codegen/BUILD b/java/dagger/internal/codegen/BUILD
index 2e257d519..ea623fc18 100644
--- a/java/dagger/internal/codegen/BUILD
+++ b/java/dagger/internal/codegen/BUILD
@@ -235,6 +235,7 @@ java_library(
         "BindingExpression.java",
         "BindingMethodImplementation.java",
         "ComponentBindingExpressions.java",
+        "ComponentImplementation.java",
         "ComponentInstanceBindingExpression.java",
         "ComponentMethodBindingExpression.java",
         "ComponentProvisionBindingExpression.java",
@@ -252,7 +253,6 @@ java_library(
         "FrameworkInstanceBindingExpression.java",
         "FrameworkInstanceSupplier.java",
         "GeneratedComponentBuilderModel.java",
-        "GeneratedComponentModel.java",
         "GeneratedInstanceBindingExpression.java",
         "GwtCompatibility.java",
         "HjarSourceFileGenerator.java",
@@ -326,7 +326,7 @@ java_library(
         "BindingMethodValidatorsModule.java",
         "ComponentGenerator.java",
         "ComponentHjarProcessingStep.java",
-        "ComponentModelBuilder.java",
+        "ComponentImplementationBuilder.java",
         "ComponentProcessingStep.java",
         "ComponentProcessor.java",
         "DiagnosticReporterFactory.java",
diff --git a/java/dagger/internal/codegen/BindingExpression.java b/java/dagger/internal/codegen/BindingExpression.java
index c4cd5c119..bf84f0697 100644
--- a/java/dagger/internal/codegen/BindingExpression.java
+++ b/java/dagger/internal/codegen/BindingExpression.java
@@ -39,7 +39,7 @@
    * #getDependencyExpression}.
    */
   Expression getDependencyExpressionForComponentMethod(
-      ComponentMethodDescriptor componentMethod, GeneratedComponentModel component) {
+      ComponentMethodDescriptor componentMethod, ComponentImplementation component) {
     return getDependencyExpression(component.name());
   }
 
@@ -54,7 +54,7 @@ boolean requiresMethodEncapsulation() {
    * @param component the component that will contain the implemented method
    */
   CodeBlock getComponentMethodImplementation(
-      ComponentMethodDescriptor componentMethod, GeneratedComponentModel component) {
+      ComponentMethodDescriptor componentMethod, ComponentImplementation component) {
     // By default, just delegate to #getDependencyExpression().
     return CodeBlock.of(
         "return $L;",
@@ -63,10 +63,10 @@ CodeBlock getComponentMethodImplementation(
 
   /**
    * Returns an expression for the implementation of a modifiable binding method for the given
-   * component model.
+   * component.
    */
   CodeBlock getModifiableBindingMethodImplementation(
-      ModifiableBindingMethod modifiableBindingMethod, GeneratedComponentModel component) {
+      ModifiableBindingMethod modifiableBindingMethod, ComponentImplementation component) {
     return CodeBlock.of("return $L;", getDependencyExpression(component.name()).codeBlock());
   }
 }
diff --git a/java/dagger/internal/codegen/BindingGraphFactory.java b/java/dagger/internal/codegen/BindingGraphFactory.java
index f62f73e1a..58ed89b54 100644
--- a/java/dagger/internal/codegen/BindingGraphFactory.java
+++ b/java/dagger/internal/codegen/BindingGraphFactory.java
@@ -778,15 +778,16 @@ void resolve(Key key) {
         return;
       }
 
-      /* If the binding was previously resolved in a supercomponent, then we may be able to avoid
-       * resolving it here and just depend on the supercomponent resolution.
+      /*
+       * If the binding was previously resolved in an ancestor component, then we may be able to
+       * avoid resolving it here and just depend on the ancestor component resolution.
        *
        * 1. If it depends transitively on multibinding contributions or optional bindings with
        *    bindings from this subcomponent, then we have to resolve it in this subcomponent so
        *    that it sees the local bindings.
        *
        * 2. If there are any explicit bindings in this component, they may conflict with those in
-       *    the supercomponent, so resolve them here so that conflicts can be caught.
+       *    the ancestor component, so resolve them here so that conflicts can be caught.
        */
       if (getPreviouslyResolvedBindings(key).isPresent()) {
         /* Resolve in the parent in case there are multibinding contributions or conflicts in some
diff --git a/java/dagger/internal/codegen/ComponentBindingExpressions.java b/java/dagger/internal/codegen/ComponentBindingExpressions.java
index 91a0cd0b7..391418364 100644
--- a/java/dagger/internal/codegen/ComponentBindingExpressions.java
+++ b/java/dagger/internal/codegen/ComponentBindingExpressions.java
@@ -57,7 +57,7 @@
 
   private final Optional<ComponentBindingExpressions> parent;
   private final BindingGraph graph;
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final ComponentRequirementFields componentRequirementFields;
   private final OptionalFactories optionalFactories;
   private final DaggerTypes types;
@@ -71,7 +71,7 @@
 
   ComponentBindingExpressions(
       BindingGraph graph,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       ComponentRequirementFields componentRequirementFields,
       OptionalFactories optionalFactories,
       DaggerTypes types,
@@ -80,9 +80,9 @@
     this(
         Optional.empty(),
         graph,
-        generatedComponentModel,
+        componentImplementation,
         componentRequirementFields,
-        new StaticSwitchingProviders(generatedComponentModel, types),
+        new StaticSwitchingProviders(componentImplementation, types),
         optionalFactories,
         types,
         elements,
@@ -92,7 +92,7 @@
   private ComponentBindingExpressions(
       Optional<ComponentBindingExpressions> parent,
       BindingGraph graph,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       ComponentRequirementFields componentRequirementFields,
       StaticSwitchingProviders staticSwitchingProviders,
       OptionalFactories optionalFactories,
@@ -101,23 +101,23 @@ private ComponentBindingExpressions(
       CompilerOptions compilerOptions) {
     this.parent = parent;
     this.graph = graph;
-    this.generatedComponentModel = generatedComponentModel;
+    this.componentImplementation = componentImplementation;
     this.componentRequirementFields = checkNotNull(componentRequirementFields);
     this.optionalFactories = checkNotNull(optionalFactories);
     this.types = checkNotNull(types);
     this.elements = checkNotNull(elements);
     this.compilerOptions = checkNotNull(compilerOptions);
     this.membersInjectionMethods =
-        new MembersInjectionMethods(generatedComponentModel, this, graph, elements, types);
+        new MembersInjectionMethods(componentImplementation, this, graph, elements, types);
     this.innerSwitchingProviders =
-        new InnerSwitchingProviders(generatedComponentModel, this, types);
+        new InnerSwitchingProviders(componentImplementation, this, types);
     this.staticSwitchingProviders = staticSwitchingProviders;
     this.modifiableBindingExpressions =
         new ModifiableBindingExpressions(
             parent.map(cbe -> cbe.modifiableBindingExpressions),
             this,
             graph,
-            generatedComponentModel,
+            componentImplementation,
             compilerOptions);
   }
 
@@ -126,12 +126,12 @@ private ComponentBindingExpressions(
    */
   ComponentBindingExpressions forChildComponent(
       BindingGraph childGraph,
-      GeneratedComponentModel childComponentModel,
+      ComponentImplementation childComponentImplementation,
       ComponentRequirementFields childComponentRequirementFields) {
     return new ComponentBindingExpressions(
         Optional.of(this),
         childGraph,
-        childComponentModel,
+        childComponentImplementation,
         childComponentRequirementFields,
         staticSwitchingProviders,
         optionalFactories,
@@ -165,9 +165,9 @@ Expression getDependencyExpression(BindingRequest request, ClassName requestingC
   Expression getDependencyExpressionForComponentMethod(
       BindingRequest request,
       ComponentMethodDescriptor componentMethod,
-      GeneratedComponentModel componentModel) {
+      ComponentImplementation componentImplementation) {
     return getBindingExpression(request)
-        .getDependencyExpressionForComponentMethod(componentMethod, componentModel);
+        .getDependencyExpressionForComponentMethod(componentMethod, componentImplementation);
   }
 
   /**
@@ -185,14 +185,12 @@ CodeBlock getCreateMethodArgumentsCodeBlock(ContributionBinding binding) {
       arguments.add(
           componentRequirementFields.getExpressionDuringInitialization(
               ComponentRequirement.forModule(binding.contributingModule().get().asType()),
-              generatedComponentModel.name()));
+              componentImplementation.name()));
     }
 
     binding.frameworkDependencies().stream()
         .map(BindingRequest::bindingRequest)
-        .map(
-            request ->
-                getDependencyExpression(request, generatedComponentModel.name()))
+        .map(request -> getDependencyExpression(request, componentImplementation.name()))
         .map(Expression::codeBlock)
         .forEach(arguments::add);
 
@@ -235,7 +233,7 @@ MethodSpec getComponentMethod(ComponentMethodDescriptor componentMethod) {
             types)
         .addCode(
             getBindingExpression(request)
-                .getComponentMethodImplementation(componentMethod, generatedComponentModel))
+                .getComponentMethodImplementation(componentMethod, componentImplementation))
         .build();
   }
 
@@ -298,7 +296,7 @@ private FrameworkInstanceBindingExpression frameworkInstanceBindingExpression(
         staticMethod.isPresent()
             ? staticMethod::get
             : new FrameworkFieldInitializer(
-                generatedComponentModel, resolvedBindings, frameworkInstanceCreationExpression);
+                componentImplementation, resolvedBindings, frameworkInstanceCreationExpression);
 
     switch (resolvedBindings.bindingType()) {
       case PROVISION:
@@ -306,7 +304,7 @@ private FrameworkInstanceBindingExpression frameworkInstanceBindingExpression(
             resolvedBindings, frameworkInstanceSupplier, types, elements);
       case PRODUCTION:
         return new ProducerNodeInstanceBindingExpression(
-            resolvedBindings, frameworkInstanceSupplier, types, elements, generatedComponentModel);
+            resolvedBindings, frameworkInstanceSupplier, types, elements, componentImplementation);
       default:
         throw new AssertionError("invalid binding type: " + resolvedBindings.bindingType());
     }
@@ -345,11 +343,11 @@ private FrameworkInstanceCreationExpression frameworkInstanceCreationExpression(
 
       case COMPONENT_PROVISION:
         return new DependencyMethodProviderCreationExpression(
-            binding, generatedComponentModel, componentRequirementFields, compilerOptions, graph);
+            binding, componentImplementation, componentRequirementFields, compilerOptions, graph);
 
       case SUBCOMPONENT_BUILDER:
         return new SubcomponentBuilderProviderCreationExpression(
-            binding.key().type(), generatedComponentModel.getSubcomponentName(binding.key()));
+            binding.key().type(), componentImplementation.getSubcomponentName(binding.key()));
 
       case INJECTION:
       case PROVISION:
@@ -359,25 +357,25 @@ private FrameworkInstanceCreationExpression frameworkInstanceCreationExpression(
 
       case COMPONENT_PRODUCTION:
         return new DependencyMethodProducerCreationExpression(
-            binding, generatedComponentModel, componentRequirementFields, graph);
+            binding, componentImplementation, componentRequirementFields, graph);
 
       case PRODUCTION:
         return new ProducerCreationExpression(binding, this);
 
       case MULTIBOUND_SET:
-        return new SetFactoryCreationExpression(binding, generatedComponentModel, this, graph);
+        return new SetFactoryCreationExpression(binding, componentImplementation, this, graph);
 
       case MULTIBOUND_MAP:
         return new MapFactoryCreationExpression(
-            binding, generatedComponentModel, this, graph, elements);
+            binding, componentImplementation, this, graph, elements);
 
       case DELEGATE:
         return new DelegatingFrameworkInstanceCreationExpression(
-            binding, generatedComponentModel, this);
+            binding, componentImplementation, this);
 
       case OPTIONAL:
         return new OptionalFactoryInstanceCreationExpression(
-            optionalFactories, binding, generatedComponentModel, this);
+            optionalFactories, binding, componentImplementation, this);
 
       case MEMBERS_INJECTOR:
         return new MembersInjectorProviderCreationExpression((ProvisionBinding) binding, this);
@@ -393,7 +391,7 @@ private InstanceFactoryCreationExpression instanceFactoryCreationExpression(
         binding.nullableType().isPresent(),
         () ->
             componentRequirementFields.getExpressionDuringInitialization(
-                componentRequirement, generatedComponentModel.name()));
+                componentRequirement, componentImplementation.name()));
   }
 
   /** Returns a binding expression for a provision binding. */
@@ -484,13 +482,13 @@ private FrameworkInstanceBindingExpression producerFromProviderBindingExpression
     return new ProducerNodeInstanceBindingExpression(
         resolvedBindings,
         new FrameworkFieldInitializer(
-            generatedComponentModel,
+            componentImplementation,
             resolvedBindings,
             new ProducerFromProviderCreationExpression(
-                resolvedBindings.contributionBinding(), generatedComponentModel, this)),
+                resolvedBindings.contributionBinding(), componentImplementation, this)),
         types,
         elements,
-        generatedComponentModel);
+        componentImplementation);
   }
 
   /**
@@ -535,7 +533,7 @@ private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBin
       case COMPONENT:
         return Optional.of(
             new ComponentInstanceBindingExpression(
-                resolvedBindings, generatedComponentModel.name()));
+                resolvedBindings, componentImplementation.name()));
 
       case COMPONENT_DEPENDENCY:
         return Optional.of(
@@ -553,17 +551,17 @@ private BindingExpression instanceBindingExpression(ResolvedBindings resolvedBin
         return Optional.of(
             new SubcomponentBuilderBindingExpression(
                 resolvedBindings,
-                generatedComponentModel.getSubcomponentName(resolvedBindings.key())));
+                componentImplementation.getSubcomponentName(resolvedBindings.key())));
 
       case MULTIBOUND_SET:
         return Optional.of(
             new SetBindingExpression(
-                resolvedBindings, generatedComponentModel, graph, this, types, elements));
+                resolvedBindings, componentImplementation, graph, this, types, elements));
 
       case MULTIBOUND_MAP:
         return Optional.of(
             new MapBindingExpression(
-                resolvedBindings, generatedComponentModel, graph, this, types, elements));
+                resolvedBindings, componentImplementation, graph, this, types, elements));
 
       case OPTIONAL:
         return Optional.of(new OptionalBindingExpression(resolvedBindings, this, types));
@@ -645,7 +643,7 @@ BindingExpression wrapInMethod(
     Optional<ComponentMethodDescriptor> matchingComponentMethod =
         graph.componentDescriptor().findMatchingComponentMethod(request);
     Optional<ModifiableBindingMethod> matchingModifiableBindingMethod =
-        generatedComponentModel.getModifiableBindingMethod(request);
+        componentImplementation.getModifiableBindingMethod(request);
 
     Optional<BindingExpression> modifiableBindingExpression =
         modifiableBindingExpressions.maybeWrapInModifiableMethodBindingExpression(
@@ -663,7 +661,7 @@ BindingExpression wrapInMethod(
             componentMethod ->
                 new ComponentMethodBindingExpression(
                     methodImplementation,
-                    generatedComponentModel,
+                    componentImplementation,
                     componentMethod,
                     matchingModifiableBindingMethod))
         .orElseGet(
@@ -672,7 +670,7 @@ BindingExpression wrapInMethod(
                     resolvedBindings,
                     request,
                     methodImplementation,
-                    generatedComponentModel,
+                    componentImplementation,
                     matchingModifiableBindingMethod));
   }
 
@@ -683,18 +681,18 @@ private BindingMethodImplementation methodImplementation(
     if (compilerOptions.fastInit()) {
       if (request.isRequestKind(RequestKind.PROVIDER)) {
         return new SingleCheckedMethodImplementation(
-            resolvedBindings, request, bindingExpression, types, generatedComponentModel);
+            resolvedBindings, request, bindingExpression, types, componentImplementation);
       } else if (request.isRequestKind(RequestKind.INSTANCE) && needsCaching(resolvedBindings)) {
         return resolvedBindings.scope().get().isReusable()
             ? new SingleCheckedMethodImplementation(
-                resolvedBindings, request, bindingExpression, types, generatedComponentModel)
+                resolvedBindings, request, bindingExpression, types, componentImplementation)
             : new DoubleCheckedMethodImplementation(
-                resolvedBindings, request, bindingExpression, types, generatedComponentModel);
+                resolvedBindings, request, bindingExpression, types, componentImplementation);
       }
     }
 
     return new BindingMethodImplementation(
-        resolvedBindings, request, bindingExpression, generatedComponentModel.name(), types);
+        resolvedBindings, request, bindingExpression, componentImplementation.name(), types);
   }
 
   /**
diff --git a/java/dagger/internal/codegen/ComponentGenerator.java b/java/dagger/internal/codegen/ComponentGenerator.java
index d15341cf3..0602d9edb 100644
--- a/java/dagger/internal/codegen/ComponentGenerator.java
+++ b/java/dagger/internal/codegen/ComponentGenerator.java
@@ -72,15 +72,15 @@ Element originatingElement(BindingGraph input) {
 
   @Override
   Optional<TypeSpec.Builder> write(ClassName componentName, BindingGraph input) {
-    return Optional.of(
-        ComponentModelBuilder.buildComponentModel(
-                types,
-                elements,
-                keyFactory,
-                compilerOptions,
-                componentName,
-                input,
-                bindingGraphFactory)
-            .generate());
+    ComponentImplementation componentImplementation =
+        ComponentImplementationBuilder.createComponentImplementation(
+            types,
+            elements,
+            keyFactory,
+            compilerOptions,
+            componentName,
+            input,
+            bindingGraphFactory);
+    return Optional.of(componentImplementation.generate());
   }
 }
diff --git a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
index cedc3896c..c8b59d3ac 100644
--- a/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
+++ b/java/dagger/internal/codegen/ComponentHjarProcessingStep.java
@@ -188,7 +188,7 @@ Element originatingElement(ComponentDescriptor input) {
       }
 
       DeclaredType componentType = MoreTypes.asDeclared(componentElement.asType());
-      // TODO(ronshapiro): unify with ComponentModelBuilder
+      // TODO(ronshapiro): unify with ComponentImplementationBuilder
       Set<MethodSignature> methodSignatures =
           Sets.newHashSetWithExpectedSize(componentDescriptor.componentMethods().size());
       componentDescriptor
diff --git a/java/dagger/internal/codegen/GeneratedComponentModel.java b/java/dagger/internal/codegen/ComponentImplementation.java
similarity index 82%
rename from java/dagger/internal/codegen/GeneratedComponentModel.java
rename to java/dagger/internal/codegen/ComponentImplementation.java
index c8a535060..03478613b 100644
--- a/java/dagger/internal/codegen/GeneratedComponentModel.java
+++ b/java/dagger/internal/codegen/ComponentImplementation.java
@@ -26,9 +26,6 @@
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.SourceFiles.simpleVariableName;
 import static javax.lang.model.element.Modifier.ABSTRACT;
-import static javax.lang.model.element.Modifier.FINAL;
-import static javax.lang.model.element.Modifier.PRIVATE;
-import static javax.lang.model.element.Modifier.PUBLIC;
 
 import com.google.auto.common.MoreTypes;
 import com.google.common.base.Supplier;
@@ -61,11 +58,11 @@
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.TypeMirror;
 
-/** The model of the component being generated. */
-final class GeneratedComponentModel {
-  /** A type of field that this component model can generate. */
-  // TODO(user, dpb): Move component requirements to top? The order should be component
-  // requirements, framework fields, private method fields, ... etc
+/** The implementation of a component type. */
+final class ComponentImplementation {
+  /** A type of field that this component can contain. */
+  // TODO(user, dpb): Move component requirements and reference managers to top? The order should
+  // be component requirements, reference managers, framework fields, private method fields, ... etc
   enum FieldSpecKind {
 
     /**
@@ -84,7 +81,7 @@
     ABSENT_OPTIONAL_FIELD
   }
 
-  /** A type of method that this component model can generate. */
+  /** A type of method that this component can contain. */
   // TODO(user, dpb): Change the oder to constructor, initialize, component, then private
   // (including MIM and AOMâ€”why treat those separately?).
   enum MethodSpecKind {
@@ -124,7 +121,7 @@
     ;
   }
 
-  /** A type of nested class that this component model can generate. */
+  /** A type of nested class that this component can contain. */
   enum TypeSpecKind {
     /** A factory class for a present optional binding. */
     PRESENT_FACTORY,
@@ -143,8 +140,8 @@
   private final ClassName name;
   private final NestingKind nestingKind;
   private final boolean isAbstract;
-  private final Optional<GeneratedComponentModel> supermodel;
-  private final Map<TypeElement, GeneratedComponentModel> subcomponentModels = new HashMap<>();
+  private final Optional<ComponentImplementation> superclassImplementation;
+  private final Map<TypeElement, ComponentImplementation> childImplementations = new HashMap<>();
   private final TypeSpec.Builder component;
   private final SubcomponentNames subcomponentNames;
   private final UniqueNameSet componentFieldNames = new UniqueNameSet();
@@ -163,11 +160,11 @@
       HashMultimap.create();
   private ImmutableList<ParameterSpec> constructorParameters;
 
-  private GeneratedComponentModel(
+  ComponentImplementation(
       ComponentDescriptor componentDescriptor,
       ClassName name,
       NestingKind nestingKind,
-      Optional<GeneratedComponentModel> supermodel,
+      Optional<ComponentImplementation> superclassImplementation,
       SubcomponentNames subcomponentNames,
       Modifier... modifiers) {
     checkName(name, nestingKind);
@@ -175,11 +172,26 @@ private GeneratedComponentModel(
     this.name = name;
     this.nestingKind = nestingKind;
     this.isAbstract = Arrays.asList(modifiers).contains(ABSTRACT);
-    this.supermodel = supermodel;
+    this.superclassImplementation = superclassImplementation;
     this.component = classBuilder(name).addModifiers(modifiers);
     this.subcomponentNames = subcomponentNames;
   }
 
+  ComponentImplementation(
+      ComponentImplementation parent,
+      ComponentDescriptor componentDescriptor,
+      Optional<ComponentImplementation> superclassImplementation,
+      Modifier... modifiers) {
+    this(
+        componentDescriptor,
+        parent.getSubcomponentName(componentDescriptor),
+        NestingKind.MEMBER,
+        superclassImplementation,
+        parent.subcomponentNames,
+        modifiers);
+  }
+
+  // TODO(dpb): Just determine the nesting kind from the name.
   private static void checkName(ClassName name, NestingKind nestingKind) {
     switch (nestingKind) {
       case TOP_LEVEL:
@@ -197,52 +209,6 @@ private static void checkName(ClassName name, NestingKind nestingKind) {
     }
   }
 
-  /** Creates a model for a root component or top-level abstract subcomponent. */
-  static GeneratedComponentModel create(ClassName name, BindingGraph graph, KeyFactory keyFactory) {
-    return new GeneratedComponentModel(
-        graph.componentDescriptor(),
-        name,
-        NestingKind.TOP_LEVEL,
-        Optional.empty(), // supermodel
-        new SubcomponentNames(graph, keyFactory),
-        PUBLIC,
-        graph.componentDescriptor().kind().isTopLevel() ? FINAL : ABSTRACT);
-  }
-
-  /**
-   * Create a model for a subcomponent. This is for concrete subcomponents implementations when not
-   * generating ahead-of-time subcomponents.
-   */
-  static GeneratedComponentModel forSubcomponent(
-      ComponentDescriptor componentDescriptor, GeneratedComponentModel parentModel) {
-    return new GeneratedComponentModel(
-        componentDescriptor,
-        parentModel.getSubcomponentName(componentDescriptor),
-        NestingKind.MEMBER,
-        Optional.empty(), // supermodel
-        parentModel.subcomponentNames,
-        PRIVATE,
-        FINAL);
-  }
-
-  /**
-   * Create a model for an inner implementation of a subcomponent. This is applicable when
-   * generating ahead-of-time subcomponents.
-   */
-  static GeneratedComponentModel forSubcomponent(
-      ComponentDescriptor componentDescriptor,
-      GeneratedComponentModel parentModel,
-      GeneratedComponentModel supermodel) {
-    return new GeneratedComponentModel(
-        componentDescriptor,
-        parentModel.getSubcomponentName(componentDescriptor),
-        NestingKind.MEMBER,
-        Optional.of(supermodel),
-        parentModel.subcomponentNames,
-        PUBLIC,
-        parentModel.isAbstract() ? ABSTRACT : FINAL);
-  }
-
   /** Returns the descriptor for the component being generated. */
   ComponentDescriptor componentDescriptor() {
     return componentDescriptor;
@@ -263,12 +229,12 @@ boolean isAbstract() {
     return isAbstract;
   }
 
-  /** Returns the model of this model's superclass. */
-  Optional<GeneratedComponentModel> supermodel() {
-    return supermodel;
+  /** Returns the superclass implementation. */
+  Optional<ComponentImplementation> superclassImplementation() {
+    return superclassImplementation;
   }
 
-  /** Returns the arguments to the modeled class's constructor. */
+  /** Returns the constructor parameters. */
   ImmutableList<ParameterSpec> constructorParameters() {
     return constructorParameters;
   }
@@ -284,7 +250,7 @@ ClassName getBuilderName() {
   }
 
   /** Returns the name of the nested implementation class for a child component. */
-  private ClassName getSubcomponentName(ComponentDescriptor childDescriptor) {
+  ClassName getSubcomponentName(ComponentDescriptor childDescriptor) {
     checkArgument(
         componentDescriptor.subcomponents().contains(childDescriptor),
         "%s is not a child of %s",
@@ -298,9 +264,9 @@ String getSubcomponentName(Key key) {
     return subcomponentNames.get(key);
   }
 
-  /** Returns the model of the child subcomponent. */
-  Optional<GeneratedComponentModel> subcomponentModel(ComponentDescriptor subcomponent) {
-    return Optional.ofNullable(subcomponentModels.get(subcomponent.componentDefinitionType()));
+  /** Returns the child implementation. */
+  Optional<ComponentImplementation> childImplementation(ComponentDescriptor child) {
+    return Optional.ofNullable(childImplementations.get(child.componentDefinitionType()));
   }
 
   /** Returns {@code true} if {@code type} is accessible from the generated component. */
@@ -316,8 +282,8 @@ void addSupertype(TypeElement supertype) {
   /** Adds the given super class to the subcomponent. */
   void addSuperclass(ClassName className) {
     checkState(
-        supermodel.isPresent(),
-        "Setting the supertype for model [%s] as a class when model has no supermodel.",
+        superclassImplementation.isPresent(),
+        "Setting the superclass for component [%s] when there is no superclass implementation.",
         name);
     component.superclass(className);
   }
@@ -387,11 +353,10 @@ void addTypes(TypeSpecKind typeKind, Iterable<TypeSpec> typeSpecs) {
     typeSpecsMap.putAll(typeKind, typeSpecs);
   }
 
-  /** Adds the type generated from the given subcomponent model. */
-  void addSubcomponent(
-      ComponentDescriptor subcomponent, GeneratedComponentModel subcomponentModel) {
-    subcomponentModels.put(subcomponent.componentDefinitionType(), subcomponentModel);
-    addType(TypeSpecKind.SUBCOMPONENT, subcomponentModel.generate().build());
+  /** Adds the type generated from the given child implementation. */
+  void addChild(ComponentDescriptor child, ComponentImplementation childImplementation) {
+    childImplementations.put(child.componentDefinitionType(), childImplementation);
+    addType(TypeSpecKind.SUBCOMPONENT, childImplementation.generate().build());
   }
 
   /** Adds a {@link Supplier} for the SwitchingProvider for the component. */
@@ -478,9 +443,9 @@ void claimMethodName(CharSequence name) {
   ImmutableList<ModifiableBindingMethod> getModifiableBindingMethods() {
     ImmutableList.Builder<ModifiableBindingMethod> modifiableBindingMethodsBuilder =
         ImmutableList.builder();
-    if (supermodel.isPresent()) {
+    if (superclassImplementation.isPresent()) {
       ImmutableList<ModifiableBindingMethod> superclassModifiableBindingMethods =
-          supermodel.get().getModifiableBindingMethods();
+          superclassImplementation.get().getModifiableBindingMethods();
       superclassModifiableBindingMethods.stream()
           .filter(method -> !modifiableBindingMethods.finalized(method))
           .forEach(modifiableBindingMethodsBuilder::add);
@@ -495,8 +460,8 @@ void claimMethodName(CharSequence name) {
    */
   Optional<ModifiableBindingMethod> getModifiableBindingMethod(BindingRequest request) {
     Optional<ModifiableBindingMethod> method = modifiableBindingMethods.getMethod(request);
-    if (!method.isPresent() && supermodel.isPresent()) {
-      return supermodel.get().getModifiableBindingMethod(request);
+    if (!method.isPresent() && superclassImplementation.isPresent()) {
+      return superclassImplementation.get().getModifiableBindingMethod(request);
     }
     return method;
   }
@@ -530,7 +495,9 @@ void registerImplementedMultibinding(ContributionBinding multibinding) {
    * a multibinding.
    */
   ImmutableSet<DependencyRequest> superclassContributionsMade(Key key) {
-    return supermodel.map(s -> s.getAllMultibindingContributions(key)).orElse(ImmutableSet.of());
+    return superclassImplementation
+        .map(s -> s.getAllMultibindingContributions(key))
+        .orElse(ImmutableSet.of());
   }
 
   /**
diff --git a/java/dagger/internal/codegen/ComponentModelBuilder.java b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
similarity index 71%
rename from java/dagger/internal/codegen/ComponentModelBuilder.java
rename to java/dagger/internal/codegen/ComponentImplementationBuilder.java
index dc826e049..c6d9f5428 100644
--- a/java/dagger/internal/codegen/ComponentModelBuilder.java
+++ b/java/dagger/internal/codegen/ComponentImplementationBuilder.java
@@ -24,15 +24,16 @@
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
 import static dagger.internal.codegen.BindingRequest.bindingRequest;
 import static dagger.internal.codegen.CodeBlocks.toParametersCodeBlock;
+import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.BUILDER_METHOD;
+import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.CANCELLATION_LISTENER_METHOD;
+import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.COMPONENT_METHOD;
+import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.CONSTRUCTOR;
+import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.INITIALIZE_METHOD;
+import static dagger.internal.codegen.ComponentImplementation.TypeSpecKind.COMPONENT_BUILDER;
+import static dagger.internal.codegen.ComponentImplementation.TypeSpecKind.SUBCOMPONENT;
 import static dagger.internal.codegen.DaggerStreams.toImmutableList;
-import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.BUILDER_METHOD;
-import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.CANCELLATION_LISTENER_METHOD;
-import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.COMPONENT_METHOD;
-import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.CONSTRUCTOR;
-import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.INITIALIZE_METHOD;
-import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.COMPONENT_BUILDER;
-import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.SUBCOMPONENT;
 import static dagger.producers.CancellationPolicy.Propagation.PROPAGATE;
+import static javax.lang.model.element.Modifier.ABSTRACT;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.PROTECTED;
@@ -58,13 +59,15 @@
 import java.util.List;
 import java.util.Optional;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.NestingKind;
 import javax.lang.model.type.DeclaredType;
 
-/** Builds the model for an implementation of a component or subcomponent. */
-abstract class ComponentModelBuilder {
+/** Builder for {@link ComponentImplementation}s. */
+// TODO(dpb): Refactor into a true factory with inner "builder" classes.
+abstract class ComponentImplementationBuilder {
   private static final String MAY_INTERRUPT_IF_RUNNING = "mayInterruptIfRunning";
 
-  static GeneratedComponentModel buildComponentModel(
+  static ComponentImplementation createComponentImplementation(
       DaggerTypes types,
       DaggerElements elements,
       KeyFactory keyFactory,
@@ -72,35 +75,36 @@ static GeneratedComponentModel buildComponentModel(
       ClassName name,
       BindingGraph graph,
       BindingGraphFactory bindingGraphFactory) {
-    GeneratedComponentModel generatedComponentModel =
-        GeneratedComponentModel.create(name, graph, keyFactory);
-    OptionalFactories optionalFactories = new OptionalFactories(generatedComponentModel);
+    ComponentImplementation componentImplementation =
+        topLevelImplementation(name, graph, keyFactory);
+    OptionalFactories optionalFactories = new OptionalFactories(componentImplementation);
     Optional<GeneratedComponentBuilderModel> generatedComponentBuilderModel =
-        GeneratedComponentBuilderModel.create(generatedComponentModel, graph, elements, types);
+        GeneratedComponentBuilderModel.create(componentImplementation, graph, elements, types);
     ComponentRequirementFields componentRequirementFields =
         new ComponentRequirementFields(
-            graph, generatedComponentModel, generatedComponentBuilderModel);
+            graph, componentImplementation, generatedComponentBuilderModel);
     ComponentBindingExpressions bindingExpressions =
         new ComponentBindingExpressions(
             graph,
-            generatedComponentModel,
+            componentImplementation,
             componentRequirementFields,
             optionalFactories,
             types,
             elements,
             compilerOptions);
-    if (generatedComponentModel.isAbstract()) {
+    if (componentImplementation.isAbstract()) {
       checkState(
           compilerOptions.aheadOfTimeSubcomponents(),
-          "Calling 'buildComponentModel()' on %s when not generating ahead-of-time subcomponents.",
+          "Calling 'componentImplementation()' on %s when not generating ahead-of-time "
+              + "subcomponents.",
           graph.componentDescriptor().componentDefinitionType());
-      return new SubComponentModelBuilder(
+      return new SubcomponentImplementationBuilder(
               Optional.empty(), /* parent */
               types,
               elements,
               keyFactory,
               graph,
-              generatedComponentModel,
+              componentImplementation,
               optionalFactories,
               bindingExpressions,
               componentRequirementFields,
@@ -109,12 +113,12 @@ static GeneratedComponentModel buildComponentModel(
               compilerOptions)
           .build();
     } else {
-      return new RootComponentModelBuilder(
+      return new RootComponentImplementationBuilder(
               types,
               elements,
               keyFactory,
               graph,
-              generatedComponentModel,
+              componentImplementation,
               optionalFactories,
               bindingExpressions,
               componentRequirementFields,
@@ -125,25 +129,38 @@ static GeneratedComponentModel buildComponentModel(
     }
   }
 
+  /** Creates a root component or top-level abstract subcomponent implementation. */
+  static ComponentImplementation topLevelImplementation(
+      ClassName name, BindingGraph graph, KeyFactory keyFactory) {
+    return new ComponentImplementation(
+        graph.componentDescriptor(),
+        name,
+        NestingKind.TOP_LEVEL,
+        Optional.empty(), // superclassImplementation
+        new SubcomponentNames(graph, keyFactory),
+        PUBLIC,
+        graph.componentDescriptor().kind().isTopLevel() ? FINAL : ABSTRACT);
+  }
+
   private final DaggerElements elements;
   private final DaggerTypes types;
   private final KeyFactory keyFactory;
   private final BindingGraph graph;
   private final ComponentBindingExpressions bindingExpressions;
   private final ComponentRequirementFields componentRequirementFields;
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final OptionalFactories optionalFactories;
   private final Optional<GeneratedComponentBuilderModel> generatedComponentBuilderModel;
   private final BindingGraphFactory bindingGraphFactory;
   private final CompilerOptions compilerOptions;
   private boolean done;
 
-  private ComponentModelBuilder(
+  private ComponentImplementationBuilder(
       DaggerTypes types,
       DaggerElements elements,
       KeyFactory keyFactory,
       BindingGraph graph,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       OptionalFactories optionalFactories,
       ComponentBindingExpressions bindingExpressions,
       ComponentRequirementFields componentRequirementFields,
@@ -154,7 +171,7 @@ private ComponentModelBuilder(
     this.elements = elements;
     this.keyFactory = keyFactory;
     this.graph = graph;
-    this.generatedComponentModel = generatedComponentModel;
+    this.componentImplementation = componentImplementation;
     this.optionalFactories = optionalFactories;
     this.bindingExpressions = bindingExpressions;
     this.componentRequirementFields = componentRequirementFields;
@@ -164,15 +181,15 @@ private ComponentModelBuilder(
   }
 
   /**
-   * Returns a {@link GeneratedComponentModel} for this component. This is only intended to be
+   * Returns a {@link ComponentImplementation} for this component. This is only intended to be
    * called once (and will throw on successive invocations). If the component must be regenerated,
    * use a new instance.
    */
-  protected final GeneratedComponentModel build() {
+  protected final ComponentImplementation build() {
     checkState(
         !done,
-        "ComponentModelBuilder has already built the GeneratedComponentModel for [%s].",
-        generatedComponentModel.name());
+        "ComponentImplementationBuilder has already built the ComponentImplementation for [%s].",
+        componentImplementation.name());
     setSupertype();
     generatedComponentBuilderModel
         .map(GeneratedComponentBuilderModel::typeSpec)
@@ -180,11 +197,11 @@ protected final GeneratedComponentModel build() {
 
     getLocalAndInheritedMethods(
             graph.componentDescriptor().componentDefinitionType(), types, elements)
-        .forEach(method -> generatedComponentModel.claimMethodName(method.getSimpleName()));
+        .forEach(method -> componentImplementation.claimMethodName(method.getSimpleName()));
 
     addFactoryMethods();
     addInterfaceMethods();
-    addSubcomponents();
+    addChildComponents();
     addConstructor();
 
     if (graph.componentDescriptor().kind().isProducer()) {
@@ -192,15 +209,16 @@ protected final GeneratedComponentModel build() {
     }
 
     done = true;
-    return generatedComponentModel;
+    return componentImplementation;
   }
 
   /** Set the supertype for this generated class. */
   private void setSupertype() {
-    if (generatedComponentModel.supermodel().isPresent()) {
-      generatedComponentModel.addSuperclass(generatedComponentModel.supermodel().get().name());
+    if (componentImplementation.superclassImplementation().isPresent()) {
+      componentImplementation.addSuperclass(
+          componentImplementation.superclassImplementation().get().name());
     } else {
-      generatedComponentModel.addSupertype(graph.componentType());
+      componentImplementation.addSupertype(graph.componentType());
     }
   }
 
@@ -231,7 +249,7 @@ protected void addInterfaceMethods() {
 
       // If the method should be implemented in this component, implement it.
       if (modifiableBindingType.hasBaseClassImplementation()) {
-        generatedComponentModel.addMethod(COMPONENT_METHOD, methodSpec);
+        componentImplementation.addMethod(COMPONENT_METHOD, methodSpec);
       }
     }
   }
@@ -241,22 +259,23 @@ protected void addInterfaceMethods() {
   private static final String CANCELLATION_LISTENER_METHOD_NAME = "onProducerFutureCancelled";
 
   private void addCancellationListenerImplementation() {
-    generatedComponentModel.addSupertype(elements.getTypeElement(CancellationListener.class));
-    generatedComponentModel.claimMethodName(CANCELLATION_LISTENER_METHOD_NAME);
+    componentImplementation.addSupertype(elements.getTypeElement(CancellationListener.class));
+    componentImplementation.claimMethodName(CANCELLATION_LISTENER_METHOD_NAME);
 
     MethodSpec.Builder methodBuilder =
         methodBuilder(CANCELLATION_LISTENER_METHOD_NAME)
             .addModifiers(PUBLIC)
             .addAnnotation(Override.class)
             .addParameter(boolean.class, MAY_INTERRUPT_IF_RUNNING);
-    if (generatedComponentModel.supermodel().isPresent()) {
+    if (componentImplementation.superclassImplementation().isPresent()) {
       methodBuilder.addStatement(
           "super.$L($L)", CANCELLATION_LISTENER_METHOD_NAME, MAY_INTERRUPT_IF_RUNNING);
     }
 
     ImmutableList<CodeBlock> cancellationStatements = cancellationStatements();
-    if (cancellationStatements.isEmpty() && generatedComponentModel.supermodel().isPresent()) {
-      // Partial subcomponent implementations that have no new cancellations don't need to override
+    if (cancellationStatements.isEmpty()
+        && componentImplementation.superclassImplementation().isPresent()) {
+      // Partial child implementations that have no new cancellations don't need to override
       // the method just to call super().
       return;
     }
@@ -267,7 +286,7 @@ private void addCancellationListenerImplementation() {
       List<List<CodeBlock>> partitions =
           Lists.partition(cancellationStatements, STATEMENTS_PER_METHOD);
       for (List<CodeBlock> partition : partitions) {
-        String methodName = generatedComponentModel.getUniqueMethodName("cancelProducers");
+        String methodName = componentImplementation.getUniqueMethodName("cancelProducers");
         MethodSpec method =
             MethodSpec.methodBuilder(methodName)
                 .addModifiers(PRIVATE)
@@ -275,13 +294,13 @@ private void addCancellationListenerImplementation() {
                 .addCode(CodeBlocks.concat(partition))
                 .build();
         methodBuilder.addStatement("$N($L)", method, MAY_INTERRUPT_IF_RUNNING);
-        generatedComponentModel.addMethod(CANCELLATION_LISTENER_METHOD, method);
+        componentImplementation.addMethod(CANCELLATION_LISTENER_METHOD, method);
       }
     }
 
     addCancelParentStatement(methodBuilder);
 
-    generatedComponentModel.addMethod(CANCELLATION_LISTENER_METHOD, methodBuilder.build());
+    componentImplementation.addMethod(CANCELLATION_LISTENER_METHOD, methodBuilder.build());
   }
 
   private ImmutableList<CodeBlock> cancellationStatements() {
@@ -295,7 +314,7 @@ private void addCancellationListenerImplementation() {
     // propagate through most of the graph, making most of the cancel calls that follow in the
     // onProducerFutureCancelled method do nothing.
     ImmutableList<Key> cancellationKeys =
-        generatedComponentModel.getCancellableProducerKeys().reverse();
+        componentImplementation.getCancellableProducerKeys().reverse();
 
     ImmutableList.Builder<CodeBlock> cancellationStatements = ImmutableList.builder();
     for (Key cancellationKey : cancellationKeys) {
@@ -306,7 +325,7 @@ private void addCancellationListenerImplementation() {
               bindingExpressions
                   .getDependencyExpression(
                       bindingRequest(cancellationKey, FrameworkType.PRODUCER_NODE),
-                      generatedComponentModel.name())
+                      componentImplementation.name())
                   .codeBlock(),
               MAY_INTERRUPT_IF_RUNNING));
     }
@@ -324,36 +343,37 @@ private MethodSignature getMethodSignature(ComponentMethodDescriptor method) {
         method, MoreTypes.asDeclared(graph.componentType().asType()), types);
   }
 
-  private void addSubcomponents() {
+  private void addChildComponents() {
     for (BindingGraph subgraph : graph.subgraphs()) {
       // TODO(b/117833324): Can an abstract inner subcomponent implementation be elided if it's
       // totally empty?
-      generatedComponentModel.addSubcomponent(
-          subgraph.componentDescriptor(), buildSubcomponentModel(subgraph));
+      componentImplementation.addChild(
+          subgraph.componentDescriptor(), buildChildImplementation(subgraph));
     }
   }
 
-  private GeneratedComponentModel getSubcomponentSupermodel(ComponentDescriptor subcomponent) {
-    // If the current model is for a subcomponent that has a defined supermodel, that supermodel
-    // should contain a reference to a model for `subcomponent`
-    if (generatedComponentModel.supermodel().isPresent()) {
-      Optional<GeneratedComponentModel> supermodel =
-          generatedComponentModel.supermodel().get().subcomponentModel(subcomponent);
+  private ComponentImplementation getChildSuperclassImplementation(ComponentDescriptor child) {
+    // If the current component has a superclass implementation, that superclass
+    // should contain a reference to the child.
+    if (componentImplementation.superclassImplementation().isPresent()) {
+      ComponentImplementation superclassImplementation =
+          componentImplementation.superclassImplementation().get();
+      Optional<ComponentImplementation> childSuperclassImplementation =
+          superclassImplementation.childImplementation(child);
       checkState(
-          supermodel.isPresent(),
-          "Attempting to generate an implementation of a subcomponent [%s] whose parent is a "
-              + "subcomponent [%s], but whose supermodel is not present on the parent's "
-              + "supermodel.",
-          subcomponent.componentDefinitionType(),
-          graph.componentType());
-      return supermodel.get();
+          childSuperclassImplementation.isPresent(),
+          "Cannot find abstract implementation of %s within %s while generating implemention "
+              + "within %s",
+          child.componentDefinitionType(),
+          superclassImplementation.name(),
+          componentImplementation.name());
+      return childSuperclassImplementation.get();
     }
 
-    // Otherwise, the enclosing component is top-level, so we must generate the supermodel for the
-    // subcomponent. We do so by building the model for the abstract base class for the
-    // subcomponent. This is done by truncating the binding graph at the subcomponent.
-    BindingGraph truncatedBindingGraph = bindingGraphFactory.create(subcomponent);
-    return buildComponentModel(
+    // Otherwise, the enclosing component is top-level, so we must recreate the implementation
+    // object for the base implementation of the child by truncating the binding graph at the child.
+    BindingGraph truncatedBindingGraph = bindingGraphFactory.create(child);
+    return createComponentImplementation(
         // TODO(ronshapiro): extract a factory class here so that we don't need to pass around
         // types, elements, keyFactory, etc...
         types,
@@ -365,33 +385,26 @@ private GeneratedComponentModel getSubcomponentSupermodel(ComponentDescriptor su
         bindingGraphFactory);
   }
 
-  private GeneratedComponentModel buildSubcomponentModel(BindingGraph childGraph) {
-    GeneratedComponentModel childModel;
-    if (compilerOptions.aheadOfTimeSubcomponents()) {
-      childModel =
-          GeneratedComponentModel.forSubcomponent(
-              childGraph.componentDescriptor(),
-              generatedComponentModel,
-              getSubcomponentSupermodel(childGraph.componentDescriptor()));
-    } else {
-      childModel =
-          GeneratedComponentModel.forSubcomponent(
-              childGraph.componentDescriptor(), generatedComponentModel);
-    }
+  private ComponentImplementation buildChildImplementation(BindingGraph childGraph) {
+    ComponentImplementation childImplementation =
+        compilerOptions.aheadOfTimeSubcomponents()
+            ? abstractInnerSubcomponent(childGraph.componentDescriptor())
+            : concreteSubcomponent(childGraph.componentDescriptor());
     Optional<GeneratedComponentBuilderModel> childBuilderModel =
-        GeneratedComponentBuilderModel.create(childModel, childGraph, elements, types);
+        GeneratedComponentBuilderModel.create(childImplementation, childGraph, elements, types);
     ComponentRequirementFields childComponentRequirementFields =
-        componentRequirementFields.forChildComponent(childGraph, childModel, childBuilderModel);
+        componentRequirementFields.forChildComponent(
+            childGraph, childImplementation, childBuilderModel);
     ComponentBindingExpressions childBindingExpressions =
         bindingExpressions.forChildComponent(
-            childGraph, childModel, childComponentRequirementFields);
-    return new SubComponentModelBuilder(
+            childGraph, childImplementation, childComponentRequirementFields);
+    return new SubcomponentImplementationBuilder(
             Optional.of(this),
             types,
             elements,
             keyFactory,
             childGraph,
-            childModel,
+            childImplementation,
             optionalFactories,
             childBindingExpressions,
             childComponentRequirementFields,
@@ -401,24 +414,44 @@ private GeneratedComponentModel buildSubcomponentModel(BindingGraph childGraph)
         .build();
   }
 
+  /** Creates an inner abstract subcomponent implementation. */
+  private ComponentImplementation abstractInnerSubcomponent(ComponentDescriptor child) {
+    return new ComponentImplementation(
+        componentImplementation,
+        child,
+        Optional.of(getChildSuperclassImplementation(child)),
+        PUBLIC,
+        componentImplementation.isAbstract() ? ABSTRACT : FINAL);
+  }
+
+  /** Creates a concrete inner subcomponent implementation. */
+  private ComponentImplementation concreteSubcomponent(ComponentDescriptor child) {
+    return new ComponentImplementation(
+        componentImplementation,
+        child,
+        Optional.empty(), // superclassImplementation
+        PRIVATE,
+        FINAL);
+  }
+
   private void addConstructor() {
     List<List<CodeBlock>> partitions =
-        Lists.partition(generatedComponentModel.getInitializations(), STATEMENTS_PER_METHOD);
+        Lists.partition(componentImplementation.getInitializations(), STATEMENTS_PER_METHOD);
 
     ImmutableList<ParameterSpec> constructorParameters = constructorParameters();
     MethodSpec.Builder constructor =
         constructorBuilder()
-            .addModifiers(generatedComponentModel.isAbstract() ? PROTECTED : PRIVATE)
+            .addModifiers(componentImplementation.isAbstract() ? PROTECTED : PRIVATE)
             .addParameters(constructorParameters);
-    generatedComponentModel.setConstructorParameters(constructorParameters);
-    generatedComponentModel
-        .supermodel()
+    componentImplementation.setConstructorParameters(constructorParameters);
+    componentImplementation
+        .superclassImplementation()
         .ifPresent(
-            supermodel ->
+            superclassImplementation ->
                 constructor.addStatement(
                     CodeBlock.of(
                         "super($L)",
-                        supermodel.constructorParameters().stream()
+                        superclassImplementation.constructorParameters().stream()
                             .map(param -> CodeBlock.of("$N", param))
                             .collect(toParametersCodeBlock()))));
 
@@ -430,7 +463,7 @@ private void addConstructor() {
             .collect(toParametersCodeBlock());
 
     for (List<CodeBlock> partition : partitions) {
-      String methodName = generatedComponentModel.getUniqueMethodName("initialize");
+      String methodName = componentImplementation.getUniqueMethodName("initialize");
       MethodSpec.Builder initializeMethod =
           methodBuilder(methodName)
               .addModifiers(PRIVATE)
@@ -442,9 +475,9 @@ private void addConstructor() {
               .addCode(CodeBlocks.concat(partition));
       initializeMethod.addParameters(initializeParameters);
       constructor.addStatement("$L($L)", methodName, initializeParametersCodeBlock);
-      generatedComponentModel.addMethod(INITIALIZE_METHOD, initializeMethod.build());
+      componentImplementation.addMethod(INITIALIZE_METHOD, initializeMethod.build());
     }
-    generatedComponentModel.addMethod(CONSTRUCTOR, constructor.build());
+    componentImplementation.addMethod(CONSTRUCTOR, constructor.build());
   }
 
   /** Returns the list of {@link ParameterSpec}s for the initialize methods. */
@@ -460,13 +493,13 @@ private void addConstructor() {
     if (generatedComponentBuilderModel.isPresent()) {
       return ImmutableList.of(
           ParameterSpec.builder(generatedComponentBuilderModel.get().name(), "builder").build());
-    } else if (generatedComponentModel.isAbstract() && generatedComponentModel.isNested()) {
+    } else if (componentImplementation.isAbstract() && componentImplementation.isNested()) {
       // If we're generating an abstract inner subcomponent, then we are not implementing module
       // instance bindings and have no need for factory method parameters.
       return ImmutableList.of();
     } else if (graph.factoryMethod().isPresent()) {
       return getFactoryMethodParameterSpecs(graph);
-    } else if (generatedComponentModel.isAbstract()) {
+    } else if (componentImplementation.isAbstract()) {
       // If we're generating an abstract base implementation of a subcomponent it's acceptable to
       // have neither a builder nor factory method.
       return ImmutableList.of();
@@ -476,14 +509,15 @@ private void addConstructor() {
     }
   }
 
-  /** Builds the model for the root component. */
-  private static final class RootComponentModelBuilder extends ComponentModelBuilder {
-    RootComponentModelBuilder(
+  /** Builds a root component implementation. */
+  private static final class RootComponentImplementationBuilder
+      extends ComponentImplementationBuilder {
+    RootComponentImplementationBuilder(
         DaggerTypes types,
         DaggerElements elements,
         KeyFactory keyFactory,
         BindingGraph graph,
-        GeneratedComponentModel generatedComponentModel,
+        ComponentImplementation componentImplementation,
         OptionalFactories optionalFactories,
         ComponentBindingExpressions bindingExpressions,
         ComponentRequirementFields componentRequirementFields,
@@ -495,7 +529,7 @@ private void addConstructor() {
           elements,
           keyFactory,
           graph,
-          generatedComponentModel,
+          componentImplementation,
           optionalFactories,
           bindingExpressions,
           componentRequirementFields,
@@ -506,7 +540,7 @@ private void addConstructor() {
 
     @Override
     protected void addBuilderClass(TypeSpec builder) {
-      super.generatedComponentModel.addType(COMPONENT_BUILDER, builder);
+      super.componentImplementation.addType(COMPONENT_BUILDER, builder);
     }
 
     @Override
@@ -522,11 +556,11 @@ protected void addFactoryMethods() {
                       : super.generatedComponentBuilderModel.get().name())
               .addStatement("return new $T()", super.generatedComponentBuilderModel.get().name())
               .build();
-      super.generatedComponentModel.addMethod(BUILDER_METHOD, builderFactoryMethod);
+      super.componentImplementation.addMethod(BUILDER_METHOD, builderFactoryMethod);
       if (canInstantiateAllRequirements()) {
         CharSequence buildMethodName =
             builderSpec().isPresent() ? builderSpec().get().buildMethod().getSimpleName() : "build";
-        super.generatedComponentModel.addMethod(
+        super.componentImplementation.addMethod(
             BUILDER_METHOD,
             methodBuilder("create")
                 .returns(ClassName.get(super.graph.componentType()))
@@ -549,23 +583,24 @@ private boolean canInstantiateAllRequirements() {
   }
 
   /**
-   * Builds the model for a subcomponent. If generating ahead-of-time subcomponents this model may
-   * be for an abstract base class implementation, an abstract inner implementation, or a concrete
+   * Builds a subcomponent implementation. If generating ahead-of-time subcomponents, this may be an
+   * abstract base class implementation, an abstract inner implementation, or a concrete
    * implementation that extends an abstract base implementation. Otherwise it represents a private,
    * inner, concrete, final implementation of a subcomponent which extends a user defined type.
    */
-  private static final class SubComponentModelBuilder extends ComponentModelBuilder {
-    private final Optional<ComponentModelBuilder> parent;
-    private final GeneratedComponentModel generatedComponentModel;
+  private static final class SubcomponentImplementationBuilder
+      extends ComponentImplementationBuilder {
+    private final Optional<ComponentImplementationBuilder> parent;
+    private final ComponentImplementation componentImplementation;
     private final ComponentBindingExpressions bindingExpressions;
 
-    SubComponentModelBuilder(
-        Optional<ComponentModelBuilder> parent,
+    SubcomponentImplementationBuilder(
+        Optional<ComponentImplementationBuilder> parent,
         DaggerTypes types,
         DaggerElements elements,
         KeyFactory keyFactory,
         BindingGraph graph,
-        GeneratedComponentModel generatedComponentModel,
+        ComponentImplementation componentImplementation,
         OptionalFactories optionalFactories,
         ComponentBindingExpressions bindingExpressions,
         ComponentRequirementFields componentRequirementFields,
@@ -577,7 +612,7 @@ private boolean canInstantiateAllRequirements() {
           elements,
           keyFactory,
           graph,
-          generatedComponentModel,
+          componentImplementation,
           optionalFactories,
           bindingExpressions,
           componentRequirementFields,
@@ -585,7 +620,7 @@ private boolean canInstantiateAllRequirements() {
           bindingGraphFactory,
           compilerOptions);
       this.parent = parent;
-      this.generatedComponentModel = generatedComponentModel;
+      this.componentImplementation = componentImplementation;
       this.bindingExpressions = bindingExpressions;
     }
 
@@ -593,16 +628,16 @@ private boolean canInstantiateAllRequirements() {
     protected void addBuilderClass(TypeSpec builder) {
       if (parent.isPresent()) {
         // In an inner implementation of a subcomponent the builder is a peer class.
-        parent.get().generatedComponentModel.addType(SUBCOMPONENT, builder);
+        parent.get().componentImplementation.addType(SUBCOMPONENT, builder);
       } else {
-        generatedComponentModel.addType(SUBCOMPONENT, builder);
+        componentImplementation.addType(SUBCOMPONENT, builder);
       }
     }
 
     @Override
     protected void addFactoryMethods() {
       // Only construct instances of subcomponents that have concrete implementations.
-      if (!generatedComponentModel.isAbstract()) {
+      if (!componentImplementation.isAbstract()) {
         // Use the parent's factory method to create this subcomponent if the
         // subcomponent was not added via {@link dagger.Module#subcomponents()}.
         super.graph.factoryMethod().ifPresent(this::createSubcomponentFactoryMethod);
@@ -613,13 +648,13 @@ private void createSubcomponentFactoryMethod(ExecutableElement factoryMethod) {
       checkState(parent.isPresent());
       parent
           .get()
-          .generatedComponentModel
+          .componentImplementation
           .addMethod(
               COMPONENT_METHOD,
               MethodSpec.overriding(factoryMethod, parentType(), super.types)
                   .addStatement(
                       "return new $T($L)",
-                      generatedComponentModel.name(),
+                      componentImplementation.name(),
                       getFactoryMethodParameterSpecs(super.graph).stream()
                           .map(param -> CodeBlock.of("$N", param))
                           .collect(toParametersCodeBlock()))
@@ -632,18 +667,18 @@ private DeclaredType parentType() {
 
     @Override
     protected void addInterfaceMethods() {
-      if (generatedComponentModel.supermodel().isPresent()) {
+      if (componentImplementation.superclassImplementation().isPresent()) {
         // Since we're overriding a subcomponent implementation we add to its implementation given
         // an expanded binding graph.
 
         // Override modifiable binding methods.
         for (ModifiableBindingMethod modifiableBindingMethod :
-            generatedComponentModel.getModifiableBindingMethods()) {
+            componentImplementation.getModifiableBindingMethods()) {
           bindingExpressions
               .modifiableBindingExpressions()
               .getModifiableBindingMethod(modifiableBindingMethod)
               .ifPresent(
-                  method -> generatedComponentModel.addImplementedModifiableBindingMethod(method));
+                  method -> componentImplementation.addImplementedModifiableBindingMethod(method));
         }
       } else {
         super.addInterfaceMethods();
@@ -655,7 +690,7 @@ protected void addCancelParentStatement(MethodSpec.Builder methodBuilder) {
       if (shouldPropagateCancellationToParent()) {
         methodBuilder.addStatement(
             "$T.this.$L($L)",
-            parent.get().generatedComponentModel.name(),
+            parent.get().componentImplementation.name(),
             CANCELLATION_LISTENER_METHOD_NAME,
             MAY_INTERRUPT_IF_RUNNING);
       }
@@ -665,7 +700,7 @@ private boolean shouldPropagateCancellationToParent() {
       return parent.isPresent()
           && parent
               .get()
-              .generatedComponentModel
+              .componentImplementation
               .componentDescriptor()
               .cancellationPolicy()
               .map(policy -> policy.fromSubcomponents().equals(PROPAGATE))
diff --git a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
index c678e2904..5d3db3bf8 100644
--- a/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/ComponentMethodBindingExpression.java
@@ -32,23 +32,23 @@
  */
 final class ComponentMethodBindingExpression extends MethodBindingExpression {
   private final BindingMethodImplementation methodImplementation;
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final ComponentMethodDescriptor componentMethod;
 
   ComponentMethodBindingExpression(
       BindingMethodImplementation methodImplementation,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       ComponentMethodDescriptor componentMethod,
       Optional<ModifiableBindingMethod> matchingModifiableBindingMethod) {
-    super(methodImplementation, generatedComponentModel, matchingModifiableBindingMethod);
+    super(methodImplementation, componentImplementation, matchingModifiableBindingMethod);
     this.methodImplementation = checkNotNull(methodImplementation);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.componentImplementation = checkNotNull(componentImplementation);
     this.componentMethod = checkNotNull(componentMethod);
   }
 
   @Override
   protected CodeBlock getComponentMethodImplementation(
-      ComponentMethodDescriptor componentMethod, GeneratedComponentModel component) {
+      ComponentMethodDescriptor componentMethod, ComponentImplementation component) {
     // There could be several methods on the component for the same request key and kind.
     // Only one should use the BindingMethodImplementation; the others can delegate that one. So
     // use methodImplementation.body() only if componentMethod equals the method for this instance.
@@ -58,7 +58,7 @@ protected CodeBlock getComponentMethodImplementation(
     // for the parent and the child. Only the parent's should use the BindingMethodImplementation;
     // the child's can delegate to the parent. So use methodImplementation.body() only if
     // componentName equals the component for this instance.
-    return componentMethod.equals(this.componentMethod) && component.equals(generatedComponentModel)
+    return componentMethod.equals(this.componentMethod) && component.equals(componentImplementation)
         ? methodImplementation.body()
         : super.getComponentMethodImplementation(componentMethod, component);
   }
diff --git a/java/dagger/internal/codegen/ComponentRequirementFields.java b/java/dagger/internal/codegen/ComponentRequirementFields.java
index cef581b07..946da190d 100644
--- a/java/dagger/internal/codegen/ComponentRequirementFields.java
+++ b/java/dagger/internal/codegen/ComponentRequirementFields.java
@@ -18,7 +18,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Suppliers.memoize;
-import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.COMPONENT_REQUIREMENT_FIELD;
+import static dagger.internal.codegen.ComponentImplementation.FieldSpecKind.COMPONENT_REQUIREMENT_FIELD;
 import static javax.lang.model.element.Modifier.PRIVATE;
 
 import com.google.common.base.Supplier;
@@ -46,34 +46,34 @@
   private final Map<ComponentRequirement, ComponentRequirementField> componentRequirementFields =
       new HashMap<>();
   private final BindingGraph graph;
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final Optional<GeneratedComponentBuilderModel> generatedComponentBuilderModel;
 
   private ComponentRequirementFields(
       Optional<ComponentRequirementFields> parent,
       BindingGraph graph,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       Optional<GeneratedComponentBuilderModel> generatedComponentBuilderModel) {
     this.parent = parent;
     this.graph = graph;
-    this.generatedComponentModel = generatedComponentModel;
+    this.componentImplementation = componentImplementation;
     this.generatedComponentBuilderModel = generatedComponentBuilderModel;
   }
 
   ComponentRequirementFields(
       BindingGraph graph,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       Optional<GeneratedComponentBuilderModel> generatedComponentBuilderModel) {
-    this(Optional.empty(), graph, generatedComponentModel, generatedComponentBuilderModel);
+    this(Optional.empty(), graph, componentImplementation, generatedComponentBuilderModel);
   }
 
   /** Returns a new object representing the fields available from a child component of this one. */
   ComponentRequirementFields forChildComponent(
       BindingGraph graph,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       Optional<GeneratedComponentBuilderModel> generatedComponentBuilderModel) {
     return new ComponentRequirementFields(
-        Optional.of(this), graph, generatedComponentModel, generatedComponentBuilderModel);
+        Optional.of(this), graph, componentImplementation, generatedComponentBuilderModel);
   }
 
   /**
@@ -113,14 +113,14 @@ private ComponentRequirementField create(ComponentRequirement requirement) {
     if (generatedComponentBuilderModel.isPresent()) {
       FieldSpec builderField =
           generatedComponentBuilderModel.get().builderFields().get(requirement);
-      return new BuilderField(requirement, generatedComponentModel, builderField);
+      return new BuilderField(requirement, componentImplementation, builderField);
     } else if (graph.factoryMethod().isPresent()
         && graph.factoryMethodParameters().containsKey(requirement)) {
       ParameterSpec factoryParameter =
           ParameterSpec.get(graph.factoryMethodParameters().get(requirement));
-      return new ComponentParameterField(requirement, generatedComponentModel, factoryParameter);
+      return new ComponentParameterField(requirement, componentImplementation, factoryParameter);
     } else if (graph.componentRequirements().contains(requirement)) {
-      return new ComponentInstantiableField(requirement, generatedComponentModel);
+      return new ComponentInstantiableField(requirement, componentImplementation);
     } else {
       throw new AssertionError();
     }
@@ -128,14 +128,14 @@ private ComponentRequirementField create(ComponentRequirement requirement) {
 
   private abstract static class AbstractField implements ComponentRequirementField {
     private final ComponentRequirement componentRequirement;
-    private final GeneratedComponentModel generatedComponentModel;
+    private final ComponentImplementation componentImplementation;
     private final Supplier<MemberSelect> field = memoize(this::createField);
 
     private AbstractField(
         ComponentRequirement componentRequirement,
-        GeneratedComponentModel generatedComponentModel) {
+        ComponentImplementation componentImplementation) {
       this.componentRequirement = checkNotNull(componentRequirement);
-      this.generatedComponentModel = checkNotNull(generatedComponentModel);
+      this.componentImplementation = checkNotNull(componentImplementation);
     }
 
     @Override
@@ -149,15 +149,15 @@ public CodeBlock getExpressionDuringInitialization(ClassName requestingClass) {
     }
 
     private MemberSelect createField() {
-      // TODO(dpb,ronshapiro): think about whether GeneratedComponentModel.addField
+      // TODO(dpb,ronshapiro): think about whether ComponentImplementation.addField
       // should make a unique name for the field.
       String fieldName =
-          generatedComponentModel.getUniqueFieldName(componentRequirement.variableName());
+          componentImplementation.getUniqueFieldName(componentRequirement.variableName());
       FieldSpec field =
           FieldSpec.builder(TypeName.get(componentRequirement.type()), fieldName, PRIVATE).build();
-      generatedComponentModel.addField(COMPONENT_REQUIREMENT_FIELD, field);
-      generatedComponentModel.addInitialization(fieldInitialization(field));
-      return MemberSelect.localField(generatedComponentModel.name(), fieldName);
+      componentImplementation.addField(COMPONENT_REQUIREMENT_FIELD, field);
+      componentImplementation.addInitialization(fieldInitialization(field));
+      return MemberSelect.localField(componentImplementation.name(), fieldName);
     }
 
     /** Returns the {@link CodeBlock} that initializes the component field during construction. */
@@ -173,15 +173,15 @@ private MemberSelect createField() {
 
     private BuilderField(
         ComponentRequirement componentRequirement,
-        GeneratedComponentModel generatedComponentModel,
+        ComponentImplementation componentImplementation,
         FieldSpec builderField) {
-      super(componentRequirement, generatedComponentModel);
+      super(componentRequirement, componentImplementation);
       this.builderField = checkNotNull(builderField);
     }
 
     @Override
     public CodeBlock getExpressionDuringInitialization(ClassName requestingClass) {
-      if (super.generatedComponentModel.name().equals(requestingClass)) {
+      if (super.componentImplementation.name().equals(requestingClass)) {
         return CodeBlock.of("builder.$N", builderField);
       } else {
         // requesting this component requirement during initialization of a child component requires
@@ -203,8 +203,8 @@ CodeBlock fieldInitialization(FieldSpec componentField) {
   private static final class ComponentInstantiableField extends AbstractField {
     private ComponentInstantiableField(
         ComponentRequirement componentRequirement,
-        GeneratedComponentModel generatedComponentModel) {
-      super(componentRequirement, generatedComponentModel);
+        ComponentImplementation componentImplementation) {
+      super(componentRequirement, componentImplementation);
     }
 
     @Override
@@ -222,9 +222,9 @@ CodeBlock fieldInitialization(FieldSpec componentField) {
 
     private ComponentParameterField(
         ComponentRequirement componentRequirement,
-        GeneratedComponentModel generatedComponentModel,
+        ComponentImplementation componentImplementation,
         ParameterSpec factoryParameter) {
-      super(componentRequirement, generatedComponentModel);
+      super(componentRequirement, componentImplementation);
       this.factoryParameter = checkNotNull(factoryParameter);
     }
 
diff --git a/java/dagger/internal/codegen/DelegatingFrameworkInstanceCreationExpression.java b/java/dagger/internal/codegen/DelegatingFrameworkInstanceCreationExpression.java
index e5f71ee72..5d5f4635f 100644
--- a/java/dagger/internal/codegen/DelegatingFrameworkInstanceCreationExpression.java
+++ b/java/dagger/internal/codegen/DelegatingFrameworkInstanceCreationExpression.java
@@ -28,15 +28,15 @@
     implements FrameworkInstanceCreationExpression {
 
   private final ContributionBinding binding;
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final ComponentBindingExpressions componentBindingExpressions;
 
   DelegatingFrameworkInstanceCreationExpression(
       ContributionBinding binding,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       ComponentBindingExpressions componentBindingExpressions) {
     this.binding = checkNotNull(binding);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.componentImplementation = checkNotNull(componentImplementation);
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
   }
 
@@ -46,7 +46,7 @@ public CodeBlock creationExpression() {
     return CodeBlocks.cast(
         componentBindingExpressions
             .getDependencyExpression(
-                bindingRequest(frameworkDependency), generatedComponentModel.name())
+                bindingRequest(frameworkDependency), componentImplementation.name())
             .codeBlock(),
         frameworkDependency.frameworkClass());
   }
diff --git a/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java b/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java
index f762e3c95..ca1aadfdf 100644
--- a/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java
+++ b/java/dagger/internal/codegen/DependencyMethodProducerCreationExpression.java
@@ -40,17 +40,17 @@
 final class DependencyMethodProducerCreationExpression
     implements FrameworkInstanceCreationExpression {
   private final ContributionBinding binding;
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final ComponentRequirementFields componentRequirementFields;
   private final BindingGraph graph;
 
   DependencyMethodProducerCreationExpression(
       ContributionBinding binding,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       ComponentRequirementFields componentRequirementFields,
       BindingGraph graph) {
     this.binding = checkNotNull(binding);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.componentImplementation = checkNotNull(componentImplementation);
     this.componentRequirementFields = checkNotNull(componentRequirementFields);
     this.graph = checkNotNull(graph);
   }
@@ -67,7 +67,7 @@ public CodeBlock creationExpression() {
                 ClassName.get(dependency.typeElement()), dependency.variableName(), PRIVATE, FINAL)
             .initializer(
                 componentRequirementFields.getExpressionDuringInitialization(
-                    dependency, generatedComponentModel.name()))
+                    dependency, componentImplementation.name()))
             .build();
     // TODO(b/70395982): Explore using a private static type instead of an anonymous class.
     TypeName keyType = TypeName.get(binding.key().type());
diff --git a/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java b/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java
index e76400ae9..81fd28bda 100644
--- a/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java
+++ b/java/dagger/internal/codegen/DependencyMethodProviderCreationExpression.java
@@ -20,7 +20,7 @@
 import static com.squareup.javapoet.MethodSpec.constructorBuilder;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static com.squareup.javapoet.TypeSpec.classBuilder;
-import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.COMPONENT_PROVISION_FACTORY;
+import static dagger.internal.codegen.ComponentImplementation.TypeSpecKind.COMPONENT_PROVISION_FACTORY;
 import static dagger.internal.codegen.TypeNames.providerOf;
 import static javax.lang.model.element.Modifier.FINAL;
 import static javax.lang.model.element.Modifier.PRIVATE;
@@ -44,7 +44,7 @@
 final class DependencyMethodProviderCreationExpression
     implements FrameworkInstanceCreationExpression {
 
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final ComponentRequirementFields componentRequirementFields;
   private final CompilerOptions compilerOptions;
   private final BindingGraph graph;
@@ -52,12 +52,12 @@
 
   DependencyMethodProviderCreationExpression(
       ContributionBinding binding,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       ComponentRequirementFields componentRequirementFields,
       CompilerOptions compilerOptions,
       BindingGraph graph) {
     this.binding = checkNotNull(binding);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.componentImplementation = checkNotNull(componentImplementation);
     this.componentRequirementFields = checkNotNull(componentRequirementFields);
     this.compilerOptions = checkNotNull(compilerOptions);
     this.graph = checkNotNull(graph);
@@ -88,7 +88,7 @@ public CodeBlock creationExpression() {
     if (binding.nullableType().isPresent()) {
       getMethod.addAnnotation(ClassName.get(MoreTypes.asTypeElement(binding.nullableType().get())));
     }
-    generatedComponentModel.addType(
+    componentImplementation.addType(
         COMPONENT_PROVISION_FACTORY,
         classBuilder(factoryClassName())
             .addSuperinterface(providerOf(keyType))
@@ -105,7 +105,7 @@ public CodeBlock creationExpression() {
         "new $T($L)",
         factoryClassName(),
         componentRequirementFields.getExpressionDuringInitialization(
-            dependency(), generatedComponentModel.name()));
+            dependency(), componentImplementation.name()));
   }
 
   private ClassName factoryClassName() {
@@ -113,7 +113,7 @@ private ClassName factoryClassName() {
         ClassName.get(dependency().typeElement()).toString().replace('.', '_')
             + "_"
             + binding.bindingElement().get().getSimpleName();
-    return generatedComponentModel.name().nestedClass(factoryName);
+    return componentImplementation.name().nestedClass(factoryName);
   }
 
   private ComponentRequirement dependency() {
diff --git a/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
index 2e0ab538b..bd245a259 100644
--- a/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/DerivedFromFrameworkInstanceBindingExpression.java
@@ -55,7 +55,7 @@ Expression getDependencyExpression(ClassName requestingClass) {
 
   @Override
   Expression getDependencyExpressionForComponentMethod(
-      ComponentMethodDescriptor componentMethod, GeneratedComponentModel component) {
+      ComponentMethodDescriptor componentMethod, ComponentImplementation component) {
     Expression expression =
         componentBindingExpressions.getDependencyExpressionForComponentMethod(
             frameworkRequest, componentMethod, component);
diff --git a/java/dagger/internal/codegen/DoubleCheckedMethodImplementation.java b/java/dagger/internal/codegen/DoubleCheckedMethodImplementation.java
index 7c059d9c1..ea8a40f60 100644
--- a/java/dagger/internal/codegen/DoubleCheckedMethodImplementation.java
+++ b/java/dagger/internal/codegen/DoubleCheckedMethodImplementation.java
@@ -16,7 +16,7 @@
 
 package dagger.internal.codegen;
 
-import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.PRIVATE_METHOD_SCOPED_FIELD;
+import static dagger.internal.codegen.ComponentImplementation.FieldSpecKind.PRIVATE_METHOD_SCOPED_FIELD;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.VOLATILE;
 
@@ -34,7 +34,7 @@
  */
 final class DoubleCheckedMethodImplementation extends BindingMethodImplementation {
 
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final ContributionBinding binding;
   private final Supplier<String> fieldName = Suppliers.memoize(this::createField);
 
@@ -43,9 +43,9 @@
       BindingRequest request,
       BindingExpression bindingExpression,
       DaggerTypes types,
-      GeneratedComponentModel generatedComponentModel) {
-    super(resolvedBindings, request, bindingExpression, generatedComponentModel.name(), types);
-    this.generatedComponentModel = generatedComponentModel;
+      ComponentImplementation componentImplementation) {
+    super(resolvedBindings, request, bindingExpression, componentImplementation.name(), types);
+    this.componentImplementation = componentImplementation;
     this.binding = resolvedBindings.contributionBinding();
   }
 
@@ -68,8 +68,8 @@ CodeBlock body() {
   }
 
   private String createField() {
-    String name = generatedComponentModel.getUniqueFieldName(BindingVariableNamer.name(binding));
-    generatedComponentModel.addField(
+    String name = componentImplementation.getUniqueFieldName(BindingVariableNamer.name(binding));
+    componentImplementation.addField(
         PRIVATE_METHOD_SCOPED_FIELD,
         FieldSpec.builder(TypeName.OBJECT, name, PRIVATE, VOLATILE)
             .initializer("new $T()", MemoizedSentinel.class)
diff --git a/java/dagger/internal/codegen/FrameworkFieldInitializer.java b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
index 9bc1d176a..159d5bbc3 100644
--- a/java/dagger/internal/codegen/FrameworkFieldInitializer.java
+++ b/java/dagger/internal/codegen/FrameworkFieldInitializer.java
@@ -18,7 +18,7 @@
 
 import static com.google.common.base.Preconditions.checkNotNull;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
-import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.FRAMEWORK_FIELD;
+import static dagger.internal.codegen.ComponentImplementation.FieldSpecKind.FRAMEWORK_FIELD;
 import static javax.lang.model.element.Modifier.PRIVATE;
 
 import com.squareup.javapoet.ClassName;
@@ -71,17 +71,17 @@ default boolean useInnerSwitchingProvider() {
     }
   }
 
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final ResolvedBindings resolvedBindings;
   private final FrameworkInstanceCreationExpression frameworkInstanceCreationExpression;
   private FieldSpec fieldSpec;
   private InitializationState fieldInitializationState = InitializationState.UNINITIALIZED;
 
   FrameworkFieldInitializer(
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       ResolvedBindings resolvedBindings,
       FrameworkInstanceCreationExpression frameworkInstanceCreationExpression) {
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.componentImplementation = checkNotNull(componentImplementation);
     this.resolvedBindings = checkNotNull(resolvedBindings);
     this.frameworkInstanceCreationExpression = checkNotNull(frameworkInstanceCreationExpression);
   }
@@ -93,7 +93,7 @@ default boolean useInnerSwitchingProvider() {
   @Override
   public final MemberSelect memberSelect() {
     initializeField();
-    return MemberSelect.localField(generatedComponentModel.name(), checkNotNull(fieldSpec).name);
+    return MemberSelect.localField(componentImplementation.name(), checkNotNull(fieldSpec).name);
   }
 
   /** Adds the field and its initialization code to the component. */
@@ -117,7 +117,7 @@ private void initializeField() {
         } else {
           codeBuilder.add(initCode);
         }
-        generatedComponentModel.addInitialization(codeBuilder.build());
+        componentImplementation.addInitialization(codeBuilder.build());
 
         fieldInitializationState = InitializationState.INITIALIZED;
         break;
@@ -125,7 +125,7 @@ private void initializeField() {
       case INITIALIZING:
         // We were recursively invoked, so create a delegate factory instead
         fieldInitializationState = InitializationState.DELEGATED;
-        generatedComponentModel.addInitialization(
+        componentImplementation.addInitialization(
             CodeBlock.of("this.$N = new $T<>();", getOrCreateField(), DelegateFactory.class));
         break;
 
@@ -146,7 +146,7 @@ private FieldSpec getOrCreateField() {
     if (fieldSpec != null) {
       return fieldSpec;
     }
-    boolean useRawType = !generatedComponentModel.isTypeAccessible(resolvedBindings.key().type());
+    boolean useRawType = !componentImplementation.isTypeAccessible(resolvedBindings.key().type());
     FrameworkField contributionBindingField =
         FrameworkField.forResolvedBindings(
             resolvedBindings, frameworkInstanceCreationExpression.alternativeFrameworkClass());
@@ -165,14 +165,13 @@ private FieldSpec getOrCreateField() {
 
     FieldSpec.Builder contributionField =
         FieldSpec.builder(
-            fieldType,
-            generatedComponentModel.getUniqueFieldName(contributionBindingField.name()));
+            fieldType, componentImplementation.getUniqueFieldName(contributionBindingField.name()));
     contributionField.addModifiers(PRIVATE);
     if (useRawType && !specificType().isPresent()) {
       contributionField.addAnnotation(AnnotationSpecs.suppressWarnings(RAWTYPES));
     }
     fieldSpec = contributionField.build();
-    generatedComponentModel.addField(FRAMEWORK_FIELD, fieldSpec);
+    componentImplementation.addField(FRAMEWORK_FIELD, fieldSpec);
 
     return fieldSpec;
   }
diff --git a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
index 54284a738..d832ca432 100644
--- a/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/FrameworkInstanceBindingExpression.java
@@ -45,8 +45,8 @@
 
   /**
    * The expression for the framework instance for this binding. The field will be {@link
-   * GeneratedComponentModel#addInitialization(CodeBlock) initialized} and {@link
-   * GeneratedComponentModel#addField(GeneratedComponentModel.FieldSpecKind, FieldSpec) added} to
+   * ComponentImplementation#addInitialization(CodeBlock) initialized} and {@link
+   * ComponentImplementation#addField(ComponentImplementation.FieldSpecKind, FieldSpec) added} to
    * the component the first time this method is invoked.
    */
   @Override
diff --git a/java/dagger/internal/codegen/GeneratedComponentBuilderModel.java b/java/dagger/internal/codegen/GeneratedComponentBuilderModel.java
index c1fdc4358..c03d0fdd1 100644
--- a/java/dagger/internal/codegen/GeneratedComponentBuilderModel.java
+++ b/java/dagger/internal/codegen/GeneratedComponentBuilderModel.java
@@ -76,12 +76,12 @@ ClassName name() {
   }
 
   static Optional<GeneratedComponentBuilderModel> create(
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       BindingGraph graph,
       Elements elements,
       Types types) {
     return hasBuilder(graph.componentDescriptor())
-        ? Optional.of(new Creator(generatedComponentModel, graph, elements, types).create())
+        ? Optional.of(new Creator(componentImplementation, graph, elements, types).create())
         : Optional.empty();
   }
 
@@ -95,28 +95,28 @@ private static boolean hasBuilder(ComponentDescriptor component) {
             + "no-op. For more, see https://google.github.io/dagger/unused-modules.\n";
     private final BindingGraph graph;
     private final TypeSpec.Builder builder;
-    private final GeneratedComponentModel generatedComponentModel;
+    private final ComponentImplementation componentImplementation;
     private final Elements elements;
     private final Types types;
 
     Creator(
-        GeneratedComponentModel generatedComponentModel,
+        ComponentImplementation componentImplementation,
         BindingGraph graph,
         Elements elements,
         Types types) {
-      this.generatedComponentModel = generatedComponentModel;
-      this.builder = classBuilder(generatedComponentModel.getBuilderName());
+      this.componentImplementation = componentImplementation;
+      this.builder = classBuilder(componentImplementation.getBuilderName());
       this.graph = graph;
       this.elements = elements;
       this.types = types;
     }
 
     GeneratedComponentBuilderModel create() {
-      if (!generatedComponentModel.isNested()) {
+      if (!componentImplementation.isNested()) {
         builder.addModifiers(STATIC);
       }
       if (builderSpec().isPresent()) {
-        if (generatedComponentModel.isAbstract()) {
+        if (componentImplementation.isAbstract()) {
           builder.addModifiers(PUBLIC);
         } else {
           builder.addModifiers(PRIVATE);
@@ -128,7 +128,7 @@ GeneratedComponentBuilderModel create() {
 
       ImmutableMap<ComponentRequirement, FieldSpec> builderFields = builderFields(graph);
 
-      if (generatedComponentModel.isAbstract()) {
+      if (componentImplementation.isAbstract()) {
         builder.addModifiers(ABSTRACT);
       } else {
         builder.addModifiers(FINAL);
@@ -142,14 +142,15 @@ GeneratedComponentBuilderModel create() {
           .addMethods(builderMethods(builderFields));
 
       return new GeneratedComponentBuilderModel(
-          builder.build(), generatedComponentModel.getBuilderName(), builderFields);
+          builder.build(), componentImplementation.getBuilderName(), builderFields);
     }
 
     /** Set the superclass being extended or interface being implemented for this builder. */
     private void setSupertype() {
-      if (generatedComponentModel.supermodel().isPresent()) {
+      if (componentImplementation.superclassImplementation().isPresent()) {
         // If there's a superclass, extend the Builder defined there.
-        builder.superclass(generatedComponentModel.supermodel().get().getBuilderName());
+        builder.superclass(
+            componentImplementation.superclassImplementation().get().getBuilderName());
       } else {
         addSupertype(builder, builderSpec().get().builderDefinitionType());
       }
@@ -210,7 +211,7 @@ private MethodSpec buildMethod(ImmutableMap<ComponentRequirement, FieldSpec> bui
                 throw new AssertionError(requirement);
             }
           });
-      buildMethod.addStatement("return new $T(this)", generatedComponentModel.name());
+      buildMethod.addStatement("return new $T(this)", componentImplementation.name());
       return buildMethod.build();
     }
 
@@ -272,7 +273,7 @@ private MethodSpec buildMethod(ImmutableMap<ComponentRequirement, FieldSpec> bui
           String componentRequirementName = simpleVariableName(componentRequirement.typeElement());
           MethodSpec.Builder builderMethod =
               methodBuilder(componentRequirementName)
-                  .returns(generatedComponentModel.getBuilderName())
+                  .returns(componentImplementation.getBuilderName())
                   .addModifiers(PUBLIC)
                   .addParameter(
                       TypeName.get(componentRequirement.type()), componentRequirementName);
@@ -305,7 +306,7 @@ private MethodSpec buildMethod(ImmutableMap<ComponentRequirement, FieldSpec> bui
       // Otherwise we use the generated builder name and take advantage of covariant returns
       // (so that we don't have to worry about setter methods that return type variables).
       if (!returnType.getKind().equals(VOID)) {
-        builderMethod.returns(generatedComponentModel.getBuilderName());
+        builderMethod.returns(componentImplementation.getBuilderName());
       }
       return builderMethod;
     }
diff --git a/java/dagger/internal/codegen/GeneratedInstanceBindingExpression.java b/java/dagger/internal/codegen/GeneratedInstanceBindingExpression.java
index a5a99f8a2..e82af0e78 100644
--- a/java/dagger/internal/codegen/GeneratedInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/GeneratedInstanceBindingExpression.java
@@ -28,29 +28,29 @@
  * overridden when generating the concrete implementation of an ancestor component.
  */
 final class GeneratedInstanceBindingExpression extends ModifiableAbstractMethodBindingExpression {
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final ContributionBinding binding;
   private final BindingRequest request;
 
   GeneratedInstanceBindingExpression(
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       ResolvedBindings resolvedBindings,
       BindingRequest request,
       Optional<ModifiableBindingMethod> matchingModifiableBindingMethod,
       Optional<ComponentMethodDescriptor> matchingComponentMethod) {
     super(
-        generatedComponentModel,
+        componentImplementation,
         ModifiableBindingType.GENERATED_INSTANCE,
         request,
         matchingModifiableBindingMethod,
         matchingComponentMethod);
-    this.generatedComponentModel = generatedComponentModel;
+    this.componentImplementation = componentImplementation;
     this.binding = resolvedBindings.contributionBinding();
     this.request = request;
   }
 
   @Override
   String chooseMethodName() {
-    return generatedComponentModel.getUniqueMethodName(request, binding);
+    return componentImplementation.getUniqueMethodName(request, binding);
   }
 }
diff --git a/java/dagger/internal/codegen/InnerSwitchingProviders.java b/java/dagger/internal/codegen/InnerSwitchingProviders.java
index c4e968da1..91c131773 100644
--- a/java/dagger/internal/codegen/InnerSwitchingProviders.java
+++ b/java/dagger/internal/codegen/InnerSwitchingProviders.java
@@ -39,10 +39,10 @@
   private final DaggerTypes types;
 
   InnerSwitchingProviders(
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       ComponentBindingExpressions componentBindingExpressions,
       DaggerTypes types) {
-    super(generatedComponentModel, types);
+    super(componentImplementation, types);
     this.componentBindingExpressions = componentBindingExpressions;
     this.types = types;
   }
diff --git a/java/dagger/internal/codegen/MapBindingExpression.java b/java/dagger/internal/codegen/MapBindingExpression.java
index b5fe89095..9d4fdf0f0 100644
--- a/java/dagger/internal/codegen/MapBindingExpression.java
+++ b/java/dagger/internal/codegen/MapBindingExpression.java
@@ -50,12 +50,12 @@
 
   MapBindingExpression(
       ResolvedBindings resolvedBindings,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       BindingGraph graph,
       ComponentBindingExpressions componentBindingExpressions,
       DaggerTypes types,
       DaggerElements elements) {
-    super(resolvedBindings, generatedComponentModel);
+    super(resolvedBindings, componentImplementation);
     this.binding = (ProvisionBinding) resolvedBindings.contributionBinding();
     BindingKind bindingKind = this.binding.kind();
     checkArgument(bindingKind.equals(MULTIBOUND_MAP), bindingKind);
diff --git a/java/dagger/internal/codegen/MapFactoryCreationExpression.java b/java/dagger/internal/codegen/MapFactoryCreationExpression.java
index 387c5ec6f..4ea660726 100644
--- a/java/dagger/internal/codegen/MapFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/MapFactoryCreationExpression.java
@@ -31,20 +31,20 @@
 /** A factory creation expression for a multibound map. */
 final class MapFactoryCreationExpression extends MultibindingFactoryCreationExpression {
 
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final BindingGraph graph;
   private final ContributionBinding binding;
   private final DaggerElements elements;
 
   MapFactoryCreationExpression(
       ContributionBinding binding,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       ComponentBindingExpressions componentBindingExpressions,
       BindingGraph graph,
       DaggerElements elements) {
-    super(binding, generatedComponentModel, componentBindingExpressions);
+    super(binding, componentImplementation, componentBindingExpressions);
     this.binding = checkNotNull(binding);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.componentImplementation = checkNotNull(componentImplementation);
     this.graph = checkNotNull(graph);
     this.elements = checkNotNull(elements);
   }
@@ -75,7 +75,7 @@ public CodeBlock creationExpression() {
           graph.contributionBindings().get(frameworkDependency.key()).contributionBinding();
       builder.add(
           ".put($L, $L)",
-          getMapKeyExpression(contributionBinding, generatedComponentModel.name(), elements),
+          getMapKeyExpression(contributionBinding, componentImplementation.name(), elements),
           multibindingDependencyExpression(frameworkDependency));
     }
     builder.add(".build()");
diff --git a/java/dagger/internal/codegen/MembersInjectionBindingExpression.java b/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
index a22b1dd5a..12e8070bc 100644
--- a/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
+++ b/java/dagger/internal/codegen/MembersInjectionBindingExpression.java
@@ -49,7 +49,7 @@ Expression getDependencyExpression(ClassName requestingClass) {
   // better suited as a method on MembersInjectionMethods
   @Override
   protected CodeBlock getComponentMethodImplementation(
-      ComponentMethodDescriptor componentMethod, GeneratedComponentModel component) {
+      ComponentMethodDescriptor componentMethod, ComponentImplementation component) {
     ExecutableElement methodElement = componentMethod.methodElement();
     ParameterSpec parameter = ParameterSpec.get(getOnlyElement(methodElement.getParameters()));
 
diff --git a/java/dagger/internal/codegen/MembersInjectionMethods.java b/java/dagger/internal/codegen/MembersInjectionMethods.java
index 36108cfa2..34c617938 100644
--- a/java/dagger/internal/codegen/MembersInjectionMethods.java
+++ b/java/dagger/internal/codegen/MembersInjectionMethods.java
@@ -19,7 +19,7 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
-import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.MEMBERS_INJECTION_METHOD;
+import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.MEMBERS_INJECTION_METHOD;
 import static dagger.internal.codegen.Util.reentrantComputeIfAbsent;
 import static javax.lang.model.element.Modifier.PRIVATE;
 
@@ -41,19 +41,19 @@
 /** Manages the member injection methods for a component. */
 final class MembersInjectionMethods {
   private final Map<Key, MethodSpec> membersInjectionMethods = new LinkedHashMap<>();
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final ComponentBindingExpressions bindingExpressions;
   private final BindingGraph graph;
   private final DaggerElements elements;
   private final DaggerTypes types;
 
   MembersInjectionMethods(
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       ComponentBindingExpressions bindingExpressions,
       BindingGraph graph,
       DaggerElements elements,
       DaggerTypes types) {
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.componentImplementation = checkNotNull(componentImplementation);
     this.bindingExpressions = checkNotNull(bindingExpressions);
     this.graph = checkNotNull(graph);
     this.elements = checkNotNull(elements);
@@ -74,14 +74,14 @@ private MethodSpec membersInjectionMethod(Key key) {
     Binding binding = resolvedBindings.binding();
     TypeMirror keyType = binding.key().type();
     TypeMirror membersInjectedType =
-        isTypeAccessibleFrom(keyType, generatedComponentModel.name().packageName())
+        isTypeAccessibleFrom(keyType, componentImplementation.name().packageName())
             ? keyType
             : elements.getTypeElement(Object.class).asType();
     TypeName membersInjectedTypeName = TypeName.get(membersInjectedType);
     Name bindingTypeName = binding.bindingTypeElement().get().getSimpleName();
     // TODO(ronshapiro): include type parameters in this name e.g. injectFooOfT, and outer class
     // simple names Foo.Builder -> injectFooBuilder
-    String methodName = generatedComponentModel.getUniqueMethodName("inject" + bindingTypeName);
+    String methodName = componentImplementation.getUniqueMethodName("inject" + bindingTypeName);
     ParameterSpec parameter = ParameterSpec.builder(membersInjectedTypeName, "instance").build();
     MethodSpec.Builder methodBuilder =
         methodBuilder(methodName)
@@ -97,18 +97,18 @@ private MethodSpec membersInjectionMethod(Key key) {
     methodBuilder.addCode(
         InjectionSiteMethod.invokeAll(
             injectionSites(binding),
-            generatedComponentModel.name(),
+            componentImplementation.name(),
             instance,
             membersInjectedType,
             types,
             request ->
                 bindingExpressions
-                    .getDependencyArgumentExpression(request, generatedComponentModel.name())
+                    .getDependencyArgumentExpression(request, componentImplementation.name())
                     .codeBlock()));
     methodBuilder.addStatement("return $L", instance);
 
     MethodSpec method = methodBuilder.build();
-    generatedComponentModel.addMethod(MEMBERS_INJECTION_METHOD, method);
+    componentImplementation.addMethod(MEMBERS_INJECTION_METHOD, method);
     return method;
   }
 
diff --git a/java/dagger/internal/codegen/MethodBindingExpression.java b/java/dagger/internal/codegen/MethodBindingExpression.java
index 1f564ba3f..9ba6a66a7 100644
--- a/java/dagger/internal/codegen/MethodBindingExpression.java
+++ b/java/dagger/internal/codegen/MethodBindingExpression.java
@@ -28,15 +28,15 @@
 abstract class MethodBindingExpression extends BindingExpression {
 
   private final BindingMethodImplementation methodImplementation;
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final Optional<ModifiableBindingMethod> matchingModifiableBindingMethod;
 
   protected MethodBindingExpression(
       BindingMethodImplementation methodImplementation,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       Optional<ModifiableBindingMethod> matchingModifiableBindingMethod) {
     this.methodImplementation = checkNotNull(methodImplementation);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.componentImplementation = checkNotNull(componentImplementation);
     this.matchingModifiableBindingMethod = checkNotNull(matchingModifiableBindingMethod);
   }
 
@@ -45,14 +45,14 @@ Expression getDependencyExpression(ClassName requestingClass) {
     addMethod();
     return Expression.create(
         methodImplementation.returnType(),
-        requestingClass.equals(generatedComponentModel.name())
+        requestingClass.equals(componentImplementation.name())
             ? CodeBlock.of("$N()", methodName())
-            : CodeBlock.of("$T.this.$N()", generatedComponentModel.name(), methodName()));
+            : CodeBlock.of("$T.this.$N()", componentImplementation.name(), methodName()));
   }
 
   @Override
   final CodeBlock getModifiableBindingMethodImplementation(
-      ModifiableBindingMethod modifiableBindingMethod, GeneratedComponentModel component) {
+      ModifiableBindingMethod modifiableBindingMethod, ComponentImplementation component) {
     // A matching modifiable binding method means that we have previously created the binding method
     // and we are now implementing it. If there is no matching method we need to first create the
     // method. We create the method by deferring to getDependencyExpression (defined above) via a
diff --git a/java/dagger/internal/codegen/MissingBindingExpression.java b/java/dagger/internal/codegen/MissingBindingExpression.java
index 2c1b7df46..c3822e4d3 100644
--- a/java/dagger/internal/codegen/MissingBindingExpression.java
+++ b/java/dagger/internal/codegen/MissingBindingExpression.java
@@ -23,30 +23,30 @@
 /**
  * A {@link ModifiableAbstractMethodBindingExpression} for a binding that is missing when generating
  * the abstract base class implementation of a subcomponent. The (unimplemented) method is added to
- * the {@link GeneratedComponentModel} when the dependency expression is requested. The method is
+ * the {@link ComponentImplementation} when the dependency expression is requested. The method is
  * overridden when generating the implementation of an ancestor component.
  */
 final class MissingBindingExpression extends ModifiableAbstractMethodBindingExpression {
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final BindingRequest request;
 
   MissingBindingExpression(
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       BindingRequest request,
       Optional<ModifiableBindingMethod> matchingModifiableBindingMethod,
       Optional<ComponentMethodDescriptor> matchingComponentMethod) {
     super(
-        generatedComponentModel,
+        componentImplementation,
         ModifiableBindingType.MISSING,
         request,
         matchingModifiableBindingMethod,
         matchingComponentMethod);
-    this.generatedComponentModel = generatedComponentModel;
+    this.componentImplementation = componentImplementation;
     this.request = request;
   }
 
   @Override
   String chooseMethodName() {
-    return generatedComponentModel.getUniqueMethodName(request);
+    return componentImplementation.getUniqueMethodName(request);
   }
 }
diff --git a/java/dagger/internal/codegen/ModifiableAbstractMethodBindingExpression.java b/java/dagger/internal/codegen/ModifiableAbstractMethodBindingExpression.java
index 095784f37..a7de8e379 100644
--- a/java/dagger/internal/codegen/ModifiableAbstractMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/ModifiableAbstractMethodBindingExpression.java
@@ -29,23 +29,23 @@
 /**
  * A {@link BindingExpression} that invokes a method that encapsulates a binding that cannot be
  * satisfied when generating the abstract base class implementation of a subcomponent. The
- * (unimplemented) method is added to the {@link GeneratedComponentModel} when the dependency
+ * (unimplemented) method is added to the {@link ComponentImplementation} when the dependency
  * expression is requested. The method is overridden when generating the implementation of an
  * ancestor component.
  */
 abstract class ModifiableAbstractMethodBindingExpression extends BindingExpression {
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final ModifiableBindingType modifiableBindingType;
   private final BindingRequest request;
   private Optional<String> methodName;
 
   ModifiableAbstractMethodBindingExpression(
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       ModifiableBindingType modifiableBindingType,
       BindingRequest request,
       Optional<ModifiableBindingMethod> matchingModifiableBindingMethod,
       Optional<ComponentMethodDescriptor> matchingComponentMethod) {
-    this.generatedComponentModel = generatedComponentModel;
+    this.componentImplementation = componentImplementation;
     this.modifiableBindingType = modifiableBindingType;
     this.request = request;
     this.methodName =
@@ -79,7 +79,7 @@ private void addUnimplementedMethod() {
     if (!methodName.isPresent()) {
       // Only add the method once in case of repeated references to the missing binding.
       methodName = Optional.of(chooseMethodName());
-      generatedComponentModel.addModifiableBindingMethod(
+      componentImplementation.addModifiableBindingMethod(
           modifiableBindingType,
           request,
           MethodSpec.methodBuilder(methodName.get())
diff --git a/java/dagger/internal/codegen/ModifiableBindingExpressions.java b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
index e65feb0b8..27bfd2fd7 100644
--- a/java/dagger/internal/codegen/ModifiableBindingExpressions.java
+++ b/java/dagger/internal/codegen/ModifiableBindingExpressions.java
@@ -36,19 +36,19 @@
   private final Optional<ModifiableBindingExpressions> parent;
   private final ComponentBindingExpressions bindingExpressions;
   private final BindingGraph graph;
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final CompilerOptions compilerOptions;
 
   ModifiableBindingExpressions(
       Optional<ModifiableBindingExpressions> parent,
       ComponentBindingExpressions bindingExpressions,
       BindingGraph graph,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       CompilerOptions compilerOptions) {
     this.parent = parent;
     this.bindingExpressions = bindingExpressions;
     this.graph = graph;
-    this.generatedComponentModel = generatedComponentModel;
+    this.componentImplementation = componentImplementation;
     this.compilerOptions = compilerOptions;
   }
 
@@ -61,7 +61,7 @@ ModifiableBindingType registerComponentMethodIfModifiable(
     BindingRequest request = bindingRequest(componentMethod.dependencyRequest().get());
     ModifiableBindingType modifiableBindingType = getModifiableBindingType(request);
     if (modifiableBindingType.isModifiable()) {
-      generatedComponentModel.registerModifiableBindingMethod(
+      componentImplementation.registerModifiableBindingMethod(
           modifiableBindingType,
           request,
           method,
@@ -82,7 +82,7 @@ ModifiableBindingType registerComponentMethodIfModifiable(
       boolean markMethodFinal =
           knownModifiableBindingWillBeFinalized(modifiableBindingMethod)
               // no need to mark the method final if the component implementation will be final
-              && generatedComponentModel.isAbstract();
+              && componentImplementation.isAbstract();
       return Optional.of(
           ModifiableBindingMethod.implement(
               modifiableBindingMethod,
@@ -95,7 +95,7 @@ ModifiableBindingType registerComponentMethodIfModifiable(
                       bindingExpressions
                           .getBindingExpression(modifiableBindingMethod.request())
                           .getModifiableBindingMethodImplementation(
-                              modifiableBindingMethod, generatedComponentModel))
+                              modifiableBindingMethod, componentImplementation))
                   .build(),
               markMethodFinal));
     }
@@ -173,16 +173,16 @@ private BindingExpression createModifiableBindingExpression(
       ModifiableBindingType type, BindingRequest request) {
     ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
     Optional<ModifiableBindingMethod> matchingModifiableBindingMethod =
-        generatedComponentModel.getModifiableBindingMethod(request);
+        componentImplementation.getModifiableBindingMethod(request);
     Optional<ComponentMethodDescriptor> matchingComponentMethod =
         graph.componentDescriptor().findMatchingComponentMethod(request);
     switch (type) {
       case GENERATED_INSTANCE:
         // If the subcomponent is abstract then we need to define an (un-implemented)
         // GeneratedInstanceBindingExpression.
-        if (generatedComponentModel.isAbstract()) {
+        if (componentImplementation.isAbstract()) {
           return new GeneratedInstanceBindingExpression(
-              generatedComponentModel,
+              componentImplementation,
               resolvedBindings,
               request,
               matchingModifiableBindingMethod,
@@ -196,9 +196,9 @@ private BindingExpression createModifiableBindingExpression(
       case MISSING:
         // If we need an expression for a missing binding and the current implementation is
         // abstract, then we need an (un-implemented) MissingBindingExpression.
-        if (generatedComponentModel.isAbstract()) {
+        if (componentImplementation.isAbstract()) {
           return new MissingBindingExpression(
-              generatedComponentModel,
+              componentImplementation,
               request,
               matchingModifiableBindingMethod,
               matchingComponentMethod);
@@ -206,9 +206,9 @@ private BindingExpression createModifiableBindingExpression(
         // Otherwise we assume that it is valid to have a missing binding as it is part of a
         // dependency chain that has been passively pruned.
         // TODO(b/117833324): Identify pruned bindings when generating the subcomponent
-        //     implementation in which the bindings are pruned. If we hold a reference to the
-        //     binding graph used to generate a given model then we can compare a model's graph with
-        //     its supermodel graph to detect pruned dependency branches.
+        // implementation in which the bindings are pruned. If we hold a reference to the binding
+        // graph used to generate a given implementation then we can compare a implementation's
+        // graph with its superclass implementation's graph to detect pruned dependency branches.
         return new PrunedConcreteMethodBindingExpression();
       case OPTIONAL:
       case MULTIBINDING:
@@ -236,7 +236,7 @@ private ModifiableBindingType getModifiableBindingType(BindingRequest request) {
 
     // When generating a component the binding is not considered modifiable. Bindings are modifiable
     // only across subcomponent implementations.
-    if (generatedComponentModel.componentDescriptor().kind().isTopLevel()) {
+    if (componentImplementation.componentDescriptor().kind().isTopLevel()) {
       return ModifiableBindingType.NONE;
     }
 
@@ -304,7 +304,7 @@ private boolean shouldModifyBinding(
     ResolvedBindings resolvedBindings = graph.resolvedBindings(request);
     switch (modifiableBindingType) {
       case GENERATED_INSTANCE:
-        return !generatedComponentModel.isAbstract();
+        return !componentImplementation.isAbstract();
       case MISSING:
         // TODO(b/72748365): investigate beder@'s comment about having intermediate component
         // ancestors satisfy missing bindings of their children with their own missing binding
@@ -315,13 +315,13 @@ private boolean shouldModifyBinding(
         // subcomponent implementation. If a binding is still missing when the subcomponent
         // implementation is concrete then it is assumed to be part of a dependency that would have
         // been passively pruned when implementing the full component hierarchy.
-        return resolvableBinding(request) || !generatedComponentModel.isAbstract();
+        return resolvableBinding(request) || !componentImplementation.isAbstract();
       case OPTIONAL:
         // Only override optional binding methods if we have a non-empty binding.
         return !resolvedBindings.contributionBinding().dependencies().isEmpty();
       case MULTIBINDING:
         // Only modify a multibinding if there are new contributions.
-        return !generatedComponentModel
+        return !componentImplementation
             .superclassContributionsMade(request.key())
             .containsAll(resolvedBindings.contributionBinding().dependencies());
       case INJECTION:
@@ -331,8 +331,8 @@ private boolean shouldModifyBinding(
         // the implementation has changed, so we implement the binding once in the base
         // implementation of the subcomponent. It will be re-implemented when generating the
         // component.
-        return !generatedComponentModel.supermodel().isPresent()
-            || !generatedComponentModel.isAbstract();
+        return !componentImplementation.superclassImplementation().isPresent()
+            || !componentImplementation.isAbstract();
       default:
         throw new IllegalStateException(
             String.format(
@@ -383,7 +383,7 @@ private boolean resolvedInThisComponent(BindingRequest request) {
               request,
               modifiableBindingType,
               methodImplementation,
-              generatedComponentModel,
+              componentImplementation,
               matchingModifiableBindingMethod,
               newModifiableBindingWillBeFinalized(modifiableBindingType, request)));
     }
@@ -403,7 +403,7 @@ private boolean resolvedInThisComponent(BindingRequest request) {
   private boolean shouldUseAModifiableConcreteMethodBindingExpression(
       ModifiableBindingType type, Optional<ComponentMethodDescriptor> matchingComponentMethod) {
     return type.isModifiable()
-        && (generatedComponentModel.supermodel().isPresent()
+        && (componentImplementation.superclassImplementation().isPresent()
             || !matchingComponentMethod.isPresent());
   }
 }
diff --git a/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java b/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java
index 114ddbd37..9ec01875b 100644
--- a/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/ModifiableConcreteMethodBindingExpression.java
@@ -36,7 +36,7 @@
   private final BindingRequest request;
   private final ModifiableBindingType modifiableBindingType;
   private final BindingMethodImplementation methodImplementation;
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final boolean bindingFinalized;
   private Optional<String> methodName;
 
@@ -45,15 +45,15 @@
       BindingRequest request,
       ModifiableBindingType modifiableBindingType,
       BindingMethodImplementation methodImplementation,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       Optional<ModifiableBindingMethod> matchingModifiableBindingMethod,
       boolean bindingFinalized) {
-    super(methodImplementation, generatedComponentModel, matchingModifiableBindingMethod);
+    super(methodImplementation, componentImplementation, matchingModifiableBindingMethod);
     this.binding = resolvedBindings.contributionBinding();
     this.request = checkNotNull(request);
     this.modifiableBindingType = checkNotNull(modifiableBindingType);
     this.methodImplementation = checkNotNull(methodImplementation);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.componentImplementation = checkNotNull(componentImplementation);
     this.bindingFinalized = bindingFinalized;
     this.methodName =
         matchingModifiableBindingMethod.map(modifiableMethod -> modifiableMethod.methodSpec().name);
@@ -61,10 +61,10 @@
 
   @Override
   protected void addMethod() {
-    // Add the modifiable binding method to the component model if we haven't already.
+    // Add the modifiable binding method to the component if we haven't already.
     if (!methodName.isPresent()) {
-      methodName = Optional.of(generatedComponentModel.getUniqueMethodName(request, binding));
-      generatedComponentModel.addModifiableBindingMethod(
+      methodName = Optional.of(componentImplementation.getUniqueMethodName(request, binding));
+      componentImplementation.addModifiableBindingMethod(
           modifiableBindingType,
           request,
           methodBuilder(methodName.get())
diff --git a/java/dagger/internal/codegen/MultibindingExpression.java b/java/dagger/internal/codegen/MultibindingExpression.java
index 93c773740..acbf70be0 100644
--- a/java/dagger/internal/codegen/MultibindingExpression.java
+++ b/java/dagger/internal/codegen/MultibindingExpression.java
@@ -31,19 +31,19 @@
 /** An abstract base class for multibinding {@link BindingExpression}s. */
 abstract class MultibindingExpression extends SimpleInvocationBindingExpression {
   private final ProvisionBinding binding;
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
 
   MultibindingExpression(
-      ResolvedBindings resolvedBindings, GeneratedComponentModel generatedComponentModel) {
+      ResolvedBindings resolvedBindings, ComponentImplementation componentImplementation) {
     super(resolvedBindings);
-    this.generatedComponentModel = generatedComponentModel;
+    this.componentImplementation = componentImplementation;
     this.binding = (ProvisionBinding) resolvedBindings.contributionBinding();
   }
 
   @Override
   Expression getDependencyExpression(ClassName requestingClass) {
     Expression expression = buildDependencyExpression(requestingClass);
-    generatedComponentModel.registerImplementedMultibinding(binding);
+    componentImplementation.registerImplementedMultibinding(binding);
     return expression;
   }
 
@@ -63,7 +63,7 @@ Expression getDependencyExpression(ClassName requestingClass) {
   protected SetView<DependencyRequest> getNewContributions(
       ImmutableSet<DependencyRequest> dependencies) {
     return Sets.difference(
-        dependencies, generatedComponentModel.superclassContributionsMade(binding.key()));
+        dependencies, componentImplementation.superclassContributionsMade(binding.key()));
   }
 
   /**
@@ -72,13 +72,13 @@ Expression getDependencyExpression(ClassName requestingClass) {
    * when generating ahead-of-time subcomponents.
    */
   protected Optional<CodeBlock> superMethodCall() {
-    if (generatedComponentModel.supermodel().isPresent()) {
+    if (componentImplementation.superclassImplementation().isPresent()) {
       Optional<ModifiableBindingMethod> method =
-          generatedComponentModel.getModifiableBindingMethod(
+          componentImplementation.getModifiableBindingMethod(
               bindingRequest(binding.key(), RequestKind.INSTANCE));
       if (method.isPresent()) {
         ImmutableSet<DependencyRequest> superclassContributions =
-            generatedComponentModel.superclassContributionsMade(binding.key());
+            componentImplementation.superclassContributionsMade(binding.key());
         if (!superclassContributions.isEmpty()) {
           return Optional.of(CodeBlock.of("super.$L()", method.get().methodSpec().name));
         }
diff --git a/java/dagger/internal/codegen/MultibindingFactoryCreationExpression.java b/java/dagger/internal/codegen/MultibindingFactoryCreationExpression.java
index b9f6ef9a6..d80e60516 100644
--- a/java/dagger/internal/codegen/MultibindingFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/MultibindingFactoryCreationExpression.java
@@ -24,16 +24,16 @@
 /** An abstract factory creation expression for multibindings. */
 abstract class MultibindingFactoryCreationExpression
     implements FrameworkInstanceCreationExpression {
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final ComponentBindingExpressions componentBindingExpressions;
   private final ContributionBinding binding;
 
   MultibindingFactoryCreationExpression(
       ContributionBinding binding,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       ComponentBindingExpressions componentBindingExpressions) {
     this.binding = checkNotNull(binding);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.componentImplementation = checkNotNull(componentImplementation);
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
   }
 
@@ -43,7 +43,7 @@ protected final CodeBlock multibindingDependencyExpression(
     CodeBlock expression =
         componentBindingExpressions
             .getDependencyExpression(
-                BindingRequest.bindingRequest(frameworkDependency), generatedComponentModel.name())
+                BindingRequest.bindingRequest(frameworkDependency), componentImplementation.name())
             .codeBlock();
     return useRawType()
         ? CodeBlocks.cast(expression, frameworkDependency.frameworkClass())
@@ -62,7 +62,7 @@ protected final BindingRequest bindingRequest() {
    * component, and therefore a raw type must be used.
    */
   protected final boolean useRawType() {
-    return !generatedComponentModel.isTypeAccessible(binding.key().type());
+    return !componentImplementation.isTypeAccessible(binding.key().type());
   }
 
   @Override
diff --git a/java/dagger/internal/codegen/OptionalFactories.java b/java/dagger/internal/codegen/OptionalFactories.java
index 71523b9eb..9987e1ea0 100644
--- a/java/dagger/internal/codegen/OptionalFactories.java
+++ b/java/dagger/internal/codegen/OptionalFactories.java
@@ -26,9 +26,9 @@
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.RAWTYPES;
 import static dagger.internal.codegen.AnnotationSpecs.Suppression.UNCHECKED;
-import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.ABSENT_OPTIONAL_FIELD;
-import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.ABSENT_OPTIONAL_METHOD;
-import static dagger.internal.codegen.GeneratedComponentModel.TypeSpecKind.PRESENT_FACTORY;
+import static dagger.internal.codegen.ComponentImplementation.FieldSpecKind.ABSENT_OPTIONAL_FIELD;
+import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.ABSENT_OPTIONAL_METHOD;
+import static dagger.internal.codegen.ComponentImplementation.TypeSpecKind.PRESENT_FACTORY;
 import static dagger.internal.codegen.RequestKinds.requestTypeName;
 import static dagger.internal.codegen.TypeNames.PROVIDER;
 import static dagger.internal.codegen.TypeNames.abstractProducerOf;
@@ -69,10 +69,10 @@
 /** The nested class and static methods required by the component to implement optional bindings. */
 // TODO(dpb): Name members simply if a component uses only one of Guava or JDK Optional.
 final class OptionalFactories {
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
 
-  OptionalFactories(GeneratedComponentModel generatedComponentModel) {
-    this.generatedComponentModel = generatedComponentModel;
+  OptionalFactories(ComponentImplementation componentImplementation) {
+    this.componentImplementation = componentImplementation;
   }
 
   /**
@@ -115,7 +115,7 @@ CodeBlock absentOptionalProvider(ContributionBinding binding) {
             optionalKind,
             kind -> {
               MethodSpec method = absentOptionalProviderMethod(kind);
-              generatedComponentModel.addMethod(ABSENT_OPTIONAL_METHOD, method);
+              componentImplementation.addMethod(ABSENT_OPTIONAL_METHOD, method);
               return method;
             }));
   }
@@ -144,7 +144,7 @@ private MethodSpec absentOptionalProviderMethod(OptionalKind optionalKind) {
                 optionalKind,
                 kind -> {
                   FieldSpec field = absentOptionalProviderField(kind);
-                  generatedComponentModel.addField(ABSENT_OPTIONAL_FIELD, field);
+                  componentImplementation.addField(ABSENT_OPTIONAL_FIELD, field);
                   return field;
                 }))
         .addCode("return provider;")
@@ -293,7 +293,7 @@ CodeBlock presentOptionalFactory(ContributionBinding binding, CodeBlock delegate
             PresentFactorySpec.of(binding),
             spec -> {
               TypeSpec type = presentOptionalFactoryClass(spec);
-              generatedComponentModel.addType(PRESENT_FACTORY, type);
+              componentImplementation.addType(PRESENT_FACTORY, type);
               return type;
             }),
         delegateFactory);
diff --git a/java/dagger/internal/codegen/OptionalFactoryInstanceCreationExpression.java b/java/dagger/internal/codegen/OptionalFactoryInstanceCreationExpression.java
index 074167da4..9d53c0ec4 100644
--- a/java/dagger/internal/codegen/OptionalFactoryInstanceCreationExpression.java
+++ b/java/dagger/internal/codegen/OptionalFactoryInstanceCreationExpression.java
@@ -30,17 +30,17 @@
     implements FrameworkInstanceCreationExpression {
   private final OptionalFactories optionalFactories;
   private final ContributionBinding binding;
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final ComponentBindingExpressions componentBindingExpressions;
 
   OptionalFactoryInstanceCreationExpression(
       OptionalFactories optionalFactories,
       ContributionBinding binding,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       ComponentBindingExpressions componentBindingExpressions) {
     this.optionalFactories = optionalFactories;
     this.binding = binding;
-    this.generatedComponentModel = generatedComponentModel;
+    this.componentImplementation = componentImplementation;
     this.componentBindingExpressions = componentBindingExpressions;
   }
 
@@ -53,7 +53,7 @@ public CodeBlock creationExpression() {
             componentBindingExpressions
                 .getDependencyExpression(
                     bindingRequest(getOnlyElement(binding.frameworkDependencies())),
-                    generatedComponentModel.name())
+                    componentImplementation.name())
                 .codeBlock());
   }
 
diff --git a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
index d80adb82a..29cba7ee6 100644
--- a/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/PrivateMethodBindingExpression.java
@@ -19,7 +19,7 @@
 import static com.google.common.base.Preconditions.checkNotNull;
 import static com.google.common.base.Preconditions.checkState;
 import static com.squareup.javapoet.MethodSpec.methodBuilder;
-import static dagger.internal.codegen.GeneratedComponentModel.MethodSpecKind.PRIVATE_METHOD;
+import static dagger.internal.codegen.ComponentImplementation.MethodSpecKind.PRIVATE_METHOD;
 import static javax.lang.model.element.Modifier.PRIVATE;
 
 import com.squareup.javapoet.TypeName;
@@ -35,29 +35,29 @@
   private final ContributionBinding binding;
   private final BindingRequest request;
   private final BindingMethodImplementation methodImplementation;
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private String methodName;
 
   PrivateMethodBindingExpression(
       ResolvedBindings resolvedBindings,
       BindingRequest request,
       BindingMethodImplementation methodImplementation,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       Optional<ModifiableBindingMethod> matchingModifiableBindingMethod) {
-    super(methodImplementation, generatedComponentModel, matchingModifiableBindingMethod);
+    super(methodImplementation, componentImplementation, matchingModifiableBindingMethod);
     this.binding = resolvedBindings.contributionBinding();
     this.request = checkNotNull(request);
     this.methodImplementation = checkNotNull(methodImplementation);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.componentImplementation = checkNotNull(componentImplementation);
   }
 
   @Override
   protected void addMethod() {
     if (methodName == null) {
       // Have to set methodName field before implementing the method in order to handle recursion.
-      methodName = generatedComponentModel.getUniqueMethodName(request, binding);
+      methodName = componentImplementation.getUniqueMethodName(request, binding);
       // TODO(user): Fix the order that these generated methods are written to the component.
-      generatedComponentModel.addMethod(
+      componentImplementation.addMethod(
           PRIVATE_METHOD,
           methodBuilder(methodName)
               .addModifiers(PRIVATE)
diff --git a/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java b/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java
index d4f6d8587..5ad9236ab 100644
--- a/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java
+++ b/java/dagger/internal/codegen/ProducerFromProviderCreationExpression.java
@@ -29,15 +29,15 @@
 /** An {@link Producer} creation expression for provision bindings. */
 final class ProducerFromProviderCreationExpression implements FrameworkInstanceCreationExpression {
   private final ContributionBinding binding;
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final ComponentBindingExpressions componentBindingExpressions;
 
   ProducerFromProviderCreationExpression(
       ContributionBinding binding,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       ComponentBindingExpressions componentBindingExpressions) {
     this.binding = checkNotNull(binding);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.componentImplementation = checkNotNull(componentImplementation);
     this.componentBindingExpressions = checkNotNull(componentBindingExpressions);
   }
 
@@ -48,7 +48,7 @@ public CodeBlock creationExpression() {
         componentBindingExpressions
             .getDependencyExpression(
                 bindingRequest(binding.key(), FrameworkType.PROVIDER),
-                generatedComponentModel.name())
+                componentImplementation.name())
             .codeBlock());
   }
 
diff --git a/java/dagger/internal/codegen/ProducerNodeInstanceBindingExpression.java b/java/dagger/internal/codegen/ProducerNodeInstanceBindingExpression.java
index 939cf8dd4..44804c460 100644
--- a/java/dagger/internal/codegen/ProducerNodeInstanceBindingExpression.java
+++ b/java/dagger/internal/codegen/ProducerNodeInstanceBindingExpression.java
@@ -17,7 +17,7 @@
 package dagger.internal.codegen;
 
 import static com.google.common.base.Preconditions.checkNotNull;
-import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.FRAMEWORK_FIELD;
+import static dagger.internal.codegen.ComponentImplementation.FieldSpecKind.FRAMEWORK_FIELD;
 import static javax.lang.model.element.Modifier.PRIVATE;
 
 import com.squareup.javapoet.ClassName;
@@ -32,9 +32,8 @@
 
 /** Binding expression for producer node instances. */
 final class ProducerNodeInstanceBindingExpression extends FrameworkInstanceBindingExpression {
-
-  /** Model for the component defining this binding. */
-  private final GeneratedComponentModel generatedComponentModel;
+  /** The component defining this binding. */
+  private final ComponentImplementation componentImplementation;
 
   private final Key key;
   private final TypeMirror type;
@@ -44,9 +43,9 @@
       FrameworkInstanceSupplier frameworkInstanceSupplier,
       DaggerTypes types,
       DaggerElements elements,
-      GeneratedComponentModel generatedComponentModel) {
+      ComponentImplementation componentImplementation) {
     super(resolvedBindings, frameworkInstanceSupplier, types, elements);
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+    this.componentImplementation = checkNotNull(componentImplementation);
     this.key = resolvedBindings.key();
     this.type = types.wrapType(resolvedBindings.key().type(), Producer.class);
   }
@@ -59,13 +58,13 @@ protected FrameworkType frameworkType() {
   @Override
   Expression getDependencyExpression(ClassName requestingClass) {
     Expression result = super.getDependencyExpression(requestingClass);
-    generatedComponentModel.addCancellableProducerKey(key);
+    componentImplementation.addCancellableProducerKey(key);
     return result;
   }
 
   @Override
   Expression getDependencyExpressionForComponentMethod(
-      ComponentMethodDescriptor componentMethod, GeneratedComponentModel component) {
+      ComponentMethodDescriptor componentMethod, ComponentImplementation component) {
     if (component.componentDescriptor().kind().isProducer()) {
       return Expression.create(type, "$N", createField(componentMethod, component));
     } else {
@@ -79,7 +78,7 @@ Expression getDependencyExpressionForComponentMethod(
   }
 
   private FieldSpec createField(
-      ComponentMethodDescriptor componentMethod, GeneratedComponentModel component) {
+      ComponentMethodDescriptor componentMethod, ComponentImplementation component) {
     // TODO(cgdecker): Use a FrameworkFieldInitializer for this?
     // Though I don't think we need the once-only behavior of that, since I think
     // getComponentMethodImplementation will only be called once anyway
diff --git a/java/dagger/internal/codegen/PrunedConcreteMethodBindingExpression.java b/java/dagger/internal/codegen/PrunedConcreteMethodBindingExpression.java
index 1fbf0fbde..147149775 100644
--- a/java/dagger/internal/codegen/PrunedConcreteMethodBindingExpression.java
+++ b/java/dagger/internal/codegen/PrunedConcreteMethodBindingExpression.java
@@ -43,7 +43,7 @@
 
   @Override
   CodeBlock getModifiableBindingMethodImplementation(
-      ModifiableBindingMethod modifiableBindingMethod, GeneratedComponentModel component) {
+      ModifiableBindingMethod modifiableBindingMethod, ComponentImplementation component) {
     return METHOD_IMPLEMENTATION;
   }
 
diff --git a/java/dagger/internal/codegen/SetBindingExpression.java b/java/dagger/internal/codegen/SetBindingExpression.java
index ffb2d7b58..e6a3a6805 100644
--- a/java/dagger/internal/codegen/SetBindingExpression.java
+++ b/java/dagger/internal/codegen/SetBindingExpression.java
@@ -42,12 +42,12 @@
 
   SetBindingExpression(
       ResolvedBindings resolvedBindings,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       BindingGraph graph,
       ComponentBindingExpressions componentBindingExpressions,
       DaggerTypes types,
       DaggerElements elements) {
-    super(resolvedBindings, generatedComponentModel);
+    super(resolvedBindings, componentImplementation);
     this.binding = (ProvisionBinding) resolvedBindings.contributionBinding();
     this.graph = graph;
     this.componentBindingExpressions = componentBindingExpressions;
diff --git a/java/dagger/internal/codegen/SetFactoryCreationExpression.java b/java/dagger/internal/codegen/SetFactoryCreationExpression.java
index 1e85bd928..7c7d01ff7 100644
--- a/java/dagger/internal/codegen/SetFactoryCreationExpression.java
+++ b/java/dagger/internal/codegen/SetFactoryCreationExpression.java
@@ -30,10 +30,10 @@
 
   SetFactoryCreationExpression(
       ContributionBinding binding,
-      GeneratedComponentModel generatedComponentModel,
+      ComponentImplementation componentImplementation,
       ComponentBindingExpressions componentBindingExpressions,
       BindingGraph graph) {
-    super(binding, generatedComponentModel, componentBindingExpressions);
+    super(binding, componentImplementation, componentBindingExpressions);
     this.binding = checkNotNull(binding);
     this.graph = checkNotNull(graph);
   }
diff --git a/java/dagger/internal/codegen/SingleCheckedMethodImplementation.java b/java/dagger/internal/codegen/SingleCheckedMethodImplementation.java
index 944436225..ca8a2e2a3 100644
--- a/java/dagger/internal/codegen/SingleCheckedMethodImplementation.java
+++ b/java/dagger/internal/codegen/SingleCheckedMethodImplementation.java
@@ -16,7 +16,7 @@
 
 package dagger.internal.codegen;
 
-import static dagger.internal.codegen.GeneratedComponentModel.FieldSpecKind.PRIVATE_METHOD_SCOPED_FIELD;
+import static dagger.internal.codegen.ComponentImplementation.FieldSpecKind.PRIVATE_METHOD_SCOPED_FIELD;
 import static javax.lang.model.element.Modifier.PRIVATE;
 import static javax.lang.model.element.Modifier.VOLATILE;
 
@@ -35,7 +35,7 @@
  */
 final class SingleCheckedMethodImplementation extends BindingMethodImplementation {
 
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final ResolvedBindings resolvedBindings;
   private final ContributionBinding binding;
   private final BindingRequest request;
@@ -46,9 +46,9 @@
       BindingRequest request,
       BindingExpression bindingExpression,
       DaggerTypes types,
-      GeneratedComponentModel generatedComponentModel) {
-    super(resolvedBindings, request, bindingExpression, generatedComponentModel.name(), types);
-    this.generatedComponentModel = generatedComponentModel;
+      ComponentImplementation componentImplementation) {
+    super(resolvedBindings, request, bindingExpression, componentImplementation.name(), types);
+    this.componentImplementation = componentImplementation;
     this.resolvedBindings = resolvedBindings;
     this.binding = resolvedBindings.contributionBinding();
     this.request = request;
@@ -77,7 +77,7 @@ CodeBlock body() {
 
   private FieldSpec createField() {
     String name =
-        generatedComponentModel.getUniqueFieldName(
+        componentImplementation.getUniqueFieldName(
             request.isRequestKind(RequestKind.INSTANCE)
                 ? BindingVariableNamer.name(binding)
                 : FrameworkField.forResolvedBindings(resolvedBindings, Optional.empty()).name());
@@ -88,7 +88,7 @@ private FieldSpec createField() {
     }
 
     FieldSpec field = builder.build();
-    generatedComponentModel.addField(PRIVATE_METHOD_SCOPED_FIELD, field);
+    componentImplementation.addField(PRIVATE_METHOD_SCOPED_FIELD, field);
     return field;
   }
 
diff --git a/java/dagger/internal/codegen/StaticSwitchingProviders.java b/java/dagger/internal/codegen/StaticSwitchingProviders.java
index 2951ed0cc..ecc5a5885 100644
--- a/java/dagger/internal/codegen/StaticSwitchingProviders.java
+++ b/java/dagger/internal/codegen/StaticSwitchingProviders.java
@@ -51,10 +51,10 @@
   private final DaggerTypes types;
   private final ClassName owningComponent;
 
-  StaticSwitchingProviders(GeneratedComponentModel generatedComponentModel, DaggerTypes types) {
-    super(generatedComponentModel, types);
+  StaticSwitchingProviders(ComponentImplementation componentImplementation, DaggerTypes types) {
+    super(componentImplementation, types);
     this.types = types;
-    this.owningComponent = generatedComponentModel.name();
+    this.owningComponent = componentImplementation.name();
   }
 
   /**
diff --git a/java/dagger/internal/codegen/SwitchingProviders.java b/java/dagger/internal/codegen/SwitchingProviders.java
index a444a6c69..adb6b54b1 100644
--- a/java/dagger/internal/codegen/SwitchingProviders.java
+++ b/java/dagger/internal/codegen/SwitchingProviders.java
@@ -90,15 +90,15 @@
   private final Map<Key, SwitchingProviderBuilder> switchingProviderBuilders =
       new LinkedHashMap<>();
 
-  private final GeneratedComponentModel generatedComponentModel;
+  private final ComponentImplementation componentImplementation;
   private final ClassName owningComponent;
   private final DaggerTypes types;
   private final UniqueNameSet switchingProviderNames = new UniqueNameSet();
 
-  SwitchingProviders(GeneratedComponentModel generatedComponentModel, DaggerTypes types) {
-    this.generatedComponentModel = checkNotNull(generatedComponentModel);
+  SwitchingProviders(ComponentImplementation componentImplementation, DaggerTypes types) {
+    this.componentImplementation = checkNotNull(componentImplementation);
     this.types = checkNotNull(types);
-    this.owningComponent = checkNotNull(generatedComponentModel).name();
+    this.owningComponent = checkNotNull(componentImplementation).name();
   }
 
   /** Returns the {@link TypeSpec} for a {@code SwitchingProvider} based on the given builder. */
@@ -118,7 +118,7 @@ private SwitchingProviderBuilder getSwitchingProviderBuilder() {
       String name = switchingProviderNames.getUniqueName("SwitchingProvider");
       SwitchingProviderBuilder switchingProviderBuilder =
           new SwitchingProviderBuilder(owningComponent.nestedClass(name));
-      generatedComponentModel.addSwitchingProvider(switchingProviderBuilder::build);
+      componentImplementation.addSwitchingProvider(switchingProviderBuilder::build);
       return switchingProviderBuilder;
     }
     return getLast(switchingProviderBuilders.values());
