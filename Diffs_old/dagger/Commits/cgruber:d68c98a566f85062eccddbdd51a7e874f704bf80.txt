diff --git a/CHANGELOG.md b/CHANGELOG.md
index 96540da86..b2168197e 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -7,15 +7,15 @@ Dagger 2 (Components)
 ### Version 2.4 *(2016-04-21)*
   * Adds [`@Binds`](http://google.github.io/dagger/api/latest/dagger/Binds.html) API for delegating
     one binding to another
-  * Adds @IntoSet, @ElementsIntoSet and @IntoMap to replace @Provides(type = ...) and @Produces(type = ...)
-  * Allow injection of Provider<Lazy<Foo>>
-  * Report an error if a @Scope annotation is applied to an @Inject constructor
+  * Adds `@IntoSet`, `@ElementsIntoSet` and `@IntoMap` to replace `@Provides(type = ...)` and `@Produces(type = ...)`
+  * Allow injection of `Provider<Lazy<Foo>>`
+  * Report an error if a `@Scope` annotation is applied to an `@Inject` constructor
   * Remove the ability to set the production executor on a component builder.
   * Ensure that no binding methods are binding framework types.
   * New format of dependency traces in error messages
   * Fixed bug: Exception when a binding in a parent that is used only in a subcomponent depends on a binding in the subcomponent
   * Update to JavaPoet 1.6.1 and Google Java Format 1.0
-    * Fixes NoSuchMethodError from [Issue #356](https://github.com/google/dagger/issues/356)
+    * Fixes `NoSuchMethodError` from [Issue #356](https://github.com/google/dagger/issues/356)
 
 ### Version 2.3 *(2016-04-08)*
   * Adds [`@Reusable`]
@@ -60,8 +60,8 @@ A patch release, most crucially including:
 A maintenance release fixing immediate issues following the Dagger 2.0 release, including:
 
   * Speed up Graph Validation (reduce build times by 10s of seconds on sampled large projects)
-  * Generate correct code for @MapKey annotation types (beta)
-  * Fix to properly emit code for class literal values in @MapKey annotations.
+  * Generate correct code for `@MapKey` annotation types (beta)
+  * Fix to properly emit code for class literal values in `@MapKey` annotations.
   * Fix for injecting component dependencies
   * Fixes to generated code to account for differences in generics handling in ecg vs. javac.
   * Subcomponents can now be abstract classes.
diff --git a/compiler/src/it/functional-tests/src/main/java/test/bind/SimpleBindingModule.java b/compiler/src/it/functional-tests/src/main/java/test/bind/SimpleBindingModule.java
index f884c8b8c..bd5dd6354 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/bind/SimpleBindingModule.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/bind/SimpleBindingModule.java
@@ -18,6 +18,15 @@
 import dagger.Binds;
 import dagger.Module;
 import dagger.Provides;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoSet;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.TreeSet;
 import javax.inject.Singleton;
 import test.SomeQualifier;
 
@@ -41,4 +50,52 @@
   static Foo<Integer> provideFooOfIntegers() {
     return new Foo<Integer>() {};
   }
+
+  @Provides
+  static Foo<Double> provideFooOfDoubles() {
+    return new Foo<Double>() {};
+  }
+
+  @Binds
+  @IntoSet
+  abstract Foo<? extends Number> bindFooOfIntegersIntoSet(Foo<Integer> fooOfIntegers);
+
+  @Binds
+  @IntoSet
+  abstract Foo<? extends Number> bindFooExtendsNumberIntoSet(Foo<Double> fooOfDoubles);
+
+  @Binds
+  @ElementsIntoSet
+  abstract Set<Object> bindSetOfFooNumbersToObjects(Set<Foo<? extends Number>> setOfFooNumbers);
+
+  @Binds
+  @IntoSet
+  abstract Object bindFooOfStringsIntoSetOfObjects(FooOfStrings impl);
+
+  @Provides
+  static HashSet<String> provideStringHashSet() {
+    return new HashSet<>(Arrays.asList("hash-string1", "hash-string2"));
+  }
+
+  @Provides
+  static TreeSet<CharSequence> provideCharSequenceTreeSet() {
+    return new TreeSet<CharSequence>(Arrays.asList("tree-charSequence1", "tree-charSequence2"));
+  }
+
+  @Provides
+  static Collection<CharSequence> provideCharSequenceCollection() {
+    return Arrays.<CharSequence>asList("list-charSequence");
+  }
+
+  @Binds
+  @ElementsIntoSet
+  abstract Set<CharSequence> bindHashSetOfStrings(HashSet<String> set);
+
+  @Binds
+  @ElementsIntoSet
+  abstract Set<CharSequence> bindTreeSetOfCharSequences(TreeSet<CharSequence> set);
+
+  @Binds
+  @ElementsIntoSet
+  abstract Set<CharSequence> bindCollectionOfCharSequences(Collection<CharSequence> collection);
 }
diff --git a/compiler/src/it/functional-tests/src/main/java/test/bind/TestComponent.java b/compiler/src/it/functional-tests/src/main/java/test/bind/TestComponent.java
index d92e6029f..0a2a18efb 100644
--- a/compiler/src/it/functional-tests/src/main/java/test/bind/TestComponent.java
+++ b/compiler/src/it/functional-tests/src/main/java/test/bind/TestComponent.java
@@ -16,6 +16,7 @@
 package test.bind;
 
 import dagger.Component;
+import java.util.Set;
 import javax.inject.Singleton;
 import test.SomeQualifier;
 
@@ -32,4 +33,10 @@
   Foo<String> qualifiedFooOfStrings();
 
   Foo<Integer> fooOfIntegers();
+
+  Set<Foo<? extends Number>> foosOfNumbers();
+
+  Set<Object> objects();
+
+  Set<CharSequence> charSequences();
 }
diff --git a/compiler/src/it/functional-tests/src/test/java/test/bind/BindTest.java b/compiler/src/it/functional-tests/src/test/java/test/bind/BindTest.java
index 04de60e00..d91daeb06 100644
--- a/compiler/src/it/functional-tests/src/test/java/test/bind/BindTest.java
+++ b/compiler/src/it/functional-tests/src/test/java/test/bind/BindTest.java
@@ -15,6 +15,7 @@
  */
 package test.bind;
 
+import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.junit.runners.JUnit4;
@@ -23,9 +24,16 @@
 
 @RunWith(JUnit4.class)
 public class BindTest {
+
+  private TestComponent component;
+
+  @Before
+  public void setUp() {
+    component = DaggerTestComponent.create();
+  }
+
   @Test
   public void bindDelegates() {
-    TestComponent component = DaggerTestComponent.create();
     assertThat(component.object()).isInstanceOf(FooOfStrings.class);
     assertThat(component.fooOfStrings()).isInstanceOf(FooOfStrings.class);
     assertThat(component.fooOfObjects()).isInstanceOf(FooOfObjects.class);
@@ -34,8 +42,14 @@ public void bindDelegates() {
 
   @Test
   public void bindWithScope() {
-    TestComponent component = DaggerTestComponent.create();
     assertThat(component.qualifiedFooOfStrings())
         .isSameAs(component.qualifiedFooOfStrings());
   }
+
+  @Test
+  public void multibindings() {
+    assertThat(component.foosOfNumbers()).hasSize(2);
+    assertThat(component.objects()).hasSize(3);
+    assertThat(component.charSequences()).hasSize(5);
+  }
 }
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/Foo.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/Foo.java
new file mode 100644
index 000000000..5b0908832
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/Foo.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.bind;
+
+/**
+ * This is the type that will be bound.  We throw in generics just to complicate the test.
+ */
+interface Foo<T> {}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/FooOfStrings.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/FooOfStrings.java
new file mode 100644
index 000000000..66f93406d
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/FooOfStrings.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.bind;
+
+/**
+ * This is not marked with {@link javax.inject.Inject @Inject} (like the {@link dagger.Provides
+ * @Provides} version in {@link test.bind.FooOfStrings}), to test that {@link dagger.Binds @Binds}
+ * properly translate to {@link dagger.internal.codegen.ProductionBinding}s when the right-hand-side
+ * of the method is also a production binding. We force this by adding a {@link
+ * dagger.producers.Produces @Produces} method to add it to the graph instead of relying on the
+ * {@link dagger.internal.codegen.ProvisionBinding} that would be created by default with an {@code
+ * @Inject} constructor.
+ */
+final class FooOfStrings implements Foo<String> {}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/SimpleBindingModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/SimpleBindingModule.java
new file mode 100644
index 000000000..fb851e21a
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/SimpleBindingModule.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.bind;
+
+import com.google.common.util.concurrent.MoreExecutors;
+import dagger.Binds;
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntoSet;
+import dagger.producers.ProducerModule;
+import dagger.producers.Produces;
+import dagger.producers.Production;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.TreeSet;
+import java.util.concurrent.Executor;
+import javax.inject.Qualifier;
+import javax.inject.Singleton;
+
+@ProducerModule(includes = SimpleBindingModule.ExecutorModule.class)
+abstract class SimpleBindingModule {
+  @Binds
+  abstract Object bindObject(FooOfStrings impl);
+
+  @Binds
+  abstract Foo<String> bindFooOfStrings(FooOfStrings impl);
+
+  @Binds
+  abstract Foo<? extends Number> bindFooOfNumbers(Foo<Integer> fooOfIntegers);
+
+  @Binds
+  @Singleton
+  @SomeQualifier
+  abstract Foo<String> bindQualifiedFooOfStrings(FooOfStrings impl);
+
+  @Produces
+  static FooOfStrings produceFooOfStrings() {
+    return new FooOfStrings();
+  }
+
+  @Produces
+  static Foo<Integer> produceFooOfIntegers() {
+    return new Foo<Integer>() {};
+  }
+
+  @Produces
+  static Foo<Double> produceFooOfDoubles() {
+    return new Foo<Double>() {};
+  }
+
+  @Binds
+  @IntoSet
+  abstract Foo<? extends Number> bindFooOfIntegersIntoSet(Foo<Integer> fooOfIntegers);
+
+  @Binds
+  @IntoSet
+  abstract Foo<? extends Number> bindFooExtendsNumberIntoSet(Foo<Double> fooOfDoubles);
+
+  @Binds
+  @ElementsIntoSet
+  abstract Set<Object> bindSetOfFooNumbersToObjects(Set<Foo<? extends Number>> setOfFooNumbers);
+
+  @Binds
+  @IntoSet
+  abstract Object bindFooOfStringsIntoSetOfObjects(FooOfStrings impl);
+
+  @Produces
+  static HashSet<String> produceStringHashSet() {
+    return new HashSet<>(Arrays.asList("hash-string1", "hash-string2"));
+  }
+
+  @Produces
+  static TreeSet<CharSequence> produceCharSequenceTreeSet() {
+    return new TreeSet<CharSequence>(Arrays.asList("tree-charSequence1", "tree-charSequence2"));
+  }
+
+  @Produces
+  static Collection<CharSequence> produceCharSequenceCollection() {
+    return Arrays.<CharSequence>asList("list-charSequence");
+  }
+
+  @Binds
+  @ElementsIntoSet
+  abstract Set<CharSequence> bindHashSetOfStrings(HashSet<String> set);
+
+  @Binds
+  @ElementsIntoSet
+  abstract Set<CharSequence> bindTreeSetOfCharSequences(TreeSet<CharSequence> set);
+
+  @Binds
+  @ElementsIntoSet
+  abstract Set<CharSequence> bindCollectionOfCharSequences(Collection<CharSequence> collection);
+
+  @Qualifier
+  @Retention(RetentionPolicy.RUNTIME)
+  @interface SomeQualifier {}
+
+  @Module
+  static final class ExecutorModule {
+    @Provides @Production
+    static Executor provideExecutor() {
+      return MoreExecutors.directExecutor();
+    }
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/SimpleBindsProductionComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/SimpleBindsProductionComponent.java
new file mode 100644
index 000000000..6c69b79f2
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/bind/SimpleBindsProductionComponent.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.bind;
+
+import com.google.common.util.concurrent.ListenableFuture;
+import dagger.producers.ProductionComponent;
+import java.util.Set;
+import javax.inject.Singleton;
+import producerstest.bind.SimpleBindingModule.SomeQualifier;
+
+@Singleton
+@ProductionComponent(modules = SimpleBindingModule.class)
+public interface SimpleBindsProductionComponent {
+  ListenableFuture<Object> object();
+
+  ListenableFuture<Foo<String>> fooOfStrings();
+
+  @SomeQualifier
+  ListenableFuture<Foo<String>> qualifiedFooOfStrings();
+
+  ListenableFuture<Foo<Integer>> fooOfIntegers();
+
+  ListenableFuture<Set<Foo<? extends Number>>> foosOfNumbers();
+
+  ListenableFuture<Set<Object>> objects();
+
+  ListenableFuture<Set<CharSequence>> charSequences();
+}
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
index 8decb55fb..a9c9360bf 100644
--- a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingComponent.java
@@ -26,7 +26,9 @@
 import producerstest.multibindings.Qualifiers.PossiblyThrowingMap;
 import producerstest.multibindings.Qualifiers.PossiblyThrowingSet;
 
-@ProductionComponent(modules = {ExecutorModule.class, MultibindingProducerModule.class})
+@ProductionComponent(
+  modules = {ExecutorModule.class, MultibindingProducerModule.class, MultibindingModule.class}
+)
 interface MultibindingComponent {
   ListenableFuture<Set<String>> strs();
   ListenableFuture<Integer> strCount();
diff --git a/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingModule.java b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingModule.java
new file mode 100644
index 000000000..5c5834f54
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/main/java/producerstest/multibindings/MultibindingModule.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.multibindings;
+
+import com.google.common.collect.ImmutableSet;
+import dagger.Module;
+import dagger.Provides;
+import dagger.multibindings.ElementsIntoSet;
+import dagger.multibindings.IntKey;
+import dagger.multibindings.IntoMap;
+import dagger.multibindings.IntoSet;
+import java.util.Set;
+
+@Module
+final class MultibindingModule {
+  @Provides
+  @IntoSet
+  static String providedStr() {
+    return "providedStr";
+  }
+
+  @Provides
+  @ElementsIntoSet
+  static Set<String> providedStrs() {
+    return ImmutableSet.of("providedStr1", "providedStr2");
+  }
+
+  @Provides
+  @IntoMap
+  @IntKey(3)
+  static String providedValueFor3() {
+    return "provided three";
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/bind/BindsProducersTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/bind/BindsProducersTest.java
new file mode 100644
index 000000000..88c675c97
--- /dev/null
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/bind/BindsProducersTest.java
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2016 Google, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package producerstest.bind;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.JUnit4;
+
+import static com.google.common.truth.Truth.assertThat;
+
+@RunWith(JUnit4.class)
+public class BindsProducersTest {
+
+  private SimpleBindsProductionComponent component;
+
+  @Before
+  public void setUp() {
+    component = DaggerSimpleBindsProductionComponent.create();
+  }
+
+  @Test
+  public void bindDelegates() throws Exception {
+    assertThat(component.object().get()).isInstanceOf(FooOfStrings.class);
+    assertThat(component.fooOfStrings().get()).isInstanceOf(FooOfStrings.class);
+    assertThat(component.fooOfIntegers().get()).isNotNull();
+  }
+
+  @Test
+  public void bindWithScope() throws Exception {
+    assertThat(component.qualifiedFooOfStrings().get())
+        .isSameAs(component.qualifiedFooOfStrings().get());
+  }
+
+  @Test
+  public void multibindings() throws Exception {
+    assertThat(component.foosOfNumbers().get()).hasSize(2);
+    assertThat(component.objects().get()).hasSize(3);
+    assertThat(component.charSequences().get()).hasSize(5);
+  }
+}
diff --git a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
index 03aae67bb..3d9c4677c 100644
--- a/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
+++ b/compiler/src/it/producers-functional-tests/src/test/java/producerstest/multibindings/MultibindingTest.java
@@ -36,8 +36,17 @@
   public void setBinding() throws Exception {
     MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     assertThat(multibindingComponent.strs().get())
-        .containsExactly("foo", "foo1", "foo2", "bar", "bar1", "bar2");
-    assertThat(multibindingComponent.strCount().get()).isEqualTo(6);
+        .containsExactly(
+            "foo",
+            "foo1",
+            "foo2",
+            "bar",
+            "bar1",
+            "bar2",
+            "providedStr",
+            "providedStr1",
+            "providedStr2");
+    assertThat(multibindingComponent.strCount().get()).isEqualTo(9);
   }
 
   @Test
@@ -50,7 +59,10 @@ public void setBindingOfProduced() throws Exception {
             Produced.successful("foo2"),
             Produced.successful("bar"),
             Produced.successful("bar1"),
-            Produced.successful("bar2"));
+            Produced.successful("bar2"),
+            Produced.successful("providedStr"),
+            Produced.successful("providedStr1"),
+            Produced.successful("providedStr2"));
   }
 
   @Test
@@ -75,31 +87,36 @@ public void setBindingOfProducedWithFailures() throws Exception {
   public void mapBinding() throws Exception {
     MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     Map<Integer, String> map = multibindingComponent.map().get();
-    assertThat(map).hasSize(2);
+    assertThat(map).hasSize(3);
     assertThat(map).containsEntry(15, "fifteen");
     assertThat(map).containsEntry(42, "forty two");
+    assertThat(map).containsEntry(3, "provided three");
   }
 
   @Test
   public void mapOfProducerBinding() throws Exception {
     MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     Map<Integer, Producer<String>> map = multibindingComponent.mapOfProducer().get();
-    assertThat(map).hasSize(2);
+    assertThat(map).hasSize(3);
     assertThat(map).containsKey(15);
     assertThat(map.get(15).get().get()).isEqualTo("fifteen");
     assertThat(map).containsKey(42);
     assertThat(map.get(42).get().get()).isEqualTo("forty two");
+    assertThat(map).containsKey(3);
+    assertThat(map.get(3).get().get()).isEqualTo("provided three");
   }
 
   @Test
   public void mapOfProducedBinding() throws Exception {
     MultibindingComponent multibindingComponent = DaggerMultibindingComponent.create();
     Map<Integer, Produced<String>> map = multibindingComponent.mapOfProduced().get();
-    assertThat(map).hasSize(2);
+    assertThat(map).hasSize(3);
     assertThat(map).containsKey(15);
     assertThat(map.get(15).get()).isEqualTo("fifteen");
     assertThat(map).containsKey(42);
     assertThat(map.get(42).get()).isEqualTo("forty two");
+    assertThat(map).containsKey(3);
+    assertThat(map.get(3).get()).isEqualTo("provided three");
   }
 
   @Test
diff --git a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
index 15845651c..703ebb384 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AbstractComponentWriter.java
@@ -33,6 +33,7 @@
 import com.squareup.javapoet.MethodSpec;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
+import com.squareup.javapoet.TypeVariableName;
 import dagger.internal.DelegateFactory;
 import dagger.internal.MapFactory;
 import dagger.internal.MapProviderFactory;
@@ -109,7 +110,6 @@
 import static dagger.internal.codegen.TypeNames.SINGLE_CHECK;
 import static dagger.internal.codegen.TypeNames.STRING;
 import static dagger.internal.codegen.TypeNames.UNSUPPORTED_OPERATION_EXCEPTION;
-import static dagger.internal.codegen.TypeNames.providerOf;
 import static dagger.internal.codegen.TypeSpecs.addSupertype;
 import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static dagger.internal.codegen.Util.requiresAPassedInstance;
@@ -534,7 +534,8 @@ private boolean useRawType(Optional<String> bindingPackage) {
    * injector.
    */
   private Optional<MemberSelect> staticMemberSelect(ResolvedBindings resolvedBindings) {
-    switch (resolvedBindings.bindingKey().kind()) {
+    BindingKey bindingKey = resolvedBindings.bindingKey();
+    switch (bindingKey.kind()) {
       case CONTRIBUTION:
         ContributionBinding contributionBinding = resolvedBindings.contributionBinding();
         if (contributionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)
@@ -542,7 +543,7 @@ private boolean useRawType(Optional<String> bindingPackage) {
           switch (contributionBinding.bindingKind()) {
             case SYNTHETIC_MULTIBOUND_MAP:
               BindingType bindingType = contributionBinding.bindingType();
-              MapType mapType = MapType.from(contributionBinding.key().type());
+              MapType mapType = MapType.from(contributionBinding.key());
               return Optional.of(
                   emptyFrameworkMapFactory(
                       frameworkMapFactoryClassName(bindingType),
@@ -554,6 +555,19 @@ private boolean useRawType(Optional<String> bindingPackage) {
                   emptySetFactoryStaticMemberSelect(
                       contributionBinding.bindingType(), contributionBinding.key()));
 
+            case INJECTION:
+            case PROVISION:
+              if (bindingKey.key().type().getKind().equals(DECLARED)) {
+                ImmutableList<TypeVariableName> typeVariables =
+                    SourceFiles.bindingTypeElementTypeVariableNames(contributionBinding);
+                if (!typeVariables.isEmpty()) {
+                  List<? extends TypeMirror> typeArguments =
+                      ((DeclaredType) bindingKey.key().type()).getTypeArguments();
+                  return Optional.of(MemberSelect.parameterizedFactoryCreateMethod(
+                      generatedClassNameForBinding(contributionBinding), typeArguments));
+                }
+              }
+
             default:
               return Optional.of(
                   staticMethod(
@@ -579,14 +593,12 @@ private boolean useRawType(Optional<String> bindingPackage) {
   }
 
   /**
-   * A static member select for an empty set factory. Calls
-   * {@link SetFactory#create(javax.inject.Provider...)},
-   * {@link SetProducer#create(dagger.producers.Producer...)}, or
-   * {@link SetOfProducedProducer#create(dagger.producers.Producer...)}, depending on the set
+   * A static member select for an empty set factory. Calls {@link SetFactory#empty()}, {@link
+   * SetProducer#empty()}, or {@link SetOfProducedProducer#empty()}, depending on the set
    * bindings.
    */
   private static MemberSelect emptySetFactoryStaticMemberSelect(BindingType bindingType, Key key) {
-    return emptySetProvider(setFactoryClassName(bindingType, key), SetType.from(key.type()));
+    return emptySetProvider(setFactoryClassName(bindingType, key), SetType.from(key));
   }
 
   /**
@@ -602,7 +614,7 @@ private static ClassName setFactoryClassName(BindingType bindingType, Key key) {
     if (bindingType.equals(BindingType.PROVISION)) {
       return SET_FACTORY;
     } else {
-      SetType setType = SetType.from(key.type());
+      SetType setType = SetType.from(key);
       return setType.elementsAreTypeOf(Produced.class) ? SET_OF_PRODUCED_PRODUCER : SET_PRODUCER;
     }
   }
@@ -618,7 +630,7 @@ private static ClassName setFactoryClassName(BindingType bindingType, Key key) {
   private static ClassName mapFactoryClassName(ContributionBinding binding) {
     switch (binding.bindingType()) {
       case PRODUCTION:
-        return MapType.from(binding.key().type()).valuesAreTypeOf(Produced.class)
+        return MapType.from(binding.key()).valuesAreTypeOf(Produced.class)
             ? MAP_OF_PRODUCED_PRODUCER : MAP_PRODUCER;
 
       case PROVISION:
@@ -684,19 +696,6 @@ private void implementInterfaceMethods() {
               }
               break;
             case INSTANCE:
-              if (memberSelect.staticMember()
-                  && bindingKey.key().type().getKind().equals(DECLARED)
-                  && !((DeclaredType) bindingKey.key().type()).getTypeArguments().isEmpty()) {
-                // If using a parameterized enum type, then we need to store the factory
-                // in a temporary variable, in order to help javac be able to infer
-                // the generics of the Factory.create methods.
-                TypeName factoryType = providerOf(TypeName.get(requestType.getReturnType()));
-                interfaceMethod
-                    .addStatement("$T factory = $L", factoryType, memberSelectCodeBlock)
-                    .addStatement("return factory.get()");
-                break;
-              }
-              // fall through in the else case.
             case LAZY:
             case PRODUCED:
             case PRODUCER:
@@ -1123,7 +1122,7 @@ private CodeBlock initializeFactoryForSetMultibinding(ContributionBinding bindin
         CodeBlock.builder().add("$T.", setFactoryClassName(binding.bindingType(), binding.key()));
     boolean useRawTypes = useRawType(binding);
     if (!useRawTypes) {
-      SetType setType = SetType.from(binding.key().type());
+      SetType setType = SetType.from(binding.key());
       builder.add(
           "<$T>",
           setType.elementsAreTypeOf(Produced.class)
@@ -1137,23 +1136,23 @@ private CodeBlock initializeFactoryForSetMultibinding(ContributionBinding bindin
       ContributionType contributionType =
           graph.resolvedBindings().get(frameworkDependency.bindingKey()).contributionType();
       String methodName;
+      String methodNameSuffix = frameworkDependency.frameworkClass().getSimpleName();
       switch (contributionType) {
         case SET:
           individualProviders++;
-          methodName = "add";
+          methodName = "add" + methodNameSuffix;
           break;
         case SET_VALUES:
           setProviders++;
-          methodName = "addSet";
+          methodName = "addCollection" + methodNameSuffix;
           break;
         default:
           throw new AssertionError(frameworkDependency + " is not a set multibinding");
       }
 
       builderMethodCalls.add(
-          ".$L$L($L)",
+          ".$L($L)",
           methodName,
-          frameworkDependency.frameworkClass().getSimpleName(),
           potentiallyCast(
               useRawTypes,
               frameworkDependency.frameworkClass(),
@@ -1184,14 +1183,18 @@ private CodeBlock initializeFactoryForMapMultibinding(ContributionBinding bindin
       BindingKey bindingKey = frameworkDependency.bindingKey();
       ContributionBinding contributionBinding =
           graph.resolvedBindings().get(bindingKey).contributionBinding();
+      CodeBlock value =
+          potentiallyCast(
+              useRawTypes,
+              frameworkDependency.frameworkClass(),
+              getDependencyArgument(frameworkDependency));
+      if (binding.bindingType().frameworkClass().equals(Producer.class)
+          && frameworkDependency.frameworkClass().equals(Provider.class)) {
+        value = CodeBlock.of("$T.producerFromProvider($L)", PRODUCERS, value);
+      }
       codeBlocks.add(
           CodeBlock.of(
-              ".put($L, $L)",
-              getMapKeyExpression(contributionBinding.mapKey().get()),
-              potentiallyCast(
-                  useRawTypes,
-                  frameworkDependency.frameworkClass(),
-                  getDependencyArgument(frameworkDependency))));
+              ".put($L, $L)", getMapKeyExpression(contributionBinding.mapKey().get()), value));
     }
     codeBlocks.add(CodeBlock.of(".build()"));
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java b/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
index d4772f3a5..5095ebbdc 100644
--- a/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
+++ b/compiler/src/main/java/dagger/internal/codegen/AnnotationSpecs.java
@@ -28,10 +28,5 @@ private static AnnotationSpec suppressWarnings(String value) {
     return AnnotationSpec.builder(SuppressWarnings.class).addMember("value", "$S", value).build();
   }
 
-  static final AnnotationSpec PROVIDES_SET_VALUES =
-      AnnotationSpec.builder(Provides.class)
-          .addMember("type", "$T.SET_VALUES", ClassName.get(Provides.Type.class))
-          .build();
-
   private AnnotationSpecs() {}
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/Binding.java b/compiler/src/main/java/dagger/internal/codegen/Binding.java
index e3e6e49be..47e343604 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Binding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Binding.java
@@ -74,10 +74,8 @@
    * Returns the name of the package in which this binding must be managed. E.g.: a binding
    * may reference non-public types.
    */
-  abstract Optional<String> bindingPackage();
-
-  protected static Optional<String> findBindingPackage(Key bindingKey) {
-    Set<String> packages = nonPublicPackageUse(bindingKey.type());
+  final Optional<String> bindingPackage() {
+    Set<String> packages = nonPublicPackageUse(key().type());
     switch (packages.size()) {
       case 0:
         return Optional.absent();
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
index 6a2a513f4..837d0b2fd 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingDeclaration.java
@@ -70,16 +70,6 @@ TypeElement bindingTypeElement() {
     return contributingModule().transform(AS_DECLARED_TYPE);
   }
 
-  /**
-   * The type of {@link #bindingElement()}, considered as a member of {@link #contributingModule()}
-   * if it is present.
-   */
-  TypeMirror declaredType(Types types) {
-    return contributingModuleType().isPresent()
-        ? types.asMemberOf(contributingModuleType().get(), bindingElement())
-        : bindingElement().asType();
-  }
-
   static final Function<BindingDeclaration, Set<TypeElement>> CONTRIBUTING_MODULE =
       new Function<BindingDeclaration, Set<TypeElement>>() {
         @Override
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
index b27fac745..45ebf760e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingGraph.java
@@ -36,6 +36,7 @@
 import dagger.Subcomponent;
 import dagger.internal.codegen.BindingType.HasBindingType;
 import dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;
+import dagger.internal.codegen.Key.HasKey;
 import dagger.producers.ProductionComponent;
 import java.util.ArrayDeque;
 import java.util.Collection;
@@ -284,6 +285,7 @@ private BindingGraph create(
       final ImmutableSetMultimap<Key, ContributionBinding> explicitMultibindings;
       final ImmutableSetMultimap<Key, MultibindingDeclaration> multibindingDeclarations;
       final ImmutableSetMultimap<Key, DelegateDeclaration> delegateDeclarations;
+      final ImmutableSetMultimap<Key, DelegateDeclaration> delegateMultibindingDeclarations;
       final Map<BindingKey, ResolvedBindings> resolvedBindings;
       final Deque<BindingKey> cycleStack = new ArrayDeque<>();
       final Cache<BindingKey, Boolean> dependsOnLocalMultibindingsCache =
@@ -309,16 +311,10 @@ private BindingGraph create(
         assert delegateDeclarations != null;
         this.delegateDeclarations = delegateDeclarations;
         this.resolvedBindings = Maps.newLinkedHashMap();
-
-        ImmutableSetMultimap.Builder<Key, ContributionBinding> explicitMultibindingsBuilder =
-            ImmutableSetMultimap.builder();
-        for (ContributionBinding binding : explicitBindingsSet) {
-          if (binding.key().bindingMethodIdentifier().isPresent()) {
-            explicitMultibindingsBuilder.put(
-                binding.key().withoutBindingMethodIdentifier(), binding);
-          }
-        }
-        this.explicitMultibindings = explicitMultibindingsBuilder.build();
+        this.explicitMultibindings =
+            multibindingsKeyedWithoutBindingIdentifiers(explicitBindingsSet);
+        this.delegateMultibindingDeclarations =
+            multibindingsKeyedWithoutBindingIdentifiers(delegateDeclarations.values());
       }
 
       /**
@@ -354,19 +350,14 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
             ImmutableSet.Builder<DelegateDeclaration> delegateDeclarationsBuilder =
                 ImmutableSet.builder();
 
-            // Add explicit bindings and declarations (those from modules and components).
-            contributionBindings.addAll(getExplicitBindings(key));
-            multibindings.addAll(getExplicitMultibindings(key));
-            multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(key));
-            delegateDeclarationsBuilder.addAll(getDelegateDeclarations(key));
-
-            // If the key is Set<Produced<T>>, then add explicit bindings and declarations for
-            // Set<T>.
-            Optional<Key> implicitSetKey = keyFactory.implicitSetKeyFromProduced(key);
-            contributionBindings.addAll(getExplicitBindings(implicitSetKey));
-            multibindings.addAll(getExplicitMultibindings(implicitSetKey));
-            multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(implicitSetKey));
-            delegateDeclarationsBuilder.addAll(getDelegateDeclarations(implicitSetKey));
+            for (Key keyOrImplicitKey : explicitAndImplicitKeys(key)) {
+              contributionBindings.addAll(getExplicitBindings(keyOrImplicitKey));
+              multibindings.addAll(getExplicitMultibindings(keyOrImplicitKey));
+              multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(keyOrImplicitKey));
+              delegateDeclarationsBuilder.addAll(getDelegateDeclarations(keyOrImplicitKey));
+              multibindings.addAll(
+                  delegateBindings(getDelegateMultibindingDeclarations(keyOrImplicitKey)));
+            }
 
             ImmutableSet<MultibindingDeclaration> multibindingDeclarations =
                 multibindingDeclarationsBuilder.build();
@@ -378,27 +369,15 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
             // If the key is Map<K, V>, get its map-of-framework-type binding keys, which are either
             // Map<K, Provider<V>> or Map<K, Producer<V>>, and grab their explicit bindings and
             // declarations.
-            Optional<Key> implicitMapProviderKey = keyFactory.implicitMapProviderKeyFrom(key);
-            ImmutableSet<ContributionBinding> explicitProviderMapBindings =
-                getExplicitMultibindings(implicitMapProviderKey);
-            ImmutableSet<MultibindingDeclaration> explicitProviderMultibindingDeclarations =
-                getMultibindingDeclarations(implicitMapProviderKey);
-
-            Optional<Key> implicitMapProducerKey = keyFactory.implicitMapProducerKeyFrom(key);
-            ImmutableSet<ContributionBinding> explicitProducerMapBindings =
-                getExplicitMultibindings(implicitMapProducerKey);
-            ImmutableSet<MultibindingDeclaration> explicitProducerMultibindingDeclarations =
-                getMultibindingDeclarations(implicitMapProducerKey);
-
-            if (!explicitProducerMapBindings.isEmpty()
-                || !explicitProducerMultibindingDeclarations.isEmpty()) {
+            if (shouldCreateSyntheticMapOfValuesBinding(
+                keyFactory.implicitMapProducerKeyFrom(key))) {
               /* If the binding key is Map<K, V> or Map<K, Produced<V>> and there are some explicit
                * Map<K, Producer<V>> bindings or multibinding declarations, then add the synthetic
                * binding that depends on Map<K, Producer<V>>. */
               contributionBindings.add(
                   productionBindingFactory.syntheticMapOfValuesOrProducedBinding(request));
-            } else if (!explicitProviderMapBindings.isEmpty()
-                || !explicitProviderMultibindingDeclarations.isEmpty()) {
+            } else if (shouldCreateSyntheticMapOfValuesBinding(
+                keyFactory.implicitMapProviderKeyFrom(key))) {
               /* If the binding key is Map<K, V> and there are some explicit Map<K, Provider<V>>
                * bindings or multibinding declarations but no explicit Map<K, Producer<V>> bindings
                * or multibinding declarations, then add the synthetic binding that depends on
@@ -452,6 +431,23 @@ ResolvedBindings lookUpBindings(DependencyRequest request) {
         }
       }
 
+      private Iterable<Key> explicitAndImplicitKeys(Key key) {
+        return ImmutableSet.<Key>builder()
+            .add(key)
+            .addAll(keyFactory.implicitSetKeyFromProduced(key).asSet())
+            .addAll(keyFactory.implicitProviderMapKeyFromProducer(key).asSet())
+            .build();
+      }
+
+      private boolean shouldCreateSyntheticMapOfValuesBinding(Optional<Key> key) {
+        if (!key.isPresent()) {
+          return false;
+        }
+        return !getExplicitMultibindings(key.get()).isEmpty()
+            || !getMultibindingDeclarations(key.get()).isEmpty()
+            || !getDelegateDeclarations(key.get()).isEmpty();
+      }
+
       private ImmutableSet<ContributionBinding> delegateBindings(
           ImmutableSet<DelegateDeclaration> delegateDeclarations) {
         ImmutableSet.Builder<ContributionBinding> builder = ImmutableSet.builder();
@@ -582,12 +578,6 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
         return explicitBindingsForKey.build();
       }
 
-      private ImmutableSet<ContributionBinding> getExplicitBindings(Optional<Key> optionalKey) {
-        return optionalKey.isPresent()
-            ? getExplicitBindings(optionalKey.get())
-            : ImmutableSet.<ContributionBinding>of();
-      }
-
       /**
        * Returns the explicit multibindings whose key (minus its
        * {@link Key#bindingMethodIdentifier()}) matches the {@code requestKey} from this and all
@@ -602,13 +592,6 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
         return explicitMultibindingsForKey.build();
       }
 
-      private ImmutableSet<ContributionBinding> getExplicitMultibindings(
-          Optional<Key> optionalKey) {
-        return optionalKey.isPresent()
-            ? getExplicitMultibindings(optionalKey.get())
-            : ImmutableSet.<ContributionBinding>of();
-      }
-
       /**
        * Returns the {@link MultibindingDeclaration}s that match the {@code key} from this and all
        * ancestor resolvers.
@@ -622,13 +605,6 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
         return multibindingDeclarations.build();
       }
 
-      private ImmutableSet<MultibindingDeclaration> getMultibindingDeclarations(
-          Optional<Key> optionalKey) {
-        return optionalKey.isPresent()
-            ? getMultibindingDeclarations(optionalKey.get())
-            : ImmutableSet.<MultibindingDeclaration>of();
-      }
-
       private ImmutableSet<DelegateDeclaration> getDelegateDeclarations(Key key) {
         ImmutableSet.Builder<DelegateDeclaration> delegateDeclarations =
             ImmutableSet.builder();
@@ -638,11 +614,14 @@ private boolean isResolvedInParent(DependencyRequest request, ContributionBindin
         return delegateDeclarations.build();
       }
 
-      private ImmutableSet<DelegateDeclaration> getDelegateDeclarations(
-          Optional<Key> optionalKey) {
-        return optionalKey.isPresent()
-            ? getDelegateDeclarations(optionalKey.get())
-            : ImmutableSet.<DelegateDeclaration>of();
+      private ImmutableSet<DelegateDeclaration> getDelegateMultibindingDeclarations(Key key) {
+        ImmutableSet.Builder<DelegateDeclaration> delegateMultibindingDeclarations =
+            ImmutableSet.builder();
+        for (Resolver resolver : getResolverLineage()) {
+          delegateMultibindingDeclarations.addAll(
+              resolver.delegateMultibindingDeclarations.get(key));
+        }
+        return delegateMultibindingDeclarations.build();
       }
 
       private Optional<ResolvedBindings> getPreviouslyResolvedBindings(
@@ -835,5 +814,21 @@ private boolean isMultibindingsWithLocalContributions(ResolvedBindings resolvedB
         }
       }
     }
+
+    /**
+     * Selects each item in {@code haveKeys} that has a {@link Key#bindingMethodIdentifier()} and
+     * indexes them by its {@link HasKey#key()}, where each key has its {@link
+     * dagger.internal.codegen.Key.BindingMethodIdentifier} removed.
+     */
+    static <T extends HasKey> ImmutableSetMultimap<Key, T>
+        multibindingsKeyedWithoutBindingIdentifiers(Iterable<T> haveKeys) {
+      ImmutableSetMultimap.Builder<Key, T> builder = ImmutableSetMultimap.builder();
+      for (T hasKey : haveKeys) {
+        if (hasKey.key().bindingMethodIdentifier().isPresent()) {
+          builder.put(hasKey.key().withoutBindingMethodIdentifier(), hasKey);
+        }
+      }
+      return builder.build();
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
index 3d4837705..0afbdd09e 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingMethodValidator.java
@@ -298,7 +298,7 @@ protected void checkSetValuesType(ValidationReport.Builder<ExecutableElement> bu
     checkSetValuesType(builder, builder.getSubject().getReturnType());
   }
 
-  /** Adds an error if {@code type} is not a a {@code Set<T>} for a reasonable {@code T}. */
+  /** Adds an error if {@code type} is not a {@code Set<T>} for a reasonable {@code T}. */
   protected final void checkSetValuesType(
       ValidationReport.Builder<ExecutableElement> builder, TypeMirror type) {
     if (!SetType.isSet(type)) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java b/compiler/src/main/java/dagger/internal/codegen/BindingVariableNamer.java
similarity index 51%
rename from compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java
rename to compiler/src/main/java/dagger/internal/codegen/BindingVariableNamer.java
index 5fe12b102..4ed87ebc5 100644
--- a/compiler/src/main/java/dagger/internal/codegen/KeyVariableNamer.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindingVariableNamer.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import com.google.common.base.Function;
 import java.util.Iterator;
 import javax.lang.model.type.DeclaredType;
 import javax.lang.model.type.TypeMirror;
@@ -25,42 +24,54 @@
 import static com.google.common.base.CaseFormat.UPPER_CAMEL;
 
 /**
- * Suggests a variable name for a type based on a {@link Key}. Prefer
+ * Suggests a variable name for a type based on a {@link Binding}. Prefer
  * {@link DependencyVariableNamer} for cases where a specific {@link DependencyRequest} is present.
  *
  * @author Gregory Kick
  * @since 2.0
  */
-enum KeyVariableNamer implements Function<Key, String> {
-  INSTANCE;
+final class BindingVariableNamer {
 
-  @Override
-  public String apply(Key key) {
+  private BindingVariableNamer() {}
+
+  static String name(Binding binding) {
     StringBuilder builder = new StringBuilder();
 
+    Key key = binding.key();
     if (key.qualifier().isPresent()) {
       // TODO(gak): Use a better name for fields with qualifiers with members.
       builder.append(key.qualifier().get().getAnnotationType().asElement().getSimpleName());
     }
 
-    key.type().accept(new SimpleTypeVisitor6<Void, StringBuilder>() {
-      @Override
-      public Void visitDeclared(DeclaredType t, StringBuilder builder) {
-        builder.append(t.asElement().getSimpleName());
-        Iterator<? extends TypeMirror> argumentIterator = t.getTypeArguments().iterator();
-        if (argumentIterator.hasNext()) {
-          builder.append("Of");
-          TypeMirror first = argumentIterator.next();
-          first.accept(this, builder);
-          while (argumentIterator.hasNext()) {
-            builder.append("And");
-            argumentIterator.next().accept(this, builder);
+    TypeMirror type = typeToName(binding);
+    type.accept(
+        new SimpleTypeVisitor6<Void, StringBuilder>() {
+          @Override
+          public Void visitDeclared(DeclaredType t, StringBuilder builder) {
+            builder.append(t.asElement().getSimpleName());
+            Iterator<? extends TypeMirror> argumentIterator = t.getTypeArguments().iterator();
+            if (argumentIterator.hasNext()) {
+              builder.append("Of");
+              TypeMirror first = argumentIterator.next();
+              first.accept(this, builder);
+              while (argumentIterator.hasNext()) {
+                builder.append("And");
+                argumentIterator.next().accept(this, builder);
+              }
+            }
+            return null;
           }
-        }
-        return null;
-      }
-    }, builder);
+        },
+        builder);
 
     return UPPER_CAMEL.to(LOWER_CAMEL, builder.toString());
   }
+
+  private static TypeMirror typeToName(Binding binding) {
+    if (binding instanceof ContributionBinding
+        && ((ContributionBinding) binding).contributionType().equals(ContributionType.SET)) {
+      return SetType.from(binding.key().type()).elementType();
+    }
+    return binding.key().type();
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
index 369f424eb..dc8929ceb 100644
--- a/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/BindsMethodValidator.java
@@ -15,27 +15,41 @@
  */
 package dagger.internal.codegen;
 
+import com.google.auto.common.MoreElements;
+import com.google.auto.common.MoreTypes;
+import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import dagger.Binds;
 import dagger.Module;
+import dagger.multibindings.IntoMap;
 import dagger.producers.ProducerModule;
 import java.util.List;
+import java.util.Set;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
+import javax.lang.model.element.TypeElement;
 import javax.lang.model.element.VariableElement;
+import javax.lang.model.type.TypeMirror;
+import javax.lang.model.type.DeclaredType;
+import javax.lang.model.util.ElementFilter;
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.auto.common.MoreElements.isAnnotationPresent;
 import static com.google.common.collect.Iterables.getOnlyElement;
 import static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;
 import static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;
+import static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_MAP_HAS_MAP_KEY;
+import static dagger.internal.codegen.ErrorMessages.BINDS_ELEMENTS_INTO_SET_METHOD_RETURN_SET;
 import static dagger.internal.codegen.ErrorMessages.BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER;
+import static dagger.internal.codegen.MapKeys.getMapKeys;
 
 /**
  * A validator for {@link Binds} methods.
  */
 final class BindsMethodValidator extends BindingMethodValidator {
   private final Types types;
+  private final Elements elements;
 
   BindsMethodValidator(Elements elements, Types types) {
     super(
@@ -45,7 +59,8 @@
         ImmutableSet.of(Module.class, ProducerModule.class),
         MUST_BE_ABSTRACT,
         RUNTIME_EXCEPTION);
-    this.types = checkNotNull(types);
+    this.types = types;
+    this.elements = elements;
   }
 
   @Override
@@ -54,31 +69,81 @@ protected void checkMethod(ValidationReport.Builder<ExecutableElement> builder)
     checkParameters(builder);
   }
 
-  @Override // TODO(dpb, ronshapiro): When @Binds methods support multibindings, stop overriding.
-  protected void checkReturnType(ValidationReport.Builder<ExecutableElement> builder) {
-    checkFrameworkType(builder);
-    checkKeyType(builder, builder.getSubject().getReturnType());
-  }
-
-  @Override // TODO(dpb, ronshapiro): When @Binds methods support multibindings, stop overriding.
+  @Override // TODO(dpb, ronshapiro): When @Binds methods support @IntoMap, stop overriding.
   protected void checkMapKeys(ValidationReport.Builder<ExecutableElement> builder) {
-    // no-op
+    if (!isAnnotationPresent(builder.getSubject(), IntoMap.class)) {
+      for (AnnotationMirror mapKey : getMapKeys(builder.getSubject())) {
+        builder.addError(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY, builder.getSubject(), mapKey);
+      }
+    }
   }
 
-  @Override // TODO(dpb, ronshapiro): When @Binds methods support multibindings, stop overriding.
+  @Override
   protected void checkMultibindings(ValidationReport.Builder<ExecutableElement> builder) {
-    // no-op
+    super.checkMultibindings(builder);
+    if (isAnnotationPresent(builder.getSubject(), IntoMap.class)) {
+      builder.addError("@Binds @IntoMap is not yet supported");
+    }
   }
 
   private void checkParameters(ValidationReport.Builder<ExecutableElement> builder) {
     List<? extends VariableElement> parameters = builder.getSubject().getParameters();
     if (parameters.size() == 1) {
       VariableElement parameter = getOnlyElement(parameters);
-      if (!types.isAssignable(parameter.asType(), builder.getSubject().getReturnType())) {
-        builder.addError(formatErrorMessage(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER));
+      TypeMirror leftHandSide = builder.getSubject().getReturnType();
+      TypeMirror rightHandSide = parameter.asType();
+      switch (ContributionType.fromBindingMethod(builder.getSubject())) {
+        case SET_VALUES:
+          if (!SetType.isSet(leftHandSide)) {
+            builder.addError(BINDS_ELEMENTS_INTO_SET_METHOD_RETURN_SET);
+          } else {
+            validateTypesAreAssignable(
+                builder,
+                rightHandSide,
+                methodParameterType(MoreTypes.asDeclared(leftHandSide), "addAll"));
+          }
+          break;
+        case SET:
+          DeclaredType parameterizedSetType = types.getDeclaredType(setElement(), leftHandSide);
+          validateTypesAreAssignable(
+              builder,
+              rightHandSide,
+              methodParameterType(parameterizedSetType, "add"));
+          break;
+        case UNIQUE:
+          validateTypesAreAssignable(builder, rightHandSide, leftHandSide);
+          break;
+        default:
+          // @IntoMap not yet supported
       }
     } else {
-      builder.addError(formatErrorMessage(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER));
+      builder.addError(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER);
     }
   }
+
+  private TypeMirror methodParameterType(DeclaredType type, String methodName) {
+    ImmutableList.Builder<ExecutableElement> methodsForName = ImmutableList.builder();
+    for (ExecutableElement method :
+        ElementFilter.methodsIn(MoreElements.asType(type.asElement()).getEnclosedElements())) {
+      if (method.getSimpleName().contentEquals(methodName)) {
+        methodsForName.add(method);
+      }
+    }
+    ExecutableElement method = getOnlyElement(methodsForName.build());
+    return getOnlyElement(
+        MoreTypes.asExecutable(types.asMemberOf(type, method)).getParameterTypes());
+  }
+
+  private void validateTypesAreAssignable(
+      ValidationReport.Builder<ExecutableElement> builder,
+      TypeMirror rightHandSide,
+      TypeMirror leftHandSide) {
+    if (!types.isAssignable(rightHandSide, leftHandSide)) {
+      builder.addError(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER);
+    }
+  }
+
+  private TypeElement setElement() {
+    return elements.getTypeElement(Set.class.getName());
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
index 27b6c7442..fe22d2b11 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ContributionBinding.java
@@ -184,9 +184,9 @@ public Kind apply(ContributionBinding binding) {
      */
     static Kind forMultibindingRequest(DependencyRequest request) {
       Key key = request.key();
-      if (SetType.isSet(key.type())) {
+      if (SetType.isSet(key)) {
         return SYNTHETIC_MULTIBOUND_SET;
-      } else if (MapType.isMap(key.type())) {
+      } else if (MapType.isMap(key)) {
         return SYNTHETIC_MULTIBOUND_MAP;
       } else {
         throw new IllegalArgumentException(
@@ -244,9 +244,9 @@ FactoryCreationStrategy factoryCreationStrategy() {
   final TypeMirror factoryType() {
     switch (contributionType()) {
       case MAP:
-        return MapType.from(key().type()).unwrappedValueType(frameworkClass());
+        return MapType.from(key()).unwrappedValueType(frameworkClass());
       case SET:
-        return SetType.from(key().type()).elementType();
+        return SetType.from(key()).elementType();
       case SET_VALUES:
       case UNIQUE:
         return key().type();
diff --git a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
index a6872f5e8..7997581ef 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DelegateDeclaration.java
@@ -18,17 +18,20 @@
 import com.google.auto.common.MoreElements;
 import com.google.auto.common.MoreTypes;
 import com.google.auto.value.AutoValue;
+import com.google.common.base.Equivalence;
 import com.google.common.base.Optional;
 import com.google.common.collect.Iterables;
 import dagger.Binds;
 import dagger.internal.codegen.ContributionType.HasContributionType;
+import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
 import javax.lang.model.type.ExecutableType;
 import javax.lang.model.util.Types;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static dagger.internal.codegen.ContributionType.UNIQUE;
+import static dagger.internal.codegen.MapKeys.getMapKey;
+import static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;
 
 /**
  * The declaration for a delegate binding established by a {@link Binds} method.
@@ -37,11 +40,6 @@
 abstract class DelegateDeclaration extends BindingDeclaration implements HasContributionType {
   abstract DependencyRequest delegateRequest();
 
-  @Override
-  public ContributionType contributionType() {
-    return UNIQUE;
-  }
-
   static final class Factory {
     private final Types types;
     private final Key.Factory keyFactory;
@@ -65,6 +63,7 @@ DelegateDeclaration create(
               Iterables.getOnlyElement(bindsMethod.getParameters()),
               Iterables.getOnlyElement(resolvedMethod.getParameterTypes()));
       return new AutoValue_DelegateDeclaration(
+          ContributionType.fromBindingMethod(bindsMethod),
           keyFactory.forBindsMethod(bindsMethod, resolvedMethod),
           bindsMethod,
           Optional.of(contributingElement),
diff --git a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
index 3cdf9832e..0a0b5b109 100644
--- a/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
+++ b/compiler/src/main/java/dagger/internal/codegen/DependencyRequest.java
@@ -199,19 +199,6 @@ public boolean apply(DependencyRequest request) {
       return builder.build();
     }
 
-    ImmutableSet<DependencyRequest> forRequiredVariables(
-        List<? extends VariableElement> variables) {
-      return FluentIterable.from(variables)
-          .transform(
-              new Function<VariableElement, DependencyRequest>() {
-                @Override
-                public DependencyRequest apply(VariableElement input) {
-                  return forRequiredVariable(input);
-                }
-              })
-          .toSet();
-    }
-
     /**
      * Creates a implicit {@link DependencyRequest} for {@code mapOfFactoryKey}, which will be used
      * to satisfy the {@code mapOfValueRequest}.
@@ -481,12 +468,5 @@ protected KindAndType defaultAction(TypeMirror otherType, Void p) {
           },
           null);
     }
-
-    static DeclaredType getEnclosingType(Element element) {
-      while (!MoreElements.isType(element)) {
-        element = element.getEnclosingElement();
-      }
-      return MoreTypes.asDeclared(element.asType());
-    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
index 8b07e58c9..cbb82fc58 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ErrorMessages.java
@@ -143,6 +143,9 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   static final String BINDING_METHOD_SET_VALUES_RAW_SET =
       "@%s methods of type set values cannot return a raw Set";
 
+  static final String BINDS_ELEMENTS_INTO_SET_METHOD_RAW_SET_PARAMETER =
+      "@Binds @ElementsIntoSet methods cannot take a raw Set parameter";
+
   static final String BINDING_METHOD_SET_VALUES_RETURN_SET =
       "@%s methods of type set values must return a Set";
 
@@ -171,12 +174,18 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   static final String BINDING_METHOD_TYPE_PARAMETER =
       "@%s methods may not have type parameters.";
 
+  // TODO(ronshapiro): clarify this error message for @ElementsIntoSet cases, where the
+  // right-hand-side might not be assignable to the left-hand-side, but still compatible with
+  // Set.addAll(Collection<? extends E>)
   static final String BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER =
       "@Binds methods must have only one parameter whose type is assignable to the return type";
 
   static final String BINDING_METHOD_NOT_IN_MODULE =
       "@%s methods can only be present within a @%s";
 
+  static final String BINDS_ELEMENTS_INTO_SET_METHOD_RETURN_SET =
+      "@Binds @ElementsIntoSet methods must return a Set and take a Set parameter";
+
   static final String BINDING_METHOD_NOT_MAP_HAS_MAP_KEY =
       "@%s methods of non map type cannot declare a map key";
 
@@ -196,9 +205,6 @@ static String inconsistentMapKeyAnnotationsError(String key) {
   static final String MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT =
       "Modules with type parameters must be abstract";
 
-  static final String REFERENCED_MODULES_MUST_NOT_BE_ABSTRACT =
-      "%s is listed as a module, but is an abstract class or interface";
-
   static final String REFERENCED_MODULE_NOT_ANNOTATED =
       "%s is listed as a module, but is not annotated with %s";
 
@@ -259,10 +265,6 @@ static String provisionMayNotDependOnProducerType(TypeMirror type) {
         MoreTypes.asTypeElement(type).getSimpleName());
   }
 
-  static final String PRODUCTION_COMPONENT_SCOPE =
-      "Production components may not declare any @Scope other than @ProductionScope; they are "
-          + "automatically scoped with @ProductionScope if no scope is applied.";
-
   static final String MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION =
       "This type supports members injection but cannot be implicitly provided.";
 
@@ -274,9 +276,6 @@ static String provisionMayNotDependOnProducerType(TypeMirror type) {
 
   static final String CONTAINS_DEPENDENCY_CYCLE_FORMAT = "%s.%s() contains a dependency cycle:\n%s";
 
-  static final String MALFORMED_MODULE_METHOD_FORMAT =
-      "Cannot generated a graph because method %s on module %s was malformed";
-
   static String nullableToNonNullable(String typeName, String bindingString) {
     return String.format(
             "%s is not nullable, but is being provided by %s",
@@ -291,8 +290,8 @@ static String nullableToNonNullable(String typeName, String bindingString) {
       "Cannot return null from a non-@Nullable @Provides method";
 
   /* Multibinding messages */
-  static final String MULTIBINDING_ANNOTATION_NOT_ON_PROVIDES_OR_PRODUCES =
-      "Multibinding annotations may only be on @Provides or @Produces methods";
+  static final String MULTIBINDING_ANNOTATION_NOT_ON_BINDING_METHOD =
+      "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods";
 
   static final String MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD =
       "Multiple multibinding annotations cannot be placed on the same %s method";
@@ -441,7 +440,7 @@ String moreThanOneRefToSubcomponent() {
     }
   }
 
-  static final class ProductionComponentBuilderMessages extends ComponentBuilderMessages {
+  private static final class ProductionComponentBuilderMessages extends ComponentBuilderMessages {
     @SuppressWarnings("hiding")
     static final ProductionComponentBuilderMessages INSTANCE =
         new ProductionComponentBuilderMessages();
@@ -452,7 +451,8 @@ String moreThanOneRefToSubcomponent() {
     }
   }
 
-  static final class ProductionSubcomponentBuilderMessages extends ComponentBuilderMessages {
+  private static final class ProductionSubcomponentBuilderMessages
+      extends ComponentBuilderMessages {
     @SuppressWarnings("hiding")
     static final ProductionSubcomponentBuilderMessages INSTANCE =
         new ProductionSubcomponentBuilderMessages();
@@ -462,14 +462,6 @@ protected String process(String s) {
       return s.replaceAll("component", "production subcomponent")
           .replaceAll("Component", "ProductionSubcomponent");
     }
-
-    String builderMethodRequiresNoArgs() {
-      return "Methods returning a @ProductionSubcomponent.Builder must have no arguments";
-    }
-
-    String moreThanOneRefToSubcomponent() {
-      return "Only one method can create a given production subcomponent. %s is created by: %s";
-    }
   }
 
   /** Error messages related to {@link Multibindings @Multibindings}. */
@@ -489,7 +481,7 @@ static String tooManyMethodsForKey(String formattedKey) {
 
     private MultibindingsMessages() {}
   }
-  
+
   /**
    * Error messages related to {@link Multibinds @Multibinds} methods and methods in
    * {@link Multibindings} interfaces.
diff --git a/compiler/src/main/java/dagger/internal/codegen/Formatter.java b/compiler/src/main/java/dagger/internal/codegen/Formatter.java
index 93f88bee1..8eb4a2006 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Formatter.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Formatter.java
@@ -16,7 +16,6 @@
 package dagger.internal.codegen;
 
 import com.google.common.base.Function;
-import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 
 import static dagger.internal.codegen.ErrorMessages.INDENT;
@@ -50,14 +49,6 @@
     return format(object);
   }
 
-  /**
-   * Formats {@code items}, one per line.
-   */
-  public void formatIndentedList(
-      StringBuilder builder, Iterable<? extends T> items, int indentLevel) {
-    formatIndentedList(builder, indentLevel, items, ImmutableList.<T>of());
-  }
-
   /**
    * Formats {@code items}, one per line. Stops after {@code limit} items.
    */
diff --git a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
index 3d1951809..a508eded3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
+++ b/compiler/src/main/java/dagger/internal/codegen/FrameworkField.java
@@ -77,10 +77,10 @@ private static TypeMirror fieldValueType(ResolvedBindings resolvedBindings) {
     if (resolvedBindings.isMultibindingContribution()) {
       switch (resolvedBindings.contributionType()) {
         case MAP:
-          return MapType.from(resolvedBindings.key().type())
+          return MapType.from(resolvedBindings.key())
               .unwrappedValueType(resolvedBindings.frameworkClass());
         case SET:
-          return SetType.from((resolvedBindings.key().type())).elementType();
+          return SetType.from(resolvedBindings.key()).elementType();
         default:
           // do nothing
       }
@@ -95,7 +95,7 @@ private static String frameworkFieldName(ResolvedBindings resolvedBindings) {
         return BINDING_ELEMENT_NAME.visit(binding.bindingElement(), binding);
       }
     }
-    return KeyVariableNamer.INSTANCE.apply(resolvedBindings.key());
+    return BindingVariableNamer.name(resolvedBindings.binding());
   }
 
   private static final ElementVisitor<String, Binding> BINDING_ELEMENT_NAME =
diff --git a/compiler/src/main/java/dagger/internal/codegen/Key.java b/compiler/src/main/java/dagger/internal/codegen/Key.java
index c67d374d8..29f804b3b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Key.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Key.java
@@ -322,7 +322,7 @@ private Key forProvidesOrProducesMethod(
         returnType = Iterables.getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());
       }
       TypeMirror keyType =
-          providesOrProducesKeyType(returnType, method, contributionType, frameworkType);
+          bindingMethodKeyType(returnType, method, contributionType, frameworkType);
       Key key = forMethod(method, keyType);
       return contributionType.equals(ContributionType.UNIQUE)
           ? key
@@ -356,10 +356,24 @@ Key forMultibindsMethod(
     /** Returns the key bound by a {@link Binds} method. */
     Key forBindsMethod(ExecutableElement method, ExecutableType methodType) {
       checkArgument(isAnnotationPresent(method, Binds.class));
-      return forMethod(method, normalize(types, methodType.getReturnType()));
+      ContributionType contributionType = ContributionType.fromBindingMethod(method);
+      TypeMirror returnType = normalize(types, methodType.getReturnType());
+      TypeMirror keyType =
+          bindingMethodKeyType(
+              // TODO(ronshapiro): Map<K, Framework<V>> can't be determined at this point. When
+              // @IntoMap support is added, consider replacing getProviderElement() with a
+              // placeholder type, which is then replaced when the DelegateDeclaration is translated
+              // into a Provision or ProductionBinding
+              returnType, method, contributionType, getProviderElement());
+      Key key = forMethod(method, keyType);
+      return contributionType.equals(ContributionType.UNIQUE)
+          ? key
+          : key.withBindingMethodIdentifier(
+              BindingMethodIdentifier.create(
+                  method, MoreElements.asType(method.getEnclosingElement())));
     }
 
-    private TypeMirror providesOrProducesKeyType(
+    private TypeMirror bindingMethodKeyType(
         TypeMirror returnType,
         ExecutableElement method,
         ContributionType contributionType,
@@ -470,8 +484,8 @@ Key forProductionImplementationExecutor() {
     private Optional<Key> maybeRewrapMapValue(
         Key possibleMapKey, Class<?> currentWrappingClass, Class<?> newWrappingClass) {
       checkArgument(!currentWrappingClass.equals(newWrappingClass));
-      if (MapType.isMap(possibleMapKey.type())) {
-        MapType mapType = MapType.from(possibleMapKey.type());
+      if (MapType.isMap(possibleMapKey)) {
+        MapType mapType = MapType.from(possibleMapKey);
         if (mapType.valuesAreTypeOf(currentWrappingClass)) {
           TypeElement wrappingElement = getClassElement(newWrappingClass);
           if (wrappingElement == null) {
@@ -495,8 +509,8 @@ Key forProductionImplementationExecutor() {
      * {@code Map<K, V>}.
      */
     private Optional<Key> maybeWrapMapValue(Key possibleMapKey, Class<?> wrappingClass) {
-      if (MapType.isMap(possibleMapKey.type())) {
-        MapType mapType = MapType.from(possibleMapKey.type());
+      if (MapType.isMap(possibleMapKey)) {
+        MapType mapType = MapType.from(possibleMapKey);
         if (!mapType.valuesAreTypeOf(wrappingClass)) {
           TypeElement wrappingElement = getClassElement(wrappingClass);
           if (wrappingElement == null) {
@@ -531,5 +545,13 @@ Key forProductionImplementationExecutor() {
       }
       return Optional.absent();
     }
+
+    /**
+     * Optionally extract a {@link Key} for a {@code Map<K, Provider<V>>} if the given key is for
+     * {@code Map<K, Producer<V>>}.
+     */
+    Optional<Key> implicitProviderMapKeyFromProducer(Key possibleMapOfProducerKey) {
+      return maybeRewrapMapValue(possibleMapOfProducerKey, Producer.class, Provider.class);
+    }
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MapType.java b/compiler/src/main/java/dagger/internal/codegen/MapType.java
index 5c0faf820..aa481cf0b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MapType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MapType.java
@@ -103,6 +103,13 @@ static boolean isMap(TypeMirror type) {
     return MoreTypes.isType(type) && MoreTypes.isTypeOf(Map.class, type);
   }
 
+  /**
+   * {@code true} if {@code key.type()} is a {@link Map} type.
+   */
+  static boolean isMap(Key key) {
+    return isMap(key.type());
+  }
+
   /**
    * Returns a {@link MapType} for {@code type}.
    *
@@ -112,4 +119,13 @@ static MapType from(TypeMirror type) {
     checkArgument(isMap(type), "%s is not a Map", type);
     return new AutoValue_MapType(MoreTypes.equivalence().wrap(MoreTypes.asDeclared(type)));
   }
+
+  /**
+   * Returns a {@link MapType} for {@code key}'s {@link Key#type() type}.
+   *
+   * @throws IllegalArgumentException if {@code key.type()} is not a {@link Map} type
+   */
+  static MapType from(Key key) {
+    return from(key.type());
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
index 33a14838f..777dabe3b 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MemberSelect.java
@@ -21,6 +21,7 @@
 import dagger.MembersInjector;
 import dagger.internal.MapProviderFactory;
 import dagger.producers.internal.MapOfProducerProducer;
+import java.util.List;
 import java.util.Set;
 import javax.lang.model.type.TypeMirror;
 
@@ -29,6 +30,7 @@
 import static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
 import static dagger.internal.codegen.CodeBlocks.toCodeBlocks;
+import static dagger.internal.codegen.TypeNames.FACTORY;
 import static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCER_PRODUCER;
 import static dagger.internal.codegen.TypeNames.MAP_PROVIDER_FACTORY;
 import static dagger.internal.codegen.TypeNames.MEMBERS_INJECTOR;
@@ -74,6 +76,19 @@ static MemberSelect staticMethod(ClassName owningClass, CodeBlock methodInvocati
     return new StaticMethod(owningClass, methodInvocationCodeBlock);
   }
 
+  /**
+   * Returns a {@link MemberSelect} for the instance of a {@code create()} method on a factory.
+   * This only applies for factories that do not have any dependencies.
+   */
+  static MemberSelect parameterizedFactoryCreateMethod(
+      ClassName owningClass, List<? extends TypeMirror> parameters) {
+    return new ParameterizedStaticMethod(
+        owningClass,
+        ImmutableList.<TypeMirror>copyOf(parameters),
+        CodeBlock.of("create()"),
+        FACTORY);
+  }
+
   private static final class StaticMethod extends MemberSelect {
     final CodeBlock methodCodeBlock;
 
@@ -130,7 +145,7 @@ static MemberSelect emptySetProvider(ClassName setFactoryType, SetType setType)
     return new ParameterizedStaticMethod(
         setFactoryType,
         ImmutableList.of(setType.elementType()),
-        CodeBlock.of("create()"),
+        CodeBlock.of("empty()"),
         SET);
   }
 
diff --git a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
index 3ca4f0cde..2429870e6 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MembersInjectionBinding.java
@@ -224,7 +224,6 @@ public Key apply(DeclaredType superclass) {
           Optional.<TypeElement>absent(),
           key,
           dependencies,
-          findBindingPackage(key),
           hasNonDefaultTypeParameters(typeElement, key.type(), types)
               ? Optional.of(
                   forInjectedType(
diff --git a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
index c875d23c7..bfb655672 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ModuleDescriptor.java
@@ -46,7 +46,6 @@
 import static com.google.common.base.Preconditions.checkState;
 import static com.google.common.base.Verify.verify;
 import static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;
-import static dagger.internal.codegen.Util.componentCanMakeNewInstances;
 import static javax.lang.model.type.TypeKind.DECLARED;
 import static javax.lang.model.type.TypeKind.NONE;
 import static javax.lang.model.util.ElementFilter.methodsIn;
@@ -62,8 +61,6 @@
     };
   }
 
-  abstract AnnotationMirror moduleAnnotation();
-
   abstract TypeElement moduleElement();
 
   abstract ImmutableSet<ModuleDescriptor> includedModules();
@@ -80,13 +77,6 @@
    */
   abstract ImmutableSet<DelegateDeclaration> delegateDeclarations();
 
-  enum DefaultCreationStrategy {
-    PASSED,
-    CONSTRUCTED,
-  }
-
-  abstract DefaultCreationStrategy defaultCreationStrategy();
-
   enum Kind {
     MODULE(
         Module.class, Provides.class, ImmutableSet.of(Module.class)),
@@ -161,11 +151,9 @@
     }
 
     ModuleDescriptor create(TypeElement moduleElement) {
-      Optional<AnnotationMirror> probableModuleAnnotation = getModuleAnnotation(moduleElement);
-      checkState(probableModuleAnnotation.isPresent(),
+      checkState(getModuleAnnotation(moduleElement).isPresent(),
           "%s did not have an AnnotationMirror for @Module",
           moduleElement.getQualifiedName());
-      AnnotationMirror moduleAnnotation = probableModuleAnnotation.get();
 
       ImmutableSet.Builder<ContributionBinding> bindings = ImmutableSet.builder();
       ImmutableSet.Builder<DelegateDeclaration> delegates = ImmutableSet.builder();
@@ -194,21 +182,13 @@ ModuleDescriptor create(TypeElement moduleElement) {
         }
       }
 
-      DefaultCreationStrategy defaultCreationStrategy =
-          (componentCanMakeNewInstances(moduleElement)
-              && moduleElement.getTypeParameters().isEmpty())
-                  ? ModuleDescriptor.DefaultCreationStrategy.CONSTRUCTED
-                  : ModuleDescriptor.DefaultCreationStrategy.PASSED;
-
       return new AutoValue_ModuleDescriptor(
-          moduleAnnotation,
           moduleElement,
           ImmutableSet.copyOf(
               collectIncludedModules(new LinkedHashSet<ModuleDescriptor>(), moduleElement)),
           bindings.build(),
           multibindingDeclarations.build(),
-          delegates.build(),
-          defaultCreationStrategy);
+          delegates.build());
     }
 
     private static Optional<AnnotationMirror> getModuleAnnotation(TypeElement moduleElement) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
index 108557e91..6da60c38c 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingAnnotationsProcessingStep.java
@@ -16,11 +16,9 @@
 package dagger.internal.codegen;
 
 import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;
-import com.google.common.base.Predicate;
-import com.google.common.base.Predicates;
-import com.google.common.collect.FluentIterable;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.SetMultimap;
+import dagger.Binds;
 import dagger.Provides;
 import dagger.multibindings.ElementsIntoSet;
 import dagger.multibindings.IntoMap;
@@ -35,8 +33,8 @@
 import javax.tools.Diagnostic.Kind;
 
 import static com.google.auto.common.MoreElements.getAnnotationMirror;
-import static dagger.internal.codegen.ErrorMessages.MULTIBINDING_ANNOTATION_NOT_ON_PROVIDES_OR_PRODUCES;
-import static dagger.internal.codegen.Util.hasAnnotationType;
+import static dagger.internal.codegen.ErrorMessages.MULTIBINDING_ANNOTATION_NOT_ON_BINDING_METHOD;
+import static dagger.internal.codegen.Util.isAnyAnnotationPresent;
 
 /**
  * Processing step which verifies that {@link IntoSet @IntoSet}, {@link ElementsIntoSet
@@ -44,6 +42,9 @@
  */
 final class MultibindingAnnotationsProcessingStep implements ProcessingStep {
 
+  private static final ImmutableSet<Class<? extends Annotation>> VALID_BINDING_ANNOTATIONS =
+      ImmutableSet.of(Provides.class, Produces.class, Binds.class);
+
   private final Messager messager;
 
   MultibindingAnnotationsProcessingStep(Messager messager) {
@@ -60,18 +61,12 @@
       SetMultimap<Class<? extends Annotation>, Element> elementsByAnnotation) {
     for (Entry<Class<? extends Annotation>, Element> entry : elementsByAnnotation.entries()) {
       Element element = entry.getValue();
-      boolean onBindingMethod =
-          FluentIterable.from(element.getAnnotationMirrors()).anyMatch(providesOrProducesMethod());
-      if (!onBindingMethod) {
+      if (!isAnyAnnotationPresent(element, VALID_BINDING_ANNOTATIONS)) {
         AnnotationMirror annotation = getAnnotationMirror(entry.getValue(), entry.getKey()).get();
         messager.printMessage(
-            Kind.ERROR, MULTIBINDING_ANNOTATION_NOT_ON_PROVIDES_OR_PRODUCES, element, annotation);
+            Kind.ERROR, MULTIBINDING_ANNOTATION_NOT_ON_BINDING_METHOD, element, annotation);
       }
     }
     return ImmutableSet.of();
   }
-
-  private static Predicate<AnnotationMirror> providesOrProducesMethod() {
-    return Predicates.or(hasAnnotationType(Provides.class), hasAnnotationType(Produces.class));
-  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java
index 4b7252cf6..b32338e93 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindingsMethodValidator.java
@@ -21,7 +21,7 @@
 import javax.lang.model.util.Elements;
 import javax.lang.model.util.Types;
 
-/** A {@link Validator} for methods in {@link Multibindings @Multibindings} interfaces. */
+/** A validator for methods in {@link Multibindings @Multibindings} interfaces. */
 final class MultibindingsMethodValidator extends MultibindsMethodValidator {
 
   MultibindingsMethodValidator(Elements elements, Types types) {
diff --git a/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java b/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java
index 3b07faad7..d31a7d990 100644
--- a/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/MultibindsMethodValidator.java
@@ -40,12 +40,12 @@
 import static dagger.internal.codegen.MapKeys.getMapKeys;
 
 /**
- * A {@link Validator} for {@link Multibinds @Multibinds} methods or methods in
- * {@link Multibindings @Multibindings} interfaces.
+ * A validator for {@link Multibinds @Multibinds} methods or methods in {@link Multibindings
+ * @Multibindings} interfaces.
  */
 class MultibindsMethodValidator extends BindingMethodValidator {
 
-  /** Creates a {@link Validator} for {@link Multibinds @Multibinds} methods. */
+  /** Creates a validator for {@link Multibinds @Multibinds} methods. */
   MultibindsMethodValidator(Elements elements, Types types) {
     this(elements, types, Multibinds.class, ImmutableSet.of(Module.class, ProducerModule.class));
   }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
index e1cbc85d6..22613b440 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProducerFactoryGenerator.java
@@ -26,11 +26,10 @@
 import com.squareup.javapoet.ClassName;
 import com.squareup.javapoet.CodeBlock;
 import com.squareup.javapoet.MethodSpec;
+import com.squareup.javapoet.ParameterizedTypeName;
 import com.squareup.javapoet.TypeName;
 import com.squareup.javapoet.TypeSpec;
 import dagger.producers.Producer;
-import dagger.producers.monitoring.ProducerMonitor;
-import java.util.List;
 import javax.annotation.processing.Filer;
 import javax.lang.model.element.Element;
 import javax.lang.model.type.TypeMirror;
@@ -42,7 +41,6 @@
 import static com.squareup.javapoet.TypeSpec.classBuilder;
 import static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;
 import static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;
-import static dagger.internal.codegen.CodeBlocks.toCodeBlocks;
 import static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;
 import static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;
 import static dagger.internal.codegen.TypeNames.ASYNC_FUNCTION;
@@ -119,8 +117,7 @@ ClassName nameGeneratedType(ProductionBinding binding) {
         methodBuilder("compute")
             .returns(futureTypeName)
             .addAnnotation(Override.class)
-            .addModifiers(PROTECTED)
-            .addParameter(ProducerMonitor.class, "monitor", FINAL);
+            .addModifiers(PROTECTED);
 
     ImmutableList<DependencyRequest> asyncDependencies = asyncDependencies(binding);
     for (DependencyRequest dependency : asyncDependencies) {
@@ -136,38 +133,42 @@ ClassName nameGeneratedType(ProductionBinding binding) {
               : futureAccess);
     }
     FutureTransform futureTransform = FutureTransform.create(fields, binding, asyncDependencies);
-    CodeBlock transformCodeBlock =
-        CodeBlock.of(
-            Joiner.on('\n')
-                .join(
-                    "new $1T<$2T, $3T>() {",
-                    "  $4L",
-                    "  @Override public $5T apply($2T $6L) $7L {",
-                    "    $8L",
-                    "  }",
-                    "}"),
-            ASYNC_FUNCTION,
-            futureTransform.applyArgType(),
-            providedTypeName,
-            futureTransform.hasUncheckedCast()
-                ? CodeBlock.of("$L // safe by specification", SUPPRESS_WARNINGS_UNCHECKED)
-                : "",
-            futureTypeName,
-            futureTransform.applyArgName(),
-            getThrowsClause(binding.thrownTypes()),
-            getInvocationCodeBlock(
-                generatedTypeName,
-                binding,
-                providedTypeName,
-                futureTransform.parameterCodeBlocks()));
+
     computeMethodBuilder.addStatement(
-        "return $T.transformAsync($L, $L, executorProvider.get())",
+        "return $T.transformAsync($L, this, executorProvider.get())",
         FUTURES,
-        futureTransform.futureCodeBlock(),
-        transformCodeBlock);
+        futureTransform.futureCodeBlock());
+
+    factoryBuilder.addSuperinterface(
+        ParameterizedTypeName.get(
+            ASYNC_FUNCTION, futureTransform.applyArgType(), providedTypeName));
+
+    MethodSpec.Builder applyMethodBuilder =
+        methodBuilder("apply")
+            .returns(futureTypeName)
+            .addJavadoc("@deprecated this may only be called from the internal {@link #compute()}")
+            .addAnnotation(Deprecated.class)
+            .addAnnotation(Override.class)
+            .addModifiers(PUBLIC)
+            .addParameter(futureTransform.applyArgType(), futureTransform.applyArgName())
+            .addExceptions(getThrownTypeNames(binding.thrownTypes()))
+            .addStatement(
+                "assert monitor != null : $S",
+                "apply() may only be called internally from compute(); "
+                    + "if it's called explicitly, the monitor might be null")
+            .addCode(
+                getInvocationCodeBlock(
+                    generatedTypeName,
+                    binding,
+                    providedTypeName,
+                    futureTransform.parameterCodeBlocks()));
+    if (futureTransform.hasUncheckedCast()) {
+      applyMethodBuilder.addAnnotation(SUPPRESS_WARNINGS_UNCHECKED);
+    }
 
     factoryBuilder.addMethod(constructorBuilder.build());
     factoryBuilder.addMethod(computeMethodBuilder.build());
+    factoryBuilder.addMethod(applyMethodBuilder.build());
 
     // TODO(gak): write a sensible toString
     return Optional.of(factoryBuilder);
@@ -486,14 +487,19 @@ private CodeBlock getInvocationCodeBlock(
   }
 
   /**
-   * Creates a CodeBlock for the throws clause.
+   * Converts the list of thrown types into type names.
    *
    * @param thrownTypes the list of thrown types.
    */
-  private CodeBlock getThrowsClause(List<? extends TypeMirror> thrownTypes) {
-    if (thrownTypes.isEmpty()) {
-      return CodeBlock.of("");
-    }
-    return CodeBlock.of("throws $L", makeParametersCodeBlock(toCodeBlocks(thrownTypes)));
+  private FluentIterable<? extends TypeName> getThrownTypeNames(
+      Iterable<? extends TypeMirror> thrownTypes) {
+    return FluentIterable.from(thrownTypes)
+        .transform(
+            new Function<TypeMirror, TypeName>() {
+              @Override
+              public TypeName apply(TypeMirror type) {
+                return TypeName.get(type);
+              }
+            });
   }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
index 38830b8a3..2ad2ea892 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProductionBinding.java
@@ -24,7 +24,6 @@
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
 import java.util.Set;
-
 import javax.lang.model.element.AnnotationMirror;
 import javax.lang.model.element.ExecutableElement;
 import javax.lang.model.element.TypeElement;
@@ -116,7 +115,6 @@ ProductionBinding forProducesMethod(
           Optional.of(contributedBy),
           key,
           dependencies,
-          findBindingPackage(key),
           Optional.<DeclaredType>absent(), // TODO(beder): Add nullability checking with Java 8.
           Optional.<DependencyRequest>absent(),
           wrapOptionalInEquivalence(getMapKey(producesMethod)),
@@ -148,7 +146,6 @@ ProductionBinding syntheticMapOfValuesOrProducedBinding(
           Optional.<TypeElement>absent(),
           requestForMapOfValuesOrProduced.key(),
           ImmutableSet.of(requestForMapOfProducers),
-          findBindingPackage(requestForMapOfValuesOrProduced.key()),
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           wrapOptionalInEquivalence(getMapKey(requestForMapOfProducers.requestElement())),
@@ -165,14 +162,13 @@ ProductionBinding syntheticMapOfValuesOrProducedBinding(
      * <p>Note that these could be set multibindings or map multibindings.
      */
     ProductionBinding syntheticMultibinding(
-        final DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
+        DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
       return new AutoValue_ProductionBinding(
           ContributionType.UNIQUE,
           request.requestElement(),
           Optional.<TypeElement>absent(),
           request.key(),
           dependencyRequestFactory.forMultibindingContributions(request, multibindingContributions),
-          findBindingPackage(request.key()),
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
@@ -193,7 +189,6 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
           Optional.<TypeElement>absent(),
           keyFactory.forProductionComponentMethod(componentMethod),
           ImmutableSet.<DependencyRequest>of(),
-          Optional.<String>absent(),
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
@@ -206,12 +201,11 @@ ProductionBinding forComponentMethod(ExecutableElement componentMethod) {
     ProductionBinding delegate(
         DelegateDeclaration delegateDeclaration, ProductionBinding delegateBinding) {
       return new AutoValue_ProductionBinding(
-          delegateBinding.contributionType(),
+          delegateDeclaration.contributionType(),
           delegateDeclaration.bindingElement(),
           delegateDeclaration.contributingModule(),
           delegateDeclaration.key(),
           ImmutableSet.of(delegateDeclaration.delegateRequest()),
-          findBindingPackage(delegateDeclaration.key()),
           delegateBinding.nullableType(),
           Optional.<DependencyRequest>absent(),
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
index 7a61391ce..748b3733f 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ProvisionBinding.java
@@ -125,7 +125,6 @@ ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,
           Optional.<TypeElement>absent(),
           key,
           dependencies,
-          findBindingPackage(key),
           Optional.<DeclaredType>absent(),
           membersInjectionRequest,
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
@@ -172,7 +171,6 @@ ProvisionBinding forProvidesMethod(
           Optional.of(contributedBy),
           key,
           dependencies,
-          findBindingPackage(key),
           ConfigurationAnnotations.getNullableType(providesMethod),
           Optional.<DependencyRequest>absent(),
           wrapOptionalInEquivalence(getMapKey(providesMethod)),
@@ -201,7 +199,6 @@ ProvisionBinding syntheticMapOfValuesBinding(DependencyRequest requestForMapOfVa
           Optional.<TypeElement>absent(),
           requestForMapOfValues.key(),
           ImmutableSet.of(requestForMapOfProviders),
-          findBindingPackage(requestForMapOfValues.key()),
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           wrapOptionalInEquivalence(getMapKey(requestForMapOfProviders.requestElement())),
@@ -217,14 +214,13 @@ ProvisionBinding syntheticMapOfValuesBinding(DependencyRequest requestForMapOfVa
      * <p>Note that these could be set multibindings or map multibindings.
      */
     ProvisionBinding syntheticMultibinding(
-        final DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
+        DependencyRequest request, Iterable<ContributionBinding> multibindingContributions) {
       return new AutoValue_ProvisionBinding(
           ContributionType.UNIQUE,
           request.requestElement(),
           Optional.<TypeElement>absent(),
           request.key(),
           dependencyRequestFactory.forMultibindingContributions(request, multibindingContributions),
-          findBindingPackage(request.key()),
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
@@ -241,7 +237,6 @@ ProvisionBinding forComponent(TypeElement componentDefinitionType) {
           Optional.<TypeElement>absent(),
           keyFactory.forComponent(componentDefinitionType.asType()),
           ImmutableSet.<DependencyRequest>of(),
-          Optional.<String>absent(),
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
@@ -261,7 +256,6 @@ ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {
           Optional.<TypeElement>absent(),
           keyFactory.forComponentMethod(componentMethod),
           ImmutableSet.<DependencyRequest>of(),
-          Optional.<String>absent(),
           ConfigurationAnnotations.getNullableType(componentMethod),
           Optional.<DependencyRequest>absent(),
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
@@ -282,7 +276,6 @@ ProvisionBinding forSubcomponentBuilderMethod(
           Optional.<TypeElement>absent(),
           keyFactory.forSubcomponentBuilderMethod(subcomponentBuilderMethod, declaredContainer),
           ImmutableSet.<DependencyRequest>of(),
-          Optional.<String>absent(),
           Optional.<DeclaredType>absent(),
           Optional.<DependencyRequest>absent(),
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
@@ -294,15 +287,13 @@ ProvisionBinding forSubcomponentBuilderMethod(
     ProvisionBinding delegate(
         DelegateDeclaration delegateDeclaration, ProvisionBinding delegate) {
       return new AutoValue_ProvisionBinding(
-          delegate.contributionType(),
+          delegateDeclaration.contributionType(),
           delegateDeclaration.bindingElement(),
           delegateDeclaration.contributingModule(),
           delegateDeclaration.key(),
           ImmutableSet.of(delegateDeclaration.delegateRequest()),
-          findBindingPackage(delegateDeclaration.key()),
           delegate.nullableType(),
           Optional.<DependencyRequest>absent(),
-          // TODO(ronshapiro): for @Binds @IntoMap, this should be delegateDeclaration.mapKey()
           Optional.<Equivalence.Wrapper<AnnotationMirror>>absent(),
           Kind.SYNTHETIC_DELEGATE_BINDING,
           Optional.<ProvisionBinding>absent(),
diff --git a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
index 0503ddcb5..49d465cb3 100644
--- a/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
+++ b/compiler/src/main/java/dagger/internal/codegen/ResolvedBindings.java
@@ -101,6 +101,16 @@ public Key key() {
     }
   }
 
+  /**
+   * Returns the single binding.
+   *
+   * @throws IllegalStateException if there is not exactly one element in {@link #bindings()},
+   *     which will never happen for contributions in valid graphs
+   */
+  Binding binding() {
+    return getOnlyElement(bindings());
+  }
+
   /**
    * All bindings for {@link #bindingKey()}, together with the component in which they were
    * resolved.
@@ -247,14 +257,6 @@ boolean isMultibindingContribution() {
         && contributionBinding().contributionType().isMultibinding();
   }
 
-  /**
-   * {@code true} if this is a {@linkplain ContributionBinding#isSyntheticBinding() synthetic}
-   * contribution.
-   */
-  boolean isSyntheticContribution() {
-    return contributionBindings().size() == 1 && contributionBinding().isSyntheticBinding();
-  }
-
   /**
    * Returns the single contribution binding.
    *
diff --git a/compiler/src/main/java/dagger/internal/codegen/Scope.java b/compiler/src/main/java/dagger/internal/codegen/Scope.java
index d8590efd8..0c136b3d7 100644
--- a/compiler/src/main/java/dagger/internal/codegen/Scope.java
+++ b/compiler/src/main/java/dagger/internal/codegen/Scope.java
@@ -105,9 +105,8 @@ private static Scope scope(Elements elements, Class<? extends Annotation> scopeA
    * <p>It's readable source because it has had common package prefixes removed, e.g.
    * {@code @javax.inject.Singleton} is returned as {@code @Singleton}.
    *
-   * <p>Make sure that the scope is actually {@link #isPresent() present} before calling as it will
-   * throw an {@link IllegalStateException} otherwise. This does not return any annotation values
-   * as according to {@link javax.inject.Scope} scope annotations are not supposed to use them.
+   * This does not return any annotation values as according to {@link javax.inject.Scope} scope
+   * annotations are not supposed to use them.
    */
   public String getReadableSource() {
     return stripCommonTypePrefixes("@" + getQualifiedName());
@@ -115,10 +114,6 @@ public String getReadableSource() {
 
   /**
    * Returns the fully qualified name of the annotation type.
-   *
-   * <p>Make sure that the scope is actually {@link #isPresent() present} before calling as it will
-   * throw an {@link IllegalStateException} otherwise. This does not return any annotation values
-   * as according to {@link javax.inject.Scope} scope annotations are not supposed to use them.
    */
   public String getQualifiedName() {
     Preconditions.checkState(annotationMirror != null,
diff --git a/compiler/src/main/java/dagger/internal/codegen/SetType.java b/compiler/src/main/java/dagger/internal/codegen/SetType.java
index 23e95c7f7..9b55eed87 100644
--- a/compiler/src/main/java/dagger/internal/codegen/SetType.java
+++ b/compiler/src/main/java/dagger/internal/codegen/SetType.java
@@ -87,6 +87,13 @@ static boolean isSet(TypeMirror type) {
     return MoreTypes.isType(type) && MoreTypes.isTypeOf(Set.class, type);
   }
 
+  /**
+   * {@code true} if {@code key.type()} is a {@link Set} type.
+   */
+  static boolean isSet(Key key) {
+    return isSet(key.type());
+  }
+
   /**
    * Returns a {@link SetType} for {@code type}.
    *
@@ -96,4 +103,13 @@ static SetType from(TypeMirror type) {
     checkArgument(isSet(type), "%s must be a Set", type);
     return new AutoValue_SetType(MoreTypes.equivalence().wrap(MoreTypes.asDeclared(type)));
   }
+
+  /**
+   * Returns a {@link SetType} for {@code key}'s {@link Key#type() type}.
+   *
+   * @throws IllegalArgumentException if {@code key.type()} is not a {@link Set} type
+   */
+  static SetType from(Key key) {
+    return from (key.type());
+  }
 }
diff --git a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
index f16e38364..1b7903c22 100644
--- a/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
+++ b/compiler/src/main/java/dagger/internal/codegen/TypeNames.java
@@ -15,7 +15,6 @@
  */
 package dagger.internal.codegen;
 
-import com.google.common.collect.ImmutableSet;
 import com.google.common.util.concurrent.AsyncFunction;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
@@ -46,7 +45,6 @@
 import dagger.producers.monitoring.ProductionComponentMonitor;
 import java.util.List;
 import java.util.Set;
-import java.util.concurrent.Executor;
 import javax.inject.Provider;
 
 /**
@@ -58,11 +56,9 @@
   static final ClassName ASYNC_FUNCTION = ClassName.get(AsyncFunction.class);
   static final ClassName DELEGATE_FACTORY = ClassName.get(DelegateFactory.class);
   static final ClassName DOUBLE_CHECK = ClassName.get(DoubleCheck.class);
-  static final ClassName EXECUTOR = ClassName.get(Executor.class);
   static final ClassName FACTORY = ClassName.get(Factory.class);
   static final ClassName FUTURES = ClassName.get(Futures.class);
   static final ClassName ILLEGAL_STATE_EXCEPTION = ClassName.get(IllegalStateException.class);
-  static final ClassName IMMUTABLE_SET = ClassName.get(ImmutableSet.class);
   static final ClassName INSTANCE_FACTORY = ClassName.get(InstanceFactory.class);
   static final ClassName LIST = ClassName.get(List.class);
   static final ClassName LISTENABLE_FUTURE = ClassName.get(ListenableFuture.class);
diff --git a/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java b/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java
index 05071f493..57c702b7b 100644
--- a/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/BindsMethodValidatorTest.java
@@ -99,6 +99,31 @@ public void noParameters() {
     assertThatMethod("@Binds abstract Object noParameters();").hasError("one parameter");
   }
 
+  @Test
+  public void intoMap() {
+    assertThatMethod("@Binds @IntoMap @IntKey(1) abstract Object bindObject(String string);")
+        .hasError("@Binds @IntoMap is not yet supported");
+  }
+
+  @Test
+  public void setElementsNotAssignable() {
+    assertThatMethod(
+            "@Binds @ElementsIntoSet abstract Set<String> bindSetOfIntegers(Set<Integer> ints);")
+        .hasError("assignable");
+  }
+
+  @Test
+  public void setElements_primitiveArgument() {
+    assertThatMethod("@Binds @ElementsIntoSet abstract Set<Number> bindInt(int integer);")
+        .hasError("assignable");
+  }
+
+  @Test
+  public void elementsIntoSet_withRawSets() {
+    assertThatMethod("@Binds @ElementsIntoSet abstract Set bindRawSet(HashSet hashSet);")
+        .hasError("cannot return a raw Set");
+  }
+
   private DaggerModuleMethodSubject assertThatMethod(String method) {
     return assertThatModuleMethod(method).withDeclaration(moduleDeclaration);
   }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
index f535d430e..9dfe0a6c6 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ComponentProcessorTest.java
@@ -1137,7 +1137,7 @@ public void subcomponentOmitsInheritedBindings() {
             "        SetModule_StringFactory.create(builder.setModule);",
             "    this.setOfStringProvider = ",
             "        SetFactory.<String>builder(1, 1)",
-            "            .addSetProvider(emptySetProvider)",
+            "            .addCollectionProvider(emptySetProvider)",
             "            .addProvider(stringProvider)",
             "            .build();",
             "  }",
diff --git a/compiler/src/test/java/dagger/internal/codegen/MultibindingTest.java b/compiler/src/test/java/dagger/internal/codegen/MultibindingTest.java
index 5b2728e88..90da7f518 100644
--- a/compiler/src/test/java/dagger/internal/codegen/MultibindingTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/MultibindingTest.java
@@ -142,17 +142,17 @@ public void appliedOnInvalidMethods_failsToCompile() {
         .processedWith(new ComponentProcessor())
         .failsToCompile()
         .withErrorContaining(
-            "Multibinding annotations may only be on @Provides or @Produces methods")
+            "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods")
         .in(component)
         .onLine(12)
         .and()
         .withErrorContaining(
-            "Multibinding annotations may only be on @Provides or @Produces methods")
+            "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods")
         .in(component)
         .onLine(13)
         .and()
         .withErrorContaining(
-            "Multibinding annotations may only be on @Provides or @Produces methods")
+            "Multibinding annotations may only be on @Provides, @Produces, or @Binds methods")
         .in(component)
         .onLine(14);
   }
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
index 59e50536a..4b9f17869 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProducerModuleFactoryGeneratorTest.java
@@ -358,7 +358,6 @@ public void publicModuleNonPublicIncludes() {
             "import com.google.common.util.concurrent.Futures;",
             "import com.google.common.util.concurrent.ListenableFuture;",
             "import dagger.producers.internal.AbstractProducer;",
-            "import dagger.producers.monitoring.ProducerMonitor;",
             "import dagger.producers.monitoring.ProducerToken;",
             "import dagger.producers.monitoring.ProductionComponentMonitor;",
             "import java.util.concurrent.Executor;",
@@ -366,7 +365,8 @@ public void publicModuleNonPublicIncludes() {
             "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
-            "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
+            "public final class TestModule_ProduceStringFactory",
+            "    extends AbstractProducer<String> implements AsyncFunction<Void, String> {",
             "  private final TestModule module;",
             "  private final Provider<Executor> executorProvider;",
             "  private final Provider<ProductionComponentMonitor> monitorProvider;",
@@ -386,20 +386,22 @@ public void publicModuleNonPublicIncludes() {
             "    this.monitorProvider = monitorProvider;",
             "  }",
             "",
-            "  @Override protected ListenableFuture<String> compute(",
-            "      final ProducerMonitor monitor) {",
+            "  @Override protected ListenableFuture<String> compute() {",
             "    return Futures.transformAsync(",
-            "      Futures.<Void>immediateFuture(null),",
-            "      new AsyncFunction<Void, String>() {",
-            "        @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
-            "          monitor.methodStarting();",
-            "          try {",
-            "            return TestModule_ProduceStringFactory.this.module.produceString();",
-            "          } finally {",
-            "            monitor.methodFinished();",
-            "          }",
-            "        }",
-            "      }, executorProvider.get());",
+            "        Futures.<Void>immediateFuture(null), this, executorProvider.get());",
+            "  }",
+            "",
+            "  @Deprecated",
+            "  @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
+            "    assert monitor != null :",
+            "        \"apply() may only be called internally from compute(); \"",
+            "        + \"if it's called explicitly, the monitor might be null\";",
+            "    monitor.methodStarting();",
+            "    try {",
+            "      return TestModule_ProduceStringFactory.this.module.produceString();",
+            "    } finally {",
+            "      monitor.methodFinished();",
+            "    }",
             "  }",
             "}");
     assertAbout(javaSource())
@@ -437,7 +439,6 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
             "import com.google.common.util.concurrent.Futures;",
             "import com.google.common.util.concurrent.ListenableFuture;",
             "import dagger.producers.internal.AbstractProducer;",
-            "import dagger.producers.monitoring.ProducerMonitor;",
             "import dagger.producers.monitoring.ProducerToken;",
             "import dagger.producers.monitoring.ProductionComponentMonitor;",
             "import java.util.concurrent.Executor;",
@@ -445,7 +446,8 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
             "import javax.inject.Provider;",
             "",
             GENERATED_ANNOTATION,
-            "public final class TestModule_ProduceStringFactory extends AbstractProducer<String> {",
+            "public final class TestModule_ProduceStringFactory",
+            "    extends AbstractProducer<String> implements AsyncFunction<Void, String> {",
             "  private final TestModule module;",
             "  private final Provider<Executor> executorProvider;",
             "  private final Provider<ProductionComponentMonitor> monitorProvider;",
@@ -465,20 +467,22 @@ public void singleProducesMethodNoArgsFutureWithProducerName() {
             "    this.monitorProvider = monitorProvider;",
             "  }",
             "",
-            "  @Override protected ListenableFuture<String> compute(",
-            "      final ProducerMonitor monitor) {",
+            "  @Override protected ListenableFuture<String> compute() {",
             "    return Futures.transformAsync(",
-            "      Futures.<Void>immediateFuture(null),",
-            "      new AsyncFunction<Void, String>() {",
-            "        @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
-            "          monitor.methodStarting();",
-            "          try {",
-            "            return TestModule_ProduceStringFactory.this.module.produceString();",
-            "          } finally {",
-            "            monitor.methodFinished();",
-            "          }",
-            "        }",
-            "      }, executorProvider.get());",
+            "      Futures.<Void>immediateFuture(null), this, executorProvider.get());",
+            "  }",
+            "",
+            "  @Deprecated",
+            "  @Override public ListenableFuture<String> apply(Void ignoredVoidArg) {",
+            "    assert monitor != null :",
+            "        \"apply() may only be called internally from compute(); \"",
+            "        + \"if it's called explicitly, the monitor might be null\";",
+            "    monitor.methodStarting();",
+            "    try {",
+            "      return TestModule_ProduceStringFactory.this.module.produceString();",
+            "    } finally {",
+            "      monitor.methodFinished();",
+            "    }",
             "  }",
             "}");
     assertAbout(javaSource())
diff --git a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
index 1b62f4875..2885c6ebc 100644
--- a/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
+++ b/compiler/src/test/java/dagger/internal/codegen/ProductionComponentProcessorTest.java
@@ -252,7 +252,7 @@ public void simpleComponent() {
             "        DoubleCheck.provider(",
             "            TestClass_SimpleComponent_MonitoringModule_MonitorFactory.create(",
             "                simpleComponentProvider,",
-            "                SetFactory.<ProductionComponentMonitor.Factory>create());",
+            "                SetFactory.<ProductionComponentMonitor.Factory>empty());",
             "    this.bProvider = TestClass_BModule_BFactory.create(",
             "        builder.bModule, TestClass_C_Factory.create());",
             "    this.bProducer = Producers.producerFromProvider(bProvider);",
diff --git a/core/src/main/java/dagger/MapKey.java b/core/src/main/java/dagger/MapKey.java
index a169e0731..e41829e1e 100644
--- a/core/src/main/java/dagger/MapKey.java
+++ b/core/src/main/java/dagger/MapKey.java
@@ -64,7 +64,7 @@
  *
  * <p>If {@code unwrapValue} is true, the annotation's single member can be any type except an
  * array.
- *
+ * 
  * <p>See {@link dagger.multibindings} for standard unwrapped map key annotations for keys that are
  * boxed primitives, strings, or classes.
  *
@@ -101,6 +101,8 @@
  * <p>(Note that there must be a class {@code MyMapKeyImpl} that implements {@code MyMapKey} in
  * order to call {@link Map#get(Object)} on the provided map.)
  *
+ * @see <a href="http://google.github.io/dagger/multibindings#map-multibindings">Map
+ *      multibinding</a>
  */
 @Documented
 @Target(ANNOTATION_TYPE)
diff --git a/core/src/main/java/dagger/Multibindings.java b/core/src/main/java/dagger/Multibindings.java
index d02d4177b..b83324df5 100644
--- a/core/src/main/java/dagger/Multibindings.java
+++ b/core/src/main/java/dagger/Multibindings.java
@@ -21,6 +21,42 @@
 
 import static java.lang.annotation.ElementType.TYPE;
 
+/**
+ * Annotates interfaces that declare multibindings.
+ *
+ * <p>You can declare that a multibound set or map is bound by nesting a
+ * {@code @Multibindings}-annotated interface within a module, with methods that return the sets or
+ * maps you want to declare.
+ *
+ * <p>You do not have to use {@code @Multibindings} for sets or maps that have at least one
+ * contribution, but you do have to declare them if they may be empty.
+ *
+ * <pre><code>
+ * {@literal @Module}
+ * class MyModule {
+ *   {@literal @Multibindings}
+ *   interface MyMultibindings {
+ *     {@literal Set<Foo>} aSet();
+ *     {@literal @MyQualifier Set<Foo>} aQualifiedSet();
+ *     {@literal Map<String, Foo>} aMap();
+ *     {@literal @MyQualifier Map<String, Foo>} aQualifiedMap();
+ *   }
+ *
+ *   {@literal @Provides}
+ *   static Object usesMultibindings(
+ *       {@literal Set<Foo>} set, {@literal @MyQualifier Map<String, Foo>} map) {
+ *     return 
+ *   }
+ * }
+ * </code></pre>
+ *
+ * <p>All methods on the interface and any supertypes (except for methods on {@link Object}) are
+ * used to declare multibindings. The names of the interface and its methods are ignored. A given
+ * set or map multibinding can be declared any number of times without error. Dagger never
+ * implements the interface or calls any of its methods.
+ *
+ * @see <a href="http://google.github.io/dagger/multibindings">Multibindings</a>
+ */
 @Documented
 @Target(TYPE)
 @Beta
diff --git a/core/src/main/java/dagger/Provides.java b/core/src/main/java/dagger/Provides.java
index 264a8b016..7be82c012 100644
--- a/core/src/main/java/dagger/Provides.java
+++ b/core/src/main/java/dagger/Provides.java
@@ -60,6 +60,8 @@
      * method as parameters. The {@code Set<T>} produced from the accumulation of values will be
      * immutable.
      *
+     * @see <a href="http://google.github.io/dagger/multibindings#set-multibindings">Set
+     *      multibinding</a>
      */
     SET,
 
@@ -68,6 +70,8 @@
      * contributed to the set. An example use is to provide a default empty set binding, which is
      * otherwise not possible using {@link #SET}.
      *
+     * @see <a href="http://google.github.io/dagger/multibindings#set-multibindings">Set
+     *      multibinding</a>
      */
     SET_VALUES,
 
@@ -77,6 +81,8 @@
      * is contributed to the map as a key/value pair. The {@code Map<K, Provider<V>>} produced from
      * the accumulation of values will be immutable.
      *
+     * @see <a href="http://google.github.io/dagger/multibindings#map-multibindings">Map
+     *      multibinding</a>
      */
     @Beta
     MAP;
diff --git a/core/src/main/java/dagger/Reusable.java b/core/src/main/java/dagger/Reusable.java
index d5e7d89c2..b7b61d8d1 100644
--- a/core/src/main/java/dagger/Reusable.java
+++ b/core/src/main/java/dagger/Reusable.java
@@ -28,8 +28,7 @@
  * <p>{@code @Reusable} is useful when you want to limit the number of provisions of a type, but
  * there is no specific lifetime over which there must be only one instance.
  *
- * @see <a href="http://google.github.io/dagger/users-guide.html#reusable-scope">Reusable Scope
- * </a>
+ * @see <a href="http://google.github.io/dagger/users-guide.html#reusable-scope">Reusable Scope</a>
  */
 @Documented
 @Beta
diff --git a/core/src/main/java/dagger/internal/DoubleCheck.java b/core/src/main/java/dagger/internal/DoubleCheck.java
index 73d4ee6a3..ef1708fa9 100644
--- a/core/src/main/java/dagger/internal/DoubleCheck.java
+++ b/core/src/main/java/dagger/internal/DoubleCheck.java
@@ -43,7 +43,16 @@ public T get() {
       synchronized (this) {
         result = instance;
         if (result == UNINITIALIZED) {
-          instance = result = provider.get();
+          result = provider.get();
+          /* Get the current instance and test to see if the call to provider.get() has resulted
+           * in a recursive call.  If it returns the same instance, we'll allow it, but if the
+           * instances differ, throw. */
+          Object currentInstance = instance;
+          if (currentInstance != UNINITIALIZED && currentInstance != result) {
+            throw new IllegalStateException("Scoped provider was invoked recursively returning "
+                + "different results: " + currentInstance + " & " + result);
+          }
+          instance = result;
           /* Null out the reference to the provider. We are never going to need it again, so we
            * can make it eligible for GC. */
           provider = null;
diff --git a/core/src/main/java/dagger/internal/SetFactory.java b/core/src/main/java/dagger/internal/SetFactory.java
index d4e89f9a8..dd0d92711 100644
--- a/core/src/main/java/dagger/internal/SetFactory.java
+++ b/core/src/main/java/dagger/internal/SetFactory.java
@@ -16,6 +16,7 @@
 package dagger.internal;
 
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
 import java.util.Set;
 import javax.inject.Provider;
@@ -45,60 +46,66 @@
       };
 
   @SuppressWarnings({"unchecked", "rawtypes"}) // safe covariant cast
-  public static <T> Factory<Set<T>> create() {
+  public static <T> Factory<Set<T>> empty() {
     return (Factory) EMPTY_FACTORY;
   }
 
   /**
    * Constructs a new {@link Builder} for a {@link SetFactory} with {@code individualProviderSize}
-   * individual {@code Provider<T>} and {@code setProviderSize} {@code Provider<Set<T>>} instances.
+   * individual {@code Provider<T>} and {@code collectionProviderSize} {@code
+   * Provider<Collection<T>>} instances.
    */
-  public static <T> Builder<T> builder(int individualProviderSize, int setProviderSize) {
-    return new Builder<T>(individualProviderSize, setProviderSize);
+  public static <T> Builder<T> builder(int individualProviderSize, int collectionProviderSize) {
+    return new Builder<T>(individualProviderSize, collectionProviderSize);
   }
 
   /**
-   * A builder to accumulate {@code Provider<T>} and {@code Provider<Set<T>>} instances. These are
-   * only intended to be single-use and from within generated code. Do <em>NOT</em> add providers
-   * after calling {@link #build()}.
+   * A builder to accumulate {@code Provider<T>} and {@code Provider<Collection<T>>} instances.
+   * These are only intended to be single-use and from within generated code. Do <em>NOT</em> add
+   * providers after calling {@link #build()}.
    */
   public static final class Builder<T> {
     private final List<Provider<T>> individualProviders;
-    private final List<Provider<Set<T>>> setProviders;
+    private final List<Provider<Collection<T>>> collectionProviders;
 
-    private Builder(int individualProviderSize, int setProviderSize) {
+    private Builder(int individualProviderSize, int collectionProviderSize) {
       individualProviders = presizedList(individualProviderSize);
-      setProviders = presizedList(setProviderSize);
+      collectionProviders = presizedList(collectionProviderSize);
     }
 
-    public Builder<T> addProvider(Provider<T> individualProvider) {
+    @SuppressWarnings("unchecked")
+    public Builder<T> addProvider(Provider<? extends T> individualProvider) {
       assert individualProvider != null : "Codegen error? Null provider";
-      individualProviders.add(individualProvider);
+      // TODO(ronshapiro): Store a List<? extends Provider<T>> and avoid the cast to Provider<T>
+      individualProviders.add((Provider<T>) individualProvider);
       return this;
     }
 
-    public Builder<T> addSetProvider(Provider<Set<T>> multipleProvider) {
-      assert multipleProvider != null : "Codegen error? Null provider";
-      setProviders.add(multipleProvider);
+    @SuppressWarnings("unchecked")
+    public Builder<T> addCollectionProvider(
+        Provider<? extends Collection<? extends T>> collectionProvider) {
+      assert collectionProvider != null : "Codegen error? Null provider";
+      collectionProviders.add((Provider<Collection<T>>) collectionProvider);
       return this;
     }
 
     public SetFactory<T> build() {
       assert !hasDuplicates(individualProviders)
           : "Codegen error?  Duplicates in the provider list";
-      assert !hasDuplicates(setProviders)
+      assert !hasDuplicates(collectionProviders)
           : "Codegen error?  Duplicates in the provider list";
 
-      return new SetFactory<T>(individualProviders, setProviders);
+      return new SetFactory<T>(individualProviders, collectionProviders);
     }
   }
 
   private final List<Provider<T>> individualProviders;
-  private final List<Provider<Set<T>>> setProviders;
+  private final List<Provider<Collection<T>>> collectionProviders;
 
-  private SetFactory(List<Provider<T>> individualProviders, List<Provider<Set<T>>> setProviders) {
+  private SetFactory(
+      List<Provider<T>> individualProviders, List<Provider<Collection<T>>> collectionProviders) {
     this.individualProviders = individualProviders;
-    this.setProviders = setProviders;
+    this.collectionProviders = collectionProviders;
   }
 
   /**
@@ -115,19 +122,20 @@ private SetFactory(List<Provider<T>> individualProviders, List<Provider<Set<T>>>
     // these loops were changed to use c-style for.  Versus enhanced for-each loops, C-style for is
     // faster for ArrayLists, at least through Java 8.
 
-    List<Set<T>> providedSets = new ArrayList<Set<T>>(setProviders.size());
-    for (int i = 0, c = setProviders.size(); i < c; i++) {
-      Set<T> providedSet = setProviders.get(i).get();
-      size += providedSet.size();
-      providedSets.add(providedSet);
+    List<Collection<T>> providedCollections =
+        new ArrayList<Collection<T>>(collectionProviders.size());
+    for (int i = 0, c = collectionProviders.size(); i < c; i++) {
+      Collection<T> providedCollection = collectionProviders.get(i).get();
+      size += providedCollection.size();
+      providedCollections.add(providedCollection);
     }
 
     Set<T> providedValues = newHashSetWithExpectedSize(size);
     for (int i = 0, c = individualProviders.size(); i < c; i++) {
       providedValues.add(checkNotNull(individualProviders.get(i).get()));
     }
-    for (int i = 0, c = providedSets.size(); i < c; i++) {
-      for (T element : providedSets.get(i)) {
+    for (int i = 0, c = providedCollections.size(); i < c; i++) {
+      for (T element : providedCollections.get(i)) {
         providedValues.add(checkNotNull(element));
       }
     }
diff --git a/core/src/main/java/dagger/multibindings/ElementsIntoSet.java b/core/src/main/java/dagger/multibindings/ElementsIntoSet.java
index 5d3e7dc8c..7e157399f 100644
--- a/core/src/main/java/dagger/multibindings/ElementsIntoSet.java
+++ b/core/src/main/java/dagger/multibindings/ElementsIntoSet.java
@@ -22,6 +22,14 @@
 import static java.lang.annotation.ElementType.METHOD;
 import static java.lang.annotation.RetentionPolicy.RUNTIME;
 
+/**
+ * The method's return type is {@code Set<T>} and all values are contributed to the set. The {@code
+ * Set<T>} produced from the accumulation of values will be immutable. An example use is to provide
+ * a default empty set binding, which is otherwise not possible using {@link IntoSet}.
+ *
+ * @see <a href="http://google.github.io/dagger/multibindings#set-multibindings">Set
+ *      multibinding</a>
+ */
 @Documented
 @Target(METHOD)
 @Retention(RUNTIME)
diff --git a/core/src/main/java/dagger/multibindings/IntoMap.java b/core/src/main/java/dagger/multibindings/IntoMap.java
index 4dc3427a3..a1e786eca 100644
--- a/core/src/main/java/dagger/multibindings/IntoMap.java
+++ b/core/src/main/java/dagger/multibindings/IntoMap.java
@@ -29,7 +29,8 @@
  * is contributed to the map as a key/value pair. The {@code Map<K, Provider<V>>} produced from
  * the accumulation of values will be immutable.
  *
- * @see <a href=google.github.io/dagger/multibindings#map-multibindings>Map multibinding</a>
+ * @see <a href="http://google.github.io/dagger/multibindings#map-multibindings">Map
+ *      multibinding</a>
  */
 @Documented
 @Target(METHOD)
diff --git a/core/src/main/java/dagger/multibindings/IntoSet.java b/core/src/main/java/dagger/multibindings/IntoSet.java
index c98a957a9..a7e3a7cdf 100644
--- a/core/src/main/java/dagger/multibindings/IntoSet.java
+++ b/core/src/main/java/dagger/multibindings/IntoSet.java
@@ -28,7 +28,8 @@
  * method as parameters. The {@code Set<T>} produced from the accumulation of values will be
  * immutable.
  *
- * @see <a href=google.github.io/dagger/multibindings#set-multibindings>Set multibinding</a>
+ * @see <a href="http://google.github.io/dagger/multibindings#set-multibindings">Set
+ *      multibinding</a>
  */
 @Documented
 @Target(METHOD)
diff --git a/core/src/main/java/dagger/multibindings/Multibinds.java b/core/src/main/java/dagger/multibindings/Multibinds.java
index d41a4dc92..48dd94257 100644
--- a/core/src/main/java/dagger/multibindings/Multibinds.java
+++ b/core/src/main/java/dagger/multibindings/Multibinds.java
@@ -21,6 +21,33 @@
 
 import static java.lang.annotation.ElementType.METHOD;
 
+/**
+ * Annotates abstract module methods that declare multibindings.
+ *
+ * <p>You can declare that a multibound set or map is bound by annotating an abstract module method
+ * that returns the set or map you want to declare with {@code @Multibinds}.
+ *
+ * <p>You do not have to use {@code @Multibinds} for sets or maps that have at least one
+ * contribution, but you do have to declare them if they may be empty.
+ *
+ * <pre><code>
+ *   {@literal @Module} abstract class MyModule {
+ *     {@literal @Multibinds Set<Foo> aSet();}
+ *     {@literal @Multibinds @MyQualifier Set<Foo> aQualifiedSet();}
+ *     {@literal @Multibinds Map<String, Foo> aMap();}
+ *     {@literal @Multibinds @MyQualifier Map<String, Foo> aQualifiedMap();}
+ *
+ *     {@literal @Provides}
+ *     {@literal static Object usesMultibindings(Set<Foo> set, @MyQualifier Map<String, Foo> map}) {
+ *       return 
+ *     }
+ *   }</code></pre>
+ *
+ * <p>A given set or map multibinding can be declared any number of times without error. Dagger
+ * never implements calls any {@code @Multibinds} methods.
+ *
+ * @see <a href="http://google.github.io/dagger/multibindings">Multibindings</a>
+ */
 @Documented
 @Target(METHOD)
 @Beta
diff --git a/core/src/main/java/dagger/multibindings/package-info.java b/core/src/main/java/dagger/multibindings/package-info.java
index 26fe0830c..e62974ddb 100644
--- a/core/src/main/java/dagger/multibindings/package-info.java
+++ b/core/src/main/java/dagger/multibindings/package-info.java
@@ -14,4 +14,11 @@
  * limitations under the License.
  */
 
+/**
+ * This package contains the API by which Dagger allows you to bind several objects into a
+ * collection that can be injected without depending directly on each of the individual bindings.
+ *
+ * @see <a href="http://google.github.io/dagger/multibindings">Multibindings in the Dagger
+ *      User's Guide</a>
+ */
 package dagger.multibindings;
diff --git a/core/src/test/java/dagger/internal/DoubleCheckTest.java b/core/src/test/java/dagger/internal/DoubleCheckTest.java
index 280dccf25..077c50807 100644
--- a/core/src/test/java/dagger/internal/DoubleCheckTest.java
+++ b/core/src/test/java/dagger/internal/DoubleCheckTest.java
@@ -27,6 +27,7 @@
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicReference;
 import javax.inject.Provider;
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -126,4 +127,58 @@ public Object get() {
       return new Object();
     }
   }
+
+  @Test public void reentranceWithoutCondition_throwsStackOverflow() {
+    final AtomicReference<Provider<Object>> doubleCheckReference =
+        new AtomicReference<Provider<Object>>();
+    Provider<Object> doubleCheck = DoubleCheck.provider(new Provider<Object>() {
+      @Override
+      public Object get() {
+        return doubleCheckReference.get().get();
+      }
+    });
+    doubleCheckReference.set(doubleCheck);
+    try {
+      doubleCheck.get();
+      fail();
+    } catch (StackOverflowError expected) {}
+  }
+
+  @Test public void reentranceReturningSameInstance() {
+    final AtomicReference<Provider<Object>> doubleCheckReference =
+        new AtomicReference<Provider<Object>>();
+    final AtomicInteger invocationCount = new AtomicInteger();
+    final Object object = new Object();
+    Provider<Object> doubleCheck = DoubleCheck.provider(new Provider<Object>() {
+     @Override
+      public Object get() {
+         if (invocationCount.incrementAndGet() == 1) {
+          doubleCheckReference.get().get();
+        }
+        return object;
+      }
+    });
+    doubleCheckReference.set(doubleCheck);
+    assertThat(doubleCheck.get()).isSameAs(object);
+  }
+
+  @Test public void reentranceReturningDifferentInstances_throwsIllegalStateException() {
+    final AtomicReference<Provider<Object>> doubleCheckReference =
+        new AtomicReference<Provider<Object>>();
+    final AtomicInteger invocationCount = new AtomicInteger();
+    Provider<Object> doubleCheck = DoubleCheck.provider(new Provider<Object>() {
+     @Override
+      public Object get() {
+        if (invocationCount.incrementAndGet() == 1) {
+          doubleCheckReference.get().get();
+        }
+        return new Object();
+      }
+    });
+    doubleCheckReference.set(doubleCheck);
+    try {
+      doubleCheck.get();
+      fail();
+    } catch (IllegalStateException expected) {}
+  }
 }
diff --git a/core/src/test/java/dagger/internal/SetFactoryTest.java b/core/src/test/java/dagger/internal/SetFactoryTest.java
index b6d5d78ab..af7cb99bf 100644
--- a/core/src/test/java/dagger/internal/SetFactoryTest.java
+++ b/core/src/test/java/dagger/internal/SetFactoryTest.java
@@ -37,7 +37,7 @@
   @Test
   public void providerReturnsNull() {
     Factory<Set<Integer>> factory =
-        SetFactory.<Integer>builder(0, 1).addSetProvider(providerOf((Set<Integer>) null)).build();
+        SetFactory.<Integer>builder(0, 1).addCollectionProvider(providerOf((Set<Integer>) null)).build();
     thrown.expect(NullPointerException.class);
     factory.get();
   }
@@ -54,7 +54,7 @@ public void providerReturnsNullSet() {
   public void providerReturnsSetWithNullElement() {
     Set<Integer> set = new LinkedHashSet<Integer>(Arrays.asList(1, null, 3));
     Factory<Set<Integer>> factory =
-        SetFactory.<Integer>builder(0, 1).addSetProvider(providerOf(set)).build();
+        SetFactory.<Integer>builder(0, 1).addCollectionProvider(providerOf(set)).build();
     thrown.expect(NullPointerException.class);
     factory.get();
   }
@@ -65,8 +65,8 @@ public void invokesProvidersEveryTime() {
         SetFactory.<Integer>builder(2, 2)
             .addProvider(incrementingIntegerProvider(0))
             .addProvider(incrementingIntegerProvider(10))
-            .addSetProvider(incrementingIntegerSetProvider(20))
-            .addSetProvider(incrementingIntegerSetProvider(30))
+            .addCollectionProvider(incrementingIntegerSetProvider(20))
+            .addCollectionProvider(incrementingIntegerSetProvider(30))
             .build();
     assertThat(factory.get()).containsExactly(0, 10, 20, 21, 30, 31);
     assertThat(factory.get()).containsExactly(1, 11, 22, 23, 32, 33);
diff --git a/pom.xml b/pom.xml
index 73f2ff670..a3df564cd 100644
--- a/pom.xml
+++ b/pom.xml
@@ -203,7 +203,9 @@
       <plugin>
         <artifactId>maven-javadoc-plugin</artifactId>
         <configuration>
+          <windowtitle>Dagger Dependency Injection ${project.version} API</windowtitle>
           <doctitle>Dagger Dependency Injection ${project.version} API</doctitle>
+          <excludePackageNames>*.internal</excludePackageNames>
         </configuration>
       </plugin>
 
diff --git a/producers/src/main/java/dagger/producers/internal/AbstractProducer.java b/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
index 8c4fe0b40..85a973370 100644
--- a/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/AbstractProducer.java
@@ -37,6 +37,7 @@
   private final Provider<ProductionComponentMonitor> monitorProvider;
   @Nullable private final ProducerToken token;
   private volatile ListenableFuture<T> instance = null;
+  protected volatile ProducerMonitor monitor = null;
 
   protected AbstractProducer() {
     this(Monitors.noOpProductionComponentMonitorProvider(), null);
@@ -48,8 +49,11 @@ protected AbstractProducer(
     this.token = token;
   }
 
-  /** Computes this producer's future, which is then cached in {@link #get}. */
-  protected abstract ListenableFuture<T> compute(ProducerMonitor monitor);
+  /**
+   * Computes this producer's future, which is then cached in {@link #get}. The {@link #monitor}
+   * will be non-null from the point of this call forward.
+   */
+  protected abstract ListenableFuture<T> compute();
 
   @Override
   public final ListenableFuture<T> get() {
@@ -59,9 +63,9 @@ protected AbstractProducer(
       synchronized (this) {
         result = instance;
         if (result == null) {
-          ProducerMonitor monitor = monitorProvider.get().producerMonitorFor(token);
+          monitor = monitorProvider.get().producerMonitorFor(token);
           monitor.requested();
-          instance = result = compute(monitor);
+          instance = result = compute();
           if (result == null) {
             throw new NullPointerException("compute returned null");
           }
diff --git a/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java b/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
index a0ba0c51a..f55194fec 100644
--- a/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/MapOfProducedProducer.java
@@ -25,7 +25,6 @@
 import dagger.internal.Beta;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
-import dagger.producers.monitoring.ProducerMonitor;
 import java.util.List;
 import java.util.Map;
 
@@ -62,7 +61,7 @@ private MapOfProducedProducer(Producer<Map<K, Producer<V>>> mapProducerProducer)
   }
 
   @Override
-  public ListenableFuture<Map<K, Produced<V>>> compute(ProducerMonitor unusedMonitor) {
+  public ListenableFuture<Map<K, Produced<V>>> compute() {
     return Futures.transformAsync(
         mapProducerProducer.get(),
         new AsyncFunction<Map<K, Producer<V>>, Map<K, Produced<V>>>() {
diff --git a/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java b/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java
index 013266f2d..0424a68d5 100644
--- a/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/MapOfProducerProducer.java
@@ -20,7 +20,6 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.internal.Beta;
 import dagger.producers.Producer;
-import dagger.producers.monitoring.ProducerMonitor;
 import java.util.Map;
 
 import static com.google.common.base.Preconditions.checkNotNull;
@@ -55,7 +54,7 @@ private MapOfProducerProducer(ImmutableMap<K, Producer<V>> contributingMap) {
   }
 
   @Override
-  public ListenableFuture<Map<K, Producer<V>>> compute(ProducerMonitor unusedMonitor) {
+  public ListenableFuture<Map<K, Producer<V>>> compute() {
     return Futures.<Map<K, Producer<V>>>immediateFuture(contributingMap);
   }
 
diff --git a/producers/src/main/java/dagger/producers/internal/MapProducer.java b/producers/src/main/java/dagger/producers/internal/MapProducer.java
index 61b7cfdbd..6897959f7 100644
--- a/producers/src/main/java/dagger/producers/internal/MapProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/MapProducer.java
@@ -24,7 +24,6 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.internal.Beta;
 import dagger.producers.Producer;
-import dagger.producers.monitoring.ProducerMonitor;
 import java.util.List;
 import java.util.Map;
 
@@ -58,7 +57,7 @@ private MapProducer(Producer<Map<K, Producer<V>>> mapProducerProducer) {
   }
 
   @Override
-  public ListenableFuture<Map<K, V>> compute(ProducerMonitor unusedMonitor) {
+  public ListenableFuture<Map<K, V>> compute() {
     return Futures.transformAsync(
         mapProducerProducer.get(),
         new AsyncFunction<Map<K, Producer<V>>, Map<K, V>>() {
diff --git a/producers/src/main/java/dagger/producers/internal/Producers.java b/producers/src/main/java/dagger/producers/internal/Producers.java
index 499de2a50..17e5cb68a 100644
--- a/producers/src/main/java/dagger/producers/internal/Producers.java
+++ b/producers/src/main/java/dagger/producers/internal/Producers.java
@@ -22,7 +22,6 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
-import dagger.producers.monitoring.ProducerMonitor;
 import java.util.Set;
 import javax.inject.Provider;
 
@@ -96,7 +95,7 @@
     checkNotNull(provider);
     return new AbstractProducer<T>() {
       @Override
-      protected ListenableFuture<T> compute(ProducerMonitor unusedMonitor) {
+      protected ListenableFuture<T> compute() {
         return Futures.immediateFuture(provider.get());
       }
     };
diff --git a/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
index 39712fac6..390949993 100644
--- a/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetOfProducedProducer.java
@@ -21,8 +21,8 @@
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Produced;
 import dagger.producers.Producer;
-import dagger.producers.monitoring.ProducerMonitor;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
 import java.util.Set;
 import java.util.concurrent.ExecutionException;
@@ -40,69 +40,73 @@
  * @since 2.0
  */
 public final class SetOfProducedProducer<T> extends AbstractProducer<Set<Produced<T>>> {
-  public static <T> Producer<Set<T>> create() {
-    return SetProducer.create();
+  public static <T> Producer<Set<T>> empty() {
+    return SetProducer.empty();
   }
 
   /**
    * Constructs a new {@link Builder} for a {@link SetProducer} with {@code individualProducerSize}
-   * individual {@code Producer<T>} and {@code setProducerSize} {@code Producer<Set<T>>} instances.
+   * individual {@code Producer<T>} and {@code collectionProducerSize} {@code
+   * Producer<Collection<T>>} instances.
    */
-  public static <T> Builder<T> builder(int individualProducerSize, int setProducerSize) {
-    return new Builder<T>(individualProducerSize, setProducerSize);
+  public static <T> Builder<T> builder(int individualProducerSize, int collectionProducerSize) {
+    return new Builder<T>(individualProducerSize, collectionProducerSize);
   }
 
   /**
-   * A builder to accumulate {@code Producer<T>} and {@code Producer<Set<T>>} instances. These are
-   * only intended to be single-use and from within generated code. Do <em>NOT</em> add producers
-   * after calling {@link #build()}.
+   * A builder to accumulate {@code Producer<T>} and {@code Producer<Collection<T>>} instances.
+   * These are only intended to be single-use and from within generated code. Do <em>NOT</em> add
+   * producers after calling {@link #build()}.
    */
   public static final class Builder<T> {
     private final List<Producer<T>> individualProducers;
-    private final List<Producer<Set<T>>> setProducers;
+    private final List<Producer<Collection<T>>> collectionProducers;
 
-    private Builder(int individualProducerSize, int setProducerSize) {
+    private Builder(int individualProducerSize, int collectionProducerSize) {
       individualProducers = presizedList(individualProducerSize);
-      setProducers = presizedList(setProducerSize);
+      collectionProducers = presizedList(collectionProducerSize);
     }
 
-    public Builder<T> addProducer(Producer<T> individualProducer) {
+    @SuppressWarnings("unchecked")
+    public Builder<T> addProducer(Producer<? extends T> individualProducer) {
       assert individualProducer != null : "Codegen error? Null producer";
-      individualProducers.add(individualProducer);
+      individualProducers.add((Producer<T>) individualProducer);
       return this;
     }
 
-    public Builder<T> addSetProducer(Producer<Set<T>> multipleProducer) {
+    @SuppressWarnings("unchecked")
+    public Builder<T> addCollectionProducer(
+        Producer<? extends Collection<? extends T>> multipleProducer) {
       assert multipleProducer != null : "Codegen error? Null producer";
-      setProducers.add(multipleProducer);
+      collectionProducers.add((Producer<Collection<T>>) multipleProducer);
       return this;
     }
 
     public SetOfProducedProducer<T> build() {
       assert !hasDuplicates(individualProducers)
           : "Codegen error?  Duplicates in the producer list";
-      assert !hasDuplicates(setProducers)
+      assert !hasDuplicates(collectionProducers)
           : "Codegen error?  Duplicates in the producer list";
 
-      return new SetOfProducedProducer<T>(individualProducers, setProducers);
+      return new SetOfProducedProducer<T>(individualProducers, collectionProducers);
     }
   }
 
   private final List<Producer<T>> individualProducers;
-  private final List<Producer<Set<T>>> setProducers;
+  private final List<Producer<Collection<T>>> collectionProducers;
 
   private SetOfProducedProducer(
-      List<Producer<T>> individualProducers, List<Producer<Set<T>>> setProducers) {
+      List<Producer<T>> individualProducers, List<Producer<Collection<T>>> collectionProducers) {
     this.individualProducers = individualProducers;
-    this.setProducers = setProducers;
+    this.collectionProducers = collectionProducers;
   }
 
   /**
    * Returns a future {@link Set} of {@link Produced} values whose iteration order is that of the
    * elements given by each of the producers, which are invoked in the order given at creation.
    *
-   * <p>If any of the delegate sets, or any elements therein, are null, then that corresponding
-   * {@code Produced} element will fail with a NullPointerException.
+   * <p>If any of the delegate collections, or any elements therein, are null, then that
+   * corresponding {@code Produced} element will fail with a NullPointerException.
    *
    * <p>Canceling this future will attempt to cancel all of the component futures; but if any of the
    * delegate futures fail or are canceled, this future succeeds, with the appropriate failed
@@ -111,41 +115,42 @@ private SetOfProducedProducer(
    * @throws NullPointerException if any of the delegate producers return null
    */
   @Override
-  public ListenableFuture<Set<Produced<T>>> compute(ProducerMonitor unusedMonitor) {
-    List<ListenableFuture<Produced<Set<T>>>> futureProducedSets =
-        new ArrayList<ListenableFuture<Produced<Set<T>>>>(
-            individualProducers.size() + setProducers.size());
+  public ListenableFuture<Set<Produced<T>>> compute() {
+    List<ListenableFuture<? extends Produced<? extends Collection<T>>>> futureProducedCollections =
+        new ArrayList<ListenableFuture<? extends Produced<? extends Collection<T>>>>(
+            individualProducers.size() + collectionProducers.size());
     for (Producer<T> producer : individualProducers) {
-      // TODO(ronshapiro): Don't require individual productions to be added to a set just to be
-      // materialized into futureProducedSets.
-      futureProducedSets.add(
+      // TODO(ronshapiro): Don't require individual productions to be added to a collection just to
+      // be materialized into futureProducedCollections.
+      futureProducedCollections.add(
           Producers.createFutureProduced(
               Producers.createFutureSingletonSet(checkNotNull(producer.get()))));
     }
-    for (Producer<Set<T>> producer : setProducers) {
-      futureProducedSets.add(Producers.createFutureProduced(checkNotNull(producer.get())));
+    for (Producer<Collection<T>> producer : collectionProducers) {
+      futureProducedCollections.add(Producers.createFutureProduced(checkNotNull(producer.get())));
     }
 
     return Futures.transform(
-        Futures.allAsList(futureProducedSets),
-        new Function<List<Produced<Set<T>>>, Set<Produced<T>>>() {
+        Futures.allAsList(futureProducedCollections),
+        new Function<List<Produced<? extends Collection<T>>>, Set<Produced<T>>>() {
           @Override
-          public Set<Produced<T>> apply(List<Produced<Set<T>>> producedSets) {
+          public Set<Produced<T>> apply(
+              List<Produced<? extends Collection<T>>> producedCollections) {
             ImmutableSet.Builder<Produced<T>> builder = ImmutableSet.builder();
-            for (Produced<Set<T>> producedSet : producedSets) {
+            for (Produced<? extends Collection<T>> producedCollection : producedCollections) {
               try {
-                Set<T> set = producedSet.get();
-                if (set == null) {
+                Collection<T> collection = producedCollection.get();
+                if (collection == null) {
                   // TODO(beder): This is a vague exception. Can we somehow point to the failing
                   // producer? See the similar comment in the component writer about null
                   // provisions.
                   builder.add(
                       Produced.<T>failed(
                           new NullPointerException(
-                              "Cannot contribute a null set into a producer set binding when it's"
-                                  + " injected as Set<Produced<T>>.")));
+                              "Cannot contribute a null collection into a producer set binding when"
+                                  + " it's injected as Set<Produced<T>>.")));
                 } else {
-                  for (T value : set) {
+                  for (T value : collection) {
                     if (value == null) {
                       builder.add(
                           Produced.<T>failed(
diff --git a/producers/src/main/java/dagger/producers/internal/SetProducer.java b/producers/src/main/java/dagger/producers/internal/SetProducer.java
index b9189d29a..10e27e60f 100644
--- a/producers/src/main/java/dagger/producers/internal/SetProducer.java
+++ b/producers/src/main/java/dagger/producers/internal/SetProducer.java
@@ -20,8 +20,8 @@
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import dagger.producers.Producer;
-import dagger.producers.monitoring.ProducerMonitor;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
 import java.util.Set;
 
@@ -47,69 +47,73 @@
       };
 
   @SuppressWarnings({"unchecked", "rawtypes"}) // safe covariant cast
-  public static <T> Producer<Set<T>> create() {
+  public static <T> Producer<Set<T>> empty() {
     return (Producer) EMPTY_PRODUCER;
   }
 
   /**
    * Constructs a new {@link Builder} for a {@link SetProducer} with {@code individualProducerSize}
-   * individual {@code Producer<T>} and {@code setProducerSize} {@code Producer<Set<T>>} instances.
+   * individual {@code Producer<T>} and {@code collectionProducerSize} {@code
+   * Producer<Collection<T>>} instances.
    */
-  public static <T> Builder<T> builder(int individualProducerSize, int setProducerSize) {
-    return new Builder<T>(individualProducerSize, setProducerSize);
+  public static <T> Builder<T> builder(int individualProducerSize, int collectionProducerSize) {
+    return new Builder<T>(individualProducerSize, collectionProducerSize);
   }
 
   /**
-   * A builder to accumulate {@code Producer<T>} and {@code Producer<Set<T>>} instances. These are
-   * only intended to be single-use and from within generated code. Do <em>NOT</em> add producers
-   * after calling {@link #build()}.
+   * A builder to accumulate {@code Producer<T>} and {@code Producer<Collection<T>>} instances.
+   * These are only intended to be single-use and from within generated code. Do <em>NOT</em> add
+   * producers after calling {@link #build()}.
    */
   public static final class Builder<T> {
     private final List<Producer<T>> individualProducers;
-    private final List<Producer<Set<T>>> setProducers;
+    private final List<Producer<Collection<T>>> collectionProducers;
 
-    private Builder(int individualProducerSize, int setProducerSize) {
+    private Builder(int individualProducerSize, int collectionProducerSize) {
       individualProducers = presizedList(individualProducerSize);
-      setProducers = presizedList(setProducerSize);
+      collectionProducers = presizedList(collectionProducerSize);
     }
 
-    public Builder<T> addProducer(Producer<T> individualProducer) {
+    @SuppressWarnings("unchecked")
+    public Builder<T> addProducer(Producer<? extends T> individualProducer) {
       assert individualProducer != null : "Codegen error? Null producer";
-      individualProducers.add(individualProducer);
+      individualProducers.add((Producer<T>) individualProducer);
       return this;
     }
 
-    public Builder<T> addSetProducer(Producer<Set<T>> multipleProducer) {
+    @SuppressWarnings("unchecked")
+    public Builder<T> addCollectionProducer(
+        Producer<? extends Collection<? extends T>> multipleProducer) {
       assert multipleProducer != null : "Codegen error? Null producer";
-      setProducers.add(multipleProducer);
+      collectionProducers.add((Producer<Collection<T>>) multipleProducer);
       return this;
     }
 
     public SetProducer<T> build() {
       assert !hasDuplicates(individualProducers)
           : "Codegen error?  Duplicates in the producer list";
-      assert !hasDuplicates(setProducers)
+      assert !hasDuplicates(collectionProducers)
           : "Codegen error?  Duplicates in the producer list";
 
-      return new SetProducer<T>(individualProducers, setProducers);
+      return new SetProducer<T>(individualProducers, collectionProducers);
     }
   }
 
   private final List<Producer<T>> individualProducers;
-  private final List<Producer<Set<T>>> setProducers;
+  private final List<Producer<Collection<T>>> collectionProducers;
 
   private SetProducer(
-      List<Producer<T>> individualProducers, List<Producer<Set<T>>> setProducers) {
+      List<Producer<T>> individualProducers, List<Producer<Collection<T>>> collectionProducers) {
     this.individualProducers = individualProducers;
-    this.setProducers = setProducers;
+    this.collectionProducers = collectionProducers;
   }
 
   /**
    * Returns a future {@link Set} whose iteration order is that of the elements given by each of the
    * producers, which are invoked in the order given at creation.
    *
-   * <p>If any of the delegate sets, or any elements therein, are null, then this future will fail
-   * with a NullPointerException.
+   * <p>If any of the delegate collections, or any elements therein, are null, then this future will
+   * fail with a NullPointerException.
    *
    * <p>Canceling this future will attempt to cancel all of the component futures, and if any of the
    * delegate futures fails or is canceled, this one is, too.
@@ -117,37 +121,32 @@ private SetProducer(
    * @throws NullPointerException if any of the delegate producers return null
    */
   @Override
-  public ListenableFuture<Set<T>> compute(ProducerMonitor unusedMonitor) {
+  public ListenableFuture<Set<T>> compute() {
     List<ListenableFuture<T>> individualFutures =
         new ArrayList<ListenableFuture<T>>(individualProducers.size());
     for (Producer<T> producer : individualProducers) {
       individualFutures.add(checkNotNull(producer.get()));
     }
 
-    List<ListenableFuture<Set<T>>> futureSets =
-        new ArrayList<ListenableFuture<Set<T>>>(setProducers.size() + 1);
-    futureSets.add(
-        Futures.transform(
-            Futures.allAsList(individualFutures),
-            // TODO(ronshapiro): make static instances of these transformation functions
-            new Function<List<T>, Set<T>>() {
-              @Override
-              public Set<T> apply(List<T> list) {
-                return ImmutableSet.copyOf(list);
-              }
-            }));
-
-    for (Producer<Set<T>> producer : setProducers) {
-      futureSets.add(checkNotNull(producer.get()));
+    // Presize the list of collections produced by the amount of collectionProducers, with one more
+    // for the consolidate individualFutures from Futures.allAsList.
+    List<ListenableFuture<? extends Collection<T>>> futureCollections =
+        new ArrayList<ListenableFuture<? extends Collection<T>>>(collectionProducers.size() + 1);
+    futureCollections.add(Futures.allAsList(individualFutures));
+    for (Producer<Collection<T>> producer : collectionProducers) {
+      futureCollections.add(checkNotNull(producer.get()));
     }
-    return Futures.transform(Futures.allAsList(futureSets), new Function<List<Set<T>>, Set<T>>() {
-      @Override public Set<T> apply(List<Set<T>> sets) {
-        ImmutableSet.Builder<T> builder = ImmutableSet.builder();
-        for (Set<T> set : sets) {
-          builder.addAll(set);
-        }
-        return builder.build();
-      }
-    });
+    return Futures.transform(
+        Futures.allAsList(futureCollections),
+        new Function<List<Collection<T>>, Set<T>>() {
+          @Override
+          public Set<T> apply(List<Collection<T>> sets) {
+            ImmutableSet.Builder<T> builder = ImmutableSet.builder();
+            for (Collection<T> set : sets) {
+              builder.addAll(set);
+            }
+            return builder.build();
+          }
+        });
   }
 }
diff --git a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
index 8bb8b7574..5169a1bc2 100644
--- a/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/AbstractProducerTest.java
@@ -79,7 +79,7 @@ public void get_nullPointerException() {
           int i = 0;
 
           @Override
-          public ListenableFuture<Integer> compute(ProducerMonitor unusedMonitor) {
+          public ListenableFuture<Integer> compute() {
             return Futures.immediateFuture(i++);
           }
         };
@@ -144,7 +144,8 @@ public void monitor_null() throws Exception {
     }
 
     @Override
-    public ListenableFuture<T> compute(ProducerMonitor unusedMonitor) {
+    public ListenableFuture<T> compute() {
+      assertThat(monitor).isNotNull();
       return delegate;
     }
   }
diff --git a/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java b/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java
index 1f87a6f99..e92ef745e 100644
--- a/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/SetOfProducedProducerTest.java
@@ -40,7 +40,7 @@ public void success() throws Exception {
     Producer<Set<Produced<Integer>>> producer =
         SetOfProducedProducer.<Integer>builder(1, 1)
             .addProducer(Producers.immediateProducer(1))
-            .addSetProducer(Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(5, 7)))
+            .addCollectionProducer(Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(5, 7)))
             .build();
     assertThat(producer.get().get())
         .containsExactly(
@@ -54,7 +54,7 @@ public void failure() throws Exception {
     RuntimeException e = new RuntimeException("monkey");
     Producer<Set<Produced<Integer>>> producer =
         SetOfProducedProducer.<Integer>builder(1, 1)
-            .addSetProducer(Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)))
+            .addCollectionProducer(Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)))
             .addProducer(Producers.<Integer>immediateFailedProducer(e))
             .build();
     assertThat(producer.get().get())
@@ -79,7 +79,7 @@ public void delegateNpe() throws Exception {
   public void delegateSetNpe() throws Exception {
     Producer<Set<Produced<Integer>>> producer =
         SetOfProducedProducer.<Integer>builder(0, 1)
-            .addSetProducer(Producers.<Set<Integer>>immediateProducer(null))
+            .addCollectionProducer(Producers.<Set<Integer>>immediateProducer(null))
             .build();
     Results<Integer> results = Results.create(producer.get().get());
     assertThat(results.successes).isEmpty();
@@ -92,7 +92,7 @@ public void delegateSetNpe() throws Exception {
   public void delegateElementNpe() throws Exception {
     Producer<Set<Produced<Integer>>> producer =
         SetOfProducedProducer.<Integer>builder(0, 1)
-            .addSetProducer(
+            .addCollectionProducer(
                 Producers.<Set<Integer>>immediateProducer(Collections.<Integer>singleton(null)))
             .build();
     Results<Integer> results = Results.create(producer.get().get());
@@ -106,7 +106,7 @@ public void delegateElementNpe() throws Exception {
   public void oneOfDelegateElementNpe() throws Exception {
     Producer<Set<Produced<Integer>>> producer =
         SetOfProducedProducer.<Integer>builder(0, 1)
-            .addSetProducer(
+            .addCollectionProducer(
                 Producers.<Set<Integer>>immediateProducer(
                     Sets.newHashSet(Arrays.asList(5, 2, null))))
             .build();
diff --git a/producers/src/test/java/dagger/producers/internal/SetProducerTest.java b/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
index da250945e..9ad22daf1 100644
--- a/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
+++ b/producers/src/test/java/dagger/producers/internal/SetProducerTest.java
@@ -38,7 +38,7 @@ public void success() throws Exception {
     Producer<Set<Integer>> producer =
         SetProducer.<Integer>builder(1, 1)
             .addProducer(Producers.immediateProducer(1))
-            .addSetProducer(Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(5, 7)))
+            .addCollectionProducer(Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(5, 7)))
             .build();
     assertThat(producer.get().get()).containsExactly(1, 5, 7);
   }
@@ -62,7 +62,7 @@ public void delegateNpe() throws Exception {
   public void delegateSetNpe() throws Exception {
     Producer<Set<Integer>> producer =
         SetProducer.<Integer>builder(0, 1)
-            .addSetProducer(Producers.<Set<Integer>>immediateProducer(null))
+            .addCollectionProducer(Producers.<Set<Integer>>immediateProducer(null))
             .build();
     ListenableFuture<Set<Integer>> future = producer.get();
     try {
@@ -77,8 +77,8 @@ public void delegateSetNpe() throws Exception {
   public void delegateElementNpe() throws Exception {
     Producer<Set<Integer>> producer =
         SetProducer.<Integer>builder(0, 2)
-            .addSetProducer(Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)))
-            .addSetProducer(
+            .addCollectionProducer(Producers.<Set<Integer>>immediateProducer(ImmutableSet.of(1, 2)))
+            .addCollectionProducer(
                 Producers.<Set<Integer>>immediateProducer(Collections.<Integer>singleton(null)))
             .build();
     ListenableFuture<Set<Integer>> future = producer.get();
